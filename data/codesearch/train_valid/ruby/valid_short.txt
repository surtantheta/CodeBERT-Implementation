1<CODESPLIT>https://github.com/jamesarosen/wants/blob/e7c8ddfe3bf79aee6422685d22b26ce664452f02/lib/wants/mimeparse.rb#L76-L98<CODESPLIT>Wants.MIMEParse.fitness_and_quality_parsed<CODESPLIT>Find the best match for a given mime - type against a list of media_ranges that have already been parsed by #parse_media_range<CODESPLIT>def fitness_and_quality_parsed ( mime_type , parsed_ranges ) best_fitness = - 1 best_fit_q = 0 target_type , target_subtype , target_params = parse_media_range ( mime_type ) parsed_ranges . each do | type , subtype , params | if ( type == target_type or type == "*" or target_type == "*" ) and ( subtype == target_subtype or subtype == "*" or target_subtype == "*" ) param_matches = target_params . find_all { | k , v | k != "q" and params . has_key? ( k ) and v == params [ k ] } . length fitness = ( type == target_type ) ? 100 : 0 fitness += ( subtype == target_subtype ) ? 10 : 0 fitness += param_matches if fitness > best_fitness best_fitness = fitness best_fit_q = params [ "q" ] end end end [ best_fitness , best_fit_q . to_f ] end

1<CODESPLIT>https://github.com/sugaryourcoffee/syc-svpro/blob/a8f8b97283ee593b4e8d5092da46a1b0e39fc8e3/lib/sycsvpro/join.rb#L96-L130<CODESPLIT>Sycsvpro.Join.execute<CODESPLIT>Creates a Join which can be invoked as follows : call - seq : Sycsvpro :: Join . new ( infile : in . csv outfile : out . csv source : source . csv rows : 1 - eof cols : 0 1 pos : 2 3 joins : 2 = 1 headerless : true header : * insert_header : Company Phone ) . execute<CODESPLIT>def execute processed_header = headerless ? true : false File . open ( outfile , 'w' ) do | out | File . open ( infile ) . each_with_index do | line , index | line = line . chomp next if line . empty? line = unstring ( line ) . chomp unless processed_header header_line = header . process ( line ) out . puts header unless header_line . empty? processed_header = true next end next if row_filter . process ( line , row : index ) . nil? values = line . split ( ';' ) target = values . dup @positions . sort . each { | p | target . insert ( p , "" ) } @joiners . each do | joiner | key = values [ joiner . join [ 1 ] ] row = joiner . lookup [ :rows ] [ key ] || [ ] joiner . pos . each_with_index { | p , i | target [ p ] = row [ i ] } end out . puts target . join ( ';' ) end end end

1<CODESPLIT>https://github.com/zendesk/samlr/blob/521b5bfe4a35b6d72a780ab610dc7229294b2ea8/lib/samlr/request.rb#L27-L38<CODESPLIT>Samlr.Request.url<CODESPLIT>Utility method to get the full redirect destination Request#url ( https : // idp . example . com / saml { : RelayState = > https : // sp . example . com / saml } )<CODESPLIT>def url ( root , params = { } ) dest = root . dup dest << ( dest . include? ( "?" ) ? "&" : "?" ) dest << "#{type}=#{param}" params . each_pair do | key , value | dest << "&#{key}=#{CGI.escape(value.to_s)}" end dest end

1<CODESPLIT>https://github.com/kickstarter/amazon_flex_pay/blob/5a4cbc608b41858a2db2f6a44884aa4efee77c1e/lib/amazon_flex_pay/pipelines/base.rb#L15-L23<CODESPLIT>AmazonFlexPay::Pipelines.Base.to_param<CODESPLIT>Converts the Pipeline object into parameters and signs them .<CODESPLIT>def to_param params = to_hash . merge ( 'callerKey' => AmazonFlexPay . access_key , 'signatureVersion' => 2 , 'signatureMethod' => 'HmacSHA256' ) params [ 'signature' ] = AmazonFlexPay . sign ( AmazonFlexPay . pipeline_endpoint , params ) AmazonFlexPay :: Util . query_string ( params ) end

0<CODESPLIT>https://github.com/dmitrypol/redi_search_rails/blob/3f08a4a5a3c9e32c0d8b7007bc13a76cbc82d7e6/lib/redi_search_rails.rb#L195-L200<CODESPLIT>RediSearchRails.ClassMethods.ft_info<CODESPLIT>add all values for a model attribute to autocomplete<CODESPLIT>def ft_info REDI_SEARCH . call ( 'FT.INFO' , @index_name ) rescue Exception => e Rails . logger . error e if defined? Rails return e . message end

1<CODESPLIT>https://github.com/LynxEyes/bootstrap_admin/blob/f0f1b265a4f05bc65724c540b90a1f0425a772d8/lib/bootstrap_admin/responder.rb#L142-L148<CODESPLIT>BootstrapAdmin.Responder.format_resource<CODESPLIT>=============================================================================<CODESPLIT>def format_resource resource , format if resource . is_a? ( ActiveRecord :: Base ) and not resource . valid? resource . errors . send "to_#{format}" else resource . send "to_#{format}" end end

1<CODESPLIT>https://github.com/defunkt/choice/blob/16e9431519463a9aa22138c0a3d07fda11486847/lib/choice/parser.rb#L206-L214<CODESPLIT>Choice.Parser.arrayize_arguments<CODESPLIT>Turns trailing command line arguments into an array for an arrayed value<CODESPLIT>def arrayize_arguments ( args ) # Go through trailing arguments and suck them in if they don't seem # to have an owner. array = [ ] until args . empty? || args . first . match ( / / ) array << args . shift end array end

0<CODESPLIT>https://github.com/asceth/ruby_reportable/blob/07880afb9b2ee97f915d5afa3e42be1d9014c1eb/lib/ruby_reportable/report.rb#L275-L330<CODESPLIT>LifxToys.Sunrise.run<CODESPLIT>end def run<CODESPLIT>def run # pre-set light color to avoid green at low brightness @lights . set_color ( "brightness:#{start_brightness} kelvin:#{start_temperature}" , duration : 0 , power_on : false ) @lights . set_color ( "brightness:#{end_brightness}" , duration : half_sunrise_time ) sleep ( half_sunrise_time ) @lights . set_color ( "kelvin:#{end_temperature}" , duration : half_sunrise_time ) end

0<CODESPLIT>https://github.com/muffinista/chatterbot/blob/e98ebb4e23882a9aa078bc5f749a6d045c35e9be/lib/chatterbot/config.rb#L125-L137<CODESPLIT>Chatterbot.Config.slurp_file<CODESPLIT>given an array or object return the highest id we can find<CODESPLIT>def slurp_file ( f ) f = File . expand_path ( f ) tmp = { } if File . exist? ( f ) File . open ( f ) { | yf | tmp = YAML :: load ( yf ) } end tmp . symbolize_keys! unless tmp == false end

1<CODESPLIT>https://github.com/WinRb/Viewpoint/blob/e8fec4ab1af25fc128062cd96770afdb9fc38c68/lib/ews/soap/exchange_data_services.rb#L72-L88<CODESPLIT>Viewpoint::EWS::SOAP.ExchangeDataServices.get_item<CODESPLIT>Gets items from the Exchange store @see http : // msdn . microsoft . com / en - us / library / aa565934 ( v = EXCHG . 140 ) . aspx<CODESPLIT>def get_item ( opts ) opts = opts . clone [ :item_shape , :item_ids ] . each do | k | validate_param ( opts , k , true ) end req = build_soap! do | type , builder | if ( type == :header ) else builder . nbuild . GetItem { builder . nbuild . parent . default_namespace = @default_ns builder . item_shape! ( opts [ :item_shape ] ) builder . item_ids! ( opts [ :item_ids ] ) } end end do_soap_request ( req , response_class : EwsResponse ) end

0<CODESPLIT>https://github.com/jemmyw/Qif/blob/87fe5ba13b980617a8b517c3f49885c6ea1b3993/lib/qif/reader.rb#L80-L94<CODESPLIT>Qif.Transaction.to_s<CODESPLIT>Guess the file format of dates reading the beginning of file or return nil if no dates are found ( ?! ) .<CODESPLIT>def to_s ( format = 'dd/mm/yyyy' ) SUPPORTED_FIELDS . collect do | k , v | next unless current = instance_variable_get ( "@#{k}" ) field = v . keys . first case current . class . to_s when "Time" , "Date" , "DateTime" "#{field}#{DateFormat.new(format).format(current)}" when "Float" "#{field}#{'%.2f'%current}" when "String" current . split ( "\n" ) . collect { | x | "#{field}#{x}" } else "#{field}#{current}" end end . concat ( @splits . collect { | s | s . to_s } ) . flatten . compact . join ( "\n" ) end

1<CODESPLIT>https://github.com/monde/mms2r/blob/4b4419580a1eccb55cc1862795d926852d4554bd/lib/mms2r/media.rb#L512-L517<CODESPLIT>MMS2R.MMS2R::Media.msg_tmp_dir<CODESPLIT>Helper to temp_file to create a unique temporary directory that is a child of tmp_dir This version is based on the message_id of the mail .<CODESPLIT>def msg_tmp_dir @dir_count += 1 dir = File . expand_path ( File . join ( @media_dir , "#{@dir_count}" ) ) FileUtils . mkdir_p ( dir ) dir end

0<CODESPLIT>https://github.com/WinRb/Viewpoint/blob/e8fec4ab1af25fc128062cd96770afdb9fc38c68/lib/viewpoint/string_utils.rb#L52-L56<CODESPLIT>Viewpoint.StringUtils.iso8601_duration_to_seconds<CODESPLIT>Change a ruby_cased string to CamelCased<CODESPLIT>def iso8601_duration_to_seconds ( input ) return nil if input . nil? || input . empty? match_data = DURATION_RE . match ( input ) raise ( StringFormatException , "Invalid duration given" ) if match_data . nil? duration = 0 duration += match_data [ :weeks ] . to_i * 604800 duration += match_data [ :days ] . to_i * 86400 duration += match_data [ :hours ] . to_i * 3600 duration += match_data [ :minutes ] . to_i * 60 duration += match_data [ :seconds ] . to_i end

1<CODESPLIT>https://github.com/BlakeWilliams/Minican/blob/fa8903f235a1471fa357af48070ba68c94a731a6/lib/minican/controller_additions.rb#L33-L40<CODESPLIT>Minican.ControllerAdditions.filter_authorized!<CODESPLIT>Controller helper method to filter out non - authorized objects from the passed in array<CODESPLIT>def filter_authorized! ( method , objects , user = current_user ) object_array = Array ( objects ) object_array . select do | object | policy = policy_for ( object ) policy . can? ( method , user ) end end

1<CODESPLIT>https://github.com/robertodecurnex/spectro/blob/0c9945659e6eb00c7ff026a5065cdbd9a74f119f/lib/spectro/compiler.rb#L87-L92<CODESPLIT>Spectro.Compiler.missing_specs_from_file<CODESPLIT>Parse the specs on the given file path and return those that have not been fulfilled or need to be updated .<CODESPLIT>def missing_specs_from_file ( path ) Spectro :: Spec :: Parser . parse ( path ) . select do | spec | index_spec = Spectro :: Database . index [ path ] && Spectro :: Database . index [ path ] [ spec . signature . name ] index_spec . nil? || index_spec [ 'spec_md5' ] != spec . md5 end end

1<CODESPLIT>https://github.com/thechrisoshow/rtf/blob/d6455933262a25628006101be802d7f7b2c3feb7/lib/rtf/node.rb#L1005-L1012<CODESPLIT>RTF.TableCellNode.border_width=<CODESPLIT>This method assigns a width in twips for the borders on all sides of the cell . Negative widths will be ignored and a width of zero will switch the border off .<CODESPLIT>def border_width = ( width ) size = width . nil? ? 0 : width if size > 0 @borders [ TOP ] = @borders [ RIGHT ] = @borders [ BOTTOM ] = @borders [ LEFT ] = size . to_i else @borders = [ nil , nil , nil , nil ] end end

1<CODESPLIT>https://github.com/mattmueller/foursquare2/blob/0affc7d4bd5a3aea51e16782def38f589d16e60a/lib/foursquare2/campaigns.rb#L7-L12<CODESPLIT>Foursquare2.Campaigns.campaign<CODESPLIT>Retrieve information about a campaign<CODESPLIT>def campaign ( campaign_id , options = { } ) response = connection . get do | req | req . url "campaigns/#{campaign_id}" , options end return_error_or_body ( response , response . body . response . campaign ) end

1<CODESPLIT>https://github.com/thefrontiergroup/scoped_attr_accessible/blob/7f70825f8eb76be95f499045a0d27028d74f8321/lib/scoped_attr_accessible/sanitizer.rb#L16-L29<CODESPLIT>ScopedAttrAccessible.Sanitizer.normalize_scope<CODESPLIT>Looks up a scope name from the registered recognizers and then from the converters .<CODESPLIT>def normalize_scope ( object , context ) return object if object . is_a? ( Symbol ) # 1. Process recognizers, looking for a match. @scope_recognizers . each_pair do | name , recognizers | return name if recognizers . any? { | r | lambda ( r ) . call ( context , object ) } end # 2. Process converters, finding a result. @scope_converters . each do | converter | scope = lambda ( converter ) . call ( context , object ) return normalize_scope ( scope , converter ) unless scope . nil? end # 3. Fall back to default return :default end

1<CODESPLIT>https://github.com/obrie/turntabler/blob/e2240f1a5d210a33c05c5b2261d291089cdcf1c6/lib/turntabler/authorized_user.rb#L154-L157<CODESPLIT>Turntabler.AuthorizedUser.buddies<CODESPLIT>Loads the list of users that are connected to the current user through a social network like Facebook or Twitter .<CODESPLIT>def buddies data = api ( 'user.get_buddies' ) data [ 'buddies' ] . map { | id | User . new ( client , :_id => id ) } end

1<CODESPLIT>https://github.com/ElMassimo/journeyman/blob/09628f3e54395b642ed6d516ebe9f3a48e8c9000/lib/journeyman/definition.rb#L11-L20<CODESPLIT>Journeyman.Definition.define<CODESPLIT>Public : Defines a new factory for Journeyman which consists in a build and create method and may optionally include finder and default methods .<CODESPLIT>def define ( name , options = { } , & config ) finder , default = options . delete ( :include_finder ) , options . delete ( :include_default ) Builder . new ( name , options , config ) . tap do | builder | define_find_method ( name , builder ) unless finder == false define_build_method ( name , builder ) define_create_method ( name , builder ) define_default_method ( name ) if default end end

1<CODESPLIT>https://github.com/OregonDigital/metadata-ingest-form/blob/1d36b5a1380fe009cda797555883b1d258463682/lib/metadata/ingest/translators/form_to_attributes.rb#L60-L66<CODESPLIT>Metadata::Ingest::Translators.FormToAttributes.attribute_lookup<CODESPLIT>Extracts the attribute definition for a given association<CODESPLIT>def attribute_lookup ( assoc ) group_data = @map [ assoc . group . to_sym ] return nil unless group_data attribute = group_data [ assoc . type . to_sym ] return attribute end

1<CODESPLIT>https://github.com/winebarrel/ddbcli/blob/93829243d02193b7edb1b2244dfbfa3609a0475f/lib/ddbcli/ddb-client.rb#L227-L256<CODESPLIT>DynamoDB.Client.retry_query<CODESPLIT>def escape ( str ) CGI . escape ( str . to_s ) . gsub ( + %20 ) end<CODESPLIT>def retry_query retval = nil ( @retry_num + 1 ) . times do | i | begin retval = yield break rescue Errno :: ETIMEDOUT => e raise e if i >= @retry_num rescue DynamoDB :: Error => e if [ / \b \b /i , / \b \b /i ] . any? { | i | i =~ e . message } raise e if i >= @retry_num else raise e end rescue Timeout :: Error => e raise e if i >= @retry_num end wait_sec = @retry_intvl * ( i + 1 ) if @debug $stderr . puts ( "Retry... (wait %d seconds)" % wait_sec ) end sleep wait_sec end return retval end

0<CODESPLIT>https://github.com/nearapogee/simplec/blob/c1096505e0323aaf2f19a36c2ff05053a8f4062c/app/models/simplec/page.rb#L318-L325<CODESPLIT>Simplec.Page.extract_search_text<CODESPLIT>Set this instance as the #embeddable association on the Simplec :: EmbeddedImage<CODESPLIT>def extract_search_text ( * attributes ) Array ( attributes ) . map { | meth | Nokogiri :: HTML ( self . send ( meth ) ) . xpath ( "//text()" ) . map { | node | text = node . text ; text . try ( :strip! ) ; text } . join ( " " ) } . reject ( :blank? ) . join ( "\n" ) end

0<CODESPLIT>https://github.com/monde/mms2r/blob/4b4419580a1eccb55cc1862795d926852d4554bd/lib/mms2r/media.rb#L486-L489<CODESPLIT>MMS2R.MMS2R::Media.transform_text_part<CODESPLIT>Helper for process template method to name a temporary filepath based on information in the part . This version attempts to honor the name of the media as labeled in the part header and creates a unique temporary directory for writing the file so filename collision does not occur . Consumers of this method expect the directory structure to the file exists if the method is overridden it is mandatory that this behavior is retained .<CODESPLIT>def transform_text_part ( part ) type = part . part_type? text = part . body . decoded . strip transform_text ( type , text ) end

0<CODESPLIT>https://github.com/googleads/google-api-ads-ruby/blob/bf8ede5dda838bbd6161f4eb7d66b4654ae6e46b/ads_common/lib/ads_common/api.rb#L190-L210<CODESPLIT>AdsCommon.Api.prepare_wrapper<CODESPLIT>Auxiliary method to create an authentication handler .<CODESPLIT>def prepare_wrapper ( version , service ) api_config . do_require ( version , service ) endpoint = api_config . endpoint ( version , service ) interface_class_name = api_config . interface_name ( version , service ) wrapper = class_for_path ( interface_class_name ) . new ( @config , endpoint ) auth_handler = get_auth_handler ( ) header_ns = api_config . config ( :header_ns ) + version . to_s soap_handler = soap_header_handler ( auth_handler , version , header_ns , wrapper . namespace ) wrapper . header_handler = soap_handler return wrapper end

0<CODESPLIT>https://github.com/campaignmonitor/createsend-ruby/blob/8ef7eb1a048363e3557dedbb2e666c4e5b1ccbe5/lib/createsend/list.rb#L118-L122<CODESPLIT>CreateSend.List.segments<CODESPLIT>Gets the active subscribers for this list .<CODESPLIT>def segments response = get "segments" response . map { | item | Hashie :: Mash . new ( item ) } end

0<CODESPLIT>https://github.com/boazsegev/plezi/blob/8f6b1a4e7874746267751cfaa71db7ad3851993a/lib/plezi/render/render.rb#L33-L37<CODESPLIT>Plezi.Controller.requested_method<CODESPLIT>Attempts to render the requested file ( i . e . index . html ) using all known rendering handlers .<CODESPLIT>def requested_method params [ '_method' . freeze ] = ( params [ '_method' . freeze ] || request . request_method . downcase ) . to_sym self . class . _pl_params2method ( params , request . env ) end

1<CODESPLIT>https://github.com/CoralineAda/mir_extensions/blob/640c0807afe2015b7912ab3dd90fcd1aa7ad07a3/lib/mir_extensions.rb#L102-L118<CODESPLIT>MirExtensions.HelperExtensions.crud_links_for_nested_resource<CODESPLIT>Display CRUD icons or links according to setting in use_crud_icons method . This method works with nested resources . Use in index views like this :<CODESPLIT>def crud_links_for_nested_resource ( model , nested_model , model_instance_name , nested_model_instance_name , actions , args = { } ) _html = "" if use_crud_icons if actions . include? ( :show ) _html << eval ( "link_to image_tag('/images/icons/view.png', :class => 'crud_icon'), #{model_instance_name}_#{nested_model_instance_name}_path(model, nested_model), :title => 'View'" ) end if actions . include? ( :edit ) _html << eval ( "link_to image_tag('/images/icons/edit.png', :class => 'crud_icon'), edit_#{model_instance_name}_#{nested_model_instance_name}_path(model, nested_model), :title => 'Edit'" ) end if actions . include? ( :delete ) _html << eval ( "link_to image_tag('/images/icons/delete.png', :class => 'crud_icon'), #{model_instance_name}_#{nested_model_instance_name}_path(model, nested_model), :method => :delete, :confirm => 'Are you sure? This action cannot be undone.', :title => 'Delete'" ) end end _html end

1<CODESPLIT>https://github.com/a14m/EGP-Rates/blob/ebb960c8cae62c5823aef50bb4121397276c7af6/lib/egp_rates/edbe.rb#L44-L54<CODESPLIT>EGPRates.EDBE.parse<CODESPLIT>Parse the #raw_exchange_rates returned in response<CODESPLIT>def parse ( raw_data ) raw_data . each_with_object ( sell : { } , buy : { } ) do | row , result | next unless row . name [ 3 ] == 'B' currency = row . name [ 0 .. 2 ] . to_sym action = row . name [ 4 .. - 1 ] . to_sym action_rate = row . value . to_f action_rate = ( action_rate * 100 ) . round ( 4 ) if currency == :JPY result [ action ] [ currency ] = action_rate end end

1<CODESPLIT>https://github.com/muffinista/chatterbot/blob/e98ebb4e23882a9aa078bc5f749a6d045c35e9be/lib/chatterbot/dsl.rb#L374-L381<CODESPLIT>Chatterbot.DSL.exclude<CODESPLIT>specify list of strings we will check when deciding to respond to a tweet or not . accepts an array or a comma - delimited string . when called any subsequent calls to search or replies will filter out tweets with these strings<CODESPLIT>def exclude ( * args ) e = flatten_list_of_strings ( args ) if e . nil? || e . empty? bot . exclude = [ ] else bot . exclude += e end end

1<CODESPLIT>https://github.com/interagent/pliny/blob/8add57f22e7be9404334222bbe7095af83bb8607/lib/pliny/config_helpers.rb#L44-L50<CODESPLIT>Pliny.CastingConfigHelpers.array<CODESPLIT>optional : accronyms array ( string ) = > [ a b ] optional : numbers array ( int ) = > [ 1 2 ] optional : notype array = > [ a b ]<CODESPLIT>def array ( method = nil ) -> ( v ) do if v v . split ( "," ) . map { | a | cast ( a , method ) } end end end

1<CODESPLIT>https://github.com/ManageIQ/active_bugzilla/blob/3672da87bc25ce057978cf8fed9688670c09a50a/lib/active_bugzilla/service.rb#L107-L116<CODESPLIT>ActiveBugzilla.Service.get<CODESPLIT>http : // www . bugzilla . org / docs / 4 . 4 / en / html / api / Bugzilla / WebService / Bug . html#get XMLRPC Bug Query of an existing bug<CODESPLIT>def get ( bug_ids , params = { } ) bug_ids = Array ( bug_ids ) raise ArgumentError , "bug_ids must be all Numeric" unless bug_ids . all? { | id | id . to_s =~ / \d / } params [ :ids ] = bug_ids results = execute ( 'Bug.get' , params ) [ 'bugs' ] return [ ] if results . nil? results end

0<CODESPLIT>https://github.com/seblindberg/ruby-linked/blob/ea4e7ee23a26db599b48b0e32c0c1ecf46adf682/lib/linked/list_enumerable.rb#L46-L53<CODESPLIT>Linked.ListEnumerable.last<CODESPLIT>Access the first n item ( s ) in the list .<CODESPLIT>def last ( n = nil ) return empty? ? nil : list_tail unless n raise ArgumentError , 'n cannot be negative' if n . negative? return [ ] if n . zero? || empty? list_tail . take ( - n ) end

1<CODESPLIT>https://github.com/jemmyw/Qif/blob/87fe5ba13b980617a8b517c3f49885c6ea1b3993/lib/qif/reader.rb#L80-L94<CODESPLIT>Qif.Reader.guess_date_format<CODESPLIT>Guess the file format of dates reading the beginning of file or return nil if no dates are found ( ?! ) .<CODESPLIT>def guess_date_format begin line = @data . gets break if line . nil? date = line [ 1 .. - 1 ] guessed_format = Qif :: DateFormat :: SUPPORTED_DATEFORMAT . find { | format_string , format | test_date_with_format? ( date , format_string , format ) } end until guessed_format @data . rewind guessed_format ? guessed_format . first : @fallback_format end

1<CODESPLIT>https://github.com/dark-panda/geos-extensions/blob/59b4b84bbed0d551b696dbea909f26f8aca50498/lib/geos/coordinate_sequence.rb#L48-L66<CODESPLIT>Geos.CoordinateSequence.as_json<CODESPLIT>Returns a Hash suitable for converting to JSON .<CODESPLIT>def as_json ( options = { } ) options = { :encoded => true , :level => 3 } . merge options if options [ :encoded ] { :type => 'lineString' , :encoded => true } . merge ( Geos :: GoogleMaps :: PolylineEncoder . encode ( self . to_a , options [ :level ] ) ) else { :type => 'lineString' , :encoded => false , :points => self . to_a } end end

0<CODESPLIT>https://github.com/trailblazer/roar/blob/2dcc627c4884cd87619c321bc98edeb1c5549093/lib/roar/hypermedia.rb#L51-L56<CODESPLIT>Spidr.Page.to_absolute<CODESPLIT>Create hypermedia links for this instance by invoking their blocks . This is called in links : getter : {} .<CODESPLIT>def to_absolute ( link ) link = link . to_s new_url = begin url . merge ( link ) rescue Exception return end if ( ! new_url . opaque ) && ( path = new_url . path ) # ensure that paths begin with a leading '/' for URI::FTP if ( new_url . scheme == 'ftp' && ! path . start_with? ( '/' ) ) path . insert ( 0 , '/' ) end # make sure the path does not contain any .. or . directories, # since URI::Generic#merge cannot normalize paths such as # "/stuff/../" new_url . path = URI . expand_path ( path ) end return new_url end

0<CODESPLIT>https://github.com/mattmueller/foursquare2/blob/0affc7d4bd5a3aea51e16782def38f589d16e60a/lib/foursquare2/users.rb#L52-L61<CODESPLIT>Foursquare2.Users.user_requests<CODESPLIT>Search for users by tip<CODESPLIT>def user_requests ( options = { } ) response = connection . get do | req | req . url "users/requests" , options end return_error_or_body ( response , response . body . response . requests ) end

0<CODESPLIT>https://github.com/WinRb/Viewpoint/blob/e8fec4ab1af25fc128062cd96770afdb9fc38c68/lib/ews/types/generic_folder.rb#L186-L213<CODESPLIT>Viewpoint::EWS::Types.GenericFolder.search_by_subject<CODESPLIT>Syncronize Items in this folder . If this method is issued multiple times it will continue where the last sync completed .<CODESPLIT>def search_by_subject ( match_str , exclude_str = nil ) items do | obj | match = { :contains => { :containment_mode => 'Substring' , :containment_comparison => 'IgnoreCase' , :field_uRI => { :field_uRI => 'item:Subject' } , :constant => { :value => match_str } } } unless exclude_str . nil? excl = { :not => { :contains => { :containment_mode => 'Substring' , :containment_comparison => 'IgnoreCase' , :field_uRI => { :field_uRI => 'item:Subject' } , :constant => { :value => exclude_str } } } } match [ :and ] = [ { :contains => match . delete ( :contains ) } , excl ] end obj . restriction = match end end

0<CODESPLIT>https://github.com/jpmckinney/pupa-ruby/blob/cb1485a42c1ee1a81cdf113a3199ad2993a45db1/lib/pupa/runner.rb#L48-L131<CODESPLIT>Ruby.Program.line_pos<CODESPLIT>Returns the command - line option parser .<CODESPLIT>def line_pos ( row ) ( row > 0 ? src . split ( "\n" ) [ 0 .. ( row - 1 ) ] . inject ( 0 ) { | pos , line | pos + line . length + 1 } : 0 ) end

1<CODESPLIT>https://github.com/ManageIQ/inventory_refresh/blob/8367841fd967a8294385d57f4b20891ff9b0958f/lib/inventory_refresh/inventory_object.rb#L96-L118<CODESPLIT>InventoryRefresh.InventoryObject.assign_attributes<CODESPLIT>Given hash of attributes we assign them to InventoryObject object using its public writers<CODESPLIT>def assign_attributes ( attributes ) attributes . each do | k , v | # We don't want timestamps or resource versions to be overwritten here, since those are driving the conditions next if %i( resource_timestamps resource_timestamps_max resource_timestamp ) . include? ( k ) next if %i( resource_counters resource_counters_max resource_counter ) . include? ( k ) if data [ :resource_timestamp ] && attributes [ :resource_timestamp ] assign_only_newest ( :resource_timestamp , :resource_timestamps , attributes , data , k , v ) elsif data [ :resource_counter ] && attributes [ :resource_counter ] assign_only_newest ( :resource_counter , :resource_counters , attributes , data , k , v ) else public_send ( "#{k}=" , v ) end end if attributes [ :resource_timestamp ] assign_full_row_version_attr ( :resource_timestamp , attributes , data ) elsif attributes [ :resource_counter ] assign_full_row_version_attr ( :resource_counter , attributes , data ) end self end

0<CODESPLIT>https://github.com/rbialek/rack-tidy/blob/fb563cd33da97a3f852c1a7fa0a5fcb51ccbe2c5/lib/rack/tidy/cleaner.rb#L34-L49<CODESPLIT>Scribble.Registry.for<CODESPLIT>thread safe version using shallow copy of env<CODESPLIT>def for * classes , & proc classes . each { | receiver_class | ForClassContext . new ( self , receiver_class ) . instance_eval proc } end

0<CODESPLIT>https://github.com/postmodern/spidr/blob/ae885272619f74c69d43ec77852f158768c6d804/lib/spidr/agent.rb#L712-L738<CODESPLIT>Spidr.Agent.prepare_request<CODESPLIT>Prepares request headers for the given URL .<CODESPLIT>def prepare_request ( url , & block ) path = unless url . path . empty? url . path else '/' end # append the URL query to the path path += "?#{url.query}" if url . query headers = prepare_request_headers ( url ) begin sleep ( @delay ) if @delay > 0 yield @sessions [ url ] , path , headers rescue SystemCallError , Timeout :: Error , SocketError , IOError , OpenSSL :: SSL :: SSLError , Net :: HTTPBadResponse , Zlib :: Error @sessions . kill! ( url ) failed ( url ) return nil end end

0<CODESPLIT>https://github.com/caruby/tissue/blob/08d99aabf4801c89842ce6dee138ccb1e4f5f56b/lib/catissue/database.rb#L503-L512<CODESPLIT>CaTissue.Database.save_changed_dependents<CODESPLIT>Ensures that a primary annotation hook exists .<CODESPLIT>def save_changed_dependents ( obj ) if CaTissue :: Specimen === obj then dsp = obj . specimen_events . detect { | ep | CaTissue :: DisposalEventParameters === ep } end if dsp then obj . specimen_events . delete ( dsp ) logger . debug { "Work around a caTissue #{obj.qp} event parameters save order dependency by deferring the #{dsp.qp} save..." } obj . specimen_events . delete ( dsp ) end # Delegate to the standard save_changed_dependents. begin super ensure obj . specimen_events << dsp if dsp end # Save the deferred disposal, if any. if dsp then logger . debug { "Creating deferred #{obj.qp} dependent #{dsp.qp}..." } save_dependent_if_changed ( obj , :specimen_events , dsp ) if obj . activity_status != 'Closed' then logger . debug { "Refetching the disposed #{obj.qp} to reflect the modified activity status..." } obj . activity_status = nil obj . find end end end

1<CODESPLIT>https://github.com/contentful/contentful.rb/blob/bdf5ca61f99ee8b8bfa449ab5ba22b7698f607f7/lib/contentful/client.rb#L295-L301<CODESPLIT>Contentful.Client.request_headers<CODESPLIT>Returns the headers used for the HTTP requests<CODESPLIT>def request_headers headers = { 'X-Contentful-User-Agent' => contentful_user_agent } headers [ 'Authorization' ] = "Bearer #{configuration[:access_token]}" if configuration [ :authentication_mechanism ] == :header headers [ 'Content-Type' ] = "application/vnd.contentful.delivery.v#{configuration[:api_version].to_i}+json" if configuration [ :api_version ] headers [ 'Accept-Encoding' ] = 'gzip' if configuration [ :gzip_encoded ] headers end

1<CODESPLIT>https://github.com/ytti/oxidized/blob/0cf095b01612c30a635a6c26843f02af20631823/lib/oxidized/output/gitcrypt.rb#L127-L136<CODESPLIT>Oxidized.GitCrypt.get_version<CODESPLIT>give the blob of a specific revision<CODESPLIT>def get_version ( node , group , oid ) repo , path = yield_repo_and_path ( node , group ) repo = Git . open repo unlock repo repo . gtree ( oid ) . files [ path ] . contents rescue StandardError 'version not found' ensure lock repo end

0<CODESPLIT>https://github.com/caruby/tissue/blob/08d99aabf4801c89842ce6dee138ccb1e4f5f56b/lib/catissue/database/controlled_values.rb#L48-L56<CODESPLIT>CaTissue.Person.name=<CODESPLIT>Returns the CV with the given public_id_or_alias and value . Loads the CV if necessary from the database . The loaded CV does not have a parent or children .<CODESPLIT>def name = ( value ) value = Name . parse ( value ) if String === value # a missing name is equivalent to an empty name for our purposes here value = Name . new ( nil , nil ) if value . nil? unless Name === value then raise ArgumentError . new ( "Name argument type invalid; expected <#{Name}>, found <#{value.class}>" ) end self . first_name = value . first self . last_name = value . last self . middle_name = value . middle if respond_to? ( :middle_name ) end

1<CODESPLIT>https://github.com/janko/image_processing/blob/4b4917d88bab1f73ebdc733f8a583734322e5226/lib/image_processing/chainable.rb#L66-L78<CODESPLIT>ImageProcessing.Chainable.branch<CODESPLIT>Creates a new builder object merging current options with new options .<CODESPLIT>def branch ( loader : nil , saver : nil , operations : nil , ** other_options ) options = respond_to? ( :options ) ? self . options : DEFAULT_OPTIONS options = options . merge ( loader : options [ :loader ] . merge ( loader ) ) if loader options = options . merge ( saver : options [ :saver ] . merge ( saver ) ) if saver options = options . merge ( operations : options [ :operations ] + operations ) if operations options = options . merge ( processor : self :: Processor ) unless self . is_a? ( Builder ) options = options . merge ( other_options ) options . freeze Builder . new ( options ) end

1<CODESPLIT>https://github.com/bdwyertech/newrelic-management/blob/265f0024b52d1fed476f35448b6b518453b4b1a6/lib/newrelic-management/notifier.rb#L40-L42<CODESPLIT>NewRelicManagement.Notifier.osx_notification<CODESPLIT>= > OS X Cocoa Messages<CODESPLIT>def osx_notification ( message , subtitle , title ) TerminalNotifier . notify ( message , title : title , subtitle : subtitle ) end

1<CODESPLIT>https://github.com/modernistik/parse-stack/blob/23730f8faa20ff90d994cdb5771096c9a9a5bdff/lib/parse/model/push.rb#L170-L174<CODESPLIT>Parse.Push.send<CODESPLIT>helper method to send a message<CODESPLIT>def send ( message = nil ) @alert = message if message . is_a? ( String ) @data = message if message . is_a? ( Hash ) client . push ( payload . as_json ) end

1<CODESPLIT>https://github.com/WinRb/Viewpoint/blob/e8fec4ab1af25fc128062cd96770afdb9fc38c68/lib/ews/soap/builders/ews_builder.rb#L213-L221<CODESPLIT>Viewpoint::EWS::SOAP.EwsBuilder.distinguished_folder_id!<CODESPLIT>Build the DistinguishedFolderId element<CODESPLIT>def distinguished_folder_id! ( dfid , change_key = nil , act_as = nil ) attribs = { 'Id' => dfid . to_s } attribs [ 'ChangeKey' ] = change_key if change_key @nbuild [ NS_EWS_TYPES ] . DistinguishedFolderId ( attribs ) { if ! act_as . nil? mailbox! ( { :email_address => act_as } ) end } end

1<CODESPLIT>https://github.com/campaignmonitor/createsend-ruby/blob/8ef7eb1a048363e3557dedbb2e666c4e5b1ccbe5/lib/createsend/list.rb#L184-L187<CODESPLIT>CreateSend.List.webhooks<CODESPLIT>Gets the webhooks for this list .<CODESPLIT>def webhooks response = get "webhooks" response . map { | item | Hashie :: Mash . new ( item ) } end

0<CODESPLIT>https://github.com/kickstarter/amazon_flex_pay/blob/5a4cbc608b41858a2db2f6a44884aa4efee77c1e/lib/amazon_flex_pay/model.rb#L115-L132<CODESPLIT>AmazonFlexPay.Model.assign<CODESPLIT>Formats times and booleans as Amazon desires them .<CODESPLIT>def assign ( hash ) hash . each do | k , v | send ( "#{k.to_s.underscore}=" , v . respond_to? ( :strip ) ? v . strip : v ) end end

0<CODESPLIT>https://github.com/leesharma/rescuetime/blob/c69e6d41f31dbaf5053be51a1e45293605612f1e/lib/rescuetime/collection.rb#L93-L103<CODESPLIT>Rescuetime.Collection.format<CODESPLIT>Parses a response from the string response body to the desired format .<CODESPLIT>def format ( format ) # Guard: fail if the passed format isn't on the whitelist format = format . to_s formatters . all . include? ( format ) || raise ( Errors :: InvalidFormatError ) @format = format self end

1<CODESPLIT>https://github.com/campaignmonitor/createsend-ruby/blob/8ef7eb1a048363e3557dedbb2e666c4e5b1ccbe5/lib/createsend/administrator.rb#L31-L41<CODESPLIT>CreateSend.Administrator.update<CODESPLIT>Updates the administator details .<CODESPLIT>def update ( new_email_address , name ) options = { :query => { :email => @email_address } , :body => { :EmailAddress => new_email_address , :Name => name } . to_json } put '/admins.json' , options # Update @email_address, so this object can continue to be used reliably @email_address = new_email_address end

0<CODESPLIT>https://github.com/bdwyertech/newrelic-management/blob/265f0024b52d1fed476f35448b6b518453b4b1a6/lib/newrelic-management/util.rb#L90-L99<CODESPLIT>NewRelicManagement.Util.filestring<CODESPLIT>= > Return Common Elements of an Array<CODESPLIT>def filestring ( file , size = 8192 ) return unless file return file unless file . is_a? ( String ) && File . file? ( file ) && File . size ( file ) <= size File . read ( file ) end

0<CODESPLIT>https://github.com/envygeeks/forwardable-extended/blob/7bde98630ff7990bc5807704b8e7538ec8676cd4/lib/forwardable/extended.rb#L135-L153<CODESPLIT>Forwardable.Extended.def_delegators<CODESPLIT>------------------------------------------------------------------------ Wraps around traditional delegation and modern delegation . ------------------------------------------------------------------------<CODESPLIT>def def_delegators ( accessor , * methods ) kwd = methods . shift if methods . first . is_a? ( Hash ) kwd = methods . pop if methods . last . is_a? ( Hash ) kwd = { } unless kwd methods . each do | method | def_delegator accessor , method , ** kwd end end

1<CODESPLIT>https://github.com/caruby/tissue/blob/08d99aabf4801c89842ce6dee138ccb1e4f5f56b/lib/catissue/domain/collection_protocol.rb#L147-L156<CODESPLIT>CaTissue.CollectionProtocol.add_defaults_local<CODESPLIT>Sets the defaults as follows : * The start date is set to now . * The title is set to the short title . * If there is no CP coordinator and there is exactly one site with a coordinator then the default CP coordinator is the site coordinator . * If there is no CP site and there is exactly one coordinator site then the default CP site is the coordinator site .<CODESPLIT>def add_defaults_local super self . start_date ||= Java :: JavaUtil :: Date . new if sites . empty? then add_default_site end if coordinators . empty? and sites . size == 1 then coord = sites . first . coordinator coordinators << coord if coord end make_default_collection_event unless events . detect { | evt | CollectionProtocolEvent === evt } end

1<CODESPLIT>https://github.com/knuedge/cratus/blob/a58465314a957db258f2c6bbda115c4be8ad0d83/lib/cratus/group.rb#L129-L171<CODESPLIT>Cratus.Group.all_members<CODESPLIT>provides a Hash of member users and groups rubocop : disable Metrics / AbcSize Metrics / MethodLength<CODESPLIT>def all_members # filters used to determine if each group member is a User or Group group_filter = "(objectClass=#{Cratus.config.group_objectclass})" user_filter = "(objectClass=#{Cratus.config.user_objectclass})" # The raw LDAP data (a list of DNs) raw_members = @raw_ldap_data [ Cratus . config . group_member_attribute ] # Somewhere to store users and groups as we gather them results = { users : [ ] , groups : [ ] } # Iterate over the members and provide a user or group raw_members . each do | member | user_result = Cratus :: LDAP . search ( user_filter , basedn : member , scope : 'object' , attrs : User . ldap_return_attributes ) if ! user_result . nil? && ! user_result . empty? results [ :users ] << User . new ( user_result . last [ User . ldap_dn_attribute . to_sym ] . last ) else group_result = Cratus :: LDAP . search ( group_filter , basedn : member , scope : 'object' , attrs : self . class . ldap_return_attributes ) unless group_result . nil? || group_result . empty? nested_group = Group . new ( group_result . last [ self . class . ldap_dn_attribute . to_sym ] . last ) results [ :groups ] << nested_group results [ :groups ] . concat ( nested_group . member_groups ) results [ :users ] . concat ( nested_group . members ) end end end # deliver the results results [ :groups ] . uniq! ( :name ) results [ :users ] . uniq! ( :username ) results end

0<CODESPLIT>https://github.com/ciconia/toughguy/blob/6d2aa40f16fc133b127ae5ca31db93d7bee3fd98/lib/toughguy/query.rb#L121-L127<CODESPLIT>ToughGuy.Query.map<CODESPLIT>Extend the sort API to allow stuff like : sort ( : kind : stamp ) sort ( : kind : stamp . desc ) # see Symbol#desc below<CODESPLIT>def map ( key = nil , & block ) m = [ ] key ? each { | d | m << d [ key ] } : each { | d | m << block [ d ] } m end

0<CODESPLIT>https://github.com/contentful/contentful.rb/blob/bdf5ca61f99ee8b8bfa449ab5ba22b7698f607f7/lib/contentful/client.rb#L367-L379<CODESPLIT>Contentful.Client.do_build_resource<CODESPLIT>Runs request and parses Response<CODESPLIT>def do_build_resource ( response ) logger . debug ( response : response ) if logger configuration [ :resource_builder ] . new ( response . object , configuration . merge ( endpoint : response . request . endpoint ) , ( response . request . query || { } ) . fetch ( :locale , nil ) == '*' , 0 ) . run end

1<CODESPLIT>https://github.com/haraldmartin/things-rb/blob/1340b57dea2ffd81d52e74088c58ed0bd36abbc7/lib/things/focus.rb#L48-L65<CODESPLIT>Things.Focus.filter_tasks!<CODESPLIT>TODO : Smarter task filtering<CODESPLIT>def filter_tasks! ( options ) @tasks = @all_tasks . reject ( :children? ) [ :completed , :canceled ] . each do | filter | proc = Proc . new { | e | e . send ( "#{filter}?" ) } if options . key? ( filter ) if options [ filter ] @tasks = @tasks . select ( proc ) else @tasks = @tasks . reject ( proc ) end end end if tag = options [ :tag ] @tasks = @tasks . select { | t | t . tag? ( tag ) } end end

0<CODESPLIT>https://github.com/thechrisoshow/rtf/blob/d6455933262a25628006101be802d7f7b2c3feb7/lib/rtf/node.rb#L456-L464<CODESPLIT>RTF.CommandNode.strike<CODESPLIT>This method provides a short cut means of creating a superscript command node . The method accepts a block that will be passed a single parameter which will be a reference to the superscript node created . After the block is complete the superscript node is appended to the end of the child nodes on the object that the method is call against .<CODESPLIT>def strike style = CharacterStyle . new style . strike = true if block_given? apply ( style ) { | node | yield node } else apply ( style ) end end

0<CODESPLIT>https://github.com/kachick/validation/blob/43390cb6d9adc45c2f040d59f22ee514629309e6/lib/validation/condition.rb#L24-L34<CODESPLIT>Grenache.Base.announce<CODESPLIT>Condition Builders A innner method for some condition builders . For build conditions AND NAND OR NOR XOR XNOR .<CODESPLIT>def announce ( key , port , opts = { } , & block ) payload = [ key , port ] link . send 'announce' , payload , opts , block if config . auto_announce periodically ( config . auto_announce_interval ) do link . send 'announce' , payload , opts , block end end end

1<CODESPLIT>https://github.com/assaf/vanity/blob/5bdd3ab21d3e495fb6e3f2596d2a048c453ca27a/lib/vanity/commands/report.rb#L11-L20<CODESPLIT>Vanity.Render.render<CODESPLIT>Render the named template . Used for reporting and the dashboard .<CODESPLIT>def render ( path_or_options , locals = { } ) if path_or_options . respond_to? ( :keys ) render_erb ( path_or_options [ :file ] || path_or_options [ :partial ] , path_or_options [ :locals ] ) else render_erb ( path_or_options , locals ) end end

0<CODESPLIT>https://github.com/modernistik/parse-stack/blob/23730f8faa20ff90d994cdb5771096c9a9a5bdff/lib/parse/client.rb#L531-L534<CODESPLIT>Parse.Client.delete<CODESPLIT>Send a { Parse :: Request } object .<CODESPLIT>def delete ( uri , body = nil , headers = { } ) request :delete , uri , body : body , headers : headers end

1<CODESPLIT>https://github.com/jonathanpike/mako/blob/2aa3665ebf23f09727e59d667b34155755493bdf/lib/mako/core.rb#L53-L57<CODESPLIT>Mako.Core.log_configuration_information<CODESPLIT>Prints configuration file source and destination directory to STDOUT .<CODESPLIT>def log_configuration_information Mako . logger . info "Configuration File: #{Mako.config.config_file}" Mako . logger . info "Theme: #{Mako.config.theme}" Mako . logger . info "Destination: #{Mako.config.destination}" end

0<CODESPLIT>https://github.com/grgr/manage_cache/blob/f845b8e7fbcfe4dfccec26df412cd04d2326f945/lib/manage_cache.rb#L127-L137<CODESPLIT>ManageCache.LocalInstanceMethods.delete_cache<CODESPLIT>Opts added to cache_key_for will be suffixed to the rest of the cache_key . For these opts to take effect on cache management ( e . g . deletion ) use regexp : { opts_key : matcher_string .... } e . g . :<CODESPLIT>def delete_cache ( key_name ) [ cache_key_for ( key_name ) , "views/#{cache_key_for(key_name)}" ] . each do | key | Rails . cache . delete ( key ) end end

1<CODESPLIT>https://github.com/arusarka/mingle4r/blob/02cd31d074f959d05395e6165c12af66c4d90636/lib/mingle4r/common_class_methods.rb#L74-L78<CODESPLIT>Mingle4r.CommonClassMethods.find<CODESPLIT>def all_attributes_set? site && user && password end routes to active resource find<CODESPLIT>def find ( * args ) scope = args . slice! ( 0 ) options = args . slice! ( 0 ) || { } @resource_class . find ( scope , options ) end

0<CODESPLIT>https://github.com/jarrett/echo_uploads/blob/60eb0bd9c3d04dc13bf6ebbfa598492475102d77/lib/echo_uploads/file.rb#L39-L43<CODESPLIT>EchoUploads.File.persist!<CODESPLIT>Deletes the file on disk if and only if no other instances of EchoUpload :: File reference it .<CODESPLIT>def persist! ( attr , options ) unless ( file . is_a? ( ActionDispatch :: Http :: UploadedFile ) or file . is_a? ( Rack :: Test :: UploadedFile ) ) raise ( "Expected #file to be a ActionDispatch::Http::UploadedFile " + "or Rack::Test::UploadedFile, but was #{file.inspect}" ) end # Configure and save the metadata object. self . key = options [ :key ] . call file # Normally, this is .default_key_proc. self . owner_attr = attr self . original_extension = :: File . extname ( file . original_filename ) self . original_basename = :: File . basename ( file . original_filename , original_extension ) self . size = file . size compute_mime! options if options [ :storage ] . is_a? String self . storage_type = options [ :storage ] else self . storage_type = options [ :storage ] . name end save! # Write the file to the filestore. It's possible that #file is an instance of # EchoUploads::MappedFile, which is a subclass of # ActionDispatch::Http::UploadedFile. if file . is_a? ( ActionDispatch :: Http :: UploadedFile ) storage . write key , file . tempfile , self else storage . write key , file , self end # If we mapped the files, they were temporarily written to tmp/echo_uploads. # Delete them. if file . is_a? ( :: EchoUploads :: MappedFile ) and :: File . exists? ( file . path ) :: File . delete file . path end # Prune any expired temporary files. (Unless automatic pruning was turned off in # the app config.) unless ( Rails . configuration . echo_uploads . respond_to? ( :prune_tmp_files_on_upload ) and ! Rails . configuration . echo_uploads . prune_tmp_files_on_upload ) self . class . prune_temporary! end end

0<CODESPLIT>https://github.com/zhimin/rformspec/blob/756e89cb730b2ec25564c6243fdcd3e81bd93649/lib/rformspec/driver.rb#L100-L117<CODESPLIT>MkCoord.Trigonometric.compute_lambda<CODESPLIT>TODO : save as file dialog helper Try the operation up to specified timeout ( in seconds ) and sleep given interval ( in seconds ) . Error will be ignored until timeout Example try_for { click_link ( waiting ) } try_for ( 10 2 ) { click_button ( Search } # try to click the Search button upto 10 seconds try every 2 seconds try_for { click_button ( Search }<CODESPLIT>def compute_lambda ( alpha , delta , eps ) a = Math . sin ( delta ) * Math . sin ( eps ) + Math . cos ( delta ) * Math . sin ( alpha ) * Math . cos ( eps ) b = Math . cos ( delta ) * Math . cos ( alpha ) lambda = Math . atan2 ( a , b ) lambda %= PI2 if lambda < 0 return lambda rescue => e raise end

0<CODESPLIT>https://github.com/CocoaPods/CLAide/blob/896d82a4dff73d80da565b0caa77c6ed74c9c6f8/lib/claide/command.rb#L555-L562<CODESPLIT>GeoRuby.KmlParser.parse<CODESPLIT>Raises a Help exception if the -- help option is specified if argv still contains remaining arguments / options by the time it reaches this implementation or when called on an ‘abstract command’ .<CODESPLIT>def parse ( kml ) @factory . reset @with_z = false @parser = REXML :: Parsers :: PullParser . new ( kml ) while @parser . has_next? e = @parser . pull if e . start_element? if ( type = ELEMENT_MAP [ e [ 0 ] ] ) @factory . begin_geometry ( type ) else @buffer = '' if ( e [ 0 ] == 'coordinates' ) # clear the buffer accumulate_start ( e ) end elsif e . end_element? if ELEMENT_MAP [ e [ 0 ] ] @factory . end_geometry ( @with_z ) @buffer = '' # clear the buffer else accumulate_end ( e ) if ( e [ 0 ] == 'coordinates' ) parse_coordinates ( @buffer ) @buffer = '' # clear the buffer end end elsif e . text? accumulate_text ( e ) elsif e . cdata? accumulate_cdata ( e ) end end @factory . geometry . dup end

0<CODESPLIT>https://github.com/zhimin/rformspec/blob/756e89cb730b2ec25564c6243fdcd3e81bd93649/lib/rformspec/driver.rb#L51-L68<CODESPLIT>RFormSpec.Driver.open_file_dialog<CODESPLIT>wrapper of keyboard operations<CODESPLIT>def open_file_dialog ( title , filepath , text = "" ) wait_and_focus_window ( title ) dialog = RFormSpec :: OpenFileDialog . new ( title , text ) dialog . enter_filepath ( filepath ) sleep 1 dialog . click_open end

1<CODESPLIT>https://github.com/BlakeWilliams/Minican/blob/fa8903f235a1471fa357af48070ba68c94a731a6/lib/minican/controller_additions.rb#L16-L22<CODESPLIT>Minican.ControllerAdditions.authorize!<CODESPLIT>Controller helper method to verify call method on policy . Raises { Minican :: AccessDenied } if the policy method fails<CODESPLIT>def authorize! ( method , object , user = current_user ) policy = policy_for ( object ) if policy . cannot? ( method , current_user ) raise Minican :: AccessDenied . new ( policy ) end end

0<CODESPLIT>https://github.com/caruby/tissue/blob/08d99aabf4801c89842ce6dee138ccb1e4f5f56b/embed/ruby/catissue/embed/jbridge.rb#L18-L32<CODESPLIT>SeriesJoiner.ArrayAdditions.join_as_series<CODESPLIT>Creates a new annotation object in the caTissue database .<CODESPLIT>def join_as_series ( options = { } ) if defined? ( I18n ) default_delimiter = I18n . translate ( :' ' , :locale => options [ :locale ] ) default_final_delimiter = I18n . translate ( :' ' , :locale => options [ :locale ] ) default_conjunction = I18n . translate ( :' ' , :locale => options [ :locale ] ) else default_delimiter = ', ' default_final_delimiter = '' default_conjunction = ' and ' end delimiter = options [ :delimiter ] || default_delimiter final_delimiter = options [ :final_delimiter ] || default_final_delimiter conjunction = options [ :conjunction ] || default_conjunction sz = self . size if sz > 0 r = self [ 0 ] if sz > 1 if sz > 2 for i in 1 .. ( sz - 2 ) r += delimiter + self [ i ] end r += final_delimiter end r += conjunction + self [ sz - 1 ] end end return r end

1<CODESPLIT>https://github.com/caruby/tissue/blob/08d99aabf4801c89842ce6dee138ccb1e4f5f56b/lib/catissue/database.rb#L503-L512<CODESPLIT>CaTissue.Database.ensure_primary_annotation_has_hook<CODESPLIT>Ensures that a primary annotation hook exists .<CODESPLIT>def ensure_primary_annotation_has_hook ( annotation ) hook = annotation . hook if hook . nil? then raise CaRuby :: DatabaseError . new ( "Cannot save annotation #{annotation} since it does not reference a hook entity" ) end if hook . identifier . nil? then logger . debug { "Ensuring that the annotation #{annotation.qp} hook entity #{hook.qp} exists in the database..." } ensure_exists ( hook ) end end

0<CODESPLIT>https://github.com/dmlond/spreadsheet_agent/blob/8fb21508470c41a1100289f4b0b52847b6d52d79/lib/spreadsheet_agent/agent.rb#L268-L345<CODESPLIT>SpreadsheetAgent.Agent.get_entry<CODESPLIT>this call initiates a race resistant attempt to make sure that there is only 1 clear winner among N potential agents attempting to run the same goal on the same spreadsheet agent s cell<CODESPLIT>def get_entry this_entry = nil if @worksheet @worksheet . list . each do | this_row | keep_row = true @config [ 'key_fields' ] . keys . reject { | key_field | ! ( @config [ 'key_fields' ] [ key_field ] [ "required" ] ) && ! ( @keys [ key_field ] ) } . each do | key | break unless keep_row keep_row = ( this_row [ key ] == @keys [ key ] ) end if keep_row return this_row end end end end

1<CODESPLIT>https://github.com/bdwyertech/newrelic-management/blob/265f0024b52d1fed476f35448b6b518453b4b1a6/lib/newrelic-management/client.rb#L104-L110<CODESPLIT>NewRelicManagement.Client.get_server_id<CODESPLIT>= > Get a Server based on ID<CODESPLIT>def get_server_id ( server_id ) return nil unless server_id =~ / / ret = nr_api . get ( url ( 'servers' , server_id ) ) . body ret [ 'server' ] rescue Faraday :: ResourceNotFound , NoMethodError nil end

0<CODESPLIT>https://github.com/piotrmurach/benchmark-trend/blob/7f565cb6a09667b4e7cf7d7741b5a604076b447e/lib/benchmark/trend.rb#L206-L243<CODESPLIT>Benchmark.Trend.fit_at<CODESPLIT>Fit the performance measurements to construct a model with slope and intercept parameters that minimize the error .<CODESPLIT>def fit_at ( type , slope : nil , intercept : nil , n : nil ) raise ArgumentError , "Incorrect input size: #{n}" unless n > 0 case type when :logarithmic , :log intercept + slope * Math . log ( n ) when :linear intercept + slope * n when :power intercept * ( n ** slope ) when :exponential , :exp intercept * ( slope ** n ) else raise ArgumentError , "Unknown fit type: #{type}" end end

1<CODESPLIT>https://github.com/campaignmonitor/createsend-ruby/blob/8ef7eb1a048363e3557dedbb2e666c4e5b1ccbe5/lib/createsend/createsend.rb#L173-L176<CODESPLIT>CreateSend.CreateSend.administrators<CODESPLIT>Gets the administrators for the account .<CODESPLIT>def administrators response = get ( '/admins.json' ) response . map { | item | Hashie :: Mash . new ( item ) } end

0<CODESPLIT>https://github.com/googleads/google-api-ads-ruby/blob/bf8ede5dda838bbd6161f4eb7d66b4654ae6e46b/ads_common/lib/ads_common/savon_service.rb#L237-L242<CODESPLIT>AdsCommon.SavonService.should_log_payloads<CODESPLIT>Check whether or not to log request summaries based on log level .<CODESPLIT>def should_log_payloads ( level , is_fault ) # Fault payloads log at INFO. return level <= Logger :: INFO if is_fault # Success payloads log at DEBUG. return level <= Logger :: DEBUG end

0<CODESPLIT>https://github.com/Undev/libftdi-ruby/blob/6fe45a1580df6db08324a237f56d2136fe721dcc/lib/ftdi.rb#L310-L318<CODESPLIT>Ftdi.Context.read_data_chunksize<CODESPLIT>Writes data .<CODESPLIT>def read_data_chunksize p = FFI :: MemoryPointer . new ( :uint , 1 ) check_result ( Ftdi . ftdi_read_data_get_chunksize ( ctx , p ) ) p . read_uint end

0<CODESPLIT>https://github.com/muffinista/chatterbot/blob/e98ebb4e23882a9aa078bc5f749a6d045c35e9be/lib/chatterbot/ui.rb#L30-L62<CODESPLIT>Chatterbot.UI.get_api_key<CODESPLIT>print out a message about getting a PIN from twitter then output the URL the user needs to visit to authorize<CODESPLIT>def get_api_key green "****************************************" green "****************************************" green "****        API SETUP TIME!         ****" green "****************************************" green "****************************************" puts "\n\nWelcome to Chatterbot. Let's walk through the steps to get a bot running.\n\n" # # At this point, we don't have any API credentials at all for # this bot, but it's possible the user has already setup an app. # Let's ask! # puts "Hey, looks like you need to get an API key from Twitter before you can get started.\n\n" app_already_exists = ask_yes_no ( "Have you already set up an app with Twitter?" ) if app_already_exists puts "Terrific! Let's get your bot running!\n\n" else puts "OK, I can help with that!\n\n" send_to_app_creation end print "\n\nPaste the 'Consumer Key' here: " STDOUT . flush config [ :consumer_key ] = STDIN . readline . chomp . strip print "Paste the 'Consumer Secret' here: " STDOUT . flush config [ :consumer_secret ] = STDIN . readline . chomp . strip puts "\n\nNow it's time to authorize your bot!\n\n" if ! app_already_exists && ask_yes_no ( "Do you want to authorize a bot using the account that created the app?" ) puts "OK, on the app page, you can click the 'Create my access token' button to proceed.\n\n" print "Paste the 'Access Token' here: " STDOUT . flush config [ :access_token ] = STDIN . readline . chomp . strip print "\n\nPaste the 'Access Token Secret' here: " STDOUT . flush config [ :access_token_secret ] = STDIN . readline . chomp . strip # reset the client so we can re-init with new OAuth credentials reset_client # at this point we should have a fully validated client, so grab # the screen name @screen_name = client . user . screen_name rescue nil else reset_client end # # capture ctrl-c and exit without a stack trace # rescue Interrupt => e exit end

1<CODESPLIT>https://github.com/nepalez/attributes_dsl/blob/f9032561629240c251cd86bf61c9a86618a8fef5/lib/attributes_dsl/attributes.rb#L30-L37<CODESPLIT>AttributesDSL.Attributes.add<CODESPLIT>Initializes the attribute from given arguments and returns new immutable collection with the attribute<CODESPLIT>def add ( name , options = { } , & coercer ) name = name . to_sym value = Attribute . new ( name , options , coercer ) clone_with do @attributes = attributes . merge ( name => value ) @transformer = nil end end

0<CODESPLIT>https://github.com/monde/mms2r/blob/4b4419580a1eccb55cc1862795d926852d4554bd/lib/mms2r/media.rb#L349-L372<CODESPLIT>MMS2R.MMS2R::Media.body<CODESPLIT>process is a template method and collects all the media in a MMS . Override helper methods to this template to clean out advertising and / or ignore media that are advertising . This method should not be overridden unless there is an extreme special case in processing the media of a MMS ( like Sprint )<CODESPLIT>def body text_file = default_text if RUBY_VERSION < "1.9" @body = text_file ? IO . read ( text_file . path ) . strip : "" require 'iconv' ic = Iconv . new ( 'UTF-8' , 'ISO-8859-1' ) @body = ic . iconv ( @body ) @body << ic . iconv ( nil ) ic . close else @body = text_file ? IO . read ( text_file . path , :mode => "rb" ) . strip : "" @body = @body . chars . select { | i | i . valid_encoding? } . join end if @body . blank? && html_file = default_html html = Nokogiri :: HTML ( IO . read ( html_file . path ) ) @body = ( html . xpath ( "//head/title" ) . map ( :text ) + html . xpath ( "//body/*" ) . map ( :text ) ) . join ( " " ) end @body end

1<CODESPLIT>https://github.com/assaf/vanity/blob/5bdd3ab21d3e495fb6e3f2596d2a048c453ca27a/lib/vanity/commands/report.rb#L41-L47<CODESPLIT>Vanity.Render.vanity_simple_format<CODESPLIT>Dumbed down from Rails simple_format .<CODESPLIT>def vanity_simple_format ( text , options = { } ) open = "<p #{options.map { |k,v| "#{k}=\"#{CGI.escapeHTML v}\"" }.join(" ")}>" text = open + text . gsub ( / \r \n / , "\n" ) . # \r\n and \r -> \n gsub ( / \n \n / , "</p>\n\n#{open}" ) . # 2+ newline  -> paragraph gsub ( / \n \n \n / , '\1<br />' ) + # 1 newline   -> br "</p>" end

1<CODESPLIT>https://github.com/thekompanee/pinpoint/blob/2aaf3c143b0c947a7339421c4e4fcc0b260c4d7b/lib/pinpoint/format.rb#L55-L59<CODESPLIT>Pinpoint.Format.output<CODESPLIT>Public : Will output any given address for the country defined in the Format .<CODESPLIT>def output ( address , options = { } ) requested_style = options . fetch ( :style , :one_line ) . to_sym styles [ requested_style ] . output ( address ) end

1<CODESPLIT>https://github.com/thechrisoshow/rtf/blob/d6455933262a25628006101be802d7f7b2c3feb7/lib/rtf/style.rb#L113-L131<CODESPLIT>RTF.CharacterStyle.prefix<CODESPLIT>This method generates a string containing the prefix associated with a style object .<CODESPLIT>def prefix ( fonts , colours ) text = StringIO . new text << '\b' if @bold text << '\i' if @italic text << '\ul' if @underline text << '\super' if @superscript text << '\caps' if @capitalise text << '\strike' if @strike text << '\sub' if @subscript text << '\v' if @hidden text << "\\cf#{colours.index(@foreground)}" if @foreground != nil text << "\\cb#{colours.index(@background)}" if @background != nil text << "\\f#{fonts.index(@font)}" if @font != nil text << "\\fs#{@font_size.to_i}" if @font_size != nil text << '\rtlch' if @flow == RIGHT_TO_LEFT text . string . length > 0 ? text . string : nil end

0<CODESPLIT>https://github.com/mmcclimon/mr_poole/blob/442404c64dd931185ddf2e2345ce2e76994c910f/lib/mr_poole/commands.rb#L74-L100<CODESPLIT>Luck.ANSIDriver.terminal_size<CODESPLIT>Todo make this take a path instead?<CODESPLIT>def terminal_size rows , cols = 25 , 80 buf = [ 0 , 0 , 0 , 0 ] . pack ( "SSSS" ) if $stdout . ioctl ( TIOCGWINSZ , buf ) >= 0 then rows , cols , row_pixels , col_pixels = buf . unpack ( "SSSS" ) end return [ rows , cols ] end

0<CODESPLIT>https://github.com/trimentor/session_captcha/blob/75ccb6b64c72d5087da984ac3ac87ca6c73c4c7e/lib/session_captcha/view.rb#L16-L26<CODESPLIT>EchoUploads.File.persist!<CODESPLIT>: nodoc Simple Captcha is a very simplified captcha .<CODESPLIT>def persist! ( attr , options ) unless ( file . is_a? ( ActionDispatch :: Http :: UploadedFile ) or file . is_a? ( Rack :: Test :: UploadedFile ) ) raise ( "Expected #file to be a ActionDispatch::Http::UploadedFile " + "or Rack::Test::UploadedFile, but was #{file.inspect}" ) end # Configure and save the metadata object. self . key = options [ :key ] . call file # Normally, this is .default_key_proc. self . owner_attr = attr self . original_extension = :: File . extname ( file . original_filename ) self . original_basename = :: File . basename ( file . original_filename , original_extension ) self . size = file . size compute_mime! options if options [ :storage ] . is_a? String self . storage_type = options [ :storage ] else self . storage_type = options [ :storage ] . name end save! # Write the file to the filestore. It's possible that #file is an instance of # EchoUploads::MappedFile, which is a subclass of # ActionDispatch::Http::UploadedFile. if file . is_a? ( ActionDispatch :: Http :: UploadedFile ) storage . write key , file . tempfile , self else storage . write key , file , self end # If we mapped the files, they were temporarily written to tmp/echo_uploads. # Delete them. if file . is_a? ( :: EchoUploads :: MappedFile ) and :: File . exists? ( file . path ) :: File . delete file . path end # Prune any expired temporary files. (Unless automatic pruning was turned off in # the app config.) unless ( Rails . configuration . echo_uploads . respond_to? ( :prune_tmp_files_on_upload ) and ! Rails . configuration . echo_uploads . prune_tmp_files_on_upload ) self . class . prune_temporary! end end

0<CODESPLIT>https://github.com/mnpopcenter/stats_package_syntax_file_generator/blob/014e23a69f9a647f20eaffcf9e95016f98d5c17e/lib/syntax_file/maker.rb#L86-L91<CODESPLIT>Ohm.Model.update_ttl<CODESPLIT>Helper methods for values and their labels .<CODESPLIT>def update_ttl new_ttl = nil # Load default if no new ttl is specified new_ttl = self . _default_expire if new_ttl . nil? # Make sure we have a valid value new_ttl = - 1 if ! new_ttl . to_i . is_a? ( Fixnum ) || new_ttl . to_i < 0 # Update indices Ohm . redis . expire ( self . key , new_ttl ) Ohm . redis . expire ( "#{self.key}:_indices" , new_ttl ) end

0<CODESPLIT>https://github.com/CoralineAda/mir_extensions/blob/640c0807afe2015b7912ab3dd90fcd1aa7ad07a3/lib/mir_extensions.rb#L68-L94<CODESPLIT>RenuoCmsRails.CmsHelper.cms_attributes<CODESPLIT>Display CRUD icons or links according to setting in use_crud_icons method .<CODESPLIT>def cms_attributes ( content_path ) config = RenuoCmsRails . config cms_attributes = { content_path : content_path , api_host : config . api_host_with_protocol , api_key : config . api_key } cms_attributes [ :private_api_key ] = config . private_api_key if cms_admin? cms_attributes end

1<CODESPLIT>https://github.com/sugaryourcoffee/syc-svpro/blob/a8f8b97283ee593b4e8d5092da46a1b0e39fc8e3/lib/sycsvpro/counter.rb#L143-L145<CODESPLIT>Sycsvpro.Counter.original_pivot_sequence_heading<CODESPLIT>Arrange heading in the original sequence regarding conditional column filters<CODESPLIT>def original_pivot_sequence_heading ( heading . sort - col_filter . pivot . keys << col_filter . pivot . keys ) . flatten end

1<CODESPLIT>https://github.com/zdavatz/spreadsheet/blob/0ab10ae72d0c04027168154d938fa9355e478d58/lib/spreadsheet/worksheet.rb#L130-L138<CODESPLIT>Spreadsheet.Worksheet.protect!<CODESPLIT>Set worklist protection<CODESPLIT>def protect! password = '' @protected = true password = password . to_s if password . size == 0 @password_hash = 0 else @password_hash = Excel :: Password . password_hash password end end

1<CODESPLIT>https://github.com/WinRb/Viewpoint/blob/e8fec4ab1af25fc128062cd96770afdb9fc38c68/lib/ews/soap/exchange_web_service.rb#L119-L127<CODESPLIT>Viewpoint::EWS::SOAP.ExchangeWebService.update_delegate<CODESPLIT>Updates delegate permissions on a principal s mailbox @see http : // msdn . microsoft . com / en - us / library / bb856529 . aspx<CODESPLIT>def update_delegate ( owner , delegate , permissions ) action = "#{SOAP_ACTION_PREFIX}/UpdateDelegate" resp = invoke ( "#{NS_EWS_MESSAGES}:UpdateDelegate" , action ) do | root | build! ( root ) do add_delegate! ( owner , delegate , permissions ) end end parse_soap_response ( resp ) end

1<CODESPLIT>https://github.com/metanorma/iso-bib-item/blob/205ef2b5e4ce626cf9b65f3c39f613825b10db03/lib/iso_bib_item/bibliographic_item.rb#L239-L262<CODESPLIT>IsoBibItem.BibliographicItem.to_xml<CODESPLIT>rubocop : disable Metrics / AbcSize Metrics / MethodLength<CODESPLIT>def to_xml Nokogiri :: XML :: Builder . new ( encoding : 'UTF-8' ) do | xml | xml . bibitem ( id : id ) do xml . fetched fetched title . each { | t | xml . title { t . to_xml xml } } link . each { | s | s . to_xml xml } docidentifier . each { | di | di . to_xml xml } dates . each { | d | d . to_xml xml , full_date : true } contributors . each do | c | xml . contributor do c . role . each { | r | r . to_xml xml } c . to_xml xml end end language . each { | l | xml . language l } script . each { | s | xml . script s } abstract . each { | a | xml . abstract { a . to_xml ( xml ) } } status . to_xml xml if status copyright . to_xml xml if copyright relations . each { | r | r . to_xml xml } series . each { | s | s . to_xml xml } if series end end . doc . root . to_xml end

1<CODESPLIT>https://github.com/googleads/google-api-ads-ruby/blob/bf8ede5dda838bbd6161f4eb7d66b4654ae6e46b/ads_savon/lib/ads_savon/client.rb#L133-L155<CODESPLIT>GoogleAdsSavon.Client.evaluate<CODESPLIT>Evaluates a given + block + inside + instance + . Stores the original block binding .<CODESPLIT>def evaluate ( instance , & block ) original_self = eval "self" , block . binding # A proxy that attemps to make method calls on +instance+. If a NoMethodError is # raised, the call will be made on +original_self+. proxy = Object . new proxy . instance_eval do class << self attr_accessor :original_self , :instance end def method_missing ( method , * args , & block ) instance . send ( method , args , block ) rescue NoMethodError original_self . send ( method , args , block ) end end proxy . instance = instance proxy . original_self = original_self proxy . instance_eval block end

1<CODESPLIT>https://github.com/barkerest/hidapi/blob/d4e8b7db3b0a742071b50fc282bdf8d7a3e062a7/lib/hidapi/device.rb#L193-L256<CODESPLIT>HIDAPI.Device.open<CODESPLIT>Opens the device .<CODESPLIT>def open if open? self . open_count += 1 if open_count < 1 HIDAPI . debug "open_count for open device #{path} is #{open_count}" self . open_count = 1 end return self end self . open_count = 0 begin self . handle = usb_device . open raise 'no handle returned' unless handle begin if handle . kernel_driver_active? ( interface ) handle . detach_kernel_driver ( interface ) end rescue LIBUSB :: ERROR_NOT_SUPPORTED HIDAPI . debug 'cannot determine kernel driver status, continuing to open device' end handle . claim_interface ( interface ) self . input_endpoint = self . output_endpoint = nil # now we need to find the endpoints. usb_device . settings . keep_if { | item | item . bInterfaceNumber == interface } . each do | intf_desc | intf_desc . endpoints . each do | ep | if ep . transfer_type == :interrupt if input_endpoint . nil? && ep . direction == :in self . input_endpoint = ep . bEndpointAddress self . input_ep_max_packet_size = ep . wMaxPacketSize end if output_endpoint . nil? && ep . direction == :out self . output_endpoint = ep . bEndpointAddress end end break if input_endpoint && output_endpoint end end # output_ep is optional, input_ep is required raise 'failed to locate input endpoint' unless input_endpoint # start the read thread self . input_reports = [ ] self . thread_initialized = false self . shutdown_thread = false self . thread = Thread . start ( self ) { | dev | dev . send ( :execute_read_thread ) } sleep 0.001 until thread_initialized rescue => e handle . close rescue nil self . handle = nil HIDAPI . debug "failed to open device #{path}: #{e.inspect}" raise DeviceOpenFailed , e . inspect end HIDAPI . debug "opened device #{path}" self . open_count = 1 self end

1<CODESPLIT>https://github.com/sugaryourcoffee/syc-svpro/blob/a8f8b97283ee593b4e8d5092da46a1b0e39fc8e3/lib/sycsvpro/join.rb#L159-L167<CODESPLIT>Sycsvpro.Join.col_positions<CODESPLIT>Initializes the column positions where the source file columns have to be inserted . If no column positions are provided the inserted columns are put at the beginning of the row<CODESPLIT>def col_positions ( pos , cols ) if pos . nil? || pos . empty? pos = [ ] cols . each { | c | pos << Array . new ( c . size ) { | c | c } } pos else pos . split ( ';' ) . collect { | p | p . split ( ',' ) . collect { | p | p . to_i } } end end

1<CODESPLIT>https://github.com/ozgg/plasper/blob/6dbca5fd7113522ecbfaced2a5ec4f0645486893/lib/Plasper/plasper.rb#L62-L69<CODESPLIT>Plasper.Plasper.sentence=<CODESPLIT>Analyze sentence<CODESPLIT>def sentence = ( sentence ) words = sentence . split ( / \s / ) add_weight :count , :word , words . length unless words . length < 1 words . each do | word | normalized_word = normalize_word word self . word = normalized_word unless normalized_word == '' end end

0<CODESPLIT>https://github.com/github/github-ldap/blob/34c2685bd07ae79c6283f14f1263d1276a162f28/lib/github/ldap.rb#L322-L332<CODESPLIT>GitHub.Ldap.configure_member_search_strategy<CODESPLIT>Internal : Set the user search strategy that will be used by Domain#user? .<CODESPLIT>def configure_member_search_strategy ( strategy = nil ) @member_search_strategy = case strategy . to_s when "classic" GitHub :: Ldap :: MemberSearch :: Classic when "recursive" GitHub :: Ldap :: MemberSearch :: Recursive when "active_directory" GitHub :: Ldap :: MemberSearch :: ActiveDirectory else # fallback to detection, defaulting to recursive strategy if active_directory_capability? GitHub :: Ldap :: MemberSearch :: ActiveDirectory else GitHub :: Ldap :: MemberSearch :: Recursive end end end

