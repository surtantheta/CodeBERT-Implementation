1<CODESPLIT>https://github.com/mojombo/god/blob/92c06aa5f6293cf26498a306e9bb7ac856d7dca0/lib/god/task.rb#L284-L309<CODESPLIT>God.Task.action<CODESPLIT>Perform the given action .<CODESPLIT>def action ( a , c = nil ) if ! self . driver . in_driver_context? # Called from outside Driver. Send an async message to Driver. self . driver . message ( :action , [ a , c ] ) else # Called from within Driver. if self . respond_to? ( a ) command = self . send ( a ) case command when String msg = "#{self.name} #{a}: #{command}" applog ( self , :info , msg ) system ( command ) when Proc msg = "#{self.name} #{a}: lambda" applog ( self , :info , msg ) command . call else raise NotImplementedError end end end end

1<CODESPLIT>https://github.com/epuber-io/epuber/blob/4d736deb3f18c034fc93fcb95cfb9bf03b63c252/lib/epuber/server/handlers.rb#L50-L55<CODESPLIT>Epuber.Server.handle_bade<CODESPLIT>@param [ String ] file_path path to bade file to render<CODESPLIT>def handle_bade ( file_path ) [ 200 , self . class . render_bade ( file_path ) ] rescue => e env [ 'sinatra.error' ] = e ShowExceptions . new ( self ) . call ( env ) end

0<CODESPLIT>https://github.com/meew0/discordrb/blob/764298a1ff0be69a1853b510d736f21c2b91a2fe/lib/discordrb/permissions.rb#L135-L147<CODESPLIT>Discordrb.User.await<CODESPLIT>Checks whether this user can do the particular action regardless of whether it has the permission defined through for example being the server owner or having the Manage Roles permission<CODESPLIT>def await ( key , attributes = { } , & block ) @bot . add_await ( key , Discordrb :: Events :: MessageEvent , { from : @id } . merge ( attributes ) , block ) end

1<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_container_registry/lib/2018-02-01-preview/generated/azure_mgmt_container_registry/registries.rb#L185-L188<CODESPLIT>Azure::ContainerRegistry::Mgmt::V2018_02_01_preview.Registries.begin_queue_build<CODESPLIT>Creates a new build based on the request parameters and add it to the build queue .<CODESPLIT>def begin_queue_build ( resource_group_name , registry_name , build_request , custom_headers : nil ) response = begin_queue_build_async ( resource_group_name , registry_name , build_request , custom_headers :custom_headers ) . value! response . body unless response . nil? end

0<CODESPLIT>https://github.com/tmm1/pygments.rb/blob/926d1adad88c22f92010a0f284d2dcc10213ec1e/lib/pygments/popen.rb#L436-L449<CODESPLIT>Pygments.Lexer.highlight<CODESPLIT>Convert a text header into JSON for easy access .<CODESPLIT>def highlight ( text , options = { } ) options [ :lexer ] = aliases . first Pygments . highlight ( text , options ) end

1<CODESPLIT>https://github.com/dicom/rtkit/blob/08248bf294769ae5b45ed4a9671f0620d5740252/lib/rtkit/bin_volume.rb#L194-L211<CODESPLIT>RTKIT.BinVolume.narray<CODESPLIT>Computes a hash code for this object .<CODESPLIT>def narray ( sort_slices = true ) if @bin_images . length > 0 # Determine the slice position of each BinImage: locations = Array . new if sort_slices @bin_images . collect { | image | locations << image . pos_slice } images = @bin_images . sort_by_order ( locations . sort_order ) else images = @bin_images end # Create volume array and fill in the images: volume = NArray . byte ( frames , columns , rows ) images . each_with_index do | sorted_image , i | volume [ i , true , true ] = sorted_image . narray end @narr = volume end end

1<CODESPLIT>https://github.com/lloeki/ruby-skyjam/blob/af435d56303b6a0790d299f4aa627d83c650a8b3/lib/skyjam/client.rb#L215-L240<CODESPLIT>SkyJam.Client.listtracks<CODESPLIT>MusicManager API<CODESPLIT>def listtracks ( continuation_token : nil ) oauth2_refresh_access_token if oauth2_access_token_expired? pb_body = MusicManager :: ExportTracksRequest . new pb_body . client_id = uploader_id pb_body . export_type = MusicManager :: ExportTracksRequest :: TrackType :: ALL pb_body . continuation_token = continuation_token unless continuation_token . nil? uri = URI ( 'https://music.google.com/music/exportids' ) http = Net :: HTTP . new ( uri . host , uri . port ) http . use_ssl = true req = Net :: HTTP :: Post . new ( uri . path ) req . body = pb_body . serialize_to_string req [ 'Content-Type' ] = 'application/x-google-protobuf' req [ 'Authorization' ] = oauth2_authentication_header req [ 'X-Device-ID' ] = uploader_id res = http . request ( req ) unless res . is_a? Net :: HTTPSuccess fail Error , 'listtracks failed: #{res.code}' end MusicManager :: ExportTracksResponse . new . parse_from_string ( res . body ) end

0<CODESPLIT>https://github.com/jinx/core/blob/964a274cc9d7ab74613910e8375e12ed210a434d/lib/jinx/import/class_path_modifier.rb#L17-L24<CODESPLIT>HornetQ::Client.MessageHandler.onMessage<CODESPLIT>Adds the directories in the given path and all Java jar files contained in the directories to the Java classpath .<CODESPLIT>def onMessage ( message ) begin if @message_count @message_count += 1 @last_time = Time . now end @proc . call message rescue SyntaxError , NameError => boom HornetQ :: logger . error "Unhandled Exception processing Message. Doesn't compile: " + boom HornetQ :: logger . error "Ignoring poison message:\n#{message.inspect}" HornetQ :: logger . error boom . backtrace . join ( "\n" ) rescue StandardError => bang HornetQ :: logger . error "Unhandled Exception processing Message. Doesn't compile: " + bang HornetQ :: logger . error "Ignoring poison message:\n#{message.inspect}" HornetQ :: logger . error boom . backtrace . join ( "\n" ) rescue => exc HornetQ :: logger . error "Unhandled Exception processing Message. Exception occurred:\n#{exc}" HornetQ :: logger . error "Ignoring poison message:\n#{message.inspect}" HornetQ :: logger . error exc . backtrace . join ( "\n" ) end end

1<CODESPLIT>https://github.com/cldwalker/hirb/blob/264f72c7c0f0966001e802414a5b0641036c7860/lib/hirb/dynamic_view.rb#L69-L81<CODESPLIT>Hirb.DynamicView.dynamic_options<CODESPLIT>Returns a hash of options based on dynamic views defined for the object s ancestry . If no config is found returns nil .<CODESPLIT>def dynamic_options ( obj ) view_methods . each do | meth | if obj . class . ancestors . map { | e | e . to_s } . include? ( method_to_class ( meth ) ) begin return send ( meth , obj ) rescue raise "View failed to generate for '#{method_to_class(meth)}' " + "while in '#{meth}' with error:\n#{$!.message}" end end end nil end

1<CODESPLIT>https://github.com/vizor-games/grably/blob/2f0e75cb4c148a1e1e8bfe0938ce56528bf6b471/lib/grably/core/win_colors.rb#L131-L182<CODESPLIT>WinColors.AnsiParser.print_string<CODESPLIT>rubocop : disable Metrics / AbcSize Metrics / CyclomaticComplexity rubocop : disable Metrics / MethodLength Metrics / PerceivedComplexity rubocop : disable Metrics / BlockNesting Metrics / BlockLength<CODESPLIT>def print_string ( s ) s = s . to_s . dup until s . empty? if s . sub! ( / \e \e \[ \( \; \= / , '\5' ) @out . write ( concealed ( Regexp . last_match ( 1 ) ) ) if Regexp . last_match ( 2 ) == '[' && Regexp . last_match ( 4 ) == 'm' attrs = Regexp . last_match ( 3 ) . split ( ';' ) attrs . push ( nil ) unless attrs attrs . each do | attr | atv = attr . to_i case atv when 0 reset_colors when 1 @bold = true when 21 @bold = false when 4 @underline = true when 24 @underline = false when 7 @revideo = true when 27 @revideo = false when 8 @concealed = true when 28 @concealed = false when 30 .. 37 @foreground = ANSI2WIN [ atv - 30 ] when 39 @foreground = @default_foreground when 40 .. 47 @background = ANSI2WIN [ atv - 40 ] when 49 @background = @default_background end end attrib = @revideo ? ( @background | ( @foreground << 4 ) ) : ( @foreground | ( @background << 4 ) ) attrib |= 0x08 if @bold attrib |= 0x400 if @underline WinColors . SetConsoleTextAttribute ( @handle , attrib ) end else @out . write ( concealed ( s ) ) s = '' end end end

1<CODESPLIT>https://github.com/Falkor/falkorlib/blob/1a6d732e8fd5550efb7c98a87ee97fcd2e051858/lib/falkorlib/common.rb#L182-L224<CODESPLIT>FalkorLib.Common.list_items<CODESPLIT>List items from a glob pattern to ask for a unique choice Supported options : : only_files [ boolean ] : list only files in the glob : only_dirs [ boolean ] : list only directories in the glob : pattern_include [ array of strings ] : pattern ( s ) to include for listing : pattern_exclude [ array of strings ] : pattern ( s ) to exclude for listing : text [ string ] : text to put<CODESPLIT>def list_items ( glob_pattern , options = { } ) list = { 0 => 'Exit' } index = 1 raw_list = { 0 => 'Exit' } Dir [ glob_pattern . to_s ] . each do | elem | #puts "=> element '#{elem}' - dir = #{File.directory?(elem)}; file = #{File.file?(elem)}" next if ( ! options [ :only_files ] . nil? ) && options [ :only_files ] && File . directory? ( elem ) next if ( ! options [ :only_dirs ] . nil? ) && options [ :only_dirs ] && File . file? ( elem ) entry = File . basename ( elem ) # unless options[:pattern_include].nil? #     select_entry = false #     options[:pattern_include].each do |pattern| #         #puts "considering pattern '#{pattern}' on entry '#{entry}'" #         select_entry |= entry =~ /#{pattern}/ #     end #     next unless select_entry # end unless options [ :pattern_exclude ] . nil? select_entry = false options [ :pattern_exclude ] . each do | pattern | #puts "considering pattern '#{pattern}' on entry '#{entry}'" select_entry |= entry =~ / #{ pattern } / end next if select_entry end #puts "selected entry = '#{entry}'" list [ index ] = entry raw_list [ index ] = elem index += 1 end text = ( options [ :text ] . nil? ) ? "select the index" : options [ :text ] default_idx = ( options [ :default ] . nil? ) ? 0 : options [ :default ] raise SystemExit , 'Empty list' if index == 1 #ap list #ap raw_list # puts list.to_yaml # answer = ask("=> #{text}", "#{default_idx}") # raise SystemExit.new('exiting selection') if answer == '0' # raise RangeError.new('Undefined index')   if Integer(answer) >= list.length # raw_list[Integer(answer)] select_from ( list , text , default_idx , raw_list ) end

1<CODESPLIT>https://github.com/malept/thermite/blob/9b380eb9e069909ff346fb3079d5be340deccaac/lib/thermite/package.rb#L60-L67<CODESPLIT>Thermite.Package.prepare_downloaded_library<CODESPLIT>: nocov :<CODESPLIT>def prepare_downloaded_library return unless config . target_os . start_with? ( 'darwin' ) libruby_path = Shellwords . escape ( config . libruby_path ) library_path = Shellwords . escape ( config . ruby_extension_path ) ` #{ library_path } #{ library_path } ` ` #{ libruby_path } #{ library_path } ` end

1<CODESPLIT>https://github.com/jkoisch/plaid_webhook/blob/ed101ab7ec38c6d532dfe9f7393624b2c29fe2c2/app/controllers/plaid_webhook/antennas_controller.rb#L41-L50<CODESPLIT>PlaidWebhook.AntennasController.create<CODESPLIT>POST / antennas<CODESPLIT>def create request . body . rewind @antenna = Antenna . new ( :access_token => params [ :antenna ] [ :access_token ] , :payload => request . body_stream . read ) if @antenna . save redirect_to @antenna , notice : 'Antenna was successfully created.' else render action : 'new' end end

0<CODESPLIT>https://github.com/wearefine/fae/blob/645d6b66945aeff54e27af6a95c4f8a1f7a67d39/app/controllers/fae/images_controller.rb#L9-L15<CODESPLIT>Fae.FormHelper.language_support<CODESPLIT>ajax delete action<CODESPLIT>def language_support ( f , attribute , options ) return if Fae . languages . blank? attribute_array = attribute . to_s . split ( '_' ) language_suffix = attribute_array . pop return unless Fae . languages . has_key? ( language_suffix . to_sym ) || Fae . languages . has_key? ( language_suffix ) label = attribute_array . push ( "(#{language_suffix})" ) . join ( ' ' ) . titleize options [ :label ] = label unless options [ :label ] . present? if options [ :wrapper_html ] . present? options [ :wrapper_html ] . deep_merge! ( { data : { language : language_suffix } } ) else options [ :wrapper_html ] = { data : { language : language_suffix } } end end

1<CODESPLIT>https://github.com/rahmal/rconfig/blob/528c2fca29fcba4eb495ae443fa04269278d226b/lib/rconfig/cascade.rb#L21-L53<CODESPLIT>RConfig.Cascade.suffixes_for<CODESPLIT>Returns a list of suffixes to try for a given config name .<CODESPLIT>def suffixes_for ( name ) name = name . to_s self . suffixes [ name ] ||= begin ol = overlay name_x = name . dup if name_x . sub! ( / / , '' ) ol = $1 end name_x . freeze result = if ol ol_ = ol . upcase ol = ol . downcase x = [ ] SUFFIXES . each do | suffix | # Standard, no overlay: # e.g.: database_<suffix>.yml x << suffix # Overlay: # e.g.: database_(US|GB)_<suffix>.yml x << [ ol_ , suffix ] end [ name_x , x . freeze ] else [ name . dup . freeze , SUFFIXES . freeze ] end result . freeze logger . debug "suffixes(#{name}) => #{result.inspect}" result end end

0<CODESPLIT>https://github.com/codevise/pageflow/blob/08a812373823581f44aa59a95b83f0deb55f4ed9/lib/pageflow/seeds.rb#L55-L66<CODESPLIT>Pageflow.Seeds.account<CODESPLIT>Build a default { Theming } for an { Account } . To be used inside a block passed to { #account } .<CODESPLIT>def account ( attributes , & block ) Account . find_or_create_by! ( attributes . slice ( :name ) ) do | account | account . attributes = attributes . reverse_merge ( name : 'Pageflow' ) build_default_theming_for ( account ) say_creating_account ( account ) yield ( account ) if block_given? end end

1<CODESPLIT>https://github.com/bitbucket-rest-api/bitbucket/blob/e03b6935104d59b3d9a922474c3dc210a5ef76d2/lib/bitbucket_rest_api/repos/default_reviewers.rb#L40-L45<CODESPLIT>BitBucket.Repos::DefaultReviewers.add<CODESPLIT>Add a user to the default - reviewers list for the repo<CODESPLIT>def add ( user_name , repo_name , reviewer_username , params = { } ) update_and_validate_user_repo_params ( user_name , repo_name ) normalize! params put_request ( "/2.0/repositories/#{user_name}/#{repo_name}/default-reviewers/#{reviewer_username}" , params ) end

0<CODESPLIT>https://github.com/awesome-print/awesome_print/blob/4564fd74721562cbef2443f7d97109bf9192343d/lib/awesome_print/ext/active_record.rb#L16-L30<CODESPLIT>AwesomePrint.ActiveRecord.awesome_active_record_instance<CODESPLIT>Add ActiveRecord class names to the dispatcher pipeline . ------------------------------------------------------------------------------<CODESPLIT>def awesome_active_record_instance ( object ) return object . inspect if ! defined? ( :: ActiveSupport :: OrderedHash ) return awesome_object ( object ) if @options [ :raw ] data = if object . class . column_names != object . attributes . keys object . attributes else object . class . column_names . inject ( :: ActiveSupport :: OrderedHash . new ) do | hash , name | if object . has_attribute? ( name ) || object . new_record? value = object . respond_to? ( name ) ? object . send ( name ) : object . read_attribute ( name ) hash [ name . to_sym ] = value end hash end end "#{object} " << awesome_hash ( data ) end

0<CODESPLIT>https://github.com/blackwinter/nuggets/blob/2a1d0beb015077b2820851ab190e886d1ad588b8/lib/nuggets/ruby_mixin.rb#L122-L125<CODESPLIT>RightDevelop::CI.Util.pseudo_java_class_name<CODESPLIT>Returns the correct command string for invoking the + name + executable that belongs to the current Ruby interpreter . Returns + nil + if the command is not found .<CODESPLIT>def pseudo_java_class_name ( name ) result = '' name . each_char do | chr | if chr =~ JAVA_CLASS_NAME result << chr elsif chr == JAVA_PACKAGE_SEPARATOR result << JAVE_PACKAGE_SEPARATOR_HOMOGLYPH else chr = chr . unpack ( 'U' ) [ 0 ] . to_s ( 16 ) result << "&#x#{chr};" end end result end

1<CODESPLIT>https://github.com/azach/rules/blob/f26b243e53cd2884a820ef82bfd93c1661de89a2/lib/rules/rule_set.rb#L39-L49<CODESPLIT>Rules.RuleSet.evaluate<CODESPLIT>TODO : Arbitrary rule set logic ( Treetop )<CODESPLIT>def evaluate ( attributes = { } ) return true unless rules . any? if evaluation_logic == 'any' ! ! rules . detect { | rule | rule . evaluate ( attributes ) } else rules . each do | rule | return false unless rule . evaluate ( attributes ) end true end end

0<CODESPLIT>https://github.com/snltd/wavefront-sdk/blob/93659d2dab64611fd56aee05cf1de1dd732b46f7/lib/wavefront-sdk/metric_helper.rb#L81-L90<CODESPLIT>Wavefront.MetricHelper.dist<CODESPLIT>When we are asked to flush the buffers duplicate the current one hand it off to the writer class and clear . If writer tells us there was an error dump the old buffer into the the new one for the next flush .<CODESPLIT>def dist ( path , interval , value , tags = nil ) key = [ path , interval , tags ] @buf [ :dists ] [ key ] += [ value ] . flatten end

0<CODESPLIT>https://github.com/xcres/xcres/blob/4747b072ab316e7c6f389db9a3cad584e814fe43/lib/xcres/analyzer/strings_analyzer.rb#L154-L162<CODESPLIT>XCRes.StringsAnalyzer.read_plist_key<CODESPLIT>Find the native development languages by trying to use the Localization native development region from Info . plist<CODESPLIT>def read_plist_key ( path , key ) raise ArgumentError , "File '#{path}' doesn't exist" unless path . exist? raise ArgumentError , 'Path is required, but nil' if path . nil? raise ArgumentError , 'Key is required, but nil' if key . nil? out = ` #{ key } #{ path } ` . chomp raise ArgumentError , "Error reading plist: #{out}" unless $? . success? out end

1<CODESPLIT>https://github.com/i0n/jumpstart/blob/e61beee175ba5a69796e00c2fb88097227c5ce9b/lib/jumpstart/base.rb#L330-L346<CODESPLIT>JumpStart.Base.set_default_template_options<CODESPLIT>Sets the default template to be used by JumpStart and writes it to a YAML file .<CODESPLIT>def set_default_template_options input = gets . chomp . strip case when input . to_i <= JumpStart . existing_templates . count && input . to_i > 0 JumpStart . default_template_name = JumpStart . existing_templates [ ( input . to_i - 1 ) ] JumpStart . dump_jumpstart_setup_yaml puts "  The default jumpstart template has been set to: " . green + JumpStart . default_template_name . green_bold jumpstart_menu when input . downcase == "b" jumpstart_menu when input . downcase == "x" exit_normal else puts "That command hasn't been understood. Try again!" . red set_default_template_options end end

1<CODESPLIT>https://github.com/mguymon/naether/blob/218d8fd36c0b8b6e16d66e5715975570b4560ec4/src/main/ruby/naether/maven.rb#L152-L176<CODESPLIT>Naether.Maven.invoke<CODESPLIT>Invoke a Maven goal<CODESPLIT>def invoke ( * opts ) #defaults config = { # Checks ENV for maven home, otherwise defaults /usr/share/maven # XXX: Reuse Eng.getMavenHome? :maven_home => ENV [ 'maven.home' ] || ENV [ 'MAVEN_HOME' ] || '/usr/share/maven' , :local_repo => File . expand_path ( '~/.m2/repository' ) } if opts . last . is_a? Hash config = config . merge ( opts . pop ) end goals = opts pom = @project . getPomFile ( ) . getAbsolutePath ( ) invoker = Naether :: Java . create ( "com.tobedevoured.naether.maven.Invoker" , config [ :local_repo ] , config [ :maven_home ] ) java_list = Naether :: Java . convert_to_java_list ( goals ) if Naether . platform == 'java' invoker . execute ( pom , java_list ) else invoker . _invoke ( 'execute' , 'Ljava.lang.String;Ljava.util.List;' , pom , java_list ) end end

1<CODESPLIT>https://github.com/rightscale/right_link/blob/b33a209c20a8a0942dd9f1fe49a08030d4ca209f/lib/instance/cook/executable_sequence.rb#L657-L666<CODESPLIT>RightScale.ExecutableSequence.report_success<CODESPLIT>Initialize inputs patch and report success<CODESPLIT>def report_success ( node ) ChefState . merge_attributes ( node . normal_attrs ) if node remove_right_script_params_from_chef_state patch = :: RightSupport :: Data :: HashTools . deep_create_patch ( @inputs , ChefState . attributes ) # We don't want to send back new attributes (ohai etc.) patch [ :right_only ] = { } @inputs_patch = patch EM . next_tick { succeed } true end

0<CODESPLIT>https://github.com/cloudfoundry/cf-uaa-lib/blob/e071d69ad5f16053321dfbb95835cf6a9b48227c/lib/uaa/token_coder.rb#L208-L222<CODESPLIT>CF::UAA.TokenIssuer.request_token<CODESPLIT>Returns hash of values decoded from the token contents taking reference_time as the comparison time for expiration . If the audience_ids were specified in the options to this instance ( see #initialize ) and the token does not contain one or more of those audience_ids an AuthError will be raised . AuthError is raised if the token has expired .<CODESPLIT>def request_token ( params ) if scope = Util . arglist ( params . delete ( :scope ) ) params [ :scope ] = Util . strlist ( scope ) end headers = { 'content-type' => FORM_UTF8 , 'accept' => JSON_UTF8 , 'authorization' => Http . basic_auth ( @client_id , @client_secret ) } reply = json_parse_reply ( @key_style , request ( @token_target , :post , '/oauth/token' , Util . encode_form ( params ) , headers ) ) raise BadResponse unless reply [ jkey :token_type ] && reply [ jkey :access_token ] TokenInfo . new ( reply ) end

1<CODESPLIT>https://github.com/m-31/puppetdb_query/blob/58103c91f291de8ce28d679256e50ae391b93ecb/lib/puppetdb_query/mongodb.rb#L169-L196<CODESPLIT>PuppetDBQuery.MongoDB.node_update<CODESPLIT>update or insert facts for given node name<CODESPLIT>def node_update ( node , facts ) logger . debug "  updating #{node}" connection [ nodes_collection ] . find ( _id : node ) . replace_one ( facts , upsert : true , bypass_document_validation : true , check_keys : false , validating_keys : false ) rescue :: Mongo :: Error :: OperationFailure => e logger . warn "  updating #{node} failed with: #{e.message}" # mongodb doesn't support keys with a dot # see https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names # as a dirty workaround we delete the document and insert it ;-) # The dotted field .. in .. is not valid for storage. (57) # .. is an illegal key in MongoDB. Keys may not start with '$' or contain a '.'. # (BSON::String::IllegalKey) raise e unless e . message =~ / / || e . message =~ / / logger . warn "    we transform the dots into underline characters" begin facts = Hash [ facts . map { | k , v | [ k . tr ( '.' , '_' ) , v ] } ] connection [ nodes_collection ] . find ( _id : node ) . replace_one ( facts , upsert : true , bypass_document_validation : true , check_keys : false , validating_keys : false ) rescue logger . error "  inserting node #{node} failed again with: #{e.message}" end end

0<CODESPLIT>https://github.com/webzakimbo/bcome-kontrol/blob/59129cc7c8bb6c39e457abed783aa23c1d60cd05/lib/objects/node/base.rb#L69-L74<CODESPLIT>DeploYML.Configuration.parse_commands<CODESPLIT>TODO - why not do these in parallel?<CODESPLIT>def parse_commands ( command ) case command when Array command . map { | line | line . to_s } when String command . enum_for ( :each_line ) . map { | line | line . chomp } else raise ( InvalidConfig , "commands must be an Array or a String" ) end end

0<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_web/lib/2016-03-01/generated/azure_mgmt_web/web_site_management_client.rb#L1337-L1340<CODESPLIT>Azure::Web::Mgmt::V2016_03_01.WebSiteManagementClient.validate<CODESPLIT>Move resources between resource groups .<CODESPLIT>def validate ( resource_group_name , validate_request , custom_headers : nil ) response = validate_async ( resource_group_name , validate_request , custom_headers :custom_headers ) . value! response . body unless response . nil? end

1<CODESPLIT>https://github.com/checkdin/checkdin-ruby/blob/c3c4b38b0f8c710e1f805100dcf3a70649215b48/lib/checkdin/client.rb#L69-L75<CODESPLIT>Checkdin.Client.return_error_or_body<CODESPLIT>Helper method to return errors or desired response data as appropriate .<CODESPLIT>def return_error_or_body ( response ) if response . status / 100 == 2 response . body else raise Checkdin :: APIError . new ( response . status , response . body ) end end

1<CODESPLIT>https://github.com/xuanxu/random_sources/blob/8fb43ea50e97191bc5d68b634887b72752f6d63e/lib/providers/hot_bits.rb#L31-L46<CODESPLIT>RandomSources.HotBits.bytes<CODESPLIT>Random bytes generator .<CODESPLIT>def bytes ( num = 10 ) num = [ [ 2048 , num . to_i ] . min , 0 ] . max numbers = [ ] response = REXML :: Document . new ( open ( "https://www.fourmilab.ch/cgi-bin/Hotbits?fmt=xml&nbytes=#{num}" ) ) status = REXML :: XPath . first ( response , "//status" ) case status . attributes [ 'result' ] . to_i when 200 data = REXML :: XPath . first ( response , "//random-data" ) . text . split data . each { | byte | numbers << byte . hex } when 503 raise StandardError . new "#{status.text}" end numbers end

1<CODESPLIT>https://github.com/spox/splib/blob/fd4451243ce4c9a319e74b33e6decdd09a509f43/lib/splib/monitor.rb#L179-L214<CODESPLIT>Splib.Monitor.start_timer<CODESPLIT>Starts the timer for waiting threads with a timeout<CODESPLIT>def start_timer @timer = Thread . new do begin until ( @stop ) do cur = [ ] t = 0.0 Thread . exclusive do t = @timers . values . min cur = @timers . dup end t = 0.0 if ! t . nil? && t < 0.0 a = 0.0 begin a = Splib . sleep ( t ) rescue Wakeup # do nothing of importance ensure next if t . nil? Thread . exclusive do cur . each_pair do | thread , value | value -= a if ( value <= 0.0 ) thread . wakeup @timers . delete ( thread ) else @timers [ thread ] = value end end end end end rescue retry end end end

1<CODESPLIT>https://github.com/greyblake/blogo/blob/eee0a8854cfdc309763197e3ef9b295008be85f6/app/controllers/blogo/admin/sessions_controller.rb#L16-L25<CODESPLIT>Blogo::Admin.SessionsController.create<CODESPLIT>POST / admin / sessions<CODESPLIT>def create user = Blogo :: User . find_by_email ( params [ :email ] ) if user && user . authenticate ( params [ :password ] ) session [ :blogo_user_id ] = user . id redirect_to blogo_admin_url , notice : I18n . translate ( 'blogo.admin.logged_in' ) else flash . now . alert = I18n . translate ( 'blogo.admin.login_fail' ) render "new" end end

0<CODESPLIT>https://github.com/bitrise-io/ipa_analyzer/blob/70dbcbdbb2371b60c327931aa8fea587505e41bd/lib/ipa_analyzer/analyzer.rb#L105-L133<CODESPLIT>Grim.Page.text<CODESPLIT>Find the . app folder which contains both the embedded . mobileprovision and Info . plist files .<CODESPLIT>def text ( options = { } ) flags = options . fetch ( :flags , [ ] ) command_parts = [ @pdftotext_path , "-enc" , "UTF-8" , "-f" , @number , "-l" , @number ] command_parts += flags if flags . length > 0 command_parts += [ Shellwords . escape ( @pdf . path ) , "-" ] command = command_parts . join ( ' ' ) Grim . logger . debug { "Running pdftotext command" } Grim . logger . debug { command } ` #{ command } ` end

0<CODESPLIT>https://github.com/roja/words/blob/4d6302e7218533fcc2afb4cd993686dd56fe2cde/lib/wordnet_connectors/pure_wordnet_connection.rb#L94-L104<CODESPLIT>Words.PureWordnetConnection.synset<CODESPLIT>Locates from a term any relevent homographs and constructs a homographs hash .<CODESPLIT>def synset ( synset_id ) raise NoWordnetConnection , "There is presently no connection to wordnet. To attempt to reistablish a connection you should use the 'open!' command on the Wordnet object." unless connected? pos = synset_id [ 0 , 1 ] File . open ( @wordnet_path + "data.#{SHORT_TO_POS_FILE_TYPE[pos]}" , "r" ) do | file | file . seek ( synset_id [ 1 .. - 1 ] . to_i ) data_line , gloss = file . readline . strip . split ( " | " ) lexical_filenum , synset_type , word_count , * data_parts = data_line . split ( " " ) [ 1 .. - 1 ] words = Array . new ( word_count . to_i ( 16 ) ) . map { "#{data_parts.shift}.#{data_parts.shift}" } relations = Array . new ( data_parts . shift . to_i ) . map { "#{data_parts.shift}.#{data_parts.shift}.#{data_parts.shift}.#{data_parts.shift}" } return { "synset_id" => synset_id , "lexical_filenum" => lexical_filenum , "synset_type" => synset_type , "words" => words . join ( '|' ) , "relations" => relations . join ( '|' ) , "gloss" => gloss . strip } end end

0<CODESPLIT>https://github.com/arashm/PoParser/blob/e84afdabbd15cc2d5e1d38101d44f8a49992b9f9/lib/poparser/entry.rb#L30-L35<CODESPLIT>Troles::Common::Api.Write.set_roles<CODESPLIT>Checks if the entry is untraslated<CODESPLIT>def set_roles * roles roles_to_set = make_valid_roles ( roles ) . flat_uniq return false if ! roles_to_set || roles_to_set . empty? store . set_roles ( roles_to_set ) end

1<CODESPLIT>https://github.com/zombor/Validator/blob/d0503c8c1c64ba3d90ccb8afe8d3e7ebfa030be8/lib/validation/validator.rb#L93-L98<CODESPLIT>Validation.Rules.get_rule_class_by_name<CODESPLIT>Resolves the specified rule name to a rule class<CODESPLIT>def get_rule_class_by_name ( klass ) klass = camelize ( klass ) Validation :: Rule . const_get ( klass ) rescue NameError => e raise InvalidRule . new ( e ) end

0<CODESPLIT>https://github.com/aws/aws-sdk-ruby/blob/e28b8d320ddf7b6ee0161bdd9d00fb786d99b63d/gems/aws-sdk-s3/lib/aws-sdk-s3/bucket_acl.rb#L224-L228<CODESPLIT>Aws.PageableResponse.each<CODESPLIT>@!group Actions @example Request syntax with placeholder values<CODESPLIT>def each ( & block ) return enum_for ( :each_page ) unless block_given? response = self yield ( response ) until response . last_page? response = response . next_page yield ( response ) end end

1<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_container_registry/lib/2018-02-01-preview/generated/azure_mgmt_container_registry/builds.rb#L570-L573<CODESPLIT>Azure::ContainerRegistry::Mgmt::V2018_02_01_preview.Builds.begin_cancel<CODESPLIT>Cancel an existing build .<CODESPLIT>def begin_cancel ( resource_group_name , registry_name , build_id , custom_headers : nil ) response = begin_cancel_async ( resource_group_name , registry_name , build_id , custom_headers :custom_headers ) . value! nil end

0<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_sql/lib/2014-04-01/generated/azure_mgmt_sql/disaster_recovery_configurations.rb#L546-L548<CODESPLIT>Azure::SQL::Mgmt::V2014_04_01.DisasterRecoveryConfigurations.begin_delete_with_http_info<CODESPLIT>Creates or updates a disaster recovery configuration .<CODESPLIT>def begin_delete_with_http_info ( resource_group_name , server_name , disaster_recovery_configuration_name , custom_headers : nil ) begin_delete_async ( resource_group_name , server_name , disaster_recovery_configuration_name , custom_headers :custom_headers ) . value! end

1<CODESPLIT>https://github.com/plataformatec/simple_form/blob/4dd9261ebb392e46a9beeefe8d83081e7c6e56b5/lib/simple_form/form_builder.rb#L530-L539<CODESPLIT>SimpleForm.FormBuilder.find_input<CODESPLIT>Find an input based on the attribute name .<CODESPLIT>def find_input ( attribute_name , options = { } , & block ) column = find_attribute_column ( attribute_name ) input_type = default_input_type ( attribute_name , column , options ) if block_given? SimpleForm :: Inputs :: BlockInput . new ( self , attribute_name , column , input_type , options , block ) else find_mapping ( input_type ) . new ( self , attribute_name , column , input_type , options ) end end

0<CODESPLIT>https://github.com/wedesoft/multiarray/blob/1ae1d98bacb4b941d6f406e44ccb184de12f83d9/lib/multiarray/random.rb#L109-L113<CODESPLIT>Hornetseye.Random.demand<CODESPLIT>Strip of all values<CODESPLIT>def demand if variables . empty? if dimension > 0 shape . last . times do | i | dest = @dest . element INT . new ( i ) Random . new ( dest , @n ) . demand end else if @n . typecode < INT_ or ( @n . typecode < OBJECT and @n . get . is_a? Integer ) @dest . store @n . typecode . new ( @n . get . lrand ) else @dest . store @n . typecode . new ( @n . get . drand ) end end @dest else super end end

0<CODESPLIT>https://github.com/philosophie/stairs/blob/535f69a783bd5ff418d786af8c91789925c4388b/lib/stairs/step.rb#L87-L97<CODESPLIT>Stairs.Step.env<CODESPLIT>Embed a step where step_name is a symbol that can be resolved to a class in Stairs :: Steps or a block is provided to be executed in an instance of Step<CODESPLIT>def env ( name , value ) ENV [ name ] = value if value Stairs . configuration . env_adapter . set name , value else Stairs . configuration . env_adapter . unset name end end

1<CODESPLIT>https://github.com/wearefine/maximus/blob/d3a6ad1826694c98a5e6a5a3175b78e69aac7945/lib/maximus/config.rb#L249-L259<CODESPLIT>Maximus.Config.split_paths<CODESPLIT>Accounting for space - separated command line arrays<CODESPLIT>def split_paths ( paths ) new_paths = { } paths . each do | p | if p . split ( '/' ) . length > 1 new_paths [ p . split ( '/' ) . last . to_s ] = p else new_paths [ 'home' ] = '/' end end new_paths end

1<CODESPLIT>https://github.com/slideshow-s9/slideshow/blob/b7a397f9136f623589816bef498914943980a313/slideshow-models/lib/slideshow/commands/merge.rb#L22-L90<CODESPLIT>Slideshow.Merge.merge<CODESPLIT>original working dir ( user called slideshow from )<CODESPLIT>def merge ( deck , ctx , headers , content_for ) manifestsrc = ctx [ :manifestsrc ] name = ctx [ :name ] outdir = ctx [ :outdir ] ## note:  ##   assumes name == basename  (e.g. name without extension and directory)  ##    rename name to basename - why? why not??  ## note: assumes working directory is (default) work directory  ##         e.g. original working dir (user called slideshow from)  puts "Merging slideshow '#{name}'..." #### pak merge  #  nb: change cwd to template pak root  @pakdir = File . dirname ( manifestsrc ) # template pak root - make availabe too in erb via binding  logger . debug " setting pakdir to >#{@pakdir}<" #  todo/fix: change current work dir (cwd) in pakman gem itself  #   for now lets do it here  logger . debug "changing cwd to pak - new >#{@pakdir}<, old >#{Dir.pwd}<" Dir . chdir ( @pakdir ) logger . debug ( "manifestsrc >#{manifestsrc}<, outdir >#{outdir}<" ) ###########################################  ## setup hash for binding  assigns = { 'name' => name , 'headers' => HeadersDrop . new ( headers ) , 'content' => deck . content , 'slides' => deck . slides . map { | slide | SlideDrop . new ( slide ) } , # strutured content - use LiquidDrop - why? why not?  } ## add content_for entries e.g.  ##    content_for :js  =>  more_content_for_js or content_for_js or extra_js etc.  ##  for now allow all three aliases  puts "content_for:" pp content_for content_for . each do | k , v | puts "  (auto-)add content_for >#{k.to_s}< to ctx:" puts v assigns [ "more_content_for_#{k}" ] = v assigns [ "content_for_#{k}" ] = v assigns [ "extra_#{k}" ] = v end puts "assigns:" pp assigns Pakman :: LiquidTemplater . new . merge_pak ( manifestsrc , outdir , assigns , name ) ## pop/restore org (original) working folder/dir  unless usrdir == @pakdir logger . debug "restoring cwd to usr - new >#{usrdir}<, old >#{Dir.pwd}<" Dir . chdir ( usrdir ) end end

1<CODESPLIT>https://github.com/negativecode/vines/blob/245d6c971dd8604d74265d67fd4e2a78319d71a2/lib/vines/stanza.rb#L163-L165<CODESPLIT>Vines.Stanza.allowed?<CODESPLIT>Return true if the to and from JIDs are allowed to communicate with one another based on the cross_domain_messages setting in conf / config . rb . If a domain s users are isolated to sending messages only within their own domain pubsub stanzas must not be processed from remote JIDs .<CODESPLIT>def allowed? stream . config . allowed? ( validate_to || stream . domain , stream . user . jid ) end

0<CODESPLIT>https://github.com/EdeyaLabs/coordsafe_api/blob/f2911a10f7b984c8a3c3d7b1a7da008da9512bd0/lib/coordsafe_api/locator.rb#L22-L30<CODESPLIT>NodeJS.Module.require_function<CODESPLIT>opts : locator_id date_from date_to If only date_from exists<CODESPLIT>def require_function lambda do | * args | this , module_id = args module_id ||= this #backwards compatibility with TRR < 0.10 return @environment . require ( module_id ) if NodeJS . builtins . keys . include? ( module_id ) #puts "requiring #{module_id} from #{CommonJS.resolve(@file.dirname, module_id).to_s}" @environment . require ( NodeJS . resolve ( @file . dirname , module_id ) . to_s ) end end

0<CODESPLIT>https://github.com/watsonbox/pocketsphinx-ruby/blob/12c71c35285c38b42bd7779c8246923bd5be150f/lib/pocketsphinx/audio_file.rb#L9-L18<CODESPLIT>ZK.Threadpool.defer<CODESPLIT>Read next block of audio samples from file ; up to max samples into buffer .<CODESPLIT>def defer ( callable = nil , & blk ) callable ||= blk raise ArgumentError , "Argument to Threadpool#defer must respond_to?(:call)" unless callable . respond_to? ( :call ) @mutex . lock begin @queue << callable @cond . broadcast ensure @mutex . unlock rescue nil end nil end

1<CODESPLIT>https://github.com/potatosalad/ruby-erlang-terms/blob/a3eaa3d976610466a5f5da177109a1248dac020d/lib/erlang/binary.rb#L272-L277<CODESPLIT>Erlang.Binary.each_bitslice<CODESPLIT>Split the bits in this Binary in groups of number bits and yield each group to the block ( as a List ) . If no block is given returns an Enumerator .<CODESPLIT>def each_bitslice ( number , & block ) return enum_for ( :each_bitslice , number ) unless block_given? bitstring = Erlang :: Bitstring . new ( @data , 8 ) bitstring . each_bitslice ( number , block ) return self end

0<CODESPLIT>https://github.com/dyoung522/nosequel/blob/b8788846a36ce03d426bfe3e575a81a6fb3c5c76/lib/nosequel/container.rb#L49-L55<CODESPLIT>NoSequel.Container.method_missing<CODESPLIT>Deletes : key from the nosequel container<CODESPLIT>def method_missing ( meth , * args , & block ) db . to_hash ( :key , :value ) . send ( meth , args , block ) end

0<CODESPLIT>https://github.com/CocoaPods/Xcodeproj/blob/3be1684437a6f8e69c7836ad4c85a2b78663272f/lib/xcodeproj/workspace.rb#L195-L213<CODESPLIT>Xcodeproj.Workspace.save_as<CODESPLIT>------------------------------------------------------------------------- Load all schemes from all projects in workspace or in the workspace container itself<CODESPLIT>def save_as ( path ) FileUtils . mkdir_p ( path ) File . open ( File . join ( path , 'contents.xcworkspacedata' ) , 'w' ) do | out | out << to_s end end

1<CODESPLIT>https://github.com/gollum/gollum-lib/blob/e811f79cb569f1bf0711947d49105db60421e2c1/lib/gollum-lib/git_access.rb#L238-L245<CODESPLIT>Gollum.GitAccess.decode_git_path<CODESPLIT>Decode octal sequences ( \ NNN ) in tree path names .<CODESPLIT>def decode_git_path ( path ) if path [ 0 ] == ?" && path [ - 1 ] == ?" path = path [ 1 ... - 1 ] path . gsub! ( / \\ \d / ) { | m | m [ 1 .. - 1 ] . to_i ( 8 ) . chr } end path . gsub! ( / \\ \\ / ) { | m | eval ( %("#{m}") ) } path end

1<CODESPLIT>https://github.com/rnhurt/google_anymote/blob/2992aee3590df9e2cf6d31cebfba2e14be926b8f/lib/google_anymote/tv.rb#L62-L65<CODESPLIT>GoogleAnymote.TV.send_keycode<CODESPLIT>Send a keystroke to the Google TV This is used for things like hitting the ENTER key<CODESPLIT>def send_keycode ( keycode ) send_request RequestMessage . new ( key_event_message : KeyEvent . new ( keycode : keycode , action : Action :: DOWN ) ) send_request RequestMessage . new ( key_event_message : KeyEvent . new ( keycode : keycode , action : Action :: UP ) ) end

0<CODESPLIT>https://github.com/hawkular/hawkular-client-ruby/blob/3b07729c2ab359e3199c282e199a3f1699ddc49c/lib/hawkular/inventory/inventory_api.rb#L56-L58<CODESPLIT>Hawkular::Inventory.Client.parent<CODESPLIT>Get childrens of a resource<CODESPLIT>def parent ( id ) hash = http_get ( url ( '/resources/%s/parent' , id ) ) Resource . new ( hash ) if hash end

1<CODESPLIT>https://github.com/movitto/reterm/blob/3e78c64e677f69b22f00dc89c2b515b9188c5e15/lib/reterm/mixins/nav_input.rb#L149-L169<CODESPLIT>RETerm.NavInput.nav_to_selected<CODESPLIT>Internal helper navigate to selected component under current<CODESPLIT>def nav_to_selected # clear nav_select ns = self . nav_select self . nav_select = nil # specified component is a direct child if self . children . include? ( ns ) remove_focus @focus = focusable . index ( ns ) #handle_focused #update_focus #focused.activate! # not a direct child, navigate down to layout # containing it else child = self . layout_containing ( ns ) child . nav_select = ns ch = child . handle_input ( true ) end end

1<CODESPLIT>https://github.com/rails/sprockets/blob/9e3f0d8e98c44f57e67bc138db87bb8469bf5ddd/lib/sprockets/bower.rb#L17-L40<CODESPLIT>Sprockets.Bower.resolve_alternates<CODESPLIT>Internal : Override resolve_alternates to install bower . json behavior .<CODESPLIT>def resolve_alternates ( load_path , logical_path ) candidates , deps = super # bower.json can only be nested one level deep if ! logical_path . index ( '/' . freeze ) dirname = File . join ( load_path , logical_path ) if directory? ( dirname ) filenames = POSSIBLE_BOWER_JSONS . map { | basename | File . join ( dirname , basename ) } filename = filenames . detect { | fn | self . file? ( fn ) } if filename deps << build_file_digest_uri ( filename ) read_bower_main ( dirname , filename ) do | path | if file? ( path ) candidates << path end end end end end return candidates , deps end

1<CODESPLIT>https://github.com/ruby-grape/grape-swagger/blob/542511d9ef08f25b587914a4976009fbc95f7dc0/lib/grape-swagger/endpoint.rb#L97-L114<CODESPLIT>Grape.Endpoint.path_item<CODESPLIT>path object<CODESPLIT>def path_item ( routes , options ) routes . each do | route | next if hidden? ( route , options ) @item , path = GrapeSwagger :: DocMethods :: PathString . build ( route , options ) @entity = route . entity || route . options [ :success ] verb , method_object = method_object ( route , options , path ) if @paths . key? ( path . to_s ) @paths [ path . to_s ] [ verb ] = method_object else @paths [ path . to_s ] = { verb => method_object } end GrapeSwagger :: DocMethods :: Extensions . add ( @paths [ path . to_s ] , @definitions , route ) end end

0<CODESPLIT>https://github.com/metanorma/relaton/blob/2fac19da2f3ef3c30b8e8d8815a14d2115df0be6/lib/relaton/db_cache.rb#L82-L87<CODESPLIT>Relaton.DbCache.delete<CODESPLIT>if cached reference is undated expire it after 60 days<CODESPLIT>def delete ( key ) file = filename key File . delete file if File . exist? file end

0<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_container_registry/lib/2017-06-01-preview/generated/azure_mgmt_container_registry/webhooks.rb#L698-L701<CODESPLIT>Azure::ContainerRegistry::Mgmt::V2017_06_01_preview.Webhooks.list_events_with_http_info<CODESPLIT>Creates a webhook for a container registry with the specified parameters .<CODESPLIT>def list_events_with_http_info ( resource_group_name , registry_name , webhook_name , custom_headers : nil ) list_events_async ( resource_group_name , registry_name , webhook_name , custom_headers :custom_headers ) . value! end

1<CODESPLIT>https://github.com/wwidea/rexport/blob/f4f978dd0327ddba3a4318dd24090fbc6d4e4e59/lib/rexport/data_fields.rb#L100-L112<CODESPLIT>Rexport.DataFields.export<CODESPLIT>Return an array of formatted export values for the passed methods<CODESPLIT>def export ( * methods ) methods . flatten . map do | method | case value = ( eval ( "self.#{method}" , binding ) rescue nil ) when Date , Time value . strftime ( "%m/%d/%y" ) when TrueClass 'Y' when FalseClass 'N' else value . to_s end end end

1<CODESPLIT>https://github.com/Netflix/Workflowable/blob/b163587d8ec68db1d336e5ee5ddd716783ad9c8b/app/controllers/workflowable/workflows_controller.rb#L41-L61<CODESPLIT>Workflowable.WorkflowsController.create<CODESPLIT>POST / workflows POST / workflows . json<CODESPLIT>def create @workflow = Workflow . new ( workflow_params ) respond_to do | format | if @workflow . save format . html { if ( @workflow . stages . count > 1 ) redirect_to configure_stages_workflow_path ( @workflow ) , notice : 'Workflow was successfully created. Please configure transitions.' else redirect_to @workflow , notice : 'Workflow was successfully created.' end } format . json { render json : @workflow , status : :created , location : @workflow } else format . html { render action : "new" } format . json { render json : @workflow . errors , status : :unprocessable_entity } end end end

0<CODESPLIT>https://github.com/iZettle/ninetails/blob/a1e7c05db0b3d01ac86f5bd8382ea951cf8895c7/app/models/ninetails/revision.rb#L21-L27<CODESPLIT>Ninetails.Revision.url_is_unique<CODESPLIT>Validate all sections and rebuild the sections array with the instances which now contain error messages<CODESPLIT>def url_is_unique if container . is_a? ( Page ) && url . present? url_exists = Ninetails :: Container . where . not ( id : container . id ) . includes ( :current_revision ) . where ( ninetails_revisions : { url : url } ) . exists? errors . add :url , "is already in use" if url_exists end end

1<CODESPLIT>https://github.com/rhomobile/rhodes/blob/3c5f87b1a44f0ba2865ca0e1dd780dd202f64872/res/build-tools/ruby-standalone/212/usr/local/lib/ruby/2.1.0/rake/dsl_definition.rb#L98-L105<CODESPLIT>Rake.DSL.namespace<CODESPLIT>Create a new rake namespace and use it for evaluating the given block . Returns a NameSpace object that can be used to lookup tasks defined in the namespace .<CODESPLIT>def namespace ( name = nil , & block ) name = name . to_s if name . kind_of? ( Symbol ) name = name . to_str if name . respond_to? ( :to_str ) unless name . kind_of? ( String ) || name . nil? raise ArgumentError , "Expected a String or Symbol for a namespace name" end Rake . application . in_namespace ( name , block ) end

0<CODESPLIT>https://github.com/stereocat/expectacle/blob/a67faca42ba5f90068c69047bb6cf01c2bca1b74/lib/expectacle/thrower.rb#L19-L27<CODESPLIT>Expectacle.Thrower.exec_each_prompt<CODESPLIT>#run_command_for_all_host [ for hosts ] - initialize command list (<CODESPLIT>def exec_each_prompt ( prompt ) check_auth_count case prompt when / #{ @prompt [ :password ] } / , / #{ @prompt [ :enable_password ] } / write_and_logging 'Send password' , embed_password , true when / #{ @prompt [ :username ] } / write_and_logging 'Send username: ' , embed_user_name when / #{ @prompt [ :command2 ] } / , / #{ @prompt [ :command1 ] } / exec_by_mode ( prompt ) when / #{ @prompt [ :yn ] } / , / #{ @prompt [ :sub1 ] } / , / #{ @prompt [ :sub2 ] } / exec_by_sub_prompt ( prompt ) else @logger . error "Unknown prompt #{prompt}" end end

1<CODESPLIT>https://github.com/Openwsman/openwsman/blob/5efb1545dbac7e6d1e0a992f3e84ca12cea1c18e/bindings/ruby/parse_swig.rb#L152-L179<CODESPLIT>RDoc.Swig_Parser.handle_class_module<CODESPLIT>handle class or module<CODESPLIT>def handle_class_module ( class_mod , class_name , options = { } ) #      puts "handle_class_module(#{class_mod}, #{class_name})" progress ( class_mod [ 0 , 1 ] ) parent = options [ :parent ] parent_name = @known_classes [ parent ] || parent if @@module_name enclosure = @top_level . find_module_named ( @@module_name ) else enclosure = @top_level end if class_mod == "class" cm = enclosure . add_class ( NormalClass , class_name , parent_name ) @stats . num_classes += 1 else cm = enclosure . add_module ( NormalModule , class_name ) @stats . num_modules += 1 end cm . record_location ( enclosure . toplevel ) cm . body = options [ :content ] cm . extend_name = options [ :extend_name ] || class_name find_class_comment ( class_name , cm ) @classes [ class_name ] = cm @known_classes [ class_name ] = cm . full_name cm end

1<CODESPLIT>https://github.com/chefspec/chefspec/blob/b7c260d480c3b71a0e61ce46148ec7b9d3f3c40e/lib/chefspec/mixins/normalize.rb#L11-L20<CODESPLIT>ChefSpec.Normalize.resource_name<CODESPLIT>Calculate the name of a resource replacing dashes with underscores and converting symbols to strings and back again .<CODESPLIT>def resource_name ( thing ) if thing . respond_to? ( :declared_type ) && thing . declared_type name = thing . declared_type elsif thing . respond_to? ( :resource_name ) name = thing . resource_name else name = thing end name . to_s . gsub ( '-' , '_' ) . to_sym end

0<CODESPLIT>https://github.com/Skalar/google_distance_matrix/blob/2bd0eb8eaa430d0a3fa3c047dab303683e7692fe/lib/google_distance_matrix/client.rb#L23-L35<CODESPLIT>GoogleDistanceMatrix.RoutesFinder.route_for<CODESPLIT>Make a GET request to given URL<CODESPLIT>def route_for ( options = { } ) options = options . with_indifferent_access origin = ensure_place options [ :origin ] destination = ensure_place options [ :destination ] raise ArgumentError , 'Must provide origin and destination' if origin . nil? || destination . nil? routes_for ( origin ) . detect { | route | route . destination == destination } end

1<CODESPLIT>https://github.com/ekosz/Plex-Ruby/blob/981dd175d674c74cad7ea8daf8b52c266c12df29/lib/plex-ruby/show.rb#L42-L44<CODESPLIT>Plex.Show.season<CODESPLIT>Select a particular season<CODESPLIT>def season ( number ) seasons . detect { | sea | sea . index . to_i == number . to_i } end

1<CODESPLIT>https://github.com/mikel/mail/blob/fb53fb369eb2bf0494ac70675970c90cdcc3f495/lib/mail/utilities.rb#L221-L223<CODESPLIT>Mail.Utilities.underscoreize<CODESPLIT>Swaps out all hyphens ( - ) for underscores ( _ ) good for stringing to symbols a field name .<CODESPLIT>def underscoreize ( str ) str . to_s . downcase . tr ( Constants :: HYPHEN , Constants :: UNDERSCORE ) end

1<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_network/lib/2019-02-01/generated/azure_mgmt_network/application_security_groups.rb#L661-L663<CODESPLIT>Azure::Network::Mgmt::V2019_02_01.ApplicationSecurityGroups.begin_update_tags_with_http_info<CODESPLIT>Updates an application security group s tags .<CODESPLIT>def begin_update_tags_with_http_info ( resource_group_name , application_security_group_name , parameters , custom_headers : nil ) begin_update_tags_async ( resource_group_name , application_security_group_name , parameters , custom_headers :custom_headers ) . value! end

0<CODESPLIT>https://github.com/aws/aws-sdk-ruby/blob/e28b8d320ddf7b6ee0161bdd9d00fb786d99b63d/gems/aws-sdk-sqs/lib/aws-sdk-sqs/queue.rb#L547-L551<CODESPLIT>Aws::SQS.Queue.set_attributes<CODESPLIT>@example Request syntax with placeholder values<CODESPLIT>def set_attributes ( options = { } ) options = options . merge ( queue_url : @url ) resp = @client . set_queue_attributes ( options ) resp . data end

1<CODESPLIT>https://github.com/daddyz/evercookie/blob/887c607e43865caf2ce7c649fc5e531653024cbe/lib/evercookie/controller.rb#L99-L113<CODESPLIT>Evercookie.EvercookieController.ec_cache<CODESPLIT>Renders page with cache header for evercookie js script<CODESPLIT>def ec_cache if not cookies [ Evercookie . cookie_cache ] . present? render :nothing => true , :status => 304 return true end puts "cache value (#{Evercookie.cookie_cache}): #{cookies[Evercookie.cookie_cache]}" response . headers [ "Content-Type" ] = "text/html" response . headers [ "Last-Modified" ] = "Wed, 30 Jun 2010 21:36:48 GMT" response . headers [ "Expires" ] = "Tue, 31 Dec 2030 23:30:45 GMT" response . headers [ "Cache-Control" ] = "private, max-age=630720000" render text : cookies [ Evercookie . cookie_cache ] end

1<CODESPLIT>https://github.com/kamito/k4compiler/blob/96e564d3570cd5d4ec8ae8e5f23511e39defcf3e/lib/k4compiler/compiler/markdown.rb#L44-L49<CODESPLIT>K4compiler.Markdown.compile<CODESPLIT>compile<CODESPLIT>def compile ( src ) src = src . read ( ) if src . respond_to? ( :read ) markdown = Redcarpet :: Markdown . new ( renderer , markdown_options ) rendered = markdown . render ( src ) return rendered end

1<CODESPLIT>https://github.com/Giphy/giphy-ruby-client/blob/75a99c4d529ac74a864f70a6d89174c5decf11e8/lib/GiphyClient/api/default_api.rb#L737-L740<CODESPLIT>GiphyClient.DefaultApi.stickers_search_get<CODESPLIT>Sticker Search Endpoint Replicates the functionality and requirements of the classic GIPHY search but returns animated stickers rather than GIFs .<CODESPLIT>def stickers_search_get ( api_key , q , opts = { } ) data , _status_code , _headers = stickers_search_get_with_http_info ( api_key , q , opts ) return data end

1<CODESPLIT>https://github.com/piotrmurach/finite_machine/blob/e54b9397e74aabd502672afb838a5ceb2d3caa2f/lib/finite_machine/state_machine.rb#L376-L383<CODESPLIT>FiniteMachine.StateMachine.transition_to!<CODESPLIT>Update this state machine state to new one<CODESPLIT>def transition_to! ( new_state ) from_state = current self . state = new_state self . initial_state = new_state if from_state == DEFAULT_STATE true rescue Exception => e catch_error ( e ) || raise_transition_error ( e ) end

1<CODESPLIT>https://github.com/zerowidth/camper_van/blob/984351a3b472e936a451f1d1cd987ca27d981d23/lib/camper_van/channel.rb#L169-L174<CODESPLIT>CamperVan.Channel.current_mode_string<CODESPLIT>Returns the current mode string<CODESPLIT>def current_mode_string n = room . membership_limit s = room . open_to_guests? ? "" : "s" i = room . locked? ? "i" : "" "+#{i}l#{s}" end

1<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_recovery_services_site_recovery/lib/2018-01-10/generated/azure_mgmt_recovery_services_site_recovery/replication_protected_items.rb#L1837-L1839<CODESPLIT>Azure::RecoveryServicesSiteRecovery::Mgmt::V2018_01_10.ReplicationProtectedItems.begin_repair_replication_with_http_info<CODESPLIT>Resynchronize or repair replication .<CODESPLIT>def begin_repair_replication_with_http_info ( fabric_name , protection_container_name , replicated_protected_item_name , custom_headers : nil ) begin_repair_replication_async ( fabric_name , protection_container_name , replicated_protected_item_name , custom_headers :custom_headers ) . value! end

0<CODESPLIT>https://github.com/aws/aws-sdk-ruby/blob/e28b8d320ddf7b6ee0161bdd9d00fb786d99b63d/gems/aws-sdk-rds/lib/aws-sdk-rds/db_cluster.rb#L1330-L1338<CODESPLIT>Aws::RDS.DBCluster.events<CODESPLIT>@example Request syntax with placeholder values<CODESPLIT>def events ( options = { } ) batches = Enumerator . new do | y | options = options . merge ( source_type : "db-cluster" , source_identifier : @id ) resp = @client . describe_events ( options ) resp . each_page do | page | batch = [ ] page . data . events . each do | e | batch << Event . new ( source_id : e . source_identifier , date : e . date , data : e , client : @client ) end y . yield ( batch ) end end Event :: Collection . new ( batches ) end

1<CODESPLIT>https://github.com/meew0/discordrb/blob/764298a1ff0be69a1853b510d736f21c2b91a2fe/lib/discordrb/data/server.rb#L173-L177<CODESPLIT>Discordrb.Server.cache_embed_data<CODESPLIT>Cache<CODESPLIT>def cache_embed_data data = JSON . parse ( API :: Server . embed ( @bot . token , @id ) ) @embed_enabled = data [ 'enabled' ] @embed_channel_id = data [ 'channel_id' ] end

0<CODESPLIT>https://github.com/hsribei/goalie/blob/9095585ec1790f6bb423b763dc0bfa7b013139dc/lib/goalie.rb#L79-L101<CODESPLIT>Opto.Option.output<CODESPLIT>Render detailed diagnostics for unhandled exceptions rescued from a controller action .<CODESPLIT>def output setters . each do | setter_config | begin setter = setter_config [ :setter ] if setter . respond_to? ( :call ) setter . call ( setter_config [ :hint ] , value , self ) else setter . new ( setter_config [ :hint ] , self ) . set ( value ) end rescue StandardError => ex raise ex , "Setter '#{setter_config[:target]}' for '#{name}' : #{ex.message}" end end end

1<CODESPLIT>https://github.com/parrish/attention/blob/ff5bd780b946636ba0e22f66bae3fb41b9c4353d/lib/attention/instance.rb#L42-L47<CODESPLIT>Attention.Instance.publish<CODESPLIT>Creates an Instance<CODESPLIT>def publish publisher . publish ( 'instance' , added : info ) do | redis | redis . setex "instance_#{ @id }" , Attention . options [ :ttl ] , JSON . dump ( info ) end heartbeat end

0<CODESPLIT>https://github.com/messagemedia/messages-ruby-sdk/blob/073f1f7ca5e4ff3df51b8eeafeaae2167ec6f311/lib/message_media_messages/http/faraday_client.rb#L58-L60<CODESPLIT>MessageMediaMessages.FaradayClient.execute_as_string<CODESPLIT>Method overridden from HttpClient .<CODESPLIT>def execute_as_string ( http_request ) response = @connection . send ( http_request . http_method . downcase , http_request . query_url ) do | request | request . headers = http_request . headers unless http_request . parameters . empty? request . body = http_request . parameters end end convert_response ( response ) end

0<CODESPLIT>https://github.com/jinx/core/blob/964a274cc9d7ab74613910e8375e12ed210a434d/lib/jinx/resource.rb#L393-L404<CODESPLIT>Jinx.Resource.difference<CODESPLIT>Matches this dependent domain object with the others on type and key attributes in the scope of a parent object . Returns the object in others which matches this domain object or nil if none .<CODESPLIT>def difference ( other , attributes = nil ) attributes ||= self . class . nondomain_attributes vh = value_hash ( attributes ) ovh = other . value_hash ( attributes ) vh . diff ( ovh ) { | key , v1 , v2 | Resource . value_equal? ( v1 , v2 ) } end

0<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_policy/lib/2017-06-01-preview/generated/azure_mgmt_policy/policy_set_definitions.rb#L318-L321<CODESPLIT>Azure::Search::Mgmt::V2015_08_19.Services.begin_create_or_update_with_http_info<CODESPLIT>Gets the built in policy set definition .<CODESPLIT>def begin_create_or_update_with_http_info ( resource_group_name , search_service_name , service , search_management_request_options : nil , custom_headers : nil ) begin_create_or_update_async ( resource_group_name , search_service_name , service , search_management_request_options :search_management_request_options , custom_headers :custom_headers ) . value! end

1<CODESPLIT>https://github.com/giuseb/mork/blob/63acbe762b09e4cda92f5d8dad41ac5735279724/lib/mork/sheet_omr.rb#L78-L86<CODESPLIT>Mork.SheetOMR.set_choices<CODESPLIT>Setting the choices / questions to analyze . If this function is not called the maximum number of choices / questions allowed by the layout will be evaluated .<CODESPLIT>def set_choices ( choices ) return false unless valid? @mim . set_ch case choices when Integer ; @mim . choxq [ 0 ... choices ] when Array ; choices else fail ArgumentError , 'Invalid choice set' end true end

0<CODESPLIT>https://github.com/cisco/cisco-network-node-utils/blob/a617a9ef9d6bd18f35f2e2f2591033e1ddd46145/lib/cisco_node_utils/bgp_neighbor_af.rb#L568-L572<CODESPLIT>Cisco.RouterBgpNeighborAF.max_prefix_get<CODESPLIT>----------------------- Nexus and XR implementations of send community differ enough that it makes sense to split up the individual methods to support them<CODESPLIT>def max_prefix_get str = config_get ( 'bgp_neighbor_af' , 'max_prefix' , @get_args ) return nil if str . nil? regexp = Regexp . new ( 'maximum-prefix (?<limit>\d+)' ' *(?<threshold>\d+)?' ' *(?<opt>restart|warning-only)?' ' *(?<interval>\d+)?' ) regexp . match ( str ) end

1<CODESPLIT>https://github.com/rightscale/right_agent/blob/64c68c162692f0a70543d10def5e4bf56505bd82/lib/right_agent/dispatched_cache.rb#L53-L66<CODESPLIT>RightScale.DispatchedCache.store<CODESPLIT>Initialize cache<CODESPLIT>def store ( token ) if token now = Time . now . to_i if @cache . has_key? ( token ) @cache [ token ] = now @lru . push ( @lru . delete ( token ) ) else @cache [ token ] = now @lru . push ( token ) @cache . delete ( @lru . shift ) while ( now - @cache [ @lru . first ] ) > @max_age end end true end

1<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_sql/lib/2017-10-01-preview/generated/azure_mgmt_sql/elastic_pools.rb#L527-L529<CODESPLIT>Azure::SQL::Mgmt::V2017_10_01_preview.ElasticPools.begin_delete_with_http_info<CODESPLIT>Deletes an elastic pool .<CODESPLIT>def begin_delete_with_http_info ( resource_group_name , server_name , elastic_pool_name , custom_headers : nil ) begin_delete_async ( resource_group_name , server_name , elastic_pool_name , custom_headers :custom_headers ) . value! end

0<CODESPLIT>https://github.com/flinc/pling/blob/fdbf998a393502de4fd193b5ffb454bd4b100ac6/lib/pling/gateway.rb#L85-L88<CODESPLIT>Flextures.Loader.equal_table_data?<CODESPLIT>Checks if this gateway is able to handle the given device<CODESPLIT>def equal_table_data? ( src , dst ) return false unless src . is_a? ( Hash ) return false unless dst . is_a? ( Hash ) ( src . to_a - dst . to_a ) . empty? end

0<CODESPLIT>https://github.com/sstephenson/hike/blob/3abf0b3feb47c26911f8cedf2cd409471fd26da1/lib/hike/cached_trail.rb#L63-L80<CODESPLIT>Hike.CachedTrail.find_in_paths<CODESPLIT>The real implementation of find_all . Trail#find_all generates a one time index and delegates here .<CODESPLIT>def find_in_paths ( logical_path , & block ) dirname , basename = File . split ( logical_path ) @paths . each do | base_path | match ( File . expand_path ( dirname , base_path ) , basename , block ) end end

0<CODESPLIT>https://github.com/backup/backup/blob/64370f925e859f858766b674717a3dbee0de7a26/vagrant/spec/support/tar_file.rb#L44-L62<CODESPLIT>BackupSpec.TarFile.contents<CODESPLIT>Return a Hash with the paths from #contents mapped to either another TarFile object ( for tar files ) or the full path to the extracted file .<CODESPLIT>def contents @contents ||= begin data = manifest . split ( "\n" ) . reject { | line | line =~ / \/ / } data . map! { | line | line . split ( ' ' ) } if gnu_tar? Hash [ data . map { | fields | [ fields [ 5 ] , fields [ 2 ] . to_i ] } ] else Hash [ data . map { | fields | [ fields [ 8 ] , fields [ 4 ] . to_i ] } ] end end end

0<CODESPLIT>https://github.com/barkerest/incline/blob/1ff08db7aa8ab7f86b223268b700bc67d15bb8aa/lib/incline/extensions/form_builder.rb#L557-L559<CODESPLIT>Cmdlib.App.addopt<CODESPLIT>Adds a recaptcha challenge to the form configured to set the specified attribute to the recaptcha response .<CODESPLIT>def addopt ( opt ) raise TypeError , 'Incorrectly types for option object.' unless opt . instance_of? Cmdlib :: Option @options [ opt . longname . to_sym ] = opt end

1<CODESPLIT>https://github.com/elevation/event_calendar/blob/131d6dee147f4d515daa77d4acc7fa77f369bfcc/lib/event_calendar/calendar_helper.rb#L49-L289<CODESPLIT>EventCalendar.CalendarHelper.calendar<CODESPLIT>Returns an HTML calendar which can show multiple overlapping events across calendar days and rows . Customize using CSS the below options and by passing in a code block .<CODESPLIT>def calendar ( options = { } , & block ) block ||= Proc . new { | d | nil } defaults = { :year => ( Time . zone || Time ) . now . year , :month => ( Time . zone || Time ) . now . month , :abbrev => true , :first_day_of_week => 0 , :show_today => true , :show_header => true , :month_name_text => ( Time . zone || Time ) . now . strftime ( "%B %Y" ) , :previous_month_text => nil , :next_month_text => nil , :event_strips => [ ] , # it would be nice to have these in the CSS file # but they are needed to perform height calculations :width => nil , :height => 500 , :day_names_height => 18 , :day_nums_height => 18 , :event_height => 18 , :event_margin => 1 , :event_padding_top => 2 , :use_all_day => false , :use_javascript => true , :link_to_day_action => false } options = defaults . merge options # default month name for the given number if options [ :show_header ] options [ :month_name_text ] ||= I18n . translate ( :' ' ) [ options [ :month ] ] end # make the height calculations # tricky since multiple events in a day could force an increase in the set height height = options [ :day_names_height ] row_heights = cal_row_heights ( options ) row_heights . each do | row_height | height += row_height end # the first and last days of this calendar month if options [ :dates ] . is_a? ( Range ) first = options [ :dates ] . begin last = options [ :dates ] . end else first = Date . civil ( options [ :year ] , options [ :month ] , 1 ) last = Date . civil ( options [ :year ] , options [ :month ] , - 1 ) end # create the day names array [Sunday, Monday, etc...] day_names = [ ] if options [ :abbrev ] day_names . concat ( I18n . translate ( :' ' ) ) else day_names . concat ( I18n . translate ( :' ' ) ) end options [ :first_day_of_week ] . times do day_names . push ( day_names . shift ) end # Build the HTML string cal = "" # outer calendar container cal << %(<div class="ec-calendar") cal << %(style="width: #{options[:width]}px;") if options [ :width ] cal << %(>) # table header, including the monthname and links to prev & next month if options [ :show_header ] cal << %(<table class="ec-calendar-header" cellpadding="0" cellspacing="0">) cal << %(<thead><tr>) if options [ :previous_month_text ] or options [ :next_month_text ] cal << %(<th colspan="2" class="ec-month-nav ec-previous-month">#{options[:previous_month_text]}</th>) colspan = 3 else colspan = 7 end cal << %(<th colspan="#{colspan}" class="ec-month-name">#{options[:month_name_text]}</th>) if options [ :next_month_text ] cal << %(<th colspan="2" class="ec-month-nav ec-next-month">#{options[:next_month_text]}</th>) end cal << %(</tr></thead></table>) end # body container (holds day names and the calendar rows) cal << %(<div class="ec-body" style="height: #{height}px;">) # day names cal << %(<table class="ec-day-names" style="height: #{options[:day_names_height]}px;" cellpadding="0" cellspacing="0">) cal << %(<tbody><tr>) day_names . each do | day_name | cal << %(<th class="ec-day-name" title="#{day_name}">#{day_name}</th>) end cal << %(</tr></tbody></table>) # container for all the calendar rows cal << %(<div class="ec-rows" style="top: #{options[:day_names_height]}px; ) cal << %(height: #{height - options[:day_names_height]}px;">) # initialize loop variables first_day_of_week = beginning_of_week ( first , options [ :first_day_of_week ] ) last_day_of_week = end_of_week ( first , options [ :first_day_of_week ] ) last_day_of_cal = end_of_week ( last , options [ :first_day_of_week ] ) row_num = 0 top = 0 # go through a week at a time, until we reach the end of the month while ( last_day_of_week <= last_day_of_cal ) cal << %(<div class="ec-row" style="top: #{top}px; height: #{row_heights[row_num]}px;">) top += row_heights [ row_num ] # this weeks background table cal << %(<table class="ec-row-bg" cellpadding="0" cellspacing="0">) cal << %(<tbody><tr>) first_day_of_week . upto ( first_day_of_week + 6 ) do | day | today_class = ( day == Date . today ) ? "ec-today-bg" : "" other_month_class = ( day < first ) || ( day > last ) ? 'ec-other-month-bg' : '' cal << %(<td class="ec-day-bg #{today_class} #{other_month_class}">&nbsp;</td>) end cal << %(</tr></tbody></table>) # calendar row cal << %(<table class="ec-row-table" cellpadding="0" cellspacing="0">) cal << %(<tbody>) # day numbers row cal << %(<tr>) first_day_of_week . upto ( last_day_of_week ) do | day | cal << %(<td class="ec-day-header ) cal << %(ec-today-header ) if options [ :show_today ] and ( day == Date . today ) cal << %(ec-other-month-header ) if ( day < first ) || ( day > last ) cal << %(ec-weekend-day-header) if weekend? ( day ) cal << %(" style="height: #{options[:day_nums_height]}px;">) if options [ :link_to_day_action ] cal << day_link ( day . day , day , options [ :link_to_day_action ] ) else cal << %(#{day.day}) end cal << %(</td>) end cal << %(</tr>) # event rows for this day # for each event strip, create a new table row options [ :event_strips ] . each do | strip | cal << %(<tr>) # go through through the strip, for the entries that correspond to the days of this week strip [ row_num 7 , 7 ] . each_with_index do | event , index | day = first_day_of_week + index if event # get the dates of this event that fit into this week dates = event . clip_range ( first_day_of_week , last_day_of_week ) # if the event (after it has been clipped) starts on this date, # then create a new cell that spans the number of days if dates [ 0 ] == day . to_date # check if we should display the bg color or not no_bg = no_event_bg? ( event , options ) class_name = event . class . name . tableize . singularize cal << %(<td class="ec-event-cell" colspan="#{(dates[1]-dates[0]).to_i + 1}" ) cal << %(style="padding-top: #{options[:event_margin]}px;">) cal << %(<div id="ec-#{class_name}-#{event.id}" class="ec-event ) if class_name != "event" cal << %(ec-#{class_name} ) end if no_bg cal << %(ec-event-no-bg" ) cal << %(style="color: #{event.color}; ) else cal << %(ec-event-bg" ) cal << %(style="background-color: #{event.color}; ) end cal << %(padding-top: #{options[:event_padding_top]}px; ) cal << %(height: #{options[:event_height] - options[:event_padding_top]}px;" ) if options [ :use_javascript ] # custom attributes needed for javascript event highlighting cal << %(data-event-id="#{event.id}" data-event-class="#{class_name}" data-color="#{event.color}" ) end cal << %(>) # add a left arrow if event is clipped at the beginning if event . start_at . to_date < dates [ 0 ] cal << %(<div class="ec-left-arrow"></div>) end # add a right arrow if event is clipped at the end if event . end_at . to_date > dates [ 1 ] cal << %(<div class="ec-right-arrow"></div>) end if no_bg cal << %(<div class="ec-bullet" style="background-color: #{event.color};"></div>) # make sure anchor text is the event color # here b/c CSS 'inherit' color doesn't work in all browsers cal << %(<style type="text/css">.ec-#{class_name}-#{event.id} a { color: #{event.color}; }</style>) end if block_given? # add the additional html that was passed as a block to this helper cal << block . call ( { :event => event , :day => day . to_date , :options => options } ) else # default content in case nothing is passed in cal << %(<a href="/#{class_name.pluralize}/#{event.id}" title="#{h(event.name)}">#{h(event.name)}</a>) end cal << %(</div></td>) end else # there wasn't an event, so create an empty cell and container cal << %(<td class="ec-event-cell ec-no-event-cell" ) cal << %(style="padding-top: #{options[:event_margin]}px;">) cal << %(<div class="ec-event" ) cal << %(style="padding-top: #{options[:event_padding_top]}px; ) cal << %(height: #{options[:event_height] - options[:event_padding_top]}px;" ) cal << %(>) cal << %(&nbsp;</div></td>) end end cal << %(</tr>) end cal << %(</tbody></table>) cal << %(</div>) # increment the calendar row we are on, and the week row_num += 1 first_day_of_week += 7 last_day_of_week += 7 end cal << %(</div>) cal << %(</div>) cal << %(</div>) end

1<CODESPLIT>https://github.com/hybridgroup/taskmapper/blob/80af7b43d955e7a9f360fec3b4137e2cd1b418d6/lib/taskmapper/helper.rb#L34-L47<CODESPLIT>TaskMapper::Provider.Helper.search_by_attribute<CODESPLIT>Goes through all the things and returns results that match the options attributes hash<CODESPLIT>def search_by_attribute ( things , options = { } , limit = 1000 ) things . find_all do | thing | options . inject ( true ) do | memo , kv | break unless memo key , value = kv begin memo &= thing . send ( key ) == value rescue NoMethodError memo = false end memo end and ( limit -= 1 ) > 0 end end

0<CODESPLIT>https://github.com/robertwahler/repo_manager/blob/d945f1cb6ac48b5689b633fcc029fd77c6a02d09/lib/repo_manager/tasks/task_manager.rb#L72-L99<CODESPLIT>RepoManager.TaskManager.task_help<CODESPLIT>load all the tasks in this gem plus the user s own repo_manager task folder<CODESPLIT>def task_help ( name ) load_tasks klass , task = find_by_namespace ( name ) # set '$thor_runner' to true to display full namespace $thor_runner = true klass . task_help ( shell , task ) end

0<CODESPLIT>https://github.com/glebm/i18n-tasks/blob/56b45e459d7d07bb19d613a17ffc1ce6f6f43cf5/lib/i18n/tasks/scanners/ruby_ast_scanner.rb#L150-L171<CODESPLIT>I18n::Tasks::Scanners.RubyAstScanner.make_buffer<CODESPLIT>Extract an array as a single string .<CODESPLIT>def make_buffer ( path , contents = read_file ( path ) ) Parser :: Source :: Buffer . new ( path ) . tap do | buffer | buffer . raw_source = contents end end

1<CODESPLIT>https://github.com/mwunsch/weary/blob/e36ce4f82d83cbc3d826eaa427acc5e66a0f849b/lib/weary/resource.rb#L146-L148<CODESPLIT>Weary.Resource.pull_url_pairs<CODESPLIT>Private : Separate the parameters needed to construct a url .<CODESPLIT>def pull_url_pairs ( params ) url . keys . map { | k | [ k , params . delete ( k ) || params . delete ( k . to_sym ) ] } end

1<CODESPLIT>https://github.com/softlayer/softlayer-ruby/blob/48d7e0e36a3b02d832e7e303a513020a8fbde93b/lib/softlayer/NetworkStorage.rb#L325-L334<CODESPLIT>SoftLayer.NetworkStorage.update_credential_password<CODESPLIT>Updates the password for the network storage credential of the username specified .<CODESPLIT>def update_credential_password ( username , password ) raise ArgumentError , "The new password cannot be nil" unless password raise ArgumentError , "The new username cannot be nil" unless username raise ArgumentError , "The new password cannot be empty" if password . empty? raise ArgumentError , "The new username cannot be empty" if username . empty? self . service . editCredential ( username . to_s , password . to_s ) @credentials = nil end

0<CODESPLIT>https://github.com/geekyfox/tdp/blob/13718e35a4539945c0b62313194cbf458a4e9ed5/lib/tdp.rb#L288-L298<CODESPLIT>TDP.DAO.apply<CODESPLIT>Registers a patch ( a Patch object ) as applied .<CODESPLIT>def apply ( patch ) @db << patch . content register ( patch ) rescue Sequel :: Error => ex raise Sequel :: Error , "Failed to apply patch #{patch.full_filename}: #{ex}" end

0<CODESPLIT>https://github.com/meew0/discordrb/blob/764298a1ff0be69a1853b510d736f21c2b91a2fe/lib/discordrb/bot.rb#L317-L338<CODESPLIT>Discordrb.Bot.voice_destroy<CODESPLIT>Connects to a voice channel initializes network connections and returns the { Voice :: VoiceBot } over which audio data can then be sent . After connecting the bot can also be accessed using { #voice } . If the bot is already connected to voice the existing connection will be terminated - you don t have to call { Discordrb :: Voice :: VoiceBot#destroy } before calling this method .<CODESPLIT>def voice_destroy ( server , destroy_vws = true ) server = server . resolve_id @gateway . send_voice_state_update ( server . to_s , nil , false , false ) @voices [ server ] . destroy if @voices [ server ] && destroy_vws @voices . delete ( server ) end

0<CODESPLIT>https://github.com/rightscale/right_link/blob/b33a209c20a8a0942dd9f1fe49a08030d4ca209f/lib/instance/cook/executable_sequence.rb#L191-L204<CODESPLIT>RightScale.ExecutableSequence.run<CODESPLIT>Determine inputs that need special security treatment .<CODESPLIT>def run @ok = true if @run_list . empty? # Deliberately avoid auditing anything since we did not run any recipes # Still download the cookbooks repos if in dev mode checkout_cookbook_repos download_cookbooks if CookState . cookbooks_path report_success ( nil ) else configure_ohai configure_logging configure_chef download_attachments if @ok install_packages if @ok checkout_cookbook_repos if @ok download_cookbooks if @ok update_cookbook_path if @ok # note that chef normally enforces path sanity before executing ohai in # the client run method. we create ohai before client run and some ohai # plugins behave badly when there is no ruby on the PATH. we need to do # a pre-emptive path sanity here before we start ohai and chef. enforce_path_sanity check_ohai { | o | converge ( o ) } if @ok end true rescue Exception => e report_failure ( 'Execution failed' , "The following exception was caught while preparing for execution: (#{e.message}) from\n#{e.backtrace.join("\n")}" ) end

0<CODESPLIT>https://github.com/sds/haml-lint/blob/024c773667e54cf88db938c2b368977005d70ee8/lib/haml_lint/tree/tag_node.rb#L100-L125<CODESPLIT>HamlLint.Linter::RuboCop.find_lints<CODESPLIT>Returns the source code for the static and dynamic attributes of a tag .<CODESPLIT>def find_lints ( ruby , source_map ) rubocop = :: RuboCop :: CLI . new filename = if document . file "#{document.file}.rb" else 'ruby_script.rb' end with_ruby_from_stdin ( ruby ) do extract_lints_from_offenses ( lint_file ( rubocop , filename ) , source_map ) end end

0<CODESPLIT>https://github.com/joshwlewis/unitwise/blob/f786d2e660721a0238949e7abce20852879de8ef/lib/unitwise/scale.rb#L104-L111<CODESPLIT>QML.Engine.evaluate<CODESPLIT>Convert to a simple string representing the scale .<CODESPLIT>def evaluate ( str , file = '<in QML::Engine#evaluate>' , lineno = 1 ) evaluate_impl ( str , file , lineno ) . tap do | result | raise result . to_error if result . is_a? ( JSObject ) && result . error? end end

0<CODESPLIT>https://github.com/donaldpiret/github-pivotal-flow/blob/676436950b691f57ad793a9023a4765ab9420dd0/lib/github_pivotal_flow/configuration.rb#L43-L53<CODESPLIT>ROF::Translators.OsfToRof.map_creator<CODESPLIT>Returns the user s Pivotal Tracker API token . If this token has not been configured prompts the user for the value . The value is checked for in the _inherited_ Git configuration but is stored in the _global_ Git configuration so that it can be used across multiple repositories .<CODESPLIT>def map_creator creator = [ ] ttl_data [ 0 ] [ @osf_map [ 'hasContributor' ] ] . each do | contributor | # Looping through the primary document and the contributors ttl_data . each do | item | next unless item [ '@id' ] == contributor [ '@id' ] if item [ @osf_map [ 'isBibliographic' ] ] [ 0 ] [ '@value' ] == 'true' creator . push map_user_from_ttl ( item [ @osf_map [ 'hasUser' ] ] [ 0 ] [ '@id' ] ) end end end creator end

1<CODESPLIT>https://github.com/UzxMx/api_warden/blob/78e4fa421abc5333da2df6903d736d8e4871483a/lib/api_warden/authentication.rb#L115-L121<CODESPLIT>ApiWarden.Authentication.ttl_for_access_token=<CODESPLIT>Set the ttl for access token .<CODESPLIT>def ttl_for_access_token = ( seconds ) raise_if_authentication_failed! key = @key_for_access_token value = @value_for_access_token ApiWarden . redis { | conn | conn . set ( key , value , ex : seconds ) } end

1<CODESPLIT>https://github.com/mare-imbrium/canis/blob/8bce60ff9dad321e299a6124620deb4771740b0b/lib/canis/core/widgets/table.rb#L483-L497<CODESPLIT>Canis.Table._calculate_column_offsets<CODESPLIT>This calculates and stores the offset at which each column starts . Used when going to next column or doing a find for a string in the table . TODO store this inside the hash so it s not calculated again in renderer<CODESPLIT>def _calculate_column_offsets @coffsets = [ ] total = 0 #@chash.each_pair { |i, c| #@chash.each_with_index { |c, i| #next if c.hidden each_column { | c , i | w = c . width @coffsets [ i ] = total c . offset = total # if you use prepare_format then use w+2 due to separator symbol total += w + 1 } end

0<CODESPLIT>https://github.com/haw-itn/openassets-ruby/blob/c2171ccb7e3bf2b8c712e9ef82a3bfaef3d1f4bf/lib/openassets/api.rb#L158-L164<CODESPLIT>OpenAssets.Api.send_assets<CODESPLIT>Creates a transaction for sending bitcoins from an address to another .<CODESPLIT>def send_assets ( from , send_asset_params , fees = nil , mode = 'broadcast' ) transfer_specs = send_asset_params . map { | param | colored_outputs = get_unspent_outputs ( [ oa_address_to_address ( param . from || from ) ] ) [ param . asset_id , OpenAssets :: Transaction :: TransferParameters . new ( colored_outputs , param . to , param . from || from , param . amount ) ] } btc_transfer_spec = OpenAssets :: Transaction :: TransferParameters . new ( get_unspent_outputs ( [ oa_address_to_address ( from ) ] ) , nil , oa_address_to_address ( from ) , 0 ) tx = create_tx_builder . transfer_assets ( transfer_specs , btc_transfer_spec , fees . nil? ? @config [ :default_fees ] : fees ) tx = process_transaction ( tx , mode ) tx end

0<CODESPLIT>https://github.com/pwnall/webkit_remote/blob/f38ac7e882726ff00e5c56898d06d91340f8179e/lib/webkit_remote/rpc.rb#L34-L50<CODESPLIT>Ons.Consumer.subscribe<CODESPLIT>Connects to the remote debugging server in a Webkit tab .<CODESPLIT>def subscribe ( topic , expression , handler = nil ) @consumer . subscribe ( topic , expression , handler || Proc . new ) self end

1<CODESPLIT>https://github.com/iyuuya/jkf/blob/4fd229c50737cab7b41281238880f1414e55e061/lib/jkf/parser/kifuable.rb#L560-L570<CODESPLIT>Jkf::Parser.Kifuable.transform_initialboard<CODESPLIT>transform initialboard to jkf<CODESPLIT>def transform_initialboard ( lines ) board = [ ] 9 . times do | i | line = [ ] 9 . times do | j | line << lines [ j ] [ 8 - i ] end board << line end { "preset" => "OTHER" , "data" => { "board" => board } } end

1<CODESPLIT>https://github.com/Mordorreal/SiteAnalyzer/blob/7b17f7c1651c2fe85dbc2088c28cf1ec94ffdefb/lib/site_analyzer/site.rb#L63-L69<CODESPLIT>SiteAnalyzer.Site.all_titles<CODESPLIT>get all titles on site and return array of them<CODESPLIT>def all_titles result = [ ] @pages . each do | page | result << [ page . page_url , page . all_titles ] if page . page_a_tags end result end

0<CODESPLIT>https://github.com/petebrowne/massimo/blob/c450edc531ad358f011da0a47e5d0bc9a038d911/lib/massimo/ui.rb#L35-L48<CODESPLIT>FreshdeskAPI.Client.method_missing<CODESPLIT>Run the given block and cleanly report any errors<CODESPLIT>def method_missing ( method , * args ) method = method . to_s method_class = method_as_class ( method ) options = args . last . is_a? ( Hash ) ? args . pop : { } FreshdeskAPI :: Collection . new ( self , method_class , options ) end

1<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_recovery_services_backup/lib/2016-06-01/generated/azure_mgmt_recovery_services_backup/item_level_recovery_connections.rb#L48-L51<CODESPLIT>Azure::RecoveryServicesBackup::Mgmt::V2016_06_01.ItemLevelRecoveryConnections.revoke<CODESPLIT>Revokes an iSCSI connection which can be used to download a script . Executing this script opens a file explorer displaying all recoverable files and folders . This is an asynchronous operation .<CODESPLIT>def revoke ( vault_name , resource_group_name , fabric_name , container_name , protected_item_name , recovery_point_id , custom_headers : nil ) response = revoke_async ( vault_name , resource_group_name , fabric_name , container_name , protected_item_name , recovery_point_id , custom_headers :custom_headers ) . value! nil end

0<CODESPLIT>https://github.com/igor-makarov/xcake/blob/4a16d5cf2662cfe1dc521b6818e441748ba5a02a/lib/xcake/dsl/project/sugar.rb#L126-L139<CODESPLIT>Xcake.Project.application_for<CODESPLIT>Defines a extension target .<CODESPLIT>def application_for ( platform , deployment_target , language = :objc ) target do | t | t . type = :application t . platform = platform t . deployment_target = deployment_target t . language = language yield ( t ) if block_given? end end

1<CODESPLIT>https://github.com/healthfinch/allscripts-unity-client/blob/fd9b7148cb6fe806a3f9dba70c138ba8c5e75985/lib/allscripts_unity_client/client.rb#L291-L311<CODESPLIT>AllscriptsUnityClient.Client.get_medication_by_trans_id<CODESPLIT>@param [ String ] userid the Allscripts EHR username .<CODESPLIT>def get_medication_by_trans_id ( userid , patientid , transaction_id ) magic_parameters = { action : 'GetMedicationByTransID' , userid : userid , patientid : patientid , parameter1 : transaction_id } result = magic ( magic_parameters ) if transaction_id == 0 || transaction_id == '0' # When transaction_id is 0 all medications should be # returned and the result should always be an array. if ! result . is_a? ( Array ) && ! result . empty? result = [ result ] elsif result . empty? result = [ ] end end result end

0<CODESPLIT>https://github.com/chef/chef-apply/blob/f3619c5af73714cfec942cbd1dae05c510c467e3/lib/chef_apply/startup.rb#L164-L174<CODESPLIT>ChefApply.CLI.connect_target<CODESPLIT>Look for a user - supplied config path by manually parsing the option . Note that we can t use Mixlib :: CLI for this . To ensure that ChefApply :: CLI initializes with correct option defaults we need to have configuraton loaded before initializing it .<CODESPLIT>def connect_target ( target_host , reporter ) connect_message = T . status . connecting ( target_host . user ) reporter . update ( connect_message ) do_connect ( target_host , reporter ) end

0<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_media_services/lib/2018-07-01/generated/azure_mgmt_media_services/live_events.rb#L269-L285<CODESPLIT>Azure::Network::Mgmt::V2016_12_01.VirtualNetworkGateways.begin_get_advertised_routes_with_http_info<CODESPLIT>@param resource_group_name [ String ] The name of the resource group within the Azure subscription . @param account_name [ String ] The Media Services account name . @param live_event_name [ String ] The name of the Live Event . @param parameters [ LiveEvent ] Live Event properties needed for creation . @param auto_start [ Boolean ] The flag indicates if the resource should be automatically started on creation . @param custom_headers [ Hash { String = > String } ] A hash of custom headers that will be added to the HTTP request .<CODESPLIT>def begin_get_advertised_routes_with_http_info ( resource_group_name , virtual_network_gateway_name , peer , custom_headers : nil ) begin_get_advertised_routes_async ( resource_group_name , virtual_network_gateway_name , peer , custom_headers :custom_headers ) . value! end

1<CODESPLIT>https://github.com/jmettraux/ruote/blob/30a6bb88a4e48ed2e1b9089754f1c8be8c1a879c/lib/ruote/worker.rb#L590-L607<CODESPLIT>Ruote.Worker.respark<CODESPLIT>This action resparks a stalled workflow instance . It s usually triggered via Dashboard#respark<CODESPLIT>def respark ( msg ) wfid = msg [ 'wfid' ] opts = msg [ 'respark' ] ps = ProcessStatus . fetch ( @context , [ wfid ] , { } ) . first error_feis = ps . errors . collect ( :fei ) errors_too = ! ! opts [ 'errors_too' ] ps . leaves . each do | fexp | next if errors_too == false && error_feis . include? ( fexp . fei ) @context . storage . put_msg ( 'cancel' , 'fei' => fexp . fei . to_h , 're_apply' => { } ) end end

0<CODESPLIT>https://github.com/philou/rspecproxies/blob/7bb32654f1c4d0316e9f89161a95583333a3a66f/lib/rspecproxies/proxy_chains.rb#L19-L28<CODESPLIT>SvnFixture.Revision.commit<CODESPLIT>Same as #proxy_message_chain but using an array of symbols as message_chain instead of a dot separated string<CODESPLIT>def commit ( repo ) # First, ensure everything up-to-date # The fourth argument as true tells update to ignore externals. repo . ctx . update ( repo . wc_path , "HEAD" , nil , true ) root = Directory . new ( repo . ctx , repo . wc_path ) root . instance_eval ( @block ) if @block ci = repo . ctx . ci ( repo . wc_path ) unless ci . revision == Svn :: Core :: INVALID_REVNUM rev = ci . revision repo . repos . fs . set_prop ( 'svn:log' , @message , rev ) if @message repo . repos . fs . set_prop ( 'svn:author' , @author , rev ) if @author repo . repos . fs . set_prop ( 'svn:date' , @date , rev ) if @date @revprops . each do | key , val | val = SvnFixture . svn_time ( val ) if val . respond_to? ( :strftime ) repo . repos . fs . set_prop ( key . to_s , val . to_s , rev ) end else puts "Warning: No change in revision #{name} (SvnFixture::Revision#commit)" end return true end

1<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_data_migration/lib/2018-04-19/generated/azure_mgmt_data_migration/services.rb#L586-L589<CODESPLIT>Azure::DataMigration::Mgmt::V2018_04_19.Services.nested_check_name_availability<CODESPLIT>Check nested resource name validity and availability<CODESPLIT>def nested_check_name_availability ( group_name , service_name , parameters , custom_headers : nil ) response = nested_check_name_availability_async ( group_name , service_name , parameters , custom_headers :custom_headers ) . value! response . body unless response . nil? end

1<CODESPLIT>https://github.com/redinger/validation_reflection/blob/7c3397e3a6ab32773cf7399455e5c63a0fdc66e9/lib/validation_reflection.rb#L81-L87<CODESPLIT>ValidationReflection.ClassMethods.remember_validation_metadata<CODESPLIT>Store validation info for easy and fast access .<CODESPLIT>def remember_validation_metadata ( validation_type , * attr_names ) configuration = attr_names . last . is_a? ( :: Hash ) ? attr_names . pop : { } self . validations ||= [ ] attr_names . flatten . each do | attr_name | self . validations << :: ActiveRecord :: Reflection :: MacroReflection . new ( validation_type , attr_name . to_sym , configuration , self ) end end

1<CODESPLIT>https://github.com/LAS-IT/open_directory_utils/blob/dd29b04728fa261c755577af066c9f817642998a/lib/open_directory_utils/commands_user_attribs.rb#L323-L335<CODESPLIT>OpenDirectoryUtils.CommandsUserAttribs.user_disable_login<CODESPLIT>/ usr / bin / pwpolicy - a diradmin - p A - B1g - S3cret - u $shortname_USERNAME - setpolicy isDisabled = 1<CODESPLIT>def user_disable_login ( attribs , dir_info ) attribs = user_record_name_alternatives ( attribs ) check_critical_attribute ( attribs , :record_name ) attribs = tidy_attribs ( attribs ) command = { attribute : 'disableuser' , value : nil } params = command . merge ( attribs ) # pwpolicy(params, dir_info) answer = pwpolicy ( params , dir_info ) attribs [ :value ] = nil return answer end

1<CODESPLIT>https://github.com/loadsmart/danger-pep8/blob/cc6b236fabed72f42a521b31d5ed9be012504a4f/lib/pep8/plugin.rb#L76-L84<CODESPLIT>Danger.DangerPep8.count_errors<CODESPLIT>Triggers a warning / failure if total lint errors found exceedes<CODESPLIT>def count_errors ( should_fail = false ) ensure_flake8_is_installed total_errors = run_flake ( :count => true ) . first . to_i if total_errors > threshold message = "#{total_errors} PEP 8 issues found" should_fail ? fail ( message ) : warn ( message ) end end

0<CODESPLIT>https://github.com/leoc/em-systemcommand/blob/e1987253527c4b4dcc8ca7fe5ce6a16235f4810d/lib/em-systemcommand.rb#L63-L83<CODESPLIT>ActiveRecordTranslatable.ClassMethods.translate<CODESPLIT>Executes the command from the Builder object . If there had been given a block at instantiation it will be called after the popen3 call and after the pipes have been attached .<CODESPLIT>def translate ( * attributes ) self . _translatable ||= Hash . new { | h , k | h [ k ] = [ ] } self . _translatable [ base_name ] = translatable . concat ( attributes ) . uniq end

1<CODESPLIT>https://github.com/rightscale/right_link/blob/b33a209c20a8a0942dd9f1fe49a08030d4ca209f/lib/instance/instance_commands.rb#L468-L474<CODESPLIT>RightScale.InstanceCommands.send_push<CODESPLIT>Helper method to send a request to one or more targets with no response expected See Sender for details<CODESPLIT>def send_push ( type , conn , payload = nil , target = nil , options = { } ) payload ||= { } payload [ :agent_identity ] = @agent_identity Sender . instance . send_push ( type , payload , target , options ) CommandIO . instance . reply ( conn , 'OK' ) true end

0<CODESPLIT>https://github.com/rails/rails/blob/85a8bc644be69908f05740a5886ec19cd3679df5/actionpack/lib/abstract_controller/rendering.rb#L116-L121<CODESPLIT>AbstractController.Translation.translate<CODESPLIT>Normalize args and options .<CODESPLIT>def translate ( key , options = { } ) options = options . dup if key . to_s . first == "." path = controller_path . tr ( "/" , "." ) defaults = [ :" #{ path } #{ key } " ] defaults << options [ :default ] if options [ :default ] options [ :default ] = defaults . flatten key = "#{path}.#{action_name}#{key}" end I18n . translate ( key , options ) end

0<CODESPLIT>https://github.com/bcobb/and_feathers/blob/f35b156f8ae6930851712bbaf502f97b3aa9a1b1/lib/and_feathers/directory.rb#L145-L153<CODESPLIT>AndFeathers.Directory.|<CODESPLIT>Iterates through this + Directory + s children depth - first<CODESPLIT>def | ( other ) if ! other . is_a? ( Directory ) raise ArgumentError , "#{other} is not a Directory" end dup . tap do | directory | other . files . each do | file | directory . add_file ( file . dup ) end other . directories . each do | new_directory | existing_directory = @directories [ new_directory . name ] if existing_directory . nil? directory . add_directory ( new_directory . dup ) else directory . add_directory ( new_directory | existing_directory ) end end end end

0<CODESPLIT>https://github.com/erector/erector/blob/59754211101b2c50a4c9daa8e64a64e6edc9e976/lib/erector/convenience.rb#L62-L89<CODESPLIT>FinanceMath.Loan.pmt<CODESPLIT>Emits a javascript block inside a + script + tag wrapped in CDATA doohickeys like all the cool JS kids do .<CODESPLIT>def pmt ( options = { } ) future_value = options . fetch ( :future_value , 0 ) type = options . fetch ( :type , 0 ) ( ( @amount * interest ( @monthly_rate , @duration ) - future_value ) / ( ( 1.0 + @monthly_rate * type ) * fvifa ( @monthly_rate , duration ) ) ) end

0<CODESPLIT>https://github.com/piotrmurach/tty/blob/872fa26d321d95b48807569f25cb1633f6fecd17/lib/tty/plugins/plugin.rb#L37-L46<CODESPLIT>TTY.Plugins.names<CODESPLIT>Load the plugin ( require the gem )<CODESPLIT>def names plugins . reduce ( { } ) do | hash , plugin | hash [ plugin . name ] = plugin hash end end

0<CODESPLIT>https://github.com/tbuehlmann/ponder/blob/930912e1b78b41afa1359121aca46197e9edff9c/lib/ponder/user.rb#L11-L51<CODESPLIT>Lazymodel.Base.attributes<CODESPLIT>Updates the properties of an user .<CODESPLIT>def attributes _attributes . inject ( HashWithIndifferentAccess . new ) do | hash , attribute | hash . update attribute => send ( attribute ) end end

0<CODESPLIT>https://github.com/dicom/ruby-dicom/blob/3ffcfe21edc8dcd31298f945781990789fc832ab/lib/dicom/anonymizer.rb#L162-L177<CODESPLIT>DICOM.Anonymizer.anonymize<CODESPLIT>Anonymizes any DICOM files found at the given path ( file or directory ) with the settings of this Anonymizer instance .<CODESPLIT>def anonymize ( dicom ) dicom = Array [ dicom ] unless dicom . respond_to? ( :to_ary ) if @tags . length > 0 prepare_anonymization dicom . each do | dcm | anonymize_dcm ( dcm . to_dcm ) end else logger . warn ( "No tags have been selected for anonymization. Aborting anonymization." ) end # Save the audit trail (if used): @audit_trail . write ( @audit_trail_file ) if @audit_trail logger . info ( "Anonymization complete." ) dicom end

1<CODESPLIT>https://github.com/aws/aws-sdk-ruby/blob/e28b8d320ddf7b6ee0161bdd9d00fb786d99b63d/gems/aws-sdk-ec2/lib/aws-sdk-ec2/classic_address.rb#L265-L269<CODESPLIT>Aws::EC2.ClassicAddress.associate<CODESPLIT>@!group Actions @example Request syntax with placeholder values<CODESPLIT>def associate ( options = { } ) options = options . merge ( public_ip : @public_ip ) resp = @client . associate_address ( options ) resp . data end

0<CODESPLIT>https://github.com/khiemns54/sp2db/blob/76c78df07ea19d6f1b5ff2e883ae206a0e94de27/lib/sp2db/base_table.rb#L161-L165<CODESPLIT>Sp2db.BaseTable.raw_filter<CODESPLIT>Convert number string to number<CODESPLIT>def raw_filter raw_data , opts = { } raw_header = raw_data [ header_row ] . map . with_index do | h , idx | is_valid = valid_header? ( h ) { idx : idx , is_remove : ! is_valid , is_required : require_header? ( h ) , name : is_valid && h . gsub ( / \s / , '' ) . gsub ( / / , '' ) . downcase } end rows = raw_data [ ( header_row + 1 ) .. - 1 ] . map . with_index do | raw , rdx | row = { } . with_indifferent_access raw_header . each do | h | val = raw [ h [ :idx ] ] next if h [ :is_remove ] if h [ :is_required ] && val . blank? row = { } break end row [ h [ :name ] ] = standardize_cell_val val end next if row . values . all? ( :blank? ) row [ :id ] = rdx + 1 if find_columns . include? ( :id ) && row [ :id ] . blank? row end . compact . reject ( :blank? ) rows = rows . select do | row | if required_columns . present? required_columns . all? { | col | row [ col ] . present? } else true end end rows end

1<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_sql/lib/2017-10-01-preview/generated/azure_mgmt_sql/managed_instance_keys.rb#L272-L288<CODESPLIT>Azure::SQL::Mgmt::V2017_10_01_preview.ManagedInstanceKeys.create_or_update_async<CODESPLIT>@param resource_group_name [ String ] The name of the resource group that contains the resource . You can obtain this value from the Azure Resource Manager API or the portal . @param managed_instance_name [ String ] The name of the managed instance . @param key_name [ String ] The name of the managed instance key to be operated on ( updated or created ) . @param parameters [ ManagedInstanceKey ] The requested managed instance key resource state . @param custom_headers [ Hash { String = > String } ] A hash of custom headers that will be added to the HTTP request .<CODESPLIT>def create_or_update_async ( resource_group_name , managed_instance_name , key_name , parameters , custom_headers : nil ) # Send request promise = begin_create_or_update_async ( resource_group_name , managed_instance_name , key_name , parameters , custom_headers :custom_headers ) promise = promise . then do | response | # Defining deserialization method. deserialize_method = lambda do | parsed_response | result_mapper = Azure :: SQL :: Mgmt :: V2017_10_01_preview :: Models :: ManagedInstanceKey . mapper ( ) parsed_response = @client . deserialize ( result_mapper , parsed_response ) end # Waiting for response. @client . get_long_running_operation_result ( response , deserialize_method ) end promise end

0<CODESPLIT>https://github.com/cespare/pinion/blob/6dea89da573cef93793a8d9b76e2e692581bddcf/lib/pinion/server.rb#L45-L109<CODESPLIT>Pinion.Server.asset_url<CODESPLIT>Boilerplate mostly stolen from sprockets https : // github . com / sstephenson / sprockets / blob / master / lib / sprockets / server . rb<CODESPLIT>def asset_url ( path ) path . sub! ( %r[ #{ @mount_point } ] , "" ) mounted_path = "#{@mount_point}/#{path}" return mounted_path unless Pinion . environment == "production" # Add on a checksum tag in production asset = Asset [ path ] raise "Error: no such asset available: #{path}" unless asset mounted_path , dot , extension = mounted_path . rpartition ( "." ) return mounted_path if dot . empty? "#{mounted_path}-#{asset.checksum}.#{extension}" end

1<CODESPLIT>https://github.com/socializer/socializer/blob/f9c3ee2ca26ca837d9f328815997c2ddface25fc/app/services/socializer/audience_list.rb#L123-L128<CODESPLIT>Socializer.AudienceList.privacy_hash<CODESPLIT>Returns a { Hash } containing the value and text for the privacy level<CODESPLIT>def privacy_hash ( privacy_symbol : ) privacy_symbol = privacy_symbol . downcase . to_sym privacy = Audience . privacy . find_value ( privacy_symbol ) { id : privacy . value , name : privacy . text } end

0<CODESPLIT>https://github.com/fabiokr/manageable/blob/9db47dea0e2e73e164923de23be20109fe1cf35f/app/controllers/manageable/application_controller.rb#L50-L53<CODESPLIT>Hyperb.HostConfig.fmt<CODESPLIT>Custom respond_with wich stores resources for later use<CODESPLIT>def fmt formated = { } attrs . each_key do | key | formated [ camelize ( key ) ] = attrs [ key ] end formated end

0<CODESPLIT>https://github.com/chrisbloom7/enumpath/blob/f5b6cdecd2a985baf89c03ac3566af5eab461932/lib/enumpath/path.rb#L46-L56<CODESPLIT>DataMapper.Model.generate<CODESPLIT>Applies the next normalized path segment to enumerable and keeps track of resolved path segments . This method recursively yields to itself via each Operator subclass s { #apply } method . If there are no remaining path segments then it stores a new result in the results array effectively ending processing on that branch of the original enumerator .<CODESPLIT>def generate ( name = default_fauxture_name , attributes = { } ) name , attributes = default_fauxture_name , name if name . is_a? Hash Sweatshop . create ( self , name , attributes ) end

1<CODESPLIT>https://github.com/bleonard/daily/blob/0de33921da7ae678f09e782017eee33df69771e7/app/formatters/html_formatter.rb#L20-L27<CODESPLIT>Ruport.Formatter::HTML.build_table_header<CODESPLIT>Generates table headers based on the column names of your Data :: Table .<CODESPLIT>def build_table_header output << "\t<table>\n" unless data . column_names . empty? || ! options . show_table_headers output << "\t\t<tr>\n\t\t\t<th>" + safe_join ( data . column_names , "</th>\n\t\t\t<th>" ) + "</th>\n\t\t</tr>\n" end end

1<CODESPLIT>https://github.com/movitto/rjr/blob/219f970fbe3a1298d59fc820fdcf968d527fd567/lib/rjr/util/thread_pool.rb#L99-L115<CODESPLIT>RJR.ThreadPool.launch_worker<CODESPLIT>Internal helper launch worker thread<CODESPLIT>def launch_worker @worker_threads << Thread . new { while work = @work_queue . pop begin #RJR::Logger.debug "launch thread pool job #{work}" @running_queue << work work . exec ( @thread_lock ) # TODO cleaner / more immediate way to pop item off running_queue #RJR::Logger.debug "finished thread pool job #{work}" rescue Exception => e # FIXME also send to rjr logger at a critical level puts "Thread raised Fatal Exception #{e}" puts "\n#{e.backtrace.join("\n")}" end end } end

0<CODESPLIT>https://github.com/piotrmurach/tty-config/blob/08c4109cdfa3e7caed1368174ef4c4cb96239f4e/lib/tty/config.rb#L318-L333<CODESPLIT>TTY.Config.validate<CODESPLIT>Define an alias to a nested key<CODESPLIT>def validate ( * keys , & validator ) key = flatten_keys ( keys ) values = validators [ key ] || [ ] values << validator validators [ key ] = values end

0<CODESPLIT>https://github.com/appium/ruby_lib/blob/1f5898400dd1928bfe42ddd5f842d1f8738f2f76/lib/appium_lib/driver.rb#L375-L382<CODESPLIT>Appium.Driver.start_driver<CODESPLIT>Returns the server s version info<CODESPLIT>def start_driver ( http_client_ops = { http_client : :: Appium :: Http :: Default . new , open_timeout : 999_999 , read_timeout : 999_999 } ) @core . quit_driver # If automationName is set only in server side, then the following automation_name should be nil before # starting driver. automation_name = @core . automation_name @driver = @core . start_driver ( server_url : server_url , http_client_ops : http_client_ops ) @http_client = @core . http_client # if automation_name was nil before start_driver, then re-extend driver specific methods # to be able to extend correctly. extend_for ( device : @core . device , automation_name : @core . automation_name ) if automation_name . nil? @appium_server_status = appium_server_version @driver end

0<CODESPLIT>https://github.com/zl4bv/packer-client/blob/e925f03572425ffeaa9901d8014b445cdea64f9f/lib/packer/client.rb#L108-L112<CODESPLIT>Packer.Client.push<CODESPLIT>Excutes + packer inspect +<CODESPLIT>def push ( template , options = { } ) args = [ 'push' ] args << "-message=#{options[:message]}" if options . key? ( :message ) args << "-name=#{options[:name]}" if options . key? ( :name ) args << "-token=#{options[:token]}" if options . key? ( :token ) args << "-var-file=#{options[:var_file]}" if options . key? ( :var_file ) vars = options [ :vars ] || { } vars . each { | key , val | args << "-var '#{key}=#{val}'" } args << template Packer :: Output :: Push . new ( command ( args , options [ :live_stream ] ) ) end

0<CODESPLIT>https://github.com/slim-template/slim/blob/ae8e7338fcfb67256d2f6b50c64fc317210e31a2/lib/slim/do_inserter.rb#L17-L20<CODESPLIT>Slim.DoInserter.on_slim_output<CODESPLIT>Handle control expression [ : slim : control code content ]<CODESPLIT>def on_slim_output ( escape , code , content ) code = code + ' do' unless code =~ BLOCK_REGEX || empty_exp? ( content ) [ :slim , :output , escape , code , compile ( content ) ] end

1<CODESPLIT>https://github.com/activeadmin/activeadmin/blob/0759c8dcf97865748c9344459162ac3c7e65a6cd/lib/active_admin/router.rb#L30-L35<CODESPLIT>ActiveAdmin.Router.define_resources_routes<CODESPLIT>Defines the routes for each resource<CODESPLIT>def define_resources_routes resources = namespaces . flat_map { | n | n . resources . values } resources . each do | config | define_resource_routes ( config ) end end

0<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_event_grid/lib/2019-02-01-preview/generated/azure_mgmt_event_grid/domains.rb#L477-L480<CODESPLIT>Azure::EventGrid::Mgmt::V2019_02_01_preview.Domains.update<CODESPLIT>List keys for a domain<CODESPLIT>def update ( resource_group_name , domain_name , domain_update_parameters , custom_headers : nil ) response = update_async ( resource_group_name , domain_name , domain_update_parameters , custom_headers :custom_headers ) . value! response . body unless response . nil? end

0<CODESPLIT>https://github.com/userhello/bit_magic/blob/78b7fc28313af9c9506220812573576d229186bb/lib/bit_magic/bits_generator.rb#L63-L78<CODESPLIT>EmailChecker.Domain.mx_servers<CODESPLIT>Initialize the generator .<CODESPLIT>def mx_servers return @mx_servers if @mx_servers @mx_servers = [ ] mx_records . each do | mx | @mx_servers . push ( preference : mx . preference , address : mx . exchange . to_s ) end @mx_servers end

0<CODESPLIT>https://github.com/puppetlabs/puppet/blob/4baeed97cbb7571ddc6635f0a24debe2e8b22cd3/lib/puppet/type.rb#L2643-L2657<CODESPLIT>Puppet.Type.finish<CODESPLIT>Convert this resource type instance to a Puppet :: Resource .<CODESPLIT>def finish # Call post_compile hook on every parameter that implements it. This includes all subclasses # of parameter including, but not limited to, regular parameters, metaparameters, relationship # parameters, and properties. eachparameter do | parameter | parameter . post_compile if parameter . respond_to? :post_compile end # Make sure all of our relationships are valid.  Again, must be done # when the entire catalog is instantiated. self . class . relationship_params . collect do | klass | if param = @parameters [ klass . name ] param . validate_relationship end end . flatten . reject { | r | r . nil? } end

1<CODESPLIT>https://github.com/kwi/BrB/blob/1ae0c82fc44759627f2145fd9e02092b37e19d69/lib/brb/request.rb#L16-L56<CODESPLIT>BrB.Request.new_brb_out_request<CODESPLIT>Execute a request on a distant object<CODESPLIT>def new_brb_out_request ( meth , * args , & blck ) Thread . current [ :brb_nb_out ] ||= 0 Thread . current [ :brb_nb_out ] += 1 raise BrBCallbackWithBlockingMethodException . new if is_brb_request_blocking? ( meth ) and block_given? block = ( is_brb_request_blocking? ( meth ) or block_given? ) ? Thread . current . to_s . to_sym : nil if block args << block args << Thread . current [ :brb_nb_out ] end if block_given? # Simulate a method with _block in order to make BrB send the answer  meth = "#{meth}_block" . to_sym end args . size > 0 ? brb_send ( [ MessageRequestCode , meth , args ] ) : brb_send ( [ MessageRequestCode , meth ] ) if block_given? # Declare the callback  declare_callback ( block , Thread . current [ :brb_nb_out ] , blck ) elsif block # Block until the request return  #TimeMonitor.instance.watch_thread!(@timeout_rcv_value || 45)  begin r = recv ( block , Thread . current [ :brb_nb_out ] , blck ) rescue Exception => e raise e ensure #TimeMonitor.instance.remove_thread!  end if r . kind_of? Exception raise r end return r end nil end

1<CODESPLIT>https://github.com/plusplus/same_same/blob/24f5d7ced9a5e2fabbe4f58ed1b47a6c12ac5954/lib/same_same/merge_goodness_measure.rb#L15-L21<CODESPLIT>SameSame.MergeGoodnessMeasure.g<CODESPLIT>th should be > = 0 and < = 1 0 means all datapoints are neighbours 1 means no datapoints are neighbours ( proximity )<CODESPLIT>def g ( number_of_links , size_x , size_y ) a = ( size_x + size_y ) ** p b = size_x ** p c = size_x ** p number_of_links / ( a - b - c ) end

1<CODESPLIT>https://github.com/carsomyr/percolate/blob/7c9e38ca5e3b62a7a6c6d470945c694499316dc9/lib/percolate/percolator.rb#L71-L88<CODESPLIT>Percolate.Percolator.find<CODESPLIT>Finds an entity or entities .<CODESPLIT>def find ( context , facet_name , * args ) facet = find_facet ( context , facet_name ) if ! facet return nil end case result = facet . find ( args ) when Array result . map { | item | @entities [ item ] } when String @entities [ result ] when NilClass nil else raise "Bad facet return type #{result.class.name.dump}" end end

1<CODESPLIT>https://github.com/AlexWayfer/flame/blob/aecb2bb22b43abf4d99a36ea580d67923e3a6564/lib/flame/path.rb#L113-L119<CODESPLIT>Flame.Path.to_routes_with_endpoint<CODESPLIT>Path parts as keys of nested Hashes<CODESPLIT>def to_routes_with_endpoint endpoint = parts . reduce ( result = Flame :: Router :: Routes . new ) do | hash , part | hash [ part ] ||= Flame :: Router :: Routes . new end [ result , endpoint ] end

0<CODESPLIT>https://github.com/nerab/pwl/blob/ef22d0f43be90c63d0a30564122c31c49148f89c/lib/pwl/locker.rb#L162-L170<CODESPLIT>Pwl.Locker.add<CODESPLIT>Delete the value that is stored under key and return it<CODESPLIT>def add ( entry_or_key , value = nil ) if value . nil? and entry_or_key . is_a? ( Entry ) # treat as entry entry = entry_or_key else entry = Entry . new ( entry_or_key ) entry . password = value end entry . validate! @backend . transaction { timestamp! ( :last_modified ) @backend [ :user ] [ encrypt ( entry . name ) ] = encrypt ( EntryMapper . to_json ( entry ) ) } end

0<CODESPLIT>https://github.com/listia/walmart_open/blob/f563da4ae7b620d7c3c52ebafb6af50a77d614b2/lib/walmart_open/request.rb#L71-L77<CODESPLIT>NbaStats.BoxScoreMisc.box_score_misc<CODESPLIT>Converts foo_bar_param to fooBarParam .<CODESPLIT>def box_score_misc ( game_id , range_type = 0 , start_period = 0 , end_period = 0 , start_range = 0 , end_range = 0 ) NbaStats :: Resources :: BoxScoreMisc . new ( get ( BOX_SCORE_MISC_PATH , { :GameID => game_id , :RangeType => range_type , :StartPeriod => start_period , :EndPeriod => end_period , :StartRange => start_range , :EndRange => end_range } ) ) end

1<CODESPLIT>https://github.com/davetron5000/methadone/blob/2e670ac24cee3ab8658a1de62a70ff58e7806dc5/lib/methadone/cli.rb#L67-L84<CODESPLIT>Methadone.CLI.copy_file<CODESPLIT>Copies a file running it through ERB<CODESPLIT>def copy_file ( relative_path , options = { } ) options [ :from ] ||= :full relative_path = File . join ( relative_path . split ( / \/ / ) ) template_path = File . join ( template_dir ( options [ :from ] ) , relative_path + ".erb" ) template = ERB . new ( File . open ( template_path ) . readlines . join ( '' ) ) relative_path_parts = File . split ( relative_path ) relative_path_parts [ - 1 ] = options [ :as ] if options [ :as ] erb_binding = options [ :binding ] or binding File . open ( File . join ( relative_path_parts ) , 'w' ) do | file | file . puts template . result ( erb_binding ) file . chmod ( 0755 ) if options [ :executable ] end end

0<CODESPLIT>https://github.com/stormbrew/user_input/blob/593a1deb08f0634089d25542971ad0ac57542259/lib/user_input/type_safe_hash.rb#L60-L67<CODESPLIT>UserInput.TypeSafeHash.each_match<CODESPLIT>Enumerates the key value pairs in the has .<CODESPLIT>def each_match ( regex , type , default = nil ) real_hash . each_key ( ) { | key | if ( matchinfo = regex . match ( key ) ) value = fetch ( key , type , default ) if ( ! value . nil? ) yield ( matchinfo , value ) end end } end

1<CODESPLIT>https://github.com/maestrano/mno-enterprise/blob/bd957f523959531926e2bf844608d77addef2047/core/app/models/mno_enterprise/base_resource.rb#L119-L124<CODESPLIT>MnoEnterprise.BaseResource.clear_association_cache<CODESPLIT>Clear the record association cache<CODESPLIT>def clear_association_cache self . class . associations [ :has_many ] . each do | assoc | instance_variable_set ( :" #{ assoc [ :name ] } " , nil ) attributes . delete ( assoc [ :name ] . to_s ) end end

1<CODESPLIT>https://github.com/cisco/cisco-network-node-utils/blob/a617a9ef9d6bd18f35f2e2f2591033e1ddd46145/lib/cisco_node_utils/bgp_af.rb#L172-L179<CODESPLIT>Cisco.RouterBgpAF.dampen_igp_metric<CODESPLIT>dampen_igp_metric ( Getter / Setter / Default )<CODESPLIT>def dampen_igp_metric match = config_get ( 'bgp_af' , 'dampen_igp_metric' , @get_args ) if match . is_a? ( Array ) return nil if match [ 0 ] == 'no ' return match [ 1 ] . to_i if match [ 1 ] end default_dampen_igp_metric end

0<CODESPLIT>https://github.com/customink/strainer/blob/5a49c4f7896e35e402777395b8160a0b5623546d/lib/strainer/command.rb#L60-L77<CODESPLIT>Strainer.Command.inside<CODESPLIT>Parse a command out of the given string ( line )<CODESPLIT>def inside ( & block ) if COOKBOOK_COMMANDS . any? { | c | command =~ / #{ c } / } Strainer . ui . debug "Detected '#{command}' should be run from inside the cookbook" inside_cookbook ( block ) else Strainer . ui . debug "Detected '#{command}' should be run from inside the sandbox" inside_sandbox ( block ) end end

1<CODESPLIT>https://github.com/itrp/itrp-client/blob/80294aa93d7a64c1966d06d4f12ed24b606e3078/lib/itrp/client.rb#L78-L94<CODESPLIT>Itrp.Client.each<CODESPLIT>Yield all retrieved resources one - by - one for the given ( paged ) API query . Raises an :: Itrp :: Exception with the response retrieved from ITRP is invalid Returns total nr of resources yielded ( for logging )<CODESPLIT>def each ( path , params = { } , header = { } , & block ) # retrieve the resources using the max page size (least nr of API calls) next_path = expand_path ( path , { per_page : MAX_PAGE_SIZE , page : 1 } . merge ( params ) ) size = 0 while next_path # retrieve the records (with retry and optionally wait for rate-limit) response = get ( next_path , { } , header ) # raise exception in case the response is invalid raise :: Itrp :: Exception . new ( response . message ) unless response . valid? # yield the resources response . json . each { | resource | yield resource } size += response . json . size # go to the next page next_path = response . pagination_relative_link ( :next ) end size end

1<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/data/azure_service_fabric/lib/6.2.0.9/generated/azure_service_fabric/service_fabric_client_apis.rb#L26475-L26477<CODESPLIT>Azure::ServiceFabric::V6_2_0_9.ServiceFabricClientAPIs.get_sub_name_info_list_with_http_info<CODESPLIT>Enumerates all the Service Fabric names under a given name .<CODESPLIT>def get_sub_name_info_list_with_http_info ( name_id , recursive : false , continuation_token : nil , timeout : 60 , custom_headers : nil ) get_sub_name_info_list_async ( name_id , recursive : recursive , continuation_token :continuation_token , timeout : timeout , custom_headers :custom_headers ) . value! end

1<CODESPLIT>https://github.com/ElMassimo/presenter_rails/blob/6dd1b8c0c96b3ecb32e3eebd2ca08804a5b52fe8/lib/presenter_rails/controller.rb#L10-L24<CODESPLIT>PresenterRails.Controller.present<CODESPLIT>Public : Defines a method and makes it available to the view context under the specified name as a memoized variable .<CODESPLIT>def present ( name , & block ) presenter_method = PresenterRails . method_name_for ( name ) ivar = PresenterRails . ivar_for ( name ) private define_method ( presenter_method ) { unless instance_variable_defined? ( ivar ) instance_variable_set ( ivar , instance_exec ( block ) ) end instance_variable_get ( ivar ) } helper Module . new { define_method ( name ) { controller . send ( presenter_method ) } } end

0<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/data/azure_cognitiveservices_luisauthoring/lib/2.0/generated/azure_cognitiveservices_luisauthoring/model.rb#L2529-L2532<CODESPLIT>Azure::CognitiveServices::LuisAuthoring::V2_0.Model.update_hierarchical_entity_with_http_info<CODESPLIT>Updates the name and children of a hierarchical entity model in a version of the application .<CODESPLIT>def update_hierarchical_entity_with_http_info ( app_id , version_id , h_entity_id , hierarchical_model_update_object , custom_headers : nil ) update_hierarchical_entity_async ( app_id , version_id , h_entity_id , hierarchical_model_update_object , custom_headers :custom_headers ) . value! end

0<CODESPLIT>https://github.com/voltrb/volt/blob/f942b92385adbc894ee4a37903ee6a9c1a65e9a4/lib/volt/server/html_parser/attribute_scope.rb#L29-L41<CODESPLIT>Volt.AttributeScope.binding_parts_and_count<CODESPLIT>Take the attributes and create any bindings<CODESPLIT>def binding_parts_and_count ( value ) if value . is_a? ( String ) parts = value . split ( / \{ \{ \} \} \} / ) . reject ( :blank? ) else parts = [ '' ] end binding_count = parts . count { | p | p [ 0 ] == '{' && p [ 1 ] == '{' && p [ - 2 ] == '}' && p [ - 1 ] == '}' } [ parts , binding_count ] end

0<CODESPLIT>https://github.com/piotrmurach/finite_machine/blob/e54b9397e74aabd502672afb838a5ceb2d3caa2f/lib/finite_machine/transition.rb#L95-L97<CODESPLIT>FiniteMachine.Transition.make_conditions<CODESPLIT>Check if this transition matches from state<CODESPLIT>def make_conditions @if . map { | c | Callable . new ( c ) } + @unless . map { | c | Callable . new ( c ) . invert } end

1<CODESPLIT>https://github.com/rhomobile/rhodes/blob/3c5f87b1a44f0ba2865ca0e1dd780dd202f64872/res/build-tools/ruby-standalone/212/usr/local/lib/ruby/2.1.0/net/imap.rb#L910-L937<CODESPLIT>Net.IMAP.idle<CODESPLIT>Sends an IDLE command that waits for notifications of new or expunged messages . Yields responses from the server during the IDLE .<CODESPLIT>def idle ( & response_handler ) raise LocalJumpError , "no block given" unless response_handler response = nil synchronize do tag = Thread . current [ :net_imap_tag ] = generate_tag put_string ( "#{tag} IDLE#{CRLF}" ) begin add_response_handler ( response_handler ) @idle_done_cond = new_cond @idle_done_cond . wait @idle_done_cond = nil if @receiver_thread_terminating raise Net :: IMAP :: Error , "connection closed" end ensure unless @receiver_thread_terminating remove_response_handler ( response_handler ) put_string ( "DONE#{CRLF}" ) response = get_tagged_response ( tag , "IDLE" ) end end end return response end

0<CODESPLIT>https://github.com/cloudfoundry/cf-uaa-lib/blob/e071d69ad5f16053321dfbb95835cf6a9b48227c/lib/uaa/scim.rb#L365-L370<CODESPLIT>CF::UAA.Scim.change_password<CODESPLIT>Change client secret . * For a client to change its own secret the token in<CODESPLIT>def change_password ( user_id , new_password , old_password = nil ) req = { "password" => new_password } req [ "oldPassword" ] = old_password if old_password json_parse_reply ( @key_style , json_put ( @target , "#{type_info(:user, :path)}/#{URI.encode(user_id)}/password" , req , headers ) ) end

0<CODESPLIT>https://github.com/ruby-concurrency/thread_safe/blob/39fc4a490c7ed881657ea49cd37d293de13b6d4e/lib/thread_safe/atomic_reference_cache_backend.rb#L529-L556<CODESPLIT>SpriteFactory.Runner.summary<CODESPLIT>Implementation for clear . Steps through each bin removing all nodes .<CODESPLIT>def summary ( images , max ) return <<-EOF \n #{ images . map { | i | "        #{report_path(i[:filename])} (#{i[:width]}x#{i[:height]})" } . join ( "\n" ) } #{ report_path ( output_image_file ) } #{ report_path ( output_style_file ) } #{ max [ :width ] } #{ max [ :height ] } EOF end

1<CODESPLIT>https://github.com/ShipCompliant/ship_compliant-ruby/blob/aa12852a58cd6cb7939eb9fbb7fdc03e46e18197/lib/ship_compliant/check_compliance_result.rb#L89-L93<CODESPLIT>ShipCompliant.CheckComplianceResult.wrap_products<CODESPLIT>Wraps each + ProductSalesTaxRates + node with ShipCompliant :: ProductSalesTaxRate<CODESPLIT>def wrap_products ( products ) Array . wrap ( products [ :product_sales_tax_rate ] ) . map do | product | ProductSalesTaxRate . new ( attributes_to_symbols ( product ) ) end end

1<CODESPLIT>https://github.com/botanicus/rango/blob/b8904453f3b7d3cd65e2bcc5236bfe645aa78e8e/lib/rango/mixins/render.rb#L11-L16<CODESPLIT>Rango.RenderMixin.render<CODESPLIT>so you can use Rango :: RenderMixin . render<CODESPLIT>def render ( path , scope = Object . new , context = Hash . new ) scope , context = Object . new , scope if context . empty? && scope . is_a? ( Hash ) #Rango.logger.inspect(context: context) template = TemplateInheritance :: Template . new ( path , scope ) return template . render ( context ) end

1<CODESPLIT>https://github.com/ebeigarts/exchanger/blob/10f24ffaaa69881bebb9823b1756cb18ca96e2f8/lib/exchanger/field.rb#L46-L53<CODESPLIT>Exchanger.Field.to_xml_field_uri<CODESPLIT>FieldURI or IndexedFieldURI <t : FieldURI FieldURI = item : Sensitivity / > <t : IndexedFieldURI FieldURI = contacts : EmailAddress FieldIndex = EmailAddress1 / ><CODESPLIT>def to_xml_field_uri ( value ) doc = Nokogiri :: XML :: Document . new if value . is_a? ( Entry ) doc . create_element ( "IndexedFieldURI" , "FieldURI" => field_uri , "FieldIndex" => value . key ) else doc . create_element ( "FieldURI" , "FieldURI" => field_uri ) end end

1<CODESPLIT>https://github.com/dspinhirne/netaddr-rb/blob/38a4a64300a2a9d228bcaf436bea8f368bc20fc5/lib/ipv6net.rb#L161-L181<CODESPLIT>NetAddr.IPv6Net.rel<CODESPLIT>rel determines the relationship to another IPv6Net . Returns : * 1 if this IPv6Net is the supernet of other * 0 if the two are equal * - 1 if this IPv6Net is a subnet of other * nil if the networks are unrelated<CODESPLIT>def rel ( other ) if ( ! other . kind_of? ( IPv6Net ) ) raise ArgumentError , "Expected an IPv6Net object for 'other' but got a #{other.class}." end # when networks are equal then we can look exlusively at the netmask if ( self . network . addr == other . network . addr ) return self . netmask . cmp ( other . netmask ) end # when networks are not equal we can use hostmask to test if they are # related and which is the supernet vs the subnet hostmask = self . netmask . mask ^ NetAddr :: F128 otherHostmask = other . netmask . mask ^ NetAddr :: F128 if ( self . network . addr | hostmask == other . network . addr | hostmask ) return 1 elsif ( self . network . addr | otherHostmask == other . network . addr | otherHostmask ) return - 1 end return nil end

0<CODESPLIT>https://github.com/cxn03651/writeexcel/blob/d0345067c21b14a7141ba66b6752be8f4be379de/lib/writeexcel/formula.rb#L532-L551<CODESPLIT>Writeexcel.Formula.get_sheet_index<CODESPLIT>Convert a function to a ptgFunc or ptgFuncVarV depending on the number of args that it takes .<CODESPLIT>def get_sheet_index ( sheet_name ) ruby_19 { sheet_name = convert_to_ascii_if_ascii ( sheet_name ) } # Handle utf8 sheetnames if is_utf8? ( sheet_name ) ruby_18 { sheet_name = utf8_to_16be ( sheet_name ) } || ruby_19 { sheet_name = sheet_name . encode ( 'UTF-16BE' ) } end if @ext_sheets [ sheet_name ] . nil? raise "Unknown sheet name '#{sheet_name}' in formula\n" else return @ext_sheets [ sheet_name ] end end

1<CODESPLIT>https://github.com/iyuuya/jkf/blob/4fd229c50737cab7b41281238880f1414e55e061/lib/jkf/parser/kifuable.rb#L171-L179<CODESPLIT>Jkf::Parser.Kifuable.parse_num<CODESPLIT>num : [  ]<CODESPLIT>def parse_num s0 = @current_pos s1 = match_regexp ( /   if s1 != :failed @reported_pos = s0 s1 = zen2n ( s1 ) end s1 end

1<CODESPLIT>https://github.com/couchrest/couchrest_extended_document/blob/71511202ae10d3010dcf7b98fcba017cb37c76da/lib/couchrest/property.rb#L28-L41<CODESPLIT>CouchRest.Property.cast<CODESPLIT>Cast the provided value using the properties details .<CODESPLIT>def cast ( parent , value ) return value unless casted if type . is_a? ( Array ) # Convert to array if it is not already value = [ value ] . compact unless value . is_a? ( Array ) arr = value . collect { | data | cast_value ( parent , data ) } # allow casted_by calls to be passed up chain by wrapping in CastedArray value = type_class != String ? :: CouchRest :: CastedArray . new ( arr , self ) : arr value . casted_by = parent if value . respond_to? ( :casted_by ) elsif ! value . nil? value = cast_value ( parent , value ) end value end

0<CODESPLIT>https://github.com/evanphx/kpeg/blob/7ebf2e58e1248ffcbd0fe2cb552cc3bd12466eb9/lib/kpeg/compiled_parser.rb#L29-L37<CODESPLIT>KPeg.Grammar.foreign_invoke<CODESPLIT>Leave these markers in! They allow us to generate standalone code automatically! INITIALIZE START This is distinct from setup_parser so that a standalone parser can redefine #initialize and still have access to the proper parser setup code . INITIALIZE END STANDALONE START Prepares for parsing + str + . If you define a custom initialize you must call this method before #parse<CODESPLIT>def foreign_invoke ( gram , name , args = nil ) ForeignInvokeRule . new gram , name . to_s , args end

1<CODESPLIT>https://github.com/mare-imbrium/canis/blob/8bce60ff9dad321e299a6124620deb4771740b0b/lib/canis/core/util/rcommandwindow.rb#L226-L258<CODESPLIT>Canis.CommandWindow.press<CODESPLIT>handles a key commandline<CODESPLIT>def press ch ch = ch . getbyte ( 0 ) if ch . class == String ## 1.9 $log . debug " XXX press #{ch} " if $log . debug? case ch when - 1 return when KEY_F1 , 27 , ?\C-q . getbyte ( 0 ) @stop = true return when KEY_ENTER , 10 , 13 #$log.debug "popup ENTER : #{@selected_index} " #$log.debug "popup ENTER :  #{field.name}" if !field.nil? @stop = true return when ?\C-d . getbyte ( 0 ) @start += @height - 1 bounds_check when KEY_UP @start -= 1 @start = 0 if @start < 0 when KEY_DOWN @start += 1 bounds_check when ?\C-b . getbyte ( 0 ) @start -= @height - 1 @start = 0 if @start < 0 when 0 @start = 0 end Ncurses :: Panel . update_panels ( ) ; Ncurses . doupdate ( ) ; @window . wrefresh end

1<CODESPLIT>https://github.com/Mordorreal/SiteAnalyzer/blob/7b17f7c1651c2fe85dbc2088c28cf1ec94ffdefb/lib/site_analyzer/page.rb#L157-L164<CODESPLIT>SiteAnalyzer.Page.all_a_tags<CODESPLIT>get all a tags<CODESPLIT>def all_a_tags return unless @page tags = [ ] @page . css ( 'a' ) . each do | node | tags << [ node [ 'href' ] , node [ 'target' ] , node [ 'rel' ] ] end tags . compact end

1<CODESPLIT>https://github.com/caruby/core/blob/a682dc57c6fa31aef765cdd206ed3d4b4c289c60/lib/caruby/database.rb#L122-L131<CODESPLIT>CaRuby.Database.open<CODESPLIT>Calls the block given to this method with this database as an argument and closes the database when done .<CODESPLIT>def open ( user = nil , password = nil ) raise ArgumentError . new ( "Database open requires an execution block" ) unless block_given? raise DatabaseError . new ( "The caRuby application database is already in use." ) if open? # reset the execution timers persistence_services . each { | svc | svc . timer . reset } # Start the session. start_session ( user , password ) # Call the block and close when done. yield ( self ) ensure close end

1<CODESPLIT>https://github.com/conversation/raca/blob/fa69dfde22359cc0e06f655055be4eadcc7019c0/lib/raca/http_client.rb#L95-L106<CODESPLIT>Raca.HttpClient.cloud_request<CODESPLIT>perform an HTTP request to rackpsace .<CODESPLIT>def cloud_request ( request , & block ) Net :: HTTP . start ( @hostname , 443 , use_ssl : true , read_timeout : 120 ) do | http | request [ 'X-Auth-Token' ] = @account . auth_token request [ 'User-Agent' ] = "raca 0.4.4 (http://rubygems.org/gems/raca)" response = http . request ( request , block ) if response . is_a? ( Net :: HTTPSuccess ) response else raise_on_error ( request , response ) end end end

0<CODESPLIT>https://github.com/26fe/tree.rb/blob/5ecf0cfbbc439e27c72b9676d6a1ccee8e6bb02b/lib/tree_rb/core/tree_node.rb#L180-L195<CODESPLIT>TreeRb.TreeNode.add_child<CODESPLIT>Add a Leaf @param [ LeafNode ] leaf<CODESPLIT>def add_child ( tree_node ) return if tree_node . parent == self if not tree_node . parent . nil? tree_node . remove_from_parent else tree_node . prefix_path = nil end tree_node . invalidate tree_node . parent = self if @children . length > 0 @children . last . next = tree_node tree_node . prev = @children . last else tree_node . prev = nil end tree_node . next = nil @children << tree_node @leaves_and_children << tree_node self end

1<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_policy_insights/lib/2018-07-01-preview/generated/azure_mgmt_policy_insights/remediations.rb#L1679-L1682<CODESPLIT>Azure::PolicyInsights::Mgmt::V2018_07_01_preview.Remediations.delete_at_resource_group<CODESPLIT>Deletes an existing remediation at resource group scope .<CODESPLIT>def delete_at_resource_group ( resource_group_name , remediation_name , custom_headers : nil ) response = delete_at_resource_group_async ( resource_group_name , remediation_name , custom_headers :custom_headers ) . value! response . body unless response . nil? end

0<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_compute/lib/2018-06-01/generated/azure_mgmt_compute/gallery_image_versions.rb#L392-L394<CODESPLIT>Azure::Compute::Mgmt::V2018_06_01.GalleryImageVersions.begin_create_or_update<CODESPLIT>Create or update a gallery Image Version .<CODESPLIT>def begin_create_or_update ( resource_group_name , gallery_name , gallery_image_name , gallery_image_version_name , gallery_image_version , custom_headers : nil ) response = begin_create_or_update_async ( resource_group_name , gallery_name , gallery_image_name , gallery_image_version_name , gallery_image_version , custom_headers :custom_headers ) . value! response . body unless response . nil? end

0<CODESPLIT>https://github.com/restaurant-cheetah/take2/blob/21bf2c67dd4aaca63e2c13733deef09cde195661/lib/take2.rb#L172-L176<CODESPLIT>Take2.ClassMethods.retriable_errors<CODESPLIT>Sets the backoff strategy<CODESPLIT>def retriable_errors ( * errors ) message = 'All retriable errors must be StandardError decendants' raise ArgumentError , message unless errors . all? { | e | e <= StandardError } self . retriable = errors end

1<CODESPLIT>https://github.com/mongodb/mongo-ruby-driver/blob/dca26d0870cb3386fad9ccc1d17228097c1fe1c8/lib/mongo/cluster.rb#L673-L684<CODESPLIT>Mongo.Cluster.sessions_supported?<CODESPLIT>Returns whether the deployment ( as this term is defined in the sessions spec ) supports sessions .<CODESPLIT>def sessions_supported? if topology . data_bearing_servers? return ! ! topology . logical_session_timeout end begin ServerSelector . get ( mode : :primary_preferred ) . select_server ( self ) ! ! topology . logical_session_timeout rescue Error :: NoServerAvailable false end end

0<CODESPLIT>https://github.com/zed-0xff/zpng/blob/d356182ab9bbc2ed3fe5c064488498cf1678b0f0/lib/zpng/image.rb#L80-L82<CODESPLIT>ZPNG.Image.inspect<CODESPLIT>save image to file<CODESPLIT>def inspect "#<ZPNG::Image " + %w' width height bpp chunks scanlines ' . map do | k | v = case ( v = send ( k ) ) when Array "[#{v.size} entries]" when String v . size > 40 ? "[#{v.bytesize} bytes]" : v . inspect else v . inspect end "#{k}=#{v}" end . compact . join ( ", " ) + ">" end

0<CODESPLIT>https://github.com/frictionlessdata/datapackage-rb/blob/75c082ab928ad417ed046819cde5b64fd0a98d20/lib/datapackage/helpers.rb#L6-L32<CODESPLIT>Sapience.Base.measure_internal<CODESPLIT>Dereference a resource that can be a URL or path to a JSON file or a hash Returns a Hash with all values that are URLs or paths dereferenced<CODESPLIT>def measure_internal ( level , index , message , params ) params . dup start = Time . now exception = nil begin if block_given? result = if ( silence_level = params [ :silence ] ) # In case someone accidentally sets `silence: true` instead of `silence: :error` silence_level = :error if silence_level == true silence ( silence_level ) { yield ( params ) } else yield ( params ) end exception = params [ :exception ] result end rescue Exception => exc # rubocop:disable RescueException exception = exc ensure end_time = Time . now # Extract options after block completes so that block can modify any of the options log_exception = params [ :log_exception ] || :partial on_exception_level = params [ :on_exception_level ] min_duration = params [ :min_duration ] || 0.0 payload = params [ :payload ] metric = params [ :metric ] duration = if block_given? 1000.0 * ( end_time - start ) else params [ :duration ] || fail ( "Mandatory block missing when :duration option is not supplied" ) end # Add scoped payload if self . payload payload = payload . nil? ? self . payload : self . payload . merge ( payload ) end merged_tags = merge_tags_with_payload ( payload ) if exception logged_exception = exception backtrace = nil case log_exception when :full # On exception change the log level if on_exception_level level = on_exception_level index = Sapience . config . level_to_index ( level ) end when :partial # On exception change the log level if on_exception_level level = on_exception_level index = Sapience . config . level_to_index ( level ) end message = "#{message} -- Exception: #{exception.class}: #{exception.message}" logged_exception = nil backtrace = exception . backtrace else # Log the message with its duration but leave out the exception that was raised logged_exception = nil backtrace = exception . backtrace end log = Log . new ( level , Thread . current . name , name , message , payload , end_time , duration , merged_tags , index , logged_exception , metric , backtrace ) # rubocop:disable LineLength self . log ( log ) if include_message? ( log ) fail exception elsif duration >= min_duration # Only log if the block took longer than 'min_duration' to complete # Add caller stack trace backtrace = extract_backtrace if index >= Sapience . config . backtrace_level_index log = Log . new ( level , Thread . current . name , name , message , payload , end_time , duration , merged_tags , index , nil , metric , backtrace ) # rubocop:disable LineLength self . log ( log ) if include_message? ( log ) end end end

1<CODESPLIT>https://github.com/github/github-ds/blob/312b43b3d96bb376b87bc5e05045c306f40f2623/lib/github/kv.rb#L114-L119<CODESPLIT>GitHub.KV.set<CODESPLIT>set :: String String expires : Time? - > nil<CODESPLIT>def set ( key , value , expires : nil ) validate_key ( key ) validate_value ( value ) mset ( { key => value } , expires : expires ) end

1<CODESPLIT>https://github.com/TwP/logging/blob/aa9a5b840479f4176504e4c53ce29d8d01315ccc/lib/logging/appenders/io.rb#L70-L77<CODESPLIT>Logging::Appenders.IO.canonical_write<CODESPLIT>This method is called by the buffering code when messages need to be written to the logging destination .<CODESPLIT>def canonical_write ( str ) return self if @io . nil? str = str . force_encoding ( encoding ) if encoding && str . encoding != encoding @io . write str self rescue StandardError => err handle_internal_error ( err ) end

1<CODESPLIT>https://github.com/ukparliament/gromnative/blob/4b291e9e910699f7881316279ca787be6f1d5038/lib/grom_native/request.rb#L53-L70<CODESPLIT>GromNative.UrlRequest.get<CODESPLIT>Creates a new instance of Parliament :: Request :: UrlRequest .<CODESPLIT>def get ( params : { } , filter : [ ] ) uri = URI . parse ( query_url ) temp_params = { } if uri . query # Returns [ ["key", "value"], ["key", "value"] ] key_value_array = URI . decode_www_form ( endpoint . query ) key_value_array . map! { | key_value_pair | [ key_value_pair [ 0 ] . to_sym , key_value_pair [ 1 ] ] } temp_params = key_value_array . to_h end temp_params = temp_params . merge ( params ) uri . query = temp_params GromNative . fetch ( uri : uri . to_s , headers : headers , filter : filter , decorators : @decorators ) end

0<CODESPLIT>https://github.com/mongodb/mongo-ruby-driver/blob/dca26d0870cb3386fad9ccc1d17228097c1fe1c8/lib/mongo/uri.rb#L539-L549<CODESPLIT>Mongo.URI.merge_uri_option<CODESPLIT>Applies URI value transformation by either using the default cast or a transformation appropriate for the given type .<CODESPLIT>def merge_uri_option ( target , value , name ) if target . key? ( name ) if REPEATABLE_OPTIONS . include? ( name ) target [ name ] += value else log_warn ( "Repeated option key: #{name}." ) end else target . merge! ( name => value ) end end

1<CODESPLIT>https://github.com/xijo/helmsman/blob/0cf50f298e8fc3c2d90344bf27c007ae2227fa9c/lib/helmsman/view_helper.rb#L23-L38<CODESPLIT>Helmsman.ViewHelper.highlight_helm?<CODESPLIT>Indicates if for the given conditions the helm should be highlighted . Examples : Given we are in pictures controller and action index highlight_helm? ( : pictures ) # true highlight_helm? ( : foobar ) # false highlight_helm? ( pictures : : index ) # true highlight_helm? ( pictures : [ : index : show ] ) # true highlight_helm? ( pictures : [ : index : show ] : foobar ) # true<CODESPLIT>def highlight_helm? ( conditions ) Array ( conditions ) . any? do | condition | case condition when Symbol , String condition . to_s == controller_name when Array if condition . first . to_s == controller_name Array ( condition . last ) . any? { | given | given . to_s == action_name } end else raise TypeError , "invalid format for highlight options, " "expected Symbol, Array or Hash got #{conditions.class.name}" end end end

1<CODESPLIT>https://github.com/decidim/decidim/blob/6e2b14e559a63088669904e3c5c49a5180700cf7/decidim-core/app/helpers/decidim/paginate_helper.rb#L11-L20<CODESPLIT>Decidim.PaginateHelper.decidim_paginate<CODESPLIT>Displays pagination links for the given collection setting the correct theme . This mostly acts as a proxy for the underlying pagination engine .<CODESPLIT>def decidim_paginate ( collection , paginate_params = { } ) # Kaminari uses url_for to generate the url, but this doesn't play nice with our engine system # and unless we remove these params they are added again as query string :( default_params = { participatory_process_id : nil , component_id : nil } paginate collection , theme : "decidim" , params : paginate_params . merge ( default_params ) end

1<CODESPLIT>https://github.com/rhomobile/rhodes/blob/3c5f87b1a44f0ba2865ca0e1dd780dd202f64872/lib/extensions/rexml/rexml/element.rb#L690-L703<CODESPLIT>REXML.Element.write<CODESPLIT>== DEPRECATED See REXML :: Formatters<CODESPLIT>def write ( output = $stdout , indent = - 1 , transitive = false , ie_hack = false ) Kernel . warn ( "#{self.class.name}.write is deprecated.  See REXML::Formatters" ) formatter = if indent > - 1 if transitive require "rexml/formatters/transitive" REXML :: Formatters :: Transitive . new ( indent , ie_hack ) else REXML :: Formatters :: Pretty . new ( indent , ie_hack ) end else REXML :: Formatters :: Default . new ( ie_hack ) end formatter . write ( self , output ) end

0<CODESPLIT>https://github.com/Bandwidth/ruby-bandwidth/blob/896df7a12e2992b5558514db943997d930ef416f/lib/bandwidth/client.rb#L150-L163<CODESPLIT>Bandwidth.Client.check_response<CODESPLIT>Convert all keys of a hash to camel cased strings<CODESPLIT>def check_response ( response ) if response . status >= 400 parsed_body = JSON . parse ( response . body ) raise Errors :: GenericError . new ( parsed_body [ 'code' ] , parsed_body [ 'message' ] ) end end

1<CODESPLIT>https://github.com/madwire/trooper/blob/ca953f9b78adf1614f7acf82c9076055540ee04c/lib/trooper/host.rb#L53-L81<CODESPLIT>Trooper.Host.execute<CODESPLIT>Public : Execute a set of commands via net / ssh .<CODESPLIT>def execute ( command , options = { } ) options = { } if options == nil commands = parse command Trooper . logger . debug commands if ! options [ :local ] connection . exec! commands do | ch , stream , data | raise Trooper :: StdError , "#{data}\n[ERROR INFO] #{commands}" if stream == :stderr ch . wait return [ commands , stream , data ] end else if commands != '' begin stdin , stdout , stderr = Open3 . popen3 ( commands ) raise Trooper :: StdError , "#{stderr.read}\n[ERROR INFO] #{commands}" if stderr . read != '' return [ commands , :stdout , stdout . read ] rescue Exception => e raise Trooper :: StdError , "#{e.message}\n[ERROR INFO] #{commands}" end end end end

0<CODESPLIT>https://github.com/Follain/tap-rep/blob/fabc476a3eee17963a278550568f7bfda3af39e0/lib/runner.rb#L74-L79<CODESPLIT>Unchained.Request.get<CODESPLIT>Per Rep include a buffer when we kick off our process In other words end_time ! = session modification time . As a result just maintaining a high watermark has the potential to miss certain sessions and the probability of missing sessions increases if there s a big gap between the time of last message in the session and the time it is closed out by an agent ( like on weekends ) .<CODESPLIT>def get ( url , params = { } ) RestClient . get ( url , build_params ( params ) ) do | resp , req , res , & block | case resp . code when 200 JSON . parse ( resp ) when 404 raise Unchained :: NotFound . new ( res . message ) else resp . return! ( req , res , block ) end end end

0<CODESPLIT>https://github.com/espresse/orientdb_binary/blob/b7f791c07a56eb6b551bed375504379487e28894/lib/orientdb_binary/database.rb#L25-L31<CODESPLIT>Support.ExampleGroup.EXT<CODESPLIT>Initializes connection to database<CODESPLIT>def EXT method_name , * description , ** metadata , & body INSTANCE_METHOD method_name , description , ** metadata do subject do end end end

1<CODESPLIT>https://github.com/sass/ruby-sass/blob/7a50eae567260a23d3bbf4d5aaf1a76db43dec32/lib/sass/script/functions.rb#L2056-L2104<CODESPLIT>Sass::Script.Functions.join<CODESPLIT>Joins together two lists into one .<CODESPLIT>def join ( list1 , list2 , separator = identifier ( "auto" ) , bracketed = identifier ( "auto" ) , kwargs = nil , * rest ) if separator . is_a? ( Hash ) kwargs = separator separator = identifier ( "auto" ) elsif bracketed . is_a? ( Hash ) kwargs = bracketed bracketed = identifier ( "auto" ) elsif rest . last . is_a? ( Hash ) rest . unshift kwargs kwargs = rest . pop end unless rest . empty? # Add 4 to rest.length because we don't want to count the kwargs hash, # which is always passed. raise ArgumentError . new ( "wrong number of arguments (#{rest.length + 4} for 2..4)" ) end if kwargs separator = kwargs . delete ( "separator" ) || separator bracketed = kwargs . delete ( "bracketed" ) || bracketed unless kwargs . empty? name , val = kwargs . to_a . first raise ArgumentError . new ( "Unknown argument $#{name} (#{val})" ) end end assert_type separator , :String , :separator unless %w( auto space comma ) . include? ( separator . value ) raise ArgumentError . new ( "Separator name must be space, comma, or auto" ) end list ( list1 . to_a + list2 . to_a , separator : if separator . value == 'auto' list1 . separator || list2 . separator || :space else separator . value . to_sym end , bracketed : if bracketed . is_a? ( Sass :: Script :: Value :: String ) && bracketed . value == 'auto' list1 . bracketed else bracketed . to_bool end ) end

1<CODESPLIT>https://github.com/Foodcritic/foodcritic/blob/f06e354833c75caa91a800e0f9343ece5185a737/features/support/command_helpers.rb#L312-L317<CODESPLIT>FoodCritic.BuildHelpers.assert_build_result<CODESPLIT>Assert the build outcome<CODESPLIT>def assert_build_result ( success , warnings ) success ? assert_no_error_occurred : assert_error_occurred warnings . each do | code | expect_warning ( code , :warning_only => true ) end end

0<CODESPLIT>https://github.com/nledez/proxmox/blob/cc679cc69deb78b20f88074b235e172869070a0d/lib/proxmox.rb#L340-L349<CODESPLIT>Proxmox.Proxmox.openvz_post<CODESPLIT>Methods manages auth<CODESPLIT>def openvz_post ( ostemplate , vmid , config = { } ) config [ 'vmid' ] = vmid config [ 'ostemplate' ] = "local%3Avztmpl%2F#{ostemplate}.tar.gz" vm_definition = config . to_a . map { | v | v . join '=' } . join '&' http_action_post ( "nodes/#{@node}/openvz" , vm_definition ) end

1<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_media_services/lib/2015-10-01/generated/azure_mgmt_media_services/media_service_operations.rb#L653-L655<CODESPLIT>Azure::MediaServices::Mgmt::V2015_10_01.MediaServiceOperations.regenerate_key_with_http_info<CODESPLIT>Regenerates a primary or secondary key for a Media Service .<CODESPLIT>def regenerate_key_with_http_info ( resource_group_name , media_service_name , parameters , custom_headers : nil ) regenerate_key_async ( resource_group_name , media_service_name , parameters , custom_headers :custom_headers ) . value! end

0<CODESPLIT>https://github.com/rlister/slackbotsy/blob/198b9e3316630f4ae76f6c3e7da71ffae89ec4ed/lib/slackbotsy/bot.rb#L69-L72<CODESPLIT>Slackbotsy.Bot.post<CODESPLIT>simple wrapper on post to send attachment ( s )<CODESPLIT>def post ( options ) payload = { username : @options [ 'name' ] , channel : @options [ 'channel' ] } . merge ( options ) payload [ :channel ] = payload [ :channel ] . gsub ( / / , '#' ) #slack api needs leading # on channel request = Net :: HTTP :: Post . new ( @uri . request_uri ) request . set_form_data ( payload : payload . to_json ) @http . request ( request ) return nil # so as not to trigger text in outgoing webhook reply end

0<CODESPLIT>https://github.com/veny/orientdb4r/blob/d02d0d27e6ed19c5c5ff377a642355f617c785d7/lib/orientdb4r/client.rb#L243-L267<CODESPLIT>Orientdb4r.Client.drop_class<CODESPLIT>Creates a new property in the schema . You need to create the class before .<CODESPLIT>def drop_class ( name , options = { } ) raise ArgumentError , 'class name is blank' if blank? ( name ) # :mode=>:strict forbids to drop a class that is a super class for other one opt_pattern = { :mode => :nil } verify_options ( options , opt_pattern ) if :strict == options [ :mode ] response = get_database children = response [ 'classes' ] . select { | i | i [ 'superClass' ] == name } unless children . empty? raise OrientdbError , "class is super-class, cannot be deleted, name=#{name}" end end command "DROP CLASS #{name}" end

0<CODESPLIT>https://github.com/spikex/strongbox/blob/1a098ad379aec0b291b350ecb3991a90d6d7522c/lib/strongbox.rb#L53-L90<CODESPLIT>Ninetails.Revision.url_is_unique<CODESPLIT>+ encrypt_with_public_key + gives the class it is called on an attribute that when assigned is automatically encrypted using a public key . This allows the unattended encryption of data without exposing the information need to decrypt it ( as would be the case when using symmetric key encryption alone ) . Small amounts of data may be encrypted directly with the public key . Larger data is encrypted using symmetric encryption . The encrypted data is stored in the database column of the same name as the attibute . If symmetric encryption is used ( the default ) additional column are need to store the generated password and IV .<CODESPLIT>def url_is_unique if container . is_a? ( Page ) && url . present? url_exists = Ninetails :: Container . where . not ( id : container . id ) . includes ( :current_revision ) . where ( ninetails_revisions : { url : url } ) . exists? errors . add :url , "is already in use" if url_exists end end

0<CODESPLIT>https://github.com/cookpad/rrrspec/blob/a5bde2b062ce68b1e32b8caddf194389c2ce28b0/rrrspec-client/lib/rrrspec/redis_models.rb#L788-L791<CODESPLIT>RRRSpec.Trial.finish<CODESPLIT>Public : Returns the passed examples<CODESPLIT>def finish ( status , stdout , stderr , passed , pending , failed ) RRRSpec . redis . hmset ( key , 'finished_at' , Time . zone . now . to_s , 'status' , status , 'stdout' , stdout , 'stderr' , stderr , 'passed' , passed , 'pending' , pending , 'failed' , failed ) end

0<CODESPLIT>https://github.com/dilcom/gnuplotrb/blob/0a3146386ae28fcbe2c09cb6e266fe40ebb659f4/lib/gnuplotrb/plot.rb#L250-L260<CODESPLIT>GnuplotRB.Plot.dataset_from_any<CODESPLIT>Checks several conditions and set options needed to handle DateTime indexes properly .<CODESPLIT>def dataset_from_any ( source ) ds = case source # when initialized with dataframe (it passes here several vectors) when ( defined? ( Daru ) ? Daru :: Vector : nil ) Dataset . new ( source ) when Dataset source . clone else Dataset . new ( source ) end data = source . is_a? ( Array ) ? source [ 0 ] : source provide_with_datetime_format ( data , ds . using ) ds end

1<CODESPLIT>https://github.com/logicminds/rubyipmi/blob/516dfb0d5f8aa126159a5f5c25d60ab5c98f862f/lib/rubyipmi/freeipmi/commands/fru.rb#L112-L125<CODESPLIT>Rubyipmi::Freeipmi.FruData.parse<CODESPLIT>parse the fru information that should be an array of lines<CODESPLIT>def parse ( data ) return unless data data . each do | line | key , value = line . split ( ':' , 2 ) if key =~ / / if value =~ / \w \s \( \) / self [ :name ] = $~ [ 1 ] . strip . gsub ( / \  / , '_' ) . downcase end else key = key . strip . gsub ( / \  / , '_' ) . downcase . gsub ( / / , '' ) self [ key ] = value . strip unless value . nil? end end end

1<CODESPLIT>https://github.com/zhimin/rwebspec/blob/aafccee2ba66d17d591d04210067035feaf2f892/lib/rwebspec-webdriver/web_browser.rb#L367-L373<CODESPLIT>RWebSpec.WebBrowser.begin_at<CODESPLIT>Crahses where http : /// ssshtttp : ///<CODESPLIT>def begin_at ( relative_url ) if relative_url =~ / \s / @browser . navigate . to relative_url else @browser . navigate . to full_url ( relative_url ) end end

1<CODESPLIT>https://github.com/Shopify/active_fulfillment/blob/3a33e16f35c5547b3b7412103743d4260bc20cd1/lib/active_fulfillment/services/shipwire.rb#L54-L56<CODESPLIT>ActiveFulfillment.ShipwireService.fulfill<CODESPLIT>Pass in the login and password for the shipwire account . Optionally pass in the : test = > true to force test mode<CODESPLIT>def fulfill ( order_id , shipping_address , line_items , options = { } ) commit :fulfillment , build_fulfillment_request ( order_id , shipping_address , line_items , options ) end

0<CODESPLIT>https://github.com/dougfales/gpx/blob/632fcda922488ca410aabce451871755ef2b544c/lib/gpx/gpx_file.rb#L196-L202<CODESPLIT>GPX.GPXFile.crop<CODESPLIT>Updates the meta data for this GPX file . Meta data includes the bounds the high and low points and the distance . This is useful when you modify the GPX data ( i . e . by adding or deleting points ) and you want the meta data to accurately reflect the new data .<CODESPLIT>def crop ( area ) reset_meta_data keep_tracks = [ ] tracks . each do | trk | trk . crop ( area ) unless trk . empty? update_meta_data ( trk ) keep_tracks << trk end end @tracks = keep_tracks routes . each { | rte | rte . crop ( area ) } waypoints . each { | wpt | wpt . crop ( area ) } end

0<CODESPLIT>https://github.com/zendesk/ruby-kafka/blob/2a73471b6a607a52dc85c79301ba522acb4566b5/lib/kafka/offset_manager.rb#L68-L75<CODESPLIT>Kafka.OffsetManager.seek_to<CODESPLIT>Move the consumer s position in the partition back to the configured default offset either the first or latest in the partition .<CODESPLIT>def seek_to ( topic , partition , offset ) @processed_offsets [ topic ] ||= { } @processed_offsets [ topic ] [ partition ] = offset @fetcher . seek ( topic , partition , offset ) end

0<CODESPLIT>https://github.com/ianwhite/orm_adapter/blob/f8c570a60d9b7a239eca721bb9504a9e3dec48c5/lib/orm_adapter/base.rb#L94-L101<CODESPLIT>Payu.Helpers.payu_verify_params<CODESPLIT>given an options hash with optional : conditions : order : limit and : offset keys returns conditions normalized order limit and offset<CODESPLIT>def payu_verify_params ( params ) pos_id = params [ 'pos_id' ] pos = Payu [ pos_id ] Signature . verify! ( params [ 'sig' ] , params [ 'pos_id' ] , params [ 'session_id' ] , params [ 'ts' ] , pos . key2 ) end

0<CODESPLIT>https://github.com/solnic/virtus/blob/a6f8969841247462bb05c456458baa66fce29ed8/lib/virtus/attribute_set.rb#L183-L188<CODESPLIT>Virtus.AttributeSet.set<CODESPLIT>Set default attributes<CODESPLIT>def set ( object , attributes ) coerce ( attributes ) . each do | name , value | writer_name = "#{name}=" if object . allowed_writer_methods . include? ( writer_name ) object . __send__ ( writer_name , value ) end end end

1<CODESPLIT>https://github.com/cisco/cisco-network-node-utils/blob/a617a9ef9d6bd18f35f2e2f2591033e1ddd46145/lib/cisco_node_utils/bgp_af.rb#L141-L154<CODESPLIT>Cisco.RouterBgpAF.additional_paths_selection=<CODESPLIT>additional paths ( Getter / Setter / Default )<CODESPLIT>def additional_paths_selection = ( route_map ) route_map . strip! if route_map . empty? state = 'no' # Dummy routemap required if not configured. if additional_paths_selection . empty? route_map = 'dummy_routemap' else route_map = additional_paths_selection end end set_args_keys ( state : state , route_map : route_map , route_policy : route_map ) config_set ( 'bgp_af' , 'additional_paths_selection' , @set_args ) end

0<CODESPLIT>https://github.com/beatrichartz/exchange/blob/4318b9dad3cce5e933827126160fafe30c68dc2a/lib/exchange/configurable.rb#L18-L21<CODESPLIT>Capybara.BootstrapDatepicker.select_bootstrap_date<CODESPLIT>Alias method chain to instantiate the subclass from a symbol should it not be a class<CODESPLIT>def select_bootstrap_date ( date_input , value ) date_input . click picker = Picker . new picker . goto_decade_panel picker . navigate_through_decades value . year picker . find_year ( value . year ) . click picker . find_month ( value . month ) . click picker . find_day ( value . day ) . click fail if Date . parse ( date_input . value ) != value end

1<CODESPLIT>https://github.com/negativecode/vines/blob/245d6c971dd8604d74265d67fd4e2a78319d71a2/lib/vines/stream.rb#L25-L35<CODESPLIT>Vines.Stream.post_init<CODESPLIT>Initialize the stream after its connection to the server has completed . EventMachine calls this method when an incoming connection is accepted into the event loop .<CODESPLIT>def post_init @remote_addr , @local_addr = addresses @user , @closed , @stanza_size = nil , false , 0 @bucket = TokenBucket . new ( 100 , 10 ) @store = Store . new ( @config . certs ) @nodes = EM :: Queue . new process_node_queue create_parser log . info { "%s %21s -> %s" % [ 'Stream connected:' . ljust ( PAD ) , @remote_addr , @local_addr ] } end

0<CODESPLIT>https://github.com/stitchfix/merch_calendar/blob/b24f1f47685928eeec8e808838e2474ddf473afd/lib/merch_calendar/retail_calendar.rb#L120-L133<CODESPLIT>MerchCalendar.RetailCalendar.merch_year_from_date<CODESPLIT>Return the ending date for a particular quarter<CODESPLIT>def merch_year_from_date ( date ) date_end_of_year = end_of_year ( date . year ) date_start_of_year = start_of_year ( date . year ) if date < date_start_of_year date . year - 1 else date . year end end

0<CODESPLIT>https://github.com/gnilrets/Birst_Command/blob/99b8317f7122f8bea586842d1384f27257d5cd82/lib/birst_command/session.rb#L66-L76<CODESPLIT>Birst_Command.Session.set_options<CODESPLIT>Public : Runs the command that is obtained from the method_missing call .<CODESPLIT>def set_options ( opts = { } ) @wsdl = opts [ :wsdl ] || Settings . session . wsdl @endpoint = opts [ :endpoint ] || Settings . session . endpoint @soap_log = opts [ :soap_log ] || Settings . session . soap_log @soap_logger = opts [ :soap_logger ] || Settings . session . soap_logger @soap_log_level = opts [ :soap_log_level ] || Settings . session . soap_log_level @username = opts [ :username ] || Settings . session . username @password = opts [ :password ] || Settings . session . password @auth_cookie = opts [ :auth_cookie ] || nil end

0<CODESPLIT>https://github.com/StemboltHQ/solidus-adyen/blob/68dd710b0a23435eedc3cc0b4b0ec5b45aa37180/app/controllers/spree/adyen_redirect_controller.rb#L83-L97<CODESPLIT>Spree.AdyenRedirectController.restore_session<CODESPLIT>If an authorization notification is received before the redirection the payment is created there . In this case we just need to assign the addition parameters received about the source .<CODESPLIT>def restore_session guest_token , payment_method_id = params . fetch ( :merchantReturnData ) . split ( "|" ) cookies . permanent . signed [ :guest_token ] = guest_token @payment_method = Spree :: PaymentMethod . find ( payment_method_id ) @order = Spree :: Order . find_by! ( number : order_number ) end

1<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_edgegateway/lib/2019-03-01/generated/azure_mgmt_edgegateway/orders.rb#L572-L581<CODESPLIT>Azure::EdgeGateway::Mgmt::V2019_03_01.Orders.list_by_data_box_edge_device_as_lazy<CODESPLIT>Lists all the orders related to a data box edge / gateway device .<CODESPLIT>def list_by_data_box_edge_device_as_lazy ( device_name , resource_group_name , custom_headers : nil ) response = list_by_data_box_edge_device_async ( device_name , resource_group_name , custom_headers :custom_headers ) . value! unless response . nil? page = response . body page . next_method = Proc . new do | next_page_link | list_by_data_box_edge_device_next_async ( next_page_link , custom_headers :custom_headers ) end page end end

1<CODESPLIT>https://github.com/GoogleCloudPlatform/fluent-plugin-google-cloud/blob/ab10cdc2b5a25bc70e9969ef422f9bcf85f94990/lib/fluent/plugin/out_google_cloud.rb#L1976-L1984<CODESPLIT>Fluent.GoogleCloudOutput.sanitize_tag<CODESPLIT>Given a tag returns the corresponding valid tag if possible or nil if the tag should be rejected . If require_valid_tags is false non - string tags are converted to strings and invalid characters are sanitized ; otherwise such tags are rejected .<CODESPLIT>def sanitize_tag ( tag ) if @require_valid_tags && ( ! tag . is_a? ( String ) || tag == '' || convert_to_utf8 ( tag ) != tag ) return nil end tag = convert_to_utf8 ( tag . to_s ) tag = '_' if tag == '' tag end

1<CODESPLIT>https://github.com/JoshMcKin/hot_tub/blob/44f22b0dfbca40bfe7cc4f7e6393122c88d7da0d/lib/hot_tub/known_clients.rb#L33-L43<CODESPLIT>HotTub.KnownClients.close_client<CODESPLIT>Attempts to close the provided client checking the options first for a close block then checking the known clients<CODESPLIT>def close_client ( clnt ) @close_client = ( known_client_action ( clnt , :close ) || false ) if @close_client . nil? if @close_client begin perform_action ( clnt , @close_client ) rescue => e HotTub . logger . error "[HotTub] There was an error closing one of your #{self.class.name} clients: #{e}" if HotTub . logger end end nil end

0<CODESPLIT>https://github.com/kontena/k8s-client/blob/efa19f43202a5d8840084a804afb936a57dc5bdd/lib/k8s/api_client.rb#L96-L101<CODESPLIT>K8s.APIClient.list_resources<CODESPLIT>TODO : skip non - namespaced resources if namespace is given or ignore namespace?<CODESPLIT>def list_resources ( resources = nil , ** options ) resources ||= self . resources . select ( :list? ) ResourceClient . list ( resources , @transport , ** options ) end

1<CODESPLIT>https://github.com/d0z0/redis_analytics/blob/f29c9db9b7425f0ee80bdd8cf572295e79d3d2bd/lib/redis_analytics/visit.rb#L45-L64<CODESPLIT>RedisAnalytics.Visit.record<CODESPLIT>method used in analytics . rb to initialize visit called from analytics . rb<CODESPLIT>def record if @current_visit_seq track ( "visit_time" , @t . to_i - @last_visit_end_time . to_i ) else @current_visit_seq ||= counter ( "visits" ) track ( "visits" , 1 ) # track core 'visit' metric if @first_visit_seq track ( "repeat_visits" , 1 ) else @first_visit_seq ||= counter ( "unique_visits" ) track ( "first_visits" , 1 ) track ( "unique_visits" , 1 ) end exec_custom_methods ( 'visit' ) # custom methods that are measured on a per-visit basis end exec_custom_methods ( 'hit' ) # custom methods that are measured on a per-page-view (per-hit) basis track ( "page_views" , 1 ) # track core 'page_view' metric track ( "second_page_views" , 1 ) if @page_view_seq_no . to_i == 1 # @last_visit_start_time and (@last_visit_start_time.to_i == @last_visit_end_time.to_i) @rack_response end

1<CODESPLIT>https://github.com/nesquena/rabl/blob/a112a4dd783996dab88299bbfead3fcb3d28f0d3/lib/rabl/builder.rb#L205-L211<CODESPLIT>Rabl.Builder.call_condition_proc<CODESPLIT>Evaluate conditions given a symbol / proc / lambda / variable to evaluate<CODESPLIT>def call_condition_proc ( condition , object ) case condition when Proc then condition . call ( object ) when Symbol then condition . to_proc . call ( object ) else condition end end

1<CODESPLIT>https://github.com/AlchemyCMS/alchemy_cms/blob/0e1c5665984ff67d387c8cb4255f805c296c2fb6/app/controllers/alchemy/api/pages_controller.rb#L9-L20<CODESPLIT>Alchemy.Api::PagesController.index<CODESPLIT>Returns all pages as json object<CODESPLIT>def index # Fix for cancancan not able to merge multiple AR scopes for logged in users if can? :edit_content , Alchemy :: Page @pages = Page . all else @pages = Page . accessible_by ( current_ability , :index ) end if params [ :page_layout ] . present? @pages = @pages . where ( page_layout : params [ :page_layout ] ) end render json : @pages , adapter : :json , root : :pages end

0<CODESPLIT>https://github.com/keita/temppath/blob/27d24d23c1f076733e9dc5cbc2f7a7826963a97c/lib/temppath.rb#L68-L72<CODESPLIT>Temppath.Generator.create<CODESPLIT>Make paths with permission 0700 by defautl . Otherwise this is same as Pathname#mkpath .<CODESPLIT>def create ( option = { } ) _basename = option [ :basename ] || @basename _basedir = @basedir if option [ :basedir ] _basedir = Pathname . new ( option [ :basedir ] ) # extend basedir with secure methods _basedir . extend OriginalMethodHolder _basedir . extend SecurePermissionMethods end # init basedir unless _basedir . exist? _basedir . mkpath end # make a path path = Pathname . new ( _basedir ) + ( _basename . to_s + generate_uuid ) # extend path object with secure methods path . extend OriginalMethodHolder path . extend SecurePermissionMethods # register a file cleaner if the path is not in basedir if _basedir != @basedir Kernel . at_exit do if @unlink FileUtils . remove_entry_secure ( path ) rescue Errno :: ENOENT end end end return path end

1<CODESPLIT>https://github.com/ideonetwork/lato-core/blob/c01fa585725c8e9992f25d8a7bd4ba2d0bfca08c/lib/lato_core/interfaces/modules.rb#L30-L37<CODESPLIT>LatoCore.Interface::Modules.core__get_modules_languages<CODESPLIT>Languages :<CODESPLIT>def core__get_modules_languages lato_modules = core__get_modules_list languages = { } lato_modules . each do | lato_module_name | languages [ lato_module_name . to_sym ] = core__get_module_languages ( lato_module_name ) end languages end

0<CODESPLIT>https://github.com/MakarovCode/EasyPayULatam/blob/c412b36fc316eabc338ce9cd152b8fea7316983d/lib/easy_pay_u_latam/r_api/subscription_interceptor.rb#L34-L38<CODESPLIT>Uninhibited.Formatter.summary_line<CODESPLIT>metodo principal de esta clase al estar en un rescue evitamos que el proyecto saque error 500 cuando algo sale mal INTERCEPTAMOS el error y lo enviamos al controller para que trabaje con el<CODESPLIT>def summary_line ( example_count , failure_count , pending_count ) pending_count -= skipped_count summary = pluralize ( example_count , "example" ) summary << " (" summary << red ( pluralize ( failure_count , "failure" ) ) summary << ", " << yellow ( "#{pending_count} pending" ) if pending_count > 0 summary << ", " << cyan ( "#{skipped_count} skipped" ) if skipped_count > 0 summary << ")" summary end

1<CODESPLIT>https://github.com/NathanTCz/packer-binary/blob/58135b5b02ff466f5f3525e57eac58db5a811acc/lib/packer/binary.rb#L42-L49<CODESPLIT>Packer.Binary.method_missing<CODESPLIT>This method maps Packer :: Binary method calls to Packer sub - commands Ex . to run packer build test . json - machine - readable :<CODESPLIT>def method_missing ( method , * args , & block ) if method . to_s =~ / \w / Packer :: Binary :: Helpers . debug ( "#{method.to_s.downcase} #{args.join(' ')}" ) Command . run ( "#{method.to_s.downcase} #{args.join(' ')}" ) else super end end

0<CODESPLIT>https://github.com/timothyf/gameday_api/blob/2cb629398221f94ffadcaee35fe9740ee30577d4/lib/gameday_api/player.rb#L69-L73<CODESPLIT>GamedayApi.Player.init<CODESPLIT>Returns the number of at bats over the entire season for this player<CODESPLIT>def init ( element , gid ) @gid = gid @pid = element . attributes [ 'id' ] @first = element . attributes [ 'first' ] @last = element . attributes [ 'last' ] @num = element . attributes [ 'num' ] @boxname = element . attributes [ 'boxname' ] @rl , = element . attributes [ 'rl' ] @position = element . attributes [ 'position' ] @status = element . attributes [ 'status' ] @bat_order = element . attributes [ 'bat_order' ] @game_position = element . attributes [ 'game_position' ] @avg = element . attributes [ 'avg' ] @hr = element . attributes [ 'hr' ] @rbi = element . attributes [ 'rbi' ] @wins = element . attributes [ 'wins' ] @losses = element . attributes [ 'losses' ] @era = element . attributes [ 'era' ] set_extra_info end

1<CODESPLIT>https://github.com/williambarry007/caboose-cms/blob/7c112911318f94cc89dba86091903a3acaf0a833/app/models/caboose/authnet.rb#L223-L238<CODESPLIT>Caboose.Authnet.verify_payment_profile<CODESPLIT>============================================================================= Verifies that the user has a payment profile and that the payment profile is valid . Creates an empty payment profile for the user if the payment profile is missing or invalid .<CODESPLIT>def verify_payment_profile ( user ) resp = self . gateway . get_customer_profile ( { :customer_profile_id => user . authnet_customer_profile_id } ) if resp . success? arr = resp . params [ 'profile' ] [ 'payment_profiles' ] arr = [ arr ] if arr && arr . is_a? ( Hash ) if arr . nil? || arr . count == 0 self . create_empty_payment_profile ( user ) user . valid_authnet_payment_profile_id = false else h = arr [ 0 ] user . authnet_payment_profile_id = h [ 'customer_payment_profile_id' ] user . valid_authnet_payment_profile_id = h [ 'bill_to' ] && h [ 'bill_to' ] [ 'address' ] && h [ 'bill_to' ] [ 'address' ] . strip . length > 0 user . save end end end

1<CODESPLIT>https://github.com/njh/ruby-mqtt/blob/878639e85827aa25688e9c4ef1511d393549dcfa/lib/mqtt/client.rb#L372-L384<CODESPLIT>MQTT.Client.get<CODESPLIT>Return the next message received from the MQTT server . An optional topic can be given to subscribe to .<CODESPLIT>def get ( topic = nil , options = { } ) if block_given? get_packet ( topic ) do | packet | yield ( packet . topic , packet . payload ) unless packet . retain && options [ :omit_retained ] end else loop do # Wait for one packet to be available packet = get_packet ( topic ) return packet . topic , packet . payload unless packet . retain && options [ :omit_retained ] end end end

0<CODESPLIT>https://github.com/aws/aws-sdk-ruby/blob/e28b8d320ddf7b6ee0161bdd9d00fb786d99b63d/gems/aws-sdk-rds/lib/aws-sdk-rds/option_group.rb#L308-L312<CODESPLIT>Aws::RDS.OptionGroup.modify<CODESPLIT>@example Request syntax with placeholder values<CODESPLIT>def modify ( options = { } ) options = options . merge ( option_group_name : @name ) resp = @client . modify_option_group ( options ) OptionGroup . new ( name : resp . data . option_group . option_group_name , data : resp . data . option_group , client : @client ) end

1<CODESPLIT>https://github.com/isabanin/mercurial-ruby/blob/d7cc2d3bfeaa7564f6ea8d622fbddd92ca5a3d0a/lib/mercurial-ruby/config_file.rb#L93-L100<CODESPLIT>Mercurial.ConfigFile.find_header<CODESPLIT>Returns content of the specified section of hgrc .<CODESPLIT>def find_header ( header ) { } . tap do | returning | contents . scan ( header_with_content_regexp ( header ) ) . flatten . first . split ( "\n" ) . each do | setting | name , value = setting . split ( '=' ) . map ( :strip ) returning [ name ] = value end end end

0<CODESPLIT>https://github.com/zed-0xff/zpng/blob/d356182ab9bbc2ed3fe5c064488498cf1678b0f0/lib/zpng/color.rb#L142-L147<CODESPLIT>ZPNG.Color.to_depth<CODESPLIT>convert to ANSI color name<CODESPLIT>def to_depth new_depth return self if depth == new_depth color = Color . new :depth => new_depth if new_depth > self . depth %w' r g b a ' . each do | part | color . send ( "#{part}=" , ( 2 ** new_depth - 1 ) / ( 2 ** depth - 1 ) * self . send ( part ) ) end else # new_depth < self.depth %w' r g b a ' . each do | part | color . send ( "#{part}=" , self . send ( part ) >> ( self . depth - new_depth ) ) end end color end

1<CODESPLIT>https://github.com/adamcooke/datey/blob/6bf55aa533f7e17df66b8a188ed6d6e6d17cf06f/lib/datey/formatter.rb#L33-L62<CODESPLIT>Datey.Formatter.date<CODESPLIT>Return the formatted date ( no time )<CODESPLIT>def date ( options = { } ) non_relative_prefix = options [ :non_relative_prefix ] || "on " if interrogator . today? result = "today" elsif interrogator . yesterday? result = "yesterday" elsif interrogator . tomorrow? result = "tomorrow" elsif @context == :future && interrogator . next_x_days? ( 6 ) result = non_relative_prefix + name_of_day elsif @context == :future && interrogator . next_week? result = "next #{name_of_day}" elsif @context == :past && interrogator . last_x_days? ( 6 ) result = non_relative_prefix + name_of_day elsif @context == :past && interrogator . last_x_days? ( 12 ) result = "last #{name_of_day}" elsif @context == :past && interrogator . next_x_days? ( 6 ) result = "next #{name_of_day}" else result = non_relative_prefix + "#{name_of_day} #{day_of_month} #{name_of_month}" result += " #{@time.year}" if include_year_in_dates? result end unless options [ :capitalize ] == false result [ 0 ] = result [ 0 ] . upcase end result end

1<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_automation/lib/2015-10-31/generated/azure_mgmt_automation/node_reports.rb#L241-L244<CODESPLIT>Azure::Automation::Mgmt::V2015_10_31.NodeReports.get_content<CODESPLIT>Retrieve the Dsc node reports by node id and report id .<CODESPLIT>def get_content ( resource_group_name , automation_account_name , node_id , report_id , custom_headers : nil ) response = get_content_async ( resource_group_name , automation_account_name , node_id , report_id , custom_headers :custom_headers ) . value! response . body unless response . nil? end

1<CODESPLIT>https://github.com/bazaarlabs/tvdbr/blob/be9a1324c8d8051b7063bf7152aa1c53c25b0661/lib/tvdbr/client.rb#L47-L53<CODESPLIT>Tvdbr.Client.each_updated_episode<CODESPLIT>Yields the block for every updated episode tvdb . each_updated_episode ( : since = > 1 . day . ago ) { |s| Episode . find_by_tvdb_id ( s . id ) . title = s . title } tvdb . each_updated_episode ( : period = > : day ) { |s| Episode . find_by_tvdb_id ( s . id ) . title = s . title }<CODESPLIT>def each_updated_episode ( options = { } , & block ) updates = options [ :since ] ? find_updates_since ( options [ :since ] ) : find_static_updates ( options [ :period ] ) updates [ :episodes ] . each do | episode_id | episode = self . find_episode_by_id ( episode_id ) block . call ( episode ) if episode && episode . name end if updates [ :episodes ] . respond_to? ( :each ) end

1<CODESPLIT>https://github.com/aws/aws-sdk-ruby/blob/e28b8d320ddf7b6ee0161bdd9d00fb786d99b63d/gems/aws-sdk-ec2/lib/aws-sdk-ec2/instance.rb#L559-L563<CODESPLIT>Aws::EC2.Instance.attach_classic_link_vpc<CODESPLIT>@!group Actions @example Request syntax with placeholder values<CODESPLIT>def attach_classic_link_vpc ( options = { } ) options = options . merge ( instance_id : @id ) resp = @client . attach_classic_link_vpc ( options ) resp . data end

1<CODESPLIT>https://github.com/fortinmike/git-multirepo/blob/81cef8abf780eb676798724adb0350acfa06a10b/lib/multirepo/commands/install-command.rb#L92-L104<CODESPLIT>MultiRepo.InstallCommand.clone_or_fetch<CODESPLIT>Repo operations<CODESPLIT>def clone_or_fetch ( dependency ) if dependency . config_entry . repo . exists? check_repo_validity ( dependency ) Console . log_substep ( "Working copy '#{dependency.config_entry.repo.path}' already exists, fetching..." ) ExtraOutput . progress ( "Fetching #{dependency.config_entry.repo.basename}" ) if @ci fetch_repo ( dependency ) else Console . log_substep ( "Cloning #{dependency.config_entry.url} into '#{dependency.config_entry.repo.path}'" ) ExtraOutput . progress ( "Cloning into #{dependency.config_entry.repo.basename}" ) if @ci clone_repo ( dependency ) end end

1<CODESPLIT>https://github.com/ONLYOFFICE/ooxml_parser/blob/08452315cde52fa94d8cb3e1eff1db4ea33abc88/lib/ooxml_parser/docx_parser/docx_data/document_structure/docx_paragraph/bookmark_start.rb#L12-L22<CODESPLIT>OoxmlParser.BookmarkStart.parse<CODESPLIT>Parse BookmarkStart object<CODESPLIT>def parse ( node ) node . attributes . each do | key , value | case key when 'id' @id = value . value . to_i when 'name' @name = value . value end end self end

0<CODESPLIT>https://github.com/solnic/transflow/blob/725eaa8e24f6077b07d7c4c47ddab1d78ceb5577/lib/transflow/transaction.rb#L107-L112<CODESPLIT>VR.Alert.before_show<CODESPLIT>Call the transaction<CODESPLIT>def before_show @flags [ :title ] = @flags [ :title ] ? @flags [ :title ] : @flags [ :headline ] @builder [ :window1 ] . title = @flags [ :title ] if @flags [ :title ] @builder [ :window1 ] . resize ( @flags [ :width ] , 100 ) if @flags [ :width ] . to_i > 100 @builder [ :headline ] . show if @flags [ :headline ] if @flags [ :input_text ] @flags [ :button_yes ] ||= "Save" @flags [ :button_no ] ||= "Cancel" @builder [ :input_text ] . show elsif choices = @flags [ :choices ] @flags [ :button_yes ] ||= "Select" @flags [ :button_no ] ||= "Cancel" choices . each { | c | @builder [ :choices_text ] . append_text ( c ) } @choices_text = choices [ 0 ] @builder [ :choices_text ] . show end @builder [ :button_no ] . show if @flags [ :button_no ] @builder [ :button_cancel ] . show if @flags [ :button_cancel ] set_glade_hash ( @flags ) end

1<CODESPLIT>https://github.com/agarie/measurable/blob/8ff8efbab1a0892bdddf6e865dd8864956168a91/lib/measurable/cosine.rb#L46-L51<CODESPLIT>Measurable.Cosine.cosine_distance<CODESPLIT>call - seq : cosine_distance ( u v ) - > Float<CODESPLIT>def cosine_distance ( u , v ) # TODO: Change this to a more specific, custom-made exception. raise ArgumentError if u . size != v . size 1 - cosine_similarity ( u , v ) end

1<CODESPLIT>https://github.com/mvidner/ruby-dbus/blob/336f1871bf0f6a0669391fb2bcf7f3a003ec97c9/lib/dbus/bus.rb#L336-L354<CODESPLIT>DBus.Connection.send_sync_or_async<CODESPLIT>This apostroph is for syntax highlighting editors confused by above xml :<CODESPLIT>def send_sync_or_async ( message , & reply_handler ) ret = nil if reply_handler . nil? send_sync ( message ) do | rmsg | raise rmsg if rmsg . is_a? ( Error ) ret = rmsg . params end else on_return ( message ) do | rmsg | if rmsg . is_a? ( Error ) reply_handler . call ( rmsg ) else reply_handler . call ( rmsg , rmsg . params ) end end @message_queue . push ( message ) end ret end

0<CODESPLIT>https://github.com/meew0/discordrb/blob/764298a1ff0be69a1853b510d736f21c2b91a2fe/lib/discordrb/events/message.rb#L142-L149<CODESPLIT>Discordrb::Events.MessageEvent.send_file<CODESPLIT>Attaches a file to the message event and converts the message into a caption .<CODESPLIT>def send_file ( file , caption : nil , filename : nil , spoiler : nil ) @message . channel . send_file ( file , caption : caption , filename : filename , spoiler : spoiler ) end

1<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_container_service/lib/2017-07-01/generated/azure_mgmt_container_service/container_services.rb#L467-L469<CODESPLIT>Azure::ContainerService::Mgmt::V2017_07_01.ContainerServices.begin_create_or_update_with_http_info<CODESPLIT>Creates or updates a container service .<CODESPLIT>def begin_create_or_update_with_http_info ( resource_group_name , container_service_name , parameters , custom_headers : nil ) begin_create_or_update_async ( resource_group_name , container_service_name , parameters , custom_headers :custom_headers ) . value! end

0<CODESPLIT>https://github.com/NCSU-Libraries/lentil/blob/c31775447a52db1781c05f6724ae293698527fe6/lib/lentil/instagram_harvester.rb#L118-L151<CODESPLIT>Lentil.InstagramHarvester.extract_image_data<CODESPLIT>Takes return from Instagram API gem and adds image users and tags to the database .<CODESPLIT>def extract_image_data ( instagram_metadata ) { url : instagram_metadata . link , external_id : instagram_metadata . id , large_url : instagram_metadata . images . standard_resolution . url , name : instagram_metadata . caption && instagram_metadata . caption . text , tags : instagram_metadata . tags , user : instagram_metadata . user , original_datetime : Time . at ( instagram_metadata . created_time . to_i ) . to_datetime , original_metadata : instagram_metadata , media_type : instagram_metadata . type , video_url : instagram_metadata . videos && instagram_metadata . videos . standard_resolution . url } end

0<CODESPLIT>https://github.com/cookpad/rrrspec/blob/a5bde2b062ce68b1e32b8caddf194389c2ce28b0/rrrspec-client/lib/rrrspec/redis_models.rb#L411-L414<CODESPLIT>RRRSpec.Taskset.to_h<CODESPLIT>Public : Returns the finished_at<CODESPLIT>def to_h h = RRRSpec . redis . hgetall ( key ) h [ 'key' ] = key h [ 'log' ] = log h [ 'tasks' ] = tasks . map { | task | { 'key' => task . key } } h [ 'slaves' ] = slaves . map { | slave | { 'key' => slave . key } } h [ 'worker_logs' ] = worker_logs . map { | worker_log | { 'key' => worker_log . key } } RRRSpec . convert_if_present ( h , 'max_workers' ) { | v | v . to_i } RRRSpec . convert_if_present ( h , 'max_trials' ) { | v | v . to_i } RRRSpec . convert_if_present ( h , 'unknown_spec_timeout_sec' ) { | v | v . to_i } RRRSpec . convert_if_present ( h , 'least_timeout_sec' ) { | v | v . to_i } RRRSpec . convert_if_present ( h , 'created_at' ) { | v | Time . zone . parse ( v ) } RRRSpec . convert_if_present ( h , 'finished_at' ) { | v | Time . zone . parse ( v ) } h . delete ( 'succeeded_count' ) h . delete ( 'failed_count' ) h end

0<CODESPLIT>https://github.com/spraints/resqued/blob/5d95bdfe009ce99ae745af552b6446b1465a3eb8/lib/resqued/listener.rb#L99-L114<CODESPLIT>Resqued.Listener.run<CODESPLIT>Private .<CODESPLIT>def run trap ( :CHLD ) { awake } SIGNALS . each { | signal | trap ( signal ) { SIGNAL_QUEUE << signal ; awake } } @socket . close_on_exec = true write_procline ( 'starting' ) config = Resqued :: Config . new ( @config_paths ) set_default_resque_logger config . before_fork ( info ) report_to_master ( "RUNNING" ) write_procline ( 'running' ) init_workers ( config ) exit_signal = run_workers_run write_procline ( 'shutdown' ) burn_down_workers ( exit_signal || :QUIT ) end

1<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_stor_simple8000_series/lib/2017-06-01/generated/azure_mgmt_stor_simple8000_series/volume_containers.rb#L151-L153<CODESPLIT>Azure::StorSimple8000Series::Mgmt::V2017_06_01.VolumeContainers.get_with_http_info<CODESPLIT>Gets the properties of the specified volume container name .<CODESPLIT>def get_with_http_info ( device_name , volume_container_name , resource_group_name , manager_name , custom_headers : nil ) get_async ( device_name , volume_container_name , resource_group_name , manager_name , custom_headers :custom_headers ) . value! end

0<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_container_instance/lib/2018-02-01-preview/generated/azure_mgmt_container_instance/start_container.rb#L40-L43<CODESPLIT>Azure::ContainerInstance::Mgmt::V2018_02_01_preview.StartContainer.launch_exec_with_http_info<CODESPLIT>Starts the exec command for a specific container instance .<CODESPLIT>def launch_exec_with_http_info ( resource_group_name , container_group_name , container_name , container_exec_request , custom_headers : nil ) launch_exec_async ( resource_group_name , container_group_name , container_name , container_exec_request , custom_headers :custom_headers ) . value! end

0<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/data/azure_service_fabric/lib/6.2.0.9/generated/azure_service_fabric/service_fabric_client_apis.rb#L5204-L5207<CODESPLIT>Azure::ServiceFabric::V6_2_0_9.ServiceFabricClientAPIs.unprovision_application_type_with_http_info<CODESPLIT>Removes or unregisters a Service Fabric application type from the cluster .<CODESPLIT>def unprovision_application_type_with_http_info ( application_type_name , unprovision_application_type_description_info , timeout : 60 , custom_headers : nil ) unprovision_application_type_async ( application_type_name , unprovision_application_type_description_info , timeout : timeout , custom_headers :custom_headers ) . value! end

1<CODESPLIT>https://github.com/cinchrb/cinch/blob/2e149ffcf94d0f4eb6c1566a8e39d7e6d8be4ee0/lib/cinch/message.rb#L193-L200<CODESPLIT>Cinch.Message.reply<CODESPLIT>@group Replying Replies to a message automatically determining if it was a channel or a private message .<CODESPLIT>def reply ( text , prefix = false ) text = text . to_s if @channel && prefix text = text . split ( "\n" ) . map { | l | "#{user.nick}: #{l}" } . join ( "\n" ) end reply_target . send ( text ) end

0<CODESPLIT>https://github.com/tsenying/simple_geocoder/blob/8958504584dc02c048f56295f1c4f19e52a2be6a/lib/simple_geocoder/geocoder.rb#L36-L49<CODESPLIT>Megam.Promos.to_hash<CODESPLIT>if geocoding fails then look for lat lng string in address<CODESPLIT>def to_hash index_hash = Hash . new index_hash [ "json_claz" ] = self . class . name index_hash [ "id" ] = id index_hash [ "code" ] = code index_hash [ "amount" ] = amount index_hash [ "created_at" ] = created_at index_hash end

0<CODESPLIT>https://github.com/ccocchi/rabl-rails/blob/8d4c7eef42b9721e0aa68fece24457368614334f/lib/rabl-rails/compiler.rb#L70-L75<CODESPLIT>RablRails.Compiler.glue<CODESPLIT>Creates a child node to be included in the output . name_or data can be an object or collection or a method to call on the data . It accepts : root and : partial options . Note that partial and blocks are not compatible Example : child ( :<CODESPLIT>def glue ( data , options = { } ) template = partial_or_block ( data , options ) { yield } @template . add_node Nodes :: Glue . new ( template ) end

1<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/data/azure_key_vault/lib/2016-10-01/generated/azure_key_vault/key_vault_client.rb#L4454-L4457<CODESPLIT>Azure::KeyVault::V2016_10_01.KeyVaultClient.delete_certificate_contacts<CODESPLIT>Deletes the certificate contacts for a specified key vault .<CODESPLIT>def delete_certificate_contacts ( vault_base_url , custom_headers : nil ) response = delete_certificate_contacts_async ( vault_base_url , custom_headers :custom_headers ) . value! response . body unless response . nil? end

1<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_cdn/lib/2016-10-02/generated/azure_mgmt_cdn/profiles.rb#L803-L805<CODESPLIT>Azure::CDN::Mgmt::V2016_10_02.Profiles.begin_create_with_http_info<CODESPLIT>Creates a new CDN profile with a profile name under the specified subscription and resource group .<CODESPLIT>def begin_create_with_http_info ( resource_group_name , profile_name , profile , custom_headers : nil ) begin_create_async ( resource_group_name , profile_name , profile , custom_headers :custom_headers ) . value! end

1<CODESPLIT>https://github.com/fusioncharts/rails-wrapper/blob/277c20fe97b29f94c64e31345c36eb4e0715c93f/samples/lib/fusioncharts/rails/chart.rb#L102-L111<CODESPLIT>Fusioncharts.Chart.render<CODESPLIT>Render the chart<CODESPLIT>def render config = json_escape JSON . generate ( self . options ) if @timeSeriesSource config . gsub! '"__DataSource__"' , json_escape ( @timeSeriesSource ) end dataUrlFormat = self . jsonUrl? ? "json" : ( self . xmlUrl ? "xml" : nil ) template = File . read ( File . expand_path ( "../../../templates/chart.erb" , __FILE__ ) ) renderer = ERB . new ( template ) return raw renderer . result ( binding ) end

0<CODESPLIT>https://github.com/indeep-xyz/ruby-file-char-licker/blob/06d9cee1bf0a40a1f90f35e6b43e211609a03b08/lib/file_char_licker/licker/mb_licker.rb#L86-L102<CODESPLIT>PhpFpmDocker.Launcher.parse_config<CODESPLIT>String#index for multibyte<CODESPLIT>def parse_config # rubocop:disable MethodLength # Test for file usability fail "Config file '#{@config_path}' not found" unless @config_path . file? fail "Config file '#{@config_path}' not readable" unless @config_path . readable? @ini_file = IniFile . load ( @config_path ) begin docker_image = @ini_file [ :main ] [ 'docker_image' ] @docker_image = Docker :: Image . get ( docker_image ) @logger . info ( to_s ) do "Docker image id=#{@docker_image.id[0..11]} name=#{docker_image}" end rescue NoMethodError raise 'No docker_image in section main in config found' rescue Docker :: Error :: NotFoundError raise "Docker_image '#{docker_image}' not found" rescue Excon :: Errors :: SocketError => e raise "Docker connection could not be established: #{e.message}" end end

1<CODESPLIT>https://github.com/cxn03651/write_xlsx/blob/6d658b29512e5ab63b947e2b03e67df70a83b55c/lib/write_xlsx/chart.rb#L1234-L1302<CODESPLIT>Writexlsx.Chart.write_cat_axis<CODESPLIT>Write the <c : catAx > element . Usually the X axis .<CODESPLIT>def write_cat_axis ( params ) # :nodoc: x_axis = params [ :x_axis ] y_axis = params [ :y_axis ] axis_ids = params [ :axis_ids ] # if there are no axis_ids then we don't need to write this element return unless axis_ids return if axis_ids . empty? position = @cat_axis_position horiz = @horiz_cat_axis # Overwrite the default axis position with a user supplied value. position = x_axis . position || position @writer . tag_elements ( 'c:catAx' ) do write_axis_id ( axis_ids [ 0 ] ) # Write the c:scaling element. write_scaling ( x_axis . reverse ) write_delete ( 1 ) unless ptrue? ( x_axis . visible ) # Write the c:axPos element. write_axis_pos ( position , y_axis . reverse ) # Write the c:majorGridlines element. write_major_gridlines ( x_axis . major_gridlines ) # Write the c:minorGridlines element. write_minor_gridlines ( x_axis . minor_gridlines ) # Write the axis title elements. if x_axis . formula write_title_formula ( x_axis , horiz , @x_axis , x_axis . layout ) elsif x_axis . name write_title_rich ( x_axis , horiz , x_axis . layout ) end # Write the c:numFmt element. write_cat_number_format ( x_axis ) # Write the c:majorTickMark element. write_major_tick_mark ( x_axis . major_tick_mark ) # Write the c:tickLblPos element. write_tick_label_pos ( x_axis . label_position ) # Write the c:spPr element for the axis line. write_sp_pr ( x_axis ) # Write the axis font elements. write_axis_font ( x_axis . num_font ) # Write the c:crossAx element. write_cross_axis ( axis_ids [ 1 ] ) if @show_crosses || ptrue? ( x_axis . visible ) write_crossing ( y_axis . crossing ) end # Write the c:auto element. write_auto ( 1 ) unless x_axis . text_axis # Write the c:labelAlign element. write_label_align ( 'ctr' ) # Write the c:labelOffset element. write_label_offset ( 100 ) # Write the c:tickLblSkip element. write_tick_lbl_skip ( x_axis . interval_unit ) end end

0<CODESPLIT>https://github.com/square/connect-ruby-sdk/blob/798eb9ded716f23b9f1518386f1c311a34bca8bf/lib/square_connect/models/v1_list_payments_request.rb#L130-L136<CODESPLIT>SquareConnect.AdditionalRecipientReceivable.transaction_id=<CODESPLIT>Custom attribute writer method checking allowed values ( enum ) .<CODESPLIT>def transaction_id = ( transaction_id ) if transaction_id . nil? fail ArgumentError , "transaction_id cannot be nil" end if transaction_id . to_s . length < 1 fail ArgumentError , "invalid value for 'transaction_id', the character length must be great than or equal to 1." end @transaction_id = transaction_id end

1<CODESPLIT>https://github.com/primer/octicons/blob/6fe5475945d5633818b49ce55619ec039789b1c8/lib/octicons_jekyll/lib/jekyll-octicons.rb#L58-L68<CODESPLIT>Jekyll.Octicons.string_to_hash<CODESPLIT>Create a ruby hash from a string passed by the jekyll tag<CODESPLIT>def string_to_hash ( markup ) options = { } if match = markup . match ( Syntax ) markup . scan ( TagAttributes ) do | key , value | options [ key . to_sym ] = value . gsub ( / \A \z / , "" ) end end options end

0<CODESPLIT>https://github.com/etagwerker/dinero_mail_ipn/blob/50d6932e5db99e34b8e521cc494e19599c009e18/lib/dinero_mail_ipn/notification_parser.rb#L53-L57<CODESPLIT>RightGit::Shell.Default.execute<CODESPLIT>Locates an XSD file .<CODESPLIT>def execute ( cmd , options = { } ) options = { :directory => nil , :outstream => nil , :raise_on_failure => true , :set_env_vars => nil , :clear_env_vars => nil , :logger => default_logger , :timeout => nil , :keep_alive_interval => nil , :keep_alive_timeout => nil } . merge ( options ) outstream = options [ :outstream ] logger = options [ :logger ] if keep_alive_interval = options [ :keep_alive_interval ] keep_alive_wake_time = :: Time . now + keep_alive_interval else keep_alive_wake_time = nil end if keep_alive_timeout = options [ :keep_alive_timeout ] unless keep_alive_interval raise :: ArgumentError , ':keep_alive_interval is required when using :keep_alive_timeout' end keep_alive_stop_time = :: Time . now + keep_alive_timeout else keep_alive_stop_time = nil end # build initial popener. exitstatus = nil popener = lambda do | output | output . sync = true loop do # note stdout remains selectable after process dies. if ( :: IO . select ( [ output ] , nil , nil , 0.1 ) rescue nil ) if data = output . gets if outstream outstream << data else data = data . strip unless data . empty? logger . info ( data ) # reset keep alive timer whenever we have normal output. if keep_alive_wake_time keep_alive_wake_time = :: Time . now + keep_alive_interval end end end else break end elsif keep_alive_wake_time now = :: Time . now if keep_alive_stop_time && now >= keep_alive_stop_time keep_alive_wake_time = nil elsif now >= keep_alive_wake_time # keep-alives go to logger, not the outstream, if any. logger . info ( '.' ) keep_alive_wake_time = now + keep_alive_interval end now = nil end end end # timeout optionally wraps popener. the timeout must happen inside of the # IO.popen block or else it has no good effect. if timeout = options [ :timeout ] popener = lambda do | p | lambda do | o | :: Timeout . timeout ( timeout ) { p . call ( o ) } end end . call ( popener ) end # build initial executioner in terms of popener. executioner = lambda do logger . info ( "+ #{cmd}" ) error_msg = nil :: IO . popen ( "#{cmd} 2>&1" , 'r' ) do | output | begin popener . call ( output ) rescue :: EOFError # done rescue :: Timeout :: Error # kill still-running process or else popen's ensure will hang. :: Process . kill ( 'KILL' , output . pid ) # intentionally not reading last data as that could still block # due to a child of created process inheriting stdout. error_msg = "Execution timed out after #{options[:timeout]} seconds." end end # note that a killed process may exit 0 under Windows. exitstatus = $? . exitstatus if 0 == exitstatus && error_msg exitstatus = 1 end if ( exitstatus != 0 && options [ :raise_on_failure ] ) error_msg ||= "Execution failed with exitstatus #{exitstatus}" raise ShellError , error_msg end end # configure executioner (by options) and then invoke executioner. configure_executioner ( executioner , options ) . call return exitstatus end

0<CODESPLIT>https://github.com/doubleleft/hook-ruby/blob/f6acdd89dfe6ed9161380300c2dff2f19f0f744a/lib/hook-client/collection.rb#L35-L43<CODESPLIT>Types.Type.match_type?<CODESPLIT>Create an item into the collection<CODESPLIT>def match_type? ( object ) result = object . kind_of_any? self . type_classes if not result result = object . type_of_any? self . type_types end return result end

1<CODESPLIT>https://github.com/rhomobile/rhodes/blob/3c5f87b1a44f0ba2865ca0e1dd780dd202f64872/res/build-tools/ruby-standalone/212/usr/local/lib/ruby/2.1.0/net/http.rb#L1401-L1443<CODESPLIT>Net.HTTP.transport_request<CODESPLIT>: nodoc :<CODESPLIT>def transport_request ( req ) count = 0 begin begin_transport req res = catch ( :response ) { req . exec @socket , @curr_http_version , edit_path ( req . path ) begin res = HTTPResponse . read_new ( @socket ) res . decode_content = req . decode_content end while res . kind_of? ( HTTPContinue ) res . uri = req . uri res . reading_body ( @socket , req . response_body_permitted? ) { yield res if block_given? } res } rescue Net :: OpenTimeout raise rescue Net :: ReadTimeout , IOError , EOFError , Errno :: ECONNRESET , Errno :: ECONNABORTED , Errno :: EPIPE , # avoid a dependency on OpenSSL defined? ( OpenSSL :: SSL ) ? OpenSSL :: SSL :: SSLError : IOError , Timeout :: Error => exception if count == 0 && IDEMPOTENT_METHODS_ . include? ( req . method ) count += 1 @socket . close if @socket and not @socket . closed? D "Conn close because of error #{exception}, and retry" retry end D "Conn close because of error #{exception}" @socket . close if @socket and not @socket . closed? raise end end_transport req , res res rescue => exception D "Conn close because of error #{exception}" @socket . close if @socket and not @socket . closed? raise exception end

1<CODESPLIT>https://github.com/otherinbox/luggage/blob/032095e09e34cf93186dd9eea4d617d6cdfdd3ec/lib/luggage/message.rb#L107-L113<CODESPLIT>Luggage.Message.method_missing<CODESPLIT>Proxy all other methods to this instance s Mail :: Message<CODESPLIT>def method_missing ( meth , * args , & block ) if mail . respond_to? ( meth ) mail . send ( meth , args , block ) else super end end

1<CODESPLIT>https://github.com/yujinakayama/astrolabe/blob/d7279b21e9fef9f56a48f87ef1403eb5264a9600/lib/astrolabe/node.rb#L132-L143<CODESPLIT>Astrolabe.Node.each_child_node<CODESPLIT>Calls the given block for each child node . If no block is given an Enumerator is returned .<CODESPLIT>def each_child_node ( * types ) return to_enum ( __method__ , types ) unless block_given? types . flatten! children . each do | child | next unless child . is_a? ( Node ) yield child if types . empty? || types . include? ( child . type ) end self end

0<CODESPLIT>https://github.com/square/connect-ruby-sdk/blob/798eb9ded716f23b9f1518386f1c311a34bca8bf/lib/square_connect/models/money.rb#L90-L95<CODESPLIT>SquareConnect.V1PageCell.valid?<CODESPLIT>Check to see if the all the properties in the model are valid<CODESPLIT>def valid? object_type_validator = EnumAttributeValidator . new ( 'String' , [ "ITEM" , "DISCOUNT" , "CATEGORY" , "PLACEHOLDER" ] ) return false unless object_type_validator . valid? ( @object_type ) placeholder_type_validator = EnumAttributeValidator . new ( 'String' , [ "ALL_ITEMS" , "DISCOUNTS_CATEGORY" , "REWARDS_FINDER" ] ) return false unless placeholder_type_validator . valid? ( @placeholder_type ) return true end

1<CODESPLIT>https://github.com/jmettraux/ruote/blob/30a6bb88a4e48ed2e1b9089754f1c8be8c1a879c/lib/ruote/reader.rb#L79-L118<CODESPLIT>Ruote.Reader.read<CODESPLIT>Turns the input into a ruote syntax tree ( raw process definition ) . This method is used by engine . launch ( x ) for example .<CODESPLIT>def read ( definition ) return definition if Ruote . is_tree? ( definition ) raise ArgumentError . new ( "cannot read process definitions of class #{definition.class}" ) unless definition . is_a? ( String ) if is_uri? ( definition ) if Ruote :: Reader . remote? ( definition ) && @context [ 'remote_definition_allowed' ] != true then raise ArgumentError . new ( 'remote process definitions are not allowed' ) end return read ( open ( definition ) . read ) end tree = nil error = Error . new ( definition ) [ Ruote :: RubyReader , Ruote :: RadialReader , Ruote :: XmlReader , Ruote :: JsonReader ] . each do | reader | next if tree next unless reader . understands? ( definition ) begin tree = reader . read ( definition , @context . treechecker ) rescue => e error << [ reader , e ] end end tree || raise ( error ) end

0<CODESPLIT>https://github.com/sugaryourcoffee/syclink/blob/941ee2045c946daa1e0db394eb643aa82c1254cc/lib/syclink/designer.rb#L152-L157<CODESPLIT>SycLink.Designer.delete_website<CODESPLIT>Creates the html representation of the website . The website is saved to the directory with websites title and needs an erb - template where the links are integrated to . An example template can be found at templates / syclink . html . erb<CODESPLIT>def delete_website ( directory ) if File . exists? yaml_file ( directory , website . title ) FileUtils . rm ( yaml_file ( directory , website . title ) ) end end

1<CODESPLIT>https://github.com/mongodb/mongo-ruby-driver/blob/dca26d0870cb3386fad9ccc1d17228097c1fe1c8/lib/mongo/uri.rb#L598-L602<CODESPLIT>Mongo.URI.add_uri_option<CODESPLIT>Adds an option to the uri options hash via the supplied strategy .<CODESPLIT>def add_uri_option ( key , strategy , value , uri_options ) target = select_target ( uri_options , strategy [ :group ] ) value = apply_transform ( key , value , strategy [ :type ] ) merge_uri_option ( target , value , strategy [ :name ] ) end

0<CODESPLIT>https://github.com/AzureAD/azure-activedirectory-library-for-ruby/blob/5d2f2530298a2545ca8caf688eabcd1143ffa304/lib/adal/token_request.rb#L118-L125<CODESPLIT>ADAL.TokenRequest.get_with_user_credential<CODESPLIT>Gets a token based on a previously acquired refresh token .<CODESPLIT>def get_with_user_credential ( user_cred , resource = nil ) logger . verbose ( 'TokenRequest getting token with user credential ' "#{user_cred} and resource #{resource}." ) oauth = if user_cred . is_a? UserIdentifier lambda do fail UserCredentialError , 'UserIdentifier can only be used once there is a ' 'matching token in the cache.' end end || -> { } request ( user_cred . request_params . merge ( RESOURCE => resource ) , oauth ) end

0<CODESPLIT>https://github.com/decidim/decidim/blob/6e2b14e559a63088669904e3c5c49a5180700cf7/decidim-core/lib/decidim/form_builder.rb#L26-L28<CODESPLIT>Decidim.IconHelper.resource_icon<CODESPLIT>Public : generates a check boxes input from a collection and adds help text and errors .<CODESPLIT>def resource_icon ( resource , options = { } ) if resource . class . name == "Decidim::Comments::Comment" icon "comment-square" , options elsif resource . respond_to? ( :component ) component_icon ( resource . component , options ) elsif resource . respond_to? ( :manifest ) manifest_icon ( resource . manifest , options ) elsif resource . is_a? ( Decidim :: User ) icon "person" , options else icon "bell" , options end end

0<CODESPLIT>https://github.com/osiro/enceladus/blob/874a8f0ad55bf3528e3e193b298967f0997d66b3/lib/enceladus/configuration/image.rb#L71-L79<CODESPLIT>Danger.DangerPronto.lint<CODESPLIT>Returns a boolean indicating whether the Image configurations are valid or not .<CODESPLIT>def lint ( commit = nil ) files = pronto ( commit ) return if files . empty? markdown offenses_message ( files ) end

0<CODESPLIT>https://github.com/andymeneely/squib/blob/1d307fe6e00306e7b21f35e6c51955724e4e0673/lib/squib/api/text.rb#L11-L22<CODESPLIT>Squib.Deck.show_info<CODESPLIT>DSL method . See http : // squib . readthedocs . io<CODESPLIT>def show_info ( config , layout ) Squib :: logger . info "Squib v#{Squib::VERSION}" Squib :: logger . info "  building #{@cards.size} #{@width}x#{@height} cards" Squib :: logger . info "  using #{@backend}" end

0<CODESPLIT>https://github.com/Yellowen/site_framework/blob/d4b1067c37c09c802aa4e1d5588ffdd3631f6395/lib/site_framework/middleware.rb#L13-L42<CODESPLIT>Middleman::Galley.Helper.nested<CODESPLIT>Middleware initializer method which gets the app from previous middleware<CODESPLIT>def nested a . current_page . children . select { | x | nested? x } . sort_by { | x | name x } . map { | x | link x } . join end

0<CODESPLIT>https://github.com/etagwerker/dinero_mail_ipn/blob/50d6932e5db99e34b8e521cc494e19599c009e18/lib/dinero_mail_ipn.rb#L74-L79<CODESPLIT>DineroMailIpn.Client.consulta_transacciones<CODESPLIT>@param [ Hash ] opts opciones para crear la instancia @option opts [ String ] : email Email de la cuenta de Dinero Mail @option opts [ String ] : account Nmero de cuenta de Dinero Mail ( sin / ) @option opts [ String ] : pin PIN de la cuenta de Dinero Mail @option opts [ String ] : password Contrasea para consultas de IPN v2 @option opts [ String ] : pais Pais de la cuenta . Por default : argentina Devuelve una { ConsultaPagoResponse } .<CODESPLIT>def consulta_transacciones ( transacciones = [ ] ) xml_builder = Nokogiri :: XML :: Builder . new do | xml | xml . REPORTE { xml . NROCTA @account xml . DETALLE { xml . CONSULTA { xml . CLAVE @password xml . TIPO 1 xml . OPERACIONES { transacciones . each do | transaction_id | xml . ID transaction_id end } } } } end body = xml_builder . to_xml body . sub! ( "<?xml version=\"1.0\"?>" , "" ) body . gsub! ( / \s / , '' ) response = self . class . post ( "http://#{@pais}.dineromail.com/Vender/Consulta_IPN.asp" , :body => "DATA=#{body}" , :headers => { "Content-type" => "application/x-www-form-urlencoded" , "Content-length" => "#{body.length}" } ) . response . body DineroMailIpn :: Reporter . new ( response ) end

0<CODESPLIT>https://github.com/stereobooster/typograf/blob/c2f89dac63361e58a856801e474db55f2fb8a472/lib/typograf/client.rb#L118-L151<CODESPLIT>ActsAsSolr.ActsMethods.acts_as_solr<CODESPLIT>Process text with remote web - service<CODESPLIT>def acts_as_solr ( options = { } , solr_options = { } , & deferred_solr_configuration ) $solr_indexed_models << self extend ClassMethods include InstanceMethods include CommonMethods include ParserMethods define_solr_configuration_methods acts_as_taggable_on :tags if options [ :taggable ] has_many :dynamic_attributes , :as => "dynamicable" if options [ :dynamic_attributes ] has_one :local , :as => "localizable" if options [ :spatial ] after_save :solr_save after_destroy :solr_destroy if deferred_solr_configuration self . deferred_solr_configuration = deferred_solr_configuration else process_acts_as_solr ( options , solr_options ) end end

0<CODESPLIT>https://github.com/nbulaj/alpha_card/blob/06fefc2dbbf0e7002fabb2be361b8d72a178f559/lib/alpha_card/resource.rb#L58-L64<CODESPLIT>AlphaCard.Resource.attributes_for_request<CODESPLIT>Validate required attributes to be filled . Raises an exception if one of the attribute is not specified .<CODESPLIT>def attributes_for_request ( attrs = filled_attributes ) return attrs if self . class :: ORIGIN_TRANSACTION_VARIABLES . empty? attrs . each_with_object ( { } ) do | ( attr , value ) , request_attrs | request_attrs [ self . class :: ORIGIN_TRANSACTION_VARIABLES . fetch ( attr , attr ) ] = value end end

1<CODESPLIT>https://github.com/shinesolutions/swagger-aem/blob/ae7da4df93e817dc2bad843779b2069d9c4e7c6b/ruby/generated/lib/swagger_aem/api_client.rb#L89-L129<CODESPLIT>SwaggerAemClient.ApiClient.build_request<CODESPLIT>Builds the HTTP request<CODESPLIT>def build_request ( http_method , path , opts = { } ) url = build_request_url ( path ) http_method = http_method . to_sym . downcase header_params = @default_headers . merge ( opts [ :header_params ] || { } ) query_params = opts [ :query_params ] || { } form_params = opts [ :form_params ] || { } update_params_for_auth! header_params , query_params , opts [ :auth_names ] # set ssl_verifyhosts option based on @config.verify_ssl_host (true/false) _verify_ssl_host = @config . verify_ssl_host ? 2 : 0 req_opts = { :method => http_method , :headers => header_params , :params => query_params , :params_encoding => @config . params_encoding , :timeout => @config . timeout , :ssl_verifypeer => @config . verify_ssl , :ssl_verifyhost => _verify_ssl_host , :sslcert => @config . cert_file , :sslkey => @config . key_file , :verbose => @config . debugging } # set custom cert, if provided req_opts [ :cainfo ] = @config . ssl_ca_cert if @config . ssl_ca_cert if [ :post , :patch , :put , :delete ] . include? ( http_method ) req_body = build_request_body ( header_params , form_params , opts [ :body ] ) req_opts . update :body => req_body if @config . debugging @config . logger . debug "HTTP request body param ~BEGIN~\n#{req_body}\n~END~\n" end end request = Typhoeus :: Request . new ( url , req_opts ) download_file ( request ) if opts [ :return_type ] == 'File' request end

1<CODESPLIT>https://github.com/roo-rb/roo/blob/4ec1104f0c3c2a29711c0c907371cd2be12bcc3c/lib/roo/excelx.rb#L176-L180<CODESPLIT>Roo.Excelx.formulas<CODESPLIT>returns each formula in the selected sheet as an array of tuples in following format [[ row col formula ] [ row col formula ] ... ]<CODESPLIT>def formulas ( sheet = nil ) sheet_for ( sheet ) . cells . select { | _ , cell | cell . formula } . map do | ( x , y ) , cell | [ x , y , cell . formula ] end end

0<CODESPLIT>https://github.com/kristianmandrup/cream/blob/6edbdc8796b4a942e11d1054649b2e058c90c9d8/lib/cream/controller/user_control.rb#L54-L63<CODESPLIT>Cream.UserControl.sign_out<CODESPLIT>Sign in an user that already was authenticated . This helper is useful for logging users in after sign up .<CODESPLIT>def sign_out ( resource_or_scope ) scope = Devise :: Mapping . find_scope! ( resource_or_scope ) warden . user ( scope ) # Without loading user here, before_logout hook is not called warden . raw_session . inspect # Without this inspect here. The session does not clear. warden . logout ( scope ) # user id    post_signout scope end

1<CODESPLIT>https://github.com/datamapper/dm-core/blob/226c5af8609a2e1da3bf3ee0b29a874401a49c0b/lib/dm-core/query.rb#L519-L527<CODESPLIT>DataMapper.Query.sort_records<CODESPLIT>Sorts a list of Records by the order<CODESPLIT>def sort_records ( records ) sort_order = order . map { | direction | [ direction . target , direction . operator == :asc ] } records . sort_by do | record | sort_order . map do | ( property , ascending ) | Sort . new ( record_value ( record , property ) , ascending ) end end end

1<CODESPLIT>https://github.com/dewski/json_builder/blob/d94cf32a5ec10454eacf111a1c9429a72e4caabc/lib/json_builder/compiler.rb#L107-L111<CODESPLIT>JSONBuilder.Compiler.key<CODESPLIT>Public : Generates the start of the JSON member . Useful if the key you are generating is dynamic .<CODESPLIT>def key ( key_name , * args , & block ) member = Member . new ( key_name , @_scope , args , block ) @_members << member member end

1<CODESPLIT>https://github.com/backup/backup/blob/64370f925e859f858766b674717a3dbee0de7a26/vagrant/spec/support/tar_file.rb#L24-L34<CODESPLIT>BackupSpec.TarFile.contents<CODESPLIT>GNU / BSD have different formats for tar - tvf .<CODESPLIT>def contents @contents ||= begin data = manifest . split ( "\n" ) . reject { | line | line =~ / \/ / } data . map! { | line | line . split ( ' ' ) } if gnu_tar? Hash [ data . map { | fields | [ fields [ 5 ] , fields [ 2 ] . to_i ] } ] else Hash [ data . map { | fields | [ fields [ 8 ] , fields [ 4 ] . to_i ] } ] end end end

0<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/data/azure_key_vault/lib/2016-10-01/generated/azure_key_vault/key_vault_client.rb#L4454-L4457<CODESPLIT>Azure::KeyVault::V2016_10_01.KeyVaultClient.get_certificate_contacts<CODESPLIT>Deletes the certificate contacts for a specified key vault .<CODESPLIT>def get_certificate_contacts ( vault_base_url , custom_headers : nil ) response = get_certificate_contacts_async ( vault_base_url , custom_headers :custom_headers ) . value! response . body unless response . nil? end

1<CODESPLIT>https://github.com/super-engineer/url_scraper/blob/443598d7b93a5b5104cdc4648875ea17ce143e7e/lib/url_scraper.rb#L89-L94<CODESPLIT>UrlScraper.Object.schema<CODESPLIT>The schema under which this particular object lies . May be any of the keys of the TYPES constant .<CODESPLIT>def schema UrlScraper :: TYPES . each_pair do | schema , types | return schema if types . include? ( self . type ) end nil end

0<CODESPLIT>https://github.com/fuminori-ido/edgarj/blob/1648ab180f1f4adaeea03d54b645f58f3702a2bf/app/controllers/edgarj/popup_controller.rb#L67-L73<CODESPLIT>CSSquirt.ImageFileList.to_images<CODESPLIT>Ajax method to execute search<CODESPLIT>def to_images image_map = [ ] self . each do | file | begin image_map << ImageFile . new ( file ) rescue Exception => e $stderr . puts "WARNING: skipped file - #{e.message}" end end image_map end

1<CODESPLIT>https://github.com/dennmart/wanikani-gem/blob/70f9e4289f758c9663c0ee4d1172acb711487df9/lib/wanikani/level.rb#L55-L66<CODESPLIT>Wanikani.Level.level_items_list<CODESPLIT>Fetches the specified item type list from WaniKani s API<CODESPLIT>def level_items_list ( type , levels ) levels = levels . join ( ',' ) if levels . is_a? ( Array ) response = api_response ( type , levels ) # The vocabulary API call without specifying levels returns a Hash instead # of an Array, so this is a hacky way of dealing with it. if response [ "requested_information" ] . is_a? ( Hash ) return response [ "requested_information" ] [ "general" ] else return response [ "requested_information" ] end end

0<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_compute/lib/2018-06-01/generated/azure_mgmt_compute/gallery_images.rb#L237-L240<CODESPLIT>Azure::Compute::Mgmt::V2018_06_01.GalleryImages.delete<CODESPLIT>List gallery Image Definitions in a gallery .<CODESPLIT>def delete ( resource_group_name , gallery_name , gallery_image_name , custom_headers : nil ) response = delete_async ( resource_group_name , gallery_name , gallery_image_name , custom_headers :custom_headers ) . value! nil end

0<CODESPLIT>https://github.com/chef/omnibus-ctl/blob/e160156deaa0afc037748b10d1c9ef0a5be97dc1/lib/omnibus-ctl.rb#L363-L371<CODESPLIT>Omnibus.Ctl.global_service_command_permitted<CODESPLIT>run an sv command for a specific service name<CODESPLIT>def global_service_command_permitted ( sv_cmd , service_name ) # For services that have been removed, we only want to # them to respond to the stop command. They should not show # up in status, and they should not be started. if removed_services . include? ( service_name ) return sv_cmd == "stop" end # For keepalived, we only want it to respond to the status # command when running global service commands like p-c-c start # and p-c-c stop if service_name == "keepalived" return sv_cmd == "status" end # If c-s-c status is called, check to see if the service # is hidden supposed to be hidden from the status results # (mover for example should be hidden). if sv_cmd == "status" return ! ( hidden_services . include? ( service_name ) ) end # All other services respond normally to p-c-c * commands return true end

1<CODESPLIT>https://github.com/messagemedia/messages-ruby-sdk/blob/073f1f7ca5e4ff3df51b8eeafeaae2167ec6f311/lib/message_media_messages/models/base_model.rb#L10-L29<CODESPLIT>MessageMediaMessages.BaseModel.to_hash<CODESPLIT>Returns a Hash representation of the current object .<CODESPLIT>def to_hash hash = { } instance_variables . each do | name | value = instance_variable_get ( name ) next if value . nil? name = name [ 1 .. - 1 ] key = self . class . names . key? ( name ) ? self . class . names [ name ] : name if value . instance_of? Array hash [ key ] = value . map { | v | v . is_a? ( BaseModel ) ? v . to_hash : v } elsif value . instance_of? Hash hash [ key ] = { } value . each do | k , v | hash [ key ] [ k ] = v . is_a? ( BaseModel ) ? v . to_hash : v end else hash [ key ] = value . is_a? ( BaseModel ) ? value . to_hash : value end end hash end

1<CODESPLIT>https://github.com/kyrylo/pry-theme/blob/db99825ff4438b04ce8b808b0303200350fe551b/lib/pry-theme/rgb.rb#L175-L181<CODESPLIT>PryTheme.RGB.validate_array<CODESPLIT>Checks whether the + ary + has correct number of elements and these elements are valid RGB numbers .<CODESPLIT>def validate_array ( ary ) correct_size = ary . size . equal? ( 3 ) correct_vals = ary . all? { | val | val . is_a? ( Integer ) && val . between? ( 0 , 255 ) } return true if correct_size && correct_vals raise ArgumentError , %|invalid value for PryTheme::RGB#validate_array(): "#{ ary }"| end

1<CODESPLIT>https://github.com/bozz/engine_room/blob/2ab43b61a034e83b1d40def62344245bcc55da3a/app/controllers/engine_room/fields_controller.rb#L47-L61<CODESPLIT>EngineRoom.FieldsController.create<CODESPLIT>POST / fields<CODESPLIT>def create @field = Field . new ( params [ :field ] ) @section = Section . find ( params [ :section_id ] ) if ( params [ :s_action ] == 'reload' ) return reload_new end if @field . save flash [ :notice ] = 'Field was successfully created.' redirect_to edit_engine_room_section_url ( @section . id ) else render :action => :new end end

1<CODESPLIT>https://github.com/triglav-dataflow/triglav-client-ruby/blob/b2f3781d65ee032ba96eb703fbd789c713a5e0bd/lib/triglav_client/api/jobs_api.rb#L152-L155<CODESPLIT>TriglavClient.JobsApi.get_job<CODESPLIT>Returns a single job<CODESPLIT>def get_job ( id_or_uri , opts = { } ) data , _status_code , _headers = get_job_with_http_info ( id_or_uri , opts ) return data end

0<CODESPLIT>https://github.com/decidim/decidim/blob/6e2b14e559a63088669904e3c5c49a5180700cf7/decidim-core/app/presenters/decidim/home_stats_presenter.rb#L30-L47<CODESPLIT>Decidim.HomeStatsPresenter.highlighted<CODESPLIT>Public : Render a collection of stats that are not primary .<CODESPLIT>def highlighted highlighted_stats = Decidim . stats . only ( [ :users_count , :processes_count ] ) . with_context ( organization ) . map { | name , data | [ name , data ] } highlighted_stats = highlighted_stats . concat ( global_stats ( priority : StatsRegistry :: HIGH_PRIORITY ) ) highlighted_stats = highlighted_stats . concat ( component_stats ( priority : StatsRegistry :: HIGH_PRIORITY ) ) highlighted_stats = highlighted_stats . reject ( :empty? ) highlighted_stats = highlighted_stats . reject { | _name , data | data . zero? } safe_join ( highlighted_stats . in_groups_of ( 2 , false ) . map do | stats | content_tag :div , class : "home-pam__highlight" do safe_join ( stats . map do | name , data | render_stats_data ( name , data ) end ) end end ) end

0<CODESPLIT>https://github.com/ledbettj/systemd-journal/blob/823ac01a88da58fd3e703076b1d6e918aba73522/lib/systemd/journal_entry.rb#L71-L80<CODESPLIT>FetcheableOnApi.Sortable.format_params<CODESPLIT>Returns the catalog message that this Journal Entry references if any .<CODESPLIT>def format_params ( params ) res = { } params . split ( "," ) . each do | attribute | sort_sign = attribute =~ / \A / ? attribute . slice! ( 0 ) : "+" res [ attribute . to_sym ] = SORT_ORDER [ sort_sign ] end res end

0<CODESPLIT>https://github.com/blahah/biopsy/blob/e46f3d1c75de4da2ec47a377f7e4f0e16a8e03d2/lib/biopsy/objective_handler.rb#L99-L113<CODESPLIT>Biopsy.ObjectiveHandler.run_for_output<CODESPLIT>Perform a euclidean distance dimension reduction of multiple objectives<CODESPLIT>def run_for_output ( raw_output , threads , allresults ) # check output files exist output_files = { } @target . output . each_pair do | key , glob | files = Dir [ glob ] size = files . reduce ( 1 ) { | sum , f | sum * File . size ( f ) } if files . empty? || size == 0 error = "output files for #{key} matching #{glob} do not exist" + " or are empty" raise ObjectiveHandlerError , error end output_files [ key ] = files . map { | f | File . expand_path ( f ) } end # run all objectives for output results = { } @objectives . each_pair do | name , objective | results [ name ] = self . run_objective ( objective , name , raw_output , output_files , threads ) end if allresults return { :results => results , :reduced => self . dimension_reduce ( results ) } else results . each_value do | value | return value . kind_of? ( Hash ) ? value [ :result ] : value end end end

0<CODESPLIT>https://github.com/rhomobile/rhodes/blob/3c5f87b1a44f0ba2865ca0e1dd780dd202f64872/lib/extensions/rexml/rexml/entity.rb#L75-L81<CODESPLIT>Digest.Instance.file<CODESPLIT>Evaluates to the unnormalized value of this entity ; that is replacing all entities -- both %ent ; and &ent ; entities . This differs from + value () + in that + value + only replaces %ent ; entities .<CODESPLIT>def file ( name ) File . open ( name , "rb" ) { | f | buf = "" while f . read ( 16384 , buf ) update buf end } self end

0<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_network/lib/2018-07-01/generated/azure_mgmt_network/virtual_network_gateways.rb#L354-L357<CODESPLIT>Azure::ApiManagement::Mgmt::V2018_01_01.Diagnostic.get_with_http_info<CODESPLIT>Gets all the connections in a virtual network gateway .<CODESPLIT>def get_with_http_info ( resource_group_name , service_name , diagnostic_id , custom_headers : nil ) get_async ( resource_group_name , service_name , diagnostic_id , custom_headers :custom_headers ) . value! end

1<CODESPLIT>https://github.com/voltrb/volt/blob/f942b92385adbc894ee4a37903ee6a9c1a65e9a4/lib/volt/helpers/time/duration.rb#L23-L29<CODESPLIT>Volt.Duration.+<CODESPLIT>Compares with the value on another Duration if Duration is passed or just compares value with the other object Adds durations or duration to a VoltTime or seconds to the duration<CODESPLIT>def + ( other ) if other . is_a? ( Volt :: Duration ) Volt :: Duration . new ( value + other . value , parts + other . parts ) else Volt :: Duration . new ( value + other , parts + [ [ :seconds , other ] ] ) end end

1<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_web/lib/2018-02-01/generated/azure_mgmt_web/app_service_environments.rb#L1578-L1580<CODESPLIT>Azure::Web::Mgmt::V2018_02_01.AppServiceEnvironments.update_multi_role_pool_with_http_info<CODESPLIT>Create or update a multi - role pool .<CODESPLIT>def update_multi_role_pool_with_http_info ( resource_group_name , name , multi_role_pool_envelope , custom_headers : nil ) update_multi_role_pool_async ( resource_group_name , name , multi_role_pool_envelope , custom_headers :custom_headers ) . value! end

0<CODESPLIT>https://github.com/rhenium/plum/blob/9190801a092d46c7079ccee201b212b2d7985952/lib/plum/stream.rb#L101-L106<CODESPLIT>Plum.Stream.promise<CODESPLIT>Sends response headers . If the encoded frame is larger than MAX_FRAME_SIZE the headers will be splitted into HEADERS frame and CONTINUATION frame ( s ) .<CODESPLIT>def promise ( headers ) stream = @connection . reserve_stream ( weight : self . weight + 1 , parent : self ) encoded = @connection . hpack_encoder . encode ( headers ) frame = Frame :: PushPromise . new ( id , stream . id , encoded , end_headers : true ) send frame stream end

1<CODESPLIT>https://github.com/olabini/codebot/blob/031ddf427fd4a245ee6ff6414c4e28dab31679c1/lib/codebot/irc_client.rb#L97-L100<CODESPLIT>Codebot.IRCClient.disconnect_from<CODESPLIT>Disconnects from a given network if the network is currently connected .<CODESPLIT>def disconnect_from ( network ) connection = @connections . delete connection_to ( network ) connection . tap ( :stop ) . tap ( :join ) unless connection . nil? end

1<CODESPLIT>https://github.com/lyfeyaj/smart_sms/blob/2156d62a160c555882286a929f8f6ab80fc52862/lib/smart_sms/helpers/fake_sms.rb#L17-L29<CODESPLIT>SmartSMS.FakeSMS.build_fake_sms<CODESPLIT>This will generate fake sms with all necessary attributes<CODESPLIT>def build_fake_sms ( mobile , code , company ) { 'sid' => SecureRandom . uuid , 'mobile' => mobile , 'send_time' => Time . zone . now , 'text' => "#{code}#{company}",  'send_status' => 'SUCCESS' , 'report_status' => 'UNKNOWN' , 'fee' => 1 , 'user_receive_time' => nil , 'error_msg' => nil } end

0<CODESPLIT>https://github.com/jeanlescure/hipster_sql_to_hbase/blob/eb181f2f869606a8fd68e88bde0a485051f262b8/lib/result_tree_to_hbase_converter.rb#L35-L50<CODESPLIT>HipsterSqlToHbase.ResultTreeToHbaseConverter.select_sentence<CODESPLIT>When SQL sentence is an INSERT query generate the Thrift mutations according to the specified query values .<CODESPLIT>def select_sentence ( hash ) thrift_method = "getRowsByScanner" thrift_table = hash [ :from ] thrift_columns = hash [ :select ] thrift_filters = recurse_where ( hash [ :where ] || [ ] ) thrift_limit = hash [ :limit ] HipsterSqlToHbase :: ThriftCallGroup . new ( [ { :method => thrift_method , :arguments => [ thrift_table , thrift_columns , thrift_filters , thrift_limit , { } ] } ] ) end

1<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_network/lib/2018-07-01/generated/azure_mgmt_network/express_route_cross_connection_peerings.rb#L129-L132<CODESPLIT>Azure::Network::Mgmt::V2018_07_01.ExpressRouteCrossConnectionPeerings.delete<CODESPLIT>Deletes the specified peering from the ExpressRouteCrossConnection .<CODESPLIT>def delete ( resource_group_name , cross_connection_name , peering_name , custom_headers : nil ) response = delete_async ( resource_group_name , cross_connection_name , peering_name , custom_headers :custom_headers ) . value! nil end

1<CODESPLIT>https://github.com/jrochkind/traject_horizon/blob/f56f1785fccfb2cb123ce3100a3051fca4db39ac/lib/traject/horizon_bib_auth_merge.rb#L39-L139<CODESPLIT>Traject.HorizonBibAuthMerge.merge!<CODESPLIT>Pass in bibtext and authtext as String -- you probably need to get column values from JDBC as bytes and then use String . from_java_bytes to avoid messing up possible Marc8 encoding .<CODESPLIT>def merge! raise Exception . new ( "Can only call `merge!` once, already called." ) if @merged @merged = true # just one? (Or neither?) Just return it. return authtext if bibtext . nil? return bibtext if authtext . nil? # For 240 and 243, it seems that anything before the first $t should # be ignored in authtext template -- we need to actually remove it,  # so later when we append any leftover fields, we don't get those.  if tag == '240' || tag == '243' authtext . sub! ( @@up_to_subfield_t_re , "\x1Ft" ) end # We need to do a crazy combination of template in text with values in authtext. # horizon, you so crazy. text template is like: #"\x1Fa.\x1Fp ;\x1Fv81." # which means each subfield after the \x1F, merge in # the subfield value from the auth record if it's present, # otherwise don't. # # plus some weird as hell stuff with punctuation and spaces, I can't # even explain it, just trial and error'd it comparing to marcout. bibtext . gsub! ( / \x1F \x1F \x1E / ) do subfield = $1 space = $2 maybe_punct = $3 # okay this is crazy hacky reverse engineering, I don't really # know what's going on but for 240 and 243, 'a' in template # is filled by 't' in auth tag. auth_subfield = if subfield == "a" && ( tag == "240" || tag == "243" ) "t" else subfield end # Find substitute fill-in value from authtext, if it can # be found -- first subfield indicated. Then we REMOVE # it from authtext, so next time this subfield is asked for, # subsequent subfield with that code will be used. substitute = nil authtext . sub! ( / \x1F #{ Regexp . escape auth_subfield } \x1F \x1E / ) do substitute = $1 '' end if substitute # Dealing with punctuation is REALLY CONFUSING -- reverse engineering # HIP/Horizon, which does WEIRD THINGS. # But we seem to have arrived at something that appears to match all cases # we can find of what HIP/Horizon does. # # If the auth value already ends up with the same punctuation from the template, # _leave it alone_ -- including preserving all spaces near the punct in the auth # value. # # Otherwise, remove all punct from the auth value, then add in the punct from the template, # along with any spaces before the punct in the template. if maybe_punct && maybe_punct . length > 0 # remove all punctuation from end of auth value? to use punct from template instead? # But preserve initial spaces from template? Unless it already ends # with the punctuation, in which case don't touch it, to avoid # messing up spaces? WEIRD, yeah. unless substitute . end_with? maybe_punct substitute . gsub! ( / \Z / , "" ) # This adding the #{space} back in, is consistent with what HIP does. # I have no idea if it's right or a bug in HIP, but being consistent. # neither leaving it in nor taking it out is exactly consistent with HznExportMarc, # which seems to have bugs. substitute << "#{space}#{maybe_punct}" end end "\x1F#{subfield}#{substitute}" else # just keep original, which has no maybe_punct "\x1F#{subfield}" end end # Sometimes there's leftover text at the end of authtext that wasn't  # included in the bibtext template. Horizon's marc reconstruction # seems to just include this on the end, we will too.  # Relies on 'prior to $t' fields being removed from 240 and 243 earlier, # to avoid including them when we shouldn't.  if authtext . length > 0 bibtext << authtext end # We mutated bibtext to fill in template, now just return it. return bibtext end

1<CODESPLIT>https://github.com/kontena/kontena/blob/5cb5b4457895985231ac88e78c8cbc5a8ffb5ec7/cli/lib/kontena/client.rb#L387-L429<CODESPLIT>Kontena.Client.refresh_token<CODESPLIT>Perform refresh token request to auth provider . Updates the client s Token object and writes changes to configuration .<CODESPLIT>def refresh_token debug { "Performing token refresh" } return false if token . nil? return false if token [ 'refresh_token' ] . nil? uri = URI . parse ( token_account [ 'token_endpoint' ] ) endpoint_data = { path : uri . path } endpoint_data [ :host ] = uri . host if uri . host endpoint_data [ :port ] = uri . port if uri . port debug { "Token refresh endpoint: #{endpoint_data.inspect}" } return false unless endpoint_data [ :path ] response = request ( { http_method : token_account [ 'token_method' ] . downcase . to_sym , body : refresh_request_params , headers : { CONTENT_TYPE => token_account [ 'token_post_content_type' ] } . merge ( token_account [ 'code_requires_basic_auth' ] ? basic_auth_header : { } ) , expects : [ 200 , 201 , 400 , 401 , 403 ] , auth : false } . merge ( endpoint_data ) ) if response && response [ 'access_token' ] debug { "Got response to refresh request" } token [ 'access_token' ] = response [ 'access_token' ] token [ 'refresh_token' ] = response [ 'refresh_token' ] token [ 'expires_at' ] = in_to_at ( response [ 'expires_in' ] ) token . config . write if token . respond_to? ( :config ) true else debug { "Got null or bad response to refresh request: #{last_response.inspect}" } false end rescue => ex error { "Access token refresh exception" } error { ex } false end

1<CODESPLIT>https://github.com/jmettraux/rufus-cloche/blob/e038fa69ded7d3de85f151d12d111466aef97aab/lib/rufus/cloche.rb#L236-L241<CODESPLIT>Rufus.Cloche.ids<CODESPLIT>Returns a sorted list of all the ids for a given type of documents .<CODESPLIT>def ids ( type ) Dir [ File . join ( dir_for ( type ) , '**' , '*.json' ) ] . collect { | path | File . basename ( path , '.json' ) } . sort end

1<CODESPLIT>https://github.com/ktonon/cog/blob/156c81a0873135d7dc47c79c705c477893fff74a/lib/cog/spec_helpers.rb#L94-L99<CODESPLIT>Cog.SpecHelpers.use_fixture<CODESPLIT>The next cog spec will execute in a fresh copy of the given fixture Fixture directories are stored in <tt > spec / fixtures< / tt > .<CODESPLIT>def use_fixture ( name ) path = File . join spec_root , 'fixtures' , name . to_s copy_fixture path , active_fixture_dir Dir . chdir active_fixture_dir nil end

0<CODESPLIT>https://github.com/ohler55/ox/blob/f5b618285a0b9c885aa86dd9d51188fce2d60856/lib/ox/element.rb#L170-L183<CODESPLIT>Ox.Element.remove_children<CODESPLIT>Returns an array of Nodes or Strings that correspond to the locations specified by the path parameter . The path parameter describes the path to the return values which can be either nodes in the XML or attributes . The path is a relative description . There are similarities between the locate () method and XPath but locate does not follow the same rules as XPath . The syntax is meant to be simpler and more Ruby like .<CODESPLIT>def remove_children ( * children ) return self if children . compact . empty? recursive_children_removal ( children . compact . map { | c | c . object_id } ) self end

1<CODESPLIT>https://github.com/npolar/npolar-api-client-ruby/blob/e28ff77dad15bb1bcfcb750f5d1fd4679aa8b7fb/lib/npolar/api/client/json_api_client.rb#L291-L319<CODESPLIT>Npolar::Api::Client.JsonApiClient.valid?<CODESPLIT>Valid?<CODESPLIT>def valid? ( document_or_id ) # FIXME Hashie::Mash will always respond to #valid? if not model? or not model . respond_to? ( :valid? ) return true end validator = model . class . new ( document_or_id ) # Return true if validator is a Hash with errors key ! # FIXME Hashie::Mash will always respond to #valid? if validator . key? :valid? or validator . key? :errors return true end valid = validator . valid? if validator . errors . nil? return true end @errors = validator . errors # store to avoid revalidating valid = case valid when true , nil true when false false end valid end

1<CODESPLIT>https://github.com/qburstruby/rammer-3.0.0/blob/72e19d2eb07fcfe0da5ae8610d74dff44906b529/lib/rammer/module_generator.rb#L151-L160<CODESPLIT>Rammer.ModuleGenerator.copy_files<CODESPLIT>= begin Function to copy the module files to project location . = end<CODESPLIT>def copy_files ( src , dest , module_model ) module_model . each do | file | presence = File . exists? ( "#{dest}/#{file}" ) ? true : false unless presence FileUtils . cp ( "#{src}/#{file}" , dest ) path = if dest . include? "app" then "app/models" else "db/migrate" end $stdout . puts "\e[1;32m \tcreate\e[0m\t#{path}/#{file}" end end end

0<CODESPLIT>https://github.com/mongodb/mongo-ruby-driver/blob/dca26d0870cb3386fad9ccc1d17228097c1fe1c8/lib/mongo/address.rb#L157-L159<CODESPLIT>Mongo.Cluster.sessions_supported?<CODESPLIT>Get a socket for the provided address given the options .<CODESPLIT>def sessions_supported? if topology . data_bearing_servers? return ! ! topology . logical_session_timeout end begin ServerSelector . get ( mode : :primary_preferred ) . select_server ( self ) ! ! topology . logical_session_timeout rescue Error :: NoServerAvailable false end end

0<CODESPLIT>https://github.com/wapcaplet/kelp/blob/592fe188db5a3d05e6120ed2157ad8d781601b7a/lib/kelp/visibility.rb#L26-L34<CODESPLIT>Kelp.Visibility.should_see<CODESPLIT>Return true if the current page contains the given text or regular expression or false if it does not .<CODESPLIT>def should_see ( texts , scope = { } ) in_scope ( scope ) do texts = [ texts ] if ( texts . class == String || texts . class == Regexp ) # Select all expected values that don't appear on the page unexpected = texts . select do | text | ! page_contains? ( text ) end if ! unexpected . empty? raise Kelp :: Unexpected , "Expected to see: #{texts.inspect}\nDid not see: #{unexpected.inspect}" end end end

0<CODESPLIT>https://github.com/Shopify/liquid/blob/b3b63a683f6daaea7e70f1602ee829abdf970ef3/lib/liquid/standardfilters.rb#L219-L232<CODESPLIT>Liquid.StandardFilters.uniq<CODESPLIT>map / collect on a given property<CODESPLIT>def uniq ( input , property = nil ) ary = InputIterator . new ( input ) if property . nil? ary . uniq elsif ary . empty? # The next two cases assume a non-empty array. [ ] elsif ary . first . respond_to? ( :[] ) begin ary . uniq { | a | a [ property ] } rescue TypeError raise_property_error ( property ) end end end

0<CODESPLIT>https://github.com/ramz15/voter_love/blob/99e97562e31c1bd0498c7f7a9b8a209af14a22f5/lib/voter_love/voter.rb#L89-L97<CODESPLIT>VoterLove.Voter.up_vote!<CODESPLIT>Down vote a votable object without raising an error . Vote is ignored .<CODESPLIT>def up_vote! ( votable ) begin up_vote ( votable ) success = true rescue Exceptions :: AlreadyVotedError success = false end success end

0<CODESPLIT>https://github.com/contactually/zuora-ruby/blob/1d64da91babbbe37715591610987ef5d3ac9e3ca/lib/utils/schema_model.rb#L48-L60<CODESPLIT>SchemaModel.InstanceMethods.check_children<CODESPLIT>Helper for dynamically defining writer method<CODESPLIT>def check_children ( child_schema , value ) return unless child_schema && value . present? if value . is_a? Array value . map ( :errors ) . reject ( :empty? ) else value . errors end end

0<CODESPLIT>https://github.com/celldee/ffi-rxs/blob/95378f3a5e5b5b3f1f726a9a1620f41ab4ee7f0e/lib/ffi-rxs/poll_items.rb#L105-L118<CODESPLIT>XES.Attribute.format<CODESPLIT>Allocate a contiguous chunk of memory and copy over the PollItem structs to this block . Note that the old +<CODESPLIT>def format raise FormatError . new ( self ) unless formattable? REXML :: Element . new ( type ) . tap do | attribute | attribute . attributes [ "key" ] = @key attribute . attributes [ "value" ] = format_value meta . each { | m | attribute . elements << m . format if m . formattable? } end end

0<CODESPLIT>https://github.com/oliamb/knnball/blob/eb67c4452481d727ded06984ba7d82a92b5a8e03/lib/knnball/kdtree.rb#L50-L104<CODESPLIT>KnnBall.KDTree.parent_ball<CODESPLIT>Retrieve the nearest point from the given coord array .<CODESPLIT>def parent_ball ( coord ) current = root d_idx = current . dimension - 1 result = nil while ( result . nil? ) if ( coord [ d_idx ] <= current . center [ d_idx ] ) if current . left . nil? result = current else current = current . left end else if current . right . nil? result = current else current = current . right end end d_idx = current . dimension - 1 end return result end

0<CODESPLIT>https://github.com/georgyangelov/vcs-toolkit/blob/9d73735da090a5e0f612aee04f423306fa512f38/lib/vcs_toolkit/merge.rb#L83-L93<CODESPLIT>VCSToolkit.Merge.extract_conflict<CODESPLIT>Group changes by their old index .<CODESPLIT>def extract_conflict ( changeset_one , changeset_two ) common_start = changeset_one . zip ( changeset_two ) . take_while do | change_one , change_two | same_change ( change_one , change_two ) end common_end = changeset_one . reverse . zip ( changeset_two . reverse ) . take_while do | change_one , change_two | same_change ( change_one , change_two ) end common_size = common_end . size + common_start . size diff_one = Diff . new changeset_one . slice ( common_start . size , changeset_one . size - common_size ) diff_two = Diff . new changeset_two . slice ( common_start . size , changeset_two . size - common_size ) common_start . map ( :first ) + [ Conflict . new ( diff_one , diff_two ) ] + common_end . map ( :first ) end

1<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_resources/lib/2018-02-01/generated/azure_mgmt_resources/resources.rb#L194-L197<CODESPLIT>Azure::Resources::Mgmt::V2018_02_01.Resources.validate_move_resources<CODESPLIT>Validates whether resources can be moved from one resource group to another resource group .<CODESPLIT>def validate_move_resources ( source_resource_group_name , parameters , custom_headers : nil ) response = validate_move_resources_async ( source_resource_group_name , parameters , custom_headers :custom_headers ) . value! nil end

0<CODESPLIT>https://github.com/duckinator/inq/blob/e23a250aca4a62702cb5f3ee87cf26012e5a8344/lib/inq/config.rb#L83-L95<CODESPLIT>Inq.Config.load_files<CODESPLIT>Take a collection of config hashes and cascade them meaning values in later ones override values in earlier ones .<CODESPLIT>def load_files ( * file_paths ) files = ( site_configs + file_paths ) . map { | f | Pathname . new ( f ) } # Keep only files that exist. files . select! ( :file? ) # Load the YAML files into Hashes. configs = files . map { | file | YAML . safe_load ( file . read ) } # Apply configs. load ( configs ) end

1<CODESPLIT>https://github.com/detroit/detroit-dnote/blob/2f4dfd2deb31227b34d4bb7f9e8ce6937d6210ef/lib/detroit-dnote.rb#L181-L191<CODESPLIT>Detroit.DNote.dnote_session<CODESPLIT>DNote Session instance .<CODESPLIT>def dnote_session :: DNote :: Session . new do | s | s . paths = files s . exclude = exclude s . ignore = ignore s . labels = labels s . title = title s . context = lines s . dryrun = trial? end end

1<CODESPLIT>https://github.com/pluginaweek/preferences/blob/949894e579eb705e208c70af05179c16a65fd406/lib/preferences.rb#L153-L224<CODESPLIT>Preferences.MacroMethods.preference<CODESPLIT>Defines a new preference for all records in the model . By default preferences are assumed to have a boolean data type so all values will be typecasted to true / false based on ActiveRecord rules .<CODESPLIT>def preference ( name , * args ) unless included_modules . include? ( InstanceMethods ) class_inheritable_hash :preference_definitions self . preference_definitions = { } has_many :stored_preferences , :as => :owner , :class_name => 'Preference' after_save :update_preferences # Named scopes named_scope :with_preferences , lambda { | preferences | build_preference_scope ( preferences ) } named_scope :without_preferences , lambda { | preferences | build_preference_scope ( preferences , true ) } extend Preferences :: ClassMethods include Preferences :: InstanceMethods end # Create the definition name = name . to_s definition = PreferenceDefinition . new ( name , args ) self . preference_definitions [ name ] = definition # Create short-hand accessor methods, making sure that the name # is method-safe in terms of what characters are allowed name = name . gsub ( / / , '' ) . underscore # Query lookup define_method ( "preferred_#{name}?" ) do | * group | preferred? ( name , group . first ) end alias_method "prefers_#{name}?" , "preferred_#{name}?" # Reader define_method ( "preferred_#{name}" ) do | * group | preferred ( name , group . first ) end alias_method "prefers_#{name}" , "preferred_#{name}" # Writer define_method ( "preferred_#{name}=" ) do | * args | write_preference ( args . flatten . unshift ( name ) ) end alias_method "prefers_#{name}=" , "preferred_#{name}=" # Changes define_method ( "preferred_#{name}_changed?" ) do | * group | preference_changed? ( name , group . first ) end alias_method "prefers_#{name}_changed?" , "preferred_#{name}_changed?" define_method ( "preferred_#{name}_was" ) do | * group | preference_was ( name , group . first ) end alias_method "prefers_#{name}_was" , "preferred_#{name}_was" define_method ( "preferred_#{name}_change" ) do | * group | preference_change ( name , group . first ) end alias_method "prefers_#{name}_change" , "preferred_#{name}_change" define_method ( "preferred_#{name}_will_change!" ) do | * group | preference_will_change! ( name , group . first ) end alias_method "prefers_#{name}_will_change!" , "preferred_#{name}_will_change!" define_method ( "reset_preferred_#{name}!" ) do | * group | reset_preference! ( name , group . first ) end alias_method "reset_prefers_#{name}!" , "reset_preferred_#{name}!" definition end

0<CODESPLIT>https://github.com/riddopic/garcun/blob/c2409bd8cf9c14b967a719810dab5269d69b42de/lib/garcon/chef/coerce/coercer.rb#L50-L56<CODESPLIT>RDSBackup.Job.to_json<CODESPLIT>Registers a coercion with the Garcon library .<CODESPLIT>def to_json JSON . pretty_generate ( { rds_instance : rds_id , account_name : account_name , backup_status : status , status_message : message , status_url : status_url , files : files , } ) end

1<CODESPLIT>https://github.com/lokalportal/chain_options/blob/b42cd6c03aeca8938b274225ebaa38fe3803866a/lib/chain_options/option_set.rb#L115-L121<CODESPLIT>ChainOptions.OptionSet.instance_method_hash<CODESPLIT>Checks the given options and transforms certain options into closures if they are symbols before . The keys that are being transformed can be seen at Option :: METHOD_SYMBOLS .<CODESPLIT>def instance_method_hash ( options ) ChainOptions :: Util . slice ( options , Option :: METHOD_SYMBOLS ) . each_with_object ( { } ) do | ( meth , value ) , h | next h [ meth ] = value if value . respond_to? ( :call ) h [ meth ] = instance . public_method ( value ) end end

1<CODESPLIT>https://github.com/rossta/montrose/blob/91af7d2d5c337aa255510179d24eb023775674bb/lib/montrose/schedule.rb#L72-L80<CODESPLIT>Montrose.Schedule.events<CODESPLIT>Returns an enumerator for iterating over timestamps in the schedule<CODESPLIT>def events ( opts = { } ) enums = @rules . map { | r | r . merge ( opts ) . events } Enumerator . new do | y | loop do enum = active_enums ( enums ) . min_by ( :peek ) or break y << enum . next end end end

1<CODESPLIT>https://github.com/jeremyd/virtualmonkey/blob/b2c7255f20ac5ec881eb90afbb5e712160db0dcb/lib/virtualmonkey/deployment_runner.rb#L57-L65<CODESPLIT>VirtualMonkey.DeploymentRunner.launch_all<CODESPLIT>Launch all servers in the deployment .<CODESPLIT>def launch_all @servers . each { | s | begin object_behavior ( s , :start ) rescue Exception => e raise e unless e . message =~ / / end } end

0<CODESPLIT>https://github.com/petebrowne/massimo/blob/c450edc531ad358f011da0a47e5d0bc9a038d911/lib/massimo/ui.rb#L35-L48<CODESPLIT>Massimo.UI.say<CODESPLIT>Run the given block and cleanly report any errors<CODESPLIT>def say ( message , * args ) options = args . extract_options! color = args . first growl ( message ) if options [ :growl ] message = ( ' ' * padding ) + message . to_s message = self . color ( message , color ) if color $stdout . puts ( message ) end

0<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_labservices/lib/2018-10-15/generated/azure_mgmt_labservices/environments.rb#L1102-L1104<CODESPLIT>Azure::EdgeGateway::Mgmt::V2019_03_01.Roles.begin_create_or_update_with_http_info<CODESPLIT>Stops an environment by stopping all resources inside the environment This operation can take a while to complete<CODESPLIT>def begin_create_or_update_with_http_info ( device_name , name , role , resource_group_name , custom_headers : nil ) begin_create_or_update_async ( device_name , name , role , resource_group_name , custom_headers :custom_headers ) . value! end

0<CODESPLIT>https://github.com/aws/aws-sdk-ruby/blob/e28b8d320ddf7b6ee0161bdd9d00fb786d99b63d/gems/aws-sdk-rds/lib/aws-sdk-rds/resource.rb#L1596-L1610<CODESPLIT>Aws::RDS.Resource.db_cluster_parameter_groups<CODESPLIT>@example Request syntax with placeholder values<CODESPLIT>def db_cluster_parameter_groups ( options = { } ) batches = Enumerator . new do | y | batch = [ ] resp = @client . describe_db_cluster_parameter_groups ( options ) resp . data . db_cluster_parameter_groups . each do | d | batch << DBClusterParameterGroup . new ( name : d . db_cluster_parameter_group_name , data : d , client : @client ) end y . yield ( batch ) end DBClusterParameterGroup :: Collection . new ( batches ) end

0<CODESPLIT>https://github.com/ruby-x/rubyx/blob/1391667f6cf16c8e132cbf85cc6a5171fb8c444e/lib/risc/builder.rb#L201-L211<CODESPLIT>Mom.ResolveMethod.to_risc<CODESPLIT>Call_get_more calls the method get_more on the factory ( see there ) . From the callers perspective the method ensures there is a next_object .<CODESPLIT>def to_risc ( compiler ) name_ = @name cache_entry_ = @cache_entry builder = compiler . builder ( self ) builder . build do word! << name_ cache_entry! << cache_entry_ type! << cache_entry [ :cached_type ] callable_method! << type [ :methods ] add_code while_start_label object! << Parfait . object_space . nil_object object - callable_method if_zero exit_label name! << callable_method [ :name ] name - word if_zero ok_label callable_method << callable_method [ :next_callable ] branch while_start_label add_code exit_label # temporary, need to raise really. factory! << Parfait . object_space . get_factory_for ( :Integer ) integer_tmp! << factory [ :reserve ] Risc :: Builtin :: Object . emit_syscall ( builder , :exit ) #uses integer_tmp add_code ok_label cache_entry [ :cached_method ] << callable_method end end

1<CODESPLIT>https://github.com/fogonthedowns/rubychem/blob/7750e29465538b7c67f5a41a5cae6b7f74a7faac/lib/rubychem/equation.rb#L158-L166<CODESPLIT>RubyChem.Equation.solve_equivalent_fractions<CODESPLIT>from the reduced row echelon form we are left with a set of equivalent fractions to transform into a whole number we do this by using the gcdlcm method<CODESPLIT>def solve_equivalent_fractions last = 0 array = Array . new @reduced_row_echelon_form . each do | x | array = last . gcdlcm ( x . last . denominator ) last = x . last . denominator end array . max end

1<CODESPLIT>https://github.com/jeremyvdw/disqussion/blob/5ad1b0325b7630daf41eb59fc8acbcb785cbc387/lib/disqussion/client/threads.rb#L185-L190<CODESPLIT>Disqussion.Threads.listPosts<CODESPLIT>Returns a list of posts within a thread .<CODESPLIT>def listPosts ( * args ) options = args . last . is_a? ( Hash ) ? args . pop : { } thread = args . first options . merge! ( :thread => thread ) if ( [ :ident , :link ] & options . keys ) . empty? response = get ( 'threads/listPosts' , options ) end

1<CODESPLIT>https://github.com/ONLYOFFICE/ooxml_parser/blob/08452315cde52fa94d8cb3e1eff1db4ea33abc88/lib/ooxml_parser/common_parser/common_data/borders_properties.rb#L47-L66<CODESPLIT>OoxmlParser.BordersProperties.parse<CODESPLIT>Parse BordersProperties<CODESPLIT>def parse ( node ) return nil if node . attribute ( 'val' ) . value == 'nil' node . attributes . each do | key , value | case key when 'val' @val = value . value . to_sym when 'sz' @size = OoxmlSize . new ( value . value . to_f , :one_eighth_point ) when 'space' @space = OoxmlSize . new ( value . value . to_f , :point ) when 'color' @color = value . value . to_s @color = Color . new ( parent : self ) . parse_hex_string ( @color ) if @color != 'auto' when 'shadow' @shadow = value . value end end self end

1<CODESPLIT>https://github.com/williambarry007/caboose-cms/blob/7c112911318f94cc89dba86091903a3acaf0a833/app/models/caboose/invoice.rb#L414-L468<CODESPLIT>Caboose.Invoice.void<CODESPLIT>Void an authorized invoice<CODESPLIT>def void resp = StdClass . new t = InvoiceTransaction . where ( :invoice_id => self . id , :transaction_type => InvoiceTransaction :: TYPE_AUTHORIZE , :success => true ) . first if self . financial_status == Invoice :: FINANCIAL_STATUS_CAPTURED resp . error = "This invoice has already been captured, you will need to refund instead" elsif t . nil? resp . error = "This invoice doesn't seem to be authorized." else sc = self . site . store_config ot = Caboose :: InvoiceTransaction . new ( :invoice_id => self . id , :date_processed => DateTime . now . utc , :transaction_type => InvoiceTransaction :: TYPE_VOID , :payment_processor => sc . pp_name , :amount => self . total ) case sc . pp_name when 'authorize.net' response = AuthorizeNet :: SIM :: Transaction . new ( sc . authnet_api_login_id , sc . authnet_api_transaction_key , self . total , :transaction_type => InvoiceTransaction :: TYPE_VOID , :transaction_id => t . transaction_id , :test => sc . pp_testing ) self . update_attributes ( :financial_status => Invoice :: FINANCIAL_STATUS_VOIDED , :status => Invoice :: STATUS_CANCELED ) self . save # TODO: Add the variant quantities invoiceed back         resp . success = "Invoice voided successfully" ot . success = response . response_code && response . response_code == '1' ot . transaction_id = response . transaction_id #ot.auth_code      = response.authorization_code ot . response_code = response . response_code ot . save when 'stripe' # TODO: Implement void invoice for strip when 'payscape' # TODO: Implement void invoice for payscape end end return resp end

0<CODESPLIT>https://github.com/coralnexus/nucleon/blob/3a3c489251139c184e0884feaa55269cf64cad44/lib/core/facade.rb#L595-L597<CODESPLIT>Nucleon.Facade.interrupt_handler<CODESPLIT>----------------------------------------------------------------------------- Utilities<CODESPLIT>def interrupt_handler logger . warn ( "Nucleon executable interrupted, shutting down" ) if @@exec_state . action @@exec_state . action . status = code . action_interrupted @@exec_state . action . finalize_execution ( false ) end code . action_interrupted end

0<CODESPLIT>https://github.com/trisrael/mindbody/blob/3adc8dd4ab09bf74ffc9155f036629edbbbe1dad/lib/mindbody/service.rb#L58-L107<CODESPLIT>ParallelAppium.Server.launch_hub_and_nodes<CODESPLIT>Builds the inner XML of the Mindbody SOAP call<CODESPLIT>def launch_hub_and_nodes ( platform ) start_hub unless port_open? ( 'localhost' , 4444 ) devices = get_devices ( platform ) if devices . nil? puts "No devices for #{platform}, Exiting...." exit else save_device_data [ devices ] end threads = ENV [ 'THREADS' ] . to_i if devices . size < threads puts "Not enough available devices, reducing to #{devices.size} threads" ENV [ 'THREADS' ] = devices . size . to_s else puts "Using #{threads} of the available #{devices.size} devices" devices = devices [ 0 , threads ] end Parallel . map_with_index ( devices , in_processes : devices . size ) do | device , index | offset = platform == 'android' ? 0 : threads port = 4000 + index + offset bp = 2250 + index + offset config_name = "#{device[:udid]}.json" generate_node_config config_name , port , device node_config = "#{Dir.pwd}/node_configs/#{config_name}" puts port appium_server_start config : node_config , port : port , bp : bp , udid : device [ :udid ] , log : "appium-#{device[:udid]}.log" , tmp : device [ :udid ] end end

0<CODESPLIT>https://github.com/rightscale/right_link/blob/b33a209c20a8a0942dd9f1fe49a08030d4ca209f/lib/instance/audit_proxy.rb#L247-L265<CODESPLIT>RightScale.AuditProxy.internal_send_audit<CODESPLIT>Send any buffered output to auditor<CODESPLIT>def internal_send_audit ( options ) RightScale :: AuditProxy . force_utf8! ( options [ :text ] ) opts = { :audit_id => @audit_id , :category => options [ :category ] , :offset => @size } opts [ :category ] ||= EventCategories :: CATEGORY_NOTIFICATION unless EventCategories :: CATEGORIES . include? ( opts [ :category ] ) Log . warning ( "Invalid category '#{opts[:category]}' for notification '#{options[:text]}', using generic category instead" ) opts [ :category ] = EventCategories :: CATEGORY_NOTIFICATION end log_method = options [ :kind ] == :error ? :error : :info log_text = AuditFormatter . send ( options [ :kind ] , options [ :text ] ) [ :detail ] log_text . chomp . split ( "\n" ) . each { | l | Log . __send__ ( log_method , l ) } begin audit = AuditFormatter . __send__ ( options [ :kind ] , options [ :text ] ) @size += audit [ :detail ] . size request = RetryableRequest . new ( "/auditor/update_entry" , opts . merge ( audit ) , :timeout => AUDIT_DELIVERY_TIMEOUT ) request . callback { | _ | } # No result of interest other than know it was successful request . errback { | message | Log . error ( "Failed to send update for audit #{@audit_id} (#{message})" ) } request . run rescue Exception => e Log . error ( "Failed to send update for audit #{@audit_id}" , e , :trace ) end true end

0<CODESPLIT>https://github.com/Thermatix/ruta/blob/b4a6e3bc7c0c4b66c804023d638b173e3f61e157/lib/ruta/router.rb#L32-L35<CODESPLIT>Dragonfly.AzureDataStore.update_metadata<CODESPLIT>map a route<CODESPLIT>def update_metadata ( uid ) return false unless store_meta path = full_path ( uid ) meta = storage ( :get_blob , container_name , path ) [ 0 ] . metadata return false if meta . present? meta = meta_from_file ( path ) return false if meta . blank? storage ( :set_blob_metadata , container_name , path , meta ) storage ( :delete_blob , container_name , meta_path ( path ) ) true rescue Azure :: Core :: Http :: HTTPError nil end

0<CODESPLIT>https://github.com/amzn/amazon-pay-sdk-ruby/blob/6321994cc10b5614630b6743da8d1eb79b2bc1ed/lib/amazon_pay/request.rb#L65-L78<CODESPLIT>AmazonPay.Request.sign<CODESPLIT>This method combines the required and optional parameters to sign the post body and generate the post url .<CODESPLIT>def sign ( post_body ) custom_escape ( Base64 . strict_encode64 ( OpenSSL :: HMAC . digest ( OpenSSL :: Digest :: SHA256 . new , @secret_key , post_body ) ) ) end

0<CODESPLIT>https://github.com/HewlettPackard/hpe3par_ruby_sdk/blob/f8cfc6e597741be593cf7fe013accadf982ee68b/lib/Hpe3parSdk/client.rb#L1706-L1713<CODESPLIT>Hpe3parSdk.Client.create_physical_copy<CODESPLIT>Deletes a physical copy<CODESPLIT>def create_physical_copy ( src_name , dest_name , dest_cpg , optional = nil ) if @current_version < @min_version_with_compression && ! optional . nil? [ :compression , :allowRemoteCopyParent , :skipZero ] . each { | key | optional . delete key } end begin @volume . create_physical_copy ( src_name , dest_name , dest_cpg , optional ) rescue => ex Util . log_exception ( ex , caller_locations ( 1 , 1 ) [ 0 ] . label ) raise ex end end

1<CODESPLIT>https://github.com/medcat/brandish/blob/c63f91dbb356aa0958351ad9bcbdab0c57e7f649/lib/brandish/path_set.rb#L142-L153<CODESPLIT>Brandish.PathSet.find_all<CODESPLIT>Finds all versions of the short path name in the paths in the path sets . If no block is given it returns an enumerable ; otherwise if a block is given it yields the joined path if it exists .<CODESPLIT>def find_all ( short , options = { } ) return to_enum ( :find_all , short , options ) unless block_given? short = :: Pathname . new ( short ) options = DEFAULT_FIND_OPTIONS . merge ( options ) @paths . reverse . each do | path | joined = path_join ( path , short , options ) yield joined if ( options [ :file ] && joined . file? ) || joined . exist? end nil end

1<CODESPLIT>https://github.com/Fullscreen/yt/blob/bf5c33b977cb162bb7735ad5b80d1abdb5a38215/lib/yt/request.rb#L284-L287<CODESPLIT>Yt.Request.error_message<CODESPLIT>Return the elements of the request / response that are worth displaying as an error message if the request fails . If the response format is JSON showing the parsed body is sufficient otherwise the whole ( inspected ) response is worth looking at .<CODESPLIT>def error_message response_body = JSON ( response . body ) rescue response . inspect { request_curl : as_curl , response_body : response_body } end

0<CODESPLIT>https://github.com/gdelugre/origami/blob/ac1df803517601d486556fd40af5d422a6f4378e/lib/origami/compound.rb#L127-L133<CODESPLIT>Origami.PDF.extract_signed_data<CODESPLIT>Returns a new compound object with updated values based on the provided block .<CODESPLIT>def extract_signed_data ( digsig ) # Computes the boundaries of the Contents field. start_sig = digsig [ :Contents ] . file_offset stream = StringScanner . new ( self . original_data ) stream . pos = digsig [ :Contents ] . file_offset Object . typeof ( stream ) . parse ( stream ) end_sig = stream . pos stream . terminate r1 , r2 = digsig . ranges if r1 . begin != 0 or r2 . end != self . original_data . size or r1 . end != start_sig or r2 . begin != end_sig raise SignatureError , "Invalid signature byte range" end self . original_data [ r1 ] + self . original_data [ r2 ] end

0<CODESPLIT>https://github.com/michaeledgar/laser/blob/0e38780eb44466ae35f33d28ec75536a4f3a969b/lib/laser/scanner.rb#L101-L115<CODESPLIT>Laser.Scanner.all_warnings_for_line<CODESPLIT>Checks for new warnings based on indentation .<CODESPLIT>def all_warnings_for_line ( line , line_number , filename ) new_warnings = check_for_indent_warnings! ( line , filename ) new_warnings . concat scan_for_line_warnings ( line , filename ) new_warnings . each { | warning | warning . line_number = line_number } end

0<CODESPLIT>https://github.com/sass/ruby-sass/blob/7a50eae567260a23d3bbf4d5aaf1a76db43dec32/lib/sass/exec/base.rb#L67-L74<CODESPLIT>Sass::Exec.Base.encoding_option<CODESPLIT>Finds the line of the source template on which an exception was raised .<CODESPLIT>def encoding_option ( opts ) encoding_desc = 'Specify the default encoding for input files.' opts . on ( '-E' , '--default-encoding ENCODING' , encoding_desc ) do | encoding | Encoding . default_external = encoding end end

1<CODESPLIT>https://github.com/yamasolutions/integral/blob/d8077b6658c8b6713d97b44ff0e136f212354a25/app/helpers/integral/application_helper.rb#L30-L36<CODESPLIT>Integral.ApplicationHelper.render_list<CODESPLIT>@param [ Integral :: List ] list the list to render @param [ Hash ] opts the options to render list @option opts [ String ] : html_classes the html classes for the list @option opts [ String ] : data_attributes the html data attributes for the list @option opts [ Hash ] : item_renderer_opts the hash of options for list items<CODESPLIT>def render_list ( list , opts = { } ) opts . reverse_merge! ( renderer : Integral :: ListRenderer ) opts [ :renderer ] . render ( list , opts ) . html_safe end

1<CODESPLIT>https://github.com/meew0/discordrb/blob/764298a1ff0be69a1853b510d736f21c2b91a2fe/lib/discordrb/data/server.rb#L559-L561<CODESPLIT>Discordrb.Server.unban<CODESPLIT>Unbans a previously banned user from this server .<CODESPLIT>def unban ( user , reason = nil ) API :: Server . unban_user ( @bot . token , @id , user . resolve_id , reason ) end

1<CODESPLIT>https://github.com/bozz/engine_room/blob/2ab43b61a034e83b1d40def62344245bcc55da3a/app/controllers/engine_room/fields_controller.rb#L83-L91<CODESPLIT>EngineRoom.FieldsController.destroy<CODESPLIT>DELETE / fields / 1<CODESPLIT>def destroy @field = Field . find ( params [ :id ] ) @field . destroy flash [ :notice ] = 'Field was successfully deleted.' section_id = params [ :section_id ] redirect_to edit_engine_room_section_url ( section_id ) end

1<CODESPLIT>https://github.com/dicom/ruby-dicom/blob/3ffcfe21edc8dcd31298f945781990789fc832ab/lib/dicom/d_client.rb#L342-L361<CODESPLIT>DICOM.DClient.send<CODESPLIT>Sends one or more DICOM files to a service class provider ( SCP / PACS ) .<CODESPLIT>def send ( files ) # Prepare the DICOM object(s): objects , success , message = load_files ( files ) if success # Open a DICOM link: establish_association if association_established? if request_approved? # Continue with our c-store operation, since our request was accepted. # Handle the transmission: perform_send ( objects ) end end # Close the DICOM link: establish_release else # Failed when loading the specified parameter as DICOM file(s). Will not transmit. logger . error ( message ) end end

1<CODESPLIT>https://github.com/litaio/lita/blob/c1a1f85f791b74e40ee6a1e2d53f19b5f7cbe0ba/lib/lita/robot.rb#L244-L265<CODESPLIT>Lita.Robot.run_app<CODESPLIT>Starts the web server .<CODESPLIT>def run_app http_config = config . http @server_thread = Thread . new do @server = Puma :: Server . new ( app ) begin @server . add_tcp_listener ( http_config . host , http_config . port . to_i ) rescue Errno :: EADDRINUSE , Errno :: EACCES => e logger . fatal I18n . t ( "lita.http.exception" , message : e . message , backtrace : e . backtrace . join ( "\n" ) ) abort end @server . min_threads = http_config . min_threads @server . max_threads = http_config . max_threads @server . run end @server_thread . abort_on_exception = true end

0<CODESPLIT>https://github.com/Vasfed/orangedata/blob/020c332b1d11855e6bd0e9ba3b40f42276d013b5/lib/orange_data/transport.rb#L157-L162<CODESPLIT>Pagination.Collection.displayed_pages<CODESPLIT>Below actual methods from api<CODESPLIT>def displayed_pages ( limit = 10 , left_offset = - 5 , right_offset = 4 ) lower , upper = nil , nil if page + left_offset < 1 || page + right_offset > pages . last lower = [ page , [ pages . last - limit , 0 ] . max + 1 ] . min upper = [ page + limit - 1 , pages . last ] . min else lower = page + left_offset upper = page + right_offset end ( lower .. upper ) . to_a end

0<CODESPLIT>https://github.com/amzn/amazon-pay-sdk-ruby/blob/6321994cc10b5614630b6743da8d1eb79b2bc1ed/lib/amazon_pay/client.rb#L133-L172<CODESPLIT>OpenGraph.Object.schema<CODESPLIT>Creates an order reference for the given object<CODESPLIT>def schema OpenGraph :: TYPES . each_pair do | schema , types | return schema if types . include? ( self . type ) end nil end

1<CODESPLIT>https://github.com/junegunn/jdbc-helper/blob/0c0e7142ca7faab93db68d526753032ab2dc652f/lib/jdbc-helper/wrapper/procedure_wrapper.rb#L21-L29<CODESPLIT>JDBCHelper.ProcedureWrapper.call<CODESPLIT>Executes the procedure and returns the values of INOUT & OUT parameters in Hash<CODESPLIT>def call ( * args ) params = build_params args cstmt = @connection . prepare_call "{call #{name}(#{Array.new(@cols.length){'?'}.join ', '})}" begin process_result ( args , cstmt . call ( params ) ) ensure cstmt . close end end

1<CODESPLIT>https://github.com/rightscale/right_chimp/blob/290d3e01f7bf4b505722a080cb0abbb0314222f8/lib/right_chimp/queue/execution_group.rb#L183-L188<CODESPLIT>Chimp.ExecutionGroup.running?<CODESPLIT>Is this execution group running anything?<CODESPLIT>def running? total_jobs_running = get_jobs_by_status ( Executor :: STATUS_NONE ) . size + get_jobs_by_status ( Executor :: STATUS_RUNNING ) . size + get_jobs_by_status ( Executor :: STATUS_RETRYING ) . size ( total_jobs_running > 0 ) end

0<CODESPLIT>https://github.com/smalruby/smalruby/blob/859a5f0b503bc55a790fda38f2bce27414226ada/lib/smalruby/character.rb#L120-L132<CODESPLIT>Smalruby.Character.position=<CODESPLIT>Y ( ) <CODESPLIT>def position = ( val ) if @enable_pen @enable_pen = false left = x + center_x top = y + center_y self . x = val [ 0 ] self . y = val [ 1 ] draw_pen ( left , top , x + center_x , y + center_y ) @enable_pen = true else self . x = val [ 0 ] self . y = val [ 1 ] end end

1<CODESPLIT>https://github.com/jgoizueta/numerals/blob/a195e75f689af926537f791441bf8d11590c99c0/lib/numerals/format/symbols.rb#L280-L296<CODESPLIT>Numerals.Format::Symbols.group_digits<CODESPLIT>Group digits ( inserting nil values as separators )<CODESPLIT>def group_digits ( digits ) if grouping? grouped = [ ] i = 0 while digits . size > 0 l = @grouping [ i ] l = digits . size if l > digits . size grouped = [ nil ] + grouped if grouped . size > 0 grouped = digits [ - l , l ] + grouped digits = digits [ 0 , digits . length - l ] i += 1 if i < @grouping . size - 1 end grouped else digits end end

1<CODESPLIT>https://github.com/untra/polyglot/blob/23163148ba91daef1ce536b37a62c1ca67c05e84/spec/support/jekyll.rb#L81-L89<CODESPLIT>Jekyll.RSpecHelpers.stub_asset_config<CODESPLIT>------------------------------------------------------------------------ Stubs the asset config on Jekyll for you this is meant to be used in a new context or at the top of a context so that you can stub the configuration and have it reset afterwards . ------------------------------------------------------------------------<CODESPLIT>def stub_asset_config ( inst , hash = nil ) ( hash = inst ; inst = nil ) if inst . is_a? ( Hash ) inst = @site || site unless inst hash = Jekyll :: Assets :: Config . merge ( hash ) allow ( inst ) . to receive ( :config ) . and_return ( inst . config . merge ( { "assets" => hash } ) ) end

1<CODESPLIT>https://github.com/datamapper/dm-sweatshop/blob/25d6b2353973df329734801417e31709f6ff7686/lib/dm-sweatshop/model.rb#L82-L85<CODESPLIT>DataMapper.Model.make<CODESPLIT>Creates an instance from given hash of attributes and adds it to records map without saving .<CODESPLIT>def make ( name = default_fauxture_name , attributes = { } ) name , attributes = default_fauxture_name , name if name . is_a? Hash Sweatshop . make ( self , name , attributes ) end

1<CODESPLIT>https://github.com/david942j/rbelftools/blob/9a453ac31d72eae3b8b99d5dbd361c101577d58e/lib/elftools/elf_file.rb#L120-L126<CODESPLIT>ELFTools.ELFFile.each_sections<CODESPLIT>Iterate all sections .<CODESPLIT>def each_sections ( & block ) return enum_for ( :each_sections ) unless block_given? Array . new ( num_sections ) do | i | section_at ( i ) . tap ( block ) end end

0<CODESPLIT>https://github.com/rvm/rvm-gem/blob/7ef58904108a1abf1dbabafc605ece1fc9c53668/lib/rvm/environment/gemset.rb#L82-L93<CODESPLIT>RVM.Environment.gemset_globalcache<CODESPLIT>Changes the current environments gemset . If : replace_env is passed and the ruby is compatible it will attempt to replace the current processes gem home and path with the one requested .<CODESPLIT>def gemset_globalcache ( enable = true ) case enable when "enabled" , :enabled run ( :__rvm_using_gemset_globalcache ) . successful? when true , "enable" , :enable rvm ( :gemset , :globalcache , :enable ) . successful? when false , "disable" , :disable rvm ( :gemset , :globalcache , :disable ) . successful? else false end end

0<CODESPLIT>https://github.com/CloudStack-extras/knife-cloudstack/blob/7fa996cabac740b8c29e7b0c84508134372823bd/lib/knife-cloudstack/connection.rb#L894-L948<CODESPLIT>CloudstackClient.Connection.send_async_request<CODESPLIT>Sends a synchronous request to the CloudStack API and returns the response as a Hash .<CODESPLIT>def send_async_request ( params ) json = send_request ( params ) params = { 'command' => 'queryAsyncJobResult' , 'jobId' => json [ 'jobid' ] } max_tries = ( ASYNC_TIMEOUT / ASYNC_POLL_INTERVAL ) . round max_tries . times do json = send_request ( params ) status = json [ 'jobstatus' ] print "." if status == 1 then print "\n" return json [ 'jobresult' ] elsif status == 2 then print "\n" puts "Request failed (#{json['jobresultcode']}): #{json['jobresult']}" exit 1 end STDOUT . flush sleep ASYNC_POLL_INTERVAL end print "\n" puts "Error: Asynchronous request timed out" exit 1 end

1<CODESPLIT>https://github.com/rightscale/right_chimp/blob/290d3e01f7bf4b505722a080cb0abbb0314222f8/lib/right_chimp/chimp.rb#L987-L1003<CODESPLIT>Chimp.Chimp.queue_runner<CODESPLIT>Execute the user s command and provide for retrys etc .<CODESPLIT>def queue_runner ( concurrency , delay , retry_count , progress ) queue = ChimpQueue . instance queue . max_threads = concurrency queue . delay = delay queue . retry_count = retry_count total_queue_size = queue . size puts "Executing..." unless progress or not quiet pbar = ProgressBar . new ( "Executing" , 100 ) if progress queue . start queue . wait_until_done ( @group ) do pbar . set ( ( ( total_queue_size . to_f - queue . size . to_f ) / total_queue_size . to_f 100 ) . to_i ) if progress end pbar . finish if progress end

0<CODESPLIT>https://github.com/grodowski/undercover/blob/8f9cb32094d1669d67ff957337f95243c4d15ff2/lib/undercover/result.rb#L50-L61<CODESPLIT>Undercover.Result.pretty_print<CODESPLIT>TODO : create a formatter interface instead and add some tests . TODO : re - enable rubocops rubocop : disable Metrics / MethodLength Metrics / AbcSize<CODESPLIT>def pretty_print pad = node . last_line . to_s . length pretty_print_lines . map do | covered , ( num , line ) | formatted_line = "#{num.to_s.rjust(pad)}: #{line}" if line . strip . length . zero? Rainbow ( formatted_line ) . darkgray . dark elsif covered . nil? Rainbow ( formatted_line ) . darkgray . dark + Rainbow ( ' hits: n/a' ) . italic . darkgray . dark elsif covered . positive? Rainbow ( formatted_line ) . green + Rainbow ( " hits: #{covered}" ) . italic . darkgray . dark elsif covered . zero? Rainbow ( formatted_line ) . red + Rainbow ( " hits: #{covered}" ) . italic . darkgray . dark end end . join ( "\n" ) end

1<CODESPLIT>https://github.com/notEthan/api_hammer/blob/a5ebc1b9e8c1635035a6b600a81b3d52cc673a8e/lib/api_hammer/sinatra.rb#L130-L137<CODESPLIT>ApiHammer.Sinatra.request_body<CODESPLIT>reads the request body<CODESPLIT>def request_body # rewind in case anything in the past has left this un-rewound  request . body . rewind request . body . read . tap do # rewind in case anything in the future expects this to have been left rewound  request . body . rewind end end

0<CODESPLIT>https://github.com/lml/commontator/blob/1cfc72bc4078fb3c92fa74987af219de583e82ff/app/controllers/commontator/subscriptions_controller.rb#L6-L17<CODESPLIT>Commontator.Thread.can_be_edited_by?<CODESPLIT>PUT / threads / 1 / subscribe<CODESPLIT>def can_be_edited_by? ( user ) ! commontable . nil? && ! user . nil? && user . is_commontator && config . thread_moderator_proc . call ( self , user ) end

1<CODESPLIT>https://github.com/as181920/as_user/blob/cfa0673c67385a1926aa831779913e96ce50ea6a/app/controllers/as_user/users_controller.rb#L9-L16<CODESPLIT>AsUser.UsersController.index<CODESPLIT>GET / users GET / users . json<CODESPLIT>def index @users = User . order ( "created_at desc" ) . page ( [ params [ :page ] . to_i , 1 ] . max ) . per ( 100 ) respond_to do | format | format . html # index.html.erb format . json { render json : @users } end end

1<CODESPLIT>https://github.com/couchrest/couchrest/blob/cdd3ad30b9fa9aad5464cb4647c18c198b2c48d9/lib/couchrest/helper/stream_row_parser.rb#L41-L89<CODESPLIT>CouchRest.StreamRowParser.parse<CODESPLIT>Instantiate a new StreamRowParser with the mode set according to the type of data . The supported modes are :<CODESPLIT>def parse ( segment , & block ) @in_rows = true if @row_level == 0 segment . each_char do | c | if @string # Inside a string, handling escaping and closure if @escape @escape = false else if c == '"' @string = false elsif c == '\\' @escape = true end end else # Inside an object @obj_close = false if @obj_level == @row_level && c == "[" # start of rows @in_rows = true elsif @obj_level == @row_level && c == "]" # end of rows @in_rows = false elsif c == "{" # object @obj_level += 1 elsif c == "}" # object end @obj_level -= 1 @obj_close = true elsif c == '"' @string = true end end # Append data if @row_level > 0 if @obj_level == 0 || ( @obj_level == @row_level && ! @obj_close ) @header << c unless @in_rows && ( c == ',' || c == ' ' || c == "\n" ) # skip row whitespace else @data << c end else @data << c end # Determine if we need to trigger an event if @obj_close && @obj_level == @row_level block . call ( @data ) @data = "" end end end

0<CODESPLIT>https://github.com/jasonlong/geo_pattern/blob/62d3222c7394f0f02ab7f4705219d616c5a72b7e/lib/geo_pattern/rake_task.rb#L79-L88<CODESPLIT>GeoPattern.Helpers.underscore<CODESPLIT>Define task<CODESPLIT>def underscore ( camel_cased_word ) return camel_cased_word unless camel_cased_word =~ / / word = camel_cased_word . to_s word . gsub! ( / \d / , '\1_\2' ) word . gsub! ( / \d / , '\1_\2' ) word . downcase! word end

0<CODESPLIT>https://github.com/piotrmurach/github/blob/8702452c66bea33c9388550aed9e9974f76aaef1/lib/github_api/client/projects.rb#L57-L64<CODESPLIT>Github.Client::Orgs::Memberships.get<CODESPLIT>Edit a project<CODESPLIT>def get ( * args ) arguments ( args , required : [ :org_name ] ) params = arguments . params if ( username = params . delete ( 'username' ) ) get_request ( "/orgs/#{arguments.org_name}/memberships/#{username}" , params ) else get_request ( "/user/memberships/orgs/#{arguments.org_name}" , params ) end end

0<CODESPLIT>https://github.com/rhomobile/rhodes/blob/3c5f87b1a44f0ba2865ca0e1dd780dd202f64872/lib/extensions/rexml/rexml/document.rb#L69-L99<CODESPLIT>REXML.Namespace.has_name?<CODESPLIT>We override this because XMLDecls and DocTypes must go at the start of the document<CODESPLIT>def has_name? ( other , ns = nil ) if ns return ( namespace ( ) == ns and name ( ) == other ) elsif other . include? ":" return fully_expanded_name == other else return name == other end end

1<CODESPLIT>https://github.com/pjb3/attribution/blob/0fc1af52b969addb80b347d2c608e31c56a3c6de/lib/attribution.rb#L100-L112<CODESPLIT>Attribution.ClassMethods.boolean<CODESPLIT>Defines a boolean attribute<CODESPLIT>def boolean ( attr , metadata = { } ) add_attribute ( attr , :boolean , metadata ) define_method ( "#{attr}=" ) do | arg | v = case arg when String then BOOLEAN_TRUE_STRINGS . include? ( arg . downcase ) when Numeric then arg == 1 when nil then nil else ! ! arg end instance_variable_set ( "@#{attr}" , v ) end alias_method "#{attr}?" , attr end

0<CODESPLIT>https://github.com/dicom/rtkit/blob/08248bf294769ae5b45ed4a9671f0620d5740252/lib/rtkit/selection.rb#L117-L124<CODESPLIT>RTKIT.Selection.add_indices<CODESPLIT>Shifts the indices of this selection by the specified number of columns and rows . Positive arguments increment the column and row indices .<CODESPLIT>def add_indices ( indices ) raise ArgumentError , "Invalid argument 'indices'. Expected Array/NArray, got #{indices.class}." unless [ NArray , Array ] . include? ( indices . class ) raise ArgumentError , "Invalid argument 'indices'. Expected Array to contain only integers, got #{indices.collect{|i| i.class}.uniq}." if indices . is_a? ( Array ) and not indices . collect { | i | i . class } . uniq == [ Fixnum ] indices = indices . to_a if indices . is_a? ( NArray ) @indices += indices end

0<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_kusto/lib/2017-09-07-privatepreview/generated/azure_mgmt_kusto/clusters.rb#L706-L709<CODESPLIT>Azure::Kusto::Mgmt::V2018_09_07_privatepreview.Clusters.begin_create_or_update_with_http_info<CODESPLIT>Returns the SKUs available for the provided resource .<CODESPLIT>def begin_create_or_update_with_http_info ( resource_group_name , cluster_name , parameters , custom_headers : nil ) begin_create_or_update_async ( resource_group_name , cluster_name , parameters , custom_headers :custom_headers ) . value! end

0<CODESPLIT>https://github.com/rails/rails/blob/85a8bc644be69908f05740a5886ec19cd3679df5/actionpack/lib/action_controller/metal/params_wrapper.rb#L275-L280<CODESPLIT>Rails.ConsoleMethods.new_session<CODESPLIT>Checks if we should perform parameters wrapping .<CODESPLIT>def new_session app = Rails . application session = ActionDispatch :: Integration :: Session . new ( app ) yield session if block_given? # This makes app.url_for and app.foo_path available in the console session . extend ( app . routes . url_helpers ) session . extend ( app . routes . mounted_helpers ) session end

0<CODESPLIT>https://github.com/spikegrobstein/capnotify/blob/b21ea876ae2a04e8090206a687436565051f0e08/lib/capnotify/plugin.rb#L71-L76<CODESPLIT>Capnotify.Plugin.get_plugin<CODESPLIT>given a plugin name as a symbol unload the capnotify plugin this will also unload any kind of capistrano plugin if the plugin supports the unload method it will be called .<CODESPLIT>def get_plugin ( name ) raise "Unknown plugin: #{ name }" unless Capistrano :: EXTENSIONS . keys . include? ( name ) self . send ( name ) end

0<CODESPLIT>https://github.com/rayh/xcoder/blob/0affa3e8f0a5c138ea25c004341d62b23c6b6711/lib/xcode/workspace.rb#L63-L68<CODESPLIT>Xcode.TargetDependency.create_dependency_on<CODESPLIT>Return the names project . Raises an error if no projects match the specified name .<CODESPLIT>def create_dependency_on ( target ) @properties [ 'target' ] = target . identifier container_item_proxy = ContainerItemProxy . default target . project . project . identifier , target . identifier , target . name container_item_proxy = @registry . add_object ( container_item_proxy ) @properties [ 'targetProxy' ] = container_item_proxy . identifier save! end

1<CODESPLIT>https://github.com/Asquera/warden-hmac-authentication/blob/10005a8d205411405e7f5f5d5711c3c2228b5b71/lib/hmac/signer.rb#L262-L268<CODESPLIT>HMAC.Signer.sign_url<CODESPLIT>convienience method to sign a url for use with query - based authentication<CODESPLIT>def sign_url ( url , secret , opts = { } ) opts = default_opts . merge ( opts ) opts [ :query_based ] = true headers , url = sign_request ( url , secret , opts ) url end

1<CODESPLIT>https://github.com/maetl/calyx/blob/5011cd4b948792bdfd22ae1d3eaac9ff529e3861/lib/calyx/registry.rb#L77-L80<CODESPLIT>Calyx.Registry.define_context_rule<CODESPLIT>Defines a rule in the temporary evaluation context .<CODESPLIT>def define_context_rule ( name , trace , productions ) productions = [ productions ] unless productions . is_a? ( Enumerable ) context [ name . to_sym ] = Rule . new ( name . to_sym , construct_rule ( productions ) , trace ) end

1<CODESPLIT>https://github.com/emancu/ork/blob/83b2deaef0e790d90f98c031f254b5f438b19edf/lib/ork/model/associations.rb#L235-L264<CODESPLIT>Ork::Model.Associations.embed_collection<CODESPLIT>A macro for find embedded objects of the same type massive assign and syntactic sugar for add an object to the collection .<CODESPLIT>def embed_collection ( name , model ) embedding << name unless embedding . include? ( name ) define_method ( name ) do return [ ] unless @embedding . has_key? name @_memo [ name ] ||= begin model = Ork :: Utils . const ( self . class , model ) @embedding [ name ] . map do | atts | new_embedded model , atts end end end define_method ( :" #{ name } " ) do | object | assert_embeddable object object . __parent = self @_memo [ name ] << object if @_memo [ name ] @embedding [ name ] = Array ( @embedding [ name ] ) << object . attributes end define_method ( :" #{ name } " ) do | object | assert_embeddable object object . __parent = nil @_memo [ name ] . delete ( object ) if @_memo [ name ] @embedding [ name ] . delete ( object . attributes ) and object if @embedding [ name ] end end

0<CODESPLIT>https://github.com/thumblemonks/riot/blob/e99a8965f2d28730fc863c647ca40b3bffb9e562/lib/riot/assertion_macros/same_elements.rb#L16-L19<CODESPLIT>Riot.SameElementsMacro.devaluate<CODESPLIT>( see Riot :: AssertionMacro#evaluate )<CODESPLIT>def devaluate ( actual , expected ) same = ( Set . new ( expected ) == Set . new ( actual ) ) same ? fail ( expected_message . elements ( expected ) . not_to_match ( actual ) ) : pass ( new_message . has_same_elements_as ( expected ) ) end

0<CODESPLIT>https://github.com/groupdocs-signature-cloud/groupdocs-signature-cloud-ruby/blob/d16e6f4bdd6cb9196d4e28ef3fc2123da94f0ef0/lib/groupdocs_signature_cloud/models/slides_sign_qr_code_options_data.rb#L472-L482<CODESPLIT>GroupDocsSignatureCloud.SlidesSignQRCodeOptionsData.margin_measure_type=<CODESPLIT>Custom attribute writer method checking allowed values ( enum ) .<CODESPLIT>def margin_measure_type = ( margin_measure_type ) validator = EnumAttributeValidator . new ( 'String' , [ "Pixels" , "Percents" , "Millimeters" ] ) if margin_measure_type . to_i == 0 unless validator . valid? ( margin_measure_type ) raise ArgumentError , "invalid value for 'margin_measure_type', must be one of #{validator.allowable_values}." end @margin_measure_type = margin_measure_type else @margin_measure_type = validator . allowable_values [ margin_measure_type . to_i ] end end

1<CODESPLIT>https://github.com/infinitetoken/barcodes/blob/76a0bda4f5afca246ef040ea96f92044366efc39/lib/barcodes/exec.rb#L81-L92<CODESPLIT>Barcodes.Exec._parse!<CODESPLIT>Parses the command line arguments<CODESPLIT>def _parse! begin self . parser . parse! ( self . argv ) rescue puts self . parser . help exit 1 end @symbology = self . argv . shift @target = self . argv . shift end

0<CODESPLIT>https://github.com/schoefmann/klarlack/blob/7c1b2668da27d663d904c9646ef0d492830fe3de/lib/varnish/client.rb#L144-L157<CODESPLIT>Varnish.Client.stats<CODESPLIT>Purge objects from the cache or show the purge queue .<CODESPLIT>def stats result = cmd ( "stats" ) Hash [ result . split ( "\n" ) . map { | line | stat = line . strip! . split ( / \s / , 2 ) [ stat [ 1 ] , stat [ 0 ] . to_i ] } . flatten ] end

1<CODESPLIT>https://github.com/negativecode/vines/blob/245d6c971dd8604d74265d67fd4e2a78319d71a2/lib/vines/stanza.rb#L80-L84<CODESPLIT>Vines.Stanza.send_unavailable<CODESPLIT>Broadcast unavailable presence from the user s available resources to the recipient s available resources . Route the stanza to a remote server if the recipient isn t hosted locally .<CODESPLIT>def send_unavailable ( from , to ) available = router . available_resources ( from , to ) stanzas = available . map { | stream | unavailable ( stream . user . jid ) } broadcast_to_available_resources ( stanzas , to ) end

0<CODESPLIT>https://github.com/garethlatwork/quickbase_client/blob/13d754de1f22a466806c5a0da74b0ded26c23f05/lib/QuickBaseClient.rb#L2218-L2232<CODESPLIT>QuickBase.Client.editRecord<CODESPLIT>Download and save a file from a file attachment field in QuickBase . Use the filename parameter to override the file name from QuickBase .<CODESPLIT>def editRecord ( dbid , rid , fvlist , disprec = nil , fform = nil , ignoreError = nil , update_id = nil , msInUTC = nil , key = nil ) @dbid , @rid , @fvlist , @disprec , @fform , @ignoreError , @update_id , @msInUTC , @key = dbid , rid , fvlist , disprec , fform , ignoreError , update_id , msInUTC , key setFieldValues ( fvlist , false ) if fvlist . is_a? ( Hash ) xmlRequestData = toXML ( :rid , @rid ) if @rid xmlRequestData = toXML ( :key , @key ) if @key @fvlist . each { | fv | xmlRequestData << fv } #see addFieldValuePair, clearFieldValuePairList, @fvlist  xmlRequestData << toXML ( :disprec , @disprec ) if @disprec xmlRequestData << toXML ( :fform , @fform ) if @fform xmlRequestData << toXML ( :ignoreError , "1" ) if @ignoreError xmlRequestData << toXML ( :update_id , @update_id ) if @update_id xmlRequestData << toXML ( :msInUTC , "1" ) if @msInUTC sendRequest ( :editRecord , xmlRequestData ) @rid = getResponseValue ( :rid ) @update_id = getResponseValue ( :update_id ) return self if @chainAPIcalls return @rid , @update_id end

1<CODESPLIT>https://github.com/ozfortress/tournament-system/blob/d4c8dc77933ba97d369f287b1c21d7fcda78830b/lib/tournament_system/round_robin.rb#L14-L22<CODESPLIT>TournamentSystem.RoundRobin.generate<CODESPLIT>Generate matches with the given driver .<CODESPLIT>def generate ( driver , options = { } ) round = options [ :round ] || guess_round ( driver ) teams = Algorithm :: Util . padd_teams_even ( driver . seeded_teams ) matches = Algorithm :: RoundRobin . round_robin_pairing ( teams , round ) create_matches driver , matches , round end

1<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_stor_simple8000_series/lib/2017-06-01/generated/azure_mgmt_stor_simple8000_series/device_settings.rb#L150-L166<CODESPLIT>Azure::StorSimple8000Series::Mgmt::V2017_06_01.DeviceSettings.create_or_update_alert_settings_async<CODESPLIT>@param device_name [ String ] The device name @param parameters [ AlertSettings ] The alert settings to be added or updated . @param resource_group_name [ String ] The resource group name @param manager_name [ String ] The manager name @param custom_headers [ Hash { String = > String } ] A hash of custom headers that will be added to the HTTP request .<CODESPLIT>def create_or_update_alert_settings_async ( device_name , parameters , resource_group_name , manager_name , custom_headers : nil ) # Send request promise = begin_create_or_update_alert_settings_async ( device_name , parameters , resource_group_name , manager_name , custom_headers :custom_headers ) promise = promise . then do | response | # Defining deserialization method. deserialize_method = lambda do | parsed_response | result_mapper = Azure :: StorSimple8000Series :: Mgmt :: V2017_06_01 :: Models :: AlertSettings . mapper ( ) parsed_response = @client . deserialize ( result_mapper , parsed_response ) end # Waiting for response. @client . get_long_running_operation_result ( response , deserialize_method ) end promise end

0<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/data/azure_cognitiveservices_luisauthoring/lib/2.0/generated/azure_cognitiveservices_luisauthoring/apps.rb#L1325-L1328<CODESPLIT>Azure::CognitiveServices::LuisAuthoring::V2_0.Apps.get_settings<CODESPLIT>Updates the application settings including UseAllTrainingData .<CODESPLIT>def get_settings ( app_id , custom_headers : nil ) response = get_settings_async ( app_id , custom_headers :custom_headers ) . value! response . body unless response . nil? end

0<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_container_service/lib/2019-02-01/generated/azure_mgmt_container_service/managed_clusters.rb#L1399-L1402<CODESPLIT>Azure::ContainerService::Mgmt::V2019_02_01.ManagedClusters.begin_reset_aadprofile_with_http_info<CODESPLIT>Reset AAD Profile of a managed cluster .<CODESPLIT>def begin_reset_aadprofile_with_http_info ( resource_group_name , resource_name , parameters , custom_headers : nil ) begin_reset_aadprofile_async ( resource_group_name , resource_name , parameters , custom_headers :custom_headers ) . value! end

1<CODESPLIT>https://github.com/olabini/codebot/blob/031ddf427fd4a245ee6ff6414c4e28dab31679c1/lib/codebot/web_listener.rb#L17-L22<CODESPLIT>Codebot.WebListener.handle_post<CODESPLIT>Handles a POST request .<CODESPLIT>def handle_post ( core , request , params ) payload = params [ 'payload' ] || request . body . read dispatch ( core , request , params [ 'splat' ] , payload ) rescue JSON :: ParserError [ 400 , 'Invalid JSON payload' ] end

0<CODESPLIT>https://github.com/wvanbergen/chunky_png/blob/691f8cb0fbe1816474bf8af8dbea4fb53debb816/lib/chunky_png/datastream.rb#L141-L147<CODESPLIT>ChunkyPNG.Datastream.each_chunk<CODESPLIT>Returns all the textual metadata key / value pairs as hash .<CODESPLIT>def each_chunk yield ( header_chunk ) other_chunks . each { | chunk | yield ( chunk ) } yield ( palette_chunk ) if palette_chunk yield ( transparency_chunk ) if transparency_chunk yield ( physical_chunk ) if physical_chunk data_chunks . each { | chunk | yield ( chunk ) } yield ( end_chunk ) end

0<CODESPLIT>https://github.com/StuartApp/h3_ruby/blob/f32e91fe1d4d1b1428e940941cb51f0ea260c46d/lib/h3/unidirectional_edges.rb#L119-L124<CODESPLIT>H3.UnidirectionalEdges.h3_unidirectional_edge_boundary<CODESPLIT>Derive unidirectional edges for a H3 index .<CODESPLIT>def h3_unidirectional_edge_boundary ( edge ) geo_boundary = GeoBoundary . new Bindings :: Private . h3_unidirectional_edge_boundary ( edge , geo_boundary ) geo_boundary [ :verts ] . take ( geo_boundary [ :num_verts ] ) . map do | d | [ rads_to_degs ( d [ :lat ] ) , rads_to_degs ( d [ :lon ] ) ] end end

0<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_web/lib/2018-02-01/generated/azure_mgmt_web/diagnostics.rb#L1829-L1832<CODESPLIT>Azure::Web::Mgmt::V2018_02_01.Diagnostics.get_site_diagnostic_category_slot_with_http_info<CODESPLIT>Get Site Analyses<CODESPLIT>def get_site_diagnostic_category_slot_with_http_info ( resource_group_name , site_name , diagnostic_category , slot , custom_headers : nil ) get_site_diagnostic_category_slot_async ( resource_group_name , site_name , diagnostic_category , slot , custom_headers :custom_headers ) . value! end

1<CODESPLIT>https://github.com/detroit/detroit-email/blob/682de790705301f2b83cd6afab585f5aaf59d42b/lib/detroit-email.rb#L125-L147<CODESPLIT>Detroit.Email.announce<CODESPLIT>Send announcement message .<CODESPLIT>def announce apply_environment unless @approved mailopts = self . mailopts if mailto . empty? report "No recipents given." else if trial? subject = mailopts [ 'subject' ] mailto = mailopts [ 'to' ] . flatten . join ( ", " ) report "email '#{subject}' to #{mailto}" else #emailer = Emailer.new(mailopts) #emailer.email if @approved email ( mailopts ) else exit - 1 end end end end

1<CODESPLIT>https://github.com/emancu/ork/blob/83b2deaef0e790d90f98c031f254b5f438b19edf/lib/ork/model/document.rb#L72-L83<CODESPLIT>Ork.Document.save<CODESPLIT>Persist the model attributes and update indices and unique indices .<CODESPLIT>def save __robject . content_type = model . content_type __robject . data = __persist_attributes __check_unique_indices __update_indices __robject . store @id = __robject . key self end

0<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_automation/lib/2015-10-31/generated/azure_mgmt_automation/job_stream_operations.rb#L330-L339<CODESPLIT>Azure::ApiManagement::Mgmt::V2019_01_01.Api.begin_create_or_update_with_http_info<CODESPLIT>Retrieve a list of jobs streams identified by job id .<CODESPLIT>def begin_create_or_update_with_http_info ( resource_group_name , service_name , api_id , parameters , if_match : nil , custom_headers : nil ) begin_create_or_update_async ( resource_group_name , service_name , api_id , parameters , if_match :if_match , custom_headers :custom_headers ) . value! end

1<CODESPLIT>https://github.com/puppetlabs/pdk/blob/0d864aff62ffef04b5104addf399d0476afd71e7/lib/pdk/report.rb#L93-L110<CODESPLIT>PDK.Report.write_text<CODESPLIT>Renders the report as plain text .<CODESPLIT>def write_text ( target = self . class . default_target ) # Open a File Object for IO if target is a string containing a filename or path target = File . open ( target , 'w' ) if target . is_a? String coverage_report = nil events . each do | _tool , tool_events | tool_events . each do | event | if event . rspec_puppet_coverage? coverage_report = event . to_text else target . puts ( event . to_text ) unless event . pass? end end end ensure target . puts "\n#{coverage_report}" if coverage_report target . close if target . is_a? File end

1<CODESPLIT>https://github.com/nevans/resque-pool/blob/62293e48eb75852aa3e0f5f726d158a8614e9259/lib/resque/pool.rb#L179-L192<CODESPLIT>Resque.Pool.trap_deferred<CODESPLIT>defer a signal for later processing in #join ( master process )<CODESPLIT>def trap_deferred ( signal ) trap ( signal ) do | sig_nr | if @waiting_for_reaper && [ :INT , :TERM ] . include? ( signal ) log "Recieved #{signal}: short circuiting QUIT waitpid" raise QuitNowException end if sig_queue . size < SIG_QUEUE_MAX_SIZE sig_queue << signal awaken_master else log "ignoring SIG#{signal}, queue=#{sig_queue.inspect}" end end end

1<CODESPLIT>https://github.com/ThoughtWorksStudios/oauth2_provider/blob/d54702f194edd05389968cf8947465860abccc5d/tools/jruby-1.5.1/lib/ruby/1.8/net/http.rb#L1033-L1064<CODESPLIT>Net.HTTP.request<CODESPLIT>Sends an HTTPRequest object REQUEST to the HTTP server . This method also sends DATA string if REQUEST is a post / put request . Giving DATA for get / head request causes ArgumentError .<CODESPLIT>def request ( req , body = nil , & block ) # :yield: +response+ unless started? start { req [ 'connection' ] ||= 'close' return request ( req , body , block ) } end if proxy_user ( ) unless use_ssl? req . proxy_basic_auth proxy_user ( ) , proxy_pass ( ) end end req . set_body_internal body begin begin_transport req req . exec @socket , @curr_http_version , edit_path ( req . path ) begin res = HTTPResponse . read_new ( @socket ) end while res . kind_of? ( HTTPContinue ) res . reading_body ( @socket , req . response_body_permitted? ) { yield res if block_given? } end_transport req , res rescue => exception D "Conn close because of error #{exception}" @socket . close unless @socket . closed? raise exception end res end

0<CODESPLIT>https://github.com/dougfales/gpx/blob/632fcda922488ca410aabce451871755ef2b544c/lib/gpx/track.rb#L79-L86<CODESPLIT>GPX.Track.to_s<CODESPLIT>Deletes all points within a given area and updates the meta data .<CODESPLIT>def to_s result = "Track \n" result << "\tName: #{name}\n" result << "\tComment: #{comment}\n" result << "\tDescription: #{description}\n" result << "\tSize: #{points.size} points\n" result << "\tSegments: #{segments.size} \n" result << "\tDistance: #{distance} km\n" result << "\tMoving duration: #{moving_duration} km\n" result << "\tLowest Point: #{lowest_point.elevation} \n" result << "\tHighest Point: #{highest_point.elevation}\n " result << "\tBounds: #{bounds}" result end

0<CODESPLIT>https://github.com/calabash/calabash/blob/fac1ce9fcff6e2460c6e72a9b89d93a91a1bc745/lib/calabash/gestures.rb#L228-L230<CODESPLIT>Calabash.Gestures.pan_up<CODESPLIT>Performs a ** pan ** heading _down_ inside the first view that matches query .<CODESPLIT>def pan_up ( query , duration : nil ) pan ( query , { x : 50 , y : 90 } , { x : 50 , y : 10 } , duration : duration ) end

1<CODESPLIT>https://github.com/menghuanwd/umeng/blob/f44f03ae3ded0a61223b179a658a1b0b652fc500/lib/umeng/send_message_bak.rb#L32-L46<CODESPLIT>Umeng.SendMessage.push_unicast<CODESPLIT><CODESPLIT>def push_unicast ( device_tokens , opts = { } ) params = { DEVICE_TOKENS => device_tokens , PUSH_TYPE => 'unicast' , PRODUCTION_MODE => opts [ PRODUCTION_MODE ] } case @plantform when 'Android' params . merge! android_params ( opts ) push ( params ) when 'iOS' params . merge! ios_params ( opts ) push ( params ) end end

1<CODESPLIT>https://github.com/dicom/rtkit/blob/08248bf294769ae5b45ed4a9671f0620d5740252/lib/rtkit/slice.rb#L166-L177<CODESPLIT>RTKIT.Slice.plane<CODESPLIT>Gives a Plane corresponding to this Slice geometry . The plane is calculated from coordinates belonging to this instance .<CODESPLIT>def plane # Such a change is only possible if the Slice instance has a Contour with at least three Coordinates: raise "This Slice does not contain a Contour. Plane determination is not possible." if @contours . length == 0 raise "This Slice does not contain a Contour with at least 3 Coordinates. Plane determination is not possible." if @contours . first . coordinates . length < 3 # Get three coordinates from our Contour: contour = @contours . first num_coords = contour . coordinates . length c1 = contour . coordinates . first c2 = contour . coordinates [ num_coords / 3 ] c3 = contour . coordinates [ 2 * num_coords / 3 ] return Plane . calculate ( c1 , c2 , c3 ) end

1<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_network/lib/2016-12-01/generated/azure_mgmt_network/virtual_network_gateways.rb#L937-L939<CODESPLIT>Azure::Network::Mgmt::V2016_12_01.VirtualNetworkGateways.begin_get_bgp_peer_status_with_http_info<CODESPLIT>The GetBgpPeerStatus operation retrieves the status of all BGP peers .<CODESPLIT>def begin_get_bgp_peer_status_with_http_info ( resource_group_name , virtual_network_gateway_name , peer : nil , custom_headers : nil ) begin_get_bgp_peer_status_async ( resource_group_name , virtual_network_gateway_name , peer : peer , custom_headers :custom_headers ) . value! end

1<CODESPLIT>https://github.com/mitchellh/virtualbox/blob/5d5dfb649077dc72846ca4cd7eb76ea9bbc99b24/lib/virtualbox/vm.rb#L558-L563<CODESPLIT>VirtualBox.VM.control<CODESPLIT>Controls the virtual machine . This method is used by { #stop } { #pause } { #resume } and { #save_state } to control the virtual machine . Typically you won t ever have to call this method and should instead call those .<CODESPLIT>def control ( command , * args ) with_open_session ( :shared ) do | session | result = session . console . send ( command , args ) result . wait if result . is_a? ( COM :: Util . versioned_interface ( :Progress ) ) end end

0<CODESPLIT>https://github.com/kares/jruby-rack-worker/blob/d6bb51b063d8da6e1c5aedf74f62d7c70ea0aa4d/src/main/ruby/resque/jruby_worker.rb#L398-L413<CODESPLIT>Resque.JRubyWorker.system_register_worker<CODESPLIT>so that we can later identify a live worker thread<CODESPLIT>def system_register_worker # :nodoc self . class . with_global_lock do workers = self . class . system_registered_workers . push ( self . id ) self . class . store_global_property ( WORKERS_KEY , workers . join ( ',' ) ) end end

0<CODESPLIT>https://github.com/weshatheleopard/rubyXL/blob/e61d78de9486316cdee039d3590177dc05db0f0c/lib/rubyXL/convenience_methods/worksheet.rb#L293-L299<CODESPLIT>RubyXL.WorksheetConvenienceMethods.get_column_width<CODESPLIT>Get raw column width value as stored in the file<CODESPLIT>def get_column_width ( column_index = 0 ) width = get_column_width_raw ( column_index ) return RubyXL :: ColumnRange :: DEFAULT_WIDTH if width . nil? ( width - ( 5.0 / RubyXL :: Font :: MAX_DIGIT_WIDTH ) ) . round end

0<CODESPLIT>https://github.com/sauspiel/rbarman/blob/89723b5e051bafb1c30848e4f431b9d058871e3f/lib/rbarman/cli_command.rb#L176-L187<CODESPLIT>RBarman.CliCommand.parse_show_server_lines<CODESPLIT>Parses lines reported by barman s check and assigns according values<CODESPLIT>def parse_show_server_lines ( server , lines ) s = Server . new ( server ) lines . each do | l | key , value = l . gsub ( "\t" , "" ) . split ( ": " ) case key . chomp when "active" s . active = value . to_bool when "ssh_command" s . ssh_cmd = value when "conninfo" s . conn_info = value when "backup_directory" s . backup_dir = value when "basebackups_directory" s . base_backups_dir = value when "wals_directory" s . wals_dir = value when "server_txt_version" s . pg_version = value end end return s end

0<CODESPLIT>https://github.com/postmodern/rprogram/blob/94c32a72c98c7310d6e6b767b55ea8b8fbf0c0be/lib/rprogram/task.rb#L235-L250<CODESPLIT>RProgram.Task.leading_non_options<CODESPLIT>Generates the command - line arguments from all options .<CODESPLIT>def leading_non_options args = [ ] # add the task leading non-options @options . each do | name , value | non_opt = get_non_option ( name ) if ( non_opt && non_opt . leading? ) args += non_opt . arguments ( value ) end end # add all leading subtask non-options @subtasks . each_value do | task | args += task . leading_non_options end return args end

0<CODESPLIT>https://github.com/bratta/googlevoiceapi/blob/5d6163209bda665ba0cd7bbe723e59f6f7085705/lib/googlevoiceapi.rb#L85-L89<CODESPLIT>GoogleVoice.Api.call<CODESPLIT>International numbers can vary in length as opposed to the standard US 10 digit number So we can t effectively validate based on length . Instead let s make sure we have at least 4 digits and at most 15 since E . 164 recommends at most 15 digits minus country code for the phone number ( http : // en . wikipedia . org / wiki / E . 164 )<CODESPLIT>def call ( remote_number , forwarding_number ) login unless logged_in? remote_number = validate_number ( remote_number ) forwarding_number = validate_number ( forwarding_number ) @agent . post ( 'https://www.google.com/voice/call/connect/' , :outgoingNumber => remote_number , :forwardingNumber => forwarding_number , :phoneType => 2 , :subscriberNumber => 'undefined' , :remember => '0' , "_rnr_se" => @rnr_se ) end

0<CODESPLIT>https://github.com/riddopic/garcun/blob/c2409bd8cf9c14b967a719810dab5269d69b42de/lib/garcon/task/count_down_latch.rb#L61-L69<CODESPLIT>ThinkFeelDoDashboard.ArmsController.create<CODESPLIT>Create a new CountDownLatch with the initial count .<CODESPLIT>def create authorize! :create , Arm @arm = Arm . new ( arm_params ) if @arm . save redirect_to @arm , notice : "Arm was successfully created." else render :new end end

1<CODESPLIT>https://github.com/rahmal/rconfig/blob/528c2fca29fcba4eb495ae443fa04269278d226b/lib/rconfig/config.rb#L42-L54<CODESPLIT>RConfig.Config.method_missing<CODESPLIT>Dotted notation can be used with arguments ( useful for creating mock objects ) in the YAML file the method name is a key argument ( s ) form a nested key so that the correct value is retrieved and returned .<CODESPLIT>def method_missing ( method , * args ) method = method . to_s return if method == 'default_key' value = self [ method ] case args . size when 0 # e.g.: RConfig.application.method value when 1 # e.g.: RConfig.application.method(one_arg) value . send ( args [ 0 ] ) else # e.g.: RConfig.application.method(arg_one, args_two, ...) value [ args ] end end

0<CODESPLIT>https://github.com/awead/solr_ead/blob/54a5f5217152882946be6d4ee6deda0e1c80263c/lib/solr_ead/indexer.rb#L105-L112<CODESPLIT>SolrEad.Indexer.solr_url<CODESPLIT>Creates solr documents for each individual component node in the ead . Field names and values are determined according to the OM terminology outlined in SolrEad :: Component as well as additional fields taken from the rest of the ead document as described in SolrEad :: Behaviors#additional_component_fields .<CODESPLIT>def solr_url if defined? ( Rails . root ) :: YAML . load ( ERB . new ( File . read ( File . join ( Rails . root , "config" , "solr.yml" ) ) ) . result ) [ Rails . env ] [ 'url' ] elsif ENV [ 'RAILS_ENV' ] :: YAML . load ( ERB . new ( File . read ( "config/solr.yml" ) ) . result ) [ ENV [ 'RAILS_ENV' ] ] [ 'url' ] else :: YAML . load ( ERB . new ( File . read ( "config/solr.yml" ) ) . result ) [ 'development' ] [ 'url' ] end end

1<CODESPLIT>https://github.com/wvanbergen/request-log-analyzer/blob/b83865d440278583ac8e4901bb33878244fd7c75/lib/request_log_analyzer/source/log_parser.rb#L329-L334<CODESPLIT>RequestLogAnalyzer::Source.LogParser.handle_request<CODESPLIT>Handles the parsed request by sending it into the pipeline .<CODESPLIT>def handle_request ( request , & _block ) # :yields: :request, request @parsed_requests += 1 request . validate accepted = block_given? ? yield ( request ) : true @skipped_requests += 1 unless accepted end

0<CODESPLIT>https://github.com/tlux/vnstat-ruby/blob/06939a65f8453b49b8bae749efcbe08ce86099e8/lib/vnstat/parser.rb#L15-L19<CODESPLIT>StatusCat.StatusHelper.status_report_header<CODESPLIT>Extracts the year and month from the given XML element .<CODESPLIT>def status_report_header ( format = StatusCat :: Checkers :: Base :: FORMAT ) name = I18n . t ( :name , scope : :status_cat ) value = I18n . t ( :value , scope : :status_cat ) status = I18n . t ( :status , scope : :status_cat ) return format ( format , name , value , status ) end

0<CODESPLIT>https://github.com/Foodcritic/foodcritic/blob/f06e354833c75caa91a800e0f9343ece5185a737/lib/foodcritic/domain.rb#L63-L73<CODESPLIT>FoodCritic.Rule.matches_tags?<CODESPLIT>Returns a string representation of this review . This representation is liable to change .<CODESPLIT>def matches_tags? ( tag_expr ) Cucumber :: Core :: Gherkin :: TagExpression . new ( tag_expr ) . evaluate ( tags . map { | tag | Cucumber :: Core :: Ast :: Tag . new ( nil , tag ) } ) end

1<CODESPLIT>https://github.com/pellegrino/jackpot/blob/188b476cd26f319ee7f5cceceb1caa4205424ed8/app/controllers/jackpot/subscriptions_controller.rb#L76-L84<CODESPLIT>Jackpot.SubscriptionsController.destroy<CODESPLIT>DELETE / subscriptions / 1 DELETE / subscriptions / 1 . json<CODESPLIT>def destroy @subscription = Subscription . find ( params [ :id ] ) @subscription . destroy respond_to do | format | format . html { redirect_to subscriptions_url } format . json { head :ok } end end

0<CODESPLIT>https://github.com/syborg/mme_tools/blob/e93919f7fcfb408b941d6144290991a7feabaa7d/lib/mme_tools/args_proc.rb#L18-L21<CODESPLIT>CLIntegracon.LazyStringProxy.method_missing<CODESPLIT>Tests if + options + includes only valid keys . Raises an error if any key is not included within + valid_options + . + valid_options + is a Hash that must include all accepted keys . values aren t taken into account .<CODESPLIT>def method_missing ( method , * args , & block ) return LazyString . new do @formatter . send ( method , args , block ) end end

1<CODESPLIT>https://github.com/koraktor/rubikon/blob/c5a09d2a6a0878bb4ae5bcf71fcb111646ed0b2b/lib/rubikon/command.rb#L194-L199<CODESPLIT>Rubikon.Command.reset<CODESPLIT>Resets this command to its initial state<CODESPLIT>def reset super @params . values . uniq . each do | param | param . send ( :reset ) if param . is_a? Parameter end end

0<CODESPLIT>https://github.com/rmosolgo/graphql-ruby/blob/d5be13a816f220b9efbabeaa69a3e56fedf311f5/lib/graphql/schema.rb#L658-L660<CODESPLIT>GraphQL.Schema.as_json<CODESPLIT>Return the GraphQL IDL for the schema<CODESPLIT>def as_json ( only : nil , except : nil , context : { } ) execute ( Introspection :: INTROSPECTION_QUERY , only : only , except : except , context : context ) . to_h end

1<CODESPLIT>https://github.com/FTB-Gamepedia/MediaWiki-Butt-Ruby/blob/d71c5dfdf9d349d025e1c3534286ce116777eaa4/lib/mediawiki/butt.rb#L114-L118<CODESPLIT>MediaWiki.Butt.query_ary_irrelevant_keys<CODESPLIT>Helper method for query methods that return a two - dimensional hashes in which the keys are not relevant to the returning value . In most cases this key is a redundant page or revision ID that is also available in the object .<CODESPLIT>def query_ary_irrelevant_keys ( params , base_response_key , property_key ) query ( params ) do | return_val , query | return_val . concat ( query [ base_response_key ] . values . collect { | obj | obj [ property_key ] } ) end end

0<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_compute/lib/2018-06-01/generated/azure_mgmt_compute/gallery_images.rb#L237-L240<CODESPLIT>Azure::Compute::Mgmt::V2018_06_01.GalleryImages.begin_create_or_update<CODESPLIT>List gallery Image Definitions in a gallery .<CODESPLIT>def begin_create_or_update ( resource_group_name , gallery_name , gallery_image_name , gallery_image , custom_headers : nil ) response = begin_create_or_update_async ( resource_group_name , gallery_name , gallery_image_name , gallery_image , custom_headers :custom_headers ) . value! response . body unless response . nil? end

1<CODESPLIT>https://github.com/nathanstitt/erb_latex/blob/ea74677264b48b72913d5eae9eaac60f4151de8c/lib/erb_latex/template.rb#L68-L78<CODESPLIT>ErbLatex.Template.to_file<CODESPLIT>Save the PDF to the file<CODESPLIT>def to_file ( file = suggested_filename ) execute do | contents | if file . is_a? ( String ) FileUtils . mv contents , file else file . write contents . read file . rewind end end file end

1<CODESPLIT>https://github.com/notonthehighstreet/chicago/blob/428e94f8089d2f36fdcff2e27ea2af572b816def/lib/chicago/query.rb#L99-L107<CODESPLIT>Chicago.Query.dataset<CODESPLIT>Applies the query to a Sequel :: Database and returns a Sequel :: Dataset .<CODESPLIT>def dataset ( db = nil ) db ||= self . class . default_db builder = Database :: DatasetBuilder . new ( db , self ) builder . select ( @columns ) builder . filter ( @filters ) builder . order ( @order ) builder . limit ( @limit ) if @limit builder . dataset end

0<CODESPLIT>https://github.com/chrismoos/fastr/blob/aa3c72221983092b8964894ad0c97f60ea029d6e/lib/fastr/application.rb#L126-L137<CODESPLIT>Fastr.Cookie.set_cookie<CODESPLIT>Watch for any file changes in the load paths .<CODESPLIT>def set_cookie ( key , value , options = { } ) cookie = [ "#{key}=#{value};" ] if options . has_key? :expires and options [ :expires ] . kind_of? Time options [ :expires ] = options [ :expires ] . utc . strftime ( '%a, %d-%b-%Y %H:%M:%S GMT' ) end # Sort the cookies alphabetically. options . sort { | a , b | a . to_s <=> b . to_s } . each do | k , v | cookie << "#{k}=#{v.to_s};" end cookie_val = cookie . join ( ' ' ) if self . headers [ 'Set-Cookie' ] . nil? self . headers [ 'Set-Cookie' ] = [ cookie_val ] else self . headers [ 'Set-Cookie' ] << cookie_val end end

0<CODESPLIT>https://github.com/wurmlab/genevalidator/blob/b44a4a7e72eb8314c73d0cd7062d37a1c4c58299/lib/genevalidator/clusterization.rb#L75-L87<CODESPLIT>GeneValidator.PairCluster.distance<CODESPLIT>Returns the weighted mean value of the cluster<CODESPLIT>def distance ( cluster , method = 0 ) d = 0 norm = 0 cluster . objects . each do | elem1 | objects . each do | elem2 | if method == 1 d += elem1 [ 1 ] * elem2 [ 1 ] * ( elem1 [ 0 ] - elem2 [ 0 ] ) . abs norm += elem1 [ 1 ] * elem2 [ 1 ] else d += ( elem1 [ 0 ] - elem2 [ 0 ] ) . abs norm = cluster . objects . length * objects . length end end end # group average distance d /= ( norm + 0.0 ) end

0<CODESPLIT>https://github.com/Shopify/active_shipping/blob/590bc805e10a137251c122a1525940c34b164a44/lib/active_shipping/external_return_label_request.rb#L290-L300<CODESPLIT>ActiveShipping.USPS.canned_address_verification_works?<CODESPLIT>Zipcode of customer returning the package . According to the USPS documentation Zipcode is optional unless <tt > address_override_notification< / tt > is true and <tt > address_validation< / tt > is set to false . It s probably just easier to require Zipcodes . <b > Required< / b > .<CODESPLIT>def canned_address_verification_works? return false unless @options [ :login ] request = <<-EOF #{ URI . encode ( @options [ :login ] ) } EOF xml = Nokogiri . XML ( commit ( :test , request , true ) ) { | config | config . strict } xml . at ( '/CarrierPickupAvailabilityResponse/City' ) . try ( :text ) == 'SAN FRANCISCO' && xml . at ( '/CarrierPickupAvailabilityResponse/Address2' ) . try ( :text ) == '18 FAIR AVE' end

0<CODESPLIT>https://github.com/aws/aws-sdk-ruby/blob/e28b8d320ddf7b6ee0161bdd9d00fb786d99b63d/gems/aws-sdk-iam/lib/aws-sdk-iam/policy.rb#L311-L315<CODESPLIT>Aws::IAM.Policy.attach_user<CODESPLIT>@example Request syntax with placeholder values<CODESPLIT>def attach_user ( options = { } ) options = options . merge ( policy_arn : @arn ) resp = @client . attach_user_policy ( options ) resp . data end

1<CODESPLIT>https://github.com/dpla/KriKri/blob/0ac26e60ce1bba60caa40263a562796267cf833f/lib/krikri/search_index.rb#L321-L333<CODESPLIT>Krikri.ProdSearchIndex.bulk_add<CODESPLIT>@param [ Hash ] opts<CODESPLIT>def bulk_add ( docs ) body = docs . map do | doc | { index : { _index : @index_name , _type : doc [ :ingestType ] , _id : doc [ :id ] , data : doc } } end @elasticsearch . bulk body : body end

1<CODESPLIT>https://github.com/angelim/rails_redshift_replicator/blob/823f6da36f43a39f340a3ca7eb159df58a86766d/lib/rails_redshift_replicator/deleter.rb#L35-L42<CODESPLIT>RailsRedshiftReplicator.Deleter.deleted_ids<CODESPLIT>Retrives ids of objects enqueued for deletion for the replication source table<CODESPLIT>def deleted_ids sql = <<-DR . squish #{ replicable . source_table } DR ActiveRecord :: Base . connection . execute ( sql ) . map { | r | r [ 'object_id' ] } end

0<CODESPLIT>https://github.com/potatosalad/ruby-jose/blob/e1be589b889f1e59ac233a5d19a3fa13f1e4b8a0/lib/jose/jwe.rb#L528-L534<CODESPLIT>JOSE.JWE.block_decrypt<CODESPLIT>Converts a { JOSE :: JWE JOSE :: JWE } into a map .<CODESPLIT>def block_decrypt ( key , aad , cipher_text , cipher_tag , encrypted_key , iv ) cek = key_decrypt ( key , encrypted_key ) return uncompress ( enc . block_decrypt ( [ aad , cipher_text , cipher_tag ] , cek , iv ) ) end

1<CODESPLIT>https://github.com/github/linguist/blob/9116c90fcbb82ac03b4b33c58cfbde1fcf745e99/lib/linguist/heuristics.rb#L94-L98<CODESPLIT>Linguist.Heuristics.matches?<CODESPLIT>Internal Internal : Check if this heuristic matches the candidate filenames or languages .<CODESPLIT>def matches? ( filename , candidates ) filename = filename . downcase candidates = candidates . compact . map ( :name ) @exts_and_langs . any? { | ext | filename . end_with? ( ext ) } end

0<CODESPLIT>https://github.com/knife-block/knife-block/blob/9ee7f991c7f8400b608e65f6dffa0bd4cf1b2524/lib/chef/knife/block.rb#L144-L154<CODESPLIT>ThreadSafe.AtomicReferenceCacheBackend.split_old_bin<CODESPLIT>list the available environments<CODESPLIT>def split_old_bin ( table , new_table , i , node , node_hash , forwarder ) table . try_lock_via_hash ( i , node , node_hash ) do split_bin ( new_table , i , node , node_hash ) table . volatile_set ( i , forwarder ) end end

0<CODESPLIT>https://github.com/jinx/core/blob/964a274cc9d7ab74613910e8375e12ed210a434d/lib/jinx/helpers/visitor.rb#L202-L206<CODESPLIT>Jinx.Visitor.filter<CODESPLIT>Returns the children to visit for the given node .<CODESPLIT>def filter raise ArgumentError . new ( "A filter block is not given to the visitor filter method" ) unless block_given? self . class . new ( @options ) { | node | yield ( node , node_children ( node ) ) } end

1<CODESPLIT>https://github.com/rails/rails/blob/85a8bc644be69908f05740a5886ec19cd3679df5/activesupport/lib/active_support/xml_mini/rexml.rb#L20-L38<CODESPLIT>ActiveSupport.XmlMini_REXML.parse<CODESPLIT>Parse an XML Document string or IO into a simple hash .<CODESPLIT>def parse ( data ) if ! data . respond_to? ( :read ) data = StringIO . new ( data || "" ) end if data . eof? { } else silence_warnings { require "rexml/document" } unless defined? ( REXML :: Document ) doc = REXML :: Document . new ( data ) if doc . root merge_element! ( { } , doc . root , XmlMini . depth ) else raise REXML :: ParseException , "The document #{doc.to_s.inspect} does not have a valid root" end end end

0<CODESPLIT>https://github.com/cxn03651/writeexcel/blob/d0345067c21b14a7141ba66b6752be8f4be379de/lib/writeexcel/worksheet.rb#L5435-L5449<CODESPLIT>Writeexcel.Worksheet.write_row_default<CODESPLIT>Determine if the link contains a sheet reference and change some of the parameters accordingly . Split the dir name and sheet name ( if it exists )<CODESPLIT>def write_row_default ( row , colMic , colMac ) #:nodoc: record = 0x0208 # Record identifier length = 0x0010 # Number of bytes to follow miyRw = 0xFF # Row height irwMac = 0x0000 # Used by Excel to optimise loading reserved = 0x0000 # Reserved grbit = 0x0100 # Option flags ixfe = 0x0F # XF index store_simple ( record , length , row , colMic , colMac , miyRw , irwMac , reserved , grbit , ixfe ) end

1<CODESPLIT>https://github.com/HewlettPackard/ilo-sdk-ruby/blob/ac171cd75d070ccf64017d43777ded40a5f018f9/lib/ilo-sdk/helpers/bios_helper.rb#L28-L32<CODESPLIT>ILO_SDK.BiosHelper.set_bios_settings<CODESPLIT>Set BIOS settings<CODESPLIT>def set_bios_settings ( options , system_id = 1 ) r = response_handler ( rest_patch ( "/redfish/v1/Systems/#{system_id}/bios/Settings/" , body : options ) ) @logger . warn ( r ) if r [ 'error' ] true end

1<CODESPLIT>https://github.com/sosedoff/goodreads/blob/aa571069ab07190c93b8a8aff77e1da2c79ab694/lib/goodreads/client/reviews.rb#L18-L21<CODESPLIT>Goodreads.Reviews.review<CODESPLIT>Get review details<CODESPLIT>def review ( id ) data = request ( "/review/show" , id : id ) Hashie :: Mash . new ( data [ "review" ] ) end

1<CODESPLIT>https://github.com/toshia/pluggaloid/blob/9b343833ac5d3dc0ec80d0395974b01d6f259233/lib/pluggaloid/plugin.rb#L206-L213<CODESPLIT>Pluggaloid.Plugin.uninstall<CODESPLIT> ==== Return self<CODESPLIT>def uninstall vm . Event [ :unload ] . call ( self . name ) vm . Delayer . new do @events . map ( :detach ) @filters . map ( :detach ) self . class . destroy name end self end

1<CODESPLIT>https://github.com/SciRuby/daru/blob/d17887e279c27e2b2ec7a252627c04b4b03c0a7a/lib/daru/index/index.rb#L145-L153<CODESPLIT>Daru.Index.at<CODESPLIT>Takes positional values and returns subset of the self capturing the indexes at mentioned positions<CODESPLIT>def at * positions positions = preprocess_positions ( positions ) validate_positions ( positions ) if positions . is_a? Integer key ( positions ) else self . class . new positions . map ( method ( :key ) ) end end

1<CODESPLIT>https://github.com/m-31/vcenter_lib/blob/28ed325c73a1faaa5347919006d5a63c1bef6588/lib/vcenter_lib/vcenter.rb#L21-L32<CODESPLIT>VcenterLib.Vcenter.vms<CODESPLIT>get all vms in all datacenters<CODESPLIT>def vms logger . debug "get all VMs in all datacenters: begin" result = dcs . inject ( [ ] ) do | r , dc | r + serviceContent . viewManager . CreateContainerView ( container : dc . vmFolder , type : [ 'VirtualMachine' ] , recursive : true ) . view end logger . debug "get all VMs in all datacenters: end" result end

0<CODESPLIT>https://github.com/pjb3/curtain/blob/ab4f3dccea9b887148689084137f1375278f2dcf/lib/curtain/rendering.rb#L30-L53<CODESPLIT>HueBridge.Color.to_h<CODESPLIT>Renders the template<CODESPLIT>def to_h hash = { } [ :bri , :hue , :sat ] . each do | attr | value = send ( attr ) hash [ attr ] = value if value end hash end

1<CODESPLIT>https://github.com/rightscale/right_agent/blob/64c68c162692f0a70543d10def5e4bf56505bd82/lib/right_agent/sender.rb#L630-L671<CODESPLIT>RightScale.Sender.http_send_once<CODESPLIT>Send request via HTTP and then immediately handle response<CODESPLIT>def http_send_once ( kind , target , packet , received_at , & callback ) begin method = packet . class . name . split ( "::" ) . last . downcase options = { :request_uuid => packet . token } options [ :time_to_live ] = ( packet . expires_at - Time . now . to_i ) if packet . expires_at > 0 result = success_result ( @agent . client . send ( method , packet . type , packet . payload , target , options ) ) rescue Exceptions :: Unauthorized => e result = error_result ( e . message ) rescue Exceptions :: ConnectivityFailure => e if queueing? @offline_handler . queue_request ( kind , packet . type , packet . payload , target , packet . token , packet . expires_at , packet . skewed_by , callback ) result = nil else result = retry_result ( e . message ) end rescue Exceptions :: RetryableError => e result = retry_result ( e . message ) rescue Exceptions :: InternalServerError => e result = error_result ( "#{e.server} internal error" ) rescue Exceptions :: Terminating => e result = nil rescue StandardError => e # These errors are either unexpected errors or HttpExceptions with an http_body # giving details about the error that are conveyed in the error_result if e . respond_to? ( :http_body ) # No need to log here since any HTTP request errors have already been logged result = error_result ( e . inspect ) else agent_type = AgentIdentity . parse ( @identity ) . agent_type ErrorTracker . log ( self , "Failed to send #{packet.trace} #{packet.type}" , e ) result = error_result ( "#{agent_type.capitalize} agent internal error" ) end end if result && packet . is_a? ( Request ) result = Result . new ( packet . token , @identity , result , from = packet . target ) result . received_at = received_at . to_f @pending_requests [ packet . token ] = PendingRequest . new ( kind , received_at , callback ) if callback handle_response ( result ) end true end

1<CODESPLIT>https://github.com/davetron5000/methadone/blob/2e670ac24cee3ab8658a1de62a70ff58e7806dc5/lib/methadone/main.rb#L295-L310<CODESPLIT>Methadone.Main.version<CODESPLIT>Set the version of your app so it appears in the banner . This also adds -- version as an option to your app which when used will act just like -- help ( see version_options to control this )<CODESPLIT>def version ( version , version_options = { } ) opts . version ( version ) if version_options . kind_of? ( String ) version_options = { :custom_docs => version_options } end version_options [ :custom_docs ] ||= "Show help/version info" version_options [ :format ] ||= "%s version %s" opts . on ( "--version" , version_options [ :custom_docs ] ) do if version_options [ :compact ] puts version_options [ :format ] % [ :: File . basename ( $0 ) , version ] else puts opts . to_s end exit 0 end end

1<CODESPLIT>https://github.com/propublica/daybreak/blob/b963a911fb68c294f02d0502570915cfb6b8a58d/lib/daybreak/journal.rb#L196-L203<CODESPLIT>Daybreak.Journal.with_tmpfile<CODESPLIT>Open temporary file and pass it to the block<CODESPLIT>def with_tmpfile path = [ @file , $$ . to_s ( 36 ) , Thread . current . object_id . to_s ( 36 ) ] . join file = File . open ( path , 'wb' ) yield ( path , file ) ensure file . close unless file . closed? File . unlink ( path ) if File . exists? ( path ) end

0<CODESPLIT>https://github.com/stitchfix/merch_calendar/blob/b24f1f47685928eeec8e808838e2474ddf473afd/lib/merch_calendar/util.rb#L60-L63<CODESPLIT>Starter.BaseFile.add_to_base<CODESPLIT>The end date of the month<CODESPLIT>def add_to_base ( file ) occurence = file . scan ( / \s \s \n / ) . last . first replacement = occurence + mount_point file . sub! ( occurence , replacement ) end

0<CODESPLIT>https://github.com/kontena/kontena/blob/5cb5b4457895985231ac88e78c8cbc5a8ffb5ec7/cli/lib/kontena/client.rb#L243-L245<CODESPLIT>Kontena.Client.post<CODESPLIT>Delete request<CODESPLIT>def post ( path , obj , params = { } , headers = { } , auth = true ) request ( http_method : :post , path : path , body : obj , query : params , headers : headers , auth : auth ) end

1<CODESPLIT>https://github.com/zhimin/rwebspec/blob/aafccee2ba66d17d591d04210067035feaf2f892/lib/rwebspec-webdriver/driver.rb#L559-L566<CODESPLIT>RWebSpec.Driver.span_with_id<CODESPLIT>return the text of specific ( identified by attribute id ) span tag For page containing <span id = preferred_recorder > iTest2 / Watir Recorder< / span > span_with_id ( preferred_recorder ) # = > iTest2 / Watir Recorder<CODESPLIT>def span_with_id ( span_id , options = { } ) if options && options [ :index ] then elements = find_elements ( :id , span_id . to_s ) elements [ options [ :index ] . to_i - 1 ] . text else find_element ( :id , span_id . to_s ) . text end end

1<CODESPLIT>https://github.com/gregwebs/hamlet.rb/blob/3ed5548e0164fa0622841746f0898fda88cbae42/lib/hamlet/parser.rb#L173-L235<CODESPLIT>Hamlet.Parser.parse_text_block<CODESPLIT>This is fundamentally broken Can keep this for multi - lie html comment perhaps But don t lookahead on text otherwise<CODESPLIT>def parse_text_block ( text_indent = nil , from = nil ) empty_lines = 0 first_line = true embedded = nil case from when :from_tag first_line = true when :from_embedded embedded = true end close_bracket = false until @lines . empty? if @lines . first =~ / \A \s \s \Z / next_line @stacks . last << [ :newline ] empty_lines += 1 if text_indent else indent = get_indent ( @lines . first ) break if indent <= @indents . last if @lines . first =~ / \A \s / indent += 1 #$1.size if $1 close_bracket = true else close_bracket = false end if empty_lines > 0 @stacks . last << [ :slim , :interpolate , "\n" * empty_lines ] empty_lines = 0 end next_line # The text block lines must be at least indented # as deep as the first line. if text_indent && indent < text_indent # special case for a leading '>' being back 1 char unless first_line && close_bracket && ( text_indent - indent == 1 ) @line . lstrip! syntax_error! ( 'Unexpected text indentation' ) end end @line . slice! ( 0 , text_indent || indent ) unless embedded @line = $' if @line =~ / \A / # a code comment if @line =~ / \A \\ \Z / @line = $` + $1 end end @stacks . last << [ :newline ] if ! first_line && ! embedded @stacks . last << [ :slim , :interpolate , ( text_indent ? "\n" : '' ) + @line ] << [ :newline ] # The indentation of first line of the text block # determines the text base indentation. text_indent ||= indent first_line = false end end end

0<CODESPLIT>https://github.com/mintdigital/pyrite/blob/acba5d6b460e4262b29be522a0bde0c29ef14cb1/lib/pyrite/dsl.rb#L61-L70<CODESPLIT>Pyrite.Dsl.code_me<CODESPLIT>Wait for a specific element the page to load or an AJAX request to return<CODESPLIT>def code_me html = browser . get_html_source filename = "#{Rails.root.join('tmp')}/pyrite-#{Time.now.to_i}.html" code = File . open ( filename , 'w' ) { | f | f . write ( html ) } puts ` #{ code } ` end

1<CODESPLIT>https://github.com/ondra-m/ruby-spark/blob/d1b9787642fe582dee906de3c6bb9407ded27145/lib/spark/command_builder.rb#L130-L138<CODESPLIT>Spark.CommandBuilder.serialize_function_from_method<CODESPLIT>Serialize method as string<CODESPLIT>def serialize_function_from_method ( meth ) if pry? meth = Pry :: Method . new ( meth ) end { type : 'method' , name : meth . name , content : meth . source } rescue raise Spark :: SerializeError , 'Method can not be serialized. Use full path or Proc.' end

1<CODESPLIT>https://github.com/zhimin/rwebspec/blob/aafccee2ba66d17d591d04210067035feaf2f892/lib/rwebspec-watir/web_browser.rb#L446-L452<CODESPLIT>RWebSpec.WebBrowser.clear_radio_option<CODESPLIT>Clear a radio button Usage : click_radio_option ( country Australia )<CODESPLIT>def clear_radio_option ( radio_group , radio_option ) if Watir :: VERSION =~ / / then radio ( :name => radio_group , :value => radio_option ) . clear else radio ( :name , radio_group , radio_option ) . clear end end

0<CODESPLIT>https://github.com/boxgrinder/boxgrinder-build/blob/fa21c27451d23f281b41a3e32339d5d791d5f420/lib/boxgrinder-build/helpers/ec2-helper.rb#L110-L115<CODESPLIT>BoxGrinder.EC2Helper.wait_for_instance_death<CODESPLIT>EC2 queries<CODESPLIT>def wait_for_instance_death ( instance , opts = { } ) wait_for_instance_status ( :terminated , instance , opts ) if instance . exists? rescue AWS :: EC2 :: Errors :: InvalidInstanceID :: NotFound end

0<CODESPLIT>https://github.com/simukappu/activity_notification/blob/7f0f0ea8db1e69d7806f5b0685e226452714847a/lib/activity_notification/rails/routes.rb#L288-L292<CODESPLIT>ActionDispatch::Routing.Mapper.subscribed_by<CODESPLIT>Check whether action path is ignored by : except or : only options<CODESPLIT>def subscribed_by ( * resources ) options = create_options ( :subscriptions , resources . extract_options! , [ :new , :edit , :update ] ) resources . each do | target | options [ :defaults ] = { target_type : target . to_s } . merge ( options [ :devise_defaults ] ) resources_options = options . select { | key , _ | [ :with_devise , :devise_default_routes , :model , :devise_defaults ] . exclude? key } if options [ :with_devise ] . present? && options [ :devise_default_routes ] . present? create_subscription_routes options , resources_options else self . resources target , only : :none do create_subscription_routes options , resources_options end end end self end

1<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_resources_management/lib/2018-03-01-preview/generated/azure_mgmt_resources_management/management_groups_api.rb#L140-L143<CODESPLIT>Azure::ResourcesManagement::Mgmt::V2018_03_01_preview.ManagementGroupsAPI.check_name_availability<CODESPLIT>Checks if the specified management group name is valid and unique<CODESPLIT>def check_name_availability ( check_name_availability_request , custom_headers : nil ) response = check_name_availability_async ( check_name_availability_request , custom_headers :custom_headers ) . value! response . body unless response . nil? end

1<CODESPLIT>https://github.com/raygao/asf-soap-adapter/blob/ab96dc48d60a6410d620cafe68ae7add012dc9d4/lib/salesforce/chatter_feed.rb#L97-L209<CODESPLIT>Salesforce.ChatterFeed.get_all_chatter_feeds_with_attachments<CODESPLIT>1 . It returns the attached file . 2 . <b > object_id < / b > corresponds to the parent_id column in the XXXFeed table 3 . <b > object_type < / b > can be one of the followings Account Asset Campaign Case Lead Contact Contract Opportunity Product2 Solution User ** Note ** : UserProfileFeed and NewsFeed are special cases . UserProfileFeed - > select ... from UserProfileFeed with Userid = userid NewsFeed - > select ... from NewsFeed where parentid = userid 4 . <b > binding < / b > can be passed in directly or using the inherited binding from the Salesforce :: SfBase base class . 5 . <b > directory_name< / b > is the directory in public / tmp for saving the attachment 6 . <b > limit< / b > is the number of records to return 7 . <b > get_attachment < / b > is a boolean flag true gets the attachment false does not get the attachment 8 . <b > query_string< / b > is used to search against the Salesforce . Note if object_id is specified query_string is ignored . 8 . returns Ruby Array of matching records 9 . TODO add conditions e . g . search - > where FeedPost . CreatedDate > 2007 - 08 - 06T03 : 23 : 00 . 000Z and FeedPost . Body like %post% pagination - ><CODESPLIT>def get_all_chatter_feeds_with_attachments ( object_id , object_type , binding , directory_name , limit = 100 , get_attachment = true , query_string = nil ) begin #e.g. select Id, type, FeedPost.body from UserProfileFeed WITH UserId = '005A0000000S8aIIAS' if ! object_id . nil? qstring = <<-HERE #{ BASE_FRAG } #{ FEEDPOST_WITHOUT_CONTENT_DATA_FRAG } #{ FEED_TRACKED_CHANGE_FRAG } #{ FEED_COMMENT_FRAG } #{ limit } #{ object_type } \' #{ object_id } \' #{ limit } HERE elsif ! query_string . nil? # this is more like a search.... qstring = <<-HERE #{ BASE_FRAG } #{ FEEDPOST_WITHOUT_CONTENT_DATA_FRAG } #{ FEED_TRACKED_CHANGE_FRAG } #{ FEED_COMMENT_FRAG } #{ limit } #{ object_type } \' #{ query_string } \' #{ limit } HERE else qstring = <<-HERE #{ BASE_FRAG } #{ FEEDPOST_WITHOUT_CONTENT_DATA_FRAG } #{ FEED_TRACKED_CHANGE_FRAG } #{ FEED_COMMENT_FRAG } #{ limit } #{ object_type } #{ limit } HERE end @logger . info ( 'qstring: ' + qstring ) # Note, if query FeedPost.ContentData, Salesforce only returns 1 entry at # a time, you will get a 'queryLocator', which can be used by calling # 'queryMore(queryLocator)' feed_results = Array . new results = binding . query ( :queryString => qstring ) if results . queryResponse . result . records . is_a? ( Hash ) # User has made only one feedpost feed = Hash . new feed = results . queryResponse . result . records if ( ! feed . FeedPost . nil? ) && ( feed . FeedPost . ContentSize . to_i > 0 ) feed = get_single_chatter_feed_with_attachment ( feed . FeedPost . Id , feed [ :type ] , binding , directory_name ) end feed_results << feed elsif results . queryResponse . result . records . is_a? ( Array ) results . queryResponse . result . records . each do | an_feed_entry | if ( an_feed_entry . is_a? ( Hash ) ) if ( an_feed_entry [ :Type ] == "TrackedChange" ) # This is a TrackedChange Feed, the FeedPost Body is nil feed = Hash . new feed = an_feed_entry feed_results << feed elsif ( ! an_feed_entry . FeedPost . nil? ) && ( an_feed_entry . FeedPost . ContentSize . to_i > 0 ) && ( get_attachment ) # This signifies that: #   1. results.queryResponse.result.records.FeedPost.Type is of "ContentPost" #   2. results.queryResponse.result.records.FeedPost.type should be of "FeedPost" an_entry_with_attachment = get_single_chatter_feed_with_attachment ( an_feed_entry . FeedPost . Id , an_feed_entry [ :type ] , binding , directory_name ) feed_results << an_entry_with_attachment else feed = Hash . new feed = an_feed_entry feed_results << feed end else @logger . info "Result #{object_id} has a results.queryResponse that is either not a valid Hash, or with nil FeedPost." end end end #if there are more entries, query it again and show it all while results . queryResponse . result . done . to_s . upcase != 'TRUE' results = binding . queryMore ( :queryString => results . queryResponse . result . queryLocator ) if results . queryResponse . result . records . is_a? ( Hash ) # User has made only one feedpost feed = Hash . new feed = results . queryResponse . result . records if ( ! feed . FeedPost . nil? ) && ( feed . FeedPost . ContentSize . to_i > 0 ) feed = get_single_chatter_feed_with_attachment ( feed . FeedPost . Id , feed [ :type ] , binding , directory_name ) end feed_results << feed elsif results . queryResponse . result . records . is_a? ( Array ) results . queryResponse . result . records . each do | an_feed_entry | if ( an_feed_entry . is_a? ( Hash ) ) if ( an_feed_entry [ :Type ] == "TrackedChange" ) # This is a TrackedChange Feed, the FeedPost Body is nil feed = Hash . new feed = an_feed_entry feed_results << feed # check to see if it has attachments elsif ( ! an_feed_entry . FeedPost . nil? ) && ( an_feed_entry . FeedPost . ContentSize . to_i > 0 ) && ( get_attachment ) # This signifies that: #   1. results.queryResponse.result.records.FeedPost.Type is of "ContentPost" #   2. results.queryResponse.result.records.FeedPost.type should be of "FeedPost" an_entry_with_attachment = get_single_chatter_feed_with_attachment ( an_feed_entry . FeedPost . Id , an_feed_entry [ :type ] , binding , directory_name ) feed_results << an_entry_with_attachment else feed = Hash . new feed = an_feed_entry feed_results << feed end else @logger . info "Result #{object_id} has a results.queryResponse that is either an invalid Hash or a nil FeedPost." end end end end return feed_results rescue Exception => exception @logger . info 'get_all_feed_posts_with_attachments: ' + exception . message return feed_results end end

1<CODESPLIT>https://github.com/nak1114/ariblib/blob/d9a85e7b37f4ebfced17ef0aaf6460f52cb19a2c/lib/ariblib/ProgramSpecificInformation.rb#L196-L228<CODESPLIT>Ariblib.NetworkInformationTable.parse_buf<CODESPLIT>< 1Kbyte<CODESPLIT>def parse_buf ret = [ ] bs = BitStream . new ( @buf ) table_id = bs . read 8 #uimsbf section_syntax_indicator = bs . read 1 #bslbf reserved_future_use = bs . read 1 #bslbf reserved = bs . read 2 #bslbf section_length = bs . read 12 #uimsbf network_id = bs . read 16 #uimsbf reserved = bs . read 2 #bslbf version_number = bs . read 5 #uimsbf current_next_indicator = bs . read 1 #bslbf section_number = bs . read 8 #uimsbf last_section_number = bs . read 8 #uimsbf reserved_future_use = bs . read 4 #bslbf network_descriptors_length = bs . read 12 #uimsbf desc = descriptor ( bs , network_descriptors_length ) ret << [ :NIT , table_id , desc ] reserved_future_use = bs . read 4 #bslbf transport_stream_loop_length = bs . read 12 #uimsbf len = bs . pos + transport_stream_loop_length 8 while bs . pos < len transport_stream_id = bs . read 16 #uimsbf original_network_id = bs . read 16 #uimsbf reserved_future_use = bs . read 4 #bslbf transport_descriptors_length = bs . read 12 #uimsbf desc = descriptor ( bs , transport_descriptors_length ) ret << [ transport_stream_id , original_network_id , desc ] end cCRC_32 = bs . read 32 #rpchof ret end

0<CODESPLIT>https://github.com/rightscale/right_agent/blob/64c68c162692f0a70543d10def5e4bf56505bd82/lib/right_agent/pending_requests.rb#L78-L85<CODESPLIT>RightScale.AgentDeployer.deploy<CODESPLIT>Create cache Store pending request<CODESPLIT>def deploy ( options ) # Initialize directory settings AgentConfig . root_dir = options [ :root_dir ] AgentConfig . cfg_dir = options [ :cfg_dir ] AgentConfig . pid_dir = options [ :pid_dir ] # Configure agent cfg = load_init_cfg check_agent ( options , cfg ) cfg = configure ( options , cfg ) # Persist configuration persist ( options , cfg ) # Setup agent monitoring monitor ( options ) if options [ :monit ] true end

0<CODESPLIT>https://github.com/WeAreFarmGeek/diplomat/blob/cb6d06dc4ec965c30bbaf22017fd0db64b9b7677/lib/diplomat/lock.rb#L12-L20<CODESPLIT>Diplomat.Lock.wait_to_acquire<CODESPLIT>Acquire a lock<CODESPLIT>def wait_to_acquire ( key , session , value = nil , check_interval = 10 , options = { } ) acquired = false until acquired acquired = acquire ( key , session , value , options ) sleep ( check_interval ) unless acquired return true if acquired end end

0<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_sql/lib/2017-03-01-preview/generated/azure_mgmt_sql/server_dns_aliases.rb#L361-L375<CODESPLIT>Azure::SQL::Mgmt::V2017_03_01_preview.ServerDnsAliases.acquire<CODESPLIT>@param resource_group_name [ String ] The name of the resource group that contains the resource . You can obtain this value from the Azure Resource Manager API or the portal . @param server_name [ String ] The name of the server that the alias is pointing to . @param dns_alias_name [ String ] The name of the server dns alias . @param parameters [ ServerDnsAliasAcquisition ] @param custom_headers [ Hash { String = > String } ] A hash of custom headers that will be added to the HTTP request .<CODESPLIT>def acquire ( resource_group_name , server_name , dns_alias_name , parameters , custom_headers : nil ) response = acquire_async ( resource_group_name , server_name , dns_alias_name , parameters , custom_headers :custom_headers ) . value! nil end

0<CODESPLIT>https://github.com/koffeinfrei/technologist/blob/0fd1d5c07c6d73ac5a184b26ad6db40981388573/lib/technologist/yaml_parser.rb#L33-L37<CODESPLIT>Conjugate.French.common_name<CODESPLIT>Create a class instance for a rule entry<CODESPLIT>def common_name ( t ) return nil unless t actual_tense = t . to_s . gsub ( ' ' , '_' ) . to_sym @changable_names ||= { :past => :passe_compose , :pass_compos =  : asse_compose}  actual_tense = @changable_names [ actual_tense ] || actual_tense actual_tense end

1<CODESPLIT>https://github.com/zverok/magic_cloud/blob/3c5d2dd19306c0fd557ba46556dc750931b3966f/lib/magic_cloud/cloud.rb#L57-L72<CODESPLIT>MagicCloud.Cloud.make_palette<CODESPLIT>rubocop : disable Metrics / MethodLength Metrics / CyclomaticComplexity Metrics / AbcSize<CODESPLIT>def make_palette ( source ) case source when :default make_const_palette ( :category20 ) when Symbol make_const_palette ( source ) when Array -> ( _ , index ) { source [ index % source . size ] } when Proc source when -> ( s ) { s . respond_to? ( :color ) } -> ( word , index ) { source . color ( word , index ) } else fail ArgumentError , "Unknown palette: #{source.inspect}" end end

0<CODESPLIT>https://github.com/rhomobile/rhodes/blob/3c5f87b1a44f0ba2865ca0e1dd780dd202f64872/res/build-tools/ruby-standalone/212/usr/local/lib/ruby/2.1.0/net/pop.rb#L452-L460<CODESPLIT>Net.POP3.start<CODESPLIT>: call - seq : Net :: POP#enable_ssl ( params = {} )<CODESPLIT>def start ( account , password ) # :yield: pop raise IOError , 'POP session already started' if @started if block_given? begin do_start account , password return yield ( self ) ensure do_finish end else do_start account , password return self end end

0<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_web/lib/2018-02-01/generated/azure_mgmt_web/app_service_environments.rb#L4402-L4404<CODESPLIT>Azure::Web::Mgmt::V2018_02_01.AppServiceEnvironments.begin_create_or_update_multi_role_pool<CODESPLIT>Move an App Service Environment to a different VNET .<CODESPLIT>def begin_create_or_update_multi_role_pool ( resource_group_name , name , multi_role_pool_envelope , custom_headers : nil ) response = begin_create_or_update_multi_role_pool_async ( resource_group_name , name , multi_role_pool_envelope , custom_headers :custom_headers ) . value! response . body unless response . nil? end

0<CODESPLIT>https://github.com/nico-hn/PseudoHikiParser/blob/d8c3d13be30409f094317ef81bd37c660dbc242d/lib/pseudohiki/htmlplugin.rb#L67-L73<CODESPLIT>Xhive.BaseTag.render<CODESPLIT>def inline lines = HtmlElement . decode (<CODESPLIT>def render ( context ) if ( errors = check_parameters ) . empty? process_parameters ( context ) route = Xhive :: Router :: Route . find ( rest_url ) render_inline? ( route , context ) ? render_inline ( route ) : render_widget_tag else errors end end

0<CODESPLIT>https://github.com/samvera/hyrax/blob/e2b4f56e829a53b1f11296324736e9d5b8c9ee5f/app/presenters/hyrax/displays_image.rb#L12-L27<CODESPLIT>Selectors.Dashboard.select_member_of_collection<CODESPLIT>Creates a display image only where FileSet is an image .<CODESPLIT>def select_member_of_collection ( collection ) find ( '#s2id_member_of_collection_ids' ) . click find ( '.select2-input' ) . set ( collection . title . first ) # Crude way of waiting for the AJAX response select2_results = [ ] time_elapsed = 0 while select2_results . empty? && time_elapsed < 30 begin_time = Time . now . to_f doc = Nokogiri :: XML . parse ( page . body ) select2_results = doc . xpath ( '//html:li[contains(@class,"select2-result")]' , html : 'http://www.w3.org/1999/xhtml' ) end_time = Time . now . to_f time_elapsed += end_time - begin_time end expect ( page ) . to have_css ( '.select2-result' ) within ".select2-result" do find ( "span" , text : collection . title . first ) . click end end

1<CODESPLIT>https://github.com/benmcredmond/OhEmbedr/blob/4c657a35ea7c7b1f23c22a3d6f9b118d4f8d04e6/lib/ohembedr.rb#L100-L118<CODESPLIT>OhEmbedr.OhEmbedr.gets<CODESPLIT>Calling + gets + returns a hash containing the oembed data .<CODESPLIT>def gets begin data = make_http_request @hash = send ( @@formats [ @format ] [ :oembed_parser ] , data ) # Call the method specified in default_formats hash above rescue RuntimeError => e if e . message == "401" # Embedding disabled return nil elsif e . message == "501" # Format not supported raise UnsupportedError , "#{@format} not supported by #{@domain}" elsif e . message == "404" # Not found raise Error , "#{@url} not found" else raise e end end end

1<CODESPLIT>https://github.com/sdalu/ruby-ble/blob/4c3b32d0ee65f787be235f1a5ee3878e6dcd995a/lib/ble/device.rb#L401-L417<CODESPLIT>BLE.Device.[]<CODESPLIT>Get value for a service / characteristic .<CODESPLIT>def [] ( service , characteristic , raw : false , async : false ) _require_connection! uuid = _uuid_characteristic ( characteristic ) chars = _characteristics ( service ) raise Service :: NotFound , service if chars . nil? char = chars [ uuid ] raise Characteristic :: NotFound , characteristic if char . nil? if char . flag? ( 'read' ) async ? char . async_read ( raw : raw ) : char . read ( raw : raw ) elsif char . flag? ( 'encrypt-read' ) || char . flag? ( 'encrypt-authenticated-read' ) raise NotYetImplemented else raise AccessUnavailable end end

0<CODESPLIT>https://github.com/chef/chef-zero/blob/5873d906942770a34f0cf0fed05973ec3240a275/lib/chef_zero/server.rb#L270-L280<CODESPLIT>ChefZero.Server.start<CODESPLIT>Start a Chef Zero server in a forked process . This method returns the PID to the forked process .<CODESPLIT>def start ( publish = true ) publish = publish [ :publish ] if publish . is_a? ( Hash ) # Legacy API if publish output = publish . respond_to? ( :puts ) ? publish : STDOUT output . puts <<-EOH . gsub ( / / , "" ) #{ ChefZero :: VERSION } EOH end thread = start_background if publish output = publish . respond_to? ( :puts ) ? publish : STDOUT output . puts <<-EOH . gsub ( / / , "" ) #{ WEBrick :: VERSION } #{ Rack . release } #{ url } EOH end %w{ INT TERM } . each do | signal | Signal . trap ( signal ) do puts "\n>> Stopping Chef Zero..." @server . shutdown end end # Move the background process to the main thread thread . join end

1<CODESPLIT>https://github.com/xuanxu/nimbus/blob/6646dbc00147408765044a99702005d3d30e052e/lib/nimbus/classification_tree.rb#L40-L64<CODESPLIT>Nimbus.ClassificationTree.build_node<CODESPLIT>Creates a node by taking a random sample of the SNPs and computing the loss function for every split by SNP of that sample .<CODESPLIT>def build_node ( individuals_ids , y_hat ) # General loss function value for the node individuals_count = individuals_ids . size return label_node ( y_hat , individuals_ids ) if individuals_count < @node_min_size node_loss_function = Nimbus :: LossFunctions . gini_index individuals_ids , @id_to_fenotype , @classes # Finding the SNP that minimizes loss function snps = snps_random_sample min_loss , min_SNP , split , split_type , ginis = node_loss_function , nil , nil , nil , nil snps . each do | snp | individuals_split_by_snp_value , node_split_type = split_by_snp_avegare_value individuals_ids , snp y_hat_0 = Nimbus :: LossFunctions . majority_class ( individuals_split_by_snp_value [ 0 ] , @id_to_fenotype , @classes ) y_hat_1 = Nimbus :: LossFunctions . majority_class ( individuals_split_by_snp_value [ 1 ] , @id_to_fenotype , @classes ) gini_0 = Nimbus :: LossFunctions . gini_index individuals_split_by_snp_value [ 0 ] , @id_to_fenotype , @classes gini_1 = Nimbus :: LossFunctions . gini_index individuals_split_by_snp_value [ 1 ] , @id_to_fenotype , @classes loss_snp = ( individuals_split_by_snp_value [ 0 ] . size * gini_0 + individuals_split_by_snp_value [ 1 ] . size * gini_1 ) / individuals_count min_loss , min_SNP , split , split_type , ginis = loss_snp , snp , individuals_split_by_snp_value , node_split_type , [ y_hat_0 , y_hat_1 ] if loss_snp < min_loss end return build_branch ( min_SNP , split , split_type , ginis , y_hat ) if min_loss < node_loss_function return label_node ( y_hat , individuals_ids ) end

1<CODESPLIT>https://github.com/rom-rb/rom/blob/7245b8cb6dadb5a9413606997a0294dd4a956f19/core/lib/rom/setup.rb#L49-L55<CODESPLIT>ROM.Setup.auto_registration<CODESPLIT>@api private Enable auto - registration for a given setup object<CODESPLIT>def auto_registration ( directory , options = { } ) auto_registration = AutoRegistration . new ( directory , options ) auto_registration . relations . map { | r | register_relation ( r ) } auto_registration . commands . map { | r | register_command ( r ) } auto_registration . mappers . map { | r | register_mapper ( r ) } self end

1<CODESPLIT>https://github.com/wilkosz/squash_matrix/blob/ce3d3e191004905d31fdc96e4439c6290141d8da/lib/squash_matrix/client.rb#L22-L35<CODESPLIT>SquashMatrix.Client.get_save_params<CODESPLIT>Returns params to create existing authenticated client<CODESPLIT>def get_save_params { player : @player , email : @email , password : @password , suppress_errors : @suppress_errors , timeout : @timeout , user_agent : @user_agent , cookie : get_cookie_string , expires : @expires . to_s , proxy_addr : @proxy_addr , proxy_port : @proxy_port } . delete_if { | _k , v | v . nil? } end

0<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_sql/lib/2017-03-01-preview/generated/azure_mgmt_sql/restore_points.rb#L163-L179<CODESPLIT>Azure::Advisor::Mgmt::V2017_03_31.Suppressions.delete_with_http_info<CODESPLIT>@param resource_group_name [ String ] The name of the resource group that contains the resource . You can obtain this value from the Azure Resource Manager API or the portal . @param server_name [ String ] The name of the server . @param database_name [ String ] The name of the database . @param parameters [ CreateDatabaseRestorePointDefinition ] The definition for creating the restore point of this database . @param custom_headers [ Hash { String = > String } ] A hash of custom headers that will be added to the HTTP request .<CODESPLIT>def delete_with_http_info ( resource_uri , recommendation_id , name , custom_headers : nil ) delete_async ( resource_uri , recommendation_id , name , custom_headers :custom_headers ) . value! end

0<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_recovery_services_site_recovery/lib/2016-08-10/generated/azure_mgmt_recovery_services_site_recovery/recovery_points.rb#L254-L257<CODESPLIT>Azure::RecoveryServicesSiteRecovery::Mgmt::V2016_08_10.RecoveryPoints.list_by_replication_protected_items_as_lazy<CODESPLIT>Get recovery points for a replication protected item .<CODESPLIT>def list_by_replication_protected_items_as_lazy ( fabric_name , protection_container_name , replicated_protected_item_name , custom_headers : nil ) response = list_by_replication_protected_items_async ( fabric_name , protection_container_name , replicated_protected_item_name , custom_headers :custom_headers ) . value! unless response . nil? page = response . body page . next_method = Proc . new do | next_page_link | list_by_replication_protected_items_next_async ( next_page_link , custom_headers :custom_headers ) end page end end

1<CODESPLIT>https://github.com/tongueroo/jets/blob/46943a519224067e58aa3e2d5656e3ca083150f9/lib/jets/router.rb#L18-L23<CODESPLIT>Jets.Router.check_collision!<CODESPLIT>Validate routes that deployable<CODESPLIT>def check_collision! paths = self . routes . map ( :path ) collision = Jets :: Resource :: ApiGateway :: RestApi :: Routes :: Collision . new collide = collision . collision? ( paths ) raise collision . exception if collide end

1<CODESPLIT>https://github.com/ronin-ruby/ronin/blob/10474c197f2c130f1e09975716955322a848b20a/lib/ronin/repository.rb#L550-L554<CODESPLIT>Ronin.Repository.find_script<CODESPLIT>Finds a cached script .<CODESPLIT>def find_script ( sub_path ) paths = @script_dirs . map { | dir | File . join ( dir , sub_path ) } return script_paths . first ( :path => paths ) end

1<CODESPLIT>https://github.com/maetl/calyx/blob/5011cd4b948792bdfd22ae1d3eaac9ff529e3861/lib/calyx/registry.rb#L106-L112<CODESPLIT>Calyx.Registry.transform<CODESPLIT>Applies the given modifier function to the given value to transform it .<CODESPLIT>def transform ( name , value ) if transforms . key? ( name ) transforms [ name ] . call ( value ) else modifiers . transform ( name , value ) end end

0<CODESPLIT>https://github.com/tclaus/keytechkit.gem/blob/caa7a6bee32b75ec18a4004179ae10cb69d148c2/lib/keytechKit/elements/element_handler.rb#L76-L83<CODESPLIT>KeytechKit.ElementHandler.whereused<CODESPLIT>Deletes an element with the key It returns the http response .<CODESPLIT>def whereused ( element_key , options = { } ) parameter = { query : options } parameter [ :basic_auth ] = @auth response = self . class . get ( "/elements/#{element_key}/whereused" , parameter ) if response . success? searchResponseHeader = SearchResponseHeader . new ( response ) return searchResponseHeader . elementList end end

0<CODESPLIT>https://github.com/mare-imbrium/canis/blob/8bce60ff9dad321e299a6124620deb4771740b0b/lib/canis/core/widgets/extras/rtextarea.rb#L812-L826<CODESPLIT>Canis.TextArea.move_chars_up<CODESPLIT>def to_s this was just annoying in debugs<CODESPLIT>def move_chars_up oldprow = @current_index oldcurpos = @curpos _maxlen = @maxlen || @width - @internal_width space_left = _maxlen - @buffer . length can_move = [ space_left , next_line . length ] . min carry_up = @list [ @current_index + 1 ] . slice! ( 0 , can_move ) @list [ @current_index ] << carry_up delete_line ( @current_index + 1 ) if next_line ( ) . length == 0 fire_handler :CHANGE , InputDataEvent . new ( oldcurpos , oldcurpos + can_move , self , :INSERT , oldprow , carry_up ) #  2008-12-24 18:34  end

1<CODESPLIT>https://github.com/gdeoliveira/mtrack/blob/a28b15457f99060855da97ca695e792fdbb39e84/lib/mtrack/state.rb#L84-L88<CODESPLIT>MTrack.State.tracked<CODESPLIT>call - seq : tracked ( group_name = nil ) = > set<CODESPLIT>def tracked ( group_name = nil ) ret_val = merge_super_states group_name ret_val . merge groups [ group_name ] . tracked unless groups [ group_name ] . nil? ret_val . subtract undefined end

1<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_compute/lib/2017-12-01/generated/azure_mgmt_compute/virtual_machine_scale_set_rolling_upgrades.rb#L78-L81<CODESPLIT>Azure::Compute::Mgmt::V2017_12_01.VirtualMachineScaleSetRollingUpgrades.start_osupgrade<CODESPLIT>Starts a rolling upgrade to move all virtual machine scale set instances to the latest available Platform Image OS version . Instances which are already running the latest available OS version are not affected .<CODESPLIT>def start_osupgrade ( resource_group_name , vm_scale_set_name , custom_headers : nil ) response = start_osupgrade_async ( resource_group_name , vm_scale_set_name , custom_headers :custom_headers ) . value! response . body unless response . nil? end

0<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_automation/lib/2015-10-31/generated/azure_mgmt_automation/runbook_operations.rb#L478-L481<CODESPLIT>Azure::Automation::Mgmt::V2015_10_31.RunbookOperations.update_with_http_info<CODESPLIT>Delete the runbook by name .<CODESPLIT>def update_with_http_info ( resource_group_name , automation_account_name , runbook_name , parameters , custom_headers : nil ) update_async ( resource_group_name , automation_account_name , runbook_name , parameters , custom_headers :custom_headers ) . value! end

1<CODESPLIT>https://github.com/mikamai/ruby-lol/blob/0833669a96e803ab34aa1576be5b3c274396dc9b/lib/lol/tournament_request.rb#L89-L92<CODESPLIT>Lol.TournamentRequest.all_lobby_events<CODESPLIT>Gets a list of lobby events by tournament code<CODESPLIT>def all_lobby_events tournament_code : result = perform_request api_url "lobby-events/by-code/#{tournament_code}" result [ "eventList" ] . map { | e | DynamicModel . new e } end

1<CODESPLIT>https://github.com/TwP/logging/blob/aa9a5b840479f4176504e4c53ce29d8d01315ccc/lib/logging/repository.rb#L180-L190<CODESPLIT>Logging.Repository.parent_name<CODESPLIT>Returns the name of the parent for the logger identified by the given _key_ . If the _key_ is for the root logger then + nil + is returned .<CODESPLIT>def parent_name ( key ) return if :root == key a = key . split PATH_DELIMITER p = :root while a . slice! ( - 1 ) and ! a . empty? k = a . join PATH_DELIMITER if @h . has_key? k then p = k ; break end end p end

0<CODESPLIT>https://github.com/square/connect-ruby-sdk/blob/798eb9ded716f23b9f1518386f1c311a34bca8bf/lib/square_connect/api/v1_employees_api.rb#L885-L888<CODESPLIT>SquareConnect.V1EmployeesApi.update_timecard<CODESPLIT>UpdateEmployeeRole Modifies the details of an employee role .<CODESPLIT>def update_timecard ( timecard_id , body , opts = { } ) data , _status_code , _headers = update_timecard_with_http_info ( timecard_id , body , opts ) return data end

0<CODESPLIT>https://github.com/rogerleite/restfolia/blob/27733fdf770482d99526be721a66b09f09a390f3/lib/restfolia/entry_point.rb#L62-L72<CODESPLIT>Restfolia.EntryPoint.post<CODESPLIT>Public : Creates an EntryPoint .<CODESPLIT>def post ( params ) body = read_body ( params ) args = self . configuration . merge ( :body => body ) http_resp = Restfolia :: HTTP :: Request . do_request ( :post , self . url , args ) Restfolia :: HTTP . response_by_status_code ( http_resp ) end

1<CODESPLIT>https://github.com/OTL/rosruby/blob/dc29af423241167ab9060b40366b4616a62c5f11/lib/ros/parameter_manager.rb#L99-L109<CODESPLIT>ROS.ParameterManager.has_param<CODESPLIT>check if the master has the key<CODESPLIT>def has_param ( key ) code , message , value = @server . call ( "hasParam" , @caller_id , key ) case code when 1 return value when - 1 raise message else return false end end

1<CODESPLIT>https://github.com/pandurang90/cloudconvert/blob/864c9a3d16750f9de2d600d1b9df80e079284f2d/lib/cloudconvert/conversion.rb#L60-L63<CODESPLIT>Cloudconvert.Conversion.converter_options<CODESPLIT>returns all possible conversions and options<CODESPLIT>def converter_options ( inputformat = "" , outputformat = "" ) response = @conversion_connection . get "conversiontypes" , { :inputformat => inputformat , :outputformat => outputformat } parse_response ( response . body ) end

0<CODESPLIT>https://github.com/Azure/azure-sdk-for-ruby/blob/78eedacf8f8cbd65c2d8a2af421405eaa4373d8e/management/azure_mgmt_resources/lib/2018-05-01/generated/azure_mgmt_resources/deployment_operations.rb#L130-L133<CODESPLIT>Azure::Resources::Mgmt::V2018_05_01.DeploymentOperations.list_at_subscription_scope_with_http_info<CODESPLIT>Gets all deployments operations for a deployment .<CODESPLIT>def list_at_subscription_scope_with_http_info ( deployment_name , top : nil , custom_headers : nil ) list_at_subscription_scope_async ( deployment_name , top : top , custom_headers :custom_headers ) . value! end

1<CODESPLIT>https://github.com/fulldecent/structured-acceptance-test/blob/9766f4863a8bcfdf6ac50a7aa36cce0314481118/implementations/ruby/lib/finding.rb#L92-L99<CODESPLIT>StatModule.Finding.categories=<CODESPLIT>Set array of categories<CODESPLIT>def categories = ( categories ) raise TypeException unless categories . is_a? ( Array ) categories . each { | item | raise TypeException unless Category . all . include? ( item ) raise DuplicateElementException if @categories . include? ( item ) @categories . push ( item ) } end

0<CODESPLIT>https://github.com/notEthan/jsi/blob/57483606e9d1996ce589e1797bd9948fa0684b88/lib/jsi/base.rb#L209-L221<CODESPLIT>JSI.Base.subscript_assign<CODESPLIT>assigns<CODESPLIT>def subscript_assign ( subscript , value ) clear_memo ( :[] , subscript ) if value . is_a? ( Base ) instance [ subscript ] = value . instance else instance [ subscript ] = value end end

1<CODESPLIT>https://github.com/lassebunk/dynamic_sitemaps/blob/37beeba143e8202218ee814056231b0e6974bafb/lib/dynamic_sitemaps/generator.rb#L5-L17<CODESPLIT>DynamicSitemaps.Generator.generate<CODESPLIT>Generates the sitemap ( s ) and index based on the configuration file specified in DynamicSitemaps . config_path . If you supply a block that block is evaluated instead of the configuration file .<CODESPLIT>def generate ( & block ) create_temp_dir if block instance_eval block else instance_eval open ( DynamicSitemaps . config_path ) . read , DynamicSitemaps . config_path end generate_index move_to_destination ping_search_engines ensure remove_temp_dir end

1<CODESPLIT>https://github.com/kpumuk/meta-tags/blob/03585f95edf96cd17024c5c155ce46ec8bc47232/lib/meta_tags/renderer.rb#L109-L112<CODESPLIT>MetaTags.Renderer.render_refresh<CODESPLIT>Renders refresh meta tag .<CODESPLIT>def render_refresh ( tags ) refresh = meta_tags . extract ( :refresh ) tags << Tag . new ( :meta , 'http-equiv' => 'refresh' , content : refresh . to_s ) if refresh . present? end

1<CODESPLIT>https://github.com/DigitPaint/html_mockup/blob/976edadc01216b82a8cea177f53fb32559eaf41e/lib/html_mockup/extractor.rb#L63-L71<CODESPLIT>HtmlMockup.Extractor.extract_source_from_file<CODESPLIT>Runs the extractor on a single file and return processed source .<CODESPLIT>def extract_source_from_file ( file_path , env = { } ) source = HtmlMockup :: Template . open ( file_path , :partials_path => self . project . partial_path , :layouts_path => self . project . layouts_path ) . render ( env . dup ) if @options [ :url_relativize ] source = relativize_urls ( source , file_path ) end source end

0<CODESPLIT>https://github.com/riddopic/garcun/blob/c2409bd8cf9c14b967a719810dab5269d69b42de/lib/garcon/core_ext/pathname.rb#L97-L101<CODESPLIT>Jinx.Inversible.add_to_inverse_collection<CODESPLIT>Expand a path with late - evaluated segments @see . path_to . Calls cleanpath ( removing // double slashes and useless .. s ) but does not reference the filesystem or make paths absolute .<CODESPLIT>def add_to_inverse_collection ( newval , accessors , inverse ) rdr , wtr = accessors # the current inverse oldval = send ( rdr ) # no-op if no change return newval if newval == oldval # delete self from the current inverse reference collection if oldval then coll = oldval . send ( inverse ) coll . delete ( self ) if coll end # call the writer on this object send ( wtr , newval ) # add self to the inverse collection if newval then coll = newval . send ( inverse ) if coll . nil? then coll = block_given? ? yield : Array . new newval . set_property_value ( inverse , coll ) end coll << self if oldval then logger . debug { "Moved #{qp} from #{rdr} #{oldval.qp} #{inverse} to #{newval.qp}." } else logger . debug { "Added #{qp} to #{rdr} #{newval.qp} #{inverse}." } end end newval end

