0<CODESPLIT>https://github.com/JedWatson/react-tappable/blob/c7a05f03f354c7556a413a6d270544629fd50ab7/dist/react-tappable.js#L6713-L6722<CODESPLIT>trapCapturedEvent<CODESPLIT>Traps top - level events by using event bubbling .<CODESPLIT>function trapCapturedEvent ( topLevelType , handlerBaseName , element ) { if ( ! element ) { return null ; } var dispatch = isInteractiveTopLevelEventType ( topLevelType ) ? dispatchInteractiveEvent : dispatchEvent ; addEventCaptureListener ( element , handlerBaseName , // Check if interactive and wrap in interactiveUpdates dispatch . bind ( null , topLevelType ) ) ; }

1<CODESPLIT>https://github.com/NEYouFan/nei-toolkit/blob/a2a8bfcfb3d6a4d685afcbcb275277c9e344e295/lib/fb-modules/util/mock_data.js#L225-L234<CODESPLIT><CODESPLIT>按类别和参数数组获取 mock 数据<CODESPLIT>function ( format , params , ds ) { this . ds = ds ; this . errorData = [ ] ; this . _sortParams ( params ) ; var result = this . _getMockByParams ( format , params ) ; return { json : result , error : this . errorData } ; }

0<CODESPLIT>https://github.com/JamieMason/shrinkpack/blob/c50981efa474123b5753a38cd14c35a798e529d9/src/analyse/prune-optional-dependencies.js#L11-L32<CODESPLIT>update<CODESPLIT>implementation<CODESPLIT>function update ( config ) { return when . join ( addUsedDependencies ( config ) , deleteUnusedDependencies ( config ) ) . then ( function ( ) { return rewriteGraph ( config ) ; } ) . then ( function ( ) { return config ; } ) ; }

0<CODESPLIT>https://github.com/joyent/kang/blob/9b138f2b4fb7873b9b0f271516daf36e20c9c037/examples/webconsole/resources/js/jquery/jquery.dataTables.js#L848-L884<CODESPLIT>_fnGetObjectDataFn<CODESPLIT>Return a function that can be used to set data from a source object taking into account the ability to use nested objects as a source<CODESPLIT>function _fnGetObjectDataFn ( mSource ) { if ( mSource === null ) { /* Give an empty string for rendering / sorting etc */ return function ( data , type ) { return null ; } ; } else if ( typeof mSource === 'function' ) { return function ( data , type ) { return mSource ( data , type ) ; } ; } else if ( typeof mSource === 'string' && mSource . indexOf ( '.' ) != - 1 ) { /* If there is a . in the source string then the data source is in a  				 * nested object so we loop over the data for each level to get the next 				 * level down. On each loop we test for undefined, and if found immediatly 				 * return. This allows entire objects to be missing and sDefaultContent to 				 * be used if defined, rather than throwing an error 				 */ var a = mSource . split ( '.' ) ; return function ( data , type ) { for ( var i = 0 , iLen = a . length ; i < iLen ; i ++ ) { data = data [ a [ i ] ] ; if ( data === undefined ) { return undefined ; } } return data ; } ; } else { /* Array or flat object mapping */ return function ( data , type ) { return data [ mSource ] ; } ; } }

0<CODESPLIT>https://github.com/warncke/immutable-core/blob/fd8f6c2194ee98b61c5e79b534fb5fb3f6f20d3d/mock/mock-cache-client.js#L15-L21<CODESPLIT>promiseReadFiles<CODESPLIT>@function MockCacheClient<CODESPLIT>function promiseReadFiles ( pattern ) { return glob ( pattern ) . then ( foundFiles => { const promisesToReadFiles = foundFiles . map ( fileName => pReadFile ( fileName ) ) ; return Promise . all ( promisesToReadFiles ) ; } ) . catch ( log . error ) ; }

0<CODESPLIT>https://github.com/multiplex/multiplex.js/blob/1e2f7df5726bdbbe6e8309066a03140ecbddb224/src/lib/collections/sorted-list.js#L254-L265<CODESPLIT><CODESPLIT>Gets the value associated with the specified key .<CODESPLIT>function ( docCtrl , renderer ) { View . call ( this ) ; // Rename docCtrl to surfaceCtrl ? this . docCtrl = docCtrl ; this . renderer = renderer ; this . document = docCtrl . session . document ; // Pull out the registered nodetypes on the written article this . nodeTypes = this . document . nodeTypes ; this . nodeViews = this . renderer . nodeViews ; this . $el . addClass ( 'surface' ) ; this . listenTo ( this . document , "property:updated" , this . onUpdateView ) ; this . listenTo ( this . document , "graph:reset" , this . reset ) ; // bind a DOM blur handler so that we can fire a node blur event this . $el . blur ( this . onBlur . bind ( this ) ) ; this . __lastFocussed = null ; }

1<CODESPLIT>https://github.com/moay/afterglow/blob/a7fbc889a18188147fcd8418c5d3bb801608b9a7/vendor/videojs/video.js#L23043-L23140<CODESPLIT>VTTRegion<CODESPLIT>VTTRegion shim http : // dev . w3 . org / html5 / webvtt / #vttregion - interface<CODESPLIT>function VTTRegion ( ) { var _width = 100 ; var _lines = 3 ; var _regionAnchorX = 0 ; var _regionAnchorY = 100 ; var _viewportAnchorX = 0 ; var _viewportAnchorY = 100 ; var _scroll = "" ; Object . defineProperties ( this , { "width" : { enumerable : true , get : function ( ) { return _width ; } , set : function ( value ) { if ( ! isValidPercentValue ( value ) ) { throw new Error ( "Width must be between 0 and 100." ) ; } _width = value ; } } , "lines" : { enumerable : true , get : function ( ) { return _lines ; } , set : function ( value ) { if ( typeof value !== "number" ) { throw new TypeError ( "Lines must be set to a number." ) ; } _lines = value ; } } , "regionAnchorY" : { enumerable : true , get : function ( ) { return _regionAnchorY ; } , set : function ( value ) { if ( ! isValidPercentValue ( value ) ) { throw new Error ( "RegionAnchorX must be between 0 and 100." ) ; } _regionAnchorY = value ; } } , "regionAnchorX" : { enumerable : true , get : function ( ) { return _regionAnchorX ; } , set : function ( value ) { if ( ! isValidPercentValue ( value ) ) { throw new Error ( "RegionAnchorY must be between 0 and 100." ) ; } _regionAnchorX = value ; } } , "viewportAnchorY" : { enumerable : true , get : function ( ) { return _viewportAnchorY ; } , set : function ( value ) { if ( ! isValidPercentValue ( value ) ) { throw new Error ( "ViewportAnchorY must be between 0 and 100." ) ; } _viewportAnchorY = value ; } } , "viewportAnchorX" : { enumerable : true , get : function ( ) { return _viewportAnchorX ; } , set : function ( value ) { if ( ! isValidPercentValue ( value ) ) { throw new Error ( "ViewportAnchorX must be between 0 and 100." ) ; } _viewportAnchorX = value ; } } , "scroll" : { enumerable : true , get : function ( ) { return _scroll ; } , set : function ( value ) { var setting = findScrollSetting ( value ) ; // Have to check for false as an empty string is a legal value. if ( setting === false ) { throw new SyntaxError ( "An invalid or illegal string was specified." ) ; } _scroll = setting ; } } } ) ; }

0<CODESPLIT>https://github.com/nayrnet/node-domoticz-mqtt/blob/14922c6470cc8eca073bd2d297f3b77ce285ac7d/domoticz.js#L14-L22<CODESPLIT>makePercent<CODESPLIT>Device IDX you want to watch . Get Options<CODESPLIT>function makePercent ( formatter ) { return function percentWrapped ( value ) { if ( value != null ) { return formatter ( value * 100 ) + '%' ; } return formatter ( value ) ; } ; }

0<CODESPLIT>https://github.com/zenparsing/moon-unit/blob/5fbe6805e3d382a0ce9e2913da65613ec33b19cb/build/moon-unit.js#L374-L382<CODESPLIT>getClass<CODESPLIT>Support for private fields<CODESPLIT>function getClass ( o ) { if ( o === null || o === undefined ) return "Object" ; return OP_toString . call ( o ) . slice ( "[object " . length , - 1 ) ; }

0<CODESPLIT>https://github.com/AlphaReplica/Connecta/blob/bc0ce3fa1ef5ef07526633da5668dcaff5ef29e0/lib/client/source/connecta.js#L28-L60<CODESPLIT>createPeerInstance<CODESPLIT>init acts as constructor<CODESPLIT>function createPeerInstance ( id ) { var peer = new ConnectaPeer ( id , stunUrls ) ; peer . onIceCandidate = gotIceCandidate ; peer . onDescription = createdDescription ; peer . onRemoteStream = gotRemoteStream ; peer . onConnected = onPeerConnected ; peer . onMessage = onPeerMessage ; peer . onBytesMessage = onBytesMessage ; peer . onConnectionFail = onPeerFailed ; peer . onClosed = onPeerClose ; peer . onError = onPeerError ; peer . onChannelState = onPeerState ; scope . peers [ id ] = peer ; peer . init ( ) ; return peer ; }

1<CODESPLIT>https://github.com/mikeal/node.couchapp.js/blob/e4ce61c342595148c37ad1ea1a88e7b53120c668/boiler/attachments/sammy/plugins/sammy.storage.js#L103-L114<CODESPLIT><CODESPLIT>Sets the value of key with value . If value is an object it is turned to and stored as a string with JSON . stringify . It also tries to conform to the KVO pattern triggering jQuery events on the element that the store is bound to . ### Example var store = new Sammy . Store ( { name : kvo } ) ; $ ( body ) . bind ( set - kvo - foo function ( e data ) { Sammy . log ( data . key + changed to + data . value ) ; } ) ; store . set ( foo bar ) ; // logged : foo changed to bar<CODESPLIT>function ( key , value ) { var string_value = ( typeof value == 'string' ) ? value : JSON . stringify ( value ) ; key = key . toString ( ) ; this . storage . set ( key , string_value ) ; if ( key != this . meta_key ) { this . _addKey ( key ) ; this . $element . trigger ( 'set-' + this . name , { key : key , value : value } ) ; this . $element . trigger ( 'set-' + this . name + '-' + key , { key : key , value : value } ) ; } ; // always return the original value return value ; }

0<CODESPLIT>https://github.com/bttmly/nba/blob/653a7199857a2e7ef96b44cf0262033349fa2354/src/util/string.js#L12-L19<CODESPLIT>addExtraTeamData<CODESPLIT>converts a dash or hypen separated string to camelCase<CODESPLIT>function addExtraTeamData ( team ) { team . teamName = team . teamName . trim ( ) ; const splitted = team . teamName . split ( " " ) ; if ( TWO_WORD_TEAMS [ team . teamName ] ) { team . simpleName = splitted . splice ( - 2 , 2 ) . join ( " " ) ; } else { team . simpleName = splitted . splice ( - 1 , 1 ) . join ( ) ; } team . location = splitted . join ( " " ) ; return team ; }

0<CODESPLIT>https://github.com/SAP/openui5/blob/8a832fca01cb1cdf8df589788e0c5723e2a33c70/src/sap.ui.core/src/sap/ui/model/odata/v4/lib/_AggregationHelper.js#L192-L225<CODESPLIT>processMinOrMax<CODESPLIT>/ * Returns the corresponding part of the aggregate term for an aggregatable property for example AggregatableProperty with method as Alias . Processes min / max as a side effect .<CODESPLIT>function processMinOrMax ( sName , sMinOrMax ) { var sAlias = "UI5" + sMinOrMax + "__" + sName ; aConcatAggregate . push ( sName + " with " + sMinOrMax + " as " + sAlias ) ; if ( mAlias2MeasureAndMethod ) { mAlias2MeasureAndMethod [ sAlias ] = { measure : sName , method : sMinOrMax } ; } }

1<CODESPLIT>https://github.com/ascartabelli/lamb/blob/d36e45945c4789e4f1a2d8805936514b53f32362/src/string/repeat.js#L23-L29<CODESPLIT>repeat<CODESPLIT>Builds a new string by repeating the source string the desired amount of times . <br / > Note that unlike the current ES6 proposal for [ String . prototype . repeat ] { @link https : // developer . mozilla . org / en - US / docs / Web / JavaScript / Reference / Global_Objects / String / repeat } this function doesn t throw a RangeError if <code > times< / code > is negative but returns an empty string instead . @example _ . repeat ( Hello - 1 ) // = > _ . repeat ( Hello 1 ) // = > Hello _ . repeat ( Hello 3 ) // = > HelloHelloHello<CODESPLIT>function repeat ( source , times ) { if ( isNil ( source ) ) { throw _makeTypeErrorFor ( source , "string" ) ; } return _repeat ( source , Math . floor ( times ) ) ; }

0<CODESPLIT>https://github.com/homerjam/angular-scroll-magic/blob/82b2a1d14497fa74d060be53b0e042f1c496351b/bower_components/gsap/src/uncompressed/plugins/KineticPlugin.js#L277-L310<CODESPLIT>deletePluginApiExcept<CODESPLIT>called each time the values should be updated and the ratio gets passed as the only parameter ( typically it s a value between 0 and 1 but it can exceed those when using an ease like Elastic . easeOut or Back . easeOut etc . )<CODESPLIT>function deletePluginApiExcept ( exceptionName , isJQueryGlobal ) { var globalApi = [ "documentWidth" , "documentHeight" , "windowWidth" , "windowHeight" , "scrollbarWidth" ] , fnApi = [ ] , removed = { global : { } , fn : { } } ; $ . each ( globalApi , function ( index , name ) { if ( ! isJQueryGlobal || exceptionName !== name ) { removed . global [ name ] = $ [ name ] ; delete $ [ name ] ; } } ) ; $ . each ( fnApi , function ( index , name ) { if ( isJQueryGlobal || exceptionName !== name ) { removed . fn [ name ] = $ . fn [ name ] ; delete $ . fn [ name ] ; } } ) ; return removed ; }

1<CODESPLIT>https://github.com/knownasilya/ember-leaflet-cartodb/blob/61d11c6268d59343746809639e0d23419674ae87/vendor/ember-leaflet-cartodb/cartodb_noleaflet.js#L25723-L25739<CODESPLIT><CODESPLIT>overwrite getTileUrl in order to support different tiles subdomains in tilejson way<CODESPLIT>function ( tilePoint ) { var EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" ; this . _adjustTilePoint ( tilePoint ) ; var tiles = [ EMPTY_GIF ] ; if ( this . tilejson ) { tiles = this . tilejson . tiles ; } var index = ( tilePoint . x + tilePoint . y ) % tiles . length ; return L . Util . template ( tiles [ index ] , L . Util . extend ( { z : this . _getZoomForUrl ( ) , x : tilePoint . x , y : tilePoint . y } , this . options ) ) ; }

1<CODESPLIT>https://github.com/darrencruse/sugarlisp-core/blob/c6ff983ebc3d60268054d6fe046db4aff6c5f78c/gentab-native.js#L528-L574<CODESPLIT>registerReactor<CODESPLIT>#react registers code that gets inserted by the transpiler after / before a call that changes one the observed cells .<CODESPLIT>function registerReactor ( forms ) { if ( forms . length != 5 ) { forms . error ( '#react expects: before/after, fnname, (observed cells), reactorcode' ) ; } // the word "before" or "after" var when = sl . valueOf ( forms [ 1 ] ) ; // a list of functions e.g. (set, ++, --) var cmds = forms [ 2 ] ; // a list of cells (arguments to the "cmds") var observed = forms [ 3 ] ; // code to inject when these cmds are invoked on these cells var reactorcode = this . transpileExpression ( forms [ 4 ] ) ; // THIS DEBUG STATEMENT IS DUMPING THE WHOLE FORMS NEED TO PRETTY IT UP TO JUST THE NAMES debug ( 'registering code to be run ' + when + ' one of "' + cmds + ' invoked on "' + observed + '"' ) ; // observed are the variables they need to declare as #cell // note: #cell is only done to encourage them to think of these //   variables as global to the file since we have no way to distinguish //   a reference to a variable in one scope from a variable with the same //   name in another (since we're a transpiler not an interpreter) var source = sl . lexerOf ( forms ) ; observed . forEach ( function ( cell ) { var arg = sl . valueOf ( cell ) ; if ( source . cells . indexOf ( arg ) === - 1 ) { console . log ( 'warning: reactor function observes "' + arg + '" but "' + arg + '" is not a cell' ) ; } } ) ; // we store for each "cmd" an array of objects of the form: //   { of: [observed1, ..., observedN], insert: form } // where "observed" are first args for cmd (e.g. "(set observedX val)"), and // insert is the (already generated) js code to insert before/after cmds . forEach ( function ( cmdAtom ) { var cmdName = sl . valueOf ( cmdAtom ) ; if ( ! source . bindingCode [ when ] [ cmdName ] ) { source . bindingCode [ when ] [ cmdName ] = [ ] ; } source . bindingCode [ when ] [ cmdName ] . push ( { of : observed , insert : reactorcode } ) ; } ) ; // we expand to nothing our only job is to register the // code that the main transpiler injects when appropriate this . noSemiColon = true ; return sl . generated ( ) ; }

0<CODESPLIT>https://github.com/bonesoul/node-hpool-web/blob/3d7749b2bcff8b59243939b5b3da19396c4878ff/public/js/plugins/iCheck/icheck.js#L39-L49<CODESPLIT>handleWarnings<CODESPLIT>Walker<CODESPLIT>function handleWarnings ( warnings ) { clearOutdatedErrors ( ) var isHotUpdate = ! isFirstCompilation isFirstCompilation = false hasCompileErrors = false function printWarnings ( ) { // Print warnings to the console. var formatted = formatWebpackMessages ( { warnings : warnings , errors : [ ] , } ) if ( typeof console !== 'undefined' && typeof console . warn === 'function' ) { for ( var i = 0 ; i < formatted . warnings . length ; i ++ ) { if ( i === 5 ) { console . warn ( 'There were more warnings in other files.\n' + 'You can find a complete log in the terminal.' ) break } console . warn ( stripAnsi ( formatted . warnings [ i ] ) ) } } } // Attempt to apply hot updates or reload. if ( isHotUpdate ) { tryApplyUpdates ( function onSuccessfulHotUpdate ( ) { // Only print warnings if we aren't refreshing the page. // Otherwise they'll disappear right away anyway. printWarnings ( ) // Only dismiss it when we're sure it's a hot update. // Otherwise it would flicker right before the reload. ErrorOverlay . dismissBuildError ( ) } ) } else { // Print initial warnings immediately. printWarnings ( ) } }

0<CODESPLIT>https://github.com/ariatemplates/ariatemplates/blob/7ed5d065818ae159bf361c9dfb209b1cf3883c90/src/aria/widgets/form/RadioButton.js#L234-L246<CODESPLIT><CODESPLIT>Sets the value property to the key value of this radio button and updates state dom etc . Typically called when user selects the radio button<CODESPLIT>function ( className ) { var loggingLevel = this . _loggingLevels [ className ] ; if ( ! ! loggingLevel ) { // If there is a logging level stored for the exact classname passed in parameter return loggingLevel ; } else { // Else, look for package names var str = className ; while ( str . indexOf ( "." ) != - 1 ) { str = str . substring ( 0 , str . lastIndexOf ( "." ) ) ; if ( this . _loggingLevels [ str ] ) { return this . _loggingLevels [ str ] ; } else if ( this . _loggingLevels [ str + ".*" ] ) { return this . _loggingLevels [ str + ".*" ] ; } } return this . _loggingLevels [ "*" ] || false ; } }

0<CODESPLIT>https://github.com/Tamersoul/magic-wand-js/blob/39d50ec17bfc060f2d360537a26a9420dd8970b6/jsfiddle/OpenLayers.debug.js#L39930-L39949<CODESPLIT><CODESPLIT>Method : clone Create a clone of this layer .<CODESPLIT>function ( ) { if ( this . strategies ) { var strategy , i , len ; for ( i = 0 , len = this . strategies . length ; i < len ; i ++ ) { strategy = this . strategies [ i ] ; if ( strategy . autoDestroy ) { strategy . destroy ( ) ; } } this . strategies = null ; } if ( this . protocol ) { if ( this . protocol . autoDestroy ) { this . protocol . destroy ( ) ; } this . protocol = null ; } this . destroyFeatures ( ) ; this . features = null ; this . selectedFeatures = null ; this . unrenderedFeatures = null ; if ( this . renderer ) { this . renderer . destroy ( ) ; } this . renderer = null ; this . geometryType = null ; this . drawn = null ; OpenLayers . Layer . prototype . destroy . apply ( this , arguments ) ; }

1<CODESPLIT>https://github.com/infusion/Complex.js/blob/7477f7b125dcd3a645b8ae4c818a14c1ed1c65b1/complex.js#L1023-L1038<CODESPLIT><CODESPLIT>Calculate the complex asinh<CODESPLIT>function ( ) { // acosh(c) = log(c + sqrt(c^2 - 1)) var res = this [ 'acos' ] ( ) ; if ( res [ 'im' ] <= 0 ) { var tmp = res [ 're' ] ; res [ 're' ] = - res [ 'im' ] ; res [ 'im' ] = tmp ; } else { var tmp = res [ 'im' ] ; res [ 'im' ] = - res [ 're' ] ; res [ 're' ] = tmp ; } return res ; }

0<CODESPLIT>https://github.com/angular/material/blob/84ac558674e73958be84312444c48d9f823f6684/src/core/services/gesture/gesture.js#L179-L186<CODESPLIT>addHandler<CODESPLIT>Register an element to listen for a handler . This allows an element to override the default options for a handler . Additionally some handlers like drag and hold only dispatch events if the domEvent happens inside an element that s registered to listen for these events .<CODESPLIT>function addHandler ( name , definition ) { var handler = new $$MdGestureHandler ( name ) ; angular . extend ( handler , definition ) ; HANDLERS [ name ] = handler ; return self ; }

0<CODESPLIT>https://github.com/kmi/node-red-contrib-noble/blob/9f30d0928df8e4b432891820c6ff97d4c18f49f4/noble/node-red-contrib-noble.js#L110-L130<CODESPLIT>query<CODESPLIT>Take care of stopping the scan and sending the status message<CODESPLIT>function query ( mode ) { var exercise = this function send ( stream ) { var input = through2 ( ) input . pipe ( stream ) . on ( 'error' , function ( err ) { exercise . emit ( 'fail' , exercise . __ ( 'fail.never_read_stdin' ) ) } ) input . write ( 'wow. such wow.' ) ; input . end ( ) ; } send ( exercise . submissionChild . stdin ) if ( mode == 'verify' ) send ( exercise . solutionChild . stdin ) }

1<CODESPLIT>https://github.com/ksmithut/confess/blob/937976ebfb52aa2cc9a5b337be28ee790ce9c403/lib/load-file.js#L18-L27<CODESPLIT>loadFile<CODESPLIT>Loads a file if it exists . If it doesn t then return the default object or empty object<CODESPLIT>function loadFile ( filepath , defaultObj ) { defaultObj = defaultObj || { } ; if ( ! isFile ( filepath ) ) { return defaultObj ; } var extension = path . extname ( filepath ) . replace ( / ^\. / , '' ) ; var contents = supportedExtensions [ extension ] ( filepath ) ; return assign ( { } , defaultObj , contents ) ; }

1<CODESPLIT>https://github.com/sealice/koa2-ueditor/blob/89fa1cc70f0375fafe023c88692fc27c83f2cd98/example/public/ueditor/third-party/highcharts/highcharts.src.js#L10356-L10433<CODESPLIT><CODESPLIT>Set up the overflow handling by adding navigation with up and down arrows below the legend .<CODESPLIT>function ( legendHeight ) { var legend = this , chart = this . chart , renderer = chart . renderer , pageCount , options = this . options , optionsY = options . y , alignTop = options . verticalAlign === 'top' , spaceHeight = chart . spacingBox . height + ( alignTop ? - optionsY : optionsY ) - this . padding , maxHeight = options . maxHeight , clipHeight , clipRect = this . clipRect , navOptions = options . navigation , animation = pick ( navOptions . animation , true ) , arrowSize = navOptions . arrowSize || 12 , nav = this . nav ; // Adjust the height if ( options . layout === 'horizontal' ) { spaceHeight /= 2 ; } if ( maxHeight ) { spaceHeight = mathMin ( spaceHeight , maxHeight ) ; } // Reset the legend height and adjust the clipping rectangle if ( legendHeight > spaceHeight && ! options . useHTML ) { this . clipHeight = clipHeight = spaceHeight - 20 - this . titleHeight ; this . pageCount = pageCount = mathCeil ( legendHeight / clipHeight ) ; this . currentPage = pick ( this . currentPage , 1 ) ; this . fullHeight = legendHeight ; // Only apply clipping if needed. Clipping causes blurred legend in PDF export (#1787) if ( ! clipRect ) { clipRect = legend . clipRect = renderer . clipRect ( 0 , 0 , 9999 , 0 ) ; legend . contentGroup . clip ( clipRect ) ; } clipRect . attr ( { height : clipHeight } ) ; // Add navigation elements if ( ! nav ) { this . nav = nav = renderer . g ( ) . attr ( { zIndex : 1 } ) . add ( this . group ) ; this . up = renderer . symbol ( 'triangle' , 0 , 0 , arrowSize , arrowSize ) . on ( 'click' , function ( ) { legend . scroll ( - 1 , animation ) ; } ) . add ( nav ) ; this . pager = renderer . text ( '' , 15 , 10 ) . css ( navOptions . style ) . add ( nav ) ; this . down = renderer . symbol ( 'triangle-down' , 0 , 0 , arrowSize , arrowSize ) . on ( 'click' , function ( ) { legend . scroll ( 1 , animation ) ; } ) . add ( nav ) ; } // Set initial position legend . scroll ( 0 ) ; legendHeight = spaceHeight ; } else if ( nav ) { clipRect . attr ( { height : chart . chartHeight } ) ; nav . hide ( ) ; this . scrollGroup . attr ( { translateY : 1 } ) ; this . clipHeight = 0 ; // #1379 } return legendHeight ; }

0<CODESPLIT>https://github.com/SignalK/sailgauge/blob/caa11797aab503905b63d0b865a20b3c4131b609/lib/signalkutils.js#L19-L37<CODESPLIT>Pass<CODESPLIT>/ * Walks directly down the hierarchy of a single SignalK message and if property name X is found in the array calls method handleX in the objectWithDispatchMethods<CODESPLIT>function Pass ( style , fields , opts , cb ) { Stream . call ( this ) // Get our own shallow copy of the fields this . fields = _ . extend ( { } , fields ) this . style = style this . opts = opts if ( ! this . fields [ style ] ) { this . fields [ style ] = { } } // Copy structure fields to style if ( this . fields . structure ) { this . fields [ style ] = this . fields . structure } // Structure no longer needed delete this . fields . structure // setup images and certs this . _setupImages ( ) this . _setupCerts ( opts . certs ) // Transform relevantData to ISO Date if its a Date instance if ( fields . relevantDate instanceof Date ) { fields . relavantDate = fields . relavantDate . toISOString ( ) } // Validate pass fields and generate this . validate ( ) this . cb = cb process . nextTick ( this . _generate . bind ( this ) ) }

1<CODESPLIT>https://github.com/PanthR/panthrMath/blob/54d249ca9903a9535f963da711bd3a87fb229c0b/panthrMath/distributions/finite.js#L112-L129<CODESPLIT><CODESPLIT>/ * eslint - disable complexity<CODESPLIT>function ( q , lowerTail , logp ) { var ind , ret ; logp = logp === true ; lowerTail = lowerTail !== false ; if ( utils . hasNaN ( q ) ) { return NaN ; } if ( q < xs [ 0 ] ) { ret = lowerTail ? 0 : 1 ; } else if ( q >= xs [ xs . length - 1 ] ) { ret = lowerTail ? 1 : 0 ; } else { ind = binSearch ( xs , function ( y ) { return y <= q ; } ) ; ret = lowerTail ? cumsLeft [ ind ] : cumsRight [ ind ] ; } ret = Math . min ( ret , 1 ) ; return logp ? Math . log ( ret ) : ret ; }

0<CODESPLIT>https://github.com/joyent/node-verror/blob/3b2d790a4bff5a15772576a8d1916b06f616e179/lib/verror.js#L51-L127<CODESPLIT>vhostof<CODESPLIT>/ * Common function used to parse constructor arguments for VError WError and SError . Named arguments to this function :<CODESPLIT>function vhostof ( req , regexp ) { var host = req . headers . host var hostname = hostnameof ( req ) if ( ! hostname ) { return } var match = regexp . exec ( hostname ) if ( ! match ) { return } var obj = Object . create ( null ) obj . host = host obj . hostname = hostname obj . length = match . length - 1 for ( var i = 1 ; i < match . length ; i ++ ) { obj [ i - 1 ] = match [ i ] } return obj }

1<CODESPLIT>https://github.com/cvisco/eslint-plugin-requirejs/blob/163abf4507ac2c282e1dd14a87f77707e79edb41/lib/rules/no-conditional-require.js#L41-L49<CODESPLIT>create<CODESPLIT>----------------------------------------------------------------------------- Rule Definition -----------------------------------------------------------------------------<CODESPLIT>function create ( context ) { return { CallExpression ( node ) { if ( isRequireCall ( node ) && ancestor ( isConditional , node ) ) { context . report ( node , message ) ; } } } ; }

1<CODESPLIT>https://github.com/codenautas/backend-plus/blob/c3d3c6ffa3c1db5fa29fc24a93f9fd5a14f8d0f0/lib/backend-plus.js#L118-L157<CODESPLIT><CODESPLIT>TODO : quitar no debería hacer falta poner esto acá<CODESPLIT>function ( tableItemOrString ) { var generatedDef ; /** @type {TableItem} */ var tableItem ; if ( typeof tableItemOrString === 'string' ) { tableItem = { name : tableItemOrString } ; } else { tableItem = tableItemOrString ; } if ( tableItem . mixin ) { generatedDef = be . tableMixin ( tableItem . mixin [ 0 ] , tableItem . mixin [ 1 ] , { name : tableItem . name , title : tableItem . title } ) ; } else if ( tableItem . tableGenerator ) { generatedDef = tableItem . tableGenerator ; } else { tableItem = changing ( { name : tableItem . name , fileName : tableItem . name } , tableItem ) ; tableItem = changing ( { source : ( tableItem . path || be . rootPath + '/server' ) + '/table-' + tableItem . fileName + '.js' } , tableItem ) ; if ( ! tableItem . source ) { throw new Error ( 'Need source for tableItem.name:' + tableItem . name ) ; } else { generatedDef = require ( tableItem . source ) ; if ( ! ( generatedDef instanceof Function ) ) { generatedDef = generatedDef [ tableItem . name ] ; var contextForDump = be . getContextForDump ( ) ; var tableDef = generatedDef ( contextForDump ) ; if ( ! tableDef . adapted ) { generatedDef = function ( generatedDef ) { /** @param {bp.Context} context  */ return function ( context ) { return be . tableDefAdapt ( generatedDef ( context ) , context ) ; } } ( generatedDef ) ; } } } } be . tableStructures [ tableItem . name ] = generatedDef ; }

0<CODESPLIT>https://github.com/rewgt/shadow-widget/blob/5baa1f563d647b6d1ecb6c108bc5bcef150ea683/lib/template.js#L11424-L11438<CODESPLIT>shadowWtcTagFlag_<CODESPLIT>failed<CODESPLIT>function shadowWtcTagFlag_ ( ) { if ( ! SHADOW_WTC_FLAGS_ ) { // not initialized yet SHADOW_WTC_FLAGS_ = { } ; SHADOW_WTC_ISPRE_ = { } ; scanOneLevel ( T , '' ) ; } return [ SHADOW_WTC_FLAGS_ , SHADOW_WTC_ISPRE_ ] ; function scanOneLevel ( aSet , sPath ) { Object . keys ( aSet ) . forEach ( function ( sKey ) { if ( ! sKey || sKey [ sKey . length - 1 ] == '_' ) return ; var value = aSet [ sKey ] ; if ( ( typeof value === 'undefined' ? 'undefined' : _typeof ( value ) ) != 'object' ) return ; if ( value . getDefaultProps ) { var props = value . getDefaultProps ( ) , iFlag = 1 ; if ( props [ 'childInline.' ] ) { if ( hasClass_ ( props . className || '' , 'rewgt-unit' ) ) iFlag = 2 ; else iFlag = 3 ; } // else iFlag = 1; // Panel(0) or Unit(1), take all of them as Unit if ( iFlag != 3 ) // no need regist Span(3), default is 3 SHADOW_WTC_FLAGS_ [ sPath + sKey ] = iFlag ; if ( props [ 'isPre.' ] ) SHADOW_WTC_ISPRE_ [ sPath + sKey ] = true ; } else scanOneLevel ( value , sPath + sKey + '.' ) ; // scan sub-level } ) ; } }

1<CODESPLIT>https://github.com/ArchimediaZerogroup/alchemy-custom-model/blob/1654c68c48dd0f760d46eac720f59fed75a32357/vendor/assets/elfinder_OLD/js/elfinder.full.js#L14163-L14172<CODESPLIT><CODESPLIT>fm . time ( cwdLoad ) ;<CODESPLIT>function ( hash ) { var l = buffer . length ; while ( l -- ) { if ( buffer [ l ] . hash == hash ) { return l ; } } return - 1 ; }

1<CODESPLIT>https://github.com/mattmccray/blam.js/blob/a535b6fe9679b687897ac0dc18b26585a5c3a114/bench/lib/benchmark.js#L371-L403<CODESPLIT>Benchmark<CODESPLIT>/ * -------------------------------------------------------------------------- The Benchmark constructor .<CODESPLIT>function Benchmark ( name , fn , options ) { var me = this ; // allow instance creation without the `new` operator if ( me == null || me . constructor != Benchmark ) { return new Benchmark ( name , fn , options ) ; } // juggle arguments if ( isClassOf ( name , 'Object' ) ) { // 1 argument (options) options = name ; } else if ( isClassOf ( name , 'Function' ) ) { // 2 arguments (fn, options) options = fn ; fn = name ; } else if ( isClassOf ( fn , 'Object' ) ) { // 2 arguments (name, options) options = fn ; fn = null ; me . name = name ; } else { // 3 arguments (name, fn [, options]) me . name = name ; } setOptions ( me , options ) ; me . id || ( me . id = ++ counter ) ; me . fn == null && ( me . fn = fn ) ; me . stats = deepClone ( me . stats ) ; me . times = deepClone ( me . times ) ; }

1<CODESPLIT>https://github.com/deftly/node-deftly/blob/0c34205fd6726356b69bcdd6dec4fcba55027af6/src/log.js#L90-L95<CODESPLIT>init<CODESPLIT>create a namespaced log instance for use in modules<CODESPLIT>function init ( state , namespace ) { namespace = namespace || 'deftly' const logger = { namespace : namespace } attach ( state , logger , namespace ) return logger }

1<CODESPLIT>https://github.com/SAP/openui5/blob/8a832fca01cb1cdf8df589788e0c5723e2a33c70/src/sap.ui.support/src/sap/ui/support/supportRules/ui/controllers/Analysis.controller.js#L996-L1007<CODESPLIT><CODESPLIT>Sets visibility to columns .<CODESPLIT>function ( aColumnsIds , bVisibilityValue ) { var aColumns = this . treeTable . getColumns ( ) ; aColumns . forEach ( function ( oColumn ) { oColumn . setVisible ( ! bVisibilityValue ) ; aColumnsIds . forEach ( function ( sRuleId ) { if ( oColumn . sId . includes ( sRuleId ) ) { oColumn . setVisible ( bVisibilityValue ) ; } } ) ; } ) ; }

0<CODESPLIT>https://github.com/nicktindall/cyclon.p2p-rtc-client/blob/eb586ce288a6ad7e1b221280825037e855b03904/lib/SocketIOSignallingService.js#L114-L122<CODESPLIT>postToFirstAvailableServer<CODESPLIT>Get the next pointer sequence number ( restoring from storage if it s present )<CODESPLIT>function postToFirstAvailableServer ( destinationNode , signallingServers , path , message ) { return new Promise ( function ( resolve , reject ) { if ( signallingServers . length === 0 ) { reject ( new Utils . UnreachableError ( createUnreachableErrorMessage ( destinationNode ) ) ) ; } else { //noinspection JSCheckFunctionSignatures httpRequestService . post ( url . resolve ( signallingServers [ 0 ] . signallingApiBase , path ) , message ) . then ( resolve ) . catch ( function ( error ) { logger . warn ( "An error occurred sending signalling message using " + signallingServers [ 0 ] . signallingApiBase + " trying next signalling server" , error ) ; postToFirstAvailableServer ( destinationNode , signallingServers . slice ( 1 ) , path , message ) . then ( resolve , reject ) ; } ) ; } } ) ; }

0<CODESPLIT>https://github.com/theboyWhoCriedWoolf/transition-manager/blob/a20fda0bb07c0098bf709ea03770b1ee2a855655/src/core/transitionViewManager.js#L128-L131<CODESPLIT>_fetchViews<CODESPLIT>convert view named references to either current view or next view if the ID s match Makes it easier to access and build generic use cases<CODESPLIT>function _fetchViews ( viewsToPrepare , actionDataClone , promises , viewCache ) { const views = viewsToPrepare , viewManager = _options . viewManager , length = views . length , currentViewID = actionDataClone . currentViewID , nextViewID = actionDataClone . nextViewID ; let i = 0 , _deferred , view , foundView , parsedRef , viewRef ; while ( i < length ) { viewRef = views [ i ] ; if ( viewRef ) { foundView = viewCache [ viewRef ] ; if ( ! foundView ) { // cache the view instance for reuse if needed foundView = viewCache [ viewRef ] = viewManager . fetchView ( viewRef ) ; _deferred = Deferred ( ) ; promises [ promises . length ] = _deferred . promise ; if ( ! foundView ) { return TVM . error ( viewRef + ' is undefined' ) ; } if ( foundView . prepareView ) { foundView . prepareView ( _deferred ) ; } else { _deferred . resolve ( ) ; } } view = foundView ; /* change ref to current view or next view to allow general transitions */ parsedRef = _viewRef ( viewRef , [ currentViewID , nextViewID ] ) ; if ( parsedRef ) { actionDataClone . views [ parsedRef ] = view ; } actionDataClone . views [ viewRef ] = view ; } ++ i ; } return actionDataClone ; }

1<CODESPLIT>https://github.com/vseryakov/backendjs/blob/7c7570a5343608912a47971f49340e2b28ce3935/lib/lib.js#L2536-L2538<CODESPLIT><CODESPLIT>month - 1<CODESPLIT>function ( t , utc , lang , tz ) { return zeropad ( utc ? t . getUTCMinutes ( ) : t . getMinutes ( ) ) }

1<CODESPLIT>https://github.com/architect/architect/blob/c5fd0b9b73ce57f2a34cf854ff8e49cc671468dd/src/deploy/lambda-one/_zip-impl.js#L19-L21<CODESPLIT>_read<CODESPLIT>get a handle on the files to zip<CODESPLIT>function _read ( callback ) { glob ( path . join ( process . cwd ( ) , pathToCode , '/*' ) , { dot : true } , callback ) }

0<CODESPLIT>https://github.com/ajaxorg/treehugger/blob/30a335ba99f0dd05f8532ce8aaa4903d5fcd2ab7/lib/acorn/dist/acorn.js#L2379-L2388<CODESPLIT>getOptions<CODESPLIT>Object type used to represent tokens . Note that normally tokens simply exist as properties on the parser object . This is only used for the onToken callback and the external tokenizer .<CODESPLIT>function getOptions ( opts ) { var options = { } ; for ( var opt in defaultOptions ) { options [ opt ] = opts && _util . has ( opts , opt ) ? opts [ opt ] : defaultOptions [ opt ] ; } if ( options . allowReserved == null ) options . allowReserved = options . ecmaVersion < 5 ; if ( _util . isArray ( options . onToken ) ) { ( function ( ) { var tokens = options . onToken ; options . onToken = function ( token ) { return tokens . push ( token ) ; } ; } ) ( ) ; } if ( _util . isArray ( options . onComment ) ) options . onComment = pushComment ( options , options . onComment ) ; return options ; }

1<CODESPLIT>https://github.com/tolokoban/ToloFrameWork/blob/730845a833a9660ebfdb60ad027ebaab5ac871b6/lib/boilerplate.view.js#L1536-L1558<CODESPLIT>outputClassBody<CODESPLIT>Class body .<CODESPLIT>function outputClassBody ( code ) { try { let out = '' ; if ( code . that ) out += "        const that = this;\n" ; if ( code . pm ) out += "        const pm = PM(this);\n" ; out += generate ( code . section . attribs . define , "Create attributes" , "        " ) ; out += generate ( code . section . elements . define , "Create elements" , "        " ) ; out += generate ( code . section . events , "Events" , "        " ) ; out += arrayToCodeWithNewLine ( code . generateLinks ( ) , "        " ) ; out += generate ( code . section . ons , "On attribute changed" , "        " ) ; out += generate ( code . section . elements . init , "Initialize elements" , "        " ) ; out += generate ( code . section . attribs . init , "Initialize attributes" , "        " ) ; if ( code . section . init ) { out += "        // Initialization.\n" ; out += ` ${ code . section . init } \n ` ; } out += "        $.addClass(this, 'view', 'custom');\n" ; return out ; } catch ( ex ) { bubble ( ex , "outputClassBody" ) ; return null ; } }

1<CODESPLIT>https://github.com/saggiyogesh/nodeportal/blob/cfd5b340f259d3a57c20892a1e2c95b133fe99ee/public/ckeditor/_source/plugins/styles/plugin.js#L1204-L1233<CODESPLIT>removeOverrides<CODESPLIT>Remove overriding styles / attributes from the specific element . Note : Remove the element if no attributes remain .<CODESPLIT>function removeOverrides ( element , overrides ) { var attributes = overrides && overrides . attributes ; if ( attributes ) { for ( var i = 0 ; i < attributes . length ; i ++ ) { var attName = attributes [ i ] [ 0 ] , actualAttrValue ; if ( ( actualAttrValue = element . getAttribute ( attName ) ) ) { var attValue = attributes [ i ] [ 1 ] ; // Remove the attribute if:  //    - The override definition value is null ;  //    - The override definition valie is a string that  //      matches the attribute value exactly.  //    - The override definition value is a regex that  //      has matches in the attribute value.  if ( attValue === null || ( attValue . test && attValue . test ( actualAttrValue ) ) || ( typeof attValue == 'string' && actualAttrValue == attValue ) ) element . removeAttribute ( attName ) ; } } } removeNoAttribsElement ( element ) ; }

0<CODESPLIT>https://github.com/angular/material/blob/84ac558674e73958be84312444c48d9f823f6684/src/components/panel/panel.js#L1359-L1456<CODESPLIT>MdPanelService<CODESPLIT>*************************************************************************** MdPanelRef * *************************************************************************** A reference to a created panel . This reference contains a unique id for the panel along with properties / functions used to control the panel .<CODESPLIT>function MdPanelService ( presets , $rootElement , $rootScope , $injector , $window ) { /**    * Default config options for the panel.    * Anything angular related needs to be done later. Therefore    *     scope: $rootScope.$new(true),    *     attachTo: $rootElement,    * are added later.    * @private {!Object}    */ this . _defaultConfigOptions = { bindToController : true , clickOutsideToClose : false , disableParentScroll : false , escapeToClose : false , focusOnOpen : true , fullscreen : false , hasBackdrop : false , propagateContainerEvents : false , transformTemplate : angular . bind ( this , this . _wrapTemplate ) , trapFocus : false , zIndex : MD_PANEL_Z_INDEX } ; /** @private {!Object} */ this . _config = { } ; /** @private {!Object} */ this . _presets = presets ; /** @private @const */ this . _$rootElement = $rootElement ; /** @private @const */ this . _$rootScope = $rootScope ; /** @private @const */ this . _$injector = $injector ; /** @private @const */ this . _$window = $window ; /** @private @const */ this . _$mdUtil = this . _$injector . get ( '$mdUtil' ) ; /** @private {!Object<string, !MdPanelRef>} */ this . _trackedPanels = { } ; /**    * @private {!Object<string,    *     {panels: !Array<!MdPanelRef>,    *     openPanels: !Array<!MdPanelRef>,    *     maxOpen: number}>}    */ this . _groups = Object . create ( null ) ; /**    * Default animations that can be used within the panel.    * @type {enum}    */ this . animation = MdPanelAnimation . animation ; /**    * Possible values of xPosition for positioning the panel relative to    * another element.    * @type {enum}    */ this . xPosition = MdPanelPosition . xPosition ; /**    * Possible values of yPosition for positioning the panel relative to    * another element.    * @type {enum}    */ this . yPosition = MdPanelPosition . yPosition ; /**    * Possible values for the interceptors that can be registered on a panel.    * @type {enum}    */ this . interceptorTypes = MdPanelRef . interceptorTypes ; /**    * Possible values for closing of a panel.    * @type {enum}    */ this . closeReasons = MdPanelRef . closeReasons ; /**    * Possible values of absolute position.    * @type {enum}    */ this . absPosition = MdPanelPosition . absPosition ; }

1<CODESPLIT>https://github.com/GoblinDBRocks/GoblinDB/blob/82e479396f49e5f2aa0b6bef0af91f1f187578ba/lib/database.js#L213-L252<CODESPLIT>deleteFn<CODESPLIT>Deletes the content stored where point indicates .<CODESPLIT>function deleteFn ( point ) { if ( point && typeof ( point ) === 'string' ) { const tree = point . split ( '.' ) ; let source = goblin . db ; return tree . every ( ( node , i ) => { if ( source [ node ] === undefined ) { logger ( 'DB_DELETE_INVALID_POINT' , node ) ; return false ; } if ( i === tree . length - 1 ) { let oldValue = source [ node ] ; if ( Array . isArray ( source ) ) { source . splice ( node , 1 ) ; return true ; } if ( delete source [ node ] ) { goblin . goblinDataEmitter . emit ( 'change' , { type : 'delete' , value : undefined , oldValue : oldValue } ) ; return true ; } else { return false ; } } source = source [ node ] ; return true ; } ) ; } logger ( 'DB_DELETE_MISSING_POINT' ) ; return false ; }

1<CODESPLIT>https://github.com/andrewplummer/Sugar/blob/4adba2e6ef8c8734a693af3141461dec6d674d50/gulpfile.js#L1844-L1864<CODESPLIT>addBuiltMethods<CODESPLIT>A build function may define methods which involve complex or optimized ways of defining sets of methods ( date units etc ) so instead of attempting to analyze the build function we are saying that any set methods must be defined in the comment block directly above the build method .<CODESPLIT>function addBuiltMethods ( ) { var opts = { } , type ; fnPackage . node . body . body . forEach ( function ( node ) { if ( isPrototypeBlock ( node ) ) { type = 'prototype' ; opts . target = node . expression . arguments [ 0 ] . name ; } if ( isMethodBlock ( node ) && hasStaticToken ( node . expression . callee . name ) ) { type = 'static' ; } } ) ; // If no special types were defined, then the // build function is simply defining instance types. if ( ! type ) { type = 'instance' ; } checkPackageForBuiltMethods ( fnPackage , type , opts ) ; }

1<CODESPLIT>https://github.com/adrai/node-cqrs-eventdenormalizer/blob/fd3411044e0673bd1b3613832599d6e85c456fea/lib/definitions/viewBuilder.js#L265-L410<CODESPLIT><CODESPLIT>Handles denormalization for 1 viewmodel .<CODESPLIT>function ( vm , evt , initValues , callback ) { var self = this ; if ( ! callback ) { callback = initValues ; initValues = null ; } var payload = evt ; if ( this . payload && this . payload !== '' ) { payload = dotty . get ( evt , this . payload ) ; } if ( initValues ) { vm . set ( _ . cloneDeep ( initValues ) ) ; } var evtId = dotty . get ( evt , this . definitions . event . id ) ; var debugOutPut = evtId ? ( ', [eventId]=' + evtId ) : '' ; debug ( '[' + this . name + ']' + debugOutPut + ' call denormalizer function' ) ; function retry ( retryIn ) { if ( self . collection . isReplaying ) { var debugMsg = '[' + self . name + ']' + debugOutPut + ' finishing denormalization because is replaying!' ; debug ( debugMsg ) ; console . log ( debugMsg ) ; return callback ( null ) ; } if ( _ . isNumber ( retryIn ) ) { retryIn = randomBetween ( 0 , retryIn ) ; } if ( _ . isObject ( retryIn ) && _ . isNumber ( retryIn . from ) && _ . isNumber ( retryIn . to ) ) { retryIn = randomBetween ( retryIn . from , retryIn . to ) ; } if ( ! _ . isNumber ( retryIn ) || retryIn === 0 ) { retryIn = randomBetween ( 0 , self . options . retryOnConcurrencyTimeout || 800 ) ; } debug ( '[' + self . name + ']' + debugOutPut + ' retry in ' + retryIn + 'ms' ) ; setTimeout ( function ( ) { self . loadViewModel ( vm . id , function ( err , vm ) { if ( err ) { debug ( err ) ; return callback ( err ) ; } self . handleOne ( vm , evt , initValues , callback ) ; } ) ; } , retryIn ) ; } var shouldBeHandled = function ( cb ) { // if (self.shouldHandleRequestsOnlyEvent) return cb(null, true); self . shouldHandle ( evt , vm , cb ) ; } ; shouldBeHandled ( function ( err , doHandle ) { if ( err ) { return callback ( err ) ; } if ( ! doHandle ) { return callback ( null , null ) ; } var denormThis = { retryCalled : false , retry : function ( ) { denormThis . retryCalled = true ; if ( arguments . length === 0 ) { return retry ( ) ; } if ( arguments . length === 1 ) { if ( ! _ . isFunction ( arguments [ 0 ] ) ) { return retry ( arguments [ 0 ] ) ; } return retry ( ) ; } retry ( arguments [ 0 ] ) ; } , toRemember : null , remindMe : function ( memories ) { denormThis . toRemember = memories ; } , getReminder : function ( memories ) { return denormThis . toRemember ; } } ; self . denormFn . call ( denormThis , _ . cloneDeep ( payload ) , vm , function ( err ) { if ( err ) { debug ( err ) ; return callback ( err ) ; } var notification = self . generateNotification ( evt , vm ) ; debug ( '[' + self . name + ']' + debugOutPut + ' generate new id for notification' ) ; self . getNewId ( function ( err , newId ) { if ( err ) { debug ( err ) ; return callback ( err ) ; } dotty . put ( notification , self . definitions . notification . id , newId ) ; self . saveViewModel ( vm , function ( err ) { if ( err ) { debug ( err ) ; if ( err instanceof ConcurrencyError ) { retry ( callback ) ; return ; } return callback ( err ) ; } if ( ! self . options . callOnAfterCommitDuringReplay && self . collection . isReplaying ) { return callback ( null , notification ) ; } self . handleAfterCommit . call ( denormThis , evt , vm , function ( err ) { if ( err ) { debug ( err ) ; return callback ( err ) ; } callback ( null , notification ) ; } ) ; } ) ; } ) ; } ) ; } ) ; }

0<CODESPLIT>https://github.com/EvilDevRu/node-redis-dump/blob/27f30b4c5a20f2a001e00d732d3c1d4ef67ddbad/lib/node-redis-dump.js#L320-L331<CODESPLIT><CODESPLIT>Check .<CODESPLIT>function ( key , data , callback ) { 'use strict' ; /** 	 * Read scores by values. 	 * 	 * @param {Array} values 	 * @param {Function} callback 	 */ var ReadScores = function ( values , callback ) { var result = [ ] ; /** 		 * Get scores recursive. 		 */ var GetRecursive = function ( ) { if ( ! values . length ) { callback ( null , result ) ; return ; } var value = values . pop ( ) ; this . getClient ( ) . zscore ( key , value , function ( err , score ) { if ( err ) { callback ( err ) ; return ; } result . push ( score ) ; GetRecursive ( ) ; } ) ; } . bind ( this ) ; GetRecursive ( ) ; } . bind ( this ) ; /** 	 * Read key. 	 * 	 * @param {String} key 	 * @param {String} type 	 * @param {Function} rkCallback 	 */ var ReadKey = function ( key , type , rkCallback ) { var params = [ key ] , command = { set : 'smembers' , zset : 'zrange' , list : 'lrange' , hash : 'hgetall' } [ type ] || 'get' ; if ( command . indexOf ( 'range' ) !== - 1 ) { params . push ( 0 ) ; params . push ( - 1 ) ; } params . push ( function ( err , values ) { if ( err ) { rkCallback ( err ) ; return ; } switch ( type ) { case 'zset' : ReadScores ( _ . clone ( values ) . reverse ( ) , function ( err , scores ) { rkCallback ( null , _ . zip ( scores , values ) ) ; } ) ; break ; default : rkCallback ( null , values ) ; break ; } } ) ; this . getClient ( ) [ command ] . apply ( this . getClient ( ) , params ) ; } . bind ( this ) ; switch ( this . getExportParams ( ) . type ) { //	Export as redis type. case 'redis' : return function ( err , type ) { var type2PrintSetCommand = { string : 'SET' , set : 'SADD' , zset : 'ZADD' , list : 'RPUSH' , hash : 'HSET' } ; if ( ! data ) { data = '' ; } ReadKey ( key , type , function ( err , value ) { if ( err ) { callback ( err ) ; return ; } var command = type2PrintSetCommand [ type ] ; key = key . trim ( ) ; switch ( type ) { case 'set' : _ . each ( value , function ( item ) { data += command + ' "' + key + '" "' + item + "\"\n" ; } ) ; break ; case 'zset' : _ . each ( value , function ( item ) { data += command + ' "' + key + '" ' + item [ 0 ] + ' "' + item [ 1 ] + "\"\n" ; } ) ; break ; case 'hash' : _ . each ( _ . pairs ( value ) , function ( item ) { data += command + ' "' + key + '" "' + item [ 0 ] + '" "' + item [ 1 ] + "\"\n" ; } ) ; break ; default : data += command + ' "' + key + '" "' + value + "\"\n" ; break ; } callback ( null , data ) ; } ) ; } ; //	Export as json type. case 'json' : return function ( err , type ) { if ( ! data ) { data = { } ; } ReadKey ( key , type , function ( err , value ) { if ( err ) { callback ( err ) ; return ; } switch ( type ) { case 'zset' : var withoutScores = [ ] ; _ . each ( value , function ( item ) { withoutScores . push ( item [ 1 ] ) ; } ) ; value = withoutScores ; break ; } data [ key . trim ( ) ] = value ; callback ( null , data ) ; } ) ; } ; } }

0<CODESPLIT>https://github.com/skerit/alchemy-styleboost/blob/2b90b8a6afc9f065f785651292fb193940021d90/public/ckeditor/4.4dev/plugins/filebrowser/plugin.js#L177-L191<CODESPLIT>browseServer<CODESPLIT>The onlick function assigned to the Upload button . Makes the final decision whether form is really submitted and updates target field when file is uploaded .<CODESPLIT>function browseServer ( evt ) { var dialog = this . getDialog ( ) ; var editor = dialog . getParentEditor ( ) ; editor . _ . filebrowserSe = this ; var width = editor . config [ 'filebrowser' + ucFirst ( dialog . getName ( ) ) + 'WindowWidth' ] || editor . config . filebrowserWindowWidth || '80%' ; var height = editor . config [ 'filebrowser' + ucFirst ( dialog . getName ( ) ) + 'WindowHeight' ] || editor . config . filebrowserWindowHeight || '70%' ; var params = this . filebrowser . params || { } ; params . CKEditor = editor . name ; params . CKEditorFuncNum = editor . _ . filebrowserFn ; if ( ! params . langCode ) params . langCode = editor . langCode ; var url = addQueryString ( this . filebrowser . url , params ) ; // TODO: V4: Remove backward compatibility (#8163).  editor . popup ( url , width , height , editor . config . filebrowserWindowFeatures || editor . config . fileBrowserWindowFeatures ) ; }

1<CODESPLIT>https://github.com/wronex/node-conquer/blob/48fa586d1fad15ad544d143d1ba4b97172fed0f1/bin/logger.js#L12-L23<CODESPLIT>write<CODESPLIT>Writes the supplied message to the log .<CODESPLIT>function write ( msg , color , prefix ) { if ( ! prefix ) prefix = clc . cyan ( '[conquer]' ) ; // Print each line of the message on its own line. var messages = msg . split ( '\n' ) ; for ( var i = 0 ; i < messages . length ; i ++ ) { var message = messages [ i ] . replace ( / (\s?$)|(\n?$) / gm , '' ) ; if ( message && message . length > 0 ) console . log ( prefix , color ? color ( message ) : message ) ; } }

1<CODESPLIT>https://github.com/roman01la/html-to-react-components/blob/74b76fafbd0728f77c2bbe32a0b26a94e604442b/lib/html2jsx.js#L495-L521<CODESPLIT><CODESPLIT>Handles pre - visit behaviour for the specified element node<CODESPLIT>function ( node ) { var tagName = jsxTagName ( node . tagName ) ; var attributes = [ ] ; for ( var i = 0 , count = node . attributes . length ; i < count ; i ++ ) { attributes . push ( this . _getElementAttribute ( node , node . attributes [ i ] ) ) ; } if ( tagName === 'textarea' ) { // Hax: textareas need their inner text moved to a "defaultValue" attribute. attributes . push ( 'defaultValue={' + JSON . stringify ( node . value ) + '}' ) ; } if ( tagName === 'style' ) { // Hax: style tag contents need to be dangerously set due to liberal curly brace usage attributes . push ( 'dangerouslySetInnerHTML={{__html: ' + JSON . stringify ( node . textContent ) + ' }}' ) ; } if ( tagName === 'pre' ) { this . _inPreTag = true ; } this . output += '<' + tagName ; if ( attributes . length > 0 ) { this . output += ' ' + attributes . join ( ' ' ) ; } if ( ! this . _isSelfClosing ( node ) ) { this . output += '>' ; } }

1<CODESPLIT>https://github.com/SAP/openui5/blob/8a832fca01cb1cdf8df589788e0c5723e2a33c70/src/sap.ui.dt/src/sap/ui/dt/ContextMenuControl.js#L471-L490<CODESPLIT><CODESPLIT>Gets the dimensions of the ContextMenu s popover<CODESPLIT>function ( bWithArrow ) { var oPopover = { } ; var bCompact = this . _bCompactMode ; var fArrowHeight = this . _getArrowHeight ( bCompact ) ; var iBaseFontsize = this . _getBaseFontSize ( ) ; this . _iFirstVisibleButtonIndex = null ; oPopover . height = parseInt ( jQuery ( "#" + this . getPopover ( ) . getId ( ) ) . css ( "height" ) ) || 40 ; oPopover . width = parseInt ( jQuery ( "#" + this . getPopover ( ) . getId ( ) ) . css ( "width" ) ) || 80 ; if ( bWithArrow ) { var iArr = iBaseFontsize * fArrowHeight ; if ( iArr ) { oPopover . height += iArr ; oPopover . width += iArr ; } } return oPopover ; }

0<CODESPLIT>https://github.com/senshu/Sozi-export/blob/870138ec5b3908a3ed9869406933d6e45193bd8a/lib/sozi-to-video.js#L32-L70<CODESPLIT>markFrames<CODESPLIT>/ * Sandboxed function<CODESPLIT>function markFrames ( list , expr , value ) { switch ( expr ) { case "all" : markInterval ( list , 0 , list . length - 1 , 1 , value ) ; break ; case "none" : break ; default : expr . split ( "," ) . forEach ( function ( intervalDef ) { var interval = intervalDef . split ( ":" ) . map ( function ( s ) { return s . trim ( ) ; } ) ; if ( interval . length > 0 ) { var first = interval [ 0 ] !== "" ? parseInt ( interval [ 0 ] ) - 1 : 0 ; var last = interval [ interval . length - 1 ] !== "" ? parseInt ( interval [ interval . length - 1 ] ) - 1 : list . length - 1 ; var second = interval . length > 2 && interval [ 1 ] !== "" ? parseInt ( interval [ 1 ] ) - 1 : first + 1 ; if ( ! isNaN ( first ) && ! isNaN ( second ) && ! isNaN ( last ) ) { markInterval ( list , first , last , second - first , value ) ; } } } ) ; } }

0<CODESPLIT>https://github.com/redisjs/jsr-store/blob/b2b5c5b0347819f8a388b5d67e121ee8d73f328c/lib/command/set.js#L63-L71<CODESPLIT>sismember<CODESPLIT>Removes and returns a random element from the set value stored at key .<CODESPLIT>function sismember ( key , member , req ) { var val = this . getKey ( key , req ) ; if ( val === undefined ) return 0 ; return val . sismember ( member ) ; }

0<CODESPLIT>https://github.com/hex7c0/transfer-rate/blob/7c12564883126fd711813e45c30687c2c5179419/index.js#L21-L157<CODESPLIT>Rc4a<CODESPLIT>/ * functions starting point<CODESPLIT>function Rc4a ( key ) { this . key = null ; this . derivatedKey = null ; this . ksa = null ; this . prga = null ; this . change ( key ) ; }

1<CODESPLIT>https://github.com/BranchMetrics/cordova-ionic-phonegap-branch-deep-linking/blob/252f591fcc833ac9fe7fb0f535d351e0879a873c/examples/phonegap1/plugins/cordova-plugin-globalization/src/blackberry10/index.js#L44-L60<CODESPLIT><CODESPLIT>Returns the string identifier for the client s current language . It returns the language identifier string to the successCB callback with a properties object as a parameter . If there is an error getting the language then the errorCB callback is invoked .<CODESPLIT>function ( successCB , failureCB , args , env ) { var result = new PluginResult ( args , env ) ; var response = g11n . getInstance ( ) . InvokeMethod ( 'getPreferredLanguage' , args ) ; var data = JSON . parse ( response ) ; console . log ( 'getPreferredLanguage: ' + JSON . stringify ( response ) ) ; if ( data . error !== undefined ) { result . error ( { code : data . error . code , message : data . error . message } ) ; } else { result . ok ( { value : data . result } ) ; } }

1<CODESPLIT>https://github.com/greggman/HappyFunTimes/blob/1c29e334ef9eca269980f5fc2b73894452688490/src/hft/scripts/misc/misc.js#L73-L103<CODESPLIT><CODESPLIT>Copies properties from obj to dst recursively . @param { Object } obj Object with new settings . @param { Object } dst Object to receive new settings . @param { number? } opt_overwriteBehavior * 0 / falsy = overwrite<CODESPLIT>function ( src , dst , opt_overwriteBehavior ) { Object . keys ( src ) . forEach ( function ( key ) { if ( opt_overwriteBehavior === 2 && dst [ key ] !== undefined ) { return ; } var value = src [ key ] ; if ( value instanceof Array ) { var newDst = dst [ key ] ; if ( ! newDst ) { newDst = [ ] ; dst [ name ] = newDst ; } copyProperties ( value , newDst , opt_overwriteBehavior ) ; } else if ( value instanceof Object && ! ( value instanceof Function ) && ! ( value instanceof HTMLElement ) ) { var newDst2 = dst [ key ] ; if ( ! newDst2 ) { newDst2 = { } ; dst [ key ] = newDst2 ; } copyProperties ( value , newDst2 , opt_overwriteBehavior ) ; } else { if ( opt_overwriteBehavior === 1 && dst [ key ] !== undefined ) { return ; } dst [ key ] = value ; } } ) ; return dst ; }

0<CODESPLIT>https://github.com/opendigitaleducation/sijil.js/blob/c0cd5250a573689a8bcd9733b958d4215b0ecfa4/docs/libs/typescript.js#L15353-L15421<CODESPLIT>bindContainer<CODESPLIT>Declares a Symbol for the node and adds it to symbols . Reports errors for conflicting identifier names .<CODESPLIT>function bindContainer ( node , containerFlags ) { // Before we recurse into a node's children, we first save the existing parent, container // and block-container.  Then after we pop out of processing the children, we restore // these saved values. var saveContainer = container ; var savedBlockScopeContainer = blockScopeContainer ; // Depending on what kind of node this is, we may have to adjust the current container // and block-container.   If the current node is a container, then it is automatically // considered the current block-container as well.  Also, for containers that we know // may contain locals, we proactively initialize the .locals field. We do this because // it's highly likely that the .locals will be needed to place some child in (for example, // a parameter, or variable declaration). // // However, we do not proactively create the .locals for block-containers because it's // totally normal and common for block-containers to never actually have a block-scoped // variable in them.  We don't want to end up allocating an object for every 'block' we // run into when most of them won't be necessary. // // Finally, if this is a block-container, then we clear out any existing .locals object // it may contain within it.  This happens in incremental scenarios.  Because we can be // reusing a node from a previous compilation, that node may have had 'locals' created // for it.  We must clear this so we don't accidentally move any stale data forward from // a previous compilation. if ( containerFlags & 1 /* IsContainer */ ) { container = blockScopeContainer = node ; if ( containerFlags & 32 /* HasLocals */ ) { container . locals = ts . createMap ( ) ; } addToContainerChain ( container ) ; } else if ( containerFlags & 2 /* IsBlockScopedContainer */ ) { blockScopeContainer = node ; blockScopeContainer . locals = undefined ; } if ( containerFlags & 4 /* IsControlFlowContainer */ ) { var saveCurrentFlow = currentFlow ; var saveBreakTarget = currentBreakTarget ; var saveContinueTarget = currentContinueTarget ; var saveReturnTarget = currentReturnTarget ; var saveActiveLabels = activeLabels ; var saveHasExplicitReturn = hasExplicitReturn ; var isIIFE = containerFlags & 16 /* IsFunctionExpression */ && ! ! ts . getImmediatelyInvokedFunctionExpression ( node ) ; // An IIFE is considered part of the containing control flow. Return statements behave // similarly to break statements that exit to a label just past the statement body. if ( isIIFE ) { currentReturnTarget = createBranchLabel ( ) ; } else { currentFlow = { flags : 2 /* Start */ } ; if ( containerFlags & 16 /* IsFunctionExpression */ ) { currentFlow . container = node ; } currentReturnTarget = undefined ; } currentBreakTarget = undefined ; currentContinueTarget = undefined ; activeLabels = undefined ; hasExplicitReturn = false ; bindChildren ( node ) ; // Reset all reachability check related flags on node (for incremental scenarios) // Reset all emit helper flags on node (for incremental scenarios) node . flags &= ~ 4030464 /* ReachabilityAndEmitFlags */ ; if ( ! ( currentFlow . flags & 1 /* Unreachable */ ) && containerFlags & 8 /* IsFunctionLike */ && ts . nodeIsPresent ( node . body ) ) { node . flags |= 32768 /* HasImplicitReturn */ ; if ( hasExplicitReturn ) node . flags |= 65536 /* HasExplicitReturn */ ; } if ( node . kind === 256 /* SourceFile */ ) { node . flags |= emitFlags ; } if ( isIIFE ) { addAntecedent ( currentReturnTarget , currentFlow ) ; currentFlow = finishFlowLabel ( currentReturnTarget ) ; } else { currentFlow = saveCurrentFlow ; } currentBreakTarget = saveBreakTarget ; currentContinueTarget = saveContinueTarget ; currentReturnTarget = saveReturnTarget ; activeLabels = saveActiveLabels ; hasExplicitReturn = saveHasExplicitReturn ; } else if ( containerFlags & 64 /* IsInterface */ ) { seenThisKeyword = false ; bindChildren ( node ) ; node . flags = seenThisKeyword ? node . flags | 16384 /* ContainsThis */ : node . flags & ~ 16384 /* ContainsThis */ ; } else { bindChildren ( node ) ; } container = saveContainer ; blockScopeContainer = savedBlockScopeContainer ; }

0<CODESPLIT>https://github.com/cargomedia/janus-gateway-js/blob/6e512b40f3f9dd54dadb8a8899bfe0a88e658bd1/src/connection.js#L27-L45<CODESPLIT>MediaPlugin<CODESPLIT>@param { string } id @param { string } address @param { Object } [ options ] @param { string } [ options . token ] @param { string } [ options . apisecret ] @param { boolean|number } [ options . keepalive ] @param { Object } [ options . pc ] RTCPeerConnection constructor options @param { Object } [ options . pc . config ] @param { Object } [ options . pc . constraints ]<CODESPLIT>function MediaPlugin ( session , name , id ) { MediaPlugin . super_ . apply ( this , arguments ) ; this . _pcListeners = { } ; this . _pc = null ; }

0<CODESPLIT>https://github.com/melonjs/melonJS/blob/6c1823cc245df7c958db243a0531506eb838d72c/src/video/canvas/canvas_renderer.js#L369-L381<CODESPLIT><CODESPLIT>Stroke a line of the given two points<CODESPLIT>function ( poly , fill ) { var context = this . backBufferContext2D ; if ( context . globalAlpha < 1 / 255 ) { // Fast path: don't draw fully transparent return ; } this . translate ( poly . pos . x , poly . pos . y ) ; context . beginPath ( ) ; context . moveTo ( poly . points [ 0 ] . x , poly . points [ 0 ] . y ) ; var point ; for ( var i = 1 ; i < poly . points . length ; i ++ ) { point = poly . points [ i ] ; context . lineTo ( point . x , point . y ) ; } context . lineTo ( poly . points [ 0 ] . x , poly . points [ 0 ] . y ) ; context [ fill === true ? "fill" : "stroke" ] ( ) ; context . closePath ( ) ; this . translate ( - poly . pos . x , - poly . pos . y ) ; }

1<CODESPLIT>https://github.com/blackbaud/skyux-cli/blob/c579986da0cfebbe74d584781d2db9dc9524d7d2/index.js#L13-L37<CODESPLIT>getGlobs<CODESPLIT>Returns results of glob . sync from specified directory and our glob pattern .<CODESPLIT>function getGlobs ( ) { // Look globally and locally for matching glob pattern const dirs = [ ` ${ process . cwd ( ) } ` , // local (where they ran the command from) ` ${ __dirname } ` , // global, if scoped package (where this code exists) ` ${ __dirname } ` , // global, if not scoped package ] ; let globs = [ ] ; dirs . forEach ( dir => { const legacyPattern = path . join ( dir , '*/skyux-builder*/package.json' ) ; const newPattern = path . join ( dir , '@skyux-sdk/builder*/package.json' ) ; logger . verbose ( ` ${ legacyPattern } ${ newPattern } ` ) ; globs = globs . concat ( [ ... glob . sync ( legacyPattern ) , ... glob . sync ( newPattern ) ] ) ; } ) ; return globs ; }

0<CODESPLIT>https://github.com/neyric/webhookit/blob/13abf6f072e23d536432235da78fd3e4e5d742b6/public/javascripts/yui/treeview/treeview.js#L2148-L2161<CODESPLIT><CODESPLIT>Recursively expands all of this node s children .<CODESPLIT>function ( ) { for ( var i = 0 ; i < this . children . length ; ++ i ) { this . children [ i ] . collapse ( ) ; this . children [ i ] . collapseAll ( ) ; } }

0<CODESPLIT>https://github.com/glaunay/nslurm/blob/002b064a700d3596d82e1c57110c0100a389f792/lib/sge.js#L244-L264<CODESPLIT><CODESPLIT>/ * KILL JOBS _kill to keep on DVL Params :<CODESPLIT>function ( partition ) { var self = this ; var results = { 'id' : [ ] , 'partition' : [ ] , 'nameUUID' : [ ] , 'status' : [ ] } ; self . data . partition . map ( function ( val , i ) { // for each partition if ( val . match ( partition ) ) { // if the job is on @partition for ( var key in self . data ) { // keep all the {'key':'value'} corresponding results [ key ] . push ( self . data [ key ] [ i ] ) ; } } } ) ; return results ; }

0<CODESPLIT>https://github.com/node-weixin/node-weixin-session/blob/d38d998637d6d5f47063d57665372a03ea65d451/lib/index.js#L4-L12<CODESPLIT>parse<CODESPLIT>WARN : these functions should be replaced in real production environment<CODESPLIT>function parse ( c ) { let ret = [ ] ; // replace windows line breaks with linux line breaks let c1 = c . replace ( new RegExp ( '[\r][\n]' , 'g' ) , '\n' ) ; // split string to line array let c2 = c1 . split ( '\n' ) ; for ( let i = 0 ; i < c2 . length ; i ++ ) { //line object let lo = { } ; // line let l = c2 [ i ] ; // trim line let l1 = l . trim ( ) ; // set line number lo . num = i + 1 ; // set original line lo . content = l1 ; // check empty line if ( l1 === '' ) { lo . isEmpty = true ; } else { lo . isEmpty = false ; // check line comment if ( l1 . startsWith ( '#' ) ) { lo . isComment = true ; lo . comment = lo . content . substring ( 1 , lo . content . length ) . trim ( ) ; } else { lo . isComment = false ; // Check included comments lo = Object . assign ( lo , checkComment ( l1 ) ) ; // check key value lo = Object . assign ( lo , checkKeyValue ( lo . contentWithoutComment ) ) ; // check block key lo = Object . assign ( lo , checkBlockKey ( lo ) ) ; } } //console.log(lo); ret . push ( lo ) ; } checkBlockEndSum ( ret ) ; determineDepth ( ret ) ; return ret ; }

1<CODESPLIT>https://github.com/eslint/eslint/blob/bc0819c94aad14f7fad3cbc2338ea15658b0f272/lib/rules/keyword-spacing.js#L176-L194<CODESPLIT>expectSpaceAfter<CODESPLIT>Reports a given token if there are not space ( s ) after the token .<CODESPLIT>function expectSpaceAfter ( token , pattern ) { const nextToken = sourceCode . getTokenAfter ( token ) ; if ( nextToken && ( CHECK_TYPE . test ( nextToken . type ) || pattern . test ( nextToken . value ) ) && ! isCloseParenOfTemplate ( nextToken ) && astUtils . isTokenOnSameLine ( token , nextToken ) && ! sourceCode . isSpaceBetweenTokens ( token , nextToken ) ) { context . report ( { loc : token . loc . start , messageId : "expectedAfter" , data : token , fix ( fixer ) { return fixer . insertTextAfter ( token , " " ) ; } } ) ; } }

1<CODESPLIT>https://github.com/dcloudio/mui/blob/ff74c90a1671a552f3604b1288bf38a4126312d0/examples/login/libs/easymob-webim-sdk/strophe-custom-2.0.0.js#L1686-L1694<CODESPLIT><CODESPLIT>Function : c Add a child to the current element and make it the new current element .<CODESPLIT>function ( name , attrs , text ) { var child = Strophe . xmlElement ( name , attrs , text ) ; this . node . appendChild ( child ) ; if ( ! text ) { this . node = child ; } return this ; }

1<CODESPLIT>https://github.com/Wtower/ng-gentelella/blob/3c45611cfa200e660aa497ba82d191231163487b/build/js/index.min.js#L66941-L67038<CODESPLIT>GaPaginateController<CODESPLIT>Paginate controller<CODESPLIT>function GaPaginateController ( ) { var self = this ; /**          * Return an array of `len` items used for html ng-repeat range          * @param len          * @returns {Array}          */ self . range = function ( len ) { var range = [ ] ; for ( var i = 0 ; i < len ; i ++ ) range . push ( i ) ; return range ; } ; /**          * Initialize controller default values          */ self . $onInit = function ( ) { // distinguish because initial may need to be provided in parent by a third variable self . paginateSize = parseInt ( self . paginateInitialSize ) ; self . paginateSizes = self . paginateSizes || [ 10 , 25 , 50 , 100 ] ; self . paginatePage = self . paginatePage || 1 ; self . itemIdx = 0 ; self . paginateEllipsis = parseInt ( self . paginateEllipsis ) || 5 ; } ; /**          * Re-calculate pagination on size or value change          * When user clicks, then force a fetch data          * @param dataRefresh: true to fetch data          */ self . rePaginate = function ( dataRefresh ) { self . pages = Math . ceil ( self . paginateCount / self . paginateSize ) ; self . paginate ( Math . ceil ( self . itemIdx / self . paginateSize ) , dataRefresh ) ; } ; /**          * Because initialization happens before data is fetched and angular fails to detect the changes          * Keep a previous value to skip calculations if no change          * Also fetch data only if a previousCount exists (not first) to avoid initial double fetch #16          */ self . $doCheck = function ( ) { if ( self . previousCount != self . paginateCount ) { self . paginateCount = parseInt ( self . paginateCount ) ; self . paginateEllipsis = parseInt ( self . paginateEllipsis ) ; self . rePaginate ( ) ; self . previousCount = self . paginateCount ; } } ; /**          * Go to page          * @param page          * @param dataRefresh          */ self . paginate = function ( page , dataRefresh ) { if ( page < 1 ) page = 1 ; if ( page > self . pages ) page = self . pages ; self . itemIdx = ( page - 1 ) * self . paginateSize ; self . focus ( 'reset' , page ) ; if ( ! dataRefresh && page == self . paginatePage ) return ; self . paginatePage = page ; self . onPaginate ( { paginator : { page : self . paginatePage , page_size : self . paginateSize } } ) ; } ; /**          * Set low and high page numbers to show around current page with an ellipsis          * @param direction: reset / left / right          * @param page: pass the new page because the self.paginatePage may not yet be updated          */ self . focus = function ( direction , page ) { if ( direction == 'reset' ) { // a new page is up self . lowEllipsis = Math . max ( page - Math . floor ( self . paginateEllipsis / 2 ) , 1 ) ; self . lowEllipsis = Math . min ( self . lowEllipsis , Math . max ( self . pages - self . paginateEllipsis , 1 ) ) ; } else if ( direction == 'left' ) { // the left ellipsis is pressed self . lowEllipsis = Math . max ( self . lowEllipsis - self . paginateEllipsis , 1 ) ; } else if ( direction == 'right' ) { // the right ellipsis is pressed self . lowEllipsis = Math . min ( self . lowEllipsis + self . paginateEllipsis , self . pages - self . paginateEllipsis + 1 ) ; } } ; /**          * Provide the upper visible index number for use in template          * @returns {number}          */ self . itemUpperIdx = function ( ) { return Math . min ( self . itemIdx + self . paginateSize , self . paginateCount ) ; } ; }

0<CODESPLIT>https://github.com/neyric/webhookit/blob/13abf6f072e23d536432235da78fd3e4e5d742b6/public/javascripts/yui/datasource/datasource-debug.js#L909-L925<CODESPLIT><CODESPLIT>Overridable default method generates a unique transaction ID and passes the live data reference directly to the handleResponse function . This method should be implemented by subclasses to achieve more complex behavior or to access remote data .<CODESPLIT>function ( oRequest , oCallback , oCaller ) { // First look in cache var oCachedResponse = this . getCachedResponse ( oRequest , oCallback , oCaller ) ; if ( oCachedResponse ) { DS . issueCallback ( oCallback , [ oRequest , oCachedResponse ] , false , oCaller ) ; return null ; } // Not in cache, so forward request to live data YAHOO . log ( "Making connection to live data for \"" + oRequest + "\"" , "info" , this . toString ( ) ) ; return this . makeConnection ( oRequest , oCallback , oCaller ) ; }

1<CODESPLIT>https://github.com/babel/minify/blob/6b8bab6bf5905ebc3a5a9130662a5fef34886de4/packages/babel-plugin-minify-simplify/src/if-statement.js#L92-L264<CODESPLIT>toReturn<CODESPLIT>There is nothing after this If block . And one or both of the consequent and alternate are either expression statment or return statements .<CODESPLIT>function toReturn ( path ) { const { node } = path ; if ( ! path . getSibling ( path . key + 1 ) . node && path . parentPath && path . parentPath . parentPath && path . parentPath . parentPath . isFunction ( ) ) { // Only the consequent is a return, void the alternate. if ( t . isReturnStatement ( node . consequent ) && t . isExpressionStatement ( node . alternate ) ) { if ( ! node . consequent . argument ) { path . replaceWith ( t . expressionStatement ( t . logicalExpression ( "||" , node . test , node . alternate . expression ) ) ) ; return REPLACED ; } path . replaceWith ( t . returnStatement ( t . conditionalExpression ( node . test , node . consequent . argument || h . VOID_0 ( t ) , t . unaryExpression ( "void" , node . alternate . expression , true ) ) ) ) ; return REPLACED ; } // Only the alternate is a return, void the consequent. if ( t . isReturnStatement ( node . alternate ) && t . isExpressionStatement ( node . consequent ) ) { if ( ! node . alternate . argument ) { path . replaceWith ( t . expressionStatement ( t . logicalExpression ( "&&" , node . test , node . consequent . expression ) ) ) ; return REPLACED ; } path . replaceWith ( t . returnStatement ( t . conditionalExpression ( node . test , t . unaryExpression ( "void" , node . consequent . expression , true ) , node . alternate . argument || h . VOID_0 ( t ) ) ) ) ; return REPLACED ; } if ( t . isReturnStatement ( node . consequent ) && ! node . alternate ) { if ( ! node . consequent . argument ) { path . replaceWith ( t . expressionStatement ( node . test ) ) ; return REPLACED ; } // This would only be worth it if the previous statement was an if // because then we may merge to create a conditional. if ( path . getSibling ( path . key - 1 ) . isIfStatement ( ) ) { path . replaceWith ( t . returnStatement ( t . conditionalExpression ( node . test , node . consequent . argument || h . VOID_0 ( t ) , h . VOID_0 ( t ) ) ) ) ; return REPLACED ; } } if ( t . isReturnStatement ( node . alternate ) && ! node . consequent ) { if ( ! node . alternate . argument ) { path . replaceWith ( t . expressionStatement ( node . test ) ) ; return REPLACED ; } // Same as above. if ( path . getSibling ( path . key - 1 ) . isIfStatement ( ) ) { path . replaceWith ( t . returnStatement ( t . conditionalExpression ( node . test , node . alternate . argument || h . VOID_0 ( t ) , h . VOID_0 ( t ) ) ) ) ; return REPLACED ; } } } let next = path . getSibling ( path . key + 1 ) ; // If the next satatement(s) is an if statement and we can simplify that // to potentailly be an expression (or a return) then this will make it // easier merge. if ( next . isIfStatement ( ) ) { next . pushContext ( path . context ) ; next . visit ( ) ; next . popContext ( ) ; next = path . getSibling ( path . key + 1 ) ; } // Some other visitor might have deleted our node. OUR NODE ;_; if ( ! path . node ) { return ; } // No alternate but the next statement is a return // also turn into a return conditional if ( t . isReturnStatement ( node . consequent ) && ! node . alternate && next . isReturnStatement ( ) ) { const nextArg = next . node . argument || h . VOID_0 ( t ) ; next . remove ( ) ; path . replaceWith ( t . returnStatement ( t . conditionalExpression ( node . test , node . consequent . argument || h . VOID_0 ( t ) , nextArg ) ) ) ; return REPLACED ; } // Next is the last expression, turn into a return while void'ing the exprs if ( path . parentPath && path . parentPath . parentPath && path . parentPath . parentPath . isFunction ( ) && ! path . getSibling ( path . key + 2 ) . node && t . isReturnStatement ( node . consequent ) && ! node . alternate && next . isExpressionStatement ( ) ) { const nextExpr = next . node . expression ; next . remove ( ) ; if ( node . consequent . argument ) { path . replaceWith ( t . returnStatement ( t . conditionalExpression ( node . test , node . consequent . argument , t . unaryExpression ( "void" , nextExpr , true ) ) ) ) ; return REPLACED ; } path . replaceWith ( t . logicalExpression ( "||" , node . test , nextExpr ) ) ; return REPLACED ; } }

1<CODESPLIT>https://github.com/antonio-gomez/three-gltf2-loader/blob/bef47cff3c2eaf0935151454e1f6f0a634916f93/lib/main.js#L1094-L1204<CODESPLIT>addMorphTargets<CODESPLIT>Specification : https : // github . com / KhronosGroup / glTF / blob / master / specification / 2 . 0 / README . md#morph - targets<CODESPLIT>function addMorphTargets ( mesh , meshDef , primitiveDef , dependencies ) { var geometry = mesh . geometry ; var material = mesh . material ; var targets = primitiveDef . targets ; var morphAttributes = geometry . morphAttributes ; morphAttributes . position = [ ] ; morphAttributes . normal = [ ] ; material . morphTargets = true ; for ( var i = 0 , il = targets . length ; i < il ; i ++ ) { var target = targets [ i ] ; var attributeName = 'morphTarget' + i ; var positionAttribute , normalAttribute ; if ( target . POSITION !== undefined ) { // Three.js morph formula is //   position //     + weight0 * ( morphTarget0 - position ) //     + weight1 * ( morphTarget1 - position ) //     ... // while the glTF one is //   position //     + weight0 * morphTarget0 //     + weight1 * morphTarget1 //     ... // then adding position to morphTarget. // So morphTarget value will depend on mesh's position, then cloning attribute // for the case if attribute is shared among two or more meshes. positionAttribute = dependencies . accessors [ target . POSITION ] . clone ( ) ; var position = geometry . attributes . position ; for ( var j = 0 , jl = positionAttribute . count ; j < jl ; j ++ ) { positionAttribute . setXYZ ( j , positionAttribute . getX ( j ) + position . getX ( j ) , positionAttribute . getY ( j ) + position . getY ( j ) , positionAttribute . getZ ( j ) + position . getZ ( j ) ) ; } } else { // Copying the original position not to affect the final position. // See the formula above. positionAttribute = geometry . attributes . position . clone ( ) ; } if ( target . NORMAL !== undefined ) { material . morphNormals = true ; // see target.POSITION's comment normalAttribute = dependencies . accessors [ target . NORMAL ] . clone ( ) ; var normal = geometry . attributes . normal ; for ( var j = 0 , jl = normalAttribute . count ; j < jl ; j ++ ) { normalAttribute . setXYZ ( j , normalAttribute . getX ( j ) + normal . getX ( j ) , normalAttribute . getY ( j ) + normal . getY ( j ) , normalAttribute . getZ ( j ) + normal . getZ ( j ) ) ; } } else { normalAttribute = geometry . attributes . normal . clone ( ) ; } if ( target . TANGENT !== undefined ) { // TODO: implement } positionAttribute . name = attributeName ; normalAttribute . name = attributeName ; morphAttributes . position . push ( positionAttribute ) ; morphAttributes . normal . push ( normalAttribute ) ; } mesh . updateMorphTargets ( ) ; if ( meshDef . weights !== undefined ) { for ( var i = 0 , il = meshDef . weights . length ; i < il ; i ++ ) { mesh . morphTargetInfluences [ i ] = meshDef . weights [ i ] ; } } }

0<CODESPLIT>https://github.com/jneen/parsimmon/blob/f71a73882383013628cdd87017ae1617c765cf93/examples/math.js#L43-L48<CODESPLIT>operators<CODESPLIT>Takes a parser for the prefix operator and a parser for the base thing being parsed and parses as many occurrences as possible of the prefix operator . Note that the parser is created using P . lazy because it s recursive . It s valid for there to be zero occurrences of the prefix operator .<CODESPLIT>function operators ( ops ) { let keys = Object . keys ( ops ) . sort ( ) ; let ps = keys . map ( k => P . string ( ops [ k ] ) . trim ( _ ) . result ( k ) ) ; return P . alt . apply ( null , ps ) ; }

1<CODESPLIT>https://github.com/jurca/idb-entity/blob/361ef8482872d9fc9a0d83b86970d49d391dc276/es2015/clone.js#L232-L260<CODESPLIT>cloneStructure<CODESPLIT>Clones the structure having the specified property keys using the provided getters and setters . The function clones the keys and values before setting them using the setters .<CODESPLIT>function cloneStructure ( keys , getter , setter , traversedValues ) { for ( let key of keys ) { let value = getter ( key ) let keyClone if ( key instanceof Object ) { if ( traversedValues . has ( key ) ) { keyClone = traversedValues . get ( key ) } else { keyClone = cloneValue ( key , traversedValues ) traversedValues . set ( key , keyClone ) } } else { keyClone = key } if ( value instanceof Object ) { if ( traversedValues . has ( value ) ) { setter ( keyClone , traversedValues . get ( value ) ) } else { let clonedValue = cloneValue ( value , traversedValues ) traversedValues . set ( value , clonedValue ) setter ( keyClone , clonedValue ) } } else { setter ( keyClone , value ) } } }

0<CODESPLIT>https://github.com/MatAtBread/nodent-transform/blob/40d61ad20b0a87fb83d420fd98ba01adbff73cac/arboriculture.js#L198-L243<CODESPLIT>cloneNode<CODESPLIT>/ * descendOn = true Enter scopes within scopes descendOn = false / undefined / null Do not enter scopes within scopes descendOn = function Descend when function ( node ) is true<CODESPLIT>function cloneNode ( n ) { if ( Array . isArray ( n ) ) return n . map ( function ( n ) { return cloneNode ( n ) ; } ) ; var o = { } ; Object . keys ( n ) . forEach ( function ( k ) { o [ k ] = n [ k ] ; } ) ; return o ; }

1<CODESPLIT>https://github.com/ld-x/last-draft-js-plugins/blob/c4e7cf03faf2ffcdc845409892ee2b18368a9a9d/draft-js-modal-plugin/src/components/EmbedModal/Url/getVideoUrl.js#L3-L10<CODESPLIT>getVideoIdYoutube<CODESPLIT>/ * eslint no - useless - escape : 0<CODESPLIT>function getVideoIdYoutube ( str ) { // link : https://youtube.com/watch?v=HBHJ0XGZfLs // share : https://youtu.be/HBHJ0XGZfLs // embed : https://youtube.com/embed/HBHJ0XGZfLs var re = / \/\/(?:www\.)?youtu(?:\.be|be\.com)\/(?:watch\?v=|embed\/)?([a-z0-9_\-]+) / i var matches = re . exec ( str ) return matches && matches [ 1 ] }

1<CODESPLIT>https://github.com/MikeMcl/big.js/blob/565c0f81365ccfa61138a74baaf6910b5bafe9cb/perf/lib/bigdecimal_ICU4J/BigDecimal-all-last.js#L680-L689<CODESPLIT>isValidRound<CODESPLIT>/ * <sgml > Test whether round is valid . < / sgml > This could be made shared for use by BigDecimal for setScale . -- private static boolean isValidRound ( int testround ) {<CODESPLIT>function isValidRound ( testround ) { //--int r=0; var r = 0 ; { var $2 = this . ROUNDS . length ; r = 0 ; r : for ( ; $2 > 0 ; $2 -- , r ++ ) { if ( testround == this . ROUNDS [ r ] ) return true ; } } /*r*/ return false ; }

1<CODESPLIT>https://github.com/arthurvaverko/ngx-highlight/blob/4e98e58e0d718a093cfe4d31ac03a21b3d1e1405/dist/vendor.bundle.js#L48351-L48357<CODESPLIT>interpretStatements<CODESPLIT>@license Copyright Google Inc . All Rights Reserved .<CODESPLIT>function interpretStatements ( statements , resultVars ) { var /** @type {?} */ stmtsWithReturn = statements . concat ( [ new ReturnStatement ( literalArr ( resultVars . map ( function ( resultVar ) { return variable ( resultVar ) ; } ) ) ) ] ) ; var /** @type {?} */ ctx = new _ExecutionContext ( null , null , null , new Map ( ) ) ; var /** @type {?} */ visitor = new StatementInterpreter ( ) ; var /** @type {?} */ result = visitor . visitAllStatements ( stmtsWithReturn , ctx ) ; return result != null ? result . value : null ; }

0<CODESPLIT>https://github.com/jonschlinkert/object-copy/blob/45c79022e7b56e2f6456cac9ff44d6876fc7738b/index.js#L91-L117<CODESPLIT>parse<CODESPLIT>Returns true if an array has any of the given elements or an object has any of the given keys .<CODESPLIT>function parse ( formula ) { formula = formula . trim ( ) . toLowerCase ( ) ; if ( formula === "even" ) { return [ 2 , 0 ] ; } else if ( formula === "odd" ) { return [ 2 , 1 ] ; } else { var parsed = formula . match ( re_nthElement ) ; if ( ! parsed ) { throw new SyntaxError ( "n-th rule couldn't be parsed ('" + formula + "')" ) ; } var a ; if ( parsed [ 1 ] ) { a = parseInt ( parsed [ 1 ] , 10 ) ; if ( isNaN ( a ) ) { if ( parsed [ 1 ] . charAt ( 0 ) === "-" ) a = - 1 ; else a = 1 ; } } else a = 0 ; return [ a , parsed [ 3 ] ? parseInt ( ( parsed [ 2 ] || "" ) + parsed [ 3 ] , 10 ) : 0 ] ; } }

0<CODESPLIT>https://github.com/bbx10/node-htu21d/blob/135e81b53ab5e98282cb16ea9d27ce193dc9bf0a/index.js#L43-L66<CODESPLIT>calc_crc8<CODESPLIT>The regular versions of the READTEMP and READHUMI commands depend on clock stretching / hold which seems to be a problem the raspberry pi i2c controller .<CODESPLIT>function calc_crc8 ( buf , len ) { var dataandcrc ; // Generator polynomial: x**8 + x**5 + x**4 + 1 = 1001 1000 1 var poly = 0x98800000 ; var i ; if ( len === null ) return - 1 ; if ( len != 3 ) return - 1 ; if ( buf === null ) return - 1 ; // Justify the data on the MSB side. Note the poly is also // justified the same way. dataandcrc = ( buf [ 0 ] << 24 ) | ( buf [ 1 ] << 16 ) | ( buf [ 2 ] << 8 ) ; for ( i = 0 ; i < 24 ; i ++ ) { if ( dataandcrc & 0x80000000 ) dataandcrc ^= poly ; dataandcrc <<= 1 ; } return ( dataandcrc === 0 ) ; }

0<CODESPLIT>https://github.com/onecommons/base/blob/4f35d9f714d0367b0622a3504802363404290246/lib/createmodel.js#L153-L287<CODESPLIT>shiftL<CODESPLIT>/ * @param { String } name model name @param { Schema } [ schema ] ( plain object or Schema object ) @param { Object } [ options ] schema options ( optional only use if schema is plain object ) @param { Model } [ baseModel ] base model to inherit from ( optional )<CODESPLIT>function shiftL ( start , end , c , maskJumps ) { var buffer = getActiveBuffer ( ) ; if ( maskJumps !== false ) //jumping over nonmask position while ( ! isMask ( start ) && start - 1 >= 0 ) start -- ; for ( var i = start ; i < end && i < getMaskLength ( ) ; i ++ ) { if ( isMask ( i ) ) { setReTargetPlaceHolder ( buffer , i ) ; var j = seekNext ( i ) ; var p = getBufferElement ( buffer , j ) ; if ( p != getPlaceHolder ( j ) ) { if ( j < getMaskLength ( ) && isValid ( i , p , true ) !== false && getActiveTests ( ) [ determineTestPosition ( i ) ] . def == getActiveTests ( ) [ determineTestPosition ( j ) ] . def ) { setBufferElement ( buffer , i , p , true ) ; } else { if ( isMask ( i ) ) break ; } } } else { setReTargetPlaceHolder ( buffer , i ) ; } } if ( c != undefined ) setBufferElement ( buffer , seekPrevious ( end ) , c ) ; if ( getActiveMaskSet ( ) [ "greedy" ] == false ) { var trbuffer = truncateInput ( buffer . join ( '' ) ) . split ( '' ) ; buffer . length = trbuffer . length ; for ( var i = 0 , bl = buffer . length ; i < bl ; i ++ ) { buffer [ i ] = trbuffer [ i ] ; } if ( buffer . length == 0 ) getActiveMaskSet ( ) [ "buffer" ] = getActiveBufferTemplate ( ) . slice ( ) ; } return start ; //return the used start position }

1<CODESPLIT>https://github.com/alexpods/ClazzJS/blob/2f94496019669813c8246d48fcceb12a3e68a870/src/components/meta/Property/Methods.js#L49-L62<CODESPLIT><CODESPLIT>Creates method for specified property<CODESPLIT>function ( name , property ) { if ( ! ( name in this . _methods ) ) { throw new Error ( 'Method "' + name + '" does not exist!' ) ; } var method = this . _methods [ name ] ( property ) ; if ( _ . isFunction ( method ) ) { method = { name : this . getMethodName ( property , name ) , body : method } } return method ; }

0<CODESPLIT>https://github.com/openactive/skos.js/blob/1bdc88eb004924f8279dac541af0374fa692fda9/src/skos.js#L34-L183<CODESPLIT>Concept<CODESPLIT>Note this library is written in ES5 to provide client - side compatibility without requiring transpiling . It has been tested on IE9 upwards . @module skos ConceptScheme constructor . @public @example // returns Concept for American Football var activityListJsonObject = JSON . parse ( response . getBody ( utf8 )) ; var scheme = new skos . ConceptScheme ( activityListJsonObject ) ; return scheme . getConceptByID ( https : // openactive . io / activity - list#9caeb442 - 2834 - 4859 - b660 - 9172ed61ee71 ) ;<CODESPLIT>function Concept ( concept ) { if ( ! ( concept . prefLabel && concept . id && concept . type === 'Concept' ) ) { throw new Error ( 'Invalid concept: "' + concept . id + '"' ) ; } this . id = concept . id ; this . prefLabel = concept . prefLabel ; this . altLabel = concept . altLabel ; this . hiddenLabel = concept . hiddenLabel ; this . definition = concept . definition ; this . _topConceptOf = concept . topConceptOf ; this . _partOfScheme = false ; this . _originalConcept = concept ; this . _broaderConcepts = [ ] ; this . _narrowerConcepts = [ ] ; this . _relatedConcepts = [ ] ; }

0<CODESPLIT>https://github.com/1144/mok-js/blob/b84f58a963c83d31cd74af5584225b6365bc88ab/mok_modules/mok_proxy.js#L14-L23<CODESPLIT>parseRequestOption<CODESPLIT>\ r \ n \ r \ n 分开head和body<CODESPLIT>function parseRequestOption ( data , pos , conf ) { var header_str = data . slice ( 0 , pos ) . toString ( 'utf8' ) ; var method = header_str . split ( ' ' , 1 ) [ 0 ] , info , opt ; if ( method === 'CONNECT' ) { info = header_str . match ( / ^[A-Z]+\s([^:\s]+):(\d+)\sHTTP / ) ; if ( info ) { opt = { method : 'CONNECT' , host : info [ 1 ] , port : info [ 2 ] } ; if ( conf [ info [ 1 ] ] ) { var o = conf [ info [ 1 ] ] [ 0 ] . transfer ( opt ) ; o . host && ( opt . host = o . host ) ; o . port && ( opt . port = o . port ) ; } return opt ; } } else { info = header_str . match ( / ^[A-Z]+\s(\S+)\sHTTP\/(\d\.\d) / ) ; if ( info ) { var host = header_str . match ( / Host:\s([^\n\s\r]+) / ) [ 1 ] ; if ( host ) { var hp = host . split ( ':' ) , path = info [ 1 ] . replace ( / ^http:\/\/[^\/]+ / , '' ) , ri = header_str . indexOf ( '\r' ) , hd1 = header_str . slice ( 0 , ri ) , hd2 = header_str . slice ( ri ) ; hd2 = hd2 . replace ( / Proxy-Connection:.+\r\n / ig , '' ) . replace ( / Keep-Alive:.+\r\n / i , '' ) . replace ( '\r\n' , '\r\nConnection: close\r\n' ) ; opt = { method : method , host : hp [ 0 ] , port : hp [ 1 ] || '80' , path : path , http_version : info [ 2 ] , data : data . slice ( pos ) } ; if ( conf [ hp [ 0 ] ] ) { var routes = conf [ hp [ 0 ] ] , i = 0 , len = routes . length , route , match ; for ( ; i < len ; i ++ ) { route = routes [ i ] ; match = path . match ( route . regexp ) ; if ( match ) { var o = ( route . transfer || route . replace ) ( opt , match ) ; if ( o . host ) { opt . host = o . host ; if ( route . replace ) { hd2 = hd2 . replace ( 'Host: ' + host , 'Host: ' + o . host + ( o . port ? ( o . port == '80' ? '' : ':' + o . port ) : hp [ 1 ] || '' ) + '\r\nsrchost: ' + host ) ; } } o . port && ( opt . port = o . port ) ; o . path && ( opt . path = o . path [ 0 ] === '/' ? o . path : '/' + o . path ) ; o . data && ( opt . data = o . data ) ; if ( info [ 2 ] !== '1.1' ) { if ( route . replace ) { opt . path = 'http://' + opt . host + ( opt . port == '80' ? '' : ':' + opt . port ) + opt . path ; } else { opt . path = 'http://' + host + opt . path ; } } opt . headers = method + ' ' + opt . path + ' HTTP/' + info [ 2 ] + hd2 ; return opt ; } } } opt . headers = method + ' ' + info [ 1 ] + ' HTTP/' + info [ 2 ] + hd2 ; return opt ; } } } return null ; }

0<CODESPLIT>https://github.com/uupaa/UserAgent.js/blob/5d90111f44c1a90a68c804f30f949b3feac436dd/docs/modules/ES.js#L1395-L1432<CODESPLIT>Array_toObject<CODESPLIT>=== Array ===============================================<CODESPLIT>function Array_toObject ( source ) { // @arg Array // @ret Object return Object . keys ( source ) . reduce ( function ( result , key ) { result [ key ] = source [ key ] ; return result ; } , { } ) ; }

0<CODESPLIT>https://github.com/bizdevfe/biz-ui/blob/4d0213be201256d098ae24449e18ddba355acaba/src/ui/Transfer.js#L335-L349<CODESPLIT><CODESPLIT>销毁<CODESPLIT>function ( element , options ) { this . $element = $ ( element ) ; this . options = $ . extend ( { } , Iconpicker . DEFAULTS , this . $element . data ( ) ) ; this . options = $ . extend ( { } , this . options , options ) ; }

0<CODESPLIT>https://github.com/box/t3js/blob/1cc1751650e339bd5243a0f20cc76543c834ac09/dist/t3-jquery.js#L260-L280<CODESPLIT>forEachEventType<CODESPLIT>Finds the closest ancestor that of an element that has a data - type attribute .<CODESPLIT>function forEachEventType ( eventTypes , handler , callback , thisValue ) { var i , type ; for ( i = 0 ; i < eventTypes . length ; i ++ ) { type = eventTypes [ i ] ; // only call the callback if the event is on the handler if ( handler [ 'on' + type ] ) { callback . call ( thisValue , type ) ; } } }

1<CODESPLIT>https://github.com/googlearchive/node-big-rig/blob/71748aab8ea166726356c6578a6a1c82e314ca33/lib/third_party/tracing/extras/rail/rail_ir_finder.js#L184-L215<CODESPLIT><CODESPLIT>Find all unassociated top - level ThreadSlices . If they start during an Idle or Load IR then add their entire hierarchy to that IR .<CODESPLIT>function ( rirs ) { var vacuumIRs = [ ] ; rirs . forEach ( function ( ir ) { if ( ir instanceof tr . e . rail . LoadInteractionRecord || ir instanceof tr . e . rail . IdleInteractionRecord ) vacuumIRs . push ( ir ) ; } ) ; if ( vacuumIRs . length === 0 ) return ; var allAssociatedEvents = tr . model . getAssociatedEvents ( rirs ) ; var unassociatedEvents = tr . model . getUnassociatedEvents ( this . model , allAssociatedEvents ) ; unassociatedEvents . forEach ( function ( event ) { if ( ! ( event instanceof tr . model . ThreadSlice ) ) return ; if ( ! event . isTopLevel ) return ; for ( var iri = 0 ; iri < vacuumIRs . length ; ++ iri ) { var ir = vacuumIRs [ iri ] ; if ( ( event . start >= ir . start ) && ( event . start < ir . end ) ) { ir . associatedEvents . addEventSet ( event . entireHierarchy ) ; return ; } } } ) ; }

1<CODESPLIT>https://github.com/FineUploader/fine-uploader/blob/057cc83a7e7657d032a75cf4a6b3612c7b4191da/client/js/s3/multipart.abort.ajax.requester.js#L44-L57<CODESPLIT>getHeaders<CODESPLIT>Attach all required headers ( including Authorization ) to the Abort request . This is a promissory function that will fulfill the associated promise once all headers have been attached or when an error has occurred that prevents headers from being attached .<CODESPLIT>function getHeaders ( id , uploadId ) { var headers = { } , promise = new qq . Promise ( ) , bucket = options . getBucket ( id ) , host = options . getHost ( id ) , signatureConstructor = getSignatureAjaxRequester . constructStringToSign ( getSignatureAjaxRequester . REQUEST_TYPE . MULTIPART_ABORT , bucket , host , options . getKey ( id ) ) . withUploadId ( uploadId ) ; // Ask the local server to sign the request.  Use this signature to form the Authorization header. getSignatureAjaxRequester . getSignature ( id , { signatureConstructor : signatureConstructor } ) . then ( promise . success , promise . failure ) ; return promise ; }

1<CODESPLIT>https://github.com/excellalabs/ngComponentRouter/blob/b2240385bf542987916e07aa0d8712c962963f2d/angular_1_router.js#L2540-L2552<CODESPLIT>splitAndFlattenLinkParams<CODESPLIT>/ * Given : [ / a / b { c : 2 } ] Returns : [ a b { c : 2 } ]<CODESPLIT>function splitAndFlattenLinkParams ( linkParams ) { var accumulation = [ ] ; linkParams . forEach ( function ( item ) { if ( isString ( item ) ) { var strItem = item ; accumulation = accumulation . concat ( strItem . split ( '/' ) ) ; } else { accumulation . push ( item ) ; } } ) ; return accumulation ; }

0<CODESPLIT>https://github.com/imbo/imboclient-js/blob/809dcc489528dca9d67f49b03b612a99704339d0/lib/url/imageurl.js#L390-L420<CODESPLIT><CODESPLIT>Sharpen the image<CODESPLIT>function ( options ) { options = options || { } ; return this . append ( [ 'thumbnail:width=' + ( options . width || 50 ) , 'height=' + ( options . height || 50 ) , 'fit=' + ( options . fit || 'outbound' ) ] . join ( ',' ) ) ; }

1<CODESPLIT>https://github.com/tkellen/requirejs-library-skeleton/blob/c4ff186c588ba9418af71afb64cf7d000aa36bfb/vendor/r.js#L6323-L6341<CODESPLIT>addComment<CODESPLIT>The following functions are needed only when the option to preserve the comments is active .<CODESPLIT>function addComment ( start , end , type , value ) { assert ( typeof start === 'number' , 'Comment must have valid position' ) ; // Because the way the actual token is scanned, often the comments // (if any) are skipped twice during the lexical analysis. // Thus, we need to skip adding a comment if the comment array already // handled it. if ( extra . comments . length > 0 ) { if ( extra . comments [ extra . comments . length - 1 ] . range [ 1 ] > start ) { return ; } } extra . comments . push ( { range : [ start , end ] , type : type , value : value } ) ; }

0<CODESPLIT>https://github.com/aaaristo/grunt-html-builder/blob/9ab9ffb5c3d3395b7b097d906ea20c1e4fd09da1/tasks/jsrender/lib/jsrender.js#L737-L826<CODESPLIT>TmplObject<CODESPLIT>============== renderContent ==============<CODESPLIT>function TmplObject ( markup , options ) { // Template object constructor var htmlTag , wrapMap = $viewsSettings . wrapMap || { } , tmpl = $extend ( { markup : markup , tmpls : [ ] , links : { } , bnds : [ ] , render : renderContent } , options ) ; if ( ! options . htmlTag ) { // Set tmpl.tag to the top-level HTML tag used in the template, if any... htmlTag = rFirstElem . exec ( markup ) ; tmpl . htmlTag = htmlTag ? htmlTag [ 1 ] . toLowerCase ( ) : "" ; } htmlTag = wrapMap [ tmpl . htmlTag ] ; if ( htmlTag && htmlTag !== wrapMap . div ) { // When using JsViews, we trim templates which are inserted into HTML contexts where text nodes are not rendered (i.e. not 'Phrasing Content'). tmpl . markup = $ . trim ( tmpl . markup ) ; tmpl . _elCnt = TRUE ; // element content model (no rendered text nodes), not phrasing content model } return tmpl ; }

0<CODESPLIT>https://github.com/SAP/openui5/blob/8a832fca01cb1cdf8df589788e0c5723e2a33c70/src/sap.ui.core/src/sap/ui/thirdparty/RequestRecorder.js#L118-L145<CODESPLIT><CODESPLIT>Sorts the entries of a har file by response and request order . After the entries are sorted the function builds a map of the entries with the assigned custom groups and url groups .<CODESPLIT>function ( sLocationUrl ) { // Try to request the har file from the given location url var mHarFileContent = null ; var oRequest = new XMLHttpRequest ( ) ; oRequest . open ( "GET" , sLocationUrl , false ) ; oRequest . addEventListener ( "load" , function ( ) { if ( this . status === 200 ) { mHarFileContent = JSON . parse ( this . responseText ) ; } } ) ; oRequest . send ( ) ; try { mHarFileContent = JSON . parse ( oRequest . responseText ) ; } catch ( e ) { throw new Error ( "Har file could not be loaded." ) ; } // Validate version of the har file if ( mHarFileContent && ( ! mHarFileContent . log || ! mHarFileContent . log . version || parseInt ( mHarFileContent . log . version , 10 ) != this . sDefaultMajorHarVersion ) ) { this . oLog . error ( sModuleName + " - Incompatible version. Please provide .har file with version " + this . sDefaultMajorHarVersion + ".x" ) ; } return mHarFileContent ; }

0<CODESPLIT>https://github.com/glidejs/glide/blob/593ad78d0f85bd7bcb6ac6ef487c607718605a89/dist/glide.esm.js#L3397-L3411<CODESPLIT>press<CODESPLIT>Starts autoplaying in configured interval .<CODESPLIT>function press ( event ) { if ( event . keyCode === 39 ) { Components . Run . make ( Components . Direction . resolve ( '>' ) ) ; } if ( event . keyCode === 37 ) { Components . Run . make ( Components . Direction . resolve ( '<' ) ) ; } }

0<CODESPLIT>https://github.com/angular/material/blob/84ac558674e73958be84312444c48d9f823f6684/src/components/select/select.js#L1254-L1276<CODESPLIT>onShow<CODESPLIT>Restore the element to a closed state<CODESPLIT>function onShow ( scope , element , opts ) { watchAsyncLoad ( ) ; sanitizeAndConfigure ( scope , opts ) ; opts . hideBackdrop = showBackdrop ( scope , element , opts ) ; return showDropDown ( scope , element , opts ) . then ( function ( response ) { element . attr ( 'aria-hidden' , 'false' ) ; opts . alreadyOpen = true ; opts . cleanupInteraction = activateInteraction ( ) ; opts . cleanupResizing = activateResizing ( ) ; autoFocus ( opts . focusedNode ) ; return response ; } , opts . hideBackdrop ) ; // ************************************ // Closure Functions // ************************************ /**        *  Attach the select DOM element(s) and animate to the correct positions        *  and scalings...        */ function showDropDown ( scope , element , opts ) { if ( opts . parent !== element . parent ( ) ) { element . parent ( ) . attr ( 'aria-owns' , element . attr ( 'id' ) ) ; } element . parent ( ) . find ( 'md-select-value' ) . attr ( 'aria-hidden' , 'true' ) ; opts . parent . append ( element ) ; return $q ( function ( resolve , reject ) { try { $animateCss ( element , { removeClass : 'md-leave' , duration : 0 } ) . start ( ) . then ( positionAndFocusMenu ) . then ( resolve ) ; } catch ( e ) { reject ( e ) ; } } ) ; } /**        * Initialize container and dropDown menu positions/scale, then animate        * to show.        */ function positionAndFocusMenu ( ) { return $q ( function ( resolve ) { if ( opts . isRemoved ) return $q . reject ( false ) ; var info = calculateMenuPositions ( scope , element , opts ) ; info . container . element . css ( animator . toCss ( info . container . styles ) ) ; info . dropDown . element . css ( animator . toCss ( info . dropDown . styles ) ) ; $$rAF ( function ( ) { element . addClass ( 'md-active' ) ; info . dropDown . element . css ( animator . toCss ( { transform : '' } ) ) ; autoFocus ( opts . focusedNode ) ; resolve ( ) ; } ) ; } ) ; } /**        * Show modal backdrop element...        */ function showBackdrop ( scope , element , options ) { // If we are not within a dialog... if ( options . disableParentScroll && ! $mdUtil . getClosest ( options . target , 'MD-DIALOG' ) ) { // !! DO this before creating the backdrop; since disableScrollAround() //    configures the scroll offset; which is used by mdBackDrop postLink() options . restoreScroll = $mdUtil . disableScrollAround ( options . element , options . parent ) ; } else { options . disableParentScroll = false ; } if ( options . hasBackdrop ) { // Override duration to immediately show invisible backdrop options . backdrop = $mdUtil . createBackdrop ( scope , "md-select-backdrop md-click-catcher" ) ; $animate . enter ( options . backdrop , $document [ 0 ] . body , null , { duration : 0 } ) ; } /**          * Hide modal backdrop element...          */ return function hideBackdrop ( ) { if ( options . backdrop ) options . backdrop . remove ( ) ; if ( options . disableParentScroll ) options . restoreScroll ( ) ; delete options . restoreScroll ; } ; } /**        *        */ function autoFocus ( focusedNode ) { if ( focusedNode && ! focusedNode . hasAttribute ( 'disabled' ) ) { focusedNode . focus ( ) ; } } /**        * Check for valid opts and set some sane defaults        */ function sanitizeAndConfigure ( scope , options ) { var selectEl = element . find ( 'md-select-menu' ) ; if ( ! options . target ) { throw new Error ( $mdUtil . supplant ( ERROR_TARGET_EXPECTED , [ options . target ] ) ) ; } angular . extend ( options , { isRemoved : false , target : angular . element ( options . target ) , // make sure it's not a naked DOM node parent : angular . element ( options . parent ) , selectEl : selectEl , contentEl : element . find ( 'md-content' ) , optionNodes : selectEl [ 0 ] . getElementsByTagName ( 'md-option' ) } ) ; } /**        * Configure various resize listeners for screen changes        */ function activateResizing ( ) { var debouncedOnResize = ( function ( scope , target , options ) { return function ( ) { if ( options . isRemoved ) return ; var updates = calculateMenuPositions ( scope , target , options ) ; var container = updates . container ; var dropDown = updates . dropDown ; container . element . css ( animator . toCss ( container . styles ) ) ; dropDown . element . css ( animator . toCss ( dropDown . styles ) ) ; } ; } ) ( scope , element , opts ) ; var window = angular . element ( $window ) ; window . on ( 'resize' , debouncedOnResize ) ; window . on ( 'orientationchange' , debouncedOnResize ) ; // Publish deactivation closure... return function deactivateResizing ( ) { // Disable resizing handlers window . off ( 'resize' , debouncedOnResize ) ; window . off ( 'orientationchange' , debouncedOnResize ) ; } ; } /**        *  If asynchronously loading, watch and update internal        *  '$$loadingAsyncDone' flag        */ function watchAsyncLoad ( ) { if ( opts . loadingAsync && ! opts . isRemoved ) { scope . $$loadingAsyncDone = false ; $q . when ( opts . loadingAsync ) . then ( function ( ) { scope . $$loadingAsyncDone = true ; delete opts . loadingAsync ; } ) . then ( function ( ) { $$rAF ( positionAndFocusMenu ) ; } ) ; } } /**        *        */ function activateInteraction ( ) { if ( opts . isRemoved ) return ; var dropDown = opts . selectEl ; var selectCtrl = dropDown . controller ( 'mdSelectMenu' ) || { } ; element . addClass ( 'md-clickable' ) ; // Close on backdrop click opts . backdrop && opts . backdrop . on ( 'click' , onBackdropClick ) ; // Escape to close // Cycling of options, and closing on enter dropDown . on ( 'keydown' , onMenuKeyDown ) ; dropDown . on ( 'click' , checkCloseMenu ) ; return function cleanupInteraction ( ) { opts . backdrop && opts . backdrop . off ( 'click' , onBackdropClick ) ; dropDown . off ( 'keydown' , onMenuKeyDown ) ; dropDown . off ( 'click' , checkCloseMenu ) ; element . removeClass ( 'md-clickable' ) ; opts . isRemoved = true ; } ; // ************************************ // Closure Functions // ************************************ function onBackdropClick ( e ) { e . preventDefault ( ) ; e . stopPropagation ( ) ; opts . restoreFocus = false ; $mdUtil . nextTick ( $mdSelect . hide , true ) ; } function onMenuKeyDown ( ev ) { ev . preventDefault ( ) ; ev . stopPropagation ( ) ; switch ( ev . keyCode ) { case keyCodes . UP_ARROW : return focusPrevOption ( ) ; case keyCodes . DOWN_ARROW : return focusNextOption ( ) ; case keyCodes . SPACE : case keyCodes . ENTER : var option = $mdUtil . getClosest ( ev . target , 'md-option' ) ; if ( option ) { dropDown . triggerHandler ( { type : 'click' , target : option } ) ; ev . preventDefault ( ) ; } checkCloseMenu ( ev ) ; break ; case keyCodes . TAB : case keyCodes . ESCAPE : ev . stopPropagation ( ) ; ev . preventDefault ( ) ; opts . restoreFocus = true ; $mdUtil . nextTick ( $mdSelect . hide , true ) ; break ; default : if ( shouldHandleKey ( ev , $mdConstant ) ) { var optNode = dropDown . controller ( 'mdSelectMenu' ) . optNodeForKeyboardSearch ( ev ) ; opts . focusedNode = optNode || opts . focusedNode ; optNode && optNode . focus ( ) ; } } } function focusOption ( direction ) { var optionsArray = $mdUtil . nodesToArray ( opts . optionNodes ) ; var index = optionsArray . indexOf ( opts . focusedNode ) ; var newOption ; do { if ( index === - 1 ) { // We lost the previously focused element, reset to first option index = 0 ; } else if ( direction === 'next' && index < optionsArray . length - 1 ) { index ++ ; } else if ( direction === 'prev' && index > 0 ) { index -- ; } newOption = optionsArray [ index ] ; if ( newOption . hasAttribute ( 'disabled' ) ) newOption = undefined ; } while ( ! newOption && index < optionsArray . length - 1 && index > 0 ) ; newOption && newOption . focus ( ) ; opts . focusedNode = newOption ; } function focusNextOption ( ) { focusOption ( 'next' ) ; } function focusPrevOption ( ) { focusOption ( 'prev' ) ; } function checkCloseMenu ( ev ) { if ( ev && ( ev . type == 'click' ) && ( ev . currentTarget != dropDown [ 0 ] ) ) return ; if ( mouseOnScrollbar ( ) ) return ; var option = $mdUtil . getClosest ( ev . target , 'md-option' ) ; if ( option && option . hasAttribute && ! option . hasAttribute ( 'disabled' ) ) { ev . preventDefault ( ) ; ev . stopPropagation ( ) ; if ( ! selectCtrl . isMultiple ) { opts . restoreFocus = true ; $mdUtil . nextTick ( function ( ) { $mdSelect . hide ( selectCtrl . ngModel . $viewValue ) ; } , true ) ; } } /**            * check if the mouseup event was on a scrollbar            */ function mouseOnScrollbar ( ) { var clickOnScrollbar = false ; if ( ev && ( ev . currentTarget . children . length > 0 ) ) { var child = ev . currentTarget . children [ 0 ] ; var hasScrollbar = child . scrollHeight > child . clientHeight ; if ( hasScrollbar && child . children . length > 0 ) { var relPosX = ev . pageX - ev . currentTarget . getBoundingClientRect ( ) . left ; if ( relPosX > child . querySelector ( 'md-option' ) . offsetWidth ) clickOnScrollbar = true ; } } return clickOnScrollbar ; } } } }

0<CODESPLIT>https://github.com/webdriverio/webdriverio/blob/8de7f1a3b12d97282ed4ee2e25e4c3c9a8940ac1/packages/wdio-sync/src/index.js#L159-L162<CODESPLIT><CODESPLIT>run hook or spec via executeSync<CODESPLIT>function ( testInterfaceFnNames , before , after , fnName , scope = global ) { const origFn = scope [ fnName ] scope [ fnName ] = wrapTestFunction ( fnName , origFn , testInterfaceFnNames , before , after ) /**      * support it.skip for the Mocha framework      */ if ( typeof origFn . skip === 'function' ) { scope [ fnName ] . skip = origFn . skip } /**      * wrap it.only for the Mocha framework      */ if ( typeof origFn . only === 'function' ) { const origOnlyFn = origFn . only scope [ fnName ] . only = wrapTestFunction ( fnName + '.only' , origOnlyFn , testInterfaceFnNames , before , after ) } }

1<CODESPLIT>https://github.com/neurospeech/web-atoms.js/blob/136a2d0987ef9fe492e99badf8ff177e9a2cc6ba/web-atoms.js#L3754-L3778<CODESPLIT><CODESPLIT>/ * Line 228 - AtomUI . js<CODESPLIT>function ( instance , methodName , create ) { /*Line 229 - 'AtomUI.js' */ if ( methodName && methodName . constructor != String ) /*Line 230 - 'AtomUI.js' */ throw new Error ( "methodName has to be string" ) ; /*Line 231 - 'AtomUI.js' */ var d = instance . __delegates ; /*Line 232 - 'AtomUI.js' */ if ( ! d ) { /*Line 233 - 'AtomUI.js' */ if ( ! create ) /*Line 234 - 'AtomUI.js' */ return null ; /*Line 235 - 'AtomUI.js' */ d = { } ; /*Line 236 - 'AtomUI.js' */ instance . __delegates = d ; /*Line 237 - 'AtomUI.js' */ } /*Line 238 - 'AtomUI.js' */ var m = d [ methodName ] ; /*Line 239 - 'AtomUI.js' */ if ( ! m ) { /*Line 240 - 'AtomUI.js' */ if ( ! create ) /*Line 241 - 'AtomUI.js' */ return null ; /*Line 242 - 'AtomUI.js' */ var f = instance [ methodName ] ; /*Line 243 - 'AtomUI.js' */ if ( ! f ) { /*Line 244 - 'AtomUI.js' */ throw new Error ( "method " + methodName + " not found" ) ; /*Line 245 - 'AtomUI.js' */ } /*Line 246 - 'AtomUI.js' */ m = function ( ) { /*Line 247 - 'AtomUI.js' */ return f . apply ( instance , arguments ) ; /*Line 248 - 'AtomUI.js' */ } ; /*Line 249 - 'AtomUI.js' */ d [ methodName ] = m ; /*Line 250 - 'AtomUI.js' */ } /*Line 251 - 'AtomUI.js' */ return m ; /*Line 252 - 'AtomUI.js' */ }

1<CODESPLIT>https://github.com/uber/npm-shrinkwrap/blob/21c8fab10259b599fc8e443ab41d3a3c85545069/index.js#L64-L290<CODESPLIT>npmShrinkwrap<CODESPLIT>/ * npm - shrinkwrap algorithm<CODESPLIT>function npmShrinkwrap ( opts , callback ) { if ( typeof opts === 'string' ) { opts = { dirname : opts } ; } var _warnings = null ; var _oldShrinkwrap = null ; getNPM ( ) . load ( { prefix : opts . dirname , dev : opts . dev , loglevel : 'error' } , verifyTree ) ; function verifyTree ( err , npm ) { if ( err ) { return callback ( err ) ; } // when running under `npm test` depth is set to 1 // reset it to a high number like 100 npm . config . set ( 'depth' , 100 ) ; npm . commands . ls ( [ ] , true , onls ) ; function onls ( err , _ , pkginfo ) { if ( err ) { return callback ( err ) ; } if ( pkginfo . problems ) { var error = NPMError ( pkginfo ) ; return callback ( error ) ; } verifyGit ( opts , onverify ) ; } function onverify ( err , errors ) { if ( err ) { return callback ( err ) ; } if ( errors . length === 0 ) { return onnpm ( null , npm ) ; } var error = ValidationError ( errors ) ; var invalid = find ( errors , function ( error ) { return error . type === 'invalid.git.version' ; } ) ; if ( invalid ) { error = ERRORS . InvalidVersionsNPMError ( { actual : invalid . actual , name : invalid . name , dirname : invalid . dirname , errors : error . errors } ) ; } var types = errors . reduce ( function ( acc , e ) { if ( acc . indexOf ( e . type ) === - 1 ) { acc . push ( e . type ) ; } return acc ; } , [ ] ) ; if ( opts . warnOnNotSemver && types . length === 1 && types [ 0 ] === 'gitlink.tag.notsemver' ) { _warnings = error . errors ; return onnpm ( null , npm ) ; } callback ( error ) ; } } function onnpm ( err , npm ) { if ( err ) { return callback ( err ) ; } var fileName = path . join ( opts . dirname , 'npm-shrinkwrap.json' ) ; readJSON ( fileName , onfile ) ; function onfile ( err , oldShrinkwrap ) { if ( err ) { // if no npm-shrinkwrap.json exists then just // create one npm . commands . shrinkwrap ( { } , true , onshrinkwrap ) ; return ; } _oldShrinkwrap = oldShrinkwrap ; /* npm.commands.shrinkwrap will blow away any                 extra keys that you set.                  We have to read extra keys & set them again                 after shrinkwrap is done             */ var keys = Object . keys ( oldShrinkwrap ) . filter ( function ( k ) { return [ 'name' , 'version' , 'dependencies' ] . indexOf ( k ) === - 1 ; } ) ; npm . commands . shrinkwrap ( { } , true , onwrapped ) ; function onwrapped ( err ) { if ( err ) { return callback ( err ) ; } readJSON ( fileName , onnewfile ) ; } function onnewfile ( err , newShrinkwrap ) { if ( err ) { return callback ( err ) ; } keys . forEach ( function ( k ) { if ( ! newShrinkwrap [ k ] ) { newShrinkwrap [ k ] = oldShrinkwrap [ k ] ; } } ) ; newShrinkwrap = sortedObject ( newShrinkwrap ) ; var buf = JSON . stringify ( newShrinkwrap , null , 2 ) + '\n' ; fs . writeFile ( fileName , buf , 'utf8' , onshrinkwrap ) ; } } } function onshrinkwrap ( err ) { if ( err ) { return callback ( err ) ; } setResolved ( opts , onResolved ) ; } function onResolved ( err ) { if ( err ) { return callback ( err ) ; } trimFrom ( opts , ontrim ) ; } function ontrim ( err ) { if ( err ) { return callback ( err ) ; } var fileName = path . join ( opts . dirname , 'npm-shrinkwrap.json' ) ; readJSON ( fileName , function ( err , newShrinkwrap ) { if ( err ) { return callback ( err ) ; } if ( _oldShrinkwrap ) { newShrinkwrap = trimNested ( _oldShrinkwrap , newShrinkwrap , opts ) ; } var buf = JSON . stringify ( newShrinkwrap , null , 2 ) + '\n' ; fs . writeFile ( fileName , buf , 'utf8' , function ( err ) { if ( err ) { return callback ( err ) ; } readJSON ( fileName , onfinalwrap ) ; } ) ; } ) ; } function onfinalwrap ( err , shrinkwrap ) { if ( err ) { return callback ( err ) ; } sync ( opts , function ( err ) { if ( err ) { return callback ( err ) ; } onsync ( null , shrinkwrap ) ; } ) ; } function onsync ( err , shrinkwrap ) { if ( err ) { return callback ( err ) ; } var warnings = _warnings ? _warnings : [ ] ; var errors = [ ] ; if ( opts . validators && Array . isArray ( opts . validators ) && opts . validators . length !== 0 ) { walkDeps ( shrinkwrap , function ( node , key , parent ) { var errs = opts . validators . map ( function ( f ) { return f ( node , key , parent ) ; } ) . filter ( Boolean ) ; if ( errs . length ) { errors = errors . concat ( errs ) ; } } ) ; } if ( errors . length ) { return callback ( ValidationError ( errors ) , warnings ) ; } callback ( null , warnings ) ; } }

1<CODESPLIT>https://github.com/facebook/fbjs/blob/f2493c0188263fd40d2e456e7567fbee3752fbbf/packages/fbjs/src/core/CSSCore.js#L65-L83<CODESPLIT><CODESPLIT>Removes the class passed in from the element<CODESPLIT>function ( element , className ) { invariant ( ! / \s / . test ( className ) , 'CSSCore.removeClass takes only a single class name. "%s" contains ' + 'multiple classes.' , className ) ; if ( className ) { if ( element . classList ) { element . classList . remove ( className ) ; } else if ( CSSCore . hasClass ( element , className ) ) { element . className = element . className . replace ( new RegExp ( '(^|\\s)' + className + '(?:\\s|$)' , 'g' ) , '$1' ) . replace ( / \s+ / g , ' ' ) // multiple spaces to one . replace ( / ^\s*|\s*$ / g , '' ) ; // trim the ends } } return element ; }

0<CODESPLIT>https://github.com/jamhall/s3rver/blob/9d24058ecb0abfc49781f2f2cb7389ab5f6b09c7/lib/middleware/website.js#L126-L148<CODESPLIT>onerror<CODESPLIT>Overrides Koa s redirect behavior with one more closely matching S3<CODESPLIT>async function onerror ( err ) { // don't do anything if there is no error. // this allows you to pass `this.onerror` // to node-style callbacks. if ( null == err ) return ; if ( ! ( err instanceof Error ) ) err = new Error ( format ( "non-error thrown: %j" , err ) ) ; let headerSent = false ; if ( this . headerSent || ! this . writable ) { headerSent = err . headerSent = true ; } // delegate this . app . emit ( "error" , err , this ) ; // nothing we can do here other // than delegate to the app-level // handler and log. if ( headerSent ) { return ; } const { res } = this ; if ( ! ( err instanceof S3Error ) ) { err = S3Error . fromError ( err ) ; } // first unset all headers res . getHeaderNames ( ) . filter ( name => ! name . match ( / ^access-control-|vary|x-amz- / i ) ) . forEach ( name => res . removeHeader ( name ) ) ; // (the presence of x-amz-error-* headers needs additional research) // this.set(err.headers); // force text/html this . type = "text/html" ; if ( ! err . description ) err . description = ` ${ err . status } ${ statuses [ err . status ] } ` ; // respond const { website } = this . state ; if ( err . code !== "NoSuchBucket" && err . code !== "UnsupportedQuery" && website . errorDocumentKey ) { // attempt to serve error document const object = await this . store . getObject ( this . params . bucket , website . errorDocumentKey ) ; if ( object ) { const objectRedirectLocation = object . metadata [ "x-amz-website-redirect-location" ] ; if ( objectRedirectLocation ) { object . content . destroy ( ) ; this . status = 301 ; this . redirect ( objectRedirectLocation ) ; res . end ( this . body ) ; } else { this . type = object . metadata [ "content-type" ] ; this . length = object . size ; object . content . pipe ( res ) ; } return ; } this . logger . error ( "Custom Error Document not found: " + website . errorDocumentKey ) ; const errorDocumentErr = new S3Error ( "NoSuchKey" , "The specified key does not exist." , { Key : website . errorDocumentKey } ) ; errorDocumentErr . description = "An Error Occurred While Attempting to Retrieve a Custom Error Document" ; err . errors . push ( errorDocumentErr ) ; } const msg = err . toHTML ( ) ; this . status = err . status ; this . length = Buffer . byteLength ( msg ) ; res . end ( msg ) ; }

0<CODESPLIT>https://github.com/wunderbyte/grunt-spiritual-dox/blob/5afcfe31ddbf7d654166aa15b938553b61de5811/src/js/guidox@wunderbyte.com/spirits/output/dox.TreeOutputSpirit.js#L72-L82<CODESPLIT>step2<CODESPLIT>/ * Split files from folders and sort them alphabetically .<CODESPLIT>function step2 ( map ) { var root = { name : "/" , nodes : [ ] } ; return ( function next ( map , parent , level ) { gui . Object . each ( map , function ( key , val ) { var node = { name : key } ; if ( typeof ( val ) === "object" ) { node . nodes = [ ] ; node . open = level < 1 ; next ( val , node , level + 1 ) ; } else { node . src = val ; } parent . nodes . push ( node ) ; } ) ; return parent ; } ) ( map , root , 0 ) ; }

0<CODESPLIT>https://github.com/daliworks/sensorjs/blob/07ae36740461c6c22ef44524e866c60de61d8aac/lib/sensor/driver/index.js#L118-L134<CODESPLIT>Device<CODESPLIT>/ * Actuator<CODESPLIT>function Device ( network , addr , modelId , sensorInfos ) { var self = this ; this . network = network ; this . address = addr ; this . modelId = modelId ; this . deviceHandle = { } ; this . url = [ 'sensorjs://' , network . sensorNetwork , addr ] . join ( '/' ) ; this . sensorUrls = [ ] ; _ . each ( sensorInfos , function ( sensorInfo ) { var url = [ self . url , sensorInfo . model , sensorInfo . id ] . join ( '/' ) ; if ( sensorInfo . options ) { url += '?' + querystring . stringify ( sensorInfo . options ) ; } self . sensorUrls . push ( url ) ; if ( sensorInfo . deviceHandle ) { // FIXME: not to manage sensor connection  //ex. futuretek snmp device connection self . deviceHandle [ sensorInfo . id ] = sensorInfo . deviceHandle ; } } ) ; EventEmitter . call ( this ) ; }

0<CODESPLIT>https://github.com/nordnet/cordova-universal-links-plugin/blob/9f2e812a0bf686279f94f68983707bc36efd7b11/hooks/lib/ios/appleAppSiteAssociationFile.js#L109-L122<CODESPLIT>getBundleId<CODESPLIT>Save data to the the apple - app - site - association file .<CODESPLIT>function getBundleId ( ) { if ( bundleId === undefined ) { var configXmlHelper = new ConfigXmlHelper ( context ) ; bundleId = configXmlHelper . getPackageName ( 'ios' ) ; } return bundleId ; }

1<CODESPLIT>https://github.com/erming/shout/blob/90a62c56af4412c6b0e0ae51fe84f3825f49e226/client/js/libs/stringcolor.js#L70-L76<CODESPLIT><CODESPLIT>Convert init to an RGBA<CODESPLIT>function ( i ) { var color = ( ( i >> 24 ) & 0xFF ) . toString ( 16 ) + ( ( i >> 16 ) & 0xFF ) . toString ( 16 ) + ( ( i >> 8 ) & 0xFF ) . toString ( 16 ) + ( i & 0xFF ) . toString ( 16 ) ; return color ; }

0<CODESPLIT>https://github.com/gethuman/pancakes-recipe/blob/ea3feb8839e2edaf1b4577c052b8958953db4498/utils/date.utils.js#L62-L77<CODESPLIT>datePlusFrequency<CODESPLIT>Recursively go through object and convert dates<CODESPLIT>function datePlusFrequency ( date , frequency ) { var minutes ; date = date || new Date ( ) ; // default is today frequency = frequency || 'hourly' ; // default is hourly switch ( frequency ) { case 'none' : minutes = 525949 ; // set far in future break ; case 'instant' : minutes = 1 ; break ; case 'hourly' : minutes = 60 ; break ; case 'daily' : minutes = 1440 ; break ; case 'weekly' : minutes = 10080 ; break ; default : minutes = 0 ; } return new Date ( date . getTime ( ) + ( minutes * 60000 ) ) ; }

1<CODESPLIT>https://github.com/SAP/openui5/blob/8a832fca01cb1cdf8df589788e0c5723e2a33c70/src/sap.ui.support/src/sap/ui/support/supportRules/Storage.js#L69-L90<CODESPLIT><CODESPLIT>Returns all previously created temporary rules .<CODESPLIT>function ( ) { var tempRules = [ ] , rawLSData ; try { rawLSData = localStorage . getItem ( constants . LOCAL_STORAGE_TEMP_RULES_KEY ) ; if ( ! rawLSData ) { return null ; } tempRules = JSON . parse ( decode ( rawLSData ) ) ; tempRules = tempRules . map ( function ( tempRule ) { return RuleSerializer . deserialize ( tempRule , true ) ; } ) ; } catch ( oError ) { // Swallow "Access Denied" exceptions in cross-origin scenarios. } return tempRules ; }

0<CODESPLIT>https://github.com/soajs/soajs.urac.driver/blob/b9b07dd5269b13d4fd5987ee2c5869d7eccba086/index.js#L17-L47<CODESPLIT>buildWebpack<CODESPLIT>Initialize the Business Logic model and set it on driver<CODESPLIT>function buildWebpack ( config , previousFileSizes ) { console . log ( 'Creating an optimized production build...' ) ; let compiler = webpack ( config ) ; return new Promise ( ( resolve , reject ) => { compiler . run ( ( err , stats ) => { let messages ; if ( err ) { if ( ! err . message ) { return reject ( err ) ; } messages = formatWebpackMessages ( { errors : [ err . message ] , warnings : [ ] , } ) ; } else { messages = formatWebpackMessages ( stats . toJson ( { all : false , warnings : true , errors : true } ) ) ; } if ( messages . errors . length ) { // Only keep the first error. Others are often indicative // of the same problem, but confuse the reader with noise. if ( messages . errors . length > 1 ) { messages . errors . length = 1 ; } return reject ( new Error ( messages . errors . join ( '\n\n' ) ) ) ; } if ( process . env . CI && ( typeof process . env . CI !== 'string' || process . env . CI . toLowerCase ( ) !== 'false' ) && messages . warnings . length ) { console . log ( chalk . yellow ( '\nTreating warnings as errors because process.env.CI = true.\n' + 'Most CI servers set it automatically.\n' ) ) ; return reject ( new Error ( messages . warnings . join ( '\n\n' ) ) ) ; } const resolveArgs = { stats , previousFileSizes , warnings : messages . warnings , } ; if ( writeStatsJson ) { return bfj . write ( paths . appBuild + '/bundle-stats.json' , stats . toJson ( ) ) . then ( ( ) => resolve ( resolveArgs ) ) . catch ( error => reject ( new Error ( error ) ) ) ; } return resolve ( resolveArgs ) ; } ) ; } ) ; }

0<CODESPLIT>https://github.com/ariatemplates/ariatemplates/blob/7ed5d065818ae159bf361c9dfb209b1cf3883c90/src/aria/utils/History.js#L449-L463<CODESPLIT><CODESPLIT>Remove old states that are present in the state store . States are considered old if they have been stored more than aria . utils . History . EXPIRATION_TIME seconds before<CODESPLIT>function ( ) { var id = this . _generateId ( ) ; this . _currentPos = stateMemory . states . length ; var stateEntry = { url : window . location . href . replace ( / #.*$ / , "" ) , id : id , title : window . document . title || "" , state : null } ; stateMemory . states . push ( stateEntry ) ; }

0<CODESPLIT>https://github.com/julesfern/spahql/blob/f2eff34e59f5af2e6a48f11f59f99c223b4a2be8/doc-html/js/spahql.js#L1348-L1351<CODESPLIT><CODESPLIT>SpahQL . QueryRunner . assert ( query rootData [ scopeData ] [ scopePath ] ) - > Boolean result - query ( SpahQL . Query ) : A parsed query instance - rootData ( Object ) : The root data context against which to run the query - scopeData ( Object ) : An optional additional data context which will be the local scope for this query . If not set will be set internally to <code > rootData< / code > . - scopePath ( String ) : An optional path indicating the scope to which this query has been restricted .<CODESPLIT>function ( primaryToken , secondaryToken , comparisonOperator , rootData , scopeData , scopePath ) { // Evaluate the tokens var primarySet = primaryToken . evaluate ( rootData , scopeData , scopePath ) ; var primaryValues = [ ] ; for ( var p in primarySet ) { primaryValues . push ( primarySet [ p ] . value ) ; } var secondarySet , secondaryValues ; if ( secondaryToken ) { secondarySet = secondaryToken . evaluate ( rootData , scopeData , scopePath ) ; secondaryValues = [ ] ; for ( var s in secondarySet ) { secondaryValues . push ( secondarySet [ s ] . value ) ; } } else { // No secondary token - just assert based on the primary set return SpahQL . DataHelper . truthySet ( primaryValues ) ; } var comparisonEval = comparisonOperator . evaluate ( rootData , scopeData ) ; var comparisonType = comparisonEval [ 0 ] . value ; // Now run the comparisons switch ( comparisonType ) { case SpahQL . Token . ComparisonOperator . COMPARISON_STRICT_EQUALITY : return SpahQL . DataHelper . eqSetStrict ( primaryValues , secondaryValues ) ; case SpahQL . Token . ComparisonOperator . COMPARISON_INEQUALITY : return ! ( SpahQL . DataHelper . eqSetStrict ( primaryValues , secondaryValues ) ) ; break ; case SpahQL . Token . ComparisonOperator . COMPARISON_ROUGH_EQUALITY : return SpahQL . DataHelper . eqSetRough ( primaryValues , secondaryValues ) ; break ; case SpahQL . Token . ComparisonOperator . COMPARISON_LT : return SpahQL . DataHelper . ltSet ( primaryValues , secondaryValues ) ; break ; case SpahQL . Token . ComparisonOperator . COMPARISON_GT : return SpahQL . DataHelper . gtSet ( primaryValues , secondaryValues ) ; break ; case SpahQL . Token . ComparisonOperator . COMPARISON_LTE : return SpahQL . DataHelper . lteSet ( primaryValues , secondaryValues ) ; break ; case SpahQL . Token . ComparisonOperator . COMPARISON_GTE : return SpahQL . DataHelper . gteSet ( primaryValues , secondaryValues ) ; break ; case SpahQL . Token . ComparisonOperator . COMPARISON_JOINT_SET : return SpahQL . DataHelper . jointSet ( primaryValues , secondaryValues ) ; break ; case SpahQL . Token . ComparisonOperator . COMPARISON_DISJOINT_SET : return ! ( SpahQL . DataHelper . jointSet ( primaryValues , secondaryValues ) ) ; break ; case SpahQL . Token . ComparisonOperator . COMPARISON_SUPERSET : return SpahQL . DataHelper . superSet ( primaryValues , secondaryValues ) ; break ; case SpahQL . Token . ComparisonOperator . COMPARISON_SUBSET : return SpahQL . DataHelper . superSet ( secondaryValues , primaryValues ) ; break ; } }

0<CODESPLIT>https://github.com/leonidas/transparency/blob/92149b83e7202423a764e1cc2ec5d78e43f77ce2/examples/todomvc/architecture-examples/backbone/js/views/app.js#L44-L70<CODESPLIT><CODESPLIT>Re - rendering the App just means refreshing the statistics -- the rest of the app doesn t change .<CODESPLIT>function ( todo ) { var view = new window . app . TodoView ( { model : todo , el : $ ( '#todo-template li' ) . clone ( ) } ) ; $ ( "#todo-list" ) . append ( view . render ( ) . el ) ; }

1<CODESPLIT>https://github.com/csokt/weblog-frontend/blob/45b003b35ddb8bf535d327952a987ed20eb4126a/src/scripts/app.js#L163-L176<CODESPLIT><CODESPLIT>###################################################################################################### WAMP comm ####<CODESPLIT>function ( ) { setups = { } model . servers = [ ] model . headers = [ ] model . ui = _ . clone ( uidefaults ) model . controls = _ . clone ( controldefaults ) if ( DEBUG ) { console . log ( 'discover started' ) } wampsession . publish ( 'discover' , [ ] ) setTimeout ( function ( ) { if ( DEBUG ) { console . log ( 'discover ended' ) } model . servers = _ . values ( setups ) } , 500 ) }

0<CODESPLIT>https://github.com/leocornus/leocornus-visualdata/blob/9d9714ca11c126f0250e650f3c1c4086709af3ab/src/bilevel-sunburst.js#L80-L123<CODESPLIT>Plugin<CODESPLIT>initialize function<CODESPLIT>function Plugin ( element , options , jsonData ) { // same the DOM element. this . element = element ; this . jsonData = jsonData ; // merge the options. // the jQuery extend function, the later object will // overwrite the former object. this . options = $ . extend ( { } , defaultOptions , options ) ; // set the plugin name. this . _name = pluginName ; // call the initialize function. this . init ( ) ; }

0<CODESPLIT>https://github.com/marceljuenemann/angular-drag-and-drop-lists/blob/7e98e194a8d66fa735bf6dc7c3e39886287b914e/angular-drag-and-drop-lists.js#L553-L562<CODESPLIT>invokeCallback<CODESPLIT>Tries to find a child element that has the dndPlaceholder class set . If none was found a new li element is created .<CODESPLIT>function invokeCallback ( expression , event , dropEffect , itemType , index , item ) { return $parse ( expression ) ( scope , { callback : dndState . callback , dropEffect : dropEffect , event : event , external : ! dndState . isDragging , index : index !== undefined ? index : getPlaceholderIndex ( ) , item : item || undefined , type : itemType } ) ; }

0<CODESPLIT>https://github.com/aantthony/javascript-cas/blob/d13ca4eb1a8aee3b712a8d48e06280b87bf96ed3/examples/solver.js#L3-L20<CODESPLIT>fromString<CODESPLIT>Does not work!!! but a general idea of how it would once bugs are fixed .<CODESPLIT>function fromString ( str ) { const bytes = [ ] ; for ( let n = 0 , l = str . length ; n < l ; n ++ ) { const hex = Number ( str . charCodeAt ( n ) ) . toString ( 16 ) ; bytes . push ( hex ) ; } return '0x' + bytes . join ( '' ) ; }

1<CODESPLIT>https://github.com/adobe-webplatform/Snap.svg/blob/b242f49e6798ac297a3dad0dfb03c0893e394464/src/paper.js#L587-L613<CODESPLIT>GsetStops<CODESPLIT>/ * \ Element . setStops [ method ] * Only for gradients! Updates stops of the gradient based on passed gradient descriptor . See<CODESPLIT>function GsetStops ( str ) { var grad = str , stops = this . stops ( ) ; if ( typeof str == "string" ) { grad = eve ( "snap.util.grad.parse" , null , "l(0,0,0,1)" + str ) . firstDefined ( ) . stops ; } if ( ! Snap . is ( grad , "array" ) ) { return ; } for ( var i = 0 ; i < stops . length ; i ++ ) { if ( grad [ i ] ) { var color = Snap . color ( grad [ i ] . color ) , attr = { "offset" : grad [ i ] . offset + "%" } ; attr [ "stop-color" ] = color . hex ; if ( color . opacity < 1 ) { attr [ "stop-opacity" ] = color . opacity ; } stops [ i ] . attr ( attr ) ; } else { stops [ i ] . remove ( ) ; } } for ( i = stops . length ; i < grad . length ; i ++ ) { this . addStop ( grad [ i ] . color , grad [ i ] . offset ) ; } return this ; }

1<CODESPLIT>https://github.com/sentanos/roblox-js/blob/ded0d976e0691cf7bb771d06fee196e621633e29/lib/group/getShout.js#L13-L36<CODESPLIT>getShout<CODESPLIT>Define<CODESPLIT>function getShout ( jar , group ) { var httpOpt = { url : '//www.roblox.com/My/Groups.aspx?gid=' + group , options : { jar : jar } } ; return http ( httpOpt ) . then ( function ( body ) { var $ = parser . load ( body ) ; var field = $ ( '#ctl00_cphRoblox_GroupStatusPane_StatusTextField' ) ; if ( field . length > 0 ) { var poster = $ ( '#ctl00_cphRoblox_GroupStatusPane_StatusPoster' ) ; return { message : field . text ( ) , author : { name : poster . text ( ) , id : poster . attr ( 'href' ) . match ( / \d+ / ) [ 0 ] } , date : getDate ( { time : $ ( '#ctl00_cphRoblox_GroupStatusPane_StatusDate' ) . text ( ) , timezone : 'CT' } ) } ; } } ) ; }

1<CODESPLIT>https://github.com/adiwidjaja/frontend-pagebuilder/blob/a08caa06cd9f919d575eb68f0d6b56fdedfb7d0f/js/tinymce/plugins/help/plugin.js#L849-L856<CODESPLIT><CODESPLIT>objectMap :: ( JsObj ( k v ) ( v k JsObj ( k v ) - > x )) - > JsObj ( k x )<CODESPLIT>function ( obj , f ) { return tupleMap ( obj , function ( x , i , obj ) { return { k : i , v : f ( x , i , obj ) } ; } ) ; }

1<CODESPLIT>https://github.com/BranchMetrics/cordova-ionic-phonegap-branch-deep-linking/blob/252f591fcc833ac9fe7fb0f535d351e0879a873c/examples/phonegap1/plugins/cordova-plugin-globalization/www/firefoxos/l10n_date.js#L145-L180<CODESPLIT>prettyDate<CODESPLIT>Returns a translated string which respresents the relative time before or after a date .<CODESPLIT>function prettyDate ( time , useCompactFormat , maxDiff ) { maxDiff = maxDiff || 86400 * 10 ; // default = 10 days switch ( time . constructor ) { case String : // timestamp time = parseInt ( time ) ; break ; case Date : time = time . getTime ( ) ; break ; } var secDiff = ( Date . now ( ) - time ) / 1000 ; if ( isNaN ( secDiff ) ) { return _ ( 'incorrectDate' ) ; } if ( Math . abs ( secDiff ) > 60 ) { // round milliseconds up if difference is over 1 minute so the result is // closer to what the user would expect (1h59m59s300ms diff should return // "in 2 hours" instead of "in an hour") secDiff = secDiff > 0 ? Math . ceil ( secDiff ) : Math . floor ( secDiff ) ; } if ( secDiff > maxDiff ) { return localeFormat ( new Date ( time ) , '%x' ) ; } var f = useCompactFormat ? '-short' : '-long' ; var parts = relativeParts ( secDiff ) ; var affix = secDiff >= 0 ? '-ago' : '-until' ; for ( var i in parts ) { return _ ( i + affix + f , { value : parts [ i ] } ) ; } }

1<CODESPLIT>https://github.com/JamieMason/shrinkpack/blob/c50981efa474123b5753a38cd14c35a798e529d9/src/lib/delete-file.js#L8-L19<CODESPLIT>deleteFile<CODESPLIT>implementation<CODESPLIT>function deleteFile ( location ) { return fs . unlink ( location ) . then ( onSuccess , onError ) ; function onSuccess ( ) { return location ; } function onError ( ) { throw new Error ( '! failed to delete ' + location ) ; } }

1<CODESPLIT>https://github.com/b-heilman/bmoor/blob/b21a315b477093c14e5f32d857b4644a5a0a36fd/src/array.js#L218-L237<CODESPLIT>intersection<CODESPLIT>I could probably make this sexier like allow uniqueness algorithm but I m keeping it simple for now<CODESPLIT>function intersection ( arr1 , arr2 ) { var rtn = [ ] ; if ( arr1 . length > arr2 . length ) { let t = arr1 ; arr1 = arr2 ; arr2 = t ; } for ( let i = 0 , c = arr1 . length ; i < c ; i ++ ) { let d = arr1 [ i ] ; if ( arr2 . indexOf ( d ) !== - 1 ) { rtn . push ( d ) ; } } return rtn ; }

0<CODESPLIT>https://github.com/soney/constraintjs/blob/98a164063efc8d3b59a372b332c7a3e0a1292561/src/map.js#L370-L376<CODESPLIT><CODESPLIT>Deallocate memory from constraints<CODESPLIT>function ( index , silent ) { var info = this . _ordered_values [ index ] ; _destroy_info ( this . _ordered_values . splice ( index , 1 ) , silent ) ; if ( silent !== true ) { this . $size . invalidate ( ) ; } }

0<CODESPLIT>https://github.com/datanews/tables/blob/4b33aa7a944a93260c49baecbb90345211cac789/lib/db.js#L86-L102<CODESPLIT>bulkUpsert<CODESPLIT>Mysql query format bulk upsert<CODESPLIT>function bulkUpsert ( connection , model , data , done ) { var query ; var n = connection . connectionManager . dialectName ; // Note that the UPSERT type is needed so that SQLite can run multiple statements, // specifically use the .exec method of the underlying sqlite library. var options = { type : connection . QueryTypes . UPSERT , raw : true } ; // Make query based on dialiect if ( n === "mysql" || n === "mariadb" || n === "mysqli" ) { query = mysqlBulkUpsert ( model , data ) ; } else if ( n === "sqlite" ) { query = sqliteBulkUpsert ( model , data ) ; } else if ( n === "pgsql" || n === "postgres" ) { query = pgsqlBulkUpsert ( model , data ) ; options . type = connection . QueryTypes . INSERT ; } // Run query if ( _ . isObject ( query ) ) { options . replacements = query . replacements ; runQuery ( connection , query . query , options , done ) ; } else if ( query ) { runQuery ( connection , query , options , done ) ; } else { done ( new Error ( "Could not create query for bulkUpsert." ) ) ; } }

1<CODESPLIT>https://github.com/h1bomb/yo/blob/11a05222d4fd1c0b5e8239672058f3d0d93aad44/examples/yo.yohobuy-mobile/client/gulpfile.js#L206-L236<CODESPLIT>libPkgPre<CODESPLIT>库文件的入口文件和过程文件的生成<CODESPLIT>function libPkgPre ( ) { var obj = { name : '' , version : config . version , spm : config . spm } , libCon , libsjs = '' , key , libDir = dist_dir . js + '' ; obj . spm . main = 'libs.js' ; obj . spm . buildArgs = '--idleading {{name}} --include all' ; libCon = JSON . stringify ( obj ) ; fs . renameSync ( 'package.json' , 'package_bak.json' ) ; fs . writeFileSync ( 'package.json' , libCon ) ; //生成库文件pkg配置 var packages = [ ] ; for ( key in obj . spm . dependencies ) { if ( obj . spm . inside [ key ] ) { packages . push ( obj . spm . inside [ key ] ) ; } else { packages . push ( key ) ; } } for ( var i = 0 ; i < packages . length ; i ++ ) { libsjs += "require('" + packages [ i ] + "');" ; } fs . writeFileSync ( 'libs.js' , libsjs ) ; //写入口文件 return libDir ; }

0<CODESPLIT>https://github.com/Akryum/v-tooltip/blob/d60513c64c266f0c1e926e2e583a5733819138bd/dist/v-tooltip.esm.js#L2125-L2130<CODESPLIT>assocIndexOf<CODESPLIT>Gets the list cache value for key .<CODESPLIT>function assocIndexOf ( array , key ) { var length = array . length ; while ( length -- ) { if ( eq_1 ( array [ length ] [ 0 ] , key ) ) { return length ; } } return - 1 ; }

0<CODESPLIT>https://github.com/postmanlabs/newman/blob/c05a5a1e82aa3c2021e94ba09e627ba4718af69e/lib/reporters/cli/cli-utils.js#L112-L129<CODESPLIT><CODESPLIT>A CLI utility helper method that generates a color inspector function for CLI reports .<CODESPLIT>function ( color ) { return ( color === 'off' ) || ( color !== 'on' ) && ( Boolean ( process . env . CI ) || ! process . stdout . isTTY ) ; // eslint-disable-line no-process-env }

1<CODESPLIT>https://github.com/fex-team/fis3/blob/7327d6c933172fbb96b8fe940d07eaee5fad30c9/lib/compile.js#L321-L358<CODESPLIT>extJs<CODESPLIT>标准化处理 javascript 内容 识别 __inline、__uri 和 __require 的用法，并将其转换成中间码。<CODESPLIT>function extJs ( content , callback , file ) { var reg = / "(?:[^\\"\r\n\f]|\\[\s\S])*"|'(?:[^\\'\n\r\f]|\\[\s\S])*'|(\/\/[^\r\n\f]+|\/\*[\s\S]*?(?:\*\/|$))|\b(__inline|__uri|__require|__id|__moduleId|__hash)\s*\(\s*("(?:[^\\"\r\n\f]|\\[\s\S])*"|'(?:[^\\'\n\r\f]|\\[\s\S])*')\s*\) / g ; callback = callback || function ( m , comment , type , value ) { if ( type ) { switch ( type ) { case '__inline' : m = map . jsEmbed . wrap ( value ) ; break ; case '__uri' : m = map . uri . wrap ( value ) ; break ; case '__id' : m = map . id . wrap ( value ) ; break ; case '__moduleId' : m = map . moduleId . wrap ( value ) ; break ; case '__require' : m = 'require(' + map . jsRequire . wrap ( value ) + ')' ; break ; case '__hash' : m = map . hash . wrap ( value ) ; break ; } } else if ( comment ) { m = analyseComment ( comment ) ; } return m ; } ; content = content . replace ( reg , callback ) ; var info = { file : file , content : content } ; fis . emit ( 'standard:js' , info ) ; return info . content ; }

0<CODESPLIT>https://github.com/nikgraf/belle/blob/e0f561d6ad704b5e3d66a38752de29f938b065af/src/utils/inject-style.js#L37-L50<CODESPLIT>updateStore<CODESPLIT>Constructs all the stored styles & injects them to the DOM .<CODESPLIT>function updateStore ( styleId , style , pseudoClass , disabled ) { styleStorage [ styleId ] = styleStorage [ styleId ] || { } ; if ( disabled ) { styleStorage [ styleId ] . disabledPseudoClasses = styleStorage [ styleId ] . disabledPseudoClasses || { } ; styleStorage [ styleId ] . disabledPseudoClasses [ pseudoClass ] = style ; } else { styleStorage [ styleId ] . pseudoClasses = styleStorage [ styleId ] . pseudoClasses || { } ; styleStorage [ styleId ] . pseudoClasses [ pseudoClass ] = style ; } }

0<CODESPLIT>https://github.com/3vot/3vot-salesforce-proxy/blob/33d57379217600c5bd684918d624ce52c83b875e/routes/login.js#L112-L138<CODESPLIT>SCAMP<CODESPLIT>Callback for the Salesforce Server Dance Auth Leg 2 adds the auth token to session<CODESPLIT>function SCAMP ( uid , options ) { EventEmitter . call ( this ) ; // #0 process the options this . c = ( options && options . c ) || 0 ; this . lease = ( options && options . lease ) || false ; this . waitSTUN = ( options && options . waitSTUN ) || 1500 ; this . weightUpdate = ( options && options . weightUpdate ) || 30000 ; this . linkFactory = new LinkFactory ( options && options . webRTCConf ) ; // #1 connection state: "connected", "partial", "disconnect" this . state = "disconnect" ; // #2 uid x counter to ensure uniqueness of broadcast messages this . uid = uid ; this . counter = 0 ; // for membership protocol // #3 neighbourhood partial views for the membership: uid->(link x weight) this . partialView = new ViewArray ( ) ; this . inView = new ViewArray ( ) ; // #4 webRTC pending messages (TODO) remove from sub this . sub = [ ] ; this . pending = new PendingArray ( ) ; // #5 register the callbacks this . callbacks = new CallbackArray ( ) ; // #6 backtracking messages using (uid x counter) -> FromChannel this . backtrack = LRU ( 500 ) ; // #7 update the weights associated with the inView and partialView var self = this ; setInterval ( function ( ) { self . updateWeights ( ) ; } , this . weightUpdate ) ; // #8 regularly renew the lease, i.e., resubscribe to the network if ( this . lease ) { setInterval ( function ( ) { self . onLeaseOver ( ) ; } , this . lease ) ; } ; }

1<CODESPLIT>https://github.com/MakerCollider/node-red-contrib-smartnode-hook/blob/245c267e832968bad880ca009929043e82c7bc25/html/scripts/highchart/highcharts-more.src.js#L2016-L2028<CODESPLIT><CODESPLIT>Get the series symbol in the legend<CODESPLIT>function ( legend , item ) { var radius = pInt ( legend . itemStyle . fontSize ) / 2 ; item . legendSymbol = this . chart . renderer . circle ( radius , legend . baseline - radius , radius ) . attr ( { zIndex : 3 } ) . add ( item . legendGroup ) ; item . legendSymbol . isMarker = true ; }

1<CODESPLIT>https://github.com/BinaryMuse/planetary.js/blob/838bf922655bdc7e501b3eb59c8e162a20d43f41/site/public/examples/quake/quake.js#L193-L202<CODESPLIT>autoscale<CODESPLIT>Plugin to automatically scale the planet s projection based on the window size when the planet is initialized<CODESPLIT>function autoscale ( options ) { options = options || { } ; return function ( planet ) { planet . onInit ( function ( ) { var width = window . innerWidth + ( options . extraWidth || 0 ) ; var height = window . innerHeight + ( options . extraHeight || 0 ) ; planet . projection . scale ( Math . min ( width , height ) / 2 ) ; } ) ; } ; }

1<CODESPLIT>https://github.com/canjs/can-connect/blob/513064178e1b229349cc219949aa69380c871a52/real-time/real-time.js#L379-L390<CODESPLIT><CODESPLIT>@function can - connect / real - time / real - time . destroyedData destroyedData @parent can - connect / real - time / real - time . callbacks<CODESPLIT>function ( props , params ) { var id = this . id ( params || props ) ; var instance = this . instanceStore . get ( id ) ; if ( ! instance ) { instance = this . hydrateInstance ( props ) ; } var serialized = this . serializeInstance ( instance ) ; this . destroyedInstance ( instance , props ) ; // we can pre-register it so everything else finds it destroy . call ( this , serialized ) ; return undefined ; }

1<CODESPLIT>https://github.com/andywer/postcss-debug/blob/e245354e057b230c008f5b4a72096d134c2fe8cf/webdebugger/build/app.js#L20239-L20257<CODESPLIT>stopWatchingForValueChange<CODESPLIT>( For IE < = 11 ) Removes the event listeners from the currently - tracked element if any exists .<CODESPLIT>function stopWatchingForValueChange ( ) { if ( ! activeElement ) { return ; } // delete restores the original property definition delete activeElement . value ; if ( activeElement . detachEvent ) { activeElement . detachEvent ( 'onpropertychange' , handlePropertyChange ) ; } else { activeElement . removeEventListener ( 'propertychange' , handlePropertyChange , false ) ; } activeElement = null ; activeElementInst = null ; activeElementValue = null ; activeElementValueProp = null ; }

1<CODESPLIT>https://github.com/staruml/metadata-json/blob/4a6ea9b93dd426cc8e874daa3ca6aef72ac5bcbb/core/Repository.js#L1282-L1290<CODESPLIT>search<CODESPLIT>Search elements by keyword and type<CODESPLIT>function search ( keyword , typeFilter ) { keyword = keyword . toLowerCase ( ) ; typeFilter = typeFilter || type . Element ; var results = findAll ( function ( elem ) { var name = elem . name ? elem . name . toLowerCase ( ) : "" ; return ( name . indexOf ( keyword ) > - 1 && elem instanceof typeFilter ) ; } ) ; return results ; }

1<CODESPLIT>https://github.com/anywhichway/wsfetch/blob/74d81a9537a748e9c6c04ffccf74f71b5eebddfa/javascript/ractive.js#L4772-L4782<CODESPLIT><CODESPLIT>Called when creating a new component definition<CODESPLIT>function ( Parent , proto , options ) { if ( ! options . css ) return ; var id = uuid ( ) ; var styles = options . noCssTransform ? options . css : transformCss ( options . css , id ) ; proto . cssId = id ; addCSS ( { id : id , styles : styles } ) ; }

0<CODESPLIT>https://github.com/nymag/nymag-fs/blob/94dcd3be2c0593b676131a9760c2318c75255a71/index.js#L113-L121<CODESPLIT>memoize<CODESPLIT>Try to get a module or return false .<CODESPLIT>function memoize ( fn ) { const dataProp = '__data__.string.__data__' , memFn = _ . memoize . apply ( _ , _ . slice ( arguments ) ) , report = _ . throttle ( reportMemoryLeak , minute ) , controlFn = function ( ) { const result = memFn . apply ( null , _ . slice ( arguments ) ) ; if ( _ . size ( _ . get ( memFn , ` ${ dataProp } ` ) ) >= memoryLeakThreshold ) { report ( fn , _ . get ( memFn , ` ${ dataProp } ` ) ) ; } return result ; } ; Object . defineProperty ( controlFn , 'cache' , defineWritable ( { get ( ) { return memFn . cache ; } , set ( value ) { memFn . cache = value ; } } ) ) ; return controlFn ; }

1<CODESPLIT>https://github.com/ubilabs/geocomplete/blob/7ce2f83ac4b621b6816f85eaede8f03595e58c9a/jquery.geocomplete.js#L533-L537<CODESPLIT><CODESPLIT>Restore the old position of the marker to the last knwon location .<CODESPLIT>function ( ) { this . marker . setPosition ( this . data . location ) ; this . setDetail ( this . details . lat , this . data . location . lat ( ) ) ; this . setDetail ( this . details . lng , this . data . location . lng ( ) ) ; }

0<CODESPLIT>https://github.com/dagrejs/dagre/blob/ec3fd32a2ae9eb413aea5b8bd31fac652a9b6a5e/lib/rank/network-simplex.js#L71-L77<CODESPLIT>calcCutValue<CODESPLIT>/ * Initializes cut values for all edges in the tree .<CODESPLIT>function calcCutValue ( t , g , child ) { var childLab = t . node ( child ) ; var parent = childLab . parent ; // True if the child is on the tail end of the edge in the directed graph var childIsTail = true ; // The graph's view of the tree edge we're inspecting var graphEdge = g . edge ( child , parent ) ; // The accumulated cut value for the edge between this node and its parent var cutValue = 0 ; if ( ! graphEdge ) { childIsTail = false ; graphEdge = g . edge ( parent , child ) ; } cutValue = graphEdge . weight ; _ . forEach ( g . nodeEdges ( child ) , function ( e ) { var isOutEdge = e . v === child , other = isOutEdge ? e . w : e . v ; if ( other !== parent ) { var pointsToHead = isOutEdge === childIsTail , otherWeight = g . edge ( e ) . weight ; cutValue += pointsToHead ? otherWeight : - otherWeight ; if ( isTreeEdge ( t , child , other ) ) { var otherCutValue = t . edge ( child , other ) . cutvalue ; cutValue += pointsToHead ? - otherCutValue : otherCutValue ; } } } ) ; return cutValue ; }

1<CODESPLIT>https://github.com/wilmoore/string-split.js/blob/3584c106212c45c7a26c9f9b4f2b70e3b3b07d07/index.js#L29-L33<CODESPLIT>split<CODESPLIT>A curried String . prototype . split with support for splitting by String RegExp or Function .<CODESPLIT>function split ( splitBy , string ) { return ( typeof splitBy === 'function' ) ? predicate ( splitBy , string ) : string . split ( splitBy ) }

0<CODESPLIT>https://github.com/immersive-web/cardboard-vr-display/blob/de59375309e637edbd3fd5e5213eac602930bb2b/src/sensor-fusion/complementary-filter.js#L34-L63<CODESPLIT>CardboardUI<CODESPLIT>An implementation of a simple complementary filter which fuses gyroscope and accelerometer data from the devicemotion event .<CODESPLIT>function CardboardUI ( gl ) { this . gl = gl ; this . attribs = { position : 0 } ; this . program = Util . linkProgram ( gl , uiVS , uiFS , this . attribs ) ; this . uniforms = Util . getProgramUniforms ( gl , this . program ) ; this . vertexBuffer = gl . createBuffer ( ) ; this . gearOffset = 0 ; this . gearVertexCount = 0 ; this . arrowOffset = 0 ; this . arrowVertexCount = 0 ; this . projMat = new Float32Array ( 16 ) ; this . listener = null ; this . onResize ( ) ; }

0<CODESPLIT>https://github.com/phun-ky/patsy/blob/b2bf3e6c72e17c38d9b2cf2fa4306478fc3858a5/lib/patsy.js#L245-L291<CODESPLIT><CODESPLIT>Function to check current input from stdin<CODESPLIT>function ( config ) { var patsy = this ; this . scripture . print ( '[Patsy]' . yellow + ': Just putting my rucksack on my Lord!' ) ; if ( typeof config !== 'undefined' && typeof config === 'object' ) { this . scripture . print ( '[Patsy]' . yellow + ': And yes, the scripture is in my rucksack, I just checked.' ) ; this . project_cfg = config ; // We have a gonfig, set up the application this . setup ( ) ; if ( opts . verbose || config . options . verbose || false ) { util . print ( '>>' . cyan + ' Changing directory to : ' + opts . app_path . inverse . cyan + '...\n' ) ; } try { process . chdir ( opts . app_path ) ; } catch ( e ) { console . trace ( ) ; patsy . utils . fail ( 'Could not change directory!' ) ; console . log ( e ) ; } if ( typeof config . proxy !== 'undefined' ) { if ( opts . verbose || config . options . verbose || false ) { util . print ( 'Loading the Proxy\n' . bold ) ; } try { /**              * Require proxy from the library              *              * @var     Object              * @source  patsy              */ var proxy = require ( './proxy/' ) ( { verbose : opts . verbose || config . options . verbose || config . proxy . options . verbose || false , patsy : patsy } ) ; proxy . start ( config ) ; } catch ( e ) { patsy . utils . fail ( 'Could not load proxy!' ) ; console . trace ( ) ; console . log ( e ) ; } } if ( typeof config . fileserver !== 'undefined' ) { if ( opts . verbose || config . options . verbose || false ) { util . print ( 'Loading the Fileserver\n' . bold ) ; } try { /**              * Require fileserver from the library              *              * @var     Object              * @source  patsy              */ var fileserver = require ( './fileserver' ) ( config ) ; fileserver . load ( patsy ) ; } catch ( ex ) { patsy . utils . fail ( 'Could not load fileserver!' ) ; console . trace ( ) ; console . log ( ex ) ; } } try { if ( opts . verbose || config . options . verbose || false ) { util . print ( 'Loading Grunt, The JavaScript Task Runner\n' . bold ) ; } this . loadGrunt ( config ) ; } catch ( ex ) { patsy . utils . fail ( 'Could not load Grunt!' ) ; console . trace ( ) ; console . log ( ex ) ; } } }

0<CODESPLIT>https://github.com/adobe/brackets/blob/d5d00d43602c438266d32b8eda8f8a3ca937b524/src/extensions/default/JavaScriptCodeHints/main.js#L123-L130<CODESPLIT>getHintResponse<CODESPLIT>Sets the configuration generally for testing / debugging use . Configuration keys are merged into the current configuration . The Tern worker is automatically updated to the new config as well .<CODESPLIT>function getHintResponse ( hints , query , type ) { var trimmedQuery , formattedHints ; if ( setConfig . config . debug ) { console . debug ( "Hints" , _ . pluck ( hints , "label" ) ) ; } function formatTypeDataForToken ( $hintObj , token ) { if ( ! hintDetailsEnabled ) { return ; } $hintObj . addClass ( 'brackets-js-hints-with-type-details' ) ; ( function _appendLink ( ) { if ( token . url ) { $ ( '<a></a>' ) . appendTo ( $hintObj ) . addClass ( "jshint-link" ) . attr ( 'href' , token . url ) . on ( "click" , function ( event ) { event . stopImmediatePropagation ( ) ; event . stopPropagation ( ) ; } ) ; } } ( ) ) ; if ( token . type ) { if ( token . type . trim ( ) !== '?' ) { if ( token . type . length < 30 ) { $ ( '<span>' + token . type . split ( '->' ) . join ( ':' ) . toString ( ) . trim ( ) + '</span>' ) . appendTo ( $hintObj ) . addClass ( "brackets-js-hints-type-details" ) ; } $ ( '<span>' + token . type . split ( '->' ) . join ( ':' ) . toString ( ) . trim ( ) + '</span>' ) . appendTo ( $hintObj ) . addClass ( "jshint-description" ) ; } } else { if ( token . keyword ) { $ ( '<span>keyword</span>' ) . appendTo ( $hintObj ) . addClass ( "brackets-js-hints-keyword" ) ; } } if ( token . doc ) { $hintObj . attr ( 'title' , token . doc ) ; $ ( '<span></span>' ) . text ( token . doc . trim ( ) ) . appendTo ( $hintObj ) . addClass ( "jshint-jsdoc" ) ; } } /*          * Returns a formatted list of hints with the query substring          * highlighted.          *          * @param {Array.<Object>} hints - the list of hints to format          * @param {string} query - querystring used for highlighting matched          *      poritions of each hint          * @return {jQuery.Deferred|{          *              hints: Array.<string|jQueryObject>,          *              match: string,          *              selectInitial: boolean,          *              handleWideResults: boolean}}          */ function formatHints ( hints , query ) { return hints . map ( function ( token ) { var $hintObj = $ ( "<span>" ) . addClass ( "brackets-js-hints" ) ; // level indicates either variable scope or property confidence if ( ! type . property && ! token . builtin && token . depth !== undefined ) { switch ( token . depth ) { case 0 : $hintObj . addClass ( "priority-high" ) ; break ; case 1 : $hintObj . addClass ( "priority-medium" ) ; break ; case 2 : $hintObj . addClass ( "priority-low" ) ; break ; default : $hintObj . addClass ( "priority-lowest" ) ; break ; } } if ( token . guess ) { $hintObj . addClass ( "guess-hint" ) ; } // is the token a keyword? if ( token . keyword ) { $hintObj . addClass ( "keyword-hint" ) ; } if ( token . literal ) { $hintObj . addClass ( "literal-hint" ) ; } // highlight the matched portion of each hint if ( token . stringRanges ) { token . stringRanges . forEach ( function ( item ) { if ( item . matched ) { $hintObj . append ( $ ( "<span>" ) . append ( _ . escape ( item . text ) ) . addClass ( "matched-hint" ) ) ; } else { $hintObj . append ( _ . escape ( item . text ) ) ; } } ) ; } else { $hintObj . text ( token . value ) ; } $hintObj . data ( "token" , token ) ; formatTypeDataForToken ( $hintObj , token ) ; return $hintObj ; } ) ; } // trim leading and trailing string literal delimiters from the query trimmedQuery = _ . trim ( query , HintUtils . SINGLE_QUOTE + HintUtils . DOUBLE_QUOTE ) ; if ( hints ) { formattedHints = formatHints ( hints , trimmedQuery ) ; } else { formattedHints = [ ] ; } return { hints : formattedHints , match : null , // the CodeHintManager should not format the results selectInitial : true , handleWideResults : hints . handleWideResults } ; }

0<CODESPLIT>https://github.com/adrai/node-cqrs-eventdenormalizer/blob/fd3411044e0673bd1b3613832599d6e85c456fea/lib/definitions/collection.js#L16-L32<CODESPLIT><CODESPLIT>Collection constructor<CODESPLIT>function ( parser , expr , param ) { if ( param . isConditional ( ) ) { // TODO: not sure what this will output parser . state . current . addDependency ( new RequireHeaderDependency ( expr . callee . range ) ) ; param . options . forEach ( function ( param ) { var result = parser . applyPluginsBailResult ( "call require:commonjs:item" , expr , param ) ; if ( result === undefined ) { throw new Error ( "Cannot convert options with mixed known and unknown stuff" ) ; } } ) ; return true ; } if ( param . isString ( ) ) { var dep ; var localModule = LocalModulesHelpers . getLocalModule ( parser . state , param . string ) ; if ( localModule ) { return true ; } dep = new AngularModuleDependency ( param . string , param . range ) ; dep . loc = param . loc ; parser . state . current . addDependency ( dep ) ; return true ; } parser . applyPluginsBailResult ( "call require:commonjs:context" , expr , param ) ; return true ; }

1<CODESPLIT>https://github.com/nisaacson/pdf-text-extract/blob/d21ead42859aae859d3f20b79ebd5c801b21837d/index.js#L182-L207<CODESPLIT>streamResultsPromise<CODESPLIT>Duplicated from function splitPages of streamResults<CODESPLIT>function streamResultsPromise ( command , args , options , cb ) { var output = '' var stderr = '' var child = spawn ( command , args , options ) child . stdout . setEncoding ( 'utf8' ) child . stderr . setEncoding ( 'utf8' ) child . stdout . on ( 'data' , stdoutHandler ) child . stderr . on ( 'data' , stderrHandler ) child . on ( 'close' , closeHandler ) function stdoutHandler ( data ) { output += data } function stderrHandler ( data ) { stderr += data } function closeHandler ( code ) { if ( code !== 0 ) { var ex = new Error ( 'pdf-text-extract command failed: ' + stderr ) throw ex } cb ( output ) } }

0<CODESPLIT>https://github.com/Freeboard/freeboard/blob/38789f6e8bd3d04f7d3b2c3427e509d00f2610fc/js/freeboard.thirdparty.js#L13151-L13169<CODESPLIT><CODESPLIT>returns the step - aligned value that val is closest to between ( inclusive ) min and max<CODESPLIT>function ( value , allowAny ) { var parsed ; if ( value !== "" ) { parsed = this . _parse ( value ) ; if ( parsed !== null ) { if ( ! allowAny ) { parsed = this . _adjustValue ( parsed ) ; } value = this . _format ( parsed ) ; } } this . element . val ( value ) ; this . _refresh ( ) ; }

0<CODESPLIT>https://github.com/ariatemplates/ariatemplates/blob/7ed5d065818ae159bf361c9dfb209b1cf3883c90/src/aria/html/Element.js#L274-L278<CODESPLIT><CODESPLIT>Called when a change occurs for a value with binding .<CODESPLIT>function ( out ) { var cfg = this . _cfg ; var attributes = ariaUtilsHtml . buildAttributeList ( cfg . attributes ) ; var markup = [ "<" , cfg . tagName , " id='" , this . _id , "' " ] ; if ( attributes ) { markup . push ( attributes , " " ) ; } var delegateId = this . __delegateId ; if ( delegateId ) { var delegateManager = ariaUtilsDelegate ; markup . push ( delegateManager . getMarkup ( delegateId ) , " " ) ; var delegateFallbackEvents = this . __delegateFallbackEvents ; for ( var i = 0 , l = delegateFallbackEvents . length ; i < l ; i ++ ) { markup . push ( delegateManager . getFallbackMarkup ( delegateFallbackEvents [ i ] , delegateId , false ) , " " ) ; } } out . write ( markup . join ( "" ) ) ; }

0<CODESPLIT>https://github.com/canjs/can-compute/blob/ac271cf6a68ec936e2f7992df2bb9bc1f5a7cf36/proto-compute.js#L427-L440<CODESPLIT>addEntities<CODESPLIT>## updater Updates the cached value and fires an event if the value has changed .<CODESPLIT>function addEntities ( schema , entityTypes , propFilter ) { var contents , entityType , i , j , labelColumn , len , len1 , linksSection , ref , reverseJoins , rjTable , rjs , table , tableId ; // Keep list of reverse join columns (one to many) to add later. table and column reverseJoins = [ ] ; // For each entity type, finding reverse joins for ( i = 0 , len = entityTypes . length ; i < len ; i ++ ) { entityType = entityTypes [ i ] ; _traverseTree ( entityType . properties , function ( prop ) { var entityCode , refTable ; if ( propFilter && ! propFilter ( prop ) ) { return null ; } if ( prop . type === "id" ) { if ( prop . idTable . match ( / ^entities\. / ) ) { entityCode = prop . idTable . split ( "." ) [ 1 ] ; // Check that exists if ( ! _ . findWhere ( entityTypes , { code : entityCode } ) ) { return ; } reverseJoins . push ( { table : prop . idTable , column : { id : "!entities." . concat ( entityType . code , "." ) . concat ( prop . id ) , name : pluralize ( entityType . name ) , deprecated : prop . deprecated || entityType . deprecated , type : "join" , join : { type : "1-n" , toTable : "entities." . concat ( entityType . code ) , inverse : prop . id , fromColumn : "_id" , toColumn : prop . id } } } ) ; } if ( prop . idTable === "admin_regions" || prop . idTable . match ( / ^regions\. / ) ) { // Check that table exists refTable = schema . getTable ( prop . idTable ) ; if ( ! refTable || ! refTable . ancestryTable ) { return ; } // Create reverse join that takes into account that regions are hierarchical return reverseJoins . push ( { table : prop . idTable , column : { id : "!entities." . concat ( entityType . code , "." ) . concat ( prop . id ) , name : entityType . name , deprecated : prop . deprecated || entityType . deprecated , type : "join" , join : { type : "1-n" , toTable : "entities." . concat ( entityType . code ) , inverse : prop . id , jsonql : { type : "op" , op : "exists" , exprs : [ { type : "scalar" , expr : null , from : { type : "table" , table : refTable . ancestryTable , alias : "subwithin" } , where : { type : "op" , op : "and" , exprs : [ { type : "op" , op : "=" , exprs : [ { type : "field" , tableAlias : "subwithin" , column : "ancestor" } , { type : "field" , tableAlias : "{from}" , column : refTable . primaryKey } ] } , { type : "op" , op : "=" , exprs : [ { type : "field" , tableAlias : "subwithin" , column : "descendant" } , { type : "field" , tableAlias : "{to}" , column : prop . id } ] } ] } } ] } } } } ) ; } } } ) ; } // For each entity type for ( j = 0 , len1 = entityTypes . length ; j < len1 ; j ++ ) { entityType = entityTypes [ j ] ; // Get label column labelColumn = null ; // Add properties contents = _mapTree ( entityType . properties || [ ] , function ( prop ) { var ref ; if ( propFilter && ! propFilter ( prop ) ) { return null ; } // Sections are untouched unless filtered if ( prop . type === "section" ) { return prop ; } // Use unique code as label if ( prop . uniqueCode ) { labelColumn = prop . id ; } prop = _ . pick ( prop , "id" , "name" , "code" , "desc" , "type" , "idTable" , "enumValues" , "deprecated" ) ; // Don't include roles delete prop . roles ; // Convert id to join if ( prop . type === "id" ) { prop . type = "join" ; prop . join = { type : "n-1" , toTable : prop . idTable , fromColumn : prop . id , toColumn : ( ( ref = schema . getTable ( prop . idTable ) ) != null ? ref . primaryKey : void 0 ) || "_id" } ; delete prop . idTable ; } // Pad date fields if ( prop . type === "date" ) { // rpad(field ,10, '-01-01') prop . jsonql = { type : "op" , op : "rpad" , exprs : [ { type : "field" , tableAlias : "{alias}" , column : prop . id } , 10 , '-01-01' ] } ; } return prop ; } ) ; // Add extra columns contents . push ( { id : "_managed_by" , name : { en : "Managed By" } , desc : { en : "User or group that manages the data for this " . concat ( formUtils . localizeString ( entityType . name ) ) } , type : "join" , join : { type : "n-1" , toTable : "subjects" , fromColumn : "_managed_by" , toColumn : "id" } } ) ; contents . push ( { id : "_created_by" , name : { en : "Added by user" } , desc : { en : "User that added this " . concat ( formUtils . localizeString ( entityType . name ) , " to the database" ) } , type : "join" , join : { type : "n-1" , toTable : "users" , fromColumn : "_created_by" , toColumn : "_id" } } ) ; contents . push ( { id : "_created_on" , name : { en : "Date added" } , desc : { en : "Date that this " . concat ( formUtils . localizeString ( entityType . name ) , " was added to the database" ) } , type : "datetime" } ) ; contents . push ( { id : "_modified_by" , name : { en : "Last modified by user" } , desc : { en : "User that modified this " . concat ( formUtils . localizeString ( entityType . name ) , " last" ) } , type : "join" , join : { type : "n-1" , toTable : "users" , fromColumn : "_modified_by" , toColumn : "_id" } } ) ; contents . push ( { id : "_modified_on" , name : { en : "Date last modified" } , desc : { en : "Date that this " . concat ( formUtils . localizeString ( entityType . name ) , " was last modified" ) } , type : "datetime" } ) ; contents . push ( { id : "_merged_entities" , name : { en : "Previous mWater IDs" } , desc : { en : "IDs of other " . concat ( formUtils . localizeString ( entityType . name ) , " that were merged into this" ) } , type : 'text[]' } ) ; // This gets overridden in the schema map contents . push ( { id : "_pending_verifications" , name : { en : "Pending Verifications" } , desc : { en : "True if there are verifications pending for this site that have not been verified" } , type : 'boolean' } ) ; // Add datasets contents . push ( { id : "!datasets" , name : "Datasets" , desc : { en : "Datasets that this " . concat ( formUtils . localizeString ( entityType . name ) , " is a part of" ) } , type : "join" , join : { type : "n-n" , toTable : "datasets" , jsonql : { type : "op" , op : "exists" , exprs : [ { type : "query" , selects : [ { type : "select" , expr : null , alias : "null_value" } ] , from : { type : "table" , table : "dataset_members" , alias : "members" } , where : { type : "op" , op : "and" , exprs : [ { type : "op" , op : "=" , exprs : [ { type : "field" , tableAlias : "members" , column : "entity_type" } , entityType . code ] } , { type : "op" , op : "=" , exprs : [ { type : "field" , tableAlias : "members" , column : "entity_id" } , { type : "field" , tableAlias : "{from}" , column : "_id" } ] } , { type : "op" , op : "=" , exprs : [ { type : "field" , tableAlias : "members" , column : "dataset" } , { type : "field" , tableAlias : "{to}" , column : "_id" } ] } ] } } ] } } } ) ; // Add related forms placeholder section contents . push ( { type : "section" , id : "!related_forms" , name : { en : "Related Surveys" } , desc : { en : "Surveys that are linked by a question to " . concat ( formUtils . localizeString ( entityType . name ) ) } , contents : [ ] } ) ; // Add related indicators placeholder section contents . push ( { type : "section" , id : "!indicators" , // Special section name name : { en : "Related Indicators" } , desc : { en : "Indicators are standardized information that are related to this site" } , contents : [ ] } ) ; tableId = "entities." . concat ( entityType . code ) ; table = { id : tableId , name : entityType . name , desc : entityType . desc , primaryKey : "_id" , label : labelColumn , contents : contents , deprecated : entityType . deprecated } ; // Legacy only if ( entityType . code === "water_point_functionality_report" ) { table . ordering = "date" ; } // Create table schema = schema . addTable ( table ) ; } ref = _ . groupBy ( reverseJoins , "table" ) ; // Add reverse joins, putting them in "!related_entities" section for ( rjTable in ref ) { rjs = ref [ rjTable ] ; table = schema . getTable ( rjTable ) ; table . contents = table . contents . slice ( ) ; linksSection = _ . findWhere ( table . contents , { id : "!related_entities" , type : "section" } ) ; if ( ! linksSection ) { linksSection = { id : "!related_entities" , type : "section" , name : { _base : "en" , en : "Related Entities" } , contents : [ ] } ; table . contents . push ( linksSection ) ; } linksSection . contents = linksSection . contents . concat ( _ . pluck ( rjs , "column" ) ) ; schema = schema . addTable ( table ) ; } return schema ; }

0<CODESPLIT>https://github.com/knsv/mermaid/blob/7d3578b31aeea3bc9bbc618dcda57d82574eaffb/src/mermaidAPI.js#L334-L460<CODESPLIT>stripExtension<CODESPLIT>##render Function that renders an svg with a graph from a chart definition . Usage example below .<CODESPLIT>function stripExtension ( url ) { var lastDotPos = url . lastIndexOf ( '.' ) ; return ( lastDotPos <= 0 ) ? url : url . substring ( 0 , lastDotPos - 1 ) ; }

0<CODESPLIT>https://github.com/alexindigo/mixly/blob/602081b28806dc46286da783fef4f3ba1ecbb199/funky.js#L79-L103<CODESPLIT>copyFunction<CODESPLIT>Adds reference to the superclass and it s prototype as a __proto__ .<CODESPLIT>function copyFunction ( original ) { // clone original function var target = fulcon ( original ) ; // copy it's "static" methods copy ( target , original ) ; // duplicate prototype methods copy ( target . prototype , original . prototype ) ; // add instance reference to the it's own constructor Object . defineProperty ( target . prototype , 'constructor' , { value : target , writable : true , enumerable : false , configurable : true } ) ; return target ; }

1<CODESPLIT>https://github.com/Dogfalo/materialize/blob/1122efadad8f1433d404696f7613e3cc13fb83a4/extras/noUiSlider/nouislider.js#L911-L928<CODESPLIT>addOrigin<CODESPLIT>Append a origin to the base<CODESPLIT>function addOrigin ( base , handleNumber ) { var origin = addNodeTo ( base , options . cssClasses . origin ) ; var handle = addNodeTo ( origin , options . cssClasses . handle ) ; addNodeTo ( handle , options . cssClasses . handleTouchArea ) ; handle . setAttribute ( 'data-handle' , handleNumber ) ; if ( handleNumber === 0 ) { addClass ( handle , options . cssClasses . handleLower ) ; } else if ( handleNumber === options . handles - 1 ) { addClass ( handle , options . cssClasses . handleUpper ) ; } return origin ; }

1<CODESPLIT>https://github.com/mtth/avsc/blob/d4e62f360b8f27c4b95372cac58c95157f87865a/lib/index.js#L74-L77<CODESPLIT>createFileDecoder<CODESPLIT>Readable stream of records from a local Avro file .<CODESPLIT>function createFileDecoder ( path , opts ) { return fs . createReadStream ( path ) . pipe ( new containers . streams . BlockDecoder ( opts ) ) ; }

0<CODESPLIT>https://github.com/pixijs/pixi-filters/blob/caeac3f2ff85077befaeb18990e7fede6defc61e/rollup.config.js#L70-L85<CODESPLIT>Agent<CODESPLIT>Get a list of the non - private sorted packages with Lerna v3<CODESPLIT>function Agent ( family , major , minor , patch , source ) { this . family = family || 'Other' ; this . major = major || '0' ; this . minor = minor || '0' ; this . patch = patch || '0' ; this . source = source || '' ; }

0<CODESPLIT>https://github.com/vuejs/vuex/blob/d7c7f9844831f98c5c9aaca213746c4ccc5d6929/dist/vuex.esm.js#L91-L101<CODESPLIT>Store<CODESPLIT>Base data struct for store s module package with some attribute and method<CODESPLIT>function Store ( options ) { var this$1 = this ; if ( options === void 0 ) options = { } ; // Auto install if it is not done yet and `window` has `Vue`. // To allow users to avoid auto-installation in some cases, // this code should be placed here. See #731 if ( ! Vue && typeof window !== 'undefined' && window . Vue ) { install ( window . Vue ) ; } if ( process . env . NODE_ENV !== 'production' ) { assert ( Vue , "must call Vue.use(Vuex) before creating a store instance." ) ; assert ( typeof Promise !== 'undefined' , "vuex requires a Promise polyfill in this browser." ) ; assert ( this instanceof Store , "store must be called with the new operator." ) ; } var plugins = options . plugins ; if ( plugins === void 0 ) plugins = [ ] ; var strict = options . strict ; if ( strict === void 0 ) strict = false ; // store internal state this . _committing = false ; this . _actions = Object . create ( null ) ; this . _actionSubscribers = [ ] ; this . _mutations = Object . create ( null ) ; this . _wrappedGetters = Object . create ( null ) ; this . _modules = new ModuleCollection ( options ) ; this . _modulesNamespaceMap = Object . create ( null ) ; this . _subscribers = [ ] ; this . _watcherVM = new Vue ( ) ; // bind commit and dispatch to self var store = this ; var ref = this ; var dispatch = ref . dispatch ; var commit = ref . commit ; this . dispatch = function boundDispatch ( type , payload ) { return dispatch . call ( store , type , payload ) } ; this . commit = function boundCommit ( type , payload , options ) { return commit . call ( store , type , payload , options ) } ; // strict mode this . strict = strict ; var state = this . _modules . root . state ; // init root module. // this also recursively registers all sub-modules // and collects all module getters inside this._wrappedGetters installModule ( this , state , [ ] , this . _modules . root ) ; // initialize the store vm, which is responsible for the reactivity // (also registers _wrappedGetters as computed properties) resetStoreVM ( this , state ) ; // apply plugins plugins . forEach ( function ( plugin ) { return plugin ( this$1 ) ; } ) ; var useDevtools = options . devtools !== undefined ? options . devtools : Vue . config . devtools ; if ( useDevtools ) { devtoolPlugin ( this ) ; } }

0<CODESPLIT>https://github.com/SAP/openui5/blob/8a832fca01cb1cdf8df589788e0c5723e2a33c70/src/sap.ui.core/src/sap/ui/events/F6Navigation.js#L152-L224<CODESPLIT>findFirstTabbableOfPreviousGroup<CODESPLIT>Finds the next / previous ( bForward ) element in the F6 chain starting from the given source element within the given scopes and focus it<CODESPLIT>function findFirstTabbableOfPreviousGroup ( $FirstTabbableInScope , $Tabbables , oSouceGroup , bFindPreviousGroup ) { var oGroup , $Target ; for ( var i = $Tabbables . length - 1 ; i >= 0 ; i -- ) { oGroup = findClosestGroup ( $Tabbables [ i ] ) ; if ( oGroup != oSouceGroup ) { if ( bFindPreviousGroup ) { //First find last tabbable of previous group and remember this new group (named "X" in the following comments) oSouceGroup = oGroup ; bFindPreviousGroup = false ; } else { //Then starting from group X and try to find again the last tabbable of previous group (named "Y") //-> Jump one tabbable back to get the first tabbable of X $Target = jQuery ( $Tabbables [ i + 1 ] ) ; break ; } } } if ( ! $Target && ! bFindPreviousGroup ) { //Group X found but not group Y -> X is the first group -> Focus the first tabbable scope (e.g. page) element $Target = $FirstTabbableInScope ; } return $Target ; }

0<CODESPLIT>https://github.com/Zeindelf/utilify-js/blob/a16f6e578c953b10cec5ca89c06aeba73ff6674f/dist/utilify.esm.js#L1929-L1937<CODESPLIT>arrayFlatten<CODESPLIT>Creates a shallow clone of the array .<CODESPLIT>function arrayFlatten ( arr , level ) { var self = this ; var result = [ ] ; var current = 0 ; level = level || Infinity ; self . _forEach ( arr , function ( el ) { if ( validateHelpers . isArray ( el ) && current < level ) { result = result . concat ( self . arrayFlatten ( el , level , current + 1 ) ) ; } else { result . push ( el ) ; } } ) ; return result ; }

1<CODESPLIT>https://github.com/wunderbyte/grunt-spiritual-dox/blob/5afcfe31ddbf7d654166aa15b938553b61de5811/src/js/libs/spiritual-gui.js#L1826-L1835<CODESPLIT><CODESPLIT>Create subclass for given class .<CODESPLIT>function ( SuperC , args ) { args = this . _breakdown_subs ( args ) ; return this . _extendclass ( SuperC , args . protos , args . recurring , args . statics , args . name ) ; }

1<CODESPLIT>https://github.com/figure-io/figure.io/blob/5d4d7fcc7216d4ce3d2bcbdee8d2972e0d928b88/build/xfig.js#L7142-L7151<CODESPLIT>kde_estimator_silverman<CODESPLIT>end METHOD estimator () FUNCTION : kde_estimator_silverman ( vector ) Use s Silverman s rule of thumb to derive an empirical estimate for an optimal KDE bandwidth selection . Source : Silverman B . W . ( 1998 ) . Density Estimation for Statistics and Data Analysis . London : Chapman & Hall / CRC . p . 48 . ISBN 0 - 412 - 24620 - 1 .<CODESPLIT>function kde_estimator_silverman ( vector ) { var stdev , N = vector . length , A ; // [0] Calculate the sample standard deviation: stdev = Vector . stdev ( vector ) ; // [1] Calculate the estimator: A = Math . pow ( ( 4 / ( 3 * N ) ) , 0.2 ) ; return A * stdev ; }

1<CODESPLIT>https://github.com/neyric/webhookit/blob/13abf6f072e23d536432235da78fd3e4e5d742b6/public/javascripts/inputex/build/inputex.js#L3164-L3199<CODESPLIT><CODESPLIT>Render the hidden list element<CODESPLIT>function ( ) { // This element wraps the input node in a float: none div this . wrapEl = inputEx . cn ( 'div' , { className : 'inputEx-StringField-wrapper' } ) ; // Attributes of the input field var attributes = { type : 'text' , id : YAHOO . util . Dom . generateId ( ) } ; if ( this . options . size ) attributes . size = this . options . size ; if ( this . options . readonly ) attributes . readonly = 'readonly' ; if ( this . options . maxLength ) attributes . maxLength = this . options . maxLength ; // Create the node this . el = inputEx . cn ( 'input' , attributes ) ; // Create the hidden input var hiddenAttrs = { type : 'hidden' , value : '' } ; if ( this . options . name ) hiddenAttrs . name = this . options . name ; this . hiddenEl = inputEx . cn ( 'input' , hiddenAttrs ) ; // Append it to the main element this . wrapEl . appendChild ( this . el ) ; this . wrapEl . appendChild ( this . hiddenEl ) ; this . fieldContainer . appendChild ( this . wrapEl ) ; // Render the list : this . listEl = inputEx . cn ( 'div' , { id : Dom . generateId ( ) } ) ; this . fieldContainer . appendChild ( this . listEl ) ; Event . onAvailable ( [ this . el , this . listEl ] , this . buildAutocomplete , this , true ) ; }

0<CODESPLIT>https://github.com/kalabox/kalabox/blob/c8d3e66fe33645e5973b138f4b8403f96abe90e8/lib/app/registry.js#L31-L38<CODESPLIT>Env<CODESPLIT>Returns true if two apps are equal .<CODESPLIT>function Env ( opts ) { if ( this instanceof Env ) { opts = opts || { } ; this . opts = opts ; this . state = _ . get ( opts , 'state' ) || { } ; } else { return new Env ( opts ) ; } }

1<CODESPLIT>https://github.com/wellcaffeinated/PhysicsJS/blob/b9eca1634b6db222571e7e820a09404513fe2e46/src/behaviors/verlet-constraints.js#L26-L34<CODESPLIT><CODESPLIT>extended<CODESPLIT>function ( options ) { parent . init . call ( this ) ; this . options . defaults ( defaults ) ; this . options ( options ) ; this . _distanceConstraints = [ ] ; this . _angleConstraints = [ ] ; }

0<CODESPLIT>https://github.com/tonyganch/gonzales-pe/blob/cb4be1c6c22184b525c6b7252823de834235a963/src/less/parse.js#L3478-L3492<CODESPLIT>checkPseudoClass3<CODESPLIT>Get node with a hexadecimal number ( e . g . #fff ) inside a simple selector<CODESPLIT>function checkPseudoClass3 ( i ) { const start = i ; let l = 0 ; // Skip `:`. i ++ ; if ( i >= tokensLength ) return 0 ; if ( l = checkIdent ( i ) ) i += l ; else return 0 ; if ( i >= tokensLength || tokens [ i ] . type !== TokenType . LeftParenthesis ) return 0 ; const right = tokens [ i ] . right ; // Skip `(`. i ++ ; if ( l = checkSC ( i ) ) i += l ; if ( l = checkUnary ( i ) ) i += l ; if ( i >= tokensLength ) return 0 ; if ( tokens [ i ] . type === TokenType . DecimalNumber ) i ++ ; if ( i >= tokensLength ) return 0 ; if ( tokens [ i ] . value === 'n' ) i ++ ; else return 0 ; if ( l = checkSC ( i ) ) i += l ; if ( i >= tokensLength ) return 0 ; if ( tokens [ i ] . value === '+' || tokens [ i ] . value === '-' ) i ++ ; else return 0 ; if ( l = checkSC ( i ) ) i += l ; if ( tokens [ i ] . type === TokenType . DecimalNumber ) i ++ ; else return 0 ; if ( l = checkSC ( i ) ) i += l ; if ( i !== right ) return 0 ; // Skip `)`. i ++ ; return i - start ; }

0<CODESPLIT>https://github.com/popeindustries/buddy/blob/c38afc2e6915743eb6cfcf5aba59a8699142c7a5/lib/resolver/resolve.js#L53-L100<CODESPLIT>_gpfReadNashorn<CODESPLIT>Find filepath for id in sourcedir directory<CODESPLIT>function _gpfReadNashorn ( path ) { var javaPath = java . nio . file . Paths . get ( path ) ; if ( java . nio . file . Files . exists ( javaPath ) ) { return new Promise ( function ( resolve , reject ) { var javaInputStream = java . nio . file . Files . newInputStream ( javaPath ) , iStreamReader = new _GpfStreamJavaReadable ( javaInputStream ) , iWritableString = new _GpfStreamWritableString ( ) ; return iStreamReader . read ( iWritableString ) . then ( function ( ) { resolve ( iWritableString . toString ( ) ) ; } ) [ "catch" ] ( reject ) ; } ) ; } return Promise . reject ( new Error ( "File not found" ) ) ; // To be improved }

0<CODESPLIT>https://github.com/mgesmundo/authorify-client/blob/39fb57db897eaa49b76444ff62bbc0ccedc7ee16/build/authorify.js#L14408-L14414<CODESPLIT>initModule<CODESPLIT>OpenSSL s legacy key derivation function .<CODESPLIT>function initModule ( forge ) { // shortcut for ASN.1 API var asn1 = forge . asn1 ; // shortcut for PKCS#7 API var p7v = forge . pkcs7asn1 = forge . pkcs7asn1 || { } ; forge . pkcs7 = forge . pkcs7 || { } ; forge . pkcs7 . asn1 = p7v ; var contentInfoValidator = { name : 'ContentInfo' , tagClass : asn1 . Class . UNIVERSAL , type : asn1 . Type . SEQUENCE , constructed : true , value : [ { name : 'ContentInfo.ContentType' , tagClass : asn1 . Class . UNIVERSAL , type : asn1 . Type . OID , constructed : false , capture : 'contentType' } , { name : 'ContentInfo.content' , tagClass : asn1 . Class . CONTEXT_SPECIFIC , type : 0 , constructed : true , optional : true , captureAsn1 : 'content' } ] } ; p7v . contentInfoValidator = contentInfoValidator ; var encryptedContentInfoValidator = { name : 'EncryptedContentInfo' , tagClass : asn1 . Class . UNIVERSAL , type : asn1 . Type . SEQUENCE , constructed : true , value : [ { name : 'EncryptedContentInfo.contentType' , tagClass : asn1 . Class . UNIVERSAL , type : asn1 . Type . OID , constructed : false , capture : 'contentType' } , { name : 'EncryptedContentInfo.contentEncryptionAlgorithm' , tagClass : asn1 . Class . UNIVERSAL , type : asn1 . Type . SEQUENCE , constructed : true , value : [ { name : 'EncryptedContentInfo.contentEncryptionAlgorithm.algorithm' , tagClass : asn1 . Class . UNIVERSAL , type : asn1 . Type . OID , constructed : false , capture : 'encAlgorithm' } , { name : 'EncryptedContentInfo.contentEncryptionAlgorithm.parameter' , tagClass : asn1 . Class . UNIVERSAL , captureAsn1 : 'encParameter' } ] } , { name : 'EncryptedContentInfo.encryptedContent' , tagClass : asn1 . Class . CONTEXT_SPECIFIC , type : 0 , /* The PKCS#7 structure output by OpenSSL somewhat differs from what      * other implementations do generate.      *      * OpenSSL generates a structure like this:      * SEQUENCE {      *    ...      *    [0]      *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38      *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45      *       ...      * }      *      * Whereas other implementations (and this PKCS#7 module) generate:      * SEQUENCE {      *    ...      *    [0] {      *       OCTET STRING      *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38      *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45      *          ...      *    }      * }      *      * In order to support both, we just capture the context specific      * field here.  The OCTET STRING bit is removed below.      */ capture : 'encryptedContent' , captureAsn1 : 'encryptedContentAsn1' } ] } ; p7v . envelopedDataValidator = { name : 'EnvelopedData' , tagClass : asn1 . Class . UNIVERSAL , type : asn1 . Type . SEQUENCE , constructed : true , value : [ { name : 'EnvelopedData.Version' , tagClass : asn1 . Class . UNIVERSAL , type : asn1 . Type . INTEGER , constructed : false , capture : 'version' } , { name : 'EnvelopedData.RecipientInfos' , tagClass : asn1 . Class . UNIVERSAL , type : asn1 . Type . SET , constructed : true , captureAsn1 : 'recipientInfos' } ] . concat ( encryptedContentInfoValidator ) } ; p7v . encryptedDataValidator = { name : 'EncryptedData' , tagClass : asn1 . Class . UNIVERSAL , type : asn1 . Type . SEQUENCE , constructed : true , value : [ { name : 'EncryptedData.Version' , tagClass : asn1 . Class . UNIVERSAL , type : asn1 . Type . INTEGER , constructed : false , capture : 'version' } ] . concat ( encryptedContentInfoValidator ) } ; var signerValidator = { name : 'SignerInfo' , tagClass : asn1 . Class . UNIVERSAL , type : asn1 . Type . SEQUENCE , constructed : true , value : [ { name : 'SignerInfo.Version' , tagClass : asn1 . Class . UNIVERSAL , type : asn1 . Type . INTEGER , constructed : false } , { name : 'SignerInfo.IssuerAndSerialNumber' , tagClass : asn1 . Class . UNIVERSAL , type : asn1 . Type . SEQUENCE , constructed : true } , { name : 'SignerInfo.DigestAlgorithm' , tagClass : asn1 . Class . UNIVERSAL , type : asn1 . Type . SEQUENCE , constructed : true } , { name : 'SignerInfo.AuthenticatedAttributes' , tagClass : asn1 . Class . CONTEXT_SPECIFIC , type : 0 , constructed : true , optional : true , capture : 'authenticatedAttributes' } , { name : 'SignerInfo.DigestEncryptionAlgorithm' , tagClass : asn1 . Class . UNIVERSAL , type : asn1 . Type . SEQUENCE , constructed : true } , { name : 'SignerInfo.EncryptedDigest' , tagClass : asn1 . Class . UNIVERSAL , type : asn1 . Type . OCTETSTRING , constructed : false , capture : 'signature' } , { name : 'SignerInfo.UnauthenticatedAttributes' , tagClass : asn1 . Class . CONTEXT_SPECIFIC , type : 1 , constructed : true , optional : true } ] } ; p7v . signedDataValidator = { name : 'SignedData' , tagClass : asn1 . Class . UNIVERSAL , type : asn1 . Type . SEQUENCE , constructed : true , value : [ { name : 'SignedData.Version' , tagClass : asn1 . Class . UNIVERSAL , type : asn1 . Type . INTEGER , constructed : false , capture : 'version' } , { name : 'SignedData.DigestAlgorithms' , tagClass : asn1 . Class . UNIVERSAL , type : asn1 . Type . SET , constructed : true , captureAsn1 : 'digestAlgorithms' } , contentInfoValidator , { name : 'SignedData.Certificates' , tagClass : asn1 . Class . CONTEXT_SPECIFIC , type : 0 , optional : true , captureAsn1 : 'certificates' } , { name : 'SignedData.CertificateRevocationLists' , tagClass : asn1 . Class . CONTEXT_SPECIFIC , type : 1 , optional : true , captureAsn1 : 'crls' } , { name : 'SignedData.SignerInfos' , tagClass : asn1 . Class . UNIVERSAL , type : asn1 . Type . SET , capture : 'signerInfos' , optional : true , value : [ signerValidator ] } ] } ; p7v . recipientInfoValidator = { name : 'RecipientInfo' , tagClass : asn1 . Class . UNIVERSAL , type : asn1 . Type . SEQUENCE , constructed : true , value : [ { name : 'RecipientInfo.version' , tagClass : asn1 . Class . UNIVERSAL , type : asn1 . Type . INTEGER , constructed : false , capture : 'version' } , { name : 'RecipientInfo.issuerAndSerial' , tagClass : asn1 . Class . UNIVERSAL , type : asn1 . Type . SEQUENCE , constructed : true , value : [ { name : 'RecipientInfo.issuerAndSerial.issuer' , tagClass : asn1 . Class . UNIVERSAL , type : asn1 . Type . SEQUENCE , constructed : true , captureAsn1 : 'issuer' } , { name : 'RecipientInfo.issuerAndSerial.serialNumber' , tagClass : asn1 . Class . UNIVERSAL , type : asn1 . Type . INTEGER , constructed : false , capture : 'serial' } ] } , { name : 'RecipientInfo.keyEncryptionAlgorithm' , tagClass : asn1 . Class . UNIVERSAL , type : asn1 . Type . SEQUENCE , constructed : true , value : [ { name : 'RecipientInfo.keyEncryptionAlgorithm.algorithm' , tagClass : asn1 . Class . UNIVERSAL , type : asn1 . Type . OID , constructed : false , capture : 'encAlgorithm' } , { name : 'RecipientInfo.keyEncryptionAlgorithm.parameter' , tagClass : asn1 . Class . UNIVERSAL , constructed : false , captureAsn1 : 'encParameter' } ] } , { name : 'RecipientInfo.encryptedKey' , tagClass : asn1 . Class . UNIVERSAL , type : asn1 . Type . OCTETSTRING , constructed : false , capture : 'encKey' } ] } ; }

1<CODESPLIT>https://github.com/ariatemplates/ariatemplates/blob/7ed5d065818ae159bf361c9dfb209b1cf3883c90/src/aria/templates/ModuleCtrlFactory.js#L805-L848<CODESPLIT><CODESPLIT>This method should only be called from aria . templates . ModuleCtrl when a module controller is disposed so that its sub - modules and flow can be disposed as well .<CODESPLIT>function ( moduleCtrlPrivate ) { var k = moduleCtrlPrivate [ MODULECTRL_ID_PROPERTY ] ; var res = getModulePrivateInfoWithCheck ( moduleCtrlPrivate , "notifyModuleCtrlDisposed" ) ; if ( ! res ) { // error is already logged return ; } res . isDisposing = true ; var subModuleInfos = res . subModuleInfos ; var parentModule = subModuleInfos ? subModuleInfos . parentModule : null ; if ( parentModule && ! parentModule . isDisposing ) { // This module is a sub-module and its parent module is not being disposed // remove the module from parent array of sub-modules ariaUtilsArray . remove ( parentModule . subModules , moduleCtrlPrivate ) ; // remove module controller from refpath: putSubModuleAtRefPath . call ( this , parentModule , subModuleInfos . subModuleDesc , null , subModuleInfos . customModule ) ; } // dispose sub-modules (including custom modules): var subModules = res . subModules ; if ( subModules ) { for ( var i = subModules . length - 1 ; i >= 0 ; i -- ) { try { subModules [ i ] . $dispose ( ) ; } catch ( ex ) { // an error when disposing a sub-module must never prevent the parent module to be disposed // (especially if the child module is a custom module) this . $logError ( this . EXCEPTION_SUBMODULE_DISPOSE , [ moduleCtrlPrivate . $classpath , subModules [ i ] . $classpath ] , ex ) ; } } res . subModules = null ; } modulesPrivateInfo [ k ] = null ; delete modulesPrivateInfo [ k ] ; if ( res . flowCtrlPrivate ) { res . flowCtrlPrivate . $dispose ( ) ; res . flowCtrlPrivate = null ; res . flowCtrl = null ; } res . moduleCtrl = null ; res . moduleCtrlPrivate = null ; res . subModuleInfos = null ; }

1<CODESPLIT>https://github.com/Whitebolt/require-extra/blob/2a8f737aab67305c9fda3ee56aa7953e97cee859/src/import.js#L93-L96<CODESPLIT>_getExtensionRegEx<CODESPLIT>Get a regular expression for the given selection of file extensions which will then be able to match file paths which have those extensions .<CODESPLIT>function _getExtensionRegEx ( ext = settings . get ( 'extensions' ) ) { let _ext = '(?:' + makeArray ( ext ) . join ( '|' ) + ')' ; return new RegExp ( _ext + '$' ) ; }

1<CODESPLIT>https://github.com/adityamukho/node-box-sdk/blob/b8403df59d53ba4e8bed5de3675467544981a683/lib/api/content/folders.js#L91-L99<CODESPLIT><CODESPLIT>Fields to set for {<CODESPLIT>function ( id , fields , done , headers , config ) { if ( ! _ . isNumber ( parseInt ( id , 10 ) ) ) { return done ( new Error ( 'id must be specified.' ) ) ; } if ( ! _ . isObject ( fields ) ) { return done ( new Error ( 'An fields object must be provided.' ) ) ; } this . _request ( [ 'folders' , id ] , 'PUT' , done , null , fields , null , headers , null , config ) ; }

0<CODESPLIT>https://github.com/ssulleyymmann/ng-all-login/blob/4aa73280c4858011894a416760bef34339ab11b1/docs/vendor.bundle.js#L62011-L62046<CODESPLIT>viewDef<CODESPLIT>@license Copyright Google Inc . All Rights Reserved .<CODESPLIT>function viewDef ( flags , nodes , updateDirectives , updateRenderer ) { // clone nodes and set auto calculated values var /** @type {?} */ viewBindingCount = 0 ; var /** @type {?} */ viewDisposableCount = 0 ; var /** @type {?} */ viewNodeFlags = 0 ; var /** @type {?} */ viewRootNodeFlags = 0 ; var /** @type {?} */ viewMatchedQueries = 0 ; var /** @type {?} */ currentParent = null ; var /** @type {?} */ currentElementHasPublicProviders = false ; var /** @type {?} */ currentElementHasPrivateProviders = false ; var /** @type {?} */ lastRenderRootNode = null ; for ( var /** @type {?} */ i = 0 ; i < nodes . length ; i ++ ) { while ( currentParent && i > currentParent . index + currentParent . childCount ) { var /** @type {?} */ newParent = currentParent . parent ; if ( newParent ) { newParent . childFlags |= ( ( currentParent . childFlags ) ) ; newParent . childMatchedQueries |= currentParent . childMatchedQueries ; } currentParent = newParent ; } var /** @type {?} */ node = nodes [ i ] ; node . index = i ; node . parent = currentParent ; node . bindingIndex = viewBindingCount ; node . outputIndex = viewDisposableCount ; // renderParent needs to account for ng-container! var /** @type {?} */ currentRenderParent = void 0 ; if ( currentParent && currentParent . flags & 1 /* TypeElement */ && ! ( ( currentParent . element ) ) . name ) { currentRenderParent = currentParent . renderParent ; } else { currentRenderParent = currentParent ; } node . renderParent = currentRenderParent ; if ( node . element ) { var /** @type {?} */ elDef = node . element ; elDef . publicProviders = currentParent ? ( ( currentParent . element ) ) . publicProviders : Object . create ( null ) ; elDef . allProviders = elDef . publicProviders ; // Note: We assume that all providers of an element are before any child element! currentElementHasPublicProviders = false ; currentElementHasPrivateProviders = false ; } validateNode ( currentParent , node , nodes . length ) ; viewNodeFlags |= node . flags ; viewMatchedQueries |= node . matchedQueryIds ; if ( node . element && node . element . template ) { viewMatchedQueries |= node . element . template . nodeMatchedQueries ; } if ( currentParent ) { currentParent . childFlags |= node . flags ; currentParent . directChildFlags |= node . flags ; currentParent . childMatchedQueries |= node . matchedQueryIds ; if ( node . element && node . element . template ) { currentParent . childMatchedQueries |= node . element . template . nodeMatchedQueries ; } } else { viewRootNodeFlags |= node . flags ; } viewBindingCount += node . bindings . length ; viewDisposableCount += node . outputs . length ; if ( ! currentRenderParent && ( node . flags & 3 /* CatRenderNode */ ) ) { lastRenderRootNode = node ; } if ( node . flags & 20224 /* CatProvider */ ) { if ( ! currentElementHasPublicProviders ) { currentElementHasPublicProviders = true ; /** @type {?} */ ( ( ( ( // Use prototypical inheritance to not get O(n^2) complexity... currentParent ) ) . element ) ) . publicProviders = Object . create ( /** @type {?} */ ( ( ( ( currentParent ) ) . element ) ) . publicProviders ) ; /** @type {?} */ ( ( ( ( currentParent ) ) . element ) ) . allProviders = ( ( ( ( currentParent ) ) . element ) ) . publicProviders ; } var /** @type {?} */ isPrivateService = ( node . flags & 8192 /* PrivateProvider */ ) !== 0 ; var /** @type {?} */ isComponent = ( node . flags & 32768 /* Component */ ) !== 0 ; if ( ! isPrivateService || isComponent ) { ( ( ( ( ( ( currentParent ) ) . element ) ) . publicProviders ) ) [ tokenKey ( /** @type {?} */ ( ( node . provider ) ) . token ) ] = node ; } else { if ( ! currentElementHasPrivateProviders ) { currentElementHasPrivateProviders = true ; /** @type {?} */ ( ( ( ( // Use protoyypical inheritance to not get O(n^2) complexity... currentParent ) ) . element ) ) . allProviders = Object . create ( /** @type {?} */ ( ( ( ( currentParent ) ) . element ) ) . publicProviders ) ; } /** @type {?} */ ( ( ( ( ( ( currentParent ) ) . element ) ) . allProviders ) ) [ tokenKey ( /** @type {?} */ ( ( node . provider ) ) . token ) ] = node ; } if ( isComponent ) { ( ( ( ( currentParent ) ) . element ) ) . componentProvider = node ; } } if ( node . childCount ) { currentParent = node ; } } while ( currentParent ) { var /** @type {?} */ newParent = currentParent . parent ; if ( newParent ) { newParent . childFlags |= currentParent . childFlags ; newParent . childMatchedQueries |= currentParent . childMatchedQueries ; } currentParent = newParent ; } var /** @type {?} */ handleEvent = function ( view , nodeIndex , eventName , event ) { return ( ( ( ( nodes [ nodeIndex ] . element ) ) . handleEvent ) ) ( view , eventName , event ) ; } ; return { // Will be filled later... factory : null , nodeFlags : viewNodeFlags , rootNodeFlags : viewRootNodeFlags , nodeMatchedQueries : viewMatchedQueries , flags : flags , nodes : nodes , updateDirectives : updateDirectives || NOOP , updateRenderer : updateRenderer || NOOP , handleEvent : handleEvent || NOOP , bindingCount : viewBindingCount , outputCount : viewDisposableCount , lastRenderRootNode : lastRenderRootNode } ; }

0<CODESPLIT>https://github.com/wireapp/wire-web-packages/blob/b352ac2ba63bf069f13f3d0c706cbb98f2f8e719/packages/cryptobox/src/demo/benchmark.js#L25-L29<CODESPLIT>initialSetup<CODESPLIT>Creates a Cryptobox with an initialized store .<CODESPLIT>async function initialSetup ( ) { const alice = await createCryptobox ( 'alice' , 1 ) ; await alice . create ( ) ; const bob = await createCryptobox ( 'bob' , 1 ) ; await bob . create ( ) ; const bobBundle = Proteus . keys . PreKeyBundle . new ( bob . identity . public_key , await bob . store . load_prekey ( Proteus . keys . PreKey . MAX_PREKEY_ID ) ) ; const cipherMessage = await alice . encrypt ( createSessionId ( bob ) , 'Hello' , bobBundle . serialise ( ) ) ; await bob . decrypt ( createSessionId ( alice ) , cipherMessage ) ; return { alice , bob } ; }

1<CODESPLIT>https://github.com/Tamersoul/magic-wand-js/blob/39d50ec17bfc060f2d360537a26a9420dd8970b6/jsfiddle/OpenLayers.debug.js#L76393-L76412<CODESPLIT><CODESPLIT>Method : setSize Set the size of the drawing surface<CODESPLIT>function ( size ) { OpenLayers . Renderer . prototype . setSize . apply ( this , arguments ) ; // setting width and height on all roots to avoid flicker which we // would get with 100% width and height on child roots var roots = [ this . rendererRoot , this . root , this . vectorRoot , this . textRoot ] ; var w = this . size . w + "px" ; var h = this . size . h + "px" ; var root ; for ( var i = 0 , len = roots . length ; i < len ; ++ i ) { root = roots [ i ] ; root . style . width = w ; root . style . height = h ; } }

1<CODESPLIT>https://github.com/neyric/webhookit/blob/13abf6f072e23d536432235da78fd3e4e5d742b6/public/javascripts/yui/carousel/carousel-debug.js#L866-L889<CODESPLIT>syncUi<CODESPLIT>Handle UI update . Call the appropriate methods on events fired when an item is added or removed for synchronizing the DOM .<CODESPLIT>function syncUi ( o ) { var carousel = this ; if ( ! JS . isObject ( o ) ) { return ; } switch ( o . ev ) { case itemAddedEvent : carousel . _syncUiForItemAdd ( o ) ; break ; case itemRemovedEvent : carousel . _syncUiForItemRemove ( o ) ; break ; case itemReplacedEvent : carousel . _syncUiForItemReplace ( o ) ; break ; case loadItemsEvent : carousel . _syncUiForLazyLoading ( o ) ; break ; } carousel . fireEvent ( uiUpdateEvent ) ; }

0<CODESPLIT>https://github.com/Tamersoul/magic-wand-js/blob/39d50ec17bfc060f2d360537a26a9420dd8970b6/jsfiddle/OpenLayers.debug.js#L67556-L67579<CODESPLIT><CODESPLIT>Method : createSLD Create the SLD document for the layer using the supplied filters .<CODESPLIT>function ( source ) { // check if we already have a selection layer for the source layer var selectionLayer ; if ( ! this . layerCache [ source . id ] ) { selectionLayer = new OpenLayers . Layer . WMS ( source . name , source . url , source . params , OpenLayers . Util . applyDefaults ( this . layerOptions , source . getOptions ( ) ) ) ; this . layerCache [ source . id ] = selectionLayer ; // make sure the layers are coupled wrt visibility, but only // if they are not displayed in the layer switcher, because in // that case the user cannot control visibility. if ( this . layerOptions . displayInLayerSwitcher === false ) { source . events . on ( { "visibilitychanged" : this . coupleLayerVisiblity , scope : selectionLayer } ) ; } this . map . addLayer ( selectionLayer ) ; } else { selectionLayer = this . layerCache [ source . id ] ; } return selectionLayer ; }

1<CODESPLIT>https://github.com/ViliamKopecky/Ristretto/blob/2a4255e7068032303c0edb458d6f9a19de5d42ee/client/ristretto.js#L27-L42<CODESPLIT><CODESPLIT>finds all link elements and reloads them .<CODESPLIT>function ( first_time ) { var links = document . getElementsByTagName ( "link" ) ; var link ; var replacing = [ ] ; for ( var i = 0 ; i < links . length ; i ++ ) { link = links [ i ] ; char = '?' ; if ( link . rel === "stylesheet" ) { replacing . push ( link ) ; } } var fn = is_touch_device ( ) ? simple_swap_links : swap_links ; for ( i = 0 ; i < replacing . length ; i ++ ) { fn ( replacing [ i ] , first_time ) ; } }

1<CODESPLIT>https://github.com/cemtopkaya/kuark-db/blob/d584aaf51f65a013bec79220a05007bd70767ac2/lib/cem.js#L627-L650<CODESPLIT>f_urunle_iliskili_teklif_templeri_sil<CODESPLIT>region TEKLIF Teklif ekleme - güncelleme - silme durumunda ürünle ilgili oluşturulan temp ler siliniyor<CODESPLIT>function f_urunle_iliskili_teklif_templeri_sil ( _teklif , _tahta_id ) { if ( _teklif . Urun_Idler && _teklif . Urun_Idler . length > 0 ) { _teklif . Urun_Idler . forEach ( function ( _urun_id ) { return [ db . redis . dbQ . del ( db . redis . kp . temp . zsetUrunTeklifleriParaBirimli ( _tahta_id , _urun_id , _teklif . ParaBirim_Id ) ) , db . redis . dbQ . del ( db . redis . kp . temp . zsetUrunTeklifleriOnayDurumunaGore ( _tahta_id , _urun_id , _teklif . TeklifDurumu_Id ) ) ] . allX ( ) ; /*db.redis.dbQ.Q.all([              db.redis.dbQ.del(db.redis.kp.temp.zsetUrunTeklifleriParaBirimli(_tahta_id, _urun.Id, schema.SABIT.PARA_BIRIM.EUR)),              db.redis.dbQ.del(db.redis.kp.temp.zsetUrunTeklifleriParaBirimli(_tahta_id, _urun.Id, schema.SABIT.PARA_BIRIM.TRY)),              db.redis.dbQ.del(db.redis.kp.temp.zsetUrunTeklifleriParaBirimli(_tahta_id, _urun.Id, schema.SABIT.PARA_BIRIM.USD)),              db.redis.dbQ.del(db.redis.kp.temp.zsetUrunTeklifleriOnayDurumunaGore(_tahta_id, _urun.Id, schema.SABIT.ONAY_DURUM.teklif.ILK_KAYIT)),              db.redis.dbQ.del(db.redis.kp.temp.zsetUrunTeklifleriOnayDurumunaGore(_tahta_id, _urun.Id, schema.SABIT.ONAY_DURUM.teklif.IHALEDEN_ATILDI)),              db.redis.dbQ.del(db.redis.kp.temp.zsetUrunTeklifleriOnayDurumunaGore(_tahta_id, _urun.Id, schema.SABIT.ONAY_DURUM.teklif.IPTAL)),              db.redis.dbQ.del(db.redis.kp.temp.zsetUrunTeklifleriOnayDurumunaGore(_tahta_id, _urun.Id, schema.SABIT.ONAY_DURUM.teklif.KAZANDI)),              db.redis.dbQ.del(db.redis.kp.temp.zsetUrunTeklifleriOnayDurumunaGore(_tahta_id, _urun.Id, schema.SABIT.ONAY_DURUM.teklif.URUN_RED)),              db.redis.dbQ.del(db.redis.kp.temp.zsetUrunTeklifleriOnayDurumunaGore(_tahta_id, _urun.Id, schema.SABIT.ONAY_DURUM.teklif.URUN_BELGESI_EKSIK))              ]);*/ } ) ; } }

0<CODESPLIT>https://github.com/chrisJohn404/LabJack-nodejs/blob/6f638eb039f3e1619e46ba5aac20d827fecafc29/lib/device.js#L1590-L1668<CODESPLIT><CODESPLIT>A helper function for the writeArray and writeArraySync function to parse or interpret the data to be written .<CODESPLIT>function ( err , res ) { if ( err ) { return onError ( 'Weird Error open' , err ) ; } //Check for no errors if ( res === 0 ) { //Save the handle & other information to the  //	device class self . handle = refDeviceHandle . readInt32LE ( 0 ) ; self . deviceType = deviceType ; self . connectionType = connectionType ; self . identifier = identifier ; self . isHandleValid = true ; return onSuccess ( ) ; } else { //Make sure that the handle, deviceType  //		& connectionType are still null self . handle = null ; self . deviceType = null ; self . connectionType = null ; self . identifier = null ; return onError ( res ) ; } }

1<CODESPLIT>https://github.com/clientIO/joint/blob/99ba02fe6c64e407bdfff6ba595d2068422c3e76/dist/joint.nowrap.js#L2822-L2866<CODESPLIT><CODESPLIT>Returns tangent line at requested length with precision better than requested opt . precision ; optionally using opt . segmentSubdivisions provided . Accepts negative length .<CODESPLIT>function ( length , opt ) { var segments = this . segments ; var numSegments = segments . length ; if ( numSegments === 0 ) return null ; // if segments is an empty array var fromStart = true ; if ( length < 0 ) { fromStart = false ; // negative lengths mean start calculation from end point length = - length ; // absolute value } opt = opt || { } ; var precision = ( opt . precision === undefined ) ? this . PRECISION : opt . precision ; var segmentSubdivisions = ( opt . segmentSubdivisions === undefined ) ? this . getSegmentSubdivisions ( { precision : precision } ) : opt . segmentSubdivisions ; // not using localOpt var lastValidSegment ; // visible AND differentiable (with a tangent) var l = 0 ; // length so far for ( var i = ( fromStart ? 0 : ( numSegments - 1 ) ) ; ( fromStart ? ( i < numSegments ) : ( i >= 0 ) ) ; ( fromStart ? ( i ++ ) : ( i -- ) ) ) { var segment = segments [ i ] ; var subdivisions = segmentSubdivisions [ i ] ; var d = segment . length ( { precision : precision , subdivisions : subdivisions } ) ; if ( segment . isDifferentiable ( ) ) { if ( length <= ( l + d ) ) { return segment . tangentAtLength ( ( ( fromStart ? 1 : - 1 ) * ( length - l ) ) , { precision : precision , subdivisions : subdivisions } ) ; } lastValidSegment = segment ; } l += d ; } // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment if ( lastValidSegment ) { var t = ( fromStart ? 1 : 0 ) ; return lastValidSegment . tangentAtT ( t ) ; } // if no valid segment, return null return null ; }

1<CODESPLIT>https://github.com/Xcraft-Inc/shellcraft.js/blob/ff23cf75212e871a18ec2f1791a6939af489e0fb/lib/option.js#L32-L38<CODESPLIT>Option<CODESPLIT>Option constructor .<CODESPLIT>function Option ( handler , options , desc ) { Option . super_ . apply ( this , [ handler , options , desc ] ) ; if ( options . params && options . params . hasOwnProperty ( 'optional' ) ) { throw new Error ( 'optional parameter is not allowed for options' ) ; } }

0<CODESPLIT>https://github.com/SAP/openui5/blob/8a832fca01cb1cdf8df589788e0c5723e2a33c70/src/sap.ui.core/src/sap/ui/core/hyphenation/Hyphenation.js#L243-L257<CODESPLIT>prepareConfig<CODESPLIT>Loads a <code > javascript< / code > file .<CODESPLIT>function prepareConfig ( sLanguage , oConfig ) { //Creating default configuration var oConfigurationForLanguage = { "require" : [ sLanguage ] , "hyphen" : "\u00AD" , "leftmin" : 3 , // The minimum of chars to remain on the old line. "rightmin" : 3 , // The minimum of chars to go on the new line "compound" : "all" , // factory-made -> fac-tory-[ZWSP]made "path" : jQuery . sap . getResourcePath ( "sap/ui/thirdparty/hyphenopoly" ) } ; // we are passing only 3 properties to hyphenopoly: hyphen, exceptions and minWordLength if ( oConfig ) { if ( "hyphen" in oConfig ) { oConfigurationForLanguage . hyphen = oConfig . hyphen ; } if ( "minWordLength" in oConfig ) { oConfigurationForLanguage . minWordLength = oConfig . minWordLength ; } if ( "exceptions" in oConfig ) { Log . info ( "[UI5 Hyphenation] Add hyphenation exceptions '" + JSON . stringify ( oConfig . exceptions ) + "' for language " + getLanguageDisplayName ( sLanguage ) , "sap.ui.core.hyphenation.Hyphenation" ) ; // transform "exceptions: {word1: "w-o-r-d-1", word2: "w-o-r-d-2"}" to "exceptions: {en-us: 'w-o-r-d-1,w-o-r-d-2'}" var aWordsExceptions = [ ] ; Object . keys ( oConfig . exceptions ) . forEach ( function ( sWord ) { aWordsExceptions . push ( oConfig . exceptions [ sWord ] ) ; } ) ; if ( aWordsExceptions . length > 0 ) { oConfigurationForLanguage . exceptions = { } ; oConfigurationForLanguage . exceptions [ sLanguage ] = aWordsExceptions . join ( ", " ) ; } } } return oConfigurationForLanguage ; }

1<CODESPLIT>https://github.com/AndreasMadsen/drugged/blob/2ba5e9a9e87dd43a6754f711a125da13c58da68b/drugged.js#L139-L156<CODESPLIT>done<CODESPLIT>The handle constructor is done<CODESPLIT>function done ( err ) { if ( err ) return handle . error ( err ) ; // Evaluate all the attach methods for ( const attachMethod of self . attachMethods ) { attachMethod . call ( handle ) ; } // No match found, send 404 if ( match . handler === null ) { err = new Error ( 'Not Found' ) ; err . statusCode = 404 ; return handle . error ( err ) ; } // match found, relay to HandlerCollection match . handler ( req . method , handle , match . params , match . splat ) ; }

1<CODESPLIT>https://github.com/meandavejustice/deploy-txp/blob/d9d3024a836c7976c337e934c5065e2d08f4dadb/lib/sign.js#L51-L66<CODESPLIT>distAddon<CODESPLIT>if we need to sign and distribute our add - on we want to use this method<CODESPLIT>function distAddon ( opts , cb ) { // sign our add-on const generatedXpi = 'addon.xpi' ; signAddon ( generatedXpi , opts . apiKey , opts . apiSecret , function ( err , signedXpiPath ) { if ( err ) return cb ( err ) ; // remove our generated xpi since we now have a signed version removeGeneratedXpi ( ) ; // move our signed xpi and rdf into the /dist dir // directory and exit checkExistsAndMv ( signedXpiPath , 'signed-addon.xpi' , function ( err ) { if ( err ) return cb ( err ) ; console . log ( 'addon.xpi written to signed-addon.xpi' ) ; cb ( ) ; } ) ; } ) ; }

0<CODESPLIT>https://github.com/basisjs/basisjs/blob/8571903014b207a09d45ad2d1bfba277bf21289b/src/basis/dom/wrapper.js#L267-L280<CODESPLIT>processInstanceClass<CODESPLIT>disabled<CODESPLIT>function processInstanceClass ( InstanceClass ) { if ( ! InstanceClass . isSubclassOf ( AbstractNode ) ) { /** @cut */ basis . dev . warn ( namespace + ': Bad class for instance, should be subclass of basis.dom.wrapper.AbstractNode' ) ; return AbstractNode ; } return InstanceClass ; }

1<CODESPLIT>https://github.com/C2FO/patio/blob/6dba197e468d36189cd74846c0cdbf0755a0ff8d/lib/plugins/inheritance.js#L135-L165<CODESPLIT><CODESPLIT>Save each column according to the columns in each table<CODESPLIT>function ( ) { var Self = this . _static , ret ; if ( Self === Self . __ctiBaseModel ) { ret = this . _super ( arguments ) ; } else { var pk = this . primaryKey [ 0 ] , tables = Self . __ctiTables , ctiColumns = Self . __ctiColumns , self = this , isRestricted = Self . isRestrictedPrimaryKey , db = this . db ; ret = asyncArray . forEach ( tables , function ( table , index ) { var cols = ctiColumns [ table ] , insert = { } , val , i = - 1 , colLength = cols . length , c ; while ( ++ i < colLength ) { c = cols [ i ] ; if ( ( index !== 0 || ( index === 0 && ( ! isRestricted || pk . indexOf ( c ) === - 1 ) ) ) && ! comb . isUndefined ( val = self [ c ] ) ) { insert [ c ] = val ; } } return db . from ( table ) . insert ( insert ) . chain ( function ( id ) { if ( comb . isUndefined ( self . primaryKeyValue ) && ! comb . isUndefined ( id ) && index === 0 ) { self . __ignore = true ; //how to handle composite keys. self [ pk ] = id ; self . __ignore = false ; } } ) ; } , 1 ) . chain ( function ( ) { self . __isNew = false ; self . __isChanged = false ; return self . _saveReload ( ) ; } ) ; } return ret . promise ( ) ; }

0<CODESPLIT>https://github.com/primus/substream/blob/626792b746e1dc90b67a81045f442ee1f584c0ec/index.js#L62-L70<CODESPLIT>setup<CODESPLIT>Setup the Primus instance so we can start creating substreams .<CODESPLIT>function setup ( ) { primus . streams = { } ; for ( var event in primus . reserved . events ) { if ( 'data' === event ) continue ; primus . on ( event , listen ( event ) ) ; } }

1<CODESPLIT>https://github.com/ngReact/ngReact/blob/5f91c2e6bc976eb1aca7517adb448e4f07ff5d98/ngReact.js#L275-L285<CODESPLIT><CODESPLIT>for each of the properties get their scope value and set it to scope . props<CODESPLIT>function ( ) { var scopeProps = { } , config = { } ; props . forEach ( function ( prop ) { var propName = getPropName ( prop ) ; scopeProps [ propName ] = scope . $eval ( findAttribute ( attrs , propName ) ) ; config [ propName ] = getPropConfig ( prop ) ; } ) ; scopeProps = applyFunctions ( scopeProps , scope , config ) ; scopeProps = angular . extend ( { } , scopeProps , injectableProps ) ; renderComponent ( reactComponent , scopeProps , scope , elem ) ; }

1<CODESPLIT>https://github.com/GjXing/Nui/blob/75edd85b1516091412795b7506f8e1c89e45c332/packages/waterfall/directive.js#L9-L35<CODESPLIT>doBindEvent<CODESPLIT>绑定事件到元素上 读取基本的控制变量<CODESPLIT>function doBindEvent ( ) { if ( this . el [ CONTEXT ] . binded ) { return ; } this . el [ CONTEXT ] . binded = true ; this . scrollEventListener = handleScrollEvent . bind ( this ) ; this . scrollEventTarget = Utils . getScrollEventTarget ( this . el ) ; const disabledExpr = this . el . getAttribute ( 'waterfall-disabled' ) ; let disabled = false ; if ( disabledExpr ) { this . vm . $watch ( disabledExpr , ( value ) => { this . disabled = value ; this . scrollEventListener ( ) ; } ) ; disabled = Boolean ( this . vm [ disabledExpr ] ) ; } this . disabled = disabled ; const offset = this . el . getAttribute ( 'waterfall-offset' ) ; this . offset = Number ( offset ) || OFFSET ; on ( this . scrollEventTarget , 'scroll' , this . scrollEventListener , true ) ; this . scrollEventListener ( ) ; }

0<CODESPLIT>https://github.com/easysoft/zui/blob/a5af01d76e9481d618d6abd3e873a8ee7e49c59f/src/js/template.js#L15-L23<CODESPLIT><CODESPLIT>model name The $componentName$ model class<CODESPLIT>function ( element , options ) { var that = this ; this . element = $ ( element ) ; this . language = ( options . language || this . element . data ( 'date-language' ) || ( $ . zui && $ . zui . clientLang ? $ . zui . clientLang ( ) . replace ( '_' , '-' ) : "zh-cn" ) ) . toLowerCase ( ) ; this . language = this . language in dates ? this . language : "en" ; this . isRTL = dates [ this . language ] . rtl || false ; this . formatType = options . formatType || this . element . data ( 'format-type' ) || 'standard' ; this . format = DPGlobal . parseFormat ( options . format || this . element . data ( 'date-format' ) || dates [ this . language ] . format || DPGlobal . getDefaultFormat ( this . formatType , 'input' ) , this . formatType ) ; this . isInline = false ; this . isVisible = false ; this . isInput = this . element . is ( 'input' ) ; this . component = this . element . is ( '.date' ) ? this . element . find ( '.input-group-addon .icon-th, .input-group-addon .icon-time, .input-group-addon .icon-calendar' ) . parent ( ) : false ; this . componentReset = this . element . is ( '.date' ) ? this . element . find ( '.input-group-addon .icon-remove' ) . parent ( ) : false ; this . hasInput = this . component && this . element . find ( 'input' ) . length ; if ( this . component && this . component . length === 0 ) { this . component = false ; } this . linkField = options . linkField || this . element . data ( 'link-field' ) || false ; this . linkFormat = DPGlobal . parseFormat ( options . linkFormat || this . element . data ( 'link-format' ) || DPGlobal . getDefaultFormat ( this . formatType , 'link' ) , this . formatType ) ; this . minuteStep = options . minuteStep || this . element . data ( 'minute-step' ) || 5 ; this . pickerPosition = options . pickerPosition || this . element . data ( 'picker-position' ) || 'bottom-right' ; this . showMeridian = options . showMeridian || this . element . data ( 'show-meridian' ) || false ; this . initialDate = options . initialDate || new Date ( ) ; this . pickerClass = options . eleClass ; this . pickerId = options . eleId ; this . _attachEvents ( ) ; this . formatViewType = "datetime" ; if ( 'formatViewType' in options ) { this . formatViewType = options . formatViewType ; } else if ( 'formatViewType' in this . element . data ( ) ) { this . formatViewType = this . element . data ( 'formatViewType' ) ; } this . minView = 0 ; if ( 'minView' in options ) { this . minView = options . minView ; } else if ( 'minView' in this . element . data ( ) ) { this . minView = this . element . data ( 'min-view' ) ; } this . minView = DPGlobal . convertViewMode ( this . minView ) ; this . maxView = DPGlobal . modes . length - 1 ; if ( 'maxView' in options ) { this . maxView = options . maxView ; } else if ( 'maxView' in this . element . data ( ) ) { this . maxView = this . element . data ( 'max-view' ) ; } this . maxView = DPGlobal . convertViewMode ( this . maxView ) ; this . wheelViewModeNavigation = false ; if ( 'wheelViewModeNavigation' in options ) { this . wheelViewModeNavigation = options . wheelViewModeNavigation ; } else if ( 'wheelViewModeNavigation' in this . element . data ( ) ) { this . wheelViewModeNavigation = this . element . data ( 'view-mode-wheel-navigation' ) ; } this . wheelViewModeNavigationInverseDirection = false ; if ( 'wheelViewModeNavigationInverseDirection' in options ) { this . wheelViewModeNavigationInverseDirection = options . wheelViewModeNavigationInverseDirection ; } else if ( 'wheelViewModeNavigationInverseDirection' in this . element . data ( ) ) { this . wheelViewModeNavigationInverseDirection = this . element . data ( 'view-mode-wheel-navigation-inverse-dir' ) ; } this . wheelViewModeNavigationDelay = 100 ; if ( 'wheelViewModeNavigationDelay' in options ) { this . wheelViewModeNavigationDelay = options . wheelViewModeNavigationDelay ; } else if ( 'wheelViewModeNavigationDelay' in this . element . data ( ) ) { this . wheelViewModeNavigationDelay = this . element . data ( 'view-mode-wheel-navigation-delay' ) ; } this . startViewMode = 2 ; if ( 'startView' in options ) { this . startViewMode = options . startView ; } else if ( 'startView' in this . element . data ( ) ) { this . startViewMode = this . element . data ( 'start-view' ) ; } this . startViewMode = DPGlobal . convertViewMode ( this . startViewMode ) ; this . viewMode = this . startViewMode ; this . viewSelect = this . minView ; if ( 'viewSelect' in options ) { this . viewSelect = options . viewSelect ; } else if ( 'viewSelect' in this . element . data ( ) ) { this . viewSelect = this . element . data ( 'view-select' ) ; } this . viewSelect = DPGlobal . convertViewMode ( this . viewSelect ) ; this . forceParse = true ; if ( 'forceParse' in options ) { this . forceParse = options . forceParse ; } else if ( 'dateForceParse' in this . element . data ( ) ) { this . forceParse = this . element . data ( 'date-force-parse' ) ; } this . picker = $ ( DPGlobal . template ) . appendTo ( this . isInline ? this . element : 'body' ) . on ( { click : $ . proxy ( this . click , this ) , mousedown : $ . proxy ( this . mousedown , this ) } ) ; if ( this . wheelViewModeNavigation ) { if ( $ . fn . mousewheel ) { this . picker . on ( { mousewheel : $ . proxy ( this . mousewheel , this ) } ) ; } else { console . log ( "Mouse Wheel event is not supported. Please include the jQuery Mouse Wheel plugin before enabling this option" ) ; } } if ( this . isInline ) { this . picker . addClass ( 'datetimepicker-inline' ) ; } else { this . picker . addClass ( 'datetimepicker-dropdown-' + this . pickerPosition + ' dropdown-menu' ) ; } if ( this . isRTL ) { this . picker . addClass ( 'datetimepicker-rtl' ) ; this . picker . find ( '.prev span, .next span' ) . toggleClass ( 'icon-arrow-left icon-arrow-right' ) ; ; } $ ( document ) . on ( 'mousedown' , function ( e ) { // Clicked outside the datetimepicker, hide it if ( $ ( e . target ) . closest ( '.datetimepicker' ) . length === 0 ) { that . hide ( ) ; } } ) ; this . autoclose = false ; if ( 'autoclose' in options ) { this . autoclose = options . autoclose ; } else if ( 'dateAutoclose' in this . element . data ( ) ) { this . autoclose = this . element . data ( 'date-autoclose' ) ; } this . keyboardNavigation = true ; if ( 'keyboardNavigation' in options ) { this . keyboardNavigation = options . keyboardNavigation ; } else if ( 'dateKeyboardNavigation' in this . element . data ( ) ) { this . keyboardNavigation = this . element . data ( 'date-keyboard-navigation' ) ; } this . todayBtn = ( options . todayBtn || this . element . data ( 'date-today-btn' ) || false ) ; this . todayHighlight = ( options . todayHighlight || this . element . data ( 'date-today-highlight' ) || false ) ; this . weekStart = ( ( options . weekStart || this . element . data ( 'date-weekstart' ) || dates [ this . language ] . weekStart || 0 ) % 7 ) ; this . weekEnd = ( ( this . weekStart + 6 ) % 7 ) ; this . startDate = - Infinity ; this . endDate = Infinity ; this . daysOfWeekDisabled = [ ] ; this . setStartDate ( options . startDate || this . element . data ( 'date-startdate' ) ) ; this . setEndDate ( options . endDate || this . element . data ( 'date-enddate' ) ) ; this . setDaysOfWeekDisabled ( options . daysOfWeekDisabled || this . element . data ( 'date-days-of-week-disabled' ) ) ; this . fillDow ( ) ; this . fillMonths ( ) ; this . update ( ) ; this . showMode ( ) ; if ( this . isInline ) { this . show ( ) ; } }

1<CODESPLIT>https://github.com/WorldMobileCoin/wmcc-core/blob/29c3759a175341cedae6b744c53eda628c669317/src/crypto/scrypt.js#L129-L186<CODESPLIT>salsa20_8<CODESPLIT>/ * Helpers<CODESPLIT>function salsa20_8 ( B ) { const B32 = new Uint32Array ( 16 ) ; const x = new Uint32Array ( 16 ) ; for ( let i = 0 ; i < 16 ; i ++ ) B32 [ i ] = B . readUInt32LE ( i * 4 , true ) ; for ( let i = 0 ; i < 16 ; i ++ ) x [ i ] = B32 [ i ] ; for ( let i = 0 ; i < 8 ; i += 2 ) { x [ 4 ] ^= R ( x [ 0 ] + x [ 12 ] , 7 ) ; x [ 8 ] ^= R ( x [ 4 ] + x [ 0 ] , 9 ) ; x [ 12 ] ^= R ( x [ 8 ] + x [ 4 ] , 13 ) ; x [ 0 ] ^= R ( x [ 12 ] + x [ 8 ] , 18 ) ; x [ 9 ] ^= R ( x [ 5 ] + x [ 1 ] , 7 ) ; x [ 13 ] ^= R ( x [ 9 ] + x [ 5 ] , 9 ) ; x [ 1 ] ^= R ( x [ 13 ] + x [ 9 ] , 13 ) ; x [ 5 ] ^= R ( x [ 1 ] + x [ 13 ] , 18 ) ; x [ 14 ] ^= R ( x [ 10 ] + x [ 6 ] , 7 ) ; x [ 2 ] ^= R ( x [ 14 ] + x [ 10 ] , 9 ) ; x [ 6 ] ^= R ( x [ 2 ] + x [ 14 ] , 13 ) ; x [ 10 ] ^= R ( x [ 6 ] + x [ 2 ] , 18 ) ; x [ 3 ] ^= R ( x [ 15 ] + x [ 11 ] , 7 ) ; x [ 7 ] ^= R ( x [ 3 ] + x [ 15 ] , 9 ) ; x [ 11 ] ^= R ( x [ 7 ] + x [ 3 ] , 13 ) ; x [ 15 ] ^= R ( x [ 11 ] + x [ 7 ] , 18 ) ; x [ 1 ] ^= R ( x [ 0 ] + x [ 3 ] , 7 ) ; x [ 2 ] ^= R ( x [ 1 ] + x [ 0 ] , 9 ) ; x [ 3 ] ^= R ( x [ 2 ] + x [ 1 ] , 13 ) ; x [ 0 ] ^= R ( x [ 3 ] + x [ 2 ] , 18 ) ; x [ 6 ] ^= R ( x [ 5 ] + x [ 4 ] , 7 ) ; x [ 7 ] ^= R ( x [ 6 ] + x [ 5 ] , 9 ) ; x [ 4 ] ^= R ( x [ 7 ] + x [ 6 ] , 13 ) ; x [ 5 ] ^= R ( x [ 4 ] + x [ 7 ] , 18 ) ; x [ 11 ] ^= R ( x [ 10 ] + x [ 9 ] , 7 ) ; x [ 8 ] ^= R ( x [ 11 ] + x [ 10 ] , 9 ) ; x [ 9 ] ^= R ( x [ 8 ] + x [ 11 ] , 13 ) ; x [ 10 ] ^= R ( x [ 9 ] + x [ 8 ] , 18 ) ; x [ 12 ] ^= R ( x [ 15 ] + x [ 14 ] , 7 ) ; x [ 13 ] ^= R ( x [ 12 ] + x [ 15 ] , 9 ) ; x [ 14 ] ^= R ( x [ 13 ] + x [ 12 ] , 13 ) ; x [ 15 ] ^= R ( x [ 14 ] + x [ 13 ] , 18 ) ; } for ( let i = 0 ; i < 16 ; i ++ ) B32 [ i ] += x [ i ] ; for ( let i = 0 ; i < 16 ; i ++ ) B . writeUInt32LE ( B32 [ i ] , 4 * i , true ) ; }

1<CODESPLIT>https://github.com/AppGeo/cartodb/blob/4cc624975d359800961bf34cb74de97488d2efb5/lib/compiler.js#L387-L389<CODESPLIT>whereBasic<CODESPLIT>Compiles a basic where clause .<CODESPLIT>function whereBasic ( statement ) { return this . _not ( statement , '' ) + this . formatter . wrap ( statement . column ) + ' ' + this . formatter . operator ( statement . operator ) + ' ' + this . formatter . parameter ( statement . value ) ; }

1<CODESPLIT>https://github.com/adobe/brackets/blob/d5d00d43602c438266d32b8eda8f8a3ca937b524/src/editor/ImageViewer.js#L437-L451<CODESPLIT>_handleFileSystemChange<CODESPLIT>Handles file system change events so we can refresh image viewers for the files that changed on disk due to external editors<CODESPLIT>function _handleFileSystemChange ( event , entry , added , removed ) { // this may have been called because files were added //  or removed to the file system.  We don't care about those if ( ! entry || entry . isDirectory ) { return ; } // Look for a viewer for the changed file var viewer = _viewers [ entry . fullPath ] ; // viewer found, call its refresh method if ( viewer ) { viewer . refresh ( ) ; } }

1<CODESPLIT>https://github.com/nknapp/promised-handlebars/blob/2274dad8a2c7558a6747e274e85b1dd4d88dbac9/lib/utils.js#L63-L70<CODESPLIT>anyApplies<CODESPLIT>Check if the predicate is true for any element of the array<CODESPLIT>function anyApplies ( array , predicate ) { for ( var i = 0 ; i < array . length ; i ++ ) { if ( predicate ( array [ i ] ) ) { return true } } return false }

0<CODESPLIT>https://github.com/neyric/webhookit/blob/13abf6f072e23d536432235da78fd3e4e5d742b6/public/javascripts/inputex/build/inputex.js#L5071-L5084<CODESPLIT><CODESPLIT>Adds an element<CODESPLIT>function ( ) { var v = this . getValue ( ) , str_value = inputEx . IntegerField . superclass . getValue . call ( this ) ; // empty field if ( v === '' ) { // validate only if not required return ! this . options . required ; } if ( isNaN ( v ) ) { return false ; } return ! ! str_value . match ( / ^[\+\-]?[0-9]+$ / ) && ( this . options . negative ? true : v >= 0 ) && v >= this . options . min && v <= this . options . max ; }

1<CODESPLIT>https://github.com/KingSora/OverlayScrollbars/blob/8e658d46e2d034a2525269d7c873bbe844762307/js/OverlayScrollbars.js#L5015-L5023<CODESPLIT>setTopRightBottomLeft<CODESPLIT>Sets the top right bottom left properties with a given prefix of the given css object .<CODESPLIT>function setTopRightBottomLeft ( targetCSSObject , prefix , values ) { if ( values === undefined ) values = [ _strEmpty , _strEmpty , _strEmpty , _strEmpty ] ; targetCSSObject [ prefix + _strTop ] = values [ 0 ] ; targetCSSObject [ prefix + _strRight ] = values [ 1 ] ; targetCSSObject [ prefix + _strBottom ] = values [ 2 ] ; targetCSSObject [ prefix + _strLeft ] = values [ 3 ] ; }

1<CODESPLIT>https://github.com/IdentityModel/oidc-token-manager/blob/92998b8c3713975d98dc41cec4de2fff2c23e102/sample/vs/Sample/oidc-token-manager.js#L6169-L6179<CODESPLIT>_jws_getHashAlgFromParsedHead<CODESPLIT>==== JWS Generation =========================================================<CODESPLIT>function _jws_getHashAlgFromParsedHead ( head ) { var sigAlg = head [ "alg" ] ; var hashAlg = "" ; if ( sigAlg != "RS256" && sigAlg != "RS512" && sigAlg != "PS256" && sigAlg != "PS512" ) throw "JWS signature algorithm not supported: " + sigAlg ; if ( sigAlg . substr ( 2 ) == "256" ) hashAlg = "sha256" ; if ( sigAlg . substr ( 2 ) == "512" ) hashAlg = "sha512" ; return hashAlg ; }

1<CODESPLIT>https://github.com/SparkPost/heml/blob/9c600cb97b4d5f46a97a0c8af75851c15d5c681c/packages/heml-render/src/index.js#L57-L77<CODESPLIT>renderElements<CODESPLIT>Renders all HEML elements<CODESPLIT>async function renderElements ( elements , globals ) { const { $ } = globals const elementMap = keyBy ( elements , 'tagName' ) const metaTagNames = filter ( elements , { parent : [ 'head' ] } ) . map ( ( { tagName } ) => tagName ) const nonMetaTagNames = difference ( elements . map ( ( { tagName } ) => tagName ) , metaTagNames ) const $nodes = [ ... $ . findNodes ( metaTagNames ) , /** Render the meta elements first to last */ ... $ . findNodes ( nonMetaTagNames ) . reverse ( ) /** Render the elements last to first/outside to inside */ ] for ( let $node of $nodes ) { const element = elementMap [ $node . prop ( 'tagName' ) . toLowerCase ( ) ] const contents = $node . html ( ) const attrs = $node [ 0 ] . attribs const renderedValue = await Promise . resolve ( renderElement ( element , attrs , contents ) ) $node . replaceWith ( renderedValue . trim ( ) ) } }

0<CODESPLIT>https://github.com/CuppaLabs/angular2-multiselect-dropdown/blob/cb94eb9af46de79c69d61b4fd37a800009fb70d3/docs/vendor.js#L21738-L21747<CODESPLIT>refreshContentQueries<CODESPLIT>Sets the host bindings for the current view .<CODESPLIT>function refreshContentQueries ( tView ) { if ( tView . contentQueries != null ) { for ( var i = 0 ; i < tView . contentQueries . length ; i += 2 ) { var directiveDefIdx = tView . contentQueries [ i ] ; var directiveDef = tView . directives [ directiveDefIdx ] ; directiveDef . contentQueriesRefresh ( directiveDefIdx , tView . contentQueries [ i + 1 ] ) ; } } }

0<CODESPLIT>https://github.com/kevinchappell/formBuilder/blob/a5028073576002af518aabab93ca48efd5ed8514/src/js/form-builder.js#L954-L991<CODESPLIT>isActuallyCombinator<CODESPLIT>Select field html since there may be multiple<CODESPLIT>function isActuallyCombinator ( combinatorNode ) { // `.foo  /*comment*/, .bar` //      ^^ // If include comments, this spaces is a combinator, but it is not combinators. if ( ! / ^\s+$ / . test ( combinatorNode . value ) ) { return true ; } let next = combinatorNode . next ( ) ; while ( skipTest ( next ) ) { next = next . next ( ) ; } if ( isNonTarget ( next ) ) { return false ; } let prev = combinatorNode . prev ( ) ; while ( skipTest ( prev ) ) { prev = prev . prev ( ) ; } if ( isNonTarget ( prev ) ) { return false ; } return true ; function skipTest ( node ) { if ( ! node ) { return false ; } if ( node . type === "comment" ) { return true ; } if ( node . type === "combinator" && / ^\s+$ / . test ( node . value ) ) { return true ; } return false ; } function isNonTarget ( node ) { if ( ! node ) { return true ; } if ( node . type === "combinator" && ! / ^\s+$ / . test ( node . value ) ) { return true ; } return false ; } }

1<CODESPLIT>https://github.com/Rafflecopter/node-relyq/blob/d2a0f4eaafde4ef897308983a38710a8d7ae292b/lib/relyq.js#L20-L77<CODESPLIT>Q<CODESPLIT>-- Master Type : Q -- The master type a task queue<CODESPLIT>function Q ( redis , preopts ) { // handle forgetting a 'new' if ( ! ( this instanceof Q ) ) { return new Q ( redis , preopts ) ; } if ( preopts === undefined ) preopts = redis , redis = preopts . redis ; if ( ! redis && preopts . createRedis ) { this . _redis = redis = preopts . createRedis ( ) } else { console . error ( 'WARNING: passing a redis instance to relyq is deprecated. Please pass options.createRedis() function.' ) this . _redis = redis } this . _options = typeof preopts === 'string' ? { prefix : preopts , redis : redis } : preopts this . _delimeter = preopts . delimeter || ':' ; this . _idfield = preopts . idfield || 'id' ; this . _prefix = preopts . prefix || preopts ; this . _clean_finish = preopts . clean_finish === undefined || preopts . clean_finish ; this . _keep_storage = preopts . clean_finish === 'keep_storage' ; this . todo = new simpleq . Q ( redis , this . _prefix + this . _delimeter + 'todo' ) ; this . doing = new simpleq . Q ( redis , this . _prefix + this . _delimeter + 'doing' ) ; this . failed = new simpleq . Q ( redis , this . _prefix + this . _delimeter + 'failed' ) ; if ( ! this . _clean_finish ) { this . done = new simpleq . Q ( redis , this . _prefix + this . _delimeter + 'done' ) ; } if ( preopts . allow_defer && preopts . createRedis ) { this . deferred = new DeferredTaskList ( this , { polling_interval : preopts . defer_polling_interval , key : this . _prefix + this . _delimeter + 'deferred' , redis : preopts . createRedis ( ) , } ) ; } if ( preopts . allow_recur && preopts . createRedis ) { this . recurring = new RecurringTaskList ( this , { polling_interval : preopts . recur_polling_interval , key : this . _prefix + this . _delimeter + 'recurring' , redis : preopts . createRedis ( ) , } ) ; } EventEmitter . call ( this ) ; var rq = this ; if ( this . _redis . ready ) { setImmediate ( function ( ) { rq . emit ( 'ready' ) } ) } else { this . _redis . once ( 'ready' , function ( ) { rq . emit ( 'ready' ) } ) } }

1<CODESPLIT>https://github.com/cornerstonejs/cornerstone/blob/f3b4accef3a700b0719e8373c08c414a1448b563/src/webgl/renderer.js#L119-L139<CODESPLIT>getImageDataType<CODESPLIT>Returns the image data type as a string representation .<CODESPLIT>function getImageDataType ( image ) { if ( image . color ) { return 'rgb' ; } const pixelData = image . getPixelData ( ) ; if ( pixelData instanceof Int16Array ) { return 'int16' ; } if ( pixelData instanceof Uint16Array ) { return 'uint16' ; } if ( pixelData instanceof Int8Array ) { return 'int8' ; } return 'uint8' ; }

1<CODESPLIT>https://github.com/fengyuanchen/viewer/blob/b6b1168eeb25812e6a39c0eba9ec6fb788f8cefd/dist/viewer.common.js#L1804-L1816<CODESPLIT>next<CODESPLIT>View the next image<CODESPLIT>function next ( ) { var loop = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : false ; var maxIndex = this . length - 1 ; var index = this . index + 1 ; if ( index > maxIndex ) { index = loop ? 0 : maxIndex ; } this . view ( index ) ; return this ; }

0<CODESPLIT>https://github.com/areslabs/babel-plugin-import-css/blob/b90d3a4ec3a644edcaa1c803314e2c39de1d29c9/src/index.js#L79-L94<CODESPLIT>devHandler<CODESPLIT>In prod the js s object which is generated by the ralated css file will write directly in the js file .<CODESPLIT>function devHandler ( curPath , importPath , jsFilename ) { var absPath = resolve ( importPath , jsFilename ) var projectDir = path . resolve ( require . resolve ( './index.js' ) , '..' , '..' , '..' , '..' , '..' ) absPath = absPath . replace ( projectDir , '@areslabs/babel-plugin-import-css/rncsscache' ) curPath . node . source . value = ( absPath + '.js' ) }

1<CODESPLIT>https://github.com/standard/eslint-plugin-standard/blob/deb1a2a05d8ed5dd2126e340e9589d94db16b670/rules/array-bracket-even-spacing.js#L75-L78<CODESPLIT>reportNoBeginningSpace<CODESPLIT>Reports that there shouldn t be a space after the first token<CODESPLIT>function reportNoBeginningSpace ( node , token ) { context . report ( node , token . loc . start , "There should be no space after '" + token . value + "'" ) }

1<CODESPLIT>https://github.com/transloadit/uppy/blob/7ae18bf992d544a64da998f033258ec09a3de275/website/inject.js#L131-L151<CODESPLIT>injectGhStars<CODESPLIT>re - enable after rate limiter issue is fixed<CODESPLIT>async function injectGhStars ( ) { const opts = { } if ( 'GITHUB_TOKEN' in process . env ) { opts . auth = process . env . GITHUB_TOKEN } const Octokit = require ( '@octokit/rest' ) const octokit = new Octokit ( opts ) let { headers , data } = await octokit . repos . get ( { owner : 'transloadit' , repo : 'uppy' } ) console . log ( ` ${ headers [ 'x-ratelimit-remaining' ] } ` ) let dstpath = path . join ( webRoot , 'themes' , 'uppy' , 'layout' , 'partials' , 'generated_stargazers.ejs' ) fs . writeFileSync ( dstpath , data . stargazers_count , 'utf-8' ) console . log ( ` ${ data . stargazers_count } ${ dstpath } ` ) }

0<CODESPLIT>https://github.com/mipengine/mip2/blob/f46dfdd628795d04054667ccd0e89f94e3c73821/packages/mip/src/components/mip-carousel.js#L199-L210<CODESPLIT>resetPosAndIdx<CODESPLIT>追加class<CODESPLIT>function resetPosAndIdx ( curIndex , totalNum , deviceWidth , endPos ) { let endInfo = { endPos : 0 , endIndex : curIndex } if ( curIndex === totalNum - 1 ) { endInfo . endPos = - deviceWidth endInfo . endIndex = 1 } else if ( curIndex === 0 ) { // if it is last one endInfo . endPos = - ( totalNum - 2 ) * deviceWidth endInfo . endIndex = totalNum - 2 } else { endInfo . endPos = endPos } return endInfo }

1<CODESPLIT>https://github.com/LabsRS-Dev/sdk/blob/5b73ec7e5c50be54cc4bedd34cc2ee0c47db06ce/src/dove.sdk/util/loaderWrapper.js#L78-L100<CODESPLIT><CODESPLIT>Method : loadExtTemplate Params : ( string ) path : the relative path to a file that contains template definition ( s )<CODESPLIT>function ( path , next ) { var t$ = this var files = typeof path === 'string' ? [ path ] : path for ( var i = 0 ; i < files . length ; i ++ ) { var name = files [ i ] . replace ( / ^\s|\s$ / g , '' ) var att = name . split ( '.' ) var ext = att [ att . length - 1 ] . toLowerCase ( ) var isCSS = ext === 'css' var tag = isCSS ? 'link' : 'script' var attr = isCSS ? ' type=\'text/css\' rel=\'stylesheet\' ' : ' language=\'javascript\' type=\'text/javascript\' ' var link = ( isCSS ? 'href' : 'src' ) + '=\'' + t$ . includePath + name + '\'' if ( $ ( tag + '[' + link + ']' ) . length === 0 ) { if ( $ . inArray ( path , t$ . cache ) === - 1 ) { t$ . cache . push ( path ) var content = '<' + tag + attr + link + '></' + tag + '>' isCSS ? $ ( 'head' ) . append ( content ) : $ ( 'head' ) . append ( content ) } } } next && next ( ) }

0<CODESPLIT>https://github.com/pandorajs/dialog/blob/8dbd3cedb9ad0d0eda8f4353ed2414d45cf85de9/src/dialog.js#L179-L194<CODESPLIT><CODESPLIT>设置焦点<CODESPLIT>function ( ) { this . mask && this . mask . setPosition ( ) ; if ( ! this . option ( 'baseElement' ) ) { this . option ( 'baseElement' , this . document ) ; } Dialog . superclass . setPosition . apply ( this ) ; }

1<CODESPLIT>https://github.com/cafjs/caf_components/blob/dca28007d6618066df8ed058362f0d4a0745c2cf/lib/templateUtils.js#L237-L255<CODESPLIT><CODESPLIT>Returns a function that filters relevant values in an environment and applies a transform to them .<CODESPLIT>function ( prefix , f ) { var retF = function ( env ) { Object . keys ( env ) . forEach ( function ( x ) { var val = env [ x ] ; if ( ( typeof val === 'string' ) && ( val . indexOf ( prefix ) === 0 ) ) { var propName = val . substring ( prefix . length , val . length ) ; env [ x ] = f ( propName ) ; } else if ( Array . isArray ( val ) ) { retF ( val ) ; } else if ( val && ( typeof val === 'object' ) ) { retF ( val ) ; } } ) ; } ; return retF ; }

1<CODESPLIT>https://github.com/gethuman/pancakes/blob/86b89ae2f0ac68f86cd5ff66421677b3aa290857/lib/annotation.helper.js#L110-L134<CODESPLIT>getParameters<CODESPLIT>Get the function parameters for a given pancakes module<CODESPLIT>function getParameters ( flapjack ) { if ( ! _ . isFunction ( flapjack ) ) { throw new Error ( 'Flapjack not a function ' + JSON . stringify ( flapjack ) ) ; } var str = flapjack . toString ( ) ; var pattern = / (?:\()([^\)]*)(?:\)) / ; var matches = pattern . exec ( str ) ; if ( matches === null || matches . length < 2 ) { throw new Error ( 'Invalid flapjack: ' + str . substring ( 0 , 200 ) ) ; } var unfiltered = matches [ 1 ] . replace ( / \s / g , '' ) . split ( ',' ) ; var params = [ ] , i ; for ( i = 0 ; i < unfiltered . length ; i ++ ) { if ( unfiltered [ i ] ) { params . push ( unfiltered [ i ] ) ; } } return params ; }

1<CODESPLIT>https://github.com/unicornjs/unicornjs/blob/840812b83648262ea5e71b0e9b876a00bcf7125b/lib/uThreadBalancer.js#L20-L23<CODESPLIT>addThread<CODESPLIT>/ * Add a thread<CODESPLIT>function addThread ( thread ) { pids . push ( thread . process . pid ) ; workers [ thread . process . pid ] = thread ; }

0<CODESPLIT>https://github.com/NLeSC/spot/blob/8e02b6e0b80a21a7fe5c62b48bf121c0f2b8e417/src/app.js#L124-L144<CODESPLIT><CODESPLIT>[ description ]<CODESPLIT>function ( percentage ) { var progressBar = document . getElementById ( 'progress-bar' ) ; progressBar . MaterialProgress . setProgress ( percentage ) ; progressBar . style . display = 'inherit' ; }

1<CODESPLIT>https://github.com/sadiqhabib/tinymce-dist/blob/3acf1e4fe83a541988fdca20f2aaf4e6dce72512/tinymce.full.js#L25522-L25536<CODESPLIT><CODESPLIT>Constructs a new observable object instance .<CODESPLIT>function ( data ) { var name , value ; data = data || { } ; for ( name in data ) { value = data [ name ] ; if ( value instanceof Binding ) { data [ name ] = value . create ( this , name ) ; } } this . data = data ; }

0<CODESPLIT>https://github.com/ariatemplates/ariatemplates/blob/7ed5d065818ae159bf361c9dfb209b1cf3883c90/src/aria/Aria.js#L211-L226<CODESPLIT><CODESPLIT>Classpath validation method<CODESPLIT>function ( tagName , propertyName ) { if ( ! __properties . hasOwnProperty ( propertyName ) ) { return "--" ; } var property = __properties [ propertyName ] ; if ( typeof property == "object" ) { tagName = tagName . toUpperCase ( ) ; if ( ! property . hasOwnProperty ( tagName ) ) { return "--" ; } property = property [ tagName ] ; } return property ; }

1<CODESPLIT>https://github.com/TendaDigital/Tournamenter/blob/2733ae9b454ae90896249ab1d7a07007eb4a69e4/models/Group.js#L29-L123<CODESPLIT><CODESPLIT>Calculate table scores / * Method responsable for computing table data score ( method inserted inside group model )<CODESPLIT>function ( ) { // Compute team Wins, Losts, Draws and Goal-Sum /*                 // Uses the key as the teamId                 {                          1: {P: x, S: y, [...]},                     teamId: {P: x, S: y, [...]}                  }             */ var rawTable = { } ; var _default = { rank : 0 , teamId : 0 , P : 0 , goalsMade : 0 , goalsTaken : 0 , S : 0 , W : 0 , D : 0 , L : 0 , score : 0 } ; for ( var k in this . matches ) { var match = this . matches [ k ] ; // Compute game points for both teams computeGame ( match , match . teamAId , match . teamAScore , match . teamBScore ) ; computeGame ( match , match . teamBId , match . teamBScore , match . teamAScore ) ; } // Adds game to the teamId. Should be runned twice for each // side of match (teamA and teamB). function computeGame ( match , teamId , goalsMade , goalsTaken ) { // Skip empty id's if ( ! teamId ) return ; // Generate default template if NOT in array yet if ( ! rawTable [ teamId ] ) { var teamRow = _ . clone ( _default ) ; // Keeps team id under team teamRow . teamId = teamId ; // Inserts team in rawTable rawTable [ teamId ] = teamRow ; } // Get teamRow (it is supposed to exist) var teamRow = rawTable [ teamId ] ; // Compute points ONLY if match is not 'scheduled' // logycaly, it's 'ended' or 'playing', so we compute it if ( match . state == 'scheduled' ) return ; // Increment Plays teamRow . P ++ ; // Compute goals made/taken teamRow . goalsMade += goalsMade * 1 ; teamRow . goalsTaken += goalsTaken * 1 ; // Win if ( goalsMade > goalsTaken ) teamRow . W ++ ; // Loose else if ( goalsMade < goalsTaken ) teamRow . L ++ ; // Drew else teamRow . D ++ ; } // Compute 'final score' and add column S (goalsMade:goalsTaken) // Transfer data to final table array var finalTable = [ ] ; _ . forEach ( rawTable , function ( row ) { row . score = row . W * 3 + row . D * 1 ; row . S = row . goalsMade * 1 + ':' + row . goalsTaken * 1 ; row . GD = row . goalsMade * 1 - row . goalsTaken * 1 ; finalTable . push ( row ) ; } ) ; // Sort by 'score' field finalTable = _ . sortBy ( finalTable , 'score' ) . reverse ( ) ; // Rank Table var pos = 0 ; var lastScore = - 1 ; _ . forEach ( finalTable , function ( row ) { // Keeps the same ranking if scores is the same if ( lastScore != row . score ) { pos ++ ; lastScore = row . score ; } row . rank = pos ; } ) ; return finalTable ; }

1<CODESPLIT>https://github.com/hl198181/neptune/blob/88030bb4222945900e6a225469380cc43a016c13/misc/demo/public/vendor/angular-form-for/form-for.js#L2363-L2368<CODESPLIT>ModelValidator<CODESPLIT>Constructor .<CODESPLIT>function ModelValidator ( $interpolate , $parse , $q , formForConfiguration ) { this . $interpolate_ = $interpolate ; this . formForConfiguration_ = formForConfiguration ; this . nestedObjectHelper_ = new formFor . NestedObjectHelper ( $parse ) ; this . promiseUtils_ = new formFor . PromiseUtils ( $q ) ; }

1<CODESPLIT>https://github.com/antvis/data-set/blob/55526ac5663b87cdc988fc579404df186603b2d9/demos/assets/g2.js#L17606-L17611<CODESPLIT>subtract<CODESPLIT>Subtracts vector b from vector a<CODESPLIT>function subtract ( out , a , b ) { out [ 0 ] = a [ 0 ] - b [ 0 ] ; out [ 1 ] = a [ 1 ] - b [ 1 ] ; out [ 2 ] = a [ 2 ] - b [ 2 ] ; return out ; }

1<CODESPLIT>https://github.com/skerit/alchemy-styleboost/blob/2b90b8a6afc9f065f785651292fb193940021d90/public/ckeditor/4.4dev/core/htmlparser/element.js#L466-L480<CODESPLIT><CODESPLIT>Removes a class name from the list of classes .<CODESPLIT>function ( className ) { var classes = this . attributes [ 'class' ] ; if ( ! classes ) return ; // We can safely assume that className won't break regexp. // http://stackoverflow.com/questions/448981/what-characters-are-valid-in-css-class-names classes = CKEDITOR . tools . trim ( classes . replace ( new RegExp ( '(?:\\s+|^)' + className + '(?:\\s+|$)' ) , ' ' ) ) ; if ( classes ) this . attributes [ 'class' ] = classes ; else delete this . attributes [ 'class' ] ; }

0<CODESPLIT>https://github.com/NASAWorldWind/WebWorldWind/blob/399daee66deded581a2d1067a2ac04232c954b8f/src/util/WWMath.js#L538-L545<CODESPLIT><CODESPLIT>Computes the distance to a globe s horizon from a viewer at a given altitude .<CODESPLIT>function ( farDistance , farResolution , depthBits ) { if ( farDistance < 0 ) { throw new ArgumentError ( Logger . logMessage ( Logger . LEVEL_SEVERE , "WWMath" , "perspectiveNearDistanceForFarDistance" , "The specified distance is negative." ) ) ; } if ( farResolution < 0 ) { throw new ArgumentError ( Logger . logMessage ( Logger . LEVEL_SEVERE , "WWMath" , "perspectiveNearDistanceForFarDistance" , "The specified resolution is negative." ) ) ; } if ( depthBits < 1 ) { throw new ArgumentError ( Logger . logMessage ( Logger . LEVEL_SEVERE , "WWMath" , "perspectiveNearDistanceForFarDistance" , "The specified depth bits is negative." ) ) ; } var maxDepthValue = ( 1 << depthBits ) - 1 ; return farDistance / ( maxDepthValue / ( 1 - farResolution / farDistance ) - maxDepthValue + 1 ) ; }

0<CODESPLIT>https://github.com/vicanso/koa-simple-session/blob/20001e595a801ab401c68eac6303ecf06390fbd8/lib/session.js#L96-L104<CODESPLIT>updateDOM<CODESPLIT>generate a new session<CODESPLIT>function updateDOM ( newFilterTree ) { var newTableFilter = newFilterTree . children [ 0 ] , newColumnFilters = newFilterTree . children [ 1 ] ; if ( ! filterTree ) { tabz . folder ( '#tabTableFilterQuery' ) . appendChild ( newTableFilter . el ) ; tabz . folder ( '#tabColumnFilterQuery' ) . appendChild ( newColumnFilters . el ) ; } else { tabz . folder ( '#tabTableFilterQuery' ) . replaceChild ( newTableFilter . el , tableFilter . el ) ; tabz . folder ( '#tabColumnFilterQuery' ) . replaceChild ( newColumnFilters . el , columnFilters . el ) ; } filterTree = newFilterTree ; tableFilter = newTableFilter ; columnFilters = newColumnFilters ; }

1<CODESPLIT>https://github.com/trevorparscal/node-palo/blob/425efdcf027c71296c732765afdf5cacae6a1a3e/lib/Resource.js#L10-L23<CODESPLIT>Resource<CODESPLIT>@class<CODESPLIT>function Resource ( pkg , config ) { var key ; // Properties this . pkg = pkg ; this . config = { } ; // Initialization for ( key in config ) { if ( Object . prototype . hasOwnProperty . call ( config , key ) ) { this . config [ key ] = config [ key ] ; } } }

0<CODESPLIT>https://github.com/kevinoid/promise-nodeify/blob/1542cb7824c1b5e0e19e925dfb9650bfe8c7cdbd/benchmark/index.js#L136-L144<CODESPLIT><CODESPLIT>Deletes the globals added by {<CODESPLIT>function ( evt ) { var data = getScriptData ( evt ) ; if ( ! hasPathFallback ( data . id ) ) { var parents = [ ] ; eachProp ( registry , function ( value , key ) { if ( key . indexOf ( '_@r' ) !== 0 ) { each ( value . depMaps , function ( depMap ) { if ( depMap . id === data . id ) { parents . push ( key ) ; return true ; } } ) ; } } ) ; return onError ( makeError ( 'scripterror' , 'Script error for "' + data . id + ( parents . length ? '", needed by: ' + parents . join ( ', ' ) : '"' ) , evt , [ data . id ] ) ) ; } }

0<CODESPLIT>https://github.com/kissyteam/kissy-xtemplate/blob/1d454ab624c867d6a862d63dba576f8d24c6dcfc/lib/kissy/5.0.0-alpha.3/lib/build/date/gregorian.js#L1170-L1198<CODESPLIT><CODESPLIT>Sets this GregorianCalendar to the date given by the date specifiers - weekYear weekOfYear and dayOfWeek . weekOfYear follows the WEEK_OF_YEAR numbering . The dayOfWeek value must be one of the DAY_OF_WEEK values : SUNDAY to SATURDAY .<CODESPLIT>function ( ) { if ( this . time === undefined ) { this . computeTime ( ) ; } var cal = new GregorianCalendar ( this . timezoneOffset , this . locale ) ; cal . setTime ( this . time ) ; return cal ; }

1<CODESPLIT>https://github.com/facebook/create-react-app/blob/57ef103440c24e41b0d7dc82b7ad7fc1dc817eca/packages/react-dev-utils/FileSizeReporter.js#L27-L104<CODESPLIT>printFileSizesAfterBuild<CODESPLIT>Prints a detailed summary of build files .<CODESPLIT>function printFileSizesAfterBuild ( webpackStats , previousSizeMap , buildFolder , maxBundleGzipSize , maxChunkGzipSize ) { var root = previousSizeMap . root ; var sizes = previousSizeMap . sizes ; var assets = ( webpackStats . stats || [ webpackStats ] ) . map ( stats => stats . toJson ( { all : false , assets : true } ) . assets . filter ( asset => canReadAsset ( asset . name ) ) . map ( asset => { var fileContents = fs . readFileSync ( path . join ( root , asset . name ) ) ; var size = gzipSize ( fileContents ) ; var previousSize = sizes [ removeFileNameHash ( root , asset . name ) ] ; var difference = getDifferenceLabel ( size , previousSize ) ; return { folder : path . join ( path . basename ( buildFolder ) , path . dirname ( asset . name ) ) , name : path . basename ( asset . name ) , size : size , sizeLabel : filesize ( size ) + ( difference ? ' (' + difference + ')' : '' ) , } ; } ) ) . reduce ( ( single , all ) => all . concat ( single ) , [ ] ) ; assets . sort ( ( a , b ) => b . size - a . size ) ; var longestSizeLabelLength = Math . max . apply ( null , assets . map ( a => stripAnsi ( a . sizeLabel ) . length ) ) ; var suggestBundleSplitting = false ; assets . forEach ( asset => { var sizeLabel = asset . sizeLabel ; var sizeLength = stripAnsi ( sizeLabel ) . length ; if ( sizeLength < longestSizeLabelLength ) { var rightPadding = ' ' . repeat ( longestSizeLabelLength - sizeLength ) ; sizeLabel += rightPadding ; } var isMainBundle = asset . name . indexOf ( 'main.' ) === 0 ; var maxRecommendedSize = isMainBundle ? maxBundleGzipSize : maxChunkGzipSize ; var isLarge = maxRecommendedSize && asset . size > maxRecommendedSize ; if ( isLarge && path . extname ( asset . name ) === '.js' ) { suggestBundleSplitting = true ; } console . log ( '  ' + ( isLarge ? chalk . yellow ( sizeLabel ) : sizeLabel ) + '  ' + chalk . dim ( asset . folder + path . sep ) + chalk . cyan ( asset . name ) ) ; } ) ; if ( suggestBundleSplitting ) { console . log ( ) ; console . log ( chalk . yellow ( 'The bundle size is significantly larger than recommended.' ) ) ; console . log ( chalk . yellow ( 'Consider reducing it with code splitting: https://goo.gl/9VhYWB' ) ) ; console . log ( chalk . yellow ( 'You can also analyze the project dependencies: https://goo.gl/LeUzfb' ) ) ; } }

1<CODESPLIT>https://github.com/airyland/vux/blob/484fc3c18bdca99b0c08efbb678c0ee0f5ceedd6/src/components/orientation/orientation.js#L126-L137<CODESPLIT><CODESPLIT>获取横竖屏信息<CODESPLIT>function ( ) { // 90度为横屏 return ( EVT_ORIENTATION_CHANGE === ORIENTATION_CHANGE ) ? { landscape : ( window . orientation === 90 || window . orientation === - 90 ) , portrait : ( window . orientation === 0 || window . orientation === - 180 ) , orientation : window . orientation } : { landscape : window . screen . width > window . screen . height , portrait : window . screen . width <= window . screen . height , orientation : window . screen . width > window . screen . height ? 90 : 0 } }

0<CODESPLIT>https://github.com/YYago/fswsyn/blob/d6fa34b8d079aa28bf9a2a94d82717edfcb8eeba/index.js#L106-L119<CODESPLIT>cleanUpNoComboFiles<CODESPLIT>自定义的 fs . writeFileSync () 试图解决长路径文件不能创建的问题。<CODESPLIT>function cleanUpNoComboFiles ( flist ) { var a = [ ] ; flist . forEach ( function ( item ) { if ( ! / nocombo=true / i . test ( item ) ) { a . push ( item ) ; } } ) ; return a ; }

0<CODESPLIT>https://github.com/gamesys/moonshine/blob/880a44077604fa397ea363e5d683105e58478c5f/vm/moonshine.js#L134-L138<CODESPLIT><CODESPLIT>Prepare an object for reuse .<CODESPLIT>function ( val ) { if ( ! val || ! ( val instanceof shine . Table ) || val . __shine . refCount === undefined ) return ; if ( -- val . __shine . refCount == 0 ) this . collect ( val ) ; }

0<CODESPLIT>https://github.com/jlas/quirky/blob/1ee950d2cc447ea16f189f499fbcd2e25925267c/game-client.js#L112-L132<CODESPLIT>runCodeBlock<CODESPLIT>Countdown timer . Update onscreen timer and end turn if time gets too low .<CODESPLIT>function runCodeBlock ( codeBlock ) { var dir = path . dirname ( codeBlock . filename ) ; return new Promise ( function ( fulfill , reject ) { var filenameWithoutDir = codeBlock . filename . replace ( dir + '/' , '' ) ; var command = runner ( codeBlock , filenameWithoutDir ) ; if ( command === null ) { fulfill ( codeBlock ) ; return ; } exec ( command , { cwd : dir } , function ( error , stdout , stderr ) { if ( error ) { console . error ( error ) ; reject ( error ) ; } else { if ( stdout ) { console . log ( stdout ) ; } if ( stderr ) { console . error ( stderr ) ; } fulfill ( codeBlock ) ; } } ) ; } ) ; }

0<CODESPLIT>https://github.com/winjs/react-winjs/blob/1a117744f24cbeb1729f38debde43550e34affeb/react-winjs.js#L1758-L1764<CODESPLIT>processChildren<CODESPLIT>TODO : Revisit all of this diffing stuff : - Make it more efficient - It s currently hard to understand because it makes aggressive assumptions ( e . g . each item has a key and each item has a winControl ) - Is it correct? - Should we just sync an array with a binding list instead of computing edits based on 2 arrays and then applying them to a binding list?<CODESPLIT>function processChildren ( componentDisplayName , children , childComponentsMap ) { var newChildComponents = [ ] ; var newChildComponentsMap = { } ; // A component's *key* represents its identity. If a component in *children* and a // component in *childComponentsMap* have the same *key*, then they are assumed to // represent the same component. React . Children . forEach ( children , function ( component ) { if ( component ) { if ( component . ref ) { console . warn ( "ref prop (" + component . ref + ") will not work on " + component . type . displayName + " component because it is inside " + "of a " + componentDisplayName + " component" ) ; } if ( component . key === null ) { console . error ( component . type . displayName + " component requires a key " + "when inside of a " + componentDisplayName + " component" ) ; } else { var winjsChildComponent = childComponentsMap [ component . key ] ; if ( winjsChildComponent ) { if ( winjsChildComponent . type === component . type ) { winjsChildComponent . update ( component ) ; } else { // If a component's *type* has changed then the component must be // recreated from scratch rather than updated. The reason is that // the tagName of the underlying DOM element may have changed. The // only way to change the tagName of the underlying DOM element is // to instantiate a new react-winjs component. winjsChildComponent . dispose ( ) ; winjsChildComponent = new WinJSChildComponent ( component ) ; } } else { winjsChildComponent = new WinJSChildComponent ( component ) ; } newChildComponents . push ( winjsChildComponent ) ; newChildComponentsMap [ component . key ] = winjsChildComponent ; } } } ) ; Object . keys ( childComponentsMap ) . forEach ( function ( key ) { if ( ! newChildComponentsMap . hasOwnProperty ( key ) ) { childComponentsMap [ key ] . dispose ( ) ; } } ) ; return { childComponents : newChildComponents , childComponentsMap : newChildComponentsMap } ; }

0<CODESPLIT>https://github.com/UNLOQIO/unloq-node-client/blob/f88adeb7f0d3c729c6b578bff4aa5f548b84133b/lib/pair/private.js#L9-L12<CODESPLIT>removeFriendship<CODESPLIT>/ * This is a private key wrapper over node - forge . privateKey that knows how to handle encoding creation and other such things .<CODESPLIT>function removeFriendship ( m1 , m2 ) { return this . update ( { _id : m1 } , { $pull : _defineProperty ( { } , pathName , { _id : m2 } ) } ) ; }

0<CODESPLIT>https://github.com/tsmith/node-control/blob/6bd8a39a6bb1faaa9efccc300ca2ec48ebcaffa0/lib/log.js#L15-L60<CODESPLIT>Log<CODESPLIT>prefix : added to log prefix to appear on each line if message has new lines<CODESPLIT>function Log ( prefix , path , echo , timestamp ) { var filestream ; if ( path ) { filestream = createWriteStream ( path ) ; } timestamp = timestamp || require ( './timestamp' ) ; return { prefix : prefix , path : path , filestream : filestream , echo : echo , timestamp : timestamp , puts : puts } ; }

1<CODESPLIT>https://github.com/eslint/eslint/blob/bc0819c94aad14f7fad3cbc2338ea15658b0f272/lib/rules/comma-style.js#L110-L119<CODESPLIT>getFixerFunction<CODESPLIT>Determines the fixer function for a given style .<CODESPLIT>function getFixerFunction ( styleType , previousItemToken , commaToken , currentItemToken ) { const text = sourceCode . text . slice ( previousItemToken . range [ 1 ] , commaToken . range [ 0 ] ) + sourceCode . text . slice ( commaToken . range [ 1 ] , currentItemToken . range [ 0 ] ) ; const range = [ previousItemToken . range [ 1 ] , currentItemToken . range [ 0 ] ] ; return function ( fixer ) { return fixer . replaceTextRange ( range , getReplacedText ( styleType , text ) ) ; } ; }

1<CODESPLIT>https://github.com/albertorestifo/node-dijkstra/blob/2de3f878f2e816b21bc063e38231d857d7f1afd1/libs/toDeepMap.js#L24-L43<CODESPLIT>toDeepMap<CODESPLIT>Creates a deep Map from the passed object .<CODESPLIT>function toDeepMap ( source ) { const map = new Map ( ) ; const keys = Object . keys ( source ) ; keys . forEach ( ( key ) => { const val = source [ key ] ; if ( val !== null && typeof val === 'object' && ! Array . isArray ( val ) ) { return map . set ( key , toDeepMap ( val ) ) ; } if ( ! isValidNode ( val ) ) { throw new Error ( ` ${ key } ` , val ) ; } return map . set ( key , Number ( val ) ) ; } ) ; return map ; }

0<CODESPLIT>https://github.com/gflarity/response/blob/bf1f7342afbdf460970935e61abda14d8ef947fe/lib/graphite.js#L34-L57<CODESPLIT>defineSchemaTable<CODESPLIT>setup our handlers for this connection data<CODESPLIT>function defineSchemaTable ( schema ) { return function ( table ) { table . timestamps ( ) ; ( schema . build || _ . noop ) ( table ) ; } ; }

0<CODESPLIT>https://github.com/byron-dupreez/logging-utils/blob/b5edac6efb288a2276dc88159a935d36816a859f/logging.js#L405-L426<CODESPLIT>extendLogFunction<CODESPLIT>A convenience function that delegates the logging to the log method of either the given logger ( if its defined and has a log or info method ) or to console ( if not )<CODESPLIT>function extendLogFunction ( target , log ) { /**    * An extension of the conventional log method that first checks if the first argument contains a valid log level and    * if so instead delegates the call to the appropriate logging function for the specified log level (passing the rest    * of the first argument (if any) and all arguments after the first argument to it); or otherwise simply delegates the    * log call to the underlying logger's log method passing ALL of the original arguments to it.    * @param {...*} data - zero or more data items to be logged - with special meaning assigned to the first argument by    * this function and also possibly by the underlying logger's log method (e.g. see console.log)    */ function logAtLevel ( data ) { const self = this || target ; // If NO arguments were passed, then delegate a no-arg call to the given logger log function const len = arguments . length ; if ( len <= 0 ) { log ( ) ; return ; } const [ logLevel , rest ] = extractLogLevelAndRest ( arguments [ 0 ] ) ; let args ; if ( ! logLevel ) { // No log level, so use all arguments passed as is args = arguments ; } else if ( rest ) { // First argument contained MORE than just a log level, so use the rest of the first argument as the first argument args = arguments ; args [ 0 ] = rest ; } else { // First argument ONLY contained a log level, so drop the first argument args = new Array ( len - 1 ) ; for ( let i = 1 ; i < len ; ++ i ) { args [ i - 1 ] = arguments [ i ] ; } } switch ( logLevel ) { case LogLevel . ERROR : self . error . apply ( null , args ) ; return ; case LogLevel . WARN : self . warn . apply ( null , args ) ; return ; case LogLevel . INFO : self . info . apply ( null , args ) ; return ; case LogLevel . DEBUG : self . debug . apply ( null , args ) ; return ; case LogLevel . TRACE : self . trace . apply ( null , args ) ; return ; case 'LOG' : log . apply ( null , args ) ; // log is already bound to its logger, so ignore thisArg return ; default : // If no valid log level was provided as a first argument then default to calling the given logger log function // using ALL of the arguments as data log . apply ( null , arguments ) ; // log is already bound to its logger, so ignore thisArg return ; } } return logAtLevel ; }

0<CODESPLIT>https://github.com/matrix-org/matrix-appservice-bridge/blob/33eb59890b36c0caf043d312f64a04d2526e4554/lib/components/app-service-bot.js#L12-L27<CODESPLIT>defaultResolveFn<CODESPLIT>Construct an AS bot user which has various helper methods .<CODESPLIT>function defaultResolveFn ( source , args , context , info ) { var fieldName = info . fieldName ; // ensure source is a value for which property access is acceptable. if ( typeof source === 'object' || typeof source === 'function' ) { return typeof source [ fieldName ] === 'function' ? source [ fieldName ] ( ) : source [ fieldName ] ; } }

1<CODESPLIT>https://github.com/jias/eoraptor.js/blob/65483f3c6c001d75de3f5c240d999351f73d1fc1/ref/nunjucks.js#L762-L769<CODESPLIT><CODESPLIT>... todo 目的何在<CODESPLIT>function ( name ) { var p = this . parent ; var val = this . variables [ name ] ; if ( val != null ) { return this ; } return p && p . resolve ( name ) ; }

0<CODESPLIT>https://github.com/jgraph/mxgraph/blob/33911ed7e055c17b74d0367f5f1f6c9ee4b4fd44/javascript/mxClient.js#L13011-L13038<CODESPLIT>mxDivResizer<CODESPLIT>Copyright ( c ) 2006 - 2015 JGraph Ltd Copyright ( c ) 2006 - 2015 Gaudenz Alder Class : mxDragSource<CODESPLIT>function mxDivResizer ( div , container ) { if ( div . nodeName . toLowerCase ( ) == 'div' ) { if ( container == null ) { container = window ; } this . div = div ; var style = mxUtils . getCurrentStyle ( div ) ; if ( style != null ) { this . resizeWidth = style . width == 'auto' ; this . resizeHeight = style . height == 'auto' ; } mxEvent . addListener ( container , 'resize' , mxUtils . bind ( this , function ( evt ) { if ( ! this . handlingResize ) { this . handlingResize = true ; this . resize ( ) ; this . handlingResize = false ; } } ) ) ; this . resize ( ) ; } }

1<CODESPLIT>https://github.com/ember-cli/loader.js/blob/4fe5b3dfd5e1a30d706d289bb4e5fdbd5a799101/benchmarks/scenarios/ember.js#L28543-L28560<CODESPLIT><CODESPLIT>Sends an action to the router which will delegate it to the currently active route hierarchy per the bubbling rules explained under actions . Example javascript App . Router . map ( function () { this . route ( index ) ; } ) ; App . ApplicationRoute = Ember . Route . extend ( { actions : { track : function ( arg ) { console . log ( arg was clicked ) ; } } } ) ; App . IndexRoute = Ember . Route . extend ( { actions : { trackIfDebug : function ( arg ) { if ( debug ) { this . send ( track arg ) ; } } } } ) ;<CODESPLIT>function ( ) { for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key ++ ) { args [ _key ] = arguments [ _key ] ; } if ( this . router && this . router . router || ! _emberMetalCore . default . testing ) { var _router ; ( _router = this . router ) . send . apply ( _router , args ) ; } else { var name = args [ 0 ] ; args = slice . call ( args , 1 ) ; var action = this . actions [ name ] ; if ( action ) { return this . actions [ name ] . apply ( this , args ) ; } } }

1<CODESPLIT>https://github.com/cuttingsoup/react-native-firebase-local-cache/blob/db755a66d6936710e85161ecfced56a1ea432887/dist/index.js#L200-L219<CODESPLIT>twice<CODESPLIT>Twice one better than once! Operates in a similar way to onValue however snapCallback will only ever be called once when fresh data arrives . The value returned by snapCallback will be cached immediately then passed to the processedCallback . If cached data is available when the listener is first turned on it will be loaded and passed to processedCallback . Once data is cached then each call to twice will call processedCallback twice once with cached data then once with fresh data after being processed by snapCallback .<CODESPLIT>function twice ( dbRef , snapCallback , processedCallback , cancelCallbackOrContext , context ) { var storageKey = getStorageKeyFromDbRef ( dbRef , 'twice' ) ; return _reactNative . AsyncStorage . getItem ( storageKey ) . then ( function ( value ) { // Called processedCallback with cached value. if ( value !== null ) { var cachedVal = JSON . parse ( value ) ; callWithContext ( processedCallback , cachedVal , cancelCallbackOrContext , context ) ; } } ) . then ( function ( ) { var callbackPeak = function callbackPeak ( snap ) { var processed = snapCallback . bind ( this ) ( snap ) ; //Store to cache. _reactNative . AsyncStorage . setItem ( storageKey , JSON . stringify ( processed ) ) . then ( function ( ) { processedCallback . bind ( this ) ( processed ) ; } . bind ( this ) ) ; } ; dbRef . once ( 'value' , callbackPeak , cancelCallbackOrContext , context ) ; } ) ; }

0<CODESPLIT>https://github.com/bitovi/documentjs/blob/5f6af5b213b840a0bfca1e146f1678db853f3b60/lib/stmd.js#L720-L747<CODESPLIT><CODESPLIT>The InlineParser object .<CODESPLIT>function ( tag , start_line , start_column ) { return { t : tag , open : true , last_line_blank : false , start_line : start_line , start_column : start_column , end_line : start_line , children : [ ] , parent : null , // string_content is formed by concatenating strings, in finalize: string_content : "" , strings : [ ] , inline_content : [ ] } ; }

1<CODESPLIT>https://github.com/S3bb1/ah-dashboard-plugin/blob/c283370ec0f99a25db5bb7029a98b4febf8c5251/public/dashboard/bower_components/fancytree/dist/jquery.fancytree-all.js#L734-L741<CODESPLIT><CODESPLIT>Return the hierarchical child index ( 1 - based e . g . 3 . 2 . 4 ) .<CODESPLIT>function ( separator ) { separator = separator || "." ; var res = [ ] ; $ . each ( this . getParentList ( false , true ) , function ( i , o ) { res . push ( o . getIndex ( ) + 1 ) ; } ) ; return res . join ( separator ) ; }

0<CODESPLIT>https://github.com/SAP/openui5/blob/8a832fca01cb1cdf8df589788e0c5723e2a33c70/src/sap.ui.documentation/src/sap/ui/documentation/sdk/controller/ApiDetail.controller.js#L100-L121<CODESPLIT><CODESPLIT>Init the Sub View and controller<CODESPLIT>function ( oBorrowedData ) { // Attach resolved borrowed data this . _oControlData . borrowed = oBorrowedData ; // Pre-process data and create model this . _bindData ( this . _sTopicid ) ; // Create the sub-view and controller this . _oView = sap . ui . view ( { height : "100%" , viewName : "sap.ui.documentation.sdk.view.SubApiDetail" , type : ViewType . XML , async : true , preprocessors : { xml : { models : { data : this . _oModel } } } } ) ; // Return view loaded promise return this . _oView . loaded ( ) ; }

0<CODESPLIT>https://github.com/kengz/poly-socketio/blob/261f84d3b4267a6d1a36eadd6526ddb45369973e/src/global-client.js#L12-L26<CODESPLIT>pass<CODESPLIT>init a global client at port<CODESPLIT>function pass ( to , input ) { var defer = cdefer ( ) clientPass ( defer . resolve , to , input ) return defer . promise . catch ( ( err ) => { console . log ( ` ${ input } ${ JSON . stringify ( to ) } ` ) } ) }

1<CODESPLIT>https://github.com/redisjs/jsr-store/blob/b2b5c5b0347819f8a388b5d67e121ee8d73f328c/lib/command/zset.js#L79-L86<CODESPLIT>zincrby<CODESPLIT>Increments the score of member in the sorted set stored at key by increment .<CODESPLIT>function zincrby ( key , increment , member , req ) { var val = this . getKey ( key , req ) ; if ( val === undefined ) { val = new SortedSet ( ) ; this . setKey ( key , val , undefined , undefined , undefined , req ) ; } return val . zincrby ( increment , member ) ; }

0<CODESPLIT>https://github.com/jmendiara/gitftw/blob/ba91b0d68b7791b5b557addc685737f6c912b4f3/src/commands.js#L535-L553<CODESPLIT>removeRemoteBranch<CODESPLIT>Gets the current workspace is clean or has something in the working tree Executes git diff - index -- quiet HEAD .<CODESPLIT>function removeRemoteBranch ( options ) { assert . ok ( options . branch , 'branch is mandatory' ) ; var args = [ 'push' , options . remote || 'origin' , ':' + options . branch ] ; return git ( args ) . then ( silent ) ; }

0<CODESPLIT>https://github.com/bfontaine/ArrayDB/blob/011939dda73cfbea112bb803480e849afba14e92/src/arraydb.js#L117-L127<CODESPLIT>match_objects_teardown<CODESPLIT>clean up marked objects<CODESPLIT>function match_objects_teardown ( o , p , result ) { if ( get_type ( o ) == 'object' ) { cleanMarks ( o ) ; } if ( get_type ( p ) == 'object' ) { cleanMarks ( p ) ; } return result ; }

0<CODESPLIT>https://github.com/RnbWd/parse-browserify/blob/c19c1b798e4010a552e130b1a9ce3b5d084dc101/lib/op.js#L434-L441<CODESPLIT><CODESPLIT>Returns an array of unfetched Parse . Object that are being removed from the relation .<CODESPLIT>function ( json ) { var decoder = Parse . Op . _opDecoderMap [ json . __op ] ; if ( decoder ) { return decoder ( json ) ; } else { return undefined ; } }

1<CODESPLIT>https://github.com/phelpstream/svp/blob/2f99adb9c5d0709e567264bba896d6a59f6a0a59/lib/functions/dig.js#L29-L55<CODESPLIT>dig<CODESPLIT>Loop recursively through an iterable data structure .<CODESPLIT>function dig ( obj ) { var iterateeFn = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : function ( val , key , iterableParent ) { return val ; } ; // eslint-disable-line no-unused-vars // modifierFn = v => v, return ( 0 , _each2 . default ) ( obj , function iterator ( itValue , key , itObj ) { var processedItValue = itValue ; // console.log("processedItValue (before)", processedItValue) if ( ( 0 , _is . isIterable ) ( itValue , { objects : true } ) ) { // console.log("Is iterable, key:", key) processedItValue = ( 0 , _each2 . default ) ( itValue , iterator ) ; // , iterateeFn } var iterateeReturnedValue = iterateeFn ( processedItValue , key , itObj ) ; // console.log("iterateeReturnedValue", iterateeReturnedValue) if ( ( 0 , _is . isObject ) ( iterateeReturnedValue ) && ( 0 , _is . isLength ) ( ( 0 , _toKeys2 . default ) ( iterateeReturnedValue ) , 1 ) && ( 0 , _get2 . default ) ( iterateeReturnedValue , "$remove" , false ) === true ) { return { $remove : true } ; } else if ( ( 0 , _is . isDefined ) ( iterateeReturnedValue ) ) { return iterateeReturnedValue ; } else { // console.log("processedItValue (after)", processedItValue) return processedItValue ; } } //,  iterateeFn ) ; }

0<CODESPLIT>https://github.com/pouchdb-community/pouchdb-adapter-cordova-sqlite/blob/380246ea1f8723968ab93bd6f5789df321fbfda2/lib/index.js#L7-L27<CODESPLIT><CODESPLIT>/ * global cordova sqlitePlugin openDatabase<CODESPLIT>function ( rootError ) { cachedClient . abortMultipartUpload ( { Bucket : destinationDetails . Bucket , Key : destinationDetails . Key , UploadId : multipartUploadID } , function ( abortError ) { if ( abortError ) ws . emit ( 'error' , rootError + '\n Additionally failed to abort the multipart upload on S3: ' + abortError ) ; else ws . emit ( 'error' , rootError ) ; } ) ; }

1<CODESPLIT>https://github.com/thetartan/identartan/blob/f1e9aeb5938759b133193f89cb6d19d9c9a27ea0/src/parse.js#L14-L20<CODESPLIT>buildTree<CODESPLIT>/ * options = { + default options for core transformSyntaxTree : <default > }<CODESPLIT>function buildTree ( tokens ) { var items = _ . map ( tokens , function ( token ) { return tartan . utils . node . newStripe ( token ) ; } ) ; var isReflected = ( tokens . length >= 2 ) && ( tokens [ 0 ] . isPivot ) ; return tartan . utils . node . newRootBlock ( items , isReflected ) ; }

1<CODESPLIT>https://github.com/Industryswarm/isnode-mod-data/blob/5adc639b88a0d72cbeef23a6b5df7f4540745089/lib/mongodb/mongodb-core/lib/sdam/cursor.js#L485-L494<CODESPLIT>isCursorDeadButNotkilled<CODESPLIT>Validate if the cursor is dead but was not explicitly killed by user<CODESPLIT>function isCursorDeadButNotkilled ( cursor , callback ) { // Cursor is dead but not marked killed, return null if ( cursor . s . dead && ! cursor . s . killed ) { cursor . s . killed = true ; setCursorNotified ( cursor , callback ) ; return true ; } return false ; }

1<CODESPLIT>https://github.com/tywei90/arr-del/blob/c1f55b9621a154785d8ef35bfc60fb4d1c3a2d62/index.js#L21-L64<CODESPLIT>arrDel<CODESPLIT>Delete array elements in one time by array consists of their indexes<CODESPLIT>function arrDel ( arr , indexArr ) { // check params if ( arr == null ) { return [ ] ; } else if ( Object . prototype . toString . call ( arr ) !== "[object Array]" ) { throw new TypeError ( 'PARAM MUST BE ARRAY' ) ; } if ( indexArr == null ) { return arr } else if ( Object . prototype . toString . call ( indexArr ) !== "[object Array]" ) { throw new TypeError ( 'PARAM MUST BE ARRAY' ) ; } var arrLen = arr . length ; for ( var i = 0 , len = indexArr . length ; i < len ; i ++ ) { if ( typeof indexArr [ i ] !== "number" ) { throw new TypeError ( 'PARAM MUST BE NUMBER ARRAY' ) ; } if ( Math . abs ( indexArr [ i ] ) > arrLen ) { indexArr [ i ] = arrLen + 1 ; } if ( indexArr [ i ] >= - arrLen && indexArr [ i ] < 0 ) { indexArr [ i ] = indexArr [ i ] + arrLen ; } } // first sort indexArr, then remove redupliction indexArr . sort ( function ( a , b ) { return a - b } ) var tmpArr = [ ] ; for ( var i = 0 , len = indexArr . length ; i < len ; i ++ ) { if ( tmpArr . indexOf ( indexArr [ i ] ) == - 1 ) { tmpArr . push ( indexArr [ i ] ) } } // should not change the value of input arr var outArr = JSON . parse ( JSON . stringify ( arr ) ) ; if ( arr . length === 0 ) { return [ ] ; } for ( var i = 0 , len = tmpArr . length ; i < len ; i ++ ) { outArr . splice ( tmpArr [ i ] - i , 1 ) ; } return outArr }

0<CODESPLIT>https://github.com/jmorrell/backbone-filtered-collection/blob/880672e7edbc3eb2151f569fe009d62d03d989c4/examples/map/js/backbone.marionette.js#L974-L992<CODESPLIT><CODESPLIT>Add an individual region to the region manager and return the region instance<CODESPLIT>function ( ) { this . removeRegions ( ) ; var args = Array . prototype . slice . call ( arguments ) ; Marionette . Controller . prototype . close . apply ( this , args ) ; }

0<CODESPLIT>https://github.com/transloadit/uppy/blob/7ae18bf992d544a64da998f033258ec09a3de275/packages/@uppy/companion/src/server/helpers/utils.js#L110-L114<CODESPLIT>readEntries<CODESPLIT>Ensure that a user - provided secret is 32 bytes long ( the length required for an AES256 key ) by hashing it with SHA256 .<CODESPLIT>function readEntries ( directoryReader , oldEntries , callback ) { directoryReader . readEntries ( ( entries ) => { const newEntries = [ ... oldEntries , ... entries ] // According to the FileSystem API spec, readEntries() must be called until it calls the callback with an empty array. if ( entries . length ) { setTimeout ( ( ) => { readEntries ( directoryReader , newEntries , callback ) } , 0 ) // Done iterating this particular directory } else { callback ( newEntries ) } } , // Make sure we resolve on error anyway ( ) => callback ( oldEntries ) ) }

1<CODESPLIT>https://github.com/gpbl/react-day-picker/blob/421af9f56b1b07ed58f864678b3bbb8617cdaff7/lib/src/ModifiersUtils.js#L69-L79<CODESPLIT>getModifiersForDay<CODESPLIT>Return the modifiers matching the given day for the given object of modifiers .<CODESPLIT>function getModifiersForDay ( day ) { var modifiersObj = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : { } ; return Object . keys ( modifiersObj ) . reduce ( function ( modifiers , modifierName ) { var value = modifiersObj [ modifierName ] ; if ( dayMatchesModifier ( day , value ) ) { modifiers . push ( modifierName ) ; } return modifiers ; } , [ ] ) ; }

0<CODESPLIT>https://github.com/caroso1222/amazon-autocomplete/blob/1638b787296b6e248687b263e9e12a472470972d/src/amazon-autocomplete.js#L202-L205<CODESPLIT>_processOnKeyUp__noWords<CODESPLIT>Remove the ac__word -- selected class from the desired element . Used when navigating through the ui widget .<CODESPLIT>function _processOnKeyUp__noWords ( evt ) { let key = evt . keyCode || evt . which ; let char = String . fromCharCode ( key ) ; if ( key == 13 ) { this . _onSelectedCB ( this . _input . value ) ; } else if ( / [a-zA-Z0-9-_ ] / . test ( char ) || key === 8 ) { let prefix = this . _input . value ; if ( prefix != '' ) this . _keyListenerDebounced ( prefix ) ; } }

0<CODESPLIT>https://github.com/GeekyAnts/vue-native-core/blob/a7b4c9e35fe3f01d7576086f41e5e9ec6975b72e/src/platforms/weex/runtime/modules/transition.js#L227-L265<CODESPLIT>enter<CODESPLIT>determine the target animation style for an entering transition .<CODESPLIT>function enter ( ref ) { var el = ref . el ; var cb = ref . cb ; var ref$1 = this . transitionResolved ; var css = ref$1 . css ; var type = ref$1 . type ; var enterClass = ref$1 . enterClass ; var enterToClass = ref$1 . enterToClass ; var enterActiveClass = ref$1 . enterActiveClass ; var appearClass = ref$1 . appearClass ; var appearToClass = ref$1 . appearToClass ; var appearActiveClass = ref$1 . appearActiveClass ; var onBeforeEnter = ref$1 . onBeforeEnter ; var onEnter = ref$1 . onEnter ; var onAfterEnter = ref$1 . onAfterEnter ; var onEnterCancelled = ref$1 . onEnterCancelled ; var onBeforeAppear = ref$1 . onBeforeAppear ; var appear = ref$1 . appear ; var onAppear = ref$1 . onAppear ; var onAfterAppear = ref$1 . onAfterAppear ; var onAppearCancelled = ref$1 . onAppearCancelled ; var duration = ref$1 . duration ; var isAppear = this . isAppear ; if ( isUndef ( el ) ) { return } if ( isAppear && ! appear && appear !== '' ) { return } if ( isDef ( el . _enterCb ) || el . nodeType !== 1 ) { return } var startClass = isAppear && appearClass ? appearClass : enterClass ; var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass ; var toClass = isAppear && appearToClass ? appearToClass : enterToClass ; var beforeEnterHook = isAppear ? ( onBeforeAppear || onBeforeEnter ) : onBeforeEnter ; var enterHook = isAppear ? ( onAppear || onEnter ) : onEnter ; var afterEnterHook = isAppear ? ( onAfterAppear || onAfterEnter ) : onAfterEnter ; var enterCancelledHook = isAppear ? ( onAppearCancelled || onEnterCancelled ) : onEnterCancelled ; var explicitEnterDuration = toNumber ( isObject ( duration ) ? duration . enter : duration ) ; if ( process . env . NODE_ENV !== 'production' && explicitEnterDuration != null ) { checkDuration ( explicitEnterDuration , 'enter' ) ; } var expectsCSS = css !== false && ! isIE9 ; var userWantsControl = getHookArgumentsLength ( enterHook ) ; var _cb = el . _enterCb = once ( function ( ) { if ( expectsCSS ) { removeTransitionClass$$1 ( el , activeClass ) ; removeTransitionClass$$1 ( el , toClass ) ; } cb && cb ( ) ; if ( _cb . cancelled ) { if ( expectsCSS ) { removeTransitionClass$$1 ( el , startClass ) ; } enterCancelledHook && enterCancelledHook ( el ) ; } else { afterEnterHook && afterEnterHook ( el ) ; } el . _enterCb = null ; } ) ; beforeEnterHook && beforeEnterHook ( el ) ; if ( expectsCSS ) { addTransitionClass$$1 ( el , startClass ) ; addTransitionClass$$1 ( el , activeClass ) ; nextFrame ( function ( ) { removeTransitionClass$$1 ( el , startClass ) ; addTransitionClass$$1 ( el , toClass ) ; if ( ! _cb . cancelled && ! userWantsControl ) { if ( isValidDuration ( explicitEnterDuration ) ) { setTimeout ( _cb , explicitEnterDuration ) ; } else { whenTransitionEnds ( el , type || getTransitionInfo ( el ) . type , _cb ) ; } } } ) ; } nextFrame ( function ( ) { return enterHook && enterHook ( el , _cb ) ; } ) ; if ( ! expectsCSS && ! userWantsControl ) { _cb ( ) ; } }

0<CODESPLIT>https://github.com/tobkle/create-graphql-server-authorization/blob/d40718907f6d2bfb76fdcb4d2e0ae8ede5701456/src/generator/getContext.js#L262-L264<CODESPLIT>buildFieldContext<CODESPLIT>prepare roles for code generator convert array to String value replace by<CODESPLIT>function buildFieldContext ( fieldType : string , { typeName , fieldName , argsStr , ReturnTypeName , query } : { typeName : string , fieldName : string , argsStr : string , ReturnTypeName : string , query : string } , codeType : string ) : any { // clone the string let argFields = ( ' ' + argsStr ) . slice ( 1 ) ; // populate some arguments with defaults const argsWithDefaultsStr = argsStr . replace ( 'lastCreatedAt' , 'lastCreatedAt = 0' ) . replace ( 'limit' , 'limit = 10' ) ; // prepares a fields string to pass on to the referenced type if ( fieldType === PAGINATED && argFields !== '' ) { argFields = argFields . replace ( '{ ' , '{ baseQuery, ' ) ; } // returns the build field context return { fieldType : fieldType || '' , fieldName : fieldName || '' , typeName : typeName || '' , TypeName : ucFirst ( typeName ) || '' , ReturnTypeName : ReturnTypeName || '' , argsString : argsWithDefaultsStr || '' , argsFields : argFields || '' , query : query || '' } ; }

0<CODESPLIT>https://github.com/joewalker/gcli/blob/672ddac06402c82c44b4e45fe9336347b9c810bb/lib/gcli/fields/selection.js#L29-L44<CODESPLIT><CODESPLIT>A field that allows selection of one of a number of options<CODESPLIT>function ( ev ) { if ( fireHoldCount > 0 ) { heldEvents . push ( ev ) ; if ( eventDebug ) { console . log ( 'Held fire: ' + name , ev ) ; } return ; } if ( eventDebug ) { console . group ( 'Fire: ' + name + ' to ' + handlers . length + ' listeners' , ev ) ; } // Use for rather than forEach because it step debugs better, which is // important for debugging events for ( var i = 0 ; i < handlers . length ; i ++ ) { var handler = handlers [ i ] ; if ( eventDebug ) { console . log ( nameFunction ( handler ) ) ; } handler . func . call ( handler . scope , ev ) ; } if ( eventDebug ) { console . groupEnd ( ) ; } }

0<CODESPLIT>https://github.com/litixsoft/lx-valid/blob/ae879336d2fdea69afa86dc6d1332587fda7bc18/lx-valid.js#L901-L1039<CODESPLIT>types<CODESPLIT>Check formats<CODESPLIT>function types ( ) { var pub = { } ; var i ; var keys = Object . keys ( revalidator . validate . types ) ; var length = keys . length ; for ( i = 0 ; i < length ; i ++ ) { pub [ keys [ i ] ] = getValidationFunctionForTypesByKey ( keys [ i ] ) ; } return pub ; }

0<CODESPLIT>https://github.com/pissang/claygl/blob/b157bb50cf8c725fa20f90ebb55481352777f0a7/dist/claygl.es.js#L29771-L29829<CODESPLIT><CODESPLIT>Update light volume mesh Light volume mesh is rendered in light accumulate pass instead of full quad . It will reduce pixels significantly when local light is relatively small . And we can use custom volume mesh to shape the light . See Deferred Shading Optimizations in GDC2011<CODESPLIT>function ( width , height ) { this . _lightAccumTex . width = width ; this . _lightAccumTex . height = height ; // PENDING viewport ? this . _gBuffer . resize ( width , height ) ; }

0<CODESPLIT>https://github.com/gwtw/js-sorting/blob/158286752539a4ec3bfc7c0f578372953357d4ed/lib/insertion-sort.js#L18-L32<CODESPLIT>sort<CODESPLIT>Sorts an array using insertion sort .<CODESPLIT>function sort ( array , compare , swap ) { var unsortedBelow = array . length ; while ( unsortedBelow !== 0 ) { var lastSwap = 0 ; for ( var i = 1 ; i < unsortedBelow ; i ++ ) { if ( compare ( array , i - 1 , i ) > 0 ) { swap ( array , i , i - 1 ) ; lastSwap = i ; } } unsortedBelow = lastSwap ; } return array ; }

0<CODESPLIT>https://github.com/paritytech/js-api/blob/9ef974118034840309aba45b19dd6d0e93bae23e/src/util/decode.js#L63-L87<CODESPLIT>log<CODESPLIT>takes a method in form name ( ... types ) and returns the inferred abi definition<CODESPLIT>function log ( type , ... rest ) { if ( argv . output ) { console . log ( LOG [ type ] ( rest ) ) ; } }

1<CODESPLIT>https://github.com/ariatemplates/ariatemplates/blob/7ed5d065818ae159bf361c9dfb209b1cf3883c90/src/aria/utils/dragdrop/Drag.js#L376-L386<CODESPLIT><CODESPLIT>Instantiate the proxy instance . @protected @param { Object } args Initialization arguments<CODESPLIT>function ( args ) { var classRef = Aria . getClassRef ( args . classpath ) ; try { var cfg = args . cfg || { } ; cfg . id = this . id || ( "proxy_" + __proxyId ) ; __proxyId ++ ; this . proxy = new classRef ( this . getElement ( ) , cfg ) ; } catch ( ex ) { this . $logError ( this . INVALID_ATTRIBUTE , [ "proxy" , "params" ] ) ; } }

0<CODESPLIT>https://github.com/HospitalRun/hospitalrun-frontend/blob/60b692a1b7aa6f2ef007c28717e76582014e07ad/prod/service-worker-28ddbc7ef7a575da0539a0f05f4bfdae.js#L20310-L20339<CODESPLIT>massageSort<CODESPLIT>collapse logically equivalent gt / gte values<CODESPLIT>function massageSort ( sort ) { if ( ! Array . isArray ( sort ) ) { throw new Error ( 'invalid sort json - should be an array' ) ; } return sort . map ( function ( sorting ) { if ( typeof sorting === 'string' ) { var obj = { } ; obj [ sorting ] = 'asc' ; return obj ; } else { return sorting ; } } ) ; }

0<CODESPLIT>https://github.com/xmaestro/wistia-js/blob/1b6a6bfedda9eada3f3e4c4de5315cd5d30fe986/lib/data.js#L44-L52<CODESPLIT>pick<CODESPLIT>/ *<CODESPLIT>function pick ( source , whitelist ) { var result = { } ; for ( var i = 0 , len = whitelist . length , key ; i < len ; i ++ ) { key = whitelist [ i ] ; if ( has ( source , key ) ) { result [ key ] = source [ key ] ; } } return result ; }

1<CODESPLIT>https://github.com/royriojas/grunt-ez-frontend/blob/84999a25503a7b897292e20ccabcb1bb8aaca119/tasks/tasks-utils.js#L194-L202<CODESPLIT><CODESPLIT>** target ** Executes a target ez - frontend task for both javascript and css<CODESPLIT>function ( ) { var arr = [ ] . slice . call ( arguments ) ; var tasks = [ ] ; arr . forEach ( function ( name ) { var prefixer = / ^css- / . test ( name ) ? 'css-target:' : 'js-target:' ; tasks . push ( prefixer + name ) ; } ) ; grunt . task . run ( tasks ) ; }

0<CODESPLIT>https://github.com/mar10/fancytree/blob/54307b76844177207e321c5b88eb03a23a6e23a2/dist/jquery.fancytree-all-deps.js#L4706-L4829<CODESPLIT>__lazyload<CODESPLIT>/ * Resolve a list of paths relative to one parent node .<CODESPLIT>function __lazyload ( dfd , parent , pathSegList ) { // console.log("__lazyload", parent, "pathSegList=", pathSegList); opts . callback ( self , parent , "loading" ) ; parent . load ( ) . done ( function ( ) { self . _loadKeyPathImpl . call ( self , dfd , opts , parent , pathSegList ) . always ( _makeResolveFunc ( dfd , self ) ) ; } ) . fail ( function ( errMsg ) { self . warn ( "loadKeyPath: error loading lazy " + parent ) ; opts . callback ( self , node , "error" ) ; dfd . rejectWith ( self ) ; } ) ; }

0<CODESPLIT>https://github.com/adobe/brackets/blob/d5d00d43602c438266d32b8eda8f8a3ca937b524/src/extensions/default/JavaScriptRefactoring/RefactoringUtils.js#L116-L138<CODESPLIT>getExpression<CODESPLIT>/ * Checks whether the text between start and end offsets form a valid set of statements<CODESPLIT>function getExpression ( ast , start , end , fileText ) { var expn = findSurroundExpression ( ast , { start : start , end : end } ) ; if ( ! expn ) { return false ; } // Class Expression also includes the trailing semicolon // Add special case for it if ( expn . type === "ClassExpression" && expn . start === start && expn . end - end <= 1 ) { expn . end = end ; return expn ; } else if ( expn . start === start && expn . end === end ) { return expn ; } // Subexpressions are possible only for BinaryExpression, LogicalExpression and SequenceExpression if ( ! ( [ "BinaryExpression" , "LogicalExpression" , "SequenceExpression" ] . includes ( expn . type ) ) ) { return false ; } // Check subexpression var parentExpn = expn ; var parentExpStr = fileText . substr ( parentExpn . start , parentExpn . end - parentExpn . start ) ; // Check whether the parentExpn forms a valid expression after replacing the sub expression var str = parentExpStr . substr ( 0 , start - parentExpn . start ) + "placeHolder" + parentExpStr . substr ( end - parentExpn . start ) ; var node = isStandAloneExpression ( str ) ; if ( node && node . type === parentExpn . type ) { return parentExpn ; } return false ; }

0<CODESPLIT>https://github.com/tpkn/string-to-ms/blob/e1387c11d04de40962f5410447b4fe3b4c8c37ae/string-to-ms.js#L5-L38<CODESPLIT>saveModelSync<CODESPLIT>/ * ! String To Milliseconds http : // tpkn . me /<CODESPLIT>function saveModelSync ( modelName , modelMetadata , modelDir ) { const buffer = ` ${ modelName } ${ JSON . stringify ( modelMetadata , null , '\t' ) } ` fs . writeFileSync ( path . join ( modelDir , modelMetadata . name . toLowerCase ( ) + '.js' ) , buffer ) }

1<CODESPLIT>https://github.com/TerriaJS/terriajs/blob/abcce28ff189f6fdbc0ee541a235ec6cabd90bd5/lib/Models/WebProcessingServiceCatalogGroup.js#L27-L51<CODESPLIT>WebProcessingServiceCatalogGroup<CODESPLIT>A catalog group that is populated by querying available processes from a Web Processing Service ( WPS ) server .<CODESPLIT>function WebProcessingServiceCatalogGroup ( terria ) { CatalogGroup . call ( this , terria ) ; /**    * Gets or sets the URL of the WPS server.  This property is observable.    * @type {String}    */ this . url = "" ; /**    * If true, WPS Execute with a key-value pair GET request, otherwise WPS Execute with an XML encoded POST request.    * @type {Boolean}    * @default false    */ this . executeWithHttpGet = false ; /**    * Gets or sets a hash of properties that will be set on each child item.    * For example, { "treat404AsError": false }    * @type {Object}    */ this . itemProperties = undefined ; knockout . track ( this , [ "url" , "itemProperties" , "executeWithHttpGet" ] ) ; }

0<CODESPLIT>https://github.com/anvilresearch/connect/blob/23bbde151e24df14c20d2e3a209fa46ac46fd751/oidc/verifyEmail.js#L23-L79<CODESPLIT>verifyClientRegistration<CODESPLIT>Verify Email<CODESPLIT>function verifyClientRegistration ( req , res , next ) { // check if we have a token and a token is required var registration = req . body var claims = req . claims var clientRegType = settings . client_registration var required = ( registration . trusted || clientRegType !== 'dynamic' ) var trustedRegScope = settings . trusted_registration_scope var regScope = settings . registration_scope // can't continue because we don't have a token if ( ! ( claims && claims . sub ) && required ) { return next ( new UnauthorizedError ( { realm : 'user' , error : 'invalid_request' , error_description : 'Missing access token' , statusCode : 400 } ) ) } // we have a token, so let's verify it if ( claims && claims . sub ) { // verify the trusted registration scope if ( registration . trusted && ! hasScope ( claims , trustedRegScope ) ) { return next ( new UnauthorizedError ( { realm : 'user' , error : 'insufficient_scope' , error_description : 'User does not have permission' , statusCode : 403 } ) ) } // verify the registration scope if ( ! registration . trusted && clientRegType === 'scoped' && ! hasScope ( claims , regScope ) ) { return next ( new UnauthorizedError ( { realm : 'user' , error : 'insufficient_scope' , error_description : 'User does not have permission' , statusCode : 403 } ) ) } next ( ) // authorization not required/provided } else { next ( ) } }

0<CODESPLIT>https://github.com/vitalets/checklist-model/blob/96b4187da15e2e08a9a9a5ae6b5ed36f51bcee8a/checklist-model.js#L138-L144<CODESPLIT>postLinkFn<CODESPLIT>declare one function to be used for both $watch functions<CODESPLIT>function postLinkFn ( scope , elem , attrs ) { // exclude recursion, but still keep the model var checklistModel = attrs . checklistModel ; attrs . $set ( "checklistModel" , null ) ; // compile with `ng-model` pointing to `checked` $compile ( elem ) ( scope ) ; attrs . $set ( "checklistModel" , checklistModel ) ; // getter for original model var checklistModelGetter = $parse ( checklistModel ) ; var checklistChange = $parse ( attrs . checklistChange ) ; var checklistBeforeChange = $parse ( attrs . checklistBeforeChange ) ; var ngModelGetter = $parse ( attrs . ngModel ) ; var comparator = function ( a , b ) { if ( ! isNaN ( a ) && ! isNaN ( b ) ) { return String ( a ) === String ( b ) ; } else { return angular . equals ( a , b ) ; } } ; if ( attrs . hasOwnProperty ( 'checklistComparator' ) ) { if ( attrs . checklistComparator [ 0 ] == '.' ) { var comparatorExpression = attrs . checklistComparator . substring ( 1 ) ; comparator = function ( a , b ) { return a [ comparatorExpression ] === b [ comparatorExpression ] ; } ; } else { comparator = $parse ( attrs . checklistComparator ) ( scope . $parent ) ; } } // watch UI checked change var unbindModel = scope . $watch ( attrs . ngModel , function ( newValue , oldValue ) { if ( newValue === oldValue ) { return ; } if ( checklistBeforeChange && ( checklistBeforeChange ( scope ) === false ) ) { ngModelGetter . assign ( scope , contains ( checklistModelGetter ( scope . $parent ) , getChecklistValue ( ) , comparator ) ) ; return ; } setValueInChecklistModel ( getChecklistValue ( ) , newValue ) ; if ( checklistChange ) { checklistChange ( scope ) ; } } ) ; // watches for value change of checklistValue var unbindCheckListValue = scope . $watch ( getChecklistValue , function ( newValue , oldValue ) { if ( newValue != oldValue && angular . isDefined ( oldValue ) && scope [ attrs . ngModel ] === true ) { var current = checklistModelGetter ( scope . $parent ) ; checklistModelGetter . assign ( scope . $parent , remove ( current , oldValue , comparator ) ) ; checklistModelGetter . assign ( scope . $parent , add ( current , newValue , comparator ) ) ; } } , true ) ; var unbindDestroy = scope . $on ( '$destroy' , destroy ) ; function destroy ( ) { unbindModel ( ) ; unbindCheckListValue ( ) ; unbindDestroy ( ) ; } function getChecklistValue ( ) { return attrs . checklistValue ? $parse ( attrs . checklistValue ) ( scope . $parent ) : attrs . value ; } function setValueInChecklistModel ( value , checked ) { var current = checklistModelGetter ( scope . $parent ) ; if ( angular . isFunction ( checklistModelGetter . assign ) ) { if ( checked === true ) { checklistModelGetter . assign ( scope . $parent , add ( current , value , comparator ) ) ; } else { checklistModelGetter . assign ( scope . $parent , remove ( current , value , comparator ) ) ; } } } // declare one function to be used for both $watch functions function setChecked ( newArr , oldArr ) { if ( checklistBeforeChange && ( checklistBeforeChange ( scope ) === false ) ) { setValueInChecklistModel ( getChecklistValue ( ) , ngModelGetter ( scope ) ) ; return ; } ngModelGetter . assign ( scope , contains ( newArr , getChecklistValue ( ) , comparator ) ) ; } // watch original model change // use the faster $watchCollection method if it's available if ( angular . isFunction ( scope . $parent . $watchCollection ) ) { scope . $parent . $watchCollection ( checklistModel , setChecked ) ; } else { scope . $parent . $watch ( checklistModel , setChecked , true ) ; } }

1<CODESPLIT>https://github.com/zhanziyang/vue-croppa/blob/46632d9ce254b834150d7fab2febb666e1c7d2a4/docs/static/kute-page_files/common.d313593452690288a963.js#L1829-L1908<CODESPLIT>tokensToFunction<CODESPLIT>Expose a method for transforming tokens into the path function .<CODESPLIT>function tokensToFunction ( tokens ) { // Compile all the tokens into regexps. var matches = new Array ( tokens . length ) ; // Compile all the patterns before compilation. for ( var i = 0 ; i < tokens . length ; i ++ ) { if ( typeof tokens [ i ] === 'object' ) { matches [ i ] = new RegExp ( '^(?:' + tokens [ i ] . pattern + ')$' ) ; } } return function ( obj , opts ) { var path = '' ; var data = obj || { } ; var options = opts || { } ; var encode = options . pretty ? encodeURIComponentPretty : encodeURIComponent ; for ( var i = 0 ; i < tokens . length ; i ++ ) { var token = tokens [ i ] ; if ( typeof token === 'string' ) { path += token ; continue } var value = data [ token . name ] ; var segment ; if ( value == null ) { if ( token . optional ) { // Prepend partial segment prefixes. if ( token . partial ) { path += token . prefix ; } continue } else { throw new TypeError ( 'Expected "' + token . name + '" to be defined' ) } } if ( index$1 ( value ) ) { if ( ! token . repeat ) { throw new TypeError ( 'Expected "' + token . name + '" to not repeat, but received `' + JSON . stringify ( value ) + '`' ) } if ( value . length === 0 ) { if ( token . optional ) { continue } else { throw new TypeError ( 'Expected "' + token . name + '" to not be empty' ) } } for ( var j = 0 ; j < value . length ; j ++ ) { segment = encode ( value [ j ] ) ; if ( ! matches [ i ] . test ( segment ) ) { throw new TypeError ( 'Expected all "' + token . name + '" to match "' + token . pattern + '", but received `' + JSON . stringify ( segment ) + '`' ) } path += ( j === 0 ? token . prefix : token . delimiter ) + segment ; } continue } segment = token . asterisk ? encodeAsterisk ( value ) : encode ( value ) ; if ( ! matches [ i ] . test ( segment ) ) { throw new TypeError ( 'Expected "' + token . name + '" to match "' + token . pattern + '", but received "' + segment + '"' ) } path += token . prefix + segment ; } return path } }

1<CODESPLIT>https://github.com/googlemaps/v3-utility-library/blob/66d4921aba3c0d5aa24d5998e485f46c34a6db27/arcgislink/src/arcgislink.js#L716-L772<CODESPLIT>setCopyrightInfo_<CODESPLIT>Find copyright control in the map<CODESPLIT>function setCopyrightInfo_ ( map ) { var div = null ; if ( map ) { var mvc = map . controls [ G . ControlPosition . BOTTOM_RIGHT ] ; if ( mvc ) { for ( var i = 0 , c = mvc . getLength ( ) ; i < c ; i ++ ) { if ( mvc . getAt ( i ) . id === 'agsCopyrights' ) { div = mvc . getAt ( i ) ; break ; } } } //var callback = callback_(setCopyrightInfo_, null, map);  if ( ! div ) { div = document . createElement ( 'div' ) ; div . style . fontFamily = 'Arial,sans-serif' ; div . style . fontSize = '10px' ; div . style . textAlign = 'right' ; div . id = 'agsCopyrights' ; map . controls [ G . ControlPosition . BOTTOM_RIGHT ] . push ( div ) ; G . event . addListener ( map , 'maptypeid_changed' , function ( ) { setCopyrightInfo_ ( map ) ; } ) ; } var ovs = map . agsOverlays ; var cp = [ ] ; var svc , type ; if ( ovs ) { for ( var i = 0 , c = ovs . getLength ( ) ; i < c ; i ++ ) { addCopyrightInfo_ ( cp , ovs . getAt ( i ) . mapService_ , map ) ; } } var ovTypes = map . overlayMapTypes ; if ( ovTypes ) { for ( var i = 0 , c = ovTypes . getLength ( ) ; i < c ; i ++ ) { type = ovTypes . getAt ( i ) ; if ( type instanceof MapType ) { for ( var j = 0 , cj = type . tileLayers_ . length ; j < cj ; j ++ ) { addCopyrightInfo_ ( cp , type . tileLayers_ [ j ] . mapService_ , map ) ; } } } } type = map . mapTypes . get ( map . getMapTypeId ( ) ) ; if ( type instanceof MapType ) { for ( var i = 0 , c = type . tileLayers_ . length ; i < c ; i ++ ) { addCopyrightInfo_ ( cp , type . tileLayers_ [ i ] . mapService_ , map ) ; } if ( type . negative ) { div . style . color = '#ffffff' ; } else { div . style . color = '#000000' ; } } div . innerHTML = cp . join ( '<br/>' ) ; } }

1<CODESPLIT>https://github.com/craftyjs/Crafty/blob/f3982baa51af24d4e8a14a3194fd3f0e92a2dcba/src/core/core.js#L1876-L1883<CODESPLIT><CODESPLIT>@ #Crafty . timer . FPS @comp Crafty . timer @kind Method<CODESPLIT>function ( value ) { if ( typeof value === "undefined" ) return FPS ; else { FPS = value ; milliSecPerFrame = 1000 / FPS ; Crafty . trigger ( "FPSChange" , value ) ; } }

0<CODESPLIT>https://github.com/Yuffster/discord-engine/blob/7ca5052915dc1d986b533b30f4e5d19f90026b44/classes/World.js#L95-L100<CODESPLIT><CODESPLIT>Adds the player to the world .<CODESPLIT>function ( name , player , target ) { if ( ! name ) return ; var that = this ; if ( ! this . menus [ name ] ) { var path ; //If there's a target, we'll assume it's a conversation. if ( target ) path = this . scriptPath + name ; else path = this . menuPath + name ; this . loadFile ( path , function ( e , menu ) { if ( e ) log_error ( e ) ; if ( ! menu ) return ; that . menus [ name ] = menu ; player . enterMenu ( menu , target ) ; } ) ; } else { player . enterMenu ( this . menus [ name ] , target ) ; } }

0<CODESPLIT>https://github.com/multiplex/multiplex.js/blob/1e2f7df5726bdbbe6e8309066a03140ecbddb224/external/qunit/qunit.js#L1843-L1855<CODESPLIT><CODESPLIT>The real equiv function<CODESPLIT>function ( result , actual , expected , message , negative ) { var currentAssert = this instanceof Assert ? this : QUnit . config . current . assert ; return currentAssert . pushResult ( { result : result , actual : actual , expected : expected , message : message , negative : negative } ) ; }

1<CODESPLIT>https://github.com/iuap-design/tinper-neoui-grid/blob/24d392eb460beede997187593982952a1af2cfcc/vendor/uui/js/u-ui.js#L4703-L4715<CODESPLIT><CODESPLIT>Handles a click event on an item .<CODESPLIT>function ( evt ) { if ( evt . target . hasAttribute ( 'disabled' ) ) { u . stopEvent ( evt ) ; // evt.stopPropagation(); } else { // Wait some time before closing menu, so the user can see the ripple. this . _closing = true ; window . setTimeout ( function ( evt ) { this . hide ( ) ; this . _closing = false ; } . bind ( this ) , 150 ) ; } }

0<CODESPLIT>https://github.com/pvdz/ZeParser/blob/c99240c5ba7054c467733800ff38265958a2dda9/Tokenizer.js#L121-L707<CODESPLIT><CODESPLIT>custom tag literal support . allows <div > < / div > kind of ( sub - expression ) tokens storeCurrentAndFetchNextToken ( bool false false true ) to get just one token<CODESPLIT>function ( token , match ) { var wtree = this . wtree ; var btree = this . btree ; if ( match . name == 12 /*asi*/ ) { token . tokposw = wtree . length ; wtree . push ( token ) ; token . tokposb = btree . length ; btree . push ( token ) ; } else { token . tokposw = match . tokposw ; wtree [ token . tokposw ] = token ; match . tokposw += 1 ; wtree [ match . tokposw ] = match ; if ( match . tokposb ) { token . tokposb = match . tokposb ; btree [ token . tokposb ] = token ; match . tokposb += 1 ; btree [ match . tokposb ] = match ; } } }

1<CODESPLIT>https://github.com/Picolab/pico-engine/blob/809ab9c99fd97f59f6c6932a8383d7f117b4c2ef/packages/krl-stdlib/src/index.js#L11-L16<CODESPLIT><CODESPLIT>coerce the value into an array of key strings<CODESPLIT>function ( path ) { if ( ! types . isArray ( path ) ) { path = [ path ] } return _ . map ( path , toKey ) }

1<CODESPLIT>https://github.com/krundru/webdriver-runner/blob/fb9db651966f546d0f6864b317475f805db86a12/lib/util.js#L19-L33<CODESPLIT>saveScreenshot<CODESPLIT>Saves current screenshot from driver . fileName is resolved from testTitle and saved under given directory .<CODESPLIT>function saveScreenshot ( driver , dir , testTitle ) { const data = driver . takeScreenshot ( ) const fileName = testTitle . replace ( / [^a-zA-Z0-9] / g , '_' ) . concat ( '_' ) . concat ( new Date ( ) . getTime ( ) ) . concat ( '.png' ) const fullPath = path . resolve ( dir , fileName ) fs . writeFileSync ( fullPath , data , 'base64' ) reportOutput ( { type : 'image' , name : fileName , file : fullPath } ) }

1<CODESPLIT>https://github.com/pixelandtonic/garnishjs/blob/3e57331081c277eeac9a022feeadac5da3f4a2f9/dist/garnish.js#L4932-L4942<CODESPLIT><CODESPLIT>Is Selected?<CODESPLIT>function ( item ) { if ( Garnish . isJquery ( item ) ) { if ( ! item [ 0 ] ) { return false ; } item = item [ 0 ] ; } return ( $ . inArray ( item , this . $selectedItems ) !== - 1 ) ; }

1<CODESPLIT>https://github.com/zynga/gravity/blob/79916523c2c0733be80c21354e5a2aa0ea4cf2c7/gravity.js#L154-L176<CODESPLIT>reduce<CODESPLIT>Given a map and a resource path drill down in the map to find the most specific map node that matches the path . Return the map node the matched path prefix and the unmatched path suffix .<CODESPLIT>function reduce ( map , path ) { var mapNode , prefix , split , splits = getResourcePathSplits ( path ) , subValue , suffix ; while ( splits . length ) { split = splits . shift ( ) ; suffix = split [ 1 ] ; prefix = suffix ? split [ 0 ] + '/' : split [ 0 ] ; mapNode = map [ prefix ] ; if ( mapNode ) { if ( ! suffix || typeof mapNode === 'string' ) { return { map : mapNode , prefix : prefix , suffix : suffix } ; } if ( typeof mapNode === 'object' ) { subValue = reduce ( mapNode , suffix ) ; if ( subValue ) { subValue . prefix = prefix + '/' + subValue . prefix ; return subValue ; } } } } return { map : map , prefix : '' , suffix : path } ; }

0<CODESPLIT>https://github.com/ocadotechnology/quantumjs/blob/5bc684b750472296f186a816529272c36218db04/quantum-api/lib/entity-transforms/changelog.js#L111-L121<CODESPLIT>label<CODESPLIT>/ * Creates a single changelog entry<CODESPLIT>function label ( tagType , count ) { const icon = tagType ? dom . create ( 'i' ) . class ( ` ${ tagType } ${ tagType } ` ) . attr ( 'title' , tags . displayName [ tagType ] ) : undefined return dom . create ( 'div' ) . class ( ` ${ tagType } ` ) . add ( icon ) . add ( dom . create ( 'span' ) . text ( count ) ) }

1<CODESPLIT>https://github.com/garyns/OneLineLogger/blob/92965144fcc87fa54b15b82843b651af4b980c0d/onelinelogger.js#L227-L229<CODESPLIT>padLeft<CODESPLIT>Pad a string .<CODESPLIT>function padLeft ( width , string , padding ) { return ( width <= string . length ) ? string : padLeft ( width , string + padding , padding ) ; }

0<CODESPLIT>https://github.com/canjs/can-view-live/blob/00f6bf4ae003afe746b3d88fcfa67c9bb2f97a60/lib/core.js#L97-L127<CODESPLIT><CODESPLIT>#### listen Calls setup but presets bind and unbind to operate on a compute<CODESPLIT>function ( nodes , val , teardown ) { // #### replace // Replaces one element with some content while keeping nodeLists data // correct. // // Take a copy of old nodeList var oldNodes = nodes . slice ( 0 ) , frag = makeFrag ( val ) ; // Register a teardown callback nodeLists . register ( nodes , teardown ) ; // Mark each node as belonging to the node list. nodeLists . update ( nodes , childNodes ( frag ) ) ; // Replace old nodes with new on the DOM nodeLists . replace ( oldNodes , frag ) ; return nodes ; }

1<CODESPLIT>https://github.com/jsrmath/sharp11/blob/4f5857c40535b1bccc102ffdcc42a086e213016a/lib/chord.js#L30-L52<CODESPLIT><CODESPLIT>Replace aliases in chord symbol<CODESPLIT>function ( symbol ) { var parentheticals ; if ( symbol === '' ) return 'M' ; // No symbol means major triad symbol = symbol . replace ( / maj / i , 'M' ) . replace ( / ∆/,   ' ')  . replace ( / min / i , 'm' ) . replace ( / ^- / , 'm' ) . replace ( / dom / , '' ) . replace ( / ^o / , 'dim' ) . replace ( / 1\/2dim / , 'ø') ;  // Remove parentheses unless they are significant, i.e. they contain an 11, or 13 parentheticals = symbol . match ( / \([^\)]*\) / g ) ; _ . each ( parentheticals , function ( parenthetical ) { if ( parenthetical . indexOf ( '11' ) === - 1 && parenthetical . indexOf ( '13' ) === - 1 ) { symbol = symbol . replace ( parenthetical , parenthetical . slice ( 1 , - 1 ) ) ; } } ) ; return symbol ; }

1<CODESPLIT>https://github.com/wix/eyes.it/blob/39de24bf472d1a02164fad838be26fa71d48dd03/src/eyes-it.js#L42-L91<CODESPLIT>eyesIt<CODESPLIT>Call original it and modify before and after<CODESPLIT>function eyesIt ( _it , _itArgs , config ) { const { windowSize , specVersion , enableSnapshotAtBrowserGet , enableSnapshotAtEnd , } = merge ( { } , defaultConfig , config ) ; const spec = _it . apply ( this , _itArgs ) ; const hooked = spec . beforeAndAfterFns ; spec . beforeAndAfterFns = function ( ) { //TODO: are we sure that we need to pass args (msg, itFn) to hooked? const result = hooked . apply ( this , _itArgs ) ; result . befores . unshift ( { fn : function ( done ) { _enableSnapshotAtBrowserGet = enableSnapshotAtBrowserGet ; eyes . open ( browser , appName , buildSpecName ( spec , specVersion ) , windowSize ) . then ( done ) ; } , timeout : ( ) => 30000 , } ) ; result . afters . unshift ( { fn : function ( done ) { _enableSnapshotAtBrowserGet = false ; Promise . resolve ( ) . then ( ( ) => { if ( enableSnapshotAtEnd ) { return eyes . checkWindow ( 'end' ) ; } } ) . then ( done ) . catch ( err => handleError ( err , done ) ) ; } , timeout : ( ) => 30000 , } ) ; result . afters . push ( { fn : function ( done ) { eyes . close ( ) . then ( done ) . catch ( err => handleError ( err , done ) ) ; } , timeout : ( ) => 30000 , } ) ; return result ; } ; return spec ; }

0<CODESPLIT>https://github.com/optimizely/nuclear-js/blob/102fe399c8730375dece7711c66f1d46c860f5ae/examples/rest-api/src/modules/rest-api/create-api-actions.js#L140-L147<CODESPLIT>onDeleteFail<CODESPLIT>Handler for API delete success dispatches flux action to remove the instance from the stores<CODESPLIT>function onDeleteFail ( model , params , reason ) { Flux . dispatch ( actionTypes . API_DELETE_FAIL , { model : model , params : params , reason : reason , } ) return Promise . reject ( reason ) }

1<CODESPLIT>https://github.com/KingSora/OverlayScrollbars/blob/8e658d46e2d034a2525269d7c873bbe844762307/js/OverlayScrollbars.js#L5213-L5225<CODESPLIT>getObjectPropVal<CODESPLIT>Gets the value of the given property from the given object .<CODESPLIT>function getObjectPropVal ( obj , path ) { var splits = path . split ( _strDot ) ; var i = 0 ; var val ; for ( ; i < splits . length ; i ++ ) { if ( ! obj . hasOwnProperty ( splits [ i ] ) ) return ; val = obj [ splits [ i ] ] ; if ( i < splits . length && type ( val ) == TYPES . o ) obj = val ; } return val ; }

0<CODESPLIT>https://github.com/vitaly-t/pg-promise/blob/a3ccf5a7fb14425c34892b869cb5502b2847180e/lib/utils/index.js#L158-L189<CODESPLIT>hasProperty<CODESPLIT>/////////////////////////////////////////////////////////////// Parses a property name and gets its name from the object if the property exists . Returns object { valid has target value } : - valid - true / false whether the syntax is valid - has - a flag that property exists ; set when valid = true - target - the target object that contains the property ; set when has = true - value - the value ; set when has = true<CODESPLIT>function hasProperty ( value , prop ) { return ( value && typeof value === 'object' && prop in value ) || value !== null && value !== undefined && value [ prop ] !== undefined ; }

0<CODESPLIT>https://github.com/byron-dupreez/aws-core-utils/blob/2530155b5afc102f61658b28183a16027ecae86a/contexts.js#L61-L99<CODESPLIT>configureEventAwsContextAndStage<CODESPLIT>Configures the given context as a standard context ( for API Gateway exposed and other types of Lambdas ) with stage handling logging custom settings an optional Kinesis instance an optional DynamoDB . DocumentClient instance the current region the given AWS event given AWS context and the resolved stage based on the given settings and options .<CODESPLIT>function configureEventAwsContextAndStage ( context , event , awsContext ) { // Configure context.event with the given AWS event if ( event ) { context . event = event ; } // Configure context.awsContext with the given AWS context if ( awsContext ) { context . awsContext = awsContext ; // Resolve the invoked Lambda's function name, version & alias (if possible) context . invokedLambda = lambdas . getFunctionNameVersionAndAlias ( awsContext ) ; } // Resolve the current stage (e.g. dev, qa, prod, ...) if possible and configure context.stage with it, if it is not // already configured if ( event && awsContext ) { stages . configureStage ( context , event , awsContext , true ) ; } return context ; }

0<CODESPLIT>https://github.com/ota-meshi/eslint-plugin-lodash-template/blob/9ff820d58da1eea47f12a87939e62a23cc07561d/lib/rules/html-indent.js#L293-L308<CODESPLIT>setOffsetRootToIndex<CODESPLIT>Calculate correct indentation of the line of the given line .<CODESPLIT>function setOffsetRootToIndex ( startIndex ) { const loc = sourceCode . getLocFromIndex ( startIndex ) if ( ! offsets . has ( loc . line ) ) { setOffsetToLoc ( loc , 0 , - 1 ) } }

1<CODESPLIT>https://github.com/Autarc/optimal-select/blob/722d220d2dc54d78121d610a69f6544c2e116721/src/adapt.js#L310-L318<CODESPLIT>traverseDescendants<CODESPLIT>Walking recursive to invoke callbacks<CODESPLIT>function traverseDescendants ( nodes , handler ) { nodes . forEach ( ( node ) => { var progress = true handler ( node , ( ) => progress = false ) if ( node . childTags && progress ) { traverseDescendants ( node . childTags , handler ) } } ) }

0<CODESPLIT>https://github.com/listenzz/react-native-navigation-hybrid/blob/50d0c136613bf76cd6b7c8007a2400a09ddc1c3a/playground/src/ReduxCounter.js#L76-L86<CODESPLIT>connectStore<CODESPLIT>Reducer<CODESPLIT>function connectStore ( modules ) { var mapStateToProps = function mapStateToProps ( state , props ) { var finalState = { } ; Object . keys ( modules ) . forEach ( function ( key ) { var moduleInstance = modules [ key ] ; var module_name = moduleInstance . module && moduleInstance . module . name || moduleInstance . name ; var stateObj = state [ module_name ] ; if ( moduleInstance . get ) { var filter_array = moduleInstance . get . split ( "," ) ; stateObj = ( 0 , _helpers . pluck ) ( stateObj , filter_array ) ; } stateObj = attachModuleSelectors ( moduleInstance , stateObj , state , props ) ; finalState [ key ] = stateObj ; } ) ; return finalState ; } ; var mapDispatchToProps = function mapDispatchToProps ( dispatch ) { var finalProps = { } ; Object . keys ( modules ) . forEach ( function ( key ) { var moduleInstance = modules [ key ] ; var actions_obj = { } ; var module_actions = moduleInstance . module && moduleInstance . module . actions || moduleInstance . actions ; if ( module_actions ) { Object . keys ( module_actions ) . forEach ( function ( action_key ) { var action = module_actions [ action_key ] ; actions_obj [ action_key ] = function ( ) { return dispatch ( action . apply ( undefined , arguments ) ) ; } ; } ) ; finalProps [ key ] = actions_obj ; } } ) ; return finalProps ; } ; var mergeProps = function mergeProps ( state , actions , ownProps ) { var finalModule = { } ; Object . keys ( state ) . forEach ( function ( key ) { var module_state = state [ key ] ; var module_actions = actions [ key ] ; finalModule [ key ] = Object . assign ( { } , module_state , module_actions ) ; } ) ; return Object . assign ( { } , finalModule , ownProps ) ; } ; return ( 0 , _reactRedux . connect ) ( mapStateToProps , mapDispatchToProps , mergeProps , { pure : true , areStatePropsEqual : function areStatePropsEqual ( a , b ) { return ( 0 , _helpers . areSame ) ( a , b ) ; } } ) ; }

1<CODESPLIT>https://github.com/splunk/splunk-sdk-javascript/blob/9aec5443860926654c2ab8ee3bf198a407c53b07/client/splunk.ui.charting.js#L17513-L17532<CODESPLIT>setExtremes<CODESPLIT>Set the extremes and optionally redraw @param { Number } newMin @param { Number } newMax @param { Boolean } redraw @param { Boolean|Object } animation Whether to apply animation and optionally animation configuration<CODESPLIT>function setExtremes ( newMin , newMax , redraw , animation ) { redraw = pick ( redraw , true ) ; // defaults to true  fireEvent ( axis , 'setExtremes' , { // fire an event to enable syncing of multiple charts  min : newMin , max : newMax } , function ( ) { // the default event handler  userMin = newMin ; userMax = newMax ; // redraw  if ( redraw ) { chart . redraw ( animation ) ; } } ) ; }

1<CODESPLIT>https://github.com/5long/roil/blob/37b14072a7aea17accc7f4e5e04dedc90a1358de/src/console/socket.io.js#L1476-L1492<CODESPLIT><CODESPLIT>check the given value for the components of the hard - coded error code : __FLASHERROR used to marshall NPE s into flash<CODESPLIT>function ( value ) { if ( typeof ( value ) == "string" && value . indexOf ( "__FLASHERROR" ) == 0 ) { var myErrorMessage = value . split ( "||" ) ; if ( FABridge . refCount > 0 ) { FABridge . refCount -- ; } throw new Error ( myErrorMessage [ 1 ] ) ; return value ; } else { return value ; } }

0<CODESPLIT>https://github.com/eface2face/meteor-html-tools/blob/93360c58596e7a9b88759d495cf8894d8c2c4f2d/html-tools.js#L3407-L3451<CODESPLIT><CODESPLIT>Input is always a dictionary ( even if zero attributes ) and each value in the dictionary is an array of Chars CharRef and maybe TemplateTag tokens . Output is null if there are zero attributes and otherwise a dictionary or an array of dictionaries and template tags . Each value in the dictionary is HTMLjs ( e . g . a string or an array of Chars CharRef and TemplateTag nodes ) . An attribute value with no input tokens is represented as not an empty array in order to prop open empty attributes with no template tags .<CODESPLIT>function ( token ) { var codePoints = token . cp ; var str = '' ; for ( var i = 0 ; i < codePoints . length ; i ++ ) str += codePointToString ( codePoints [ i ] ) ; return HTML . CharRef ( { html : token . v , str : str } ) ; }

1<CODESPLIT>https://github.com/tadam313/sheet-db/blob/2ca1b85b8a6086a327d65b98b68b543fade84848/src/api/v3/index.js#L97-L119<CODESPLIT>getOperationContext<CODESPLIT>Retrieves the operation context for the given type<CODESPLIT>function getOperationContext ( opType , options ) { var operation = getOperation ( opType ) ; options = options || { } ; options . visibility = ! options . token ? 'public' : 'private' ; options . apiRoot = APISPEC . root ; operation . headers = operation . headers || { } ; operation . headers [ 'GData-Version' ] = Number ( APISPEC . version ) . toFixed ( 1 ) ; if ( options . token ) { operation . headers [ 'Authorization' ] = 'Bearer ' + options . token ; delete options . token ; } operation . url = tpl ( operation . url , options ) ; operation . body = options . body ; operation . strictSSL = false ; return operation ; }

1<CODESPLIT>https://github.com/gems-uff/noworkflow/blob/3e824c5b18378872911b31db8a61222676c3fb1d/capture/noworkflow/jupyter/extension.js#L3543-L3556<CODESPLIT><CODESPLIT>If callback is non - null it will be used for error and load events .<CODESPLIT>function ( method , data , callback ) { xhr . open ( method , url , true , user , password ) ; if ( mimeType != null && ! headers . has ( "accept" ) ) headers . set ( "accept" , mimeType + ",*/*" ) ; if ( xhr . setRequestHeader ) headers . each ( function ( value , name ) { xhr . setRequestHeader ( name , value ) ; } ) ; if ( mimeType != null && xhr . overrideMimeType ) xhr . overrideMimeType ( mimeType ) ; if ( responseType != null ) xhr . responseType = responseType ; if ( timeout > 0 ) xhr . timeout = timeout ; if ( callback == null && typeof data === "function" ) callback = data , data = null ; if ( callback != null && callback . length === 1 ) callback = fixCallback ( callback ) ; if ( callback != null ) request . on ( "error" , callback ) . on ( "load" , function ( xhr ) { callback ( null , xhr ) ; } ) ; event . call ( "beforesend" , request , xhr ) ; xhr . send ( data == null ? null : data ) ; return request ; }

1<CODESPLIT>https://github.com/remarkjs/remark-man/blob/11c18a54d75e45d95f973ba86dcfc23cd90e0de7/lib/handlers.js#L152-L165<CODESPLIT>blockquote<CODESPLIT>/ * Compile a block quote .<CODESPLIT>function blockquote ( node ) { var self = this var value self . level ++ value = self . all ( node ) . join ( '\n' ) self . level -- value = '.RS ' + ( self . level ? 4 : 0 ) + '\n' + value + '\n.RE 0\n' return value }

1<CODESPLIT>https://github.com/Esri/terraformer/blob/0f70aa08f3400e9b566fb89c604164b89633db8c/terraformer.js#L166-L208<CODESPLIT>calculateBoundsFromNestedArrayOfArrays<CODESPLIT>/ * Internal : Calculate a bounding box from an array of arrays of arrays [ [ [ lng lat ] [ lng lat ] [ lng lat ] ] [ [ lng lat ] [ lng lat ] [ lng lat ] ] [ [ lng lat ] [ lng lat ] [ lng lat ] ] ]<CODESPLIT>function calculateBoundsFromNestedArrayOfArrays ( array ) { var x1 = null , x2 = null , y1 = null , y2 = null ; for ( var i = 0 ; i < array . length ; i ++ ) { var inner = array [ i ] ; for ( var j = 0 ; j < inner . length ; j ++ ) { var innerinner = inner [ j ] ; for ( var k = 0 ; k < innerinner . length ; k ++ ) { var lonlat = innerinner [ k ] ; var lon = lonlat [ 0 ] ; var lat = lonlat [ 1 ] ; if ( x1 === null ) { x1 = lon ; } else if ( lon < x1 ) { x1 = lon ; } if ( x2 === null ) { x2 = lon ; } else if ( lon > x2 ) { x2 = lon ; } if ( y1 === null ) { y1 = lat ; } else if ( lat < y1 ) { y1 = lat ; } if ( y2 === null ) { y2 = lat ; } else if ( lat > y2 ) { y2 = lat ; } } } } return [ x1 , y1 , x2 , y2 ] ; }

1<CODESPLIT>https://github.com/yoshuawuyts/initialize-engine/blob/aa627bde2770f01989e36438dea8236b27533028/index.js#L84-L97<CODESPLIT>installDeps<CODESPLIT>install npm dependencies ( obj str obj fn ) - > null<CODESPLIT>function installDeps ( deps , cliOpts , argv , cb ) { const mods = deps . map ( function ( dep ) { return function ( done ) { process . stdout . write ( 'pkg: ' + dep + '\n' ) const infinity = '--cache-min Infinity' const args = [ 'npm i' , cliOpts , dep , infinity ] . join ( ' ' ) exec ( args , function ( err ) { if ( err ) return cb ( err ) } ) } } ) parallel ( mods , cb ) }

0<CODESPLIT>https://github.com/atd-schubert/node-stream-lib/blob/90f27042fae84d2fbdbf9d28149b0673997f151a/lib/random.js#L18-L26<CODESPLIT>validate<CODESPLIT>Create a stream of random values from dictionary<CODESPLIT>function validate ( opts , options ) { if ( ! isObject ( options ) ) { return new TypeError ( 'invalid input argument. Options must be an object. Value: `' + options + '`.' ) ; } if ( options . hasOwnProperty ( 'allowHalfOpen' ) ) { opts . allowHalfOpen = options . allowHalfOpen ; if ( ! isBoolean ( opts . allowHalfOpen ) ) { return new TypeError ( 'invalid option. Allow half open option must be a boolean primitive. Option: `' + opts . allowHalfOpen + '`.' ) ; } } if ( options . hasOwnProperty ( 'highWaterMark' ) ) { opts . highWaterMark = options . highWaterMark ; if ( ! isNonNegative ( opts . highWaterMark ) ) { return new TypeError ( 'invalid option. High watermark option must be a nonnegative number. Option: `' + opts . highWaterMark + '`.' ) ; } } return null ; }

0<CODESPLIT>https://github.com/zhanziyang/vue-croppa/blob/46632d9ce254b834150d7fab2febb666e1c7d2a4/docs/static/kute-page_files/undefined.cd4343636fa2ca97594c.js#L16486-L16490<CODESPLIT>warn<CODESPLIT>This method is like _ . min except that it accepts iteratee which is invoked for each element in array to generate the criterion by which the value is ranked . The iteratee is invoked with one argument : ( value ) .<CODESPLIT>function warn ( ) { var args = Array . prototype . slice . apply ( arguments ) ; if ( typeof console !== undefined && console . warn ) { console . warn . apply ( console , args ) ; } }

0<CODESPLIT>https://github.com/greggman/twgl.js/blob/ae88dfe4d7a7d44a5b739fcbe50bccccd0e1a1fd/src/primitives.js#L913-L925<CODESPLIT>create3DFVertices<CODESPLIT>Expands RLE data<CODESPLIT>function create3DFVertices ( ) { const positions = [ // left column front 0 , 0 , 0 , 0 , 150 , 0 , 30 , 0 , 0 , 0 , 150 , 0 , 30 , 150 , 0 , 30 , 0 , 0 , // top rung front 30 , 0 , 0 , 30 , 30 , 0 , 100 , 0 , 0 , 30 , 30 , 0 , 100 , 30 , 0 , 100 , 0 , 0 , // middle rung front 30 , 60 , 0 , 30 , 90 , 0 , 67 , 60 , 0 , 30 , 90 , 0 , 67 , 90 , 0 , 67 , 60 , 0 , // left column back 0 , 0 , 30 , 30 , 0 , 30 , 0 , 150 , 30 , 0 , 150 , 30 , 30 , 0 , 30 , 30 , 150 , 30 , // top rung back 30 , 0 , 30 , 100 , 0 , 30 , 30 , 30 , 30 , 30 , 30 , 30 , 100 , 0 , 30 , 100 , 30 , 30 , // middle rung back 30 , 60 , 30 , 67 , 60 , 30 , 30 , 90 , 30 , 30 , 90 , 30 , 67 , 60 , 30 , 67 , 90 , 30 , // top 0 , 0 , 0 , 100 , 0 , 0 , 100 , 0 , 30 , 0 , 0 , 0 , 100 , 0 , 30 , 0 , 0 , 30 , // top rung front 100 , 0 , 0 , 100 , 30 , 0 , 100 , 30 , 30 , 100 , 0 , 0 , 100 , 30 , 30 , 100 , 0 , 30 , // under top rung 30 , 30 , 0 , 30 , 30 , 30 , 100 , 30 , 30 , 30 , 30 , 0 , 100 , 30 , 30 , 100 , 30 , 0 , // between top rung and middle 30 , 30 , 0 , 30 , 60 , 30 , 30 , 30 , 30 , 30 , 30 , 0 , 30 , 60 , 0 , 30 , 60 , 30 , // top of middle rung 30 , 60 , 0 , 67 , 60 , 30 , 30 , 60 , 30 , 30 , 60 , 0 , 67 , 60 , 0 , 67 , 60 , 30 , // front of middle rung 67 , 60 , 0 , 67 , 90 , 30 , 67 , 60 , 30 , 67 , 60 , 0 , 67 , 90 , 0 , 67 , 90 , 30 , // bottom of middle rung. 30 , 90 , 0 , 30 , 90 , 30 , 67 , 90 , 30 , 30 , 90 , 0 , 67 , 90 , 30 , 67 , 90 , 0 , // front of bottom 30 , 90 , 0 , 30 , 150 , 30 , 30 , 90 , 30 , 30 , 90 , 0 , 30 , 150 , 0 , 30 , 150 , 30 , // bottom 0 , 150 , 0 , 0 , 150 , 30 , 30 , 150 , 30 , 0 , 150 , 0 , 30 , 150 , 30 , 30 , 150 , 0 , // left side 0 , 0 , 0 , 0 , 0 , 30 , 0 , 150 , 30 , 0 , 0 , 0 , 0 , 150 , 30 , 0 , 150 , 0 , ] ; const texcoords = [ // left column front 0.22 , 0.19 , 0.22 , 0.79 , 0.34 , 0.19 , 0.22 , 0.79 , 0.34 , 0.79 , 0.34 , 0.19 , // top rung front 0.34 , 0.19 , 0.34 , 0.31 , 0.62 , 0.19 , 0.34 , 0.31 , 0.62 , 0.31 , 0.62 , 0.19 , // middle rung front 0.34 , 0.43 , 0.34 , 0.55 , 0.49 , 0.43 , 0.34 , 0.55 , 0.49 , 0.55 , 0.49 , 0.43 , // left column back 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , // top rung back 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , // middle rung back 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , // top 0 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , // top rung front 0 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , // under top rung 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , // between top rung and middle 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , // top of middle rung 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , // front of middle rung 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , // bottom of middle rung. 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , // front of bottom 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , // bottom 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , // left side 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , ] ; const normals = expandRLEData ( [ // left column front // top rung front // middle rung front 18 , 0 , 0 , 1 , // left column back // top rung back // middle rung back 18 , 0 , 0 , - 1 , // top 6 , 0 , 1 , 0 , // top rung front 6 , 1 , 0 , 0 , // under top rung 6 , 0 , - 1 , 0 , // between top rung and middle 6 , 1 , 0 , 0 , // top of middle rung 6 , 0 , 1 , 0 , // front of middle rung 6 , 1 , 0 , 0 , // bottom of middle rung. 6 , 0 , - 1 , 0 , // front of bottom 6 , 1 , 0 , 0 , // bottom 6 , 0 , - 1 , 0 , // left side 6 , - 1 , 0 , 0 , ] ) ; const colors = expandRLEData ( [ // left column front // top rung front // middle rung front 18 , 200 , 70 , 120 , // left column back // top rung back // middle rung back 18 , 80 , 70 , 200 , // top 6 , 70 , 200 , 210 , // top rung front 6 , 200 , 200 , 70 , // under top rung 6 , 210 , 100 , 70 , // between top rung and middle 6 , 210 , 160 , 70 , // top of middle rung 6 , 70 , 180 , 210 , // front of middle rung 6 , 100 , 70 , 210 , // bottom of middle rung. 6 , 76 , 210 , 100 , // front of bottom 6 , 140 , 210 , 80 , // bottom 6 , 90 , 130 , 110 , // left side 6 , 160 , 160 , 220 , ] , [ 255 ] ) ; const numVerts = positions . length / 3 ; const arrays = { position : createAugmentedTypedArray ( 3 , numVerts ) , texcoord : createAugmentedTypedArray ( 2 , numVerts ) , normal : createAugmentedTypedArray ( 3 , numVerts ) , color : createAugmentedTypedArray ( 4 , numVerts , Uint8Array ) , indices : createAugmentedTypedArray ( 3 , numVerts / 3 , Uint16Array ) , } ; arrays . position . push ( positions ) ; arrays . texcoord . push ( texcoords ) ; arrays . normal . push ( normals ) ; arrays . color . push ( colors ) ; for ( let ii = 0 ; ii < numVerts ; ++ ii ) { arrays . indices . push ( ii ) ; } return arrays ; }

1<CODESPLIT>https://github.com/getsentry/sentry-javascript/blob/a872223343fecf7364473b78bede937f1eb57bd0/packages/raven-js/plugins/react-native.js#L45-L52<CODESPLIT>urlencode<CODESPLIT>Extract key / value pairs from an object and encode them for use in a query string<CODESPLIT>function urlencode ( obj ) { var pairs = [ ] ; for ( var key in obj ) { if ( { } . hasOwnProperty . call ( obj , key ) ) pairs . push ( encodeURIComponent ( key ) + '=' + encodeURIComponent ( obj [ key ] ) ) ; } return pairs . join ( '&' ) ; }

0<CODESPLIT>https://github.com/aui/angular-popups/blob/36a8a11803a8e3593a51bb9931bc9a657ee820d7/src/directives/directives.js#L165-L171<CODESPLIT>fix<CODESPLIT>定时关闭<CODESPLIT>function fix ( elem ) { var temp = document . createElement ( 'popup' ) ; document . body . appendChild ( temp ) ; temp . appendChild ( elem [ 0 ] ) ; return $ ( temp ) ; }

1<CODESPLIT>https://github.com/rekit/rekit-core/blob/e98ab59da85a517717e1ff4e7c724d4c917a45b8/core/plugin.js#L112-L160<CODESPLIT>loadPlugin<CODESPLIT>Load plugin instance plugin depends on project config<CODESPLIT>function loadPlugin ( pluginRoot , noUI ) { // noUI flag is used for loading dev plugins whose ui is from webpack dev server try { // const pkgJson = require(paths.join(pluginRoot, 'package.json')); const pluginInstance = { } ; // Core part const coreIndex = paths . join ( pluginRoot , 'core/index.js' ) ; if ( fs . existsSync ( coreIndex ) ) { Object . assign ( pluginInstance , require ( coreIndex ) ) ; } // UI part if ( ! noUI && fs . existsSync ( path . join ( pluginRoot , 'build/main.js' ) ) ) { pluginInstance . ui = { root : path . join ( pluginRoot , 'build' ) , } ; } // Plugin meta defined in package.json const pkgJsonPath = path . join ( pluginRoot , 'package.json' ) ; let pkgJson = null ; if ( fs . existsSync ( pkgJsonPath ) ) { pkgJson = fs . readJsonSync ( pkgJsonPath ) ; [ 'appType' , 'name' , 'featureFiles' ] . forEach ( key => { if ( ! pluginInstance . hasOwnProperty ( key ) && pkgJson . hasOwnProperty ( key ) ) { if ( key === 'name' ) { let name = pkgJson . name ; if ( name . startsWith ( 'rekit-plugin' ) ) name = name . replace ( 'rekit-plugin-' , '' ) ; pluginInstance . name = name ; } else { pluginInstance [ key ] = pkgJson [ key ] || null ; } } } ) ; if ( pkgJson . rekitPlugin ) { Object . keys ( pkgJson . rekitPlugin ) . forEach ( key => { if ( ! pluginInstance . hasOwnProperty ( key ) ) { pluginInstance [ key ] = pkgJson . rekitPlugin [ key ] ; } } ) ; } } return pluginInstance ; } catch ( e ) { logger . warn ( ` ${ pluginRoot } ` , e ) ; } return null ; }

0<CODESPLIT>https://github.com/emmetio/emmet/blob/7c9a4623cea414c2f2cc9caebc13355d2bbd898d/lib/assets/range.js#L153-L163<CODESPLIT><CODESPLIT>Low - level comparision method<CODESPLIT>function ( range ) { if ( this . overlap ( range ) ) { var start = Math . max ( range . start , this . start ) ; var end = Math . min ( range . end , this . end ) ; return new Range ( start , end - start ) ; } return null ; }

1<CODESPLIT>https://github.com/redisjs/jsr-store/blob/b2b5c5b0347819f8a388b5d67e121ee8d73f328c/lib/store.js#L46-L53<CODESPLIT>getDatabase<CODESPLIT>Get a database and inject it into the list at the specified index if no db exists at that index .<CODESPLIT>function getDatabase ( index , opts ) { var db ; if ( ! this . _databases [ index ] ) { db = new Database ( this , opts ) ; this . _databases [ index ] = db ; } return this . _databases [ index ] ; }

1<CODESPLIT>https://github.com/ampproject/worker-dom/blob/d1c7bee8c2259c61e25eb4d27606ff70e2f02fd4/demo/preact-dbmon/dbmon.js#L1583-L1597<CODESPLIT>TodoList<CODESPLIT>To - do list adapted from example on https : // reactjs . org .<CODESPLIT>function TodoList ( props ) { return h ( 'ul' , null , props . items . map ( function ( item ) { return h ( 'li' , { key : item . id , } , item . text , ) ; } ) , ) ; }

0<CODESPLIT>https://github.com/imbo/imboclient-js/blob/809dcc489528dca9d67f49b03b612a99704339d0/lib/node/request.js#L20-L43<CODESPLIT>adaptModulePath<CODESPLIT>Send an HTTP request with the given options<CODESPLIT>function adaptModulePath ( modulePath , state ) { // const fileName = state.file.opts.filename; const options = getStateOptions ( state ) ; const filesMap = createFilesMap ( options ) ; const rootPath = getRootPath ( options ) ; let module = determineContext ( modulePath , options ) ; // Do not generate infinite cyrcular references on empty nodes if ( ! module . file ) { return null ; } // Safeguard against circular calls if ( lastIn === lastOut ) { return null ; } // Remove relative path prefix before replace const absoluteModule = path . isAbsolute ( module . file ) ; // Try to replace aliased module let found = false ; let constantModulePart ; filesMap . keys . filter ( ( k ) => { const d = filesMap . contents [ k ] ; let idx = module . file . search ( d . regexp ) ; if ( ! found && idx > - 1 ) { // throw `Found ${d} in ${module.file}` // constantModulePart = module.file.slice(0, idx) || './'; constantModulePart = './' ; if ( module . file [ idx ] === '/' ) { idx += 1 ; } const value = d . value [ 0 ] === '.' && idx > 0 ? d . value . slice ( 2 ) : d . value ; // const value = d.value; // Replace the alias with it's path and continue module . file = ` ${ module . file . slice ( 0 , idx ) || '' } ${ value } ${ module . file . slice ( idx + d . expose . length ) || '' } ` ; found = true ; // Revaluate npm and react flags based on the new mapping module = determineContext ( module . file , options ) ; return true ; } return false ; } ) ; // Leave NPM modules as resolved, do not remap and ignore wrongfully formatted strings of form require('npm:') if ( module . npm ) { return module . file || null ; } // Do not touch direct requires to npm modules (non annotated) if ( module . file . indexOf ( './' ) !== 0 && module . file . indexOf ( '/' ) !== 0 ) { return null ; } // Check if any substitution took place if ( found ) { // Module alias substituted if ( ! path . isAbsolute ( module . file ) ) { if ( ! absoluteModule && module . file [ 0 ] !== '.' ) { // Add the relative notation back module . file = ` ${ module . file } ` ; } } } // Do not break node_modules required by name if ( ! found && module . file [ 0 ] !== '.' ) { if ( reactOsFileInfer ( options ) ) { const aux2 = mapForReact ( module . file ) ; if ( aux2 !== module . file ) { return aux2 ; } } return null ; } // Enforce absolute paths on absolute mode if ( rootPath ) { if ( ! path . isAbsolute ( module . file ) ) { module . file = path . join ( rootPath , module . file ) ; if ( reactOsFileInfer ( options ) ) { return mapForReact ( module . file ) ; } return module . file ; } // After the node is replaced the visitor will be called again. // Without this condition these functions will generate a circular loop. return null ; } // throw `Gets here: ${JSON.stringify(module.file)}`; // Do not bother with relative paths that are not aliased if ( ! found ) { return null ; } let moduleMapped = mapToRelative ( module . file , constantModulePart , options ) ; if ( moduleMapped . indexOf ( './' ) !== 0 ) { moduleMapped = ` ${ moduleMapped } ` ; } // throw JSON.stringify({ //   moduleMapped, modulePath, module, constantModulePart // }, null, 2); return moduleMapped !== modulePath ? moduleMapped : null ; }

1<CODESPLIT>https://github.com/gwtw/js-sorting/blob/158286752539a4ec3bfc7c0f578372953357d4ed/lib/selection-sort.js#L21-L37<CODESPLIT>sort<CODESPLIT>Sorts an array using selection sort .<CODESPLIT>function sort ( array , compare , swap ) { for ( var i = 0 ; i < array . length - 1 ; i ++ ) { var minIndex = i ; for ( var j = i + 1 ; j < array . length ; j ++ ) { if ( compare ( array , j , minIndex ) < 0 ) { minIndex = j ; } } if ( minIndex !== i ) { swap ( array , i , minIndex ) ; } } return array ; }

0<CODESPLIT>https://github.com/glennjones/elsewhere-profiles/blob/f86a5d040d540d4f8ed4f86518b75a0e6c8855ba/lib/utilities.js#L227-L237<CODESPLIT>endsWith<CODESPLIT>is an object a URL - very simple version<CODESPLIT>function endsWith ( str , test ) { var lastIndex = str . lastIndexOf ( test ) ; return ( lastIndex != - 1 ) && ( lastIndex + test . length == str . length ) ; }

1<CODESPLIT>https://github.com/Tamersoul/magic-wand-js/blob/39d50ec17bfc060f2d360537a26a9420dd8970b6/jsfiddle/OpenLayers.debug.js#L39856-L39885<CODESPLIT><CODESPLIT>Constructor : OpenLayers . Layer . Vector Create a new vector layer<CODESPLIT>function ( name , options ) { OpenLayers . Layer . prototype . initialize . apply ( this , arguments ) ; // allow user-set renderer, otherwise assign one if ( ! this . renderer || ! this . renderer . supported ( ) ) { this . assignRenderer ( ) ; } // if no valid renderer found, display error if ( ! this . renderer || ! this . renderer . supported ( ) ) { this . renderer = null ; this . displayError ( ) ; } if ( ! this . styleMap ) { this . styleMap = new OpenLayers . StyleMap ( ) ; } this . features = [ ] ; this . selectedFeatures = [ ] ; this . unrenderedFeatures = { } ; // Allow for custom layer behavior if ( this . strategies ) { for ( var i = 0 , len = this . strategies . length ; i < len ; i ++ ) { this . strategies [ i ] . setLayer ( this ) ; } } }

0<CODESPLIT>https://github.com/TNRIS/weather-alerts-geojson/blob/ccc91f033e5bc91957c9903763d4593a2a97a3d1/lib/feature-transform.js#L8-L14<CODESPLIT>createDetailed<CODESPLIT>converts an alert polygon string to a GeoJSON polygon geometry<CODESPLIT>function createDetailed ( options ) { let helper = new helper_1 . Helper ( options . stream ) ; return function ( percentage , msg , moduleProgress , activeModules , moduleName ) { if ( percentage === 0 ) helper . begin ( ) ; else if ( percentage === 1 ) helper . end ( ) ; helper . beginWrite ( ) ; if ( percentage !== 1 ) { helper . write ( '\n' ) ; helper . write ( chalk_1 . default . cyan ( ` ${ ( percentage * 100 ) . toFixed ( 2 ) } ` ) + ` ${ msg } \n ` ) ; helper . write ( chalk_1 . default . gray ( [ moduleProgress , activeModules , moduleName ] . filter ( x => x != undefined ) . join ( ' :: ' ) ) ) ; } helper . endWrite ( ) ; } ; }

0<CODESPLIT>https://github.com/jonschlinkert/lazy-cache/blob/2f15129f05f2d69cbc2cb7ba52e383fc31b9fc2c/index.js#L21-L45<CODESPLIT>render<CODESPLIT>Cache results of the first function call to ensure only calling once .<CODESPLIT>function render ( source , destination ) { const unique = crypto . createHmac ( 'sha1' , PLUGIN_NAME ) . update ( source ) . digest ( 'hex' ) ; const mmdcExecutable = which . sync ( 'mmdc' ) ; const mmdPath = path . join ( destination , ` ${ unique } ` ) ; const svgFilename = ` ${ unique } ` ; const svgPath = path . join ( destination , svgFilename ) ; // Write temporary file fs . outputFileSync ( mmdPath , source ) ; // Invoke mermaid.cli execSync ( ` ${ mmdcExecutable } ${ mmdPath } ${ svgPath } ` ) ; // Clean up temporary file fs . removeSync ( mmdPath ) ; return ` ${ svgFilename } ` ; }

1<CODESPLIT>https://github.com/paglias/KnockoutApp/blob/7010bc4508c2ec05154c966519325a3f61add3e5/build/knockout.app.js#L304-L319<CODESPLIT><CODESPLIT>Add one or more models to collection and optionally create them on the server setting the create parameter to true It will also add a reference to the collection on each model<CODESPLIT>function ( model_s , create , options ) { var toAdd = model_s instanceof Array ? model_s : [ model_s ] , self = this ; ko . utils . arrayForEach ( toAdd , function ( attributes ) { var model ; if ( attributes instanceof Model ) { model = attributes ; model . collection = self ; } else { model = new self . model ( attributes , { collection : self } ) ; } self . models . push ( model ) ; if ( create ) model . save ( options ) ; } ) ; }

1<CODESPLIT>https://github.com/Reportr/dashboard/blob/bff0ea7f324de78ab8bf8c4301ce30696ad7d960/public/build/static/application.js#L17969-L17973<CODESPLIT>bindKey<CODESPLIT>Creates a function that when called invokes the method at object [ key ] and prepends any additional bindKey arguments to those provided to the bound function . This method differs from _ . bind by allowing bound functions to reference methods that will be redefined or don t yet exist . See [ Peter Michaux s article ] ( http : // michaux . ca / articles / lazy - function - definition - pattern ) for more details .<CODESPLIT>function bindKey ( object , key ) { return arguments . length < 3 ? createWrapper ( key , BIND_FLAG | BIND_KEY_FLAG , null , object ) : createWrapper ( key , BIND_FLAG | BIND_KEY_FLAG | PARTIAL_FLAG , null , object , slice ( arguments , 2 ) ) ; }

1<CODESPLIT>https://github.com/darrencruse/sugarlisp-core/blob/c6ff983ebc3d60268054d6fe046db4aff6c5f78c/lexer.js#L1214-L1234<CODESPLIT>formatTokenDump<CODESPLIT>format the token dump into a string<CODESPLIT>function formatTokenDump ( tokens , formatter , resultPrefix , resultSuffix ) { var tokensSexpStr = "" ; var currentLine = - 999 ; tokens . forEach ( function ( token , index ) { // skip the wrapping () it's annoying in the dump if ( ! ( ( index === 0 && token . text === "(" ) || ( index === tokens . length - 1 && token . text === ")" ) ) ) { // add a return if this starts a different line: if ( currentLine !== - 999 && token . line !== currentLine ) { tokensSexpStr += '\n' ; } tokensSexpStr += formatter ( token ) ; currentLine = token . line ; } } ) ; return ( resultPrefix ? resultPrefix : "" ) + tokensSexpStr + ( resultSuffix ? resultSuffix : "" ) ; }

1<CODESPLIT>https://github.com/ctgnauh/aqicn/blob/8dd97b883bff07cbbe6cf21bd00e4ac49e5b5f1d/src/aqicn.js#L95-L107<CODESPLIT><CODESPLIT>污染等级及相关信息<CODESPLIT>function ( level , lang ) { 'use strict' ; var self = this ; if ( level > 6 || level < 0 ) { level = 0 ; } return { value : level , name : self . info . level [ level ] . name [ lang ] , implication : self . info . level [ level ] . implication [ lang ] , statement : self . info . level [ level ] . statement [ lang ] } ; }

1<CODESPLIT>https://github.com/jneurock/gulp-viking-posts/blob/e14b19a6fe743c9525af0448d8988589961f936a/index.js#L242-L277<CODESPLIT>parseFrontMatter<CODESPLIT>Parse YAML front matter from post<CODESPLIT>function parseFrontMatter ( file , post , options ) { var _formatDate = options && typeof options . formatDate === 'function' ? options . formatDate : formatDate , content = frontMatter ( file . contents . toString ( ) ) , prop = '' ; if ( content . attributes ) { post . category = content . attributes . category || '' ; post . created = content . attributes . created ? _formatDate ( content . attributes . created ) : '' ; post . title = content . attributes . title || '' ; post . updated = content . attributes . updated ? _formatDate ( content . attributes . updated ) : '' ; if ( content . attributes . excerpt ) { post . excerpt = markdown ( content . attributes . excerpt ) ; } post . content = content . body ? markdown ( content . body ) : '' ; if ( post . content && highlightSyntax ) { highlightPostSyntax ( post ) ; } // Look for custom front-matter for ( prop in content . attributes ) { if ( content . attributes . hasOwnProperty ( prop ) && isCustomFrontMatter ( prop ) ) { post [ prop ] = content . attributes [ prop ] ; } } } }

1<CODESPLIT>https://github.com/publishlab/node-acme-client/blob/a58fd0bff5931bc52ca92c39909f25db37b58f89/src/crypto/openssl.js#L68-L79<CODESPLIT>getAction<CODESPLIT>Get OpenSSL action from buffer<CODESPLIT>function getAction ( key ) { const keyString = key . toString ( ) ; if ( keyString . match ( / CERTIFICATE\sREQUEST-{5}$ / m ) ) { return 'req' ; } else if ( keyString . match ( / (PUBLIC|PRIVATE)\sKEY-{5}$ / m ) ) { return 'rsa' ; } return 'x509' ; }

0<CODESPLIT>https://github.com/TempoIQ/tempoiq-node-js/blob/b3ab72f9d7760a54df9ef75093d349b28a29864c/lib/models/device.js#L4-L16<CODESPLIT><CODESPLIT>The top level container for a group of sensors .<CODESPLIT>function ( err , httpRes , body ) { if ( err ) _callback ( err ) else { try { var res = JSON . parse ( body ) } catch ( err ) { _callback ( null , body ) } if ( httpRes && httpRes . statusCode !== 200 ) { maybeRetry ( res , IOD , IODOpts , apiType , _callback ) } else _callback ( null , res ) } }

0<CODESPLIT>https://github.com/heap/heap-node/blob/b4b65d3daa74f1122bbbd7921c6ed3a45bd0b858/lib/client.js#L36-L54<CODESPLIT>expandErrors<CODESPLIT>Creates a new client for the Heap server - side API .<CODESPLIT>function expandErrors ( logger ) { var oldLogFunc = logger . log logger . log = function ( ) { var args = Array . prototype . slice . call ( arguments , 0 ) if ( args . length >= 2 && args [ 1 ] instanceof Error ) { args [ 1 ] = args [ 1 ] . stack } return oldLogFunc . apply ( this , args ) } ; return logger }

0<CODESPLIT>https://github.com/davidfig/jsdoc-template/blob/b54ea3af8b3368b8604f2f9a493bb169b7e24e27/plugins/es6-fix.js#L24-L38<CODESPLIT>bindShinryouEntered<CODESPLIT>Called before parsing a file giving us a change to replace the source .<CODESPLIT>function bindShinryouEntered ( dom , visitId ) { dom . on ( "shinryou-batch-entered" , function ( event , targetVisitId , shinryouList ) { if ( visitId === targetVisitId ) { event . stopPropagation ( ) ; dom . broadcast ( "rx-shinryou-batch-entered" , [ targetVisitId , shinryouList ] ) ; } } ) }

1<CODESPLIT>https://github.com/thinkkoa/think_lib/blob/1934e363fb931820c1cca746f34a7306084fa342/index.js#L353-L366<CODESPLIT>isWritable<CODESPLIT>Checks if the file or folder p is writable<CODESPLIT>function isWritable ( p ) { if ( ! fs . existsSync ( p ) ) { return false ; } let stats = fs . statSync ( p ) ; let mode = stats . mode ; let uid = process . getuid ? process . getuid ( ) : 0 ; let gid = process . getgid ? process . getgid ( ) : 0 ; let owner = uid === stats . uid ; let group = gid === stats . gid ; return ! ! ( owner && ( mode & parseInt ( '00200' , 8 ) ) || group && ( mode & parseInt ( '00020' , 8 ) ) || ( mode & parseInt ( '00002' , 8 ) ) ) ; }

1<CODESPLIT>https://github.com/addthis/fluxthis/blob/ccd399554ecac886d7389ffe9d6e72519d92c481/vendor/koa-compose.es6.js#L23-L35<CODESPLIT>compose<CODESPLIT>Compose middleware returning a fully valid middleware comprised of all those which are passed .<CODESPLIT>function compose ( middleware ) { return function * ( next ) { if ( ! next ) next = noop ( ) ; var i = middleware . length ; while ( i -- ) { next = middleware [ i ] . call ( this , next ) ; } yield * next ; } }

0<CODESPLIT>https://github.com/melonjs/melonJS/blob/6c1823cc245df7c958db243a0531506eb838d72c/dist/melonjs.js#L21750-L21757<CODESPLIT>setColor<CODESPLIT>Draw a filled rectangle at the specified coordinates<CODESPLIT>function setColor ( color ) { this . backBufferContext2D . strokeStyle = this . backBufferContext2D . fillStyle = color instanceof me . Color ? color . toRGBA ( ) : color ; }

1<CODESPLIT>https://github.com/geneontology/amigo/blob/c12209eff40abf15ad612525633ce7c2a625dfa9/javascript/web/FacetMatrix.js#L124-L308<CODESPLIT>next_step<CODESPLIT>Get the information for the incoming terms launch stage 02 . function init ( response manager ) {<CODESPLIT>function next_step ( response , search ) { ll ( 'init start...' ) ; // Prevent future actions (the register would be sticky). search . unregister ( 'search' , 'next step' ) ; // Take a look at the two facets that we'll be iterating over. ll ( 'Gathering functions for term data...' ) ; var reqs_to_do = 0 ; f1 = response . facet_field ( global_facet1 ) ; f2 = response . facet_field ( global_facet2 ) ; ll ( 'f1: ' + f1 ) ; ll ( 'f2: ' + f2 ) ; // Collect the initial node information for the two axes. // Also collect the initial index by id for both axes. var id_to_index = { } ; us . each ( [ f1 , f2 ] , function ( set ) { us . each ( set , function ( set_pair , set_index ) { var sid = set_pair [ 0 ] ; nodes . push ( { id : sid , index : set_index } ) ; id_to_index [ sid ] = set_index ; } ) ; } ) ; ll ( 'id_to_index #: ' + us . keys ( id_to_index ) . length ) ; // Now collect the batch URLs along one facet in reference to // the other (arbitrary)--we should be able to get what we // want by just looking at once facet and checking the other // as we vary it. var collected_functions = [ ] ; us . each ( f1 , function ( f1_pair ) { reqs_to_do ++ ; collected_functions . push ( function ( ) { var f1_id = f1_pair [ 0 ] ; // Return the state. // We have to reset the rows as well since rows is // not sticky across a search action (think about // it). search . set ( 'rows' , 0 ) ; // we don't need any actual rows search . set_facet_limit ( flimit ) ; search . reset_query_filters ( ) ; search . add_query_filter ( global_facet1 , f1_id ) ; return search . search ( ) ; } ) ; } ) ; // Fetch the data and scrape out what we want. var reqs_done = 0 ; var accumulator_fun = function ( resp ) { // Update progress bar. reqs_done ++ ; var per = Math . round ( ( reqs_done / reqs_to_do ) * 100 ) ; //ll(reqs_done + ' of ' + reqs_to_do + ' = ' + per + '%'); // jQuery(pwidget).progressbar('value', per); jQuery ( pwidget_bs3_bar ) . css ( 'width' , per + '%' ) ; jQuery ( pwidget_bs3_bar ) . attr ( 'aria-valuenow' , per ) ; // Recover the facet that we're currently looking at: 1. var f1_name = '???' ; var fq_set = resp . parameter ( 'fq' ) ; //ll('accumu: ' + dump(fq_set)); us . each ( fq_set , function ( fq_item ) { // Split up each line in the set. var two_part = bbop . first_split ( ':' , fq_item ) ; var fkey = two_part [ 0 ] ; var fval = bbop . dequote ( two_part [ 1 ] ) ; //ll('Looking at info for: ' + fval); // Check to see if it matches. If it does, that's the // recovered value. if ( fkey === global_facet1 ) { f1_name = fval ; } } ) ; ll ( 'got: ' + f1_name ) ; // Now grab out all of the second-facet information. //ll('accumu: ' + resp.raw()); var incoming_facet = resp . facet_field ( global_facet2 ) ; var in_hash = bbop . hashify ( incoming_facet ) ; ll ( 'in_hash: ' + bbop . dump ( in_hash ) ) ; us . each ( f2 , function ( f2_line , f2_index ) { // Figure out the value for this pair. var f2_name = f2_line [ 0 ] ; //var comb_val = f2_line[1]; var comb_val = 0 ; var results_val = 0 ; if ( typeof ( in_hash [ f2_name ] ) !== 'undefined' ) { results_val = in_hash [ f2_name ] ; } ll ( [ f1_name , f2_name ] . join ( ', ' ) + ': ' + results_val ) ; // Up the max. if ( results_val > max_val ) { max_val = results_val ; } // While we're here, let's also create a lookup // structure. if ( typeof ( val_hash [ f1_name ] ) === 'undefined' ) { val_hash [ f1_name ] = { } ; } if ( typeof ( val_hash [ f2_name ] ) === 'undefined' ) { val_hash [ f2_name ] = { } ; } if ( typeof ( val_hash [ f1_name ] [ f2_name ] ) === 'undefined' ) { val_hash [ f1_name ] [ f2_name ] = results_val ; } if ( typeof ( val_hash [ f2_name ] [ f1_name ] ) === 'undefined' ) { val_hash [ f2_name ] [ f1_name ] = results_val ; } } ) ; } ; /// /// Coloration functions using D3. /// We have the max_val now, so we can compute color. /// // A value from our values domain in to a color in our range. // 0 always maps to a white-ish color. var c = d3 . scale . linear ( ) . domain ( [ 0 , max_val ] ) . rangeRound ( [ 127 , 255 ] ) ; function value_to_color_dark ( val ) { //var retval = '#efefef'; var retval = '#fafafa' ; if ( val !== 0 ) { var cval = c ( val ) ; var cinv = 255 - cval ; var chex = cinv . toString ( 16 ) ; if ( cval ) { if ( chex . length === 1 ) { chex = '0' + chex ; } retval = '#' + chex + chex + chex + '' ; } } return retval ; } function value_to_color_step ( val ) { //var retval = '#efefef'; var retval = '#fafafa' ; if ( val !== 0 ) { // 1-3 = pale green // 4-10 = yellow // 11-100 = orange // 101+ = red  if ( val <= 3 ) { retval = '#79f853' ; // green } else if ( val <= 10 ) { //retval = '#f5ff2b'; // yellow retval = '#e8f129' ; // yellow } else if ( val <= 100 ) { retval = '#fd953b' ; // orange		 } else { retval = '#ff4e53' ; } } return retval ; } // Decide our coloration live at this point. //var value_to_color = value_to_color_dark; // default value_to_color = value_to_color_step ; // default // var curr_color_selection = // 	jQuery("input:radio[name=color]:checked").val(); // The final function is the data renderer. var final_fun = function ( ) { ll ( 'Entering final_fun...' ) ; // We are done! jQuery ( pwidget_bs3_container ) . hide ( ) ; //render(matrix, nodes, max_val); render ( ) ; } ; // The final function is the data renderer. var error_fun = function ( err ) { alert ( 'Encountered error while running: ' + err . toString ( ) ) ; } ; search . run_promise_functions ( collected_functions , accumulator_fun , final_fun , error_fun ) ; }

0<CODESPLIT>https://github.com/mtth/avsc/blob/d4e62f360b8f27c4b95372cac58c95157f87865a/lib/utils.js#L35-L41<CODESPLIT>getOption<CODESPLIT>Create a new buffer with the input contents .<CODESPLIT>function getOption ( opts , key , def ) { var value = opts [ key ] ; return value === undefined ? def : value ; }

1<CODESPLIT>https://github.com/filmic/Robol/blob/f0611bcabda7f8009a04063a0661b7daed603b5e/lib/robol.js#L326-L335<CODESPLIT><CODESPLIT>Callback for lint task<CODESPLIT>function ( blob ) { if ( blob . csslint && blob . csslint . length && blob . csslint [ 0 ] . line !== undefined ) { console . log ( '\nCSSLint reports issues in: ' . red + blob . name ) ; blob . csslint . forEach ( function ( i ) { if ( i ) { console . log ( ' Line ' + i . line + ', Col ' + i . col + ': ' + i . message ) ; } } ) ; } }

1<CODESPLIT>https://github.com/semibran/pack/blob/27103c7b53111ec96624d926b295b2976ea850af/lib/pack.js#L93-L102<CODESPLIT>validate<CODESPLIT>determines if the region specified by box is clear of all other boxes<CODESPLIT>function validate ( boxes , box ) { var a = box for ( var i = 0 ; i < boxes . length ; i ++ ) { var b = boxes [ i ] if ( intersects ( a , b ) ) { return false } } return true }

0<CODESPLIT>https://github.com/realtime-framework/RealtimeMessaging-Javascript/blob/0a13dbd1457e77783aa043a3ff411408bbd097ed/ortc.js#L3617-L3632<CODESPLIT><CODESPLIT>/ * Disconnects the socket .<CODESPLIT>function ( ) { stopHeartBeatInterval ( ortc ) ; if ( isConnecting ) { delegateExceptionCallback ( ortc , 'Unable to connect' ) ; } isConnecting = true ; delegateReconnectingCallback ( ortc ) ; reconnectStartedAt = new Date ( ) . getTime ( ) ; if ( clusterUrl && clusterUrl != null ) { clusterConnection ( ) ; } else { ortc . sockjs = createSocketConnection ( url ) ; } }

0<CODESPLIT>https://github.com/mz121star/NJBlog/blob/08be4473daa854e3e8942340998a6c282f3f8c44/libs/mocha/should.js#L415-L421<CODESPLIT><CODESPLIT>Assert string value matches _regexp_ .<CODESPLIT>function ( n , desc ) { this . obj . should . have . property ( 'length' ) ; var len = this . obj . length ; this . assert ( n == len , function ( ) { return 'expected ' + this . inspect + ' to have a length of ' + n + ' but got ' + len + ( desc ? " | " + desc : "" ) } , function ( ) { return 'expected ' + this . inspect + ' to not have a length of ' + len + ( desc ? " | " + desc : "" ) } ) ; return this ; }

1<CODESPLIT>https://github.com/JamesMessinger/json-schema-lib/blob/6a30b2be496b82eda61d050b30e64b44fa42734a/lib/api/JsonSchemaLib/read.js#L26-L50<CODESPLIT>read<CODESPLIT>Reads the given file URL or data including any other files or URLs that are referneced by JSON References ( $ref ) .<CODESPLIT>function read ( url , data , config , callback ) { // Create a new JSON Schema and root file var schema = new Schema ( config , this . plugins ) ; var rootFile = new File ( schema ) ; schema . files . push ( rootFile ) ; if ( url ) { // Resolve the user-supplied URL to an absolute URL url = schema . plugins . resolveURL ( { to : url } ) ; // Remove any hash from the URL, since this URL represents the WHOLE file, not a fragment of it rootFile . url = stripHash ( url ) ; } if ( data ) { // No need to read the file, because its data was passed-in rootFile . data = data ; rootFile [ __internal ] . state = STATE_READ ; safeCall ( parseFile , rootFile , callback ) ; } else { // Read/download the file safeCall ( readFile , rootFile , callback ) ; } }

1<CODESPLIT>https://github.com/tmcw/stickshift/blob/1be06709ca2e1c59d5e5d4b9a0c7b34a46349001/stickshift.js#L14868-L14883<CODESPLIT>ReactWheelHandler<CODESPLIT>onWheel is the callback that will be called with right frame rate if any wheel events happened onWheel should is to be called with two arguments : deltaX and deltaY in this order<CODESPLIT>function ReactWheelHandler ( onWheel , /*boolean*/ handleScrollX , /*boolean*/ handleScrollY , /*?boolean*/ stopPropagation ) { this . $ReactWheelHandler_animationFrameID = null ; this . $ReactWheelHandler_deltaX = 0 ; this . $ReactWheelHandler_deltaY = 0 ; this . $ReactWheelHandler_didWheel = this . $ReactWheelHandler_didWheel . bind ( this ) ; this . $ReactWheelHandler_handleScrollX = handleScrollX ; this . $ReactWheelHandler_handleScrollY = handleScrollY ; this . $ReactWheelHandler_stopPropagation = ! ! stopPropagation ; this . $ReactWheelHandler_onWheelCallback = onWheel ; this . onWheel = this . onWheel . bind ( this ) ; }

0<CODESPLIT>https://github.com/sony/cdp-js/blob/00e5ef7f2cb4addac61bfbee1fa2bc99e939e0b6/packages/master-tasks/tasks/bundle.js#L75-L119<CODESPLIT>generateBannerNode<CODESPLIT>///////////////////////////////////////////////////////////////////// for classical module structure<CODESPLIT>function generateBannerNode ( ) { const _ = require ( 'lodash' ) ; const srcmap = require ( './srcmap' ) ; const dependencies = ( ( ) => { var modules = [ ] ; config . include_modules . forEach ( function ( target ) { const pkgPath = path . join ( __dirname , '../..' , target , 'package.json' ) ; const pkg = require ( pkgPath ) ; modules . push ( { name : pkg . name , version : pkg . version , } ) ; } ) ; const include = fs . readFileSync ( path . join ( __dirname , '..' , 'BANNER-INCLUDES' ) ) . toString ( ) ; return _ . template ( include ) ( { modules : modules } ) ; } ) ( ) ; const bannerText = banner ( '' , null ) . replace ( ' */' , dependencies ) . replace ( / \ufeff / gm , '' ) ; return srcmap . getNodeFromCode ( bannerText ) ; }

0<CODESPLIT>https://github.com/nhn/tui.grid/blob/9f66e339485e505bb85490c03a6a2db8dd599e0a/src/js/view/layout/header.js#L198-L209<CODESPLIT><CODESPLIT>Returns an array of names of merged - column which contains every column name in the given array .<CODESPLIT>function ( ) { var $ths = this . $el . find ( 'th' ) ; var columnNames , mergedColumnNames ; if ( this . selectionModel . hasSelection ( ) ) { columnNames = this . _getSelectedColumnNames ( ) ; } else if ( this . focusModel . has ( true ) ) { columnNames = [ this . focusModel . get ( 'columnName' ) ] ; } $ths . removeClass ( classNameConst . CELL_SELECTED ) ; if ( columnNames ) { mergedColumnNames = this . _getContainingMergedColumnNames ( columnNames ) ; _ . each ( columnNames . concat ( mergedColumnNames ) , function ( columnName ) { $ths . filter ( '[' + ATTR_COLUMN_NAME + '="' + columnName + '"]' ) . addClass ( classNameConst . CELL_SELECTED ) ; } ) ; } }

0<CODESPLIT>https://github.com/relief-melone/limitpromises/blob/1735b92749740204b597c1c6026257d54ade8200/src/services/service.retryPromiseTimeout.js#L17-L56<CODESPLIT><CODESPLIT>Handles Timeout of promises<CODESPLIT>function ( name , dimensions ) { name = name || '' ; name = name . replace ( / ^\s* / , '' ) ; name = name . replace ( / \s*$ / , '' ) ; if ( name . length === 0 ) { throw 'A name for the custom event must be provided' ; } _ . each ( dimensions , function ( val , key ) { if ( ! _ . isString ( key ) || ! _ . isString ( val ) ) { throw 'track() dimensions expects keys and values of type "string".' ; } } ) ; return Parse . _request ( { route : 'events' , className : name , method : 'POST' , data : { dimensions : dimensions } } ) ; }

1<CODESPLIT>https://github.com/LI-NA/optipng.js/blob/9657fe80a9135e58e20c858515f049c6c76a08e7/demo/js/optipng.js#L18-L66759<CODESPLIT>optipng<CODESPLIT>-- pre - jses are emitted after the Module integration code so that they can refer to Module ( if they choose ; they can also define Module )<CODESPLIT>function optipng ( file , options , printFunction ) { if ( typeof file === 'undefined' ) return ; var stdout = "" ; var stderr = "" ; // Default arguments. set output file var args = [ '-out' , '/output.png' ] ; // You also can use array of options. if ( Array . isArray ( options ) ) { args = args . concat ( options ) ; } else { // Create command line options to passed using input `options` object for ( var key in options ) { if ( typeof options [ key ] == "string" ) { args . push ( "-" + key ) ; if ( typeof options [ key ] !== "boolean" ) { // option has a value args . push ( String ( options [ key ] ) ) ; } } } } // Target file name. args . push ( "/input.png" ) ; var Module = { "print" : function ( text ) { stdout += text + "\n" ; if ( typeof printFunction == "function" ) printFunction ( text ) ; } , "printErr" : function ( text ) { stderr += text + "\n" ; if ( typeof printFunction == "function" ) printFunction ( text ) ; } , // Mounting input file "preRun" : [ function ( ) { FS . writeFile ( "/input.png" , file , { encoding : "binary" } ) ; } ] , "arguments" : args , "ENVIRONMENT" : "SHELL" // maximum compatibility??? } ; // Sometimes an existing Module object exists with properties // meant to overwrite the default module functionality. Here // we collect those properties and reapply _after_ we configure // the current environment's defaults to avoid having to be so // defensive during initialization. var moduleOverrides = { } ; var key ; for ( key in Module ) { if ( Module . hasOwnProperty ( key ) ) { moduleOverrides [ key ] = Module [ key ] ; } } Module [ 'arguments' ] = [ ] ; Module [ 'thisProgram' ] = './this.program' ; Module [ 'quit' ] = function ( status , toThrow ) { throw toThrow ; } ; Module [ 'preRun' ] = [ ] ; Module [ 'postRun' ] = [ ] ; // The environment setup code below is customized to use Module. // *** Environment setup code *** var ENVIRONMENT_IS_WEB = false ; var ENVIRONMENT_IS_WORKER = false ; var ENVIRONMENT_IS_NODE = false ; var ENVIRONMENT_IS_SHELL = false ; // Three configurations we can be running in: // 1) We could be the application main() thread running in the main JS UI thread. (ENVIRONMENT_IS_WORKER == false and ENVIRONMENT_IS_PTHREAD == false) // 2) We could be the application main() thread proxied to worker. (with Emscripten -s PROXY_TO_WORKER=1) (ENVIRONMENT_IS_WORKER == true, ENVIRONMENT_IS_PTHREAD == false) // 3) We could be an application pthread running in a worker. (ENVIRONMENT_IS_WORKER == true and ENVIRONMENT_IS_PTHREAD == true) if ( Module [ 'ENVIRONMENT' ] ) { if ( Module [ 'ENVIRONMENT' ] === 'WEB' ) { ENVIRONMENT_IS_WEB = true ; } else if ( Module [ 'ENVIRONMENT' ] === 'WORKER' ) { ENVIRONMENT_IS_WORKER = true ; } else if ( Module [ 'ENVIRONMENT' ] === 'NODE' ) { ENVIRONMENT_IS_NODE = true ; } else if ( Module [ 'ENVIRONMENT' ] === 'SHELL' ) { ENVIRONMENT_IS_SHELL = true ; } else { throw new Error ( 'Module[\'ENVIRONMENT\'] value is not valid. must be one of: WEB|WORKER|NODE|SHELL.' ) ; } } else { ENVIRONMENT_IS_WEB = typeof window === 'object' ; ENVIRONMENT_IS_WORKER = typeof importScripts === 'function' ; ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof require === 'function' && ! ENVIRONMENT_IS_WEB && ! ENVIRONMENT_IS_WORKER ; ENVIRONMENT_IS_SHELL = ! ENVIRONMENT_IS_WEB && ! ENVIRONMENT_IS_NODE && ! ENVIRONMENT_IS_WORKER ; } if ( ENVIRONMENT_IS_NODE ) { // Expose functionality in the same simple way that the shells work // Note that we pollute the global namespace here, otherwise we break in node var nodeFS ; var nodePath ; Module [ 'read' ] = function shell_read ( filename , binary ) { var ret ; ret = tryParseAsDataURI ( filename ) ; if ( ! ret ) { if ( ! nodeFS ) nodeFS = require ( 'fs' ) ; if ( ! nodePath ) nodePath = require ( 'path' ) ; filename = nodePath [ 'normalize' ] ( filename ) ; ret = nodeFS [ 'readFileSync' ] ( filename ) ; } return binary ? ret : ret . toString ( ) ; } ; Module [ 'readBinary' ] = function readBinary ( filename ) { var ret = Module [ 'read' ] ( filename , true ) ; if ( ! ret . buffer ) { ret = new Uint8Array ( ret ) ; } assert ( ret . buffer ) ; return ret ; } ; if ( process [ 'argv' ] . length > 1 ) { Module [ 'thisProgram' ] = process [ 'argv' ] [ 1 ] . replace ( / \\ / g , '/' ) ; } Module [ 'arguments' ] = process [ 'argv' ] . slice ( 2 ) ; if ( typeof module !== 'undefined' ) { module [ 'exports' ] = Module ; } process [ 'on' ] ( 'uncaughtException' , function ( ex ) { // suppress ExitStatus exceptions from showing an error if ( ! ( ex instanceof ExitStatus ) ) { throw ex ; } } ) ; // Currently node will swallow unhandled rejections, but this behavior is // deprecated, and in the future it will exit with error status. process [ 'on' ] ( 'unhandledRejection' , function ( reason , p ) { Module [ 'printErr' ] ( 'node.js exiting due to unhandled promise rejection' ) ; process [ 'exit' ] ( 1 ) ; } ) ; Module [ 'inspect' ] = function ( ) { return '[Emscripten Module object]' ; } ; } else if ( ENVIRONMENT_IS_SHELL ) { if ( typeof read != 'undefined' ) { Module [ 'read' ] = function shell_read ( f ) { var data = tryParseAsDataURI ( f ) ; if ( data ) { return intArrayToString ( data ) ; } return read ( f ) ; } ; } Module [ 'readBinary' ] = function readBinary ( f ) { var data ; data = tryParseAsDataURI ( f ) ; if ( data ) { return data ; } if ( typeof readbuffer === 'function' ) { return new Uint8Array ( readbuffer ( f ) ) ; } data = read ( f , 'binary' ) ; assert ( typeof data === 'object' ) ; return data ; } ; if ( typeof scriptArgs != 'undefined' ) { Module [ 'arguments' ] = scriptArgs ; } else if ( typeof arguments != 'undefined' ) { Module [ 'arguments' ] = arguments ; } if ( typeof quit === 'function' ) { Module [ 'quit' ] = function ( status , toThrow ) { quit ( status ) ; } } } else if ( ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER ) { Module [ 'read' ] = function shell_read ( url ) { try { var xhr = new XMLHttpRequest ( ) ; xhr . open ( 'GET' , url , false ) ; xhr . send ( null ) ; return xhr . responseText ; } catch ( err ) { var data = tryParseAsDataURI ( url ) ; if ( data ) { return intArrayToString ( data ) ; } throw err ; } } ; if ( ENVIRONMENT_IS_WORKER ) { Module [ 'readBinary' ] = function readBinary ( url ) { try { var xhr = new XMLHttpRequest ( ) ; xhr . open ( 'GET' , url , false ) ; xhr . responseType = 'arraybuffer' ; xhr . send ( null ) ; return new Uint8Array ( xhr . response ) ; } catch ( err ) { var data = tryParseAsDataURI ( url ) ; if ( data ) { return data ; } throw err ; } } ; } Module [ 'readAsync' ] = function readAsync ( url , onload , onerror ) { var xhr = new XMLHttpRequest ( ) ; xhr . open ( 'GET' , url , true ) ; xhr . responseType = 'arraybuffer' ; xhr . onload = function xhr_onload ( ) { if ( xhr . status == 200 || ( xhr . status == 0 && xhr . response ) ) { // file URLs can return 0 onload ( xhr . response ) ; return ; } var data = tryParseAsDataURI ( url ) ; if ( data ) { onload ( data . buffer ) ; return ; } onerror ( ) ; } ; xhr . onerror = onerror ; xhr . send ( null ) ; } ; Module [ 'setWindowTitle' ] = function ( title ) { document . title = title } ; } else { // Unreachable because SHELL is dependent on the others throw new Error ( 'unknown runtime environment' ) ; } // console.log is checked first, as 'print' on the web will open a print dialogue // printErr is preferable to console.warn (works better in shells) // bind(console) is necessary to fix IE/Edge closed dev tools panel behavior. Module [ 'print' ] = typeof console !== 'undefined' ? console . log . bind ( console ) : ( typeof print !== 'undefined' ? print : null ) ; Module [ 'printErr' ] = typeof printErr !== 'undefined' ? printErr : ( ( typeof console !== 'undefined' && console . warn . bind ( console ) ) || Module [ 'print' ] ) ; // *** Environment setup code *** // Closure helpers Module . print = Module [ 'print' ] ; Module . printErr = Module [ 'printErr' ] ; // Merge back in the overrides for ( key in moduleOverrides ) { if ( moduleOverrides . hasOwnProperty ( key ) ) { Module [ key ] = moduleOverrides [ key ] ; } } // Free the object hierarchy contained in the overrides, this lets the GC // reclaim data used e.g. in memoryInitializerRequest, which is a large typed array. moduleOverrides = undefined ; // {{PREAMBLE_ADDITIONS}} var STACK_ALIGN = 16 ; // stack management, and other functionality that is provided by the compiled code, // should not be used before it is ready stackSave = stackRestore = stackAlloc = setTempRet0 = getTempRet0 = function ( ) { abort ( 'cannot use the stack before compiled code is ready to run, and has provided stack access' ) ; } ; function staticAlloc ( size ) { assert ( ! staticSealed ) ; var ret = STATICTOP ; STATICTOP = ( STATICTOP + size + 15 ) & - 16 ; return ret ; } function dynamicAlloc ( size ) { assert ( DYNAMICTOP_PTR ) ; var ret = HEAP32 [ DYNAMICTOP_PTR >> 2 ] ; var end = ( ret + size + 15 ) & - 16 ; HEAP32 [ DYNAMICTOP_PTR >> 2 ] = end ; if ( end >= TOTAL_MEMORY ) { var success = enlargeMemory ( ) ; if ( ! success ) { HEAP32 [ DYNAMICTOP_PTR >> 2 ] = ret ; return 0 ; } } return ret ; } function alignMemory ( size , factor ) { if ( ! factor ) factor = STACK_ALIGN ; // stack alignment (16-byte) by default var ret = size = Math . ceil ( size / factor ) * factor ; return ret ; } function getNativeTypeSize ( type ) { switch ( type ) { case 'i1' : case 'i8' : return 1 ; case 'i16' : return 2 ; case 'i32' : return 4 ; case 'i64' : return 8 ; case 'float' : return 4 ; case 'double' : return 8 ; default : { if ( type [ type . length - 1 ] === '*' ) { return 4 ; // A pointer } else if ( type [ 0 ] === 'i' ) { var bits = parseInt ( type . substr ( 1 ) ) ; assert ( bits % 8 === 0 ) ; return bits / 8 ; } else { return 0 ; } } } } function warnOnce ( text ) { if ( ! warnOnce . shown ) warnOnce . shown = { } ; if ( ! warnOnce . shown [ text ] ) { warnOnce . shown [ text ] = 1 ; Module . printErr ( text ) ; } } var jsCallStartIndex = 1 ; var functionPointers = new Array ( 0 ) ; // 'sig' parameter is only used on LLVM wasm backend function addFunction ( func , sig ) { if ( typeof sig === 'undefined' ) { Module . printErr ( 'Warning: addFunction: Provide a wasm function signature ' + 'string as a second argument' ) ; } var base = 0 ; for ( var i = base ; i < base + 0 ; i ++ ) { if ( ! functionPointers [ i ] ) { functionPointers [ i ] = func ; return jsCallStartIndex + i ; } } throw 'Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.' ; } function removeFunction ( index ) { functionPointers [ index - jsCallStartIndex ] = null ; } var funcWrappers = { } ; function getFuncWrapper ( func , sig ) { if ( ! func ) return ; // on null pointer, return undefined assert ( sig ) ; if ( ! funcWrappers [ sig ] ) { funcWrappers [ sig ] = { } ; } var sigCache = funcWrappers [ sig ] ; if ( ! sigCache [ func ] ) { // optimize away arguments usage in common cases if ( sig . length === 1 ) { sigCache [ func ] = function dynCall_wrapper ( ) { return dynCall ( sig , func ) ; } ; } else if ( sig . length === 2 ) { sigCache [ func ] = function dynCall_wrapper ( arg ) { return dynCall ( sig , func , [ arg ] ) ; } ; } else { // general case sigCache [ func ] = function dynCall_wrapper ( ) { return dynCall ( sig , func , Array . prototype . slice . call ( arguments ) ) ; } ; } } return sigCache [ func ] ; } function makeBigInt ( low , high , unsigned ) { return unsigned ? ( ( + ( ( low >>> 0 ) ) ) + ( ( + ( ( high >>> 0 ) ) ) * 4294967296.0 ) ) : ( ( + ( ( low >>> 0 ) ) ) + ( ( + ( ( high | 0 ) ) ) * 4294967296.0 ) ) ; } function dynCall ( sig , ptr , args ) { if ( args && args . length ) { assert ( args . length == sig . length - 1 ) ; assert ( ( 'dynCall_' + sig ) in Module , 'bad function pointer type - no table for sig \'' + sig + '\'' ) ; return Module [ 'dynCall_' + sig ] . apply ( null , [ ptr ] . concat ( args ) ) ; } else { assert ( sig . length == 1 ) ; assert ( ( 'dynCall_' + sig ) in Module , 'bad function pointer type - no table for sig \'' + sig + '\'' ) ; return Module [ 'dynCall_' + sig ] . call ( null , ptr ) ; } } function getCompilerSetting ( name ) { throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for getCompilerSetting or emscripten_get_compiler_setting to work' ; } var Runtime = { // FIXME backwards compatibility layer for ports. Support some Runtime.* //       for now, fix it there, then remove it from here. That way we //       can minimize any period of breakage. dynCall : dynCall , // for SDL2 port // helpful errors getTempRet0 : function ( ) { abort ( 'getTempRet0() is now a top-level function, after removing the Runtime object. Remove "Runtime."' ) } , staticAlloc : function ( ) { abort ( 'staticAlloc() is now a top-level function, after removing the Runtime object. Remove "Runtime."' ) } , stackAlloc : function ( ) { abort ( 'stackAlloc() is now a top-level function, after removing the Runtime object. Remove "Runtime."' ) } , } ; // The address globals begin at. Very low in memory, for code size and optimization opportunities. // Above 0 is static memory, starting with globals. // Then the stack. // Then 'dynamic' memory for sbrk. var GLOBAL_BASE = 8 ; // === Preamble library stuff === // Documentation for the public APIs defined in this file must be updated in: //    site/source/docs/api_reference/preamble.js.rst // A prebuilt local version of the documentation is available at: //    site/build/text/docs/api_reference/preamble.js.txt // You can also build docs locally as HTML or other formats in site/ // An online HTML version (which may be of a different version of Emscripten) //    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html //======================================== // Runtime essentials //======================================== var ABORT = 0 ; // whether we are quitting the application. no code should run after this. set in exit() and abort() var EXITSTATUS = 0 ; /** @type {function(*, string=)} */ function assert ( condition , text ) { if ( ! condition ) { abort ( 'Assertion failed: ' + text ) ; } } var globalScope = this ; // Returns the C function with a specified identifier (for C++, you need to do manual name mangling) function getCFunc ( ident ) { var func = Module [ '_' + ident ] ; // closure exported function assert ( func , 'Cannot call unknown function ' + ident + ', make sure it is exported' ) ; return func ; } var JSfuncs = { // Helpers for cwrap -- it can't refer to Runtime directly because it might // be renamed by closure, instead it calls JSfuncs['stackSave'].body to find // out what the minified function name is. 'stackSave' : function ( ) { stackSave ( ) } , 'stackRestore' : function ( ) { stackRestore ( ) } , // type conversion from js to c 'arrayToC' : function ( arr ) { var ret = stackAlloc ( arr . length ) ; writeArrayToMemory ( arr , ret ) ; return ret ; } , 'stringToC' : function ( str ) { var ret = 0 ; if ( str !== null && str !== undefined && str !== 0 ) { // null string // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0' var len = ( str . length << 2 ) + 1 ; ret = stackAlloc ( len ) ; stringToUTF8 ( str , ret , len ) ; } return ret ; } } ; // For fast lookup of conversion functions var toC = { 'string' : JSfuncs [ 'stringToC' ] , 'array' : JSfuncs [ 'arrayToC' ] } ; // C calling interface. function ccall ( ident , returnType , argTypes , args , opts ) { var func = getCFunc ( ident ) ; var cArgs = [ ] ; var stack = 0 ; assert ( returnType !== 'array' , 'Return type should not be "array".' ) ; if ( args ) { for ( var i = 0 ; i < args . length ; i ++ ) { var converter = toC [ argTypes [ i ] ] ; if ( converter ) { if ( stack === 0 ) stack = stackSave ( ) ; cArgs [ i ] = converter ( args [ i ] ) ; } else { cArgs [ i ] = args [ i ] ; } } } var ret = func . apply ( null , cArgs ) ; if ( returnType === 'string' ) ret = Pointer_stringify ( ret ) ; else if ( returnType === 'boolean' ) ret = Boolean ( ret ) ; if ( stack !== 0 ) { stackRestore ( stack ) ; } return ret ; } function cwrap ( ident , returnType , argTypes ) { argTypes = argTypes || [ ] ; var cfunc = getCFunc ( ident ) ; // When the function takes numbers and returns a number, we can just return // the original function var numericArgs = argTypes . every ( function ( type ) { return type === 'number' } ) ; var numericRet = returnType !== 'string' ; if ( numericRet && numericArgs ) { return cfunc ; } return function ( ) { return ccall ( ident , returnType , argTypes , arguments ) ; } } /** @type {function(number, number, string, boolean=)} */ function setValue ( ptr , value , type , noSafe ) { type = type || 'i8' ; if ( type . charAt ( type . length - 1 ) === '*' ) type = 'i32' ; // pointers are 32-bit switch ( type ) { case 'i1' : HEAP8 [ ( ( ptr ) >> 0 ) ] = value ; break ; case 'i8' : HEAP8 [ ( ( ptr ) >> 0 ) ] = value ; break ; case 'i16' : HEAP16 [ ( ( ptr ) >> 1 ) ] = value ; break ; case 'i32' : HEAP32 [ ( ( ptr ) >> 2 ) ] = value ; break ; case 'i64' : ( tempI64 = [ value >>> 0 , ( tempDouble = value , ( + ( Math_abs ( tempDouble ) ) ) >= 1.0 ? ( tempDouble > 0.0 ? ( ( Math_min ( ( + ( Math_floor ( ( tempDouble ) / 4294967296.0 ) ) ) , 4294967295.0 ) ) | 0 ) >>> 0 : ( ~ ~ ( ( + ( Math_ceil ( ( tempDouble - + ( ( ( ~ ~ ( tempDouble ) ) ) >>> 0 ) ) / 4294967296.0 ) ) ) ) ) >>> 0 ) : 0 ) ] , HEAP32 [ ( ( ptr ) >> 2 ) ] = tempI64 [ 0 ] , HEAP32 [ ( ( ( ptr ) + ( 4 ) ) >> 2 ) ] = tempI64 [ 1 ] ) ; break ; case 'float' : HEAPF32 [ ( ( ptr ) >> 2 ) ] = value ; break ; case 'double' : HEAPF64 [ ( ( ptr ) >> 3 ) ] = value ; break ; default : abort ( 'invalid type for setValue: ' + type ) ; } } /** @type {function(number, string, boolean=)} */ function getValue ( ptr , type , noSafe ) { type = type || 'i8' ; if ( type . charAt ( type . length - 1 ) === '*' ) type = 'i32' ; // pointers are 32-bit switch ( type ) { case 'i1' : return HEAP8 [ ( ( ptr ) >> 0 ) ] ; case 'i8' : return HEAP8 [ ( ( ptr ) >> 0 ) ] ; case 'i16' : return HEAP16 [ ( ( ptr ) >> 1 ) ] ; case 'i32' : return HEAP32 [ ( ( ptr ) >> 2 ) ] ; case 'i64' : return HEAP32 [ ( ( ptr ) >> 2 ) ] ; case 'float' : return HEAPF32 [ ( ( ptr ) >> 2 ) ] ; case 'double' : return HEAPF64 [ ( ( ptr ) >> 3 ) ] ; default : abort ( 'invalid type for getValue: ' + type ) ; } return null ; } var ALLOC_NORMAL = 0 ; // Tries to use _malloc() var ALLOC_STACK = 1 ; // Lives for the duration of the current function call var ALLOC_STATIC = 2 ; // Cannot be freed var ALLOC_DYNAMIC = 3 ; // Cannot be freed except through sbrk var ALLOC_NONE = 4 ; // Do not allocate // allocate(): This is for internal use. You can use it yourself as well, but the interface //             is a little tricky (see docs right below). The reason is that it is optimized //             for multiple syntaxes to save space in generated code. So you should //             normally not use allocate(), and instead allocate memory using _malloc(), //             initialize it with setValue(), and so forth. // @slab: An array of data, or a number. If a number, then the size of the block to allocate, //        in *bytes* (note that this is sometimes confusing: the next parameter does not //        affect this!) // @types: Either an array of types, one for each byte (or 0 if no type at that position), //         or a single type which is used for the entire block. This only matters if there //         is initial data - if @slab is a number, then this does not matter at all and is //         ignored. // @allocator: How to allocate memory, see ALLOC_* /** @type {function((TypedArray|Array<number>|number), string, number, number=)} */ function allocate ( slab , types , allocator , ptr ) { var zeroinit , size ; if ( typeof slab === 'number' ) { zeroinit = true ; size = slab ; } else { zeroinit = false ; size = slab . length ; } var singleType = typeof types === 'string' ? types : null ; var ret ; if ( allocator == ALLOC_NONE ) { ret = ptr ; } else { ret = [ typeof _malloc === 'function' ? _malloc : staticAlloc , stackAlloc , staticAlloc , dynamicAlloc ] [ allocator === undefined ? ALLOC_STATIC : allocator ] ( Math . max ( size , singleType ? 1 : types . length ) ) ; } if ( zeroinit ) { var stop ; ptr = ret ; assert ( ( ret & 3 ) == 0 ) ; stop = ret + ( size & ~ 3 ) ; for ( ; ptr < stop ; ptr += 4 ) { HEAP32 [ ( ( ptr ) >> 2 ) ] = 0 ; } stop = ret + size ; while ( ptr < stop ) { HEAP8 [ ( ( ptr ++ ) >> 0 ) ] = 0 ; } return ret ; } if ( singleType === 'i8' ) { if ( slab . subarray || slab . slice ) { HEAPU8 . set ( /** @type {!Uint8Array} */ ( slab ) , ret ) ; } else { HEAPU8 . set ( new Uint8Array ( slab ) , ret ) ; } return ret ; } var i = 0 , type , typeSize , previousType ; while ( i < size ) { var curr = slab [ i ] ; type = singleType || types [ i ] ; if ( type === 0 ) { i ++ ; continue ; } assert ( type , 'Must know what type to store in allocate!' ) ; if ( type == 'i64' ) type = 'i32' ; // special case: we have one i32 here, and one i32 later setValue ( ret + i , curr , type ) ; // no need to look up size unless type changes, so cache it if ( previousType !== type ) { typeSize = getNativeTypeSize ( type ) ; previousType = type ; } i += typeSize ; } return ret ; } // Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready function getMemory ( size ) { if ( ! staticSealed ) return staticAlloc ( size ) ; if ( ! runtimeInitialized ) return dynamicAlloc ( size ) ; return _malloc ( size ) ; } /** @type {function(number, number=)} */ function Pointer_stringify ( ptr , length ) { if ( length === 0 || ! ptr ) return '' ; // TODO: use TextDecoder // Find the length, and check for UTF while doing so var hasUtf = 0 ; var t ; var i = 0 ; while ( 1 ) { assert ( ptr + i < TOTAL_MEMORY ) ; t = HEAPU8 [ ( ( ( ptr ) + ( i ) ) >> 0 ) ] ; hasUtf |= t ; if ( t == 0 && ! length ) break ; i ++ ; if ( length && i == length ) break ; } if ( ! length ) length = i ; var ret = '' ; if ( hasUtf < 128 ) { var MAX_CHUNK = 1024 ; // split up into chunks, because .apply on a huge string can overflow the stack var curr ; while ( length > 0 ) { curr = String . fromCharCode . apply ( String , HEAPU8 . subarray ( ptr , ptr + Math . min ( length , MAX_CHUNK ) ) ) ; ret = ret ? ret + curr : curr ; ptr += MAX_CHUNK ; length -= MAX_CHUNK ; } return ret ; } return UTF8ToString ( ptr ) ; } // Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns // a copy of that string as a Javascript String object. function AsciiToString ( ptr ) { var str = '' ; while ( 1 ) { var ch = HEAP8 [ ( ( ptr ++ ) >> 0 ) ] ; if ( ! ch ) return str ; str += String . fromCharCode ( ch ) ; } } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr', // null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP. function stringToAscii ( str , outPtr ) { return writeAsciiToMemory ( str , outPtr , false ) ; } // Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns // a copy of that string as a Javascript String object. var UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder ( 'utf8' ) : undefined ; function UTF8ArrayToString ( u8Array , idx ) { var endPtr = idx ; // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself. // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage. while ( u8Array [ endPtr ] ) ++ endPtr ; if ( endPtr - idx > 16 && u8Array . subarray && UTF8Decoder ) { return UTF8Decoder . decode ( u8Array . subarray ( idx , endPtr ) ) ; } else { var u0 , u1 , u2 , u3 , u4 , u5 ; var str = '' ; while ( 1 ) { // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629 u0 = u8Array [ idx ++ ] ; if ( ! u0 ) return str ; if ( ! ( u0 & 0x80 ) ) { str += String . fromCharCode ( u0 ) ; continue ; } u1 = u8Array [ idx ++ ] & 63 ; if ( ( u0 & 0xE0 ) == 0xC0 ) { str += String . fromCharCode ( ( ( u0 & 31 ) << 6 ) | u1 ) ; continue ; } u2 = u8Array [ idx ++ ] & 63 ; if ( ( u0 & 0xF0 ) == 0xE0 ) { u0 = ( ( u0 & 15 ) << 12 ) | ( u1 << 6 ) | u2 ; } else { u3 = u8Array [ idx ++ ] & 63 ; if ( ( u0 & 0xF8 ) == 0xF0 ) { u0 = ( ( u0 & 7 ) << 18 ) | ( u1 << 12 ) | ( u2 << 6 ) | u3 ; } else { u4 = u8Array [ idx ++ ] & 63 ; if ( ( u0 & 0xFC ) == 0xF8 ) { u0 = ( ( u0 & 3 ) << 24 ) | ( u1 << 18 ) | ( u2 << 12 ) | ( u3 << 6 ) | u4 ; } else { u5 = u8Array [ idx ++ ] & 63 ; u0 = ( ( u0 & 1 ) << 30 ) | ( u1 << 24 ) | ( u2 << 18 ) | ( u3 << 12 ) | ( u4 << 6 ) | u5 ; } } } if ( u0 < 0x10000 ) { str += String . fromCharCode ( u0 ) ; } else { var ch = u0 - 0x10000 ; str += String . fromCharCode ( 0xD800 | ( ch >> 10 ) , 0xDC00 | ( ch & 0x3FF ) ) ; } } } } // Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns // a copy of that string as a Javascript String object. function UTF8ToString ( ptr ) { return UTF8ArrayToString ( HEAPU8 , ptr ) ; } // Copies the given Javascript String object 'str' to the given byte array at address 'outIdx', // encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP. // Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write. // Parameters: //   str: the Javascript string to copy. //   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element. //   outIdx: The starting offset in the array to begin the copying. //   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null //                    terminator, i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else. //                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator. // Returns the number of bytes written, EXCLUDING the null terminator. function stringToUTF8Array ( str , outU8Array , outIdx , maxBytesToWrite ) { if ( ! ( maxBytesToWrite > 0 ) ) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes. return 0 ; var startIdx = outIdx ; var endIdx = outIdx + maxBytesToWrite - 1 ; // -1 for string null terminator. for ( var i = 0 ; i < str . length ; ++ i ) { // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8. // See http://unicode.org/faq/utf_bom.html#utf16-3 // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629 var u = str . charCodeAt ( i ) ; // possibly a lead surrogate if ( u >= 0xD800 && u <= 0xDFFF ) u = 0x10000 + ( ( u & 0x3FF ) << 10 ) | ( str . charCodeAt ( ++ i ) & 0x3FF ) ; if ( u <= 0x7F ) { if ( outIdx >= endIdx ) break ; outU8Array [ outIdx ++ ] = u ; } else if ( u <= 0x7FF ) { if ( outIdx + 1 >= endIdx ) break ; outU8Array [ outIdx ++ ] = 0xC0 | ( u >> 6 ) ; outU8Array [ outIdx ++ ] = 0x80 | ( u & 63 ) ; } else if ( u <= 0xFFFF ) { if ( outIdx + 2 >= endIdx ) break ; outU8Array [ outIdx ++ ] = 0xE0 | ( u >> 12 ) ; outU8Array [ outIdx ++ ] = 0x80 | ( ( u >> 6 ) & 63 ) ; outU8Array [ outIdx ++ ] = 0x80 | ( u & 63 ) ; } else if ( u <= 0x1FFFFF ) { if ( outIdx + 3 >= endIdx ) break ; outU8Array [ outIdx ++ ] = 0xF0 | ( u >> 18 ) ; outU8Array [ outIdx ++ ] = 0x80 | ( ( u >> 12 ) & 63 ) ; outU8Array [ outIdx ++ ] = 0x80 | ( ( u >> 6 ) & 63 ) ; outU8Array [ outIdx ++ ] = 0x80 | ( u & 63 ) ; } else if ( u <= 0x3FFFFFF ) { if ( outIdx + 4 >= endIdx ) break ; outU8Array [ outIdx ++ ] = 0xF8 | ( u >> 24 ) ; outU8Array [ outIdx ++ ] = 0x80 | ( ( u >> 18 ) & 63 ) ; outU8Array [ outIdx ++ ] = 0x80 | ( ( u >> 12 ) & 63 ) ; outU8Array [ outIdx ++ ] = 0x80 | ( ( u >> 6 ) & 63 ) ; outU8Array [ outIdx ++ ] = 0x80 | ( u & 63 ) ; } else { if ( outIdx + 5 >= endIdx ) break ; outU8Array [ outIdx ++ ] = 0xFC | ( u >> 30 ) ; outU8Array [ outIdx ++ ] = 0x80 | ( ( u >> 24 ) & 63 ) ; outU8Array [ outIdx ++ ] = 0x80 | ( ( u >> 18 ) & 63 ) ; outU8Array [ outIdx ++ ] = 0x80 | ( ( u >> 12 ) & 63 ) ; outU8Array [ outIdx ++ ] = 0x80 | ( ( u >> 6 ) & 63 ) ; outU8Array [ outIdx ++ ] = 0x80 | ( u & 63 ) ; } } // Null-terminate the pointer to the buffer. outU8Array [ outIdx ] = 0 ; return outIdx - startIdx ; } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr', // null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP. // Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write. // Returns the number of bytes written, EXCLUDING the null terminator. function stringToUTF8 ( str , outPtr , maxBytesToWrite ) { assert ( typeof maxBytesToWrite == 'number' , 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!' ) ; return stringToUTF8Array ( str , HEAPU8 , outPtr , maxBytesToWrite ) ; } // Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte. function lengthBytesUTF8 ( str ) { var len = 0 ; for ( var i = 0 ; i < str . length ; ++ i ) { // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8. // See http://unicode.org/faq/utf_bom.html#utf16-3 var u = str . charCodeAt ( i ) ; // possibly a lead surrogate if ( u >= 0xD800 && u <= 0xDFFF ) u = 0x10000 + ( ( u & 0x3FF ) << 10 ) | ( str . charCodeAt ( ++ i ) & 0x3FF ) ; if ( u <= 0x7F ) { ++ len ; } else if ( u <= 0x7FF ) { len += 2 ; } else if ( u <= 0xFFFF ) { len += 3 ; } else if ( u <= 0x1FFFFF ) { len += 4 ; } else if ( u <= 0x3FFFFFF ) { len += 5 ; } else { len += 6 ; } } return len ; } // Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns // a copy of that string as a Javascript String object. var UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder ( 'utf-16le' ) : undefined ; function UTF16ToString ( ptr ) { assert ( ptr % 2 == 0 , 'Pointer passed to UTF16ToString must be aligned to two bytes!' ) ; var endPtr = ptr ; // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself. // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage. var idx = endPtr >> 1 ; while ( HEAP16 [ idx ] ) ++ idx ; endPtr = idx << 1 ; if ( endPtr - ptr > 32 && UTF16Decoder ) { return UTF16Decoder . decode ( HEAPU8 . subarray ( ptr , endPtr ) ) ; } else { var i = 0 ; var str = '' ; while ( 1 ) { var codeUnit = HEAP16 [ ( ( ( ptr ) + ( i * 2 ) ) >> 1 ) ] ; if ( codeUnit == 0 ) return str ; ++ i ; // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through. str += String . fromCharCode ( codeUnit ) ; } } } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr', // null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP. // Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write. // Parameters: //   str: the Javascript string to copy. //   outPtr: Byte address in Emscripten HEAP where to write the string to. //   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null //                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else. //                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator. // Returns the number of bytes written, EXCLUDING the null terminator. function stringToUTF16 ( str , outPtr , maxBytesToWrite ) { assert ( outPtr % 2 == 0 , 'Pointer passed to stringToUTF16 must be aligned to two bytes!' ) ; assert ( typeof maxBytesToWrite == 'number' , 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!' ) ; // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed. if ( maxBytesToWrite === undefined ) { maxBytesToWrite = 0x7FFFFFFF ; } if ( maxBytesToWrite < 2 ) return 0 ; maxBytesToWrite -= 2 ; // Null terminator. var startPtr = outPtr ; var numCharsToWrite = ( maxBytesToWrite < str . length * 2 ) ? ( maxBytesToWrite / 2 ) : str . length ; for ( var i = 0 ; i < numCharsToWrite ; ++ i ) { // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP. var codeUnit = str . charCodeAt ( i ) ; // possibly a lead surrogate HEAP16 [ ( ( outPtr ) >> 1 ) ] = codeUnit ; outPtr += 2 ; } // Null-terminate the pointer to the HEAP. HEAP16 [ ( ( outPtr ) >> 1 ) ] = 0 ; return outPtr - startPtr ; } // Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte. function lengthBytesUTF16 ( str ) { return str . length * 2 ; } function UTF32ToString ( ptr ) { assert ( ptr % 4 == 0 , 'Pointer passed to UTF32ToString must be aligned to four bytes!' ) ; var i = 0 ; var str = '' ; while ( 1 ) { var utf32 = HEAP32 [ ( ( ( ptr ) + ( i * 4 ) ) >> 2 ) ] ; if ( utf32 == 0 ) return str ; ++ i ; // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing. // See http://unicode.org/faq/utf_bom.html#utf16-3 if ( utf32 >= 0x10000 ) { var ch = utf32 - 0x10000 ; str += String . fromCharCode ( 0xD800 | ( ch >> 10 ) , 0xDC00 | ( ch & 0x3FF ) ) ; } else { str += String . fromCharCode ( utf32 ) ; } } } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr', // null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP. // Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write. // Parameters: //   str: the Javascript string to copy. //   outPtr: Byte address in Emscripten HEAP where to write the string to. //   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null //                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else. //                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator. // Returns the number of bytes written, EXCLUDING the null terminator. function stringToUTF32 ( str , outPtr , maxBytesToWrite ) { assert ( outPtr % 4 == 0 , 'Pointer passed to stringToUTF32 must be aligned to four bytes!' ) ; assert ( typeof maxBytesToWrite == 'number' , 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!' ) ; // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed. if ( maxBytesToWrite === undefined ) { maxBytesToWrite = 0x7FFFFFFF ; } if ( maxBytesToWrite < 4 ) return 0 ; var startPtr = outPtr ; var endPtr = startPtr + maxBytesToWrite - 4 ; for ( var i = 0 ; i < str . length ; ++ i ) { // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap. // See http://unicode.org/faq/utf_bom.html#utf16-3 var codeUnit = str . charCodeAt ( i ) ; // possibly a lead surrogate if ( codeUnit >= 0xD800 && codeUnit <= 0xDFFF ) { var trailSurrogate = str . charCodeAt ( ++ i ) ; codeUnit = 0x10000 + ( ( codeUnit & 0x3FF ) << 10 ) | ( trailSurrogate & 0x3FF ) ; } HEAP32 [ ( ( outPtr ) >> 2 ) ] = codeUnit ; outPtr += 4 ; if ( outPtr + 4 > endPtr ) break ; } // Null-terminate the pointer to the HEAP. HEAP32 [ ( ( outPtr ) >> 2 ) ] = 0 ; return outPtr - startPtr ; } // Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte. function lengthBytesUTF32 ( str ) { var len = 0 ; for ( var i = 0 ; i < str . length ; ++ i ) { // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap. // See http://unicode.org/faq/utf_bom.html#utf16-3 var codeUnit = str . charCodeAt ( i ) ; if ( codeUnit >= 0xD800 && codeUnit <= 0xDFFF ) ++ i ; // possibly a lead surrogate, so skip over the tail surrogate. len += 4 ; } return len ; } // Allocate heap space for a JS string, and write it there. // It is the responsibility of the caller to free() that memory. function allocateUTF8 ( str ) { var size = lengthBytesUTF8 ( str ) + 1 ; var ret = _malloc ( size ) ; if ( ret ) stringToUTF8Array ( str , HEAP8 , ret , size ) ; return ret ; } // Allocate stack space for a JS string, and write it there. function allocateUTF8OnStack ( str ) { var size = lengthBytesUTF8 ( str ) + 1 ; var ret = stackAlloc ( size ) ; stringToUTF8Array ( str , HEAP8 , ret , size ) ; return ret ; } function demangle ( func ) { warnOnce ( 'warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling' ) ; return func ; } function demangleAll ( text ) { var regex = / __Z[\w\d_]+ / g ; return text . replace ( regex , function ( x ) { var y = demangle ( x ) ; return x === y ? x : ( x + ' [' + y + ']' ) ; } ) ; } function jsStackTrace ( ) { var err = new Error ( ) ; if ( ! err . stack ) { // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown, // so try that as a special-case. try { throw new Error ( 0 ) ; } catch ( e ) { err = e ; } if ( ! err . stack ) { return '(no stack trace available)' ; } } return err . stack . toString ( ) ; } function stackTrace ( ) { var js = jsStackTrace ( ) ; if ( Module [ 'extraStackTrace' ] ) js += '\n' + Module [ 'extraStackTrace' ] ( ) ; return demangleAll ( js ) ; } // Memory management var PAGE_SIZE = 16384 ; var WASM_PAGE_SIZE = 65536 ; var ASMJS_PAGE_SIZE = 16777216 ; var MIN_TOTAL_MEMORY = 16777216 ; function alignUp ( x , multiple ) { if ( x % multiple > 0 ) { x += multiple - ( x % multiple ) ; } return x ; } var HEAP , /** @type {ArrayBuffer} */ buffer , /** @type {Int8Array} */ HEAP8 , /** @type {Uint8Array} */ HEAPU8 , /** @type {Int16Array} */ HEAP16 , /** @type {Uint16Array} */ HEAPU16 , /** @type {Int32Array} */ HEAP32 , /** @type {Uint32Array} */ HEAPU32 , /** @type {Float32Array} */ HEAPF32 , /** @type {Float64Array} */ HEAPF64 ; function updateGlobalBuffer ( buf ) { Module [ 'buffer' ] = buffer = buf ; } function updateGlobalBufferViews ( ) { Module [ 'HEAP8' ] = HEAP8 = new Int8Array ( buffer ) ; Module [ 'HEAP16' ] = HEAP16 = new Int16Array ( buffer ) ; Module [ 'HEAP32' ] = HEAP32 = new Int32Array ( buffer ) ; Module [ 'HEAPU8' ] = HEAPU8 = new Uint8Array ( buffer ) ; Module [ 'HEAPU16' ] = HEAPU16 = new Uint16Array ( buffer ) ; Module [ 'HEAPU32' ] = HEAPU32 = new Uint32Array ( buffer ) ; Module [ 'HEAPF32' ] = HEAPF32 = new Float32Array ( buffer ) ; Module [ 'HEAPF64' ] = HEAPF64 = new Float64Array ( buffer ) ; } var STATIC_BASE , STATICTOP , staticSealed ; // static area var STACK_BASE , STACKTOP , STACK_MAX ; // stack area var DYNAMIC_BASE , DYNAMICTOP_PTR ; // dynamic area handled by sbrk STATIC_BASE = STATICTOP = STACK_BASE = STACKTOP = STACK_MAX = DYNAMIC_BASE = DYNAMICTOP_PTR = 0 ; staticSealed = false ; // Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode. function writeStackCookie ( ) { assert ( ( STACK_MAX & 3 ) == 0 ) ; HEAPU32 [ ( STACK_MAX >> 2 ) - 1 ] = 0x02135467 ; HEAPU32 [ ( STACK_MAX >> 2 ) - 2 ] = 0x89BACDFE ; } function checkStackCookie ( ) { if ( HEAPU32 [ ( STACK_MAX >> 2 ) - 1 ] != 0x02135467 || HEAPU32 [ ( STACK_MAX >> 2 ) - 2 ] != 0x89BACDFE ) { abort ( 'Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x02135467, but received 0x' + HEAPU32 [ ( STACK_MAX >> 2 ) - 2 ] . toString ( 16 ) + ' ' + HEAPU32 [ ( STACK_MAX >> 2 ) - 1 ] . toString ( 16 ) ) ; } // Also test the global address 0 for integrity. This check is not compatible with SAFE_SPLIT_MEMORY though, since that mode already tests all address 0 accesses on its own. if ( HEAP32 [ 0 ] !== 0x63736d65 /* 'emsc' */ ) throw 'Runtime error: The application has corrupted its heap memory area (address zero)!' ; } function abortStackOverflow ( allocSize ) { abort ( 'Stack overflow! Attempted to allocate ' + allocSize + ' bytes on the stack, but stack has only ' + ( STACK_MAX - stackSave ( ) + allocSize ) + ' bytes available!' ) ; } function abortOnCannotGrowMemory ( ) { abort ( 'Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + TOTAL_MEMORY + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime but prevents some optimizations, (3) set Module.TOTAL_MEMORY to a higher value before the program runs, or (4) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ' ) ; } function enlargeMemory ( ) { abortOnCannotGrowMemory ( ) ; } var TOTAL_STACK = Module [ 'TOTAL_STACK' ] || 5242880 ; var TOTAL_MEMORY = Module [ 'TOTAL_MEMORY' ] || 268435456 ; if ( TOTAL_MEMORY < TOTAL_STACK ) Module . printErr ( 'TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')' ) ; // Initialize the runtime's memory // check for full engine support (use string 'subarray' to avoid closure compiler confusion) assert ( typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && Int32Array . prototype . subarray !== undefined && Int32Array . prototype . set !== undefined , 'JS engine does not provide full typed array support' ) ; // Use a provided buffer, if there is one, or else allocate a new one if ( Module [ 'buffer' ] ) { buffer = Module [ 'buffer' ] ; assert ( buffer . byteLength === TOTAL_MEMORY , 'provided buffer should be ' + TOTAL_MEMORY + ' bytes, but it is ' + buffer . byteLength ) ; } else { // Use a WebAssembly memory where available { buffer = new ArrayBuffer ( TOTAL_MEMORY ) ; } assert ( buffer . byteLength === TOTAL_MEMORY ) ; Module [ 'buffer' ] = buffer ; } updateGlobalBufferViews ( ) ; function getTotalMemory ( ) { return TOTAL_MEMORY ; } // Endianness check (note: assumes compiler arch was little-endian) HEAP32 [ 0 ] = 0x63736d65 ; /* 'emsc' */ HEAP16 [ 1 ] = 0x6373 ; if ( HEAPU8 [ 2 ] !== 0x73 || HEAPU8 [ 3 ] !== 0x63 ) throw 'Runtime error: expected the system to be little-endian!' ; function callRuntimeCallbacks ( callbacks ) { while ( callbacks . length > 0 ) { var callback = callbacks . shift ( ) ; if ( typeof callback == 'function' ) { callback ( ) ; continue ; } var func = callback . func ; if ( typeof func === 'number' ) { if ( callback . arg === undefined ) { Module [ 'dynCall_v' ] ( func ) ; } else { Module [ 'dynCall_vi' ] ( func , callback . arg ) ; } } else { func ( callback . arg === undefined ? null : callback . arg ) ; } } } var __ATPRERUN__ = [ ] ; // functions called before the runtime is initialized var __ATINIT__ = [ ] ; // functions called during startup var __ATMAIN__ = [ ] ; // functions called when main() is to be run var __ATEXIT__ = [ ] ; // functions called during shutdown var __ATPOSTRUN__ = [ ] ; // functions called after the runtime has exited var runtimeInitialized = false ; var runtimeExited = false ; function preRun ( ) { // compatibility - merge in anything from Module['preRun'] at this time if ( Module [ 'preRun' ] ) { if ( typeof Module [ 'preRun' ] == 'function' ) Module [ 'preRun' ] = [ Module [ 'preRun' ] ] ; while ( Module [ 'preRun' ] . length ) { addOnPreRun ( Module [ 'preRun' ] . shift ( ) ) ; } } callRuntimeCallbacks ( __ATPRERUN__ ) ; } function ensureInitRuntime ( ) { checkStackCookie ( ) ; if ( runtimeInitialized ) return ; runtimeInitialized = true ; callRuntimeCallbacks ( __ATINIT__ ) ; } function preMain ( ) { checkStackCookie ( ) ; callRuntimeCallbacks ( __ATMAIN__ ) ; } function exitRuntime ( ) { checkStackCookie ( ) ; callRuntimeCallbacks ( __ATEXIT__ ) ; runtimeExited = true ; } function postRun ( ) { checkStackCookie ( ) ; // compatibility - merge in anything from Module['postRun'] at this time if ( Module [ 'postRun' ] ) { if ( typeof Module [ 'postRun' ] == 'function' ) Module [ 'postRun' ] = [ Module [ 'postRun' ] ] ; while ( Module [ 'postRun' ] . length ) { addOnPostRun ( Module [ 'postRun' ] . shift ( ) ) ; } } callRuntimeCallbacks ( __ATPOSTRUN__ ) ; } function addOnPreRun ( cb ) { __ATPRERUN__ . unshift ( cb ) ; } function addOnInit ( cb ) { __ATINIT__ . unshift ( cb ) ; } function addOnPreMain ( cb ) { __ATMAIN__ . unshift ( cb ) ; } function addOnExit ( cb ) { __ATEXIT__ . unshift ( cb ) ; } function addOnPostRun ( cb ) { __ATPOSTRUN__ . unshift ( cb ) ; } // Deprecated: This function should not be called because it is unsafe and does not provide // a maximum length limit of how many bytes it is allowed to write. Prefer calling the // function stringToUTF8Array() instead, which takes in a maximum length that can be used // to be secure from out of bounds writes. /** @deprecated */ function writeStringToMemory ( string , buffer , dontAddNull ) { warnOnce ( 'writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!' ) ; var /** @type {number} */ lastChar , /** @type {number} */ end ; if ( dontAddNull ) { // stringToUTF8Array always appends null. If we don't want to do that, remember the // character that existed at the location where the null will be placed, and restore // that after the write (below). end = buffer + lengthBytesUTF8 ( string ) ; lastChar = HEAP8 [ end ] ; } stringToUTF8 ( string , buffer , Infinity ) ; if ( dontAddNull ) HEAP8 [ end ] = lastChar ; // Restore the value under the null character. } function writeArrayToMemory ( array , buffer ) { assert ( array . length >= 0 , 'writeArrayToMemory array must have a length (should be an array or typed array)' ) HEAP8 . set ( array , buffer ) ; } function writeAsciiToMemory ( str , buffer , dontAddNull ) { for ( var i = 0 ; i < str . length ; ++ i ) { assert ( str . charCodeAt ( i ) === str . charCodeAt ( i ) & 0xff ) ; HEAP8 [ ( ( buffer ++ ) >> 0 ) ] = str . charCodeAt ( i ) ; } // Null-terminate the pointer to the HEAP. if ( ! dontAddNull ) HEAP8 [ ( ( buffer ) >> 0 ) ] = 0 ; } function unSign ( value , bits , ignore ) { if ( value >= 0 ) { return value ; } return bits <= 32 ? 2 * Math . abs ( 1 << ( bits - 1 ) ) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts : Math . pow ( 2 , bits ) + value ; } function reSign ( value , bits , ignore ) { if ( value <= 0 ) { return value ; } var half = bits <= 32 ? Math . abs ( 1 << ( bits - 1 ) ) // abs is needed if bits == 32 : Math . pow ( 2 , bits - 1 ) ; if ( value >= half && ( bits <= 32 || value > half ) ) { // for huge values, we can hit the precision limit and always get true here. so don't do that // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors // TODO: In i64 mode 1, resign the two parts separately and safely value = - 2 * half + value ; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts } return value ; } // check for imul support, and also for correctness ( https://bugs.webkit.org/show_bug.cgi?id=126345 ) if ( ! Math [ 'imul' ] || Math [ 'imul' ] ( 0xffffffff , 5 ) !== - 5 ) Math [ 'imul' ] = function imul ( a , b ) { var ah = a >>> 16 ; var al = a & 0xffff ; var bh = b >>> 16 ; var bl = b & 0xffff ; return ( al * bl + ( ( ah * bl + al * bh ) << 16 ) ) | 0 ; } ; Math . imul = Math [ 'imul' ] ; if ( ! Math [ 'clz32' ] ) Math [ 'clz32' ] = function ( x ) { x = x >>> 0 ; for ( var i = 0 ; i < 32 ; i ++ ) { if ( x & ( 1 << ( 31 - i ) ) ) return i ; } return 32 ; } ; Math . clz32 = Math [ 'clz32' ] if ( ! Math [ 'trunc' ] ) Math [ 'trunc' ] = function ( x ) { return x < 0 ? Math . ceil ( x ) : Math . floor ( x ) ; } ; Math . trunc = Math [ 'trunc' ] ; var Math_abs = Math . abs ; var Math_cos = Math . cos ; var Math_sin = Math . sin ; var Math_tan = Math . tan ; var Math_acos = Math . acos ; var Math_asin = Math . asin ; var Math_atan = Math . atan ; var Math_atan2 = Math . atan2 ; var Math_exp = Math . exp ; var Math_log = Math . log ; var Math_sqrt = Math . sqrt ; var Math_ceil = Math . ceil ; var Math_floor = Math . floor ; var Math_pow = Math . pow ; var Math_imul = Math . imul ; var Math_fround = Math . fround ; var Math_round = Math . round ; var Math_min = Math . min ; var Math_max = Math . max ; var Math_clz32 = Math . clz32 ; var Math_trunc = Math . trunc ; // A counter of dependencies for calling run(). If we need to // do asynchronous work before running, increment this and // decrement it. Incrementing must happen in a place like // PRE_RUN_ADDITIONS (used by emcc to add file preloading). // Note that you can add dependencies in preRun, even though // it happens right before run - run will be postponed until // the dependencies are met. var runDependencies = 0 ; var runDependencyWatcher = null ; var dependenciesFulfilled = null ; // overridden to take different actions when all run dependencies are fulfilled var runDependencyTracking = { } ; function getUniqueRunDependency ( id ) { var orig = id ; while ( 1 ) { if ( ! runDependencyTracking [ id ] ) return id ; id = orig + Math . random ( ) ; } return id ; } function addRunDependency ( id ) { runDependencies ++ ; if ( Module [ 'monitorRunDependencies' ] ) { Module [ 'monitorRunDependencies' ] ( runDependencies ) ; } if ( id ) { assert ( ! runDependencyTracking [ id ] ) ; runDependencyTracking [ id ] = 1 ; if ( runDependencyWatcher === null && typeof setInterval !== 'undefined' ) { // Check for missing dependencies every few seconds runDependencyWatcher = setInterval ( function ( ) { if ( ABORT ) { clearInterval ( runDependencyWatcher ) ; runDependencyWatcher = null ; return ; } var shown = false ; for ( var dep in runDependencyTracking ) { if ( ! shown ) { shown = true ; Module . printErr ( 'still waiting on run dependencies:' ) ; } Module . printErr ( 'dependency: ' + dep ) ; } if ( shown ) { Module . printErr ( '(end of list)' ) ; } } , 10000 ) ; } } else { Module . printErr ( 'warning: run dependency added without ID' ) ; } } function removeRunDependency ( id ) { runDependencies -- ; if ( Module [ 'monitorRunDependencies' ] ) { Module [ 'monitorRunDependencies' ] ( runDependencies ) ; } if ( id ) { assert ( runDependencyTracking [ id ] ) ; delete runDependencyTracking [ id ] ; } else { Module . printErr ( 'warning: run dependency removed without ID' ) ; } if ( runDependencies == 0 ) { if ( runDependencyWatcher !== null ) { clearInterval ( runDependencyWatcher ) ; runDependencyWatcher = null ; } if ( dependenciesFulfilled ) { var callback = dependenciesFulfilled ; dependenciesFulfilled = null ; callback ( ) ; // can add another dependenciesFulfilled } } } Module [ "preloadedImages" ] = { } ; // maps url to image data Module [ "preloadedAudios" ] = { } ; // maps url to audio data var memoryInitializer = null ; // Prefix of data URIs emitted by SINGLE_FILE and related options. var dataURIPrefix = 'data:application/octet-stream;base64,' ; // Indicates whether filename is a base64 data URI. function isDataURI ( filename ) { return String . prototype . startsWith ? filename . startsWith ( dataURIPrefix ) : filename . indexOf ( dataURIPrefix ) === 0 ; } // === Body === var ASM_CONSTS = [ ] ; STATIC_BASE = GLOBAL_BASE ; STATICTOP = STATIC_BASE + 101632 ; /* global initializers */ __ATINIT__ . push ( ) ; memoryInitializer = "data:application/octet-stream;base64,CAAAABAAAAAgAAAAQAAAAIAAAAD4AAAAyIcBAMiHAQDIhwEAyIcBAMiHAQDIhwEAyIcBAMiHAQBATgAAQk4AAEROAABHTgAAQE4AAEtOAABETgAAR04AAEBOAABCTgAARE4AAEROAABATgAAS04AAEROAABETgAAT04AAEJOAABETgAARE4AAE9OAABLTgAARE4AAEROAAABAAAAAAAAAAMAAAABAAAAAgAAAAAAAAAEAAAAAAAAAPtZAAD/WQAAA1oAAPtZAAD/WQAAA1oAAAdaAAC6WQAAylkAANtZAAC6WQAAylkAANtZAADrWQAAAQEBARAQEBARERERRERERFVVVVWqqqqqAwADAAADAAMDAwMDMDAwMDMzMzPMzMzMDwAAAAAADwAPAA8AAA8ADw8PDw/w8PDwgICAgAgICAiIiIiIIiIiIqqqqqpVVVVVwADAAADAAMDAwMDADAwMDMzMzMwzMzMz8AAAAAAA8ADwAPAAAPAA8PDw8PAPDw8P8PDw8MzMzMyqqqqqAP8A//Dw8PDMzMzMAAD//wD/AP/w8PDwDw8PDzMzMzNVVVVVAP8A/w8PDw8zMzMzAAD//wD/AP8PDw8PCAAAAAgAAAAEAAAABAAAAAIAAAACAAAAAQAAAAAAAACWMAd3LGEO7rpRCZkZxG0Hj/RqcDWlY+mjlWSeMojbDqS43Hke6dXgiNnSlytMtgm9fLF+By2455Edv5BkELcd8iCwakhxufPeQb6EfdTaGuvk3W1RtdT0x4XTg1aYbBPAqGtkevli/ezJZYpPXAEU2WwGY2M9D/r1DQiNyCBuO14QaUzkQWDVcnFnotHkAzxH1ARL/YUN0mu1CqX6qLU1bJiyQtbJu9tA+bys42zYMnVc30XPDdbcWT3Rq6ww2SY6AN5RgFHXyBZh0L+19LQhI8SzVpmVus8Ppb24nrgCKAiIBV+y2QzGJOkLsYd8by8RTGhYqx1hwT0tZraQQdx2BnHbAbwg0pgqENXviYWxcR+1tgal5L+fM9S46KLJB3g0+QAPjqgJlhiYDuG7DWp/LT1tCJdsZJEBXGPm9FFra2JhbBzYMGWFTgBi8u2VBmx7pQEbwfQIglfED/XG2bBlUOm3Euq4vot8iLn83x3dYkkt2hXzfNOMZUzU+1hhsk3OUbU6dAC8o+Iwu9RBpd9K15XYPW3E0aT79NbTaulpQ/zZbjRGiGet0Lhg2nMtBETlHQMzX0wKqsl8Dd08cQVQqkECJxAQC76GIAzJJbVoV7OFbyAJ1Ga5n+Rhzg753l6YydkpIpjQsLSo18cXPbNZgQ20LjtcvbetbLrAIIO47bazv5oM4rYDmtKxdDlH1eqvd9KdFSbbBIMW3HMSC2PjhDtklD5qbQ2oWmp6C88O5J3/CZMnrgAKsZ4HfUSTD/DSowiHaPIBHv7CBmldV2L3y2dlgHE2bBnnBmtudhvU/uAr04laetoQzErdZ2/fufn5776OQ763F9WOsGDoo9bWfpPRocTC2DhS8t9P8We70WdXvKbdBrU/SzaySNorDdhMGwqv9koDNmB6BEHD72DfVd9nqO+ObjF5vmlGjLNhyxqDZryg0m8lNuJoUpV3DMwDRwu7uRYCIi8mBVW+O7rFKAu9spJatCsEarNcp//XwjHP0LWLntksHa7eW7DCZJsm8mPsnKNqdQqTbQKpBgmcPzYO64VnB3ITVwAFgkq/lRR6uOKuK7F7OBu2DJuO0pINvtXlt+/cfCHf2wvU0tOGQuLU8fiz3Whug9ofzRa+gVsmufbhd7Bvd0e3GOZaCIhwag//yjsGZlwLARH/nmWPaa5i+NP/a2FFz2wWeOIKoO7SDddUgwROwrMDOWEmZ6f3FmDQTUdpSdt3bj5KatGu3FrW2WYL30DwO9g3U668qcWeu95/z7JH6f+1MBzyvb2KwrrKMJOzU6ajtCQFNtC6kwbXzSlX3lS/Z9kjLnpms7hKYcQCG2hdlCtvKje+C7ShjgzDG98FWo3vAi0AAAAAQTEbGYJiNjLDUy0rBMVsZEX0d32Gp1pWx5ZBTwiK2chJu8LRiujv+svZ9OMMT7WsTX6utY4tg57PHJiHURLCShAj2VPTcPR4kkHvYVXXri4U5rU317WYHJaEgwVZmBuCGKkAm9v6LbCayzapXV135hxsbP/fP0HUng5azaIkhJXjFZ+MIEayp2F3qb6m4ejx59Dz6CSD3sNlssXaqq5dXeufRkQozGtvaf1wdq5rMTnvWiogLAkHC204HBLzNkbfsgddxnFUcO0wZWv09/Mqu7bCMaJ1kRyJNKAHkPu8nxe6jYQOed6pJTjvsjz/efNzvkjoan0bxUE8Kt5YBU958ER+YumHLU/CxhxU2wGKFZRAuw6Ng+gjpsLZOL8NxaA4TPS7IY+nlgrOlo0TCQDMXEgx10WLYvpuylPhd1Rdu7oVbKCj1j+NiJcOlpFQmNfeEanMx9L64eyTy/r1XNdich3meWvetVRAn4RPWVgSDhYZIxUP2nA4JJtBIz2na/1l5lrmfCUJy1dkONBOo66RAeKfihghzKczYP28Kq/hJK3u0D+0LYMSn2yyCYarJEjJ6hVT0ClGfvtod2Xi9nk/L7dIJDZ0GwkdNSoSBPK8U0uzjUhScN5leTHvfmD+8+bnv8L9/nyR0NU9oMvM+jaKg7sHkZp4VLyxOWWnqEuYgzsKqZgiyfq1CYjLrhBPXe9fDmz0Rs0/2W2MDsJ0QxJa8wIjQerBcGzBgEF32EfXNpcG5i2OxbUApYSEG7waikFxW7taaJjod0PZ2WxaHk8tFV9+NgycLRsn3RwAPhIAmLlTMYOgkGKui9FTtZIWxfTdV/TvxJSnwu/Vltn26bwHrqiNHLdr3jGcKu8qhe15a8qsSHDTbxtd+C4qRuHhNt5moAfFf2NU6FQiZfNN5fOyAqTCqRtnkYQwJqCfKbiuxeT5n979Oszz1nv96M+8a6mA/VqymT4Jn7J/OISrsCQcLPEVBzUyRioec3cxB7ThcEj10GtRNoNGeneyXWNO1/rLD+bh0sy1zPmNhNfgShKWrwsjjbbIcKCdiUG7hEZdIwMHbDgaxD8VMYUODihCmE9nA6lUfsD6eVWBy2JMH8U4gV70I5idpw6z3JYVqhsAVOVaMU/8mWJi19hTec4XT+FJVn76UJUt13vUHMxiE4qNLVK7ljSR6Lsf0NmgBuzzfl6twmVHbpFIbC+gU3XoNhI6qQcJI2pUJAgrZT8R5HmnlqVIvI9mG5GkJyqKveC8y/KhjdDrYt79wCPv5tm94bwU/NCnDT+DiiZ+spE/uSTQcPgVy2k7RuZCenf9W7VrZdz0Wn7FNwlT7nY4SPexrgm48J8SoTPMP4py/SSTAAAAADdqwgFu1IQDWb5GAtyoCQfrwssGsnyNBIUWTwW4URMOjzvRD9aFlw3h71UMZPkaCVOT2AgKLZ4KPUdcC3CjJhxHyeQdHneiHykdYB6sCy8bm2HtGsLfqxj1tWkZyPI1Ev+Y9xOmJrERkUxzEBRaPBUjMP4Ueo64Fk3kehfgRk041yyPOY6SyTu5+As6PO5EPwuEhj5SOsA8ZVACPVgXXjZvfZw3NsPaNQGpGDSEv1cxs9WVMOpr0zLdAREzkOVrJKePqSX+Me8nyVstJkxNYiN7J6AiIpnmIBXzJCEotHgqH966K0Zg/ClxCj4o9BxxLcN2syyayPUuraI3L8CNmnD351hxrlkec5kz3HIcJZN3K09RdnLxF3RFm9V1eNyJfk+2S38WCA19IWLPfKR0gHmTHkJ4yqAEev3KxnuwLrxsh0R+bd76OG/pkPpubIa1a1vsd2oCUjFoNTjzaQh/r2I/FW1jZqsrYVHB6WDU16Zl471kZLoDImaNaeBnIMvXSBehFUlOH1NLeXWRSvxj3k/LCRxOkrdaTKXdmE2YmsRGr/AGR/ZOQEXBJIJERDLNQXNYD0Aq5klCHYyLQ1Bo8VRnAjNVPrx1VwnWt1aMwPhTu6o6UuIUfFDVfr5R6DniWt9TIFuG7WZZsYekWDSR610D+ylcWkVvXm0vrV+AGzXht3H34O7PseLZpXPjXLM85mvZ/ucyZ7jlBQ165DhKJu8PIOTuVp6i7GH0YO3k4i/o04jt6Yo2q+u9XGnq8LgT/cfS0fyebJf+qQZV/ywQGvobetj7QsSe+XWuXPhI6QDzf4PC8iY9hPARV0bxlEEJ9KMry/X6lY33zf9P9mBdeNlXN7rYDon82jnjPtu89XHei5+z39Ih9d3lSzfc2Axr1+9mqda22O/UgbIt1QSkYtAzzqDRanDm010aJNIQ/l7FJ5ScxH4q2sZJQBjHzFZXwvs8lcOigtPBlegRwKivTcufxY/KxnvJyPERC8l0B0TMQ22GzRrTwM8tuQLOQJavkXf8bZAuQiuSGSjpk5w+pparVGSX8uoilcWA4JT4x7yfz61+npYTOJyhefqdJG+1mBMFd5lKuzGbfdHzmjA1iY0HX0uMXuENjmmLz4/snYCK2/dCi4JJBIm1I8aIiGSag78OWILmsB6A0drcgVTMk4RjplGFOhgXhw1y1Yag0OKpl7ogqM4EZqr5bqSrfHjrrksSKa8SrG+tJcatrBiB8acv6zOmdlV1pEE/t6XEKfig80M6oar9fKOdl76i0HPEtecZBrS+p0C2ic2CtwzbzbI7sQ+zYg9JsVVli7BoIte7X0gVugb2U7gxnJG5tIrevIPgHL3aXlq/7TSYvgAAAABlZ7y4i8gJqu6vtRJXl2KPMvDeN9xfayW5ONed7yi0xYpPCH1k4L1vAYcB17i/1krd2GryM3ff4FYQY1ifVxlQ+jCl6BSfEPpx+KxCyMB7362nx2dDCHJ1Jm/OzXB/rZUVGBEt+7ekP57QGIcn6M8aQo9zoqwgxrDJR3oIPq8yoFvIjhi1ZzsK0ACHsmk4UC8MX+yX4vBZhYeX5T3Rh4ZltOA63VpPj88/KDN3hhDk6uN3WFIN2O1AaL9R+KH4K/DEn5dIKjAiWk9XnuL2b0l/kwj1x32nQNUYwPxtTtCfNSu3I43FGJafoH8qJxlH/bp8IEECko/0EPfoSKg9WBSbWD+oI7aQHTHT96GJas92FA+oyqzhB3++hGDDBtJwoF63FxzmWbip9DzfFUyF58LR4IB+aQ4vy3trSHfDog8Ny8dosXMpxwRhTKC42fWYb0SQ/9P8flBm7hs32lZNJ7kOKEAFtsbvsKSjiAwcGrDbgX/XZzmReNIr9B9ukwP3JjtmkJqDiD8vke1YkylUYES0MQf4DN+oTR66z/Gm7N+S/om4LkZnF5tUAnAn7LtI8HHeL0zJMID521XnRWOcoD9r+ceD0xdoNsFyD4p5yzdd5K5Q4VxA/1ROJZjo9nOIi64W7zcW+ECCBJ0nPrwkH+khQXhVma/X4IvKsFwzO7ZZ7V7R5VWwflBH1Rns/2whO2IJRofa5+kyyIKOjnDUnu0osflRkF9W5II6MVg6gwmPp+ZuMx8IwYYNbaY6taThQL3BhvwFLylJF0pO9a/zdiIylhGeini+K5gd2ZcgS8n0eC6uSMDAAf3SpWZBahxelvd5OSpPl5afXfLxI+UFGWtNYH7X9Y7RYufrtt5fUo4JwjfptXrZRgBovCG80Oox34iPVmMwYfnWIgSeapq9pr0H2MEBvzZutK1TCQgVmk5yHf8pzqURhnu3dOHHD83ZEJKovqwqRhEZOCN2pYB1ZsbYEAF6YP6uz3KbyXPKIvGkV0eWGO+pOa39zF4RRQbuTXZjifHOjSZE3OhB+GRReS/5NB6TQdqxJlO/1prr6cb5s4yhRQtiDvAZB2lMob5RmzzbNieENZmSllD+Li6ZuVQm/N7onhJxXYx3FuE0zi42qatJihFF5j8DIIGDu3aR4OMT9lxb/VnpSZg+VfEhBoJsRGE+1KrOi8bPqTd+OEF/1l0mw26ziXZ81u7KxG/WHVkKsaHh5B4U84F5qEvXacsTsg53q1yhwrk5xn4BgP6pnOWZFSQLNqA2blEcjqcWZobCcdo+LN5vLEm505TwgQQJlea4sXtJDaMeLrEbSD7SQy1ZbvvD9tvpppFnUR+psMx6zgx0lGG5ZvEGBd4AAAAAdwcwlu4OYSyZCVG6B23EGXBq9I/pY6U1nmSVow7biDJ53Lik4NXpHpfS2YgJtkwrfrF8vee4LQeQvx2RHbcQZGqwIPLzuXFIhL5B3hra1H1t3eTr9NS1UYPThccTbJhWZGuowP1i+XqKZcnsFAFcT2MGbNn6Dz1jjQgN9TtuIMhMaRBe1WBB5KJncXI8A+TRSwTUR9INhf2lCrVrNbWo+kKymGzbu8nWrLz5QDLYbONF31x13NYNz6vRPVkm2TCsUd4AOsjXUYC/0GEWIbT0tVazxCPPupWZuL2lDygCuJ5fBYgIxgzZsrEL6SQvb3yHWGhMEcFhHau2Zi09dtxBkAHbcQaY0iC879UQKnGxhYkGtrUfn7/kpei41DN4B8miDwD5NJYJqI7hDpgYf2oNuwhtPS2RZGyX5mNcAWtrUfQcbGFihWUw2PJiAE5sBpXtGwGle4II9MH1D8RXZbDZxhK36VCLvrjq/LmIfGLdHd8V2i1JjNN88/vUTGVNsmFYOrVRzqO8AHTUuzDiSt+lQT3Yldek0cRt09b0+0Np6Wo0btn8rWeIRtpguNBEBC1zMwMd5aoKTF/dDXzJUAVxPCcCQaq+CxAQyQwghldotSUgb4WzuWbUCc5h5J9e3vkOKdnJmLDQmCLH16i0WbM9Fy60DYG3vVw7wLpsre24gyCav7O2A7biDHSx0prq1Uc5ndJ3rwTbJhVz3BaD42MLEpRkO4QNbWo+empaqOQOzwuTCf+dCgCuJ30HnrHwD5NEhwij0h4B8mhpBsL+92JXXYBlZ8sZbDZxbmsG5/7UG3aJ0yvgENp6WmfdSsz5ud9vjr7v+Re3vkNgsI7V1taj6KHRk3442MLET9/yUtG7Z/GmvFdnP7UG3UiyNkvYDSvarwobTDYDSvZBBHpg32Dvw6hn31Uxbo7vRmm+ecths4y8ZoMaJW/SoFJo4jbMDHeVuwtHAyICFrlVBSYvxbo7vrK9CygrtFqSXLNqBMLX/6e10M8xLNmei1verh2bZMKw7GPyJnVqo5wCbZMKnAkGqesONj9yB2eFBQBXE5W/SoLiuHoUe7Errgy2GziS0o6b5dW+DXzc77cL298hhtPS1PHU4kJo3bP4H9qDboG+Fs32uSZbb7B34Ri3R3eICFrm/w9qcGYGO8oRAQtcj2We//hirmlha//TFmzPRaAK4njXDdLuTgSDVDkDs8KnZyZh0GAW90lpR00+bnfbrtFqStnWWtxA3wtmN9g78Km8rlPeu57FR7LPfzC1/+m9vfIcyrrCilOzkzAktKOmutA2Bc3XBpNU3lcpI9lnv7Nmei7EYUq4XWgbAipvK5S0C743wwyOoVoF3xstAu+NAAAAABkbMUEyNmKCKy1Tw2RsxQR9d/RFVlqnhk9BlsfI2YoI0cK7Sfrv6Irj9NnLrLVPDLWufk2egy2Oh5gcz0rCElFT2SMQePRw02HvQZIurtdVN7XmFByYtdcFg4SWghuYWZsAqRiwLfrbqTbLmuZ3XV3/bGwc1EE/381aDp6VhCSijJ8V46eyRiC+qXdh8ejhpujz0OfD3oMk2sWyZV1drqpERp/rb2vMKHZw/Wk5MWuuICpa7wsHCSwSHDht30Y288ZdB7LtcFRx9GtlMLsq8/eiMcK2iRyRdZAHoDQXn7z7DoSNuiWp3nk8su84c/N5/2roSL5BxRt9WN4qPPB5TwXpYn5Ewk8th9tUHMaUFYoBjQ67QKYj6IO/ONnCOKDFDSG79EwKlqePE42WzlzMAAlF1zFIbvpii3fhU8q6u11Uo6BsFYiNP9aRlg6X3teYUMfMqRHs4frS9frLk3Ji11xreeYdQFS13llPhJ8WDhJYDxUjGSQ4cNo9I0GbZf1rp3zmWuZXywklTtA4ZAGRrqMYip/iM6fMISq8/WCtJOGvtD/Q7p8Sgy2GCbJsyUgkq9BTFer7fkYp4mV3aC8/efY2JEi3HQkbdAQSKjVLU7zyUkiNs3ll3nBgfu8x5+bz/v79wr/V0JF8zMugPYOKNvqakQe7sbxUeKinZTk7g5hLIpipCgm1+skQrsuIX+9dT0b0bA5t2T/NdMIOjPNaEkPqQSMCwWxwwdh3QYCXNtdHji3mBqUAtcW8G4SEcUGKGmhau1tDd+iYWmzZ2RUtTx4MNn5fJxstnD4AHN25mAASoIMxU4uuYpCStVPR3fTFFsTv9FfvwqeU9tmW1a4HvOm3HI2onDHea4Uq7yrKa3nt03BIrPhdG2/hRiouZt424X/FB6BU6FRjTfNlIgKy8+UbqcKkMISRZymfoCbkxa64/d6f+dbzzDrP6P17gKlrvJmyWv2ynwk+q4Q4fywcJLA1BxXxHipGMgcxd3NIcOG0UWvQ9XpGgzZjXbJ3y/rXTtLh5g/5zLXM4NeEja+WEkq2jSMLnaBwyIS7QYkDI11GGjhsBzEVP8QoDg6FZ0+YQn5UqQNVefrATGLLgYE4xR+YI/Resw6nnaoVltzlVAAb/E8xWtdiYpnOeVPYSeFPF1D6flZ71y2VYswc1C2NihM0lrtSH7vokQag2dBefvPsR2XCrWxIkW51U6AvOhI26CMJB6kIJFRqET9lK5aneeSPvEilpJEbZr2KKifyy7zg69CNocD93mLZ5u8jFLzhvQ2n0PwmioM/P5GyfnDQJLlpyxX4QuZGO1v9d3rcZWu1xX5a9O5TCTf3SDh2uAmusaESn/CKP8wzkyT9cgAAAAABwmo3A4TUbgJGvlkHCajcBsvC6wSNfLIFTxaFDhNRuA/RO48Nl4XWDFXv4Qka+WQI2JNTCp4tCgtcRz0cJqNwHeTJRx+idx4eYB0pGy8LrBrtYZsYq9/CGWm19RI18sgT95j/EbEmphBzTJEVPFoUFP4wIxa4jnoXeuRNOE1G4DmPLNc7yZKOOgv4uT9E7jw+hoQLPMA6Uj0CUGU2XhdYN5x9bzXawzY0GKkBMVe/hDCV1bMy02vqMxEB3SRr5ZAlqY+nJ+8x/iYtW8kjYk1MIqAneyDmmSIhJPMVKni0KCu63h8p/GBGKD4KcS1xHPQss3bDLvXImi83oq1wmo3AcVjn93MeWa5y3DOZd5MlHHZRTyt0F/FyddWbRX6J3Hh/S7ZPfQ0IFnzPYiF5gHSkeEIek3oEoMp7xsr9bLwusG1+RIdvOPrebvqQ6Wu1hmxqd+xbaDFSAmnzODVir38IY20VP2Erq2Zg6cFRZabX1GRkveNmIgO6Z+BpjUjXyyBJFaEXS1MfTkqRdXlP3mP8ThwJy0xat5JNmN2lRsSamEcG8K9FQE72RIIkwUHNMkRAD1hzQknmKkOLjB1U8WhQVTMCZ1d1vD5Wt9YJU/jAjFI6qrtQfBTiUb5+1VriOehbIFPfWWbthlikh7Fd65E0XCn7A15vRVpfrS9t4TUbgOD3cbfisc/u43Ol2eY8s1zn/tlr5bhnMuR6DQXvJko47uQgD+yinlbtYPRh6C/i5OntiNPrqzaK6mlcvf0TuPD80dLH/pdsnv9VBqn6GhAs+9h6G/mexEL4XK518wDpSPLCg3/whD0m8UZXEfQJQZT1yyuj942V+vZP/83ZeF1g2Lo3V9r8iQ7bPuM53nH1vN+zn4vd9SHS3DdL5ddrDNjWqWbv1O/YttUtsoHQYqQE0aDOM9PmcGrSJBpdxV7+EMSclCfG2ip+xxhAScJXVszDlTz7wdOCosAR6JXLTa+oyo/Fn8jJe8bJCxHxzEQHdM2GbUPPwNMazgK5LZGvlkCQbfx3kitCLpPpKBmWpj6cl2RUq5Ui6vKU4IDFn7zH+J5+rc+cOBOWnfp5oZi1bySZdwUTmzG7Sprz0X2NiTUwjEtfB44N4V6Pz4tpioCd7ItC99uJBEmCiMYjtYOaZIiCWA6/gB6w5oHc2tGEk8xUhVGmY4cXGDqG1XINqeLQoKggupeqZgTOq6Ru+a7reHyvKRJLrW+sEqytxiWn8YEYpjPrL6R1VXaltz9BoPgpxKE6Q/OjfP2qor6XnbXEc9C0BhnntkCnvreCzYmyzdsMsw+xO7FJD2Kwi2VVu9ciaLoVSF+4U/YGuZGcMbzeirS9HOCDv1pe2r6YNO0AAAAAuLxnZaoJyIsSta/uj2KXVzfe8DIla1/cndc4ucW0KO99CE+Kb73gZNcBhwFK1r+48mrY3eDfdzNYYxBWUBlXn+ilMPr6EJ8UQqz4cd97wMhnx6etdXIIQ83ObyaVrX9wLREYFT+kt/uHGNCeGs/oJ6Jzj0KwxiCsCHpHyaAyrz4YjshbCjtntbKHANAvUDhpl+xfDIVZ8OI95ZeHZYaH0d064LTPj09adzMoP+rkEIZSWHfjQO3YDfhRv2jwK/ihSJefxFoiMCrinldPf0lv9sf1CJPVQKd9bfzAGDWf0E6NI7crn5YYxScqf6C6/UcZAkEgfBD0j5KoSOj3mxRYPSOoP1gxHZC2iaH30xR2z2qsyqgPvn8H4QbDYIReoHDS5hwXt/SpuFlMFd880cLnhWl+gOB7yy8Ow3dIa8sND6JzsWjHYQTHKdm4oExEb5j1/NP/kO5mUH5W2jcbDrknTbYFQCiksO/GHAyIo4HbsBo5Z9d/K9J4kZNuH/Q7JvcDg5qQZpEvP4gpk1jttERgVAz4BzEeTajfpvHPuv6S3+xGLriJVJsXZ+wncAJx8Ei7yUwv3tv5gDBjRedVaz+gnNODx/nBNmgXeYoPcuRdN8tc4VCuTlT/QPbomCWui4hzFjfvFgSCQPi8PiedIekfJJlVeEGL4NevM1ywyu1ZtjtV5dFeR1B+sP/sGdViOyFs2odGCcgy6edwjo6CKO2e1JBR+bGC5FZfOlgxOqePCYMfM27mDYbBCLU6pm29QOGkBfyGwRdJKS+v9U5KMiJ284qeEZaYK754IJfZHXj0yUvASK4u0v0BwGpBZqX3ll4cTyo5eV2flpflI/HyTWsZBfXXfmDnYtGOX96268IJjlJ6tek3aABG2dC8IbyI3zHqMGNWjyLW+WGaap4EB72mvb8BwdittG42FQgJUx1yTpqlzin/t3uGEQ/H4XSSENnNKqy+qDgZEUaApXYj2MZmdWB6ARByz67+ynPJm1ek8SLvGJZH/a05qUURXsx2Te4GzvGJY9xEJo1k+EHo+S95UUGTHjRTJrHa65rWv7P5xukLRaGMGfAOYqFMaQc8m1G+hCc225aSmTUuLv5QJlS5mZ7o3vyMXXESNOEWd6k2Ls4RikmrAz/mRbuDgSDj4JF2W1z2E0npWf3xVT6YbIIGIdQ+YUTGi86qfjepz9Z/QThuwyZdfHaJs8TK7tZZHdZv4aGxCvMUHuRLqHmBE8tp16t3DrK5wqFcAX7GOZyp/oAkFZnlNqA2C44cUW6GZhanPtpxwixv3iyU07lJCQSB8LG45pWjDUl7G7EuHkPSPkj7blkt6dv2w1FnkabMsKkfdAzOema5YZTeBQbxAAAAAAAAAAABAAAABAAEAAgABAACAAAABAAFABAACAACAAAABAAGACAAIAACAAAABAAEABAAEAADAAAACAAQACAAIAADAAAACAAQAIAAgAADAAAACAAgAIAAAAEDAAAAIACAAAIBAAQDAAAAIAACAQIBABADAAAAgjEAAGQjAAABAQAAHgEAAA8AAAAKMQAA7CIAAAAAAAAeAAAADwAAAAAAAACgIgAAAAAAABMAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAADAAAABwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAQAAAAIAAAACAAAAAwAAAAMAAAAEAAAABAAAAAUAAAAFAAAABgAAAAYAAAAHAAAABwAAAAgAAAAIAAAACQAAAAkAAAAKAAAACgAAAAsAAAALAAAADAAAAAwAAAANAAAADQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAEAAAABAAAAAQAAAAIAAAACAAAAAgAAAAIAAAADAAAAAwAAAAMAAAADAAAABAAAAAQAAAAEAAAABAAAAAUAAAAFAAAABQAAAAUAAAAAAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAFAAAABgAAAAcAAAAIAAAACgAAAAwAAAAOAAAAEAAAABQAAAAYAAAAHAAAACAAAAAoAAAAMAAAADgAAABAAAAAUAAAAGAAAABwAAAAgAAAAKAAAADAAAAA4AAAAAAAAAAAAAAAAQAAAAIAAAADAAAABAAAAAYAAAAIAAAADAAAABAAAAAYAAAAIAAAADAAAABAAAAAYAAAAIAAAADAAAAAAAEAAIABAAAAAgAAAAMAAAAEAAAABgAAAAgAAAAMAAAAEAAAABgAAAAgAAAAMAAAAEAAAABgAABrcwAAe3MAAMiHAQCGcwAAkXMAAJ5zAACpcwAAvXMAAMpzAADIhwEABAAAAAUAAAD4JAAABQAAAAAAAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAgAAADpiAEAAAQAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAACv////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPgkAAB8JQAABQAAAAAAAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQAAAAgAAADxjAEAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAA//////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlAcBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAARABIAAAAIAAcACQAGAAoABQALAAQADAADAA0AAgAOAAEADwBgBwAAAAhQAAAIEAAUCHMAEgcfAAAIcAAACDAAAAnAABAHCgAACGAAAAggAAAJoAAACAAAAAiAAAAIQAAACeAAEAcGAAAIWAAACBgAAAmQABMHOwAACHgAAAg4AAAJ0AARBxEAAAhoAAAIKAAACbAAAAgIAAAIiAAACEgAAAnwABAHBAAACFQAAAgUABUI4wATBysAAAh0AAAINAAACcgAEQcNAAAIZAAACCQAAAmoAAAIBAAACIQAAAhEAAAJ6AAQBwgAAAhcAAAIHAAACZgAFAdTAAAIfAAACDwAAAnYABIHFwAACGwAAAgsAAAJuAAACAwAAAiMAAAITAAACfgAEAcDAAAIUgAACBIAFQijABMHIwAACHIAAAgyAAAJxAARBwsAAAhiAAAIIgAACaQAAAgCAAAIggAACEIAAAnkABAHBwAACFoAAAgaAAAJlAAUB0MAAAh6AAAIOgAACdQAEgcTAAAIagAACCoAAAm0AAAICgAACIoAAAhKAAAJ9AAQBwUAAAhWAAAIFgBACAAAEwczAAAIdgAACDYAAAnMABEHDwAACGYAAAgmAAAJrAAACAYAAAiGAAAIRgAACewAEAcJAAAIXgAACB4AAAmcABQHYwAACH4AAAg+AAAJ3AASBxsAAAhuAAAILgAACbwAAAgOAAAIjgAACE4AAAn8AGAHAAAACFEAAAgRABUIgwASBx8AAAhxAAAIMQAACcIAEAcKAAAIYQAACCEAAAmiAAAIAQAACIEAAAhBAAAJ4gAQBwYAAAhZAAAIGQAACZIAEwc7AAAIeQAACDkAAAnSABEHEQAACGkAAAgpAAAJsgAACAkAAAiJAAAISQAACfIAEAcEAAAIVQAACBUAEAgCARMHKwAACHUAAAg1AAAJygARBw0AAAhlAAAIJQAACaoAAAgFAAAIhQAACEUAAAnqABAHCAAACF0AAAgdAAAJmgAUB1MAAAh9AAAIPQAACdoAEgcXAAAIbQAACC0AAAm6AAAIDQAACI0AAAhNAAAJ+gAQBwMAAAhTAAAIEwAVCMMAEwcjAAAIcwAACDMAAAnGABEHCwAACGMAAAgjAAAJpgAACAMAAAiDAAAIQwAACeYAEAcHAAAIWwAACBsAAAmWABQHQwAACHsAAAg7AAAJ1gASBxMAAAhrAAAIKwAACbYAAAgLAAAIiwAACEsAAAn2ABAHBQAACFcAAAgXAEAIAAATBzMAAAh3AAAINwAACc4AEQcPAAAIZwAACCcAAAmuAAAIBwAACIcAAAhHAAAJ7gAQBwkAAAhfAAAIHwAACZ4AFAdjAAAIfwAACD8AAAneABIHGwAACG8AAAgvAAAJvgAACA8AAAiPAAAITwAACf4AYAcAAAAIUAAACBAAFAhzABIHHwAACHAAAAgwAAAJwQAQBwoAAAhgAAAIIAAACaEAAAgAAAAIgAAACEAAAAnhABAHBgAACFgAAAgYAAAJkQATBzsAAAh4AAAIOAAACdEAEQcRAAAIaAAACCgAAAmxAAAICAAACIgAAAhIAAAJ8QAQBwQAAAhUAAAIFAAVCOMAEwcrAAAIdAAACDQAAAnJABEHDQAACGQAAAgkAAAJqQAACAQAAAiEAAAIRAAACekAEAcIAAAIXAAACBwAAAmZABQHUwAACHwAAAg8AAAJ2QASBxcAAAhsAAAILAAACbkAAAgMAAAIjAAACEwAAAn5ABAHAwAACFIAAAgSABUIowATByMAAAhyAAAIMgAACcUAEQcLAAAIYgAACCIAAAmlAAAIAgAACIIAAAhCAAAJ5QAQBwcAAAhaAAAIGgAACZUAFAdDAAAIegAACDoAAAnVABIHEwAACGoAAAgqAAAJtQAACAoAAAiKAAAISgAACfUAEAcFAAAIVgAACBYAQAgAABMHMwAACHYAAAg2AAAJzQARBw8AAAhmAAAIJgAACa0AAAgGAAAIhgAACEYAAAntABAHCQAACF4AAAgeAAAJnQAUB2MAAAh+AAAIPgAACd0AEgcbAAAIbgAACC4AAAm9AAAIDgAACI4AAAhOAAAJ/QBgBwAAAAhRAAAIEQAVCIMAEgcfAAAIcQAACDEAAAnDABAHCgAACGEAAAghAAAJowAACAEAAAiBAAAIQQAACeMAEAcGAAAIWQAACBkAAAmTABMHOwAACHkAAAg5AAAJ0wARBxEAAAhpAAAIKQAACbMAAAgJAAAIiQAACEkAAAnzABAHBAAACFUAAAgVABAIAgETBysAAAh1AAAINQAACcsAEQcNAAAIZQAACCUAAAmrAAAIBQAACIUAAAhFAAAJ6wAQBwgAAAhdAAAIHQAACZsAFAdTAAAIfQAACD0AAAnbABIHFwAACG0AAAgtAAAJuwAACA0AAAiNAAAITQAACfsAEAcDAAAIUwAACBMAFQjDABMHIwAACHMAAAgzAAAJxwARBwsAAAhjAAAIIwAACacAAAgDAAAIgwAACEMAAAnnABAHBwAACFsAAAgbAAAJlwAUB0MAAAh7AAAIOwAACdcAEgcTAAAIawAACCsAAAm3AAAICwAACIsAAAhLAAAJ9wAQBwUAAAhXAAAIFwBACAAAEwczAAAIdwAACDcAAAnPABEHDwAACGcAAAgnAAAJrwAACAcAAAiHAAAIRwAACe8AEAcJAAAIXwAACB8AAAmfABQHYwAACH8AAAg/AAAJ3wASBxsAAAhvAAAILwAACb8AAAgPAAAIjwAACE8AAAn/ABAFAQAXBQEBEwURABsFARARBQUAGQUBBBUFQQAdBQFAEAUDABgFAQIUBSEAHAUBIBIFCQAaBQEIFgWBAEAFAAAQBQIAFwWBARMFGQAbBQEYEQUHABkFAQYVBWEAHQUBYBAFBAAYBQEDFAUxABwFATASBQ0AGgUBDBYFwQBABQAAAwAEAAUABgAHAAgACQAKAAsADQAPABEAEwAXABsAHwAjACsAMwA7AEMAUwBjAHMAgwCjAMMA4wACAQAAAAAQABAAEAAQABAAEAAQABAAEQARABEAEQASABIAEgASABMAEwATABMAFAAUABQAFAAVABUAFQAVABAATQDKAAEAAgADAAQABQAHAAkADQARABkAIQAxAEEAYQCBAMEAAQGBAQECAQMBBAEGAQgBDAEQARgBIAEwAUABYAAAAAAQABAAEAAQABEAEQASABIAEwATABQAFAAVABUAFgAWABcAFwAYABgAGQAZABoAGgAbABsAHAAcAB0AHQBAAEAAAAAFABAABQAIAAUAGAAFAAQABQAUAAUADAAFABwABQACAAUAEgAFAAoABQAaAAUABgAFABYABQAOAAUAHgAFAAEABQARAAUACQAFABkABQAFAAUAFQAFAA0ABQAdAAUAAwAFABMABQALAAUAGwAFAAcABQAXAAUADAAIAIwACABMAAgAzAAIACwACACsAAgAbAAIAOwACAAcAAgAnAAIAFwACADcAAgAPAAIALwACAB8AAgA/AAIAAIACACCAAgAQgAIAMIACAAiAAgAogAIAGIACADiAAgAEgAIAJIACABSAAgA0gAIADIACACyAAgAcgAIAPIACAAKAAgAigAIAEoACADKAAgAKgAIAKoACABqAAgA6gAIABoACACaAAgAWgAIANoACAA6AAgAugAIAHoACAD6AAgABgAIAIYACABGAAgAxgAIACYACACmAAgAZgAIAOYACAAWAAgAlgAIAFYACADWAAgANgAIALYACAB2AAgA9gAIAA4ACACOAAgATgAIAM4ACAAuAAgArgAIAG4ACADuAAgAHgAIAJ4ACABeAAgA3gAIAD4ACAC+AAgAfgAIAP4ACAABAAgAgQAIAEEACADBAAgAIQAIAKEACABhAAgA4QAIABEACACRAAgAUQAIANEACAAxAAgAsQAIAHEACADxAAgACQAIAIkACABJAAgAyQAIACkACACpAAgAaQAIAOkACAAZAAgAmQAIAFkACADZAAgAOQAIALkACAB5AAgA+QAIAAUACACFAAgARQAIAMUACAAlAAgApQAIAGUACADlAAgAFQAIAJUACABVAAgA1QAIADUACAC1AAgAdQAIAPUACAANAAgAjQAIAE0ACADNAAgALQAIAK0ACABtAAgA7QAIAB0ACACdAAgAXQAIAN0ACAA9AAgAvQAIAH0ACAD9AAgAEwAJABMBCQCTAAkAkwEJAFMACQBTAQkA0wAJANMBCQAzAAkAMwEJALMACQCzAQkAcwAJAHMBCQDzAAkA8wEJAAsACQALAQkAiwAJAIsBCQBLAAkASwEJAMsACQDLAQkAKwAJACsBCQCrAAkAqwEJAGsACQBrAQkA6wAJAOsBCQAbAAkAGwEJAJsACQCbAQkAWwAJAFsBCQDbAAkA2wEJADsACQA7AQkAuwAJALsBCQB7AAkAewEJAPsACQD7AQkABwAJAAcBCQCHAAkAhwEJAEcACQBHAQkAxwAJAMcBCQAnAAkAJwEJAKcACQCnAQkAZwAJAGcBCQDnAAkA5wEJABcACQAXAQkAlwAJAJcBCQBXAAkAVwEJANcACQDXAQkANwAJADcBCQC3AAkAtwEJAHcACQB3AQkA9wAJAPcBCQAPAAkADwEJAI8ACQCPAQkATwAJAE8BCQDPAAkAzwEJAC8ACQAvAQkArwAJAK8BCQBvAAkAbwEJAO8ACQDvAQkAHwAJAB8BCQCfAAkAnwEJAF8ACQBfAQkA3wAJAN8BCQA/AAkAPwEJAL8ACQC/AQkAfwAJAH8BCQD/AAkA/wEJAAAABwBAAAcAIAAHAGAABwAQAAcAUAAHADAABwBwAAcACAAHAEgABwAoAAcAaAAHABgABwBYAAcAOAAHAHgABwAEAAcARAAHACQABwBkAAcAFAAHAFQABwA0AAcAdAAHAAMACACDAAgAQwAIAMMACAAjAAgAowAIAGMACADjAAgAJXMlcyVzACVzJXMlcyVzAFVzaW5nIGxpYnBuZyB2ZXJzaW9uICVzIGFuZCB6bGliIHZlcnNpb24gJXMKAFRoaXMgcHJvZ3JhbSBpcyBvcGVuLXNvdXJjZSBzb2Z0d2FyZS4gU2VlIExJQ0VOU0UgZm9yIG1vcmUgZGV0YWlscy4KClBvcnRpb25zIG9mIHRoaXMgc29mdHdhcmUgYXJlIGJhc2VkIGluIHBhcnQgb24gdGhlIHdvcmsgb2Y6CiAgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlciAoemxpYikKICBHbGVubiBSYW5kZXJzLVBlaHJzb24gYW5kIHRoZSBQTkcgRGV2ZWxvcG1lbnQgR3JvdXAgKGxpYnBuZykKICBNaXlhc2FrYSBNYXNhcnUgKEJNUCBzdXBwb3J0KQogIERhdmlkIEtvYmxhcyAoR0lGIHN1cHBvcnQpCgBUeXBlICJvcHRpcG5nIC1oIiBmb3IgZXh0ZW5kZWQgaGVscC4KAEJhc2ljIG9wdGlvbnM6CiAgICAtPywgLWgsIC1oZWxwCXNob3cgdGhlIGV4dGVuZGVkIGhlbHAKICAgIC1vIDxsZXZlbD4JCW9wdGltaXphdGlvbiBsZXZlbCAoMC03KQkJW2RlZmF1bHQ6IDJdCiAgICAtdgkJCXJ1biBpbiB2ZXJib3NlIG1vZGUgLyBzaG93IGNvcHlyaWdodCBhbmQgdmVyc2lvbiBpbmZvCgBFeGFtcGxlczoKICAgIG9wdGlwbmcgZmlsZS5wbmcJCQkJCQkoZGVmYXVsdCBzcGVlZCkKICAgIG9wdGlwbmcgLW81IGZpbGUucG5nCQkJCQkoc2xvdykKICAgIG9wdGlwbmcgLW83IGZpbGUucG5nCQkJCQkodmVyeSBzbG93KQoAQmFzaWMgb3B0aW9uczoKICAgIC0/LCAtaCwgLWhlbHAJc2hvdyB0aGlzIGhlbHAKICAgIC1vIDxsZXZlbD4JCW9wdGltaXphdGlvbiBsZXZlbCAoMC03KQkJW2RlZmF1bHQ6IDJdCiAgICAtdgkJCXJ1biBpbiB2ZXJib3NlIG1vZGUgLyBzaG93IGNvcHlyaWdodCBhbmQgdmVyc2lvbiBpbmZvCkdlbmVyYWwgb3B0aW9uczoKICAgIC1iYWNrdXAsIC1rZWVwCWtlZXAgYSBiYWNrdXAgb2YgdGhlIG1vZGlmaWVkIGZpbGVzCiAgICAtY2xvYmJlcgkJb3ZlcndyaXRlIGV4aXN0aW5nIGZpbGVzCiAgICAtZml4CQllbmFibGUgZXJyb3IgcmVjb3ZlcnkKICAgIC1mb3JjZQkJZW5mb3JjZSB3cml0aW5nIG9mIGEgbmV3IG91dHB1dCBmaWxlCiAgICAtcHJlc2VydmUJCXByZXNlcnZlIGZpbGUgYXR0cmlidXRlcyBpZiBwb3NzaWJsZQogICAgLXF1aWV0LCAtc2lsZW50CXJ1biBpbiBxdWlldCBtb2RlCiAgICAtc2ltdWxhdGUJCXJ1biBpbiBzaW11bGF0aW9uIG1vZGUKICAgIC1vdXQgPGZpbGU+CQl3cml0ZSBvdXRwdXQgZmlsZSB0byA8ZmlsZT4KICAgIC1kaXIgPGRpcmVjdG9yeT4Jd3JpdGUgb3V0cHV0IGZpbGUocykgdG8gPGRpcmVjdG9yeT4KICAgIC1sb2cgPGZpbGU+CQlsb2cgbWVzc2FnZXMgdG8gPGZpbGU+CiAgICAtLQkJCXN0b3Agb3B0aW9uIHN3aXRjaCBwYXJzaW5nCk9wdGltaXphdGlvbiBvcHRpb25zOgogICAgLWYgPGZpbHRlcnM+CVBORyBkZWx0YSBmaWx0ZXJzICgwLTUpCQkJW2RlZmF1bHQ6IDAsNV0KICAgIC1pIDx0eXBlPgkJUE5HIGludGVybGFjZSB0eXBlICgwLTEpCiAgICAtemMgPGxldmVscz4JemxpYiBjb21wcmVzc2lvbiBsZXZlbHMgKDEtOSkJCVtkZWZhdWx0OiA5XQogICAgLXptIDxsZXZlbHM+CXpsaWIgbWVtb3J5IGxldmVscyAoMS05KQkJW2RlZmF1bHQ6IDhdCiAgICAtenMgPHN0cmF0ZWdpZXM+CXpsaWIgY29tcHJlc3Npb24gc3RyYXRlZ2llcyAoMC0zKQlbZGVmYXVsdDogMC0zXQogICAgLXp3IDxzaXplPgkJemxpYiB3aW5kb3cgc2l6ZSAoMjU2LDUxMiwxaywyayw0ayw4aywxNmssMzJrKQogICAgLWZ1bGwJCXByb2R1Y2UgYSBmdWxsIHJlcG9ydCBvbiBJREFUIChtaWdodCByZWR1Y2Ugc3BlZWQpCiAgICAtbmIJCQlubyBiaXQgZGVwdGggcmVkdWN0aW9uCiAgICAtbmMJCQlubyBjb2xvciB0eXBlIHJlZHVjdGlvbgogICAgLW5wCQkJbm8gcGFsZXR0ZSByZWR1Y3Rpb24KICAgIC1ueAkJCW5vIHJlZHVjdGlvbnMKICAgIC1uegkJCW5vIElEQVQgcmVjb2RpbmcKRWRpdGluZyBvcHRpb25zOgogICAgLXNuaXAJCWN1dCBvbmUgaW1hZ2Ugb3V0IG9mIG11bHRpLWltYWdlIG9yIGFuaW1hdGlvbiBmaWxlcwogICAgLXN0cmlwIDxvYmplY3RzPglzdHJpcCBtZXRhZGF0YSBvYmplY3RzIChlLmcuICJhbGwiKQpPcHRpbWl6YXRpb24gbGV2ZWxzOgogICAgLW8wCQk8PT4JLW8xIC1ueCAtbnoJCQkJKDAgb3IgMSB0cmlhbHMpCiAgICAtbzEJCTw9PgktemM5IC16bTggLXpzMCAtZjAJCQkoMSB0cmlhbCkKICAgIAkJKG9yLi4uKQktemM5IC16bTggLXpzMSAtZjUJCQkoMSB0cmlhbCkKICAgIC1vMgkJPD0+CS16YzkgLXptOCAtenMwLTMgLWYwLDUJCQkoOCB0cmlhbHMpCiAgICAtbzMJCTw9PgktemM5IC16bTgtOSAtenMwLTMgLWYwLDUJCSgxNiB0cmlhbHMpCiAgICAtbzQJCTw9PgktemM5IC16bTggLXpzMC0zIC1mMC01CQkJKDI0IHRyaWFscykKICAgIC1vNQkJPD0+CS16YzkgLXptOC05IC16czAtMyAtZjAtNQkJKDQ4IHRyaWFscykKICAgIC1vNgkJPD0+CS16YzEtOSAtem04IC16czAtMyAtZjAtNQkJKDEyMCB0cmlhbHMpCiAgICAtbzcJCTw9PgktemMxLTkgLXptOC05IC16czAtMyAtZjAtNQkJKDI0MCB0cmlhbHMpCiAgICAtbzcgLXptMS05CTw9PgktemMxLTkgLXptMS05IC16czAtMyAtZjAtNQkJKDEwODAgdHJpYWxzKQpOb3RlczoKICAgIFRoZSBjb21iaW5hdGlvbiBmb3IgLW8xIGlzIGNob3NlbiBoZXVyaXN0aWNhbGx5LgogICAgRXhoYXVzdGl2ZSBjb21iaW5hdGlvbnMgc3VjaCBhcyAiLW83IC16bTEtOSIgYXJlIG5vdCBnZW5lcmFsbHkgcmVjb21tZW5kZWQuCgBTeW5vcHNpczoKICAgIG9wdGlwbmcgW29wdGlvbnNdIGZpbGVzIC4uLgpGaWxlczoKICAgIEltYWdlIGZpbGVzIG9mIHR5cGU6IFBORywgQk1QLCBHSUYsIFBOTSBvciBUSUZGCgBDYW4ndCBpbml0aWFsaXplIG9wdGltaXphdGlvbiBlbmdpbmUAQ2FuJ3QgZmluYWxpemUgb3B0aW1pemF0aW9uIGVuZ2luZQAKKiogSU5URVJOQUwgRVJST1I6ICVzCgBQbGVhc2Ugc3VibWl0IGEgZGVmZWN0IHJlcG9ydC4KaHR0cDovL29wdGlwbmcuc291cmNlZm9yZ2UubmV0LwoKAFRoZSBleGVjdXRpb24gb2YgdGhpcyBwcm9ncmFtIGhhcyBiZWVuIHRlcm1pbmF0ZWQgYWJub3JtYWxseS4KAA0APD8+AE9wdGlQTkcgdmVyc2lvbiAwLjcuNwpDb3B5cmlnaHQgKEMpIDIwMDEtMjAxNyBDb3NtaW4gVHJ1dGEgYW5kIHRoZSBDb250cmlidXRpbmcgQXV0aG9ycy4KAGEAQ2FuJ3Qgb3BlbiBsb2cgZmlsZTogJXMKACoqIFdhcm5pbmc6ICVzCgoAVGhlIG9wdGlvbiAtbG9nIGlzIGRlcHJlY2F0ZWQ7IHVzZSBzaGVsbCByZWRpcmVjdGlvbgAqKiBFcnJvcjogAGZpbwAtAD8AaGVscABiYWNrdXAAa2VlcABjbG9iYmVyAGRlYnVnAGZpeABmb3JjZQBmdWxsAG5iAG5jAG5wAG54AG56AHByZXNlcnZlAHF1aWV0AHNpbGVudABzaW11bGF0ZQBzbmlwAHYAdmVyYm9zZQB2ZXJzaW9uAE5vIGFyZ3VtZW50IGFsbG93ZWQgZm9yIG9wdGlvbjogJXMAbwAtbwBNdWx0aXBsZSBvcHRpbWl6YXRpb24gbGV2ZWxzIGFyZSBub3QgcGVybWl0dGVkAGkALWkATXVsdGlwbGUgaW50ZXJsYWNlIHR5cGVzIGFyZSBub3QgcGVybWl0dGVkAGYALWYAemMALXpjAHptAC16bQB6cwAtenMAencALXp3AE11bHRpcGxlIHdpbmRvdyBzaXplcyBhcmUgbm90IHBlcm1pdHRlZABzdHJpcAAtc3RyaXAAb3V0AE11bHRpcGxlIG91dHB1dCBmaWxlIG5hbWVzIGFyZSBub3QgcGVybWl0dGVkAC1vdXQAZGlyAE11bHRpcGxlIG91dHB1dCBkaXIgbmFtZXMgYXJlIG5vdCBwZXJtaXR0ZWQALWRpcgBsb2cATXVsdGlwbGUgbG9nIGZpbGUgbmFtZXMgYXJlIG5vdCBwZXJtaXR0ZWQALWxvZwBVbnJlY29nbml6ZWQgb3B0aW9uOiAlcwBUaGUgb3B0aW9uIC1vdXQgcmVxdWlyZXMgb25lIGlucHV0IGZpbGUAVGhlIG9wdGlvbnMgLW91dCBhbmQgLWRpciBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlAC5sb2cAVG8gcHJldmVudCBhY2NpZGVudGFsIGRhdGEgY29ycnVwdGlvbiwgdGhlIGxvZyBmaWxlIG5hbWUgbXVzdCBlbmQgd2l0aCAiLmxvZyIATWlzc2luZyBhcmd1bWVudCBmb3Igb3B0aW9uICVzAEludmFsaWQgYXJndW1lbnQgZm9yIG9wdGlvbiAlczogJXMAYWxsAE1hbmlwdWxhdGlvbiBvZiBpbmRpdmlkdWFsIGNodW5rcyBpcyBub3QgaW1wbGVtZW50ZWQAVGhlIE9wdGlQTkcgZW5naW5lIGlzIG5vdCBydW5uaW5nACoqIFByb2Nlc3Npbmc6ICVzCgAKAEVycm9yOiAlcwoAcmIAQ2FuJ3Qgb3BlbiB0aGUgaW5wdXQgZmlsZQBNeXN0ZXJpb3VzIGVycm9yIGluIG9wbmdfcmVhZF9maWxlAFJlY292ZXJhYmxlIGVycm9ycyBmb3VuZCBpbiBpbnB1dC4AIEZpeGluZy4uLgoAIFJlcnVuIE9wdGlQTkcgd2l0aCAtZml4IGVuYWJsZWQuCgBQcmV2aW91cyBlcnJvcihzKSBub3QgZml4ZWQASURBVCByZWNvZGluZyBpcyBuZWNlc3NhcnksIGJ1dCBpcyBkaXNhYmxlZCBieSB0aGUgdXNlci4KAENhbid0IGNvbnRpbnVlAERpZ2l0YWwgc2lnbmF0dXJlIGZvdW5kIGluIGlucHV0LgAgRXJhc2luZy4uLgoAIFJlcnVuIE9wdGlQTkcgd2l0aCAtZm9yY2UgZW5hYmxlZC4KAENhbid0IG9wdGltaXplIGRpZ2l0YWxseS1zaWduZWQgZmlsZXMAQ29udmVyc2lvbiB0byBQTkcgcmVxdWlyZXMgc25pcHBpbmcuIFJlcnVuIE9wdGlQTkcgd2l0aCAtc25pcCBlbmFibGVkLgoASW5jb21wYXRpYmxlIGlucHV0IGZvcm1hdABTdHJpcHBpbmcgbWV0YWRhdGEuLi4KAC5wbmcAQ2FuJ3QgY3JlYXRlIHRoZSBvdXRwdXQgZmlsZSAobmFtZSB0b28gbG9uZykAQ2FuJ3QgY3JlYXRlIGJhY2t1cCBmaWxlIChuYW1lIHRvbyBsb25nKQBlAFRoZSBvdXRwdXQgZmlsZSBleGlzdHMuIFJlcnVuIE9wdGlQTkcgd2l0aCAtYmFja3VwIGVuYWJsZWQuCgBDYW4ndCBvdmVyd3JpdGUgdGhlIG91dHB1dCBmaWxlAGZ3AENhbid0IGJhY2sgdXAgdGhlIGV4aXN0aW5nIG91dHB1dCBmaWxlAElucHV0IElEQVQgc2l6ZSA9ICVsbHUgYnl0ZXMKAElucHV0IGZpbGUgc2l6ZSA9ICVsbHUgYnl0ZXMKAAolcyBpcyBhbHJlYWR5IG9wdGltaXplZC4KAApObyBvdXRwdXQ6IHNpbXVsYXRpb24gbW9kZS4KAApPdXRwdXQgZmlsZTogJXMKAENhbid0IGJhY2sgdXAgdGhlIG91dHB1dCBmaWxlAENhbid0IGJhY2sgdXAgdGhlIGlucHV0IGZpbGUAd2IAQ2FuJ3Qgb3BlbiB0aGUgb3V0cHV0IGZpbGUAQ2FuJ3QgcmVvcGVuIHRoZSBpbnB1dCBmaWxlAENhbid0IHJlcG9zaXRpb24gdGhlIGlucHV0IGZpbGUATXlzdGVyaW91cyBlcnJvciBpbiBvcG5nX2NvcHlfZmlsZQBDYW4ndCByZWNvdmVyIHRoZSBvcmlnaW5hbCBmaWxlIGZyb20gYmFja3VwAE92ZXJ3cm90ZSBpbnB1dCB3aXRoIG5vIHRlbXBvcmFyeSBiYWNrdXAAQ2FuJ3QgcmVtb3ZlIHRoZSBicm9rZW4gb3V0cHV0IGZpbGUAQ2FuJ3QgcmVtb3ZlIHRoZSBiYWNrdXAgZmlsZQAKT3V0cHV0IElEQVQgc2l6ZSA9ICVsbHUgYnl0ZXMAICgAKQAKT3V0cHV0IGZpbGUgc2l6ZSA9ICVsbHUgYnl0ZXMgKAApCgBubyBjaGFuZ2UAMSBieXRlACVsbHUgYnl0ZXMAID0gACBpbmNyZWFzZQAgZGVjcmVhc2UALi4uACVzJXMAV2FybmluZzogJXMKAFJlYWQgZXJyb3IARGF0YSBlcnJvcgBJRU5ESW5jb3JyZWN0IGluZm8gaW4gcG5nX3B0ci0+aW9fc3RhdGUAV3JpdGluZyBjaHVuayBoZWFkZXIsIGV4cGVjdGluZyA4IGJ5dGVzAElEQVRQTFRFdFJOU1dyaXRpbmcgY2h1bmsgQ1JDLCBleHBlY3RpbmcgNCBieXRlcwBXcm9uZyBndWVzcyBvZiB0aGUgb3V0cHV0IElEQVQgc2l6ZQBDYW4ndCBmaW5hbGl6ZSBJREFUAENhbid0IHdyaXRlIHRoZSBvdXRwdXQgZmlsZQBkU0lHYWNUTGZjVExmZEFUSW52YWxpZCBlbmNvZGluZyBwYXJhbWV0ZXJzAE5vIGluZm8gaW4gaW1hZ2UASURBVCBzaXplcyBsYXJnZXIgdGhhbiB0aGUgbWF4aW11bSBjaHVuayBzaXplIGFyZSBjdXJyZW50bHkgdW5zdXBwb3J0ZWQAClNlbGVjdGluZyBwYXJhbWV0ZXJzOgoAICB6YyA9ICVkICB6bSA9ICVkICB6cyA9ICVkICBmID0gJWQACQlJREFUIHNpemUgPSAlbGx1ACAgemMgPSAqICB6bSA9ICogIHpzID0gKiAgZiA9ICoJCUlEQVQgc2l6ZSA+ICVzCgAyR0IASXRlcmF0aW9ucyBub3QgaW5pdGlhbGl6ZWQAClRyeWluZzoKAAkJSURBVCB0b28gYmlnCgAJCUlEQVQgc2l6ZSA9ICVsbHUKAEluY29uc2lzdGVudCBpdGVyYXRpb24gY291bnRlcgBObyBJREFUIGluIGlucHV0AEludmFsaWQgaXRlcmF0aW9uIHBhcmFtZXRlcnMASXRlcmF0aW9uIHBhcmFtZXRlcihzKSBvdXQgb2YgcmFuZ2UAW2ludGVybmFsXSBJbnZhbGlkIHByZXNldAA5ADgAMC0AMCw1ADgtOQAxLTkAVW5yZWNvZ25pemVkIGltYWdlIGZpbGUgZm9ybWF0AEFQTkcAQVBORyBkYXRhc3RyZWFtAE5vIGZvcm1hdCBuYW1lIGZyb20gcG5neHRlcm4AQ2FuJ3QgZ2V0IHRoZSBjb3JyZWN0IGZpbGUgc2l6ZQBQTkcASW1wb3J0aW5nICVzACAobXVsdGktaW1hZ2Ugb3IgYW5pbWF0aW9uKQA7IHNuaXBwaW5nLi4uAENhbid0IHJlbGlhYmx5IHJlZHVjZSBBUE5HIGZpbGU7IGRpc2FibGluZyByZWR1Y3Rpb25zLgooRGlkIHlvdSB3YW50IHRvIC1zbmlwIGFuZCBvcHRpbWl6ZSB0aGUgZmlyc3QgZnJhbWU/KQoAUmVkdWNpbmcgaW1hZ2UgdG8gACVsdXglbHUgcGl4ZWxzACwgACVkeCVkIGJpdHMvcGl4ZWwAJWQgYml0cy9waXhlbAAxIGJpdC9waXhlbAAxIGNvbG9yACVkIGNvbG9ycwAgKCVkIHRyYW5zcGFyZW50KQAgaW4gcGFsZXR0ZQBSR0IAZ3JheXNjYWxlACthbHBoYQArdHJhbnNwYXJlbmN5AGludGVybGFjZWQAQ2FuJ3QgcmVhZCB0aGUgaW5wdXQgZmlsZSBvciB1bmV4cGVjdGVkIGVuZCBvZiBmaWxlAFBORyBJL08gbXVzdCBzdGFydCB3aXRoIHRoZSBmaXJzdCA4IGJ5dGVzAENhbid0IGdldCB0aGUgZmlsZS1wb3NpdGlvbiBpbmRpY2F0b3IgaW4gaW5wdXQgZmlsZQBSZWFkaW5nIGNodW5rIGhlYWRlciwgZXhwZWN0aW5nIDggYnl0ZXMASW5jb3JyZWN0IEkvTyBoYW5kbGVyIHNldHVwAEZvdW5kIElEQVQgd2l0aCBubyByb3dzAEZhaWxlZCBhbGxvY2F0aW9uIG9mIGltYWdlIHJvd3M7IHVuc2FmZSBsaWJwbmcgYWxsb2NhdG9yAFJlYWRpbmcgY2h1bmsgQ1JDLCBleHBlY3RpbmcgNCBieXRlcwBiS0dEaElTVHNCSVQqKiBTdGF0dXMgcmVwb3J0CgAldSBmaWxlKHMpIGhhdmUgYmVlbiBwcm9jZXNzZWQuCgAldSBtdWx0aS1pbWFnZSBmaWxlKHMpIGhhdmUgYmVlbiBzbmlwcGVkLgoAJXUgZXJyb3IocykgaGF2ZSBiZWVuIGVuY291bnRlcmVkLgoAJXUgZXJyb25lb3VzIGZpbGUocykgaGF2ZSBiZWVuIGZpeGVkLgoALwAuYmFrAD8/JSUASU5GSU5JVFklJQAldS4lMDJ1JSUAJWxsdSUwMnUlJQAlbGx1LiUwMnV4ACVsbHV4AEltYWdlIHJlZHVjdGlvbiByZXF1aXJlcyB0aGUgcHJlc2VuY2Ugb2YgYWxsIGNyaXRpY2FsIGluZm9ybWF0aW9uACEoY29sb3JfdHlwZSAmIDEpAG9wbmdyZWR1Yy5jAG9wbmdfcmVkdWNlX3RvX3BhbGV0dGUAbnVtX3BhbGV0dGUgPCAwAG51bV9wYWxldHRlID4gMCAmJiBudW1fcGFsZXR0ZSA8PSAyNTYAbnVtX3RyYW5zID49IDAgJiYgbnVtX3RyYW5zIDw9IG51bV9wYWxldHRlAGluZGV4ID49IDAAbnVtX3BhbGV0dGUgPiAwAG9wbmdfcmVkdWNlX3BhbGV0dGVfYml0cwBzcmNfYml0X2RlcHRoID09IGRlc3RfYml0X2RlcHRoACpudW1fcGFsZXR0ZSA+PSAwICYmICpudW1fcGFsZXR0ZSA8PSBtYXhfdHVwbGVzAG9wbmdfaW5zZXJ0X3BhbGV0dGVfZW50cnkAKm51bV90cmFucyA+PSAwICYmICpudW1fdHJhbnMgPD0gKm51bV9wYWxldHRlAGxvdyA+PSAwICYmIGxvdyA8PSAqbnVtX3BhbGV0dGUAbG93IDw9ICpudW1fdHJhbnMAb3BuZ19nZXRfYWxwaGFfcm93AGJpdF9kZXB0aCA9PSA4AGNoYW5uZWxzID09IDMAY29sb3JfdHlwZSA9PSAwAGNoYW5uZWxzID09IDEAY2hhbm5lbHMgPiAxAHRyYW5zX2FscGhhICE9ICgodm9pZCopMCkgJiYgbnVtX3RyYW5zID4gMABvcG5nX3JlZHVjZV9wYWxldHRlAGxhc3RfY29sb3JfaW5kZXggPj0gMABsYXN0X2NvbG9yX2luZGV4ID49IGxhc3RfdHJhbnNfaW5kZXgAVG9vIGZldyBjb2xvcnMgaW4gUExURQBudW1fcGFsZXR0ZSA9PSBsYXN0X2NvbG9yX2luZGV4ICsgMQBUb28gbWFueSBhbHBoYSB2YWx1ZXMgaW4gdFJOUwBudW1fdHJhbnMgPT0gbGFzdF90cmFuc19pbmRleCArIDEAbnVtX3RyYW5zID4gMABvcG5nX3JlYWxsb2NfdFJOUwBvcG5nX3JlYWxsb2NfUExURQBiaXRfZGVwdGggPCA4AG9wbmdfYW5hbHl6ZV9zYW1wbGVfdXNhZ2UAc3JjX2JpdF9kZXB0aCA+PSA4AG9wbmdfcmVkdWNlX2JpdHMAc3JjX2JpdF9kZXB0aCA9PSAxNgBzcmNfY29sb3JfdHlwZSAmIDIAc3JjX2NvbG9yX3R5cGUgJiA0AHNyY19zYW1wbGVfc2l6ZSA+IGRlc3Rfc2FtcGxlX3NpemUAQ2FuJ3QgZnRlbGwgaW4gaW5wdXQgZmlsZSBzdHJlYW0AQ2FuJ3QgZnNlZWsgaW4gaW5wdXQgZmlsZSBzdHJlYW0ARXh0cmFuZW91cyBkYXRhIGZvdW5kIGFmdGVyIElFTkQAAAAADUlIRFJQTkcgZmlsZSBhcHBlYXJzIHRvIGJlIGNvcnJ1cHRlZCBieSB0ZXh0IGZpbGUgY29udmVyc2lvbnMAik1ORw0KGgpNTkcgZGVjb2RpbmcgaXMgbm90IHN1cHBvcnRlZABQTkcgZGF0YXN0cmVhbQBQb3J0YWJsZSBOZXR3b3JrIEdyYXBoaWNzAFBvcnRhYmxlIE5ldHdvcmsgR3JhcGhpY3MgZW1iZWRkZWQgZGF0YXN0cmVhbQBCTVAAT1MvMiBCaXRtYXAAV2luZG93cyBCaXRtYXAATWlzc2luZyBjb2xvciBtYXNrIGluIEJNUCBmaWxlAEpQRUctY29tcHJlc3NlZCBCTVAgZmlsZXMgYXJlIG5vdCBzdXBwb3J0ZWQAVW5zdXBwb3J0ZWQgY29tcHJlc3Npb24gbWV0aG9kIGluIEJNUCBmaWxlAEludmFsaWQgaW1hZ2UgZGltZW5zaW9ucyBpbiBCTVAgZmlsZQBJbnZhbGlkIHBpeGVsIGRlcHRoIGluIEJNUCBmaWxlAENhbid0IGhhbmRsZSBleGNlZWRpbmdseSBsYXJnZSBCTVAgZGltZW5zaW9ucwBJbnZhbGlkIGNvbG9yIG1hc2sgaW4gQk1QIGZpbGUARXJyb3IgcmVhZGluZyBjb2xvciBwYWxldHRlIGluIEJNUCBmaWxlAEVycm9yIHJlYWRpbmcgQk1QIGZpbGUAR0lGODdhR0lGODlhR3JhcGhpY3MgSW50ZXJjaGFuZ2UgRm9ybWF0AE5vIGltYWdlIGluIEdJRiBmaWxlAEpQRUcAAAAADGpQICANCocK/0//UUpQRUctMjAwMACLSk5HDQoaCgAAABpKSERSSk5HAEpQRUcgZGVjb2RpbmcgaXMgbm90IHN1cHBvcnRlZABKUEVHLTIwMDAgZGVjb2RpbmcgaXMgbm90IHN1cHBvcnRlZABKTkcgKEpQRUcpIGRlY29kaW5nIGlzIG5vdCBzdXBwb3J0ZWQAUG9ydGFibGUgQml0bWFwAFBvcnRhYmxlIEdyYXltYXAAUG9ydGFibGUgUGl4bWFwAFBvcnRhYmxlIEFueW1hcABQQk0AUEdNAFBQTQBQQU0AQ2FuJ3QgaGFuZGxlIFBOTSBmb3JtYXRzIG5ld2VyIHRoYW4gUFBNICgiUDYiKQBDYW4ndCBoYW5kbGUgZXhjZWVkaW5nbHkgbGFyZ2UgUE5NIGRpbWVuc2lvbnMAQ2FuJ3QgaGFuZGxlIFBOTSBzYW1wbGVzIGxhcmdlciB0aGFuIDE2IGJpdHMAUG9zc2libHkgaW5leGFjdCBzYW1wbGUgY29udmVyc2lvbiBmcm9tIFBOTSB0byBQTkcAT3ZlcmZsb3cgaW4gUE5NIHNhbXBsZXMARXJyb3IgaW4gUE5NIGltYWdlIGZpbGUARXh0cmFuZW91cyBkYXRhIGZvdW5kIGFmdGVyIFBOTSBpbWFnZQBUSUZGAFRhZ2dlZCBJbWFnZSBGaWxlIEZvcm1hdABVbnN1cHBvcnRlZCBUSUZGIGNvbG9yIHNwYWNlAFVuc3VwcG9ydGVkIFRJRkYgc2FtcGxlIGRlcHRoAE92ZXJmbG93IGluIFRJRkYgc2FtcGxlcwBtdWx0aS1pbWFnZQBNaXNzaW5nIElIRFIAQ2FuJ3QgaGFuZGxlIGV4Y2VlZGluZ2x5IGxhcmdlIGltYWdlIGRpbWVuc2lvbnMAVG9vIG1hbnkgYnl0ZXMgZm9yIFBORyBzaWduYXR1cmUAiVBORw0KGgpQb3RlbnRpYWwgb3ZlcmZsb3cgaW4gcG5nX3phbGxvYygpADEuNi4zNABBcHBsaWNhdGlvbiBidWlsdCB3aXRoIGxpYnBuZy0AIGJ1dCBydW5uaW5nIHdpdGggAFVua25vd24gZnJlZXIgcGFyYW1ldGVyIGluIHBuZ19kYXRhX2ZyZWVyAHVuZXhwZWN0ZWQgemxpYiByZXR1cm4AdW5zdXBwb3J0ZWQgemxpYiB2ZXJzaW9uAHRydW5jYXRlZABkYW1hZ2VkIExaIHN0cmVhbQBiYWQgcGFyYW1ldGVycyB0byB6bGliAHpsaWIgSU8gZXJyb3IAbWlzc2luZyBMWiBkaWN0aW9uYXJ5AHVuZXhwZWN0ZWQgZW5kIG9mIExaIHN0cmVhbQB1bmV4cGVjdGVkIHpsaWIgcmV0dXJuIGNvZGUASW1hZ2Ugd2lkdGggaXMgemVybyBpbiBJSERSAEludmFsaWQgaW1hZ2Ugd2lkdGggaW4gSUhEUgBJbWFnZSB3aWR0aCBpcyB0b28gbGFyZ2UgZm9yIHRoaXMgYXJjaGl0ZWN0dXJlAEltYWdlIHdpZHRoIGV4Y2VlZHMgdXNlciBsaW1pdCBpbiBJSERSAEltYWdlIGhlaWdodCBpcyB6ZXJvIGluIElIRFIASW52YWxpZCBpbWFnZSBoZWlnaHQgaW4gSUhEUgBJbWFnZSBoZWlnaHQgZXhjZWVkcyB1c2VyIGxpbWl0IGluIElIRFIASW52YWxpZCBiaXQgZGVwdGggaW4gSUhEUgBJbnZhbGlkIGNvbG9yIHR5cGUgaW4gSUhEUgBJbnZhbGlkIGNvbG9yIHR5cGUvYml0IGRlcHRoIGNvbWJpbmF0aW9uIGluIElIRFIAVW5rbm93biBpbnRlcmxhY2UgbWV0aG9kIGluIElIRFIAVW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QgaW4gSUhEUgBVbmtub3duIGZpbHRlciBtZXRob2QgaW4gSUhEUgBJbnZhbGlkIElIRFIgZGF0YQB1bmRlZmluZWQAbGlicG5nIGVycm9yOiAlcwBsaWJwbmcgd2FybmluZzogJXMAT3V0IG9mIG1lbW9yeQBpbnRlcm5hbCBlcnJvcjogYXJyYXkgcmVhbGxvYwBNaXNzaW5nIElIRFIgYmVmb3JlIElEQVQATWlzc2luZyBQTFRFIGJlZm9yZSBJREFUAFRvbyBtYW55IElEQVRzIGZvdW5kAHBuZ19yZWFkX3VwZGF0ZV9pbmZvL3BuZ19zdGFydF9yZWFkX2ltYWdlOiBkdXBsaWNhdGUgY2FsbABwbmdfc3RhcnRfcmVhZF9pbWFnZS9wbmdfcmVhZF91cGRhdGVfaW5mbzogZHVwbGljYXRlIGNhbGwASW52YWxpZCBhdHRlbXB0IHRvIHJlYWQgcm93IGRhdGEAYmFkIGFkYXB0aXZlIGZpbHRlciB2YWx1ZQBzZXF1ZW50aWFsIHJvdyBvdmVyZmxvdwBpbnRlcm5hbCBzZXF1ZW50aWFsIHJvdyBzaXplIGNhbGN1bGF0aW9uIGVycm9yAEludGVybGFjZSBoYW5kbGluZyBzaG91bGQgYmUgdHVybmVkIG9uIHdoZW4gdXNpbmcgcG5nX3JlYWRfaW1hZ2UAUmVhZCBwYWxldHRlIGluZGV4IGV4Y2VlZGluZyBudW1fcGFsZXR0ZQAuVG9vIG1hbnkgSURBVHMgZm91bmQALi5Ub28gbWFueSBJREFUcyBmb3VuZABJbWFnZSBpcyB0b28gaGlnaCB0byBwcm9jZXNzIHdpdGggcG5nX3JlYWRfcG5nKCkAUE5HX1RSQU5TRk9STV9TQ0FMRV8xNiBub3Qgc3VwcG9ydGVkAFBOR19UUkFOU0ZPUk1fU1RSSVBfMTYgbm90IHN1cHBvcnRlZABQTkdfVFJBTlNGT1JNX1NUUklQX0FMUEhBIG5vdCBzdXBwb3J0ZWQAUE5HX1RSQU5TRk9STV9FWFBBTkQgbm90IHN1cHBvcnRlZABQTkdfVFJBTlNGT1JNX0dSQVlfVE9fUkdCIG5vdCBzdXBwb3J0ZWQAUE5HX1RSQU5TRk9STV9FWFBBTkRfMTYgbm90IHN1cHBvcnRlZABDYWxsIHRvIE5VTEwgcmVhZCBmdW5jdGlvbgBSZWFkIEVycm9yAE5VTEwgcm93IGJ1ZmZlcgBVbmluaXRpYWxpemVkIHJvdwBQTkcgdW5zaWduZWQgaW50ZWdlciBvdXQgb2YgcmFuZ2UATm90IGEgUE5HIGZpbGUAUE5HIGZpbGUgY29ycnVwdGVkIGJ5IEFTQ0lJIGNvbnZlcnNpb24AaW52YWxpZCBjaHVuayB0eXBlAGNodW5rIGRhdGEgaXMgdG9vIGxhcmdlAENSQyBlcnJvcgBpbnZhbGlkIHdpbmRvdyBzaXplIChsaWJwbmcpAG91dCBvZiBwbGFjZQBpbnZhbGlkAG1pc3NpbmcgSUhEUgBkdXBsaWNhdGUAaWdub3JlZCBpbiBncmF5c2NhbGUgUE5HAHRSTlMgbXVzdCBiZSBhZnRlcgBoSVNUIG11c3QgYmUgYWZ0ZXIAYktHRCBtdXN0IGJlIGFmdGVyAGludmFsaWQgd2l0aCBhbHBoYSBjaGFubmVsAGludmFsaWQgaW5kZXgAdW5rbm93biBjaHVuayBleGNlZWRzIG1lbW9yeSBsaW1pdHMAbm8gc3BhY2UgaW4gY2h1bmsgY2FjaGUAdW5oYW5kbGVkIGNyaXRpY2FsIGNodW5rAGludGVybmFsIHJvdyBsb2dpYyBlcnJvcgBpbnRlcm5hbCByb3cgc2l6ZSBjYWxjdWxhdGlvbiBlcnJvcgBpbnRlcm5hbCByb3cgd2lkdGggZXJyb3IAaW52YWxpZCB1c2VyIHRyYW5zZm9ybSBwaXhlbCBkZXB0aABOb3QgZW5vdWdoIGltYWdlIGRhdGEAaW5zdWZmaWNpZW50IG1lbW9yeSB0byByZWFkIGNodW5rAEV4dHJhIGNvbXByZXNzZWQgZGF0YQBUb28gbXVjaCBpbWFnZSBkYXRhAFJvdyBoYXMgdG9vIG1hbnkgYnl0ZXMgdG8gYWxsb2NhdGUgaW4gbWVtb3J5AEludmFsaWQgcGFsZXR0ZSBzaXplLCBoSVNUIGFsbG9jYXRpb24gc2tpcHBlZABJbnN1ZmZpY2llbnQgbWVtb3J5IGZvciBoSVNUIGNodW5rIGRhdGEASW52YWxpZCBwYWxldHRlIGxlbmd0aABJbnZhbGlkIHBhbGV0dGUAdFJOUyBjaHVuayBoYXMgb3V0LW9mLXJhbmdlIHNhbXBsZXMgZm9yIGJpdF9kZXB0aAB0b28gbWFueSB1bmtub3duIGNodW5rcwBwbmdfc2V0X3Vua25vd25fY2h1bmtzIG5vdyBleHBlY3RzIGEgdmFsaWQgbG9jYXRpb24AaW52YWxpZCBsb2NhdGlvbiBpbiBwbmdfc2V0X3Vua25vd25fY2h1bmtzAHVua25vd24gY2h1bms6IG91dCBvZiBtZW1vcnkAaW52YWxpZCB1bmtub3duIGNodW5rIGxvY2F0aW9uAHBuZ19zZXRfa2VlcF91bmtub3duX2NodW5rczogaW52YWxpZCBrZWVwAHBuZ19zZXRfa2VlcF91bmtub3duX2NodW5rczogbm8gY2h1bmsgbGlzdABiS0dEAGNIUk0AZVhJZgBnQU1BAGhJU1QAaUNDUABpVFh0AG9GRnMAcENBTABwSFlzAHNCSVQAc0NBTABzUExUAHNURVIAc1JHQgB0RVh0AHRJTUUAelRYdABwbmdfc2V0X2tlZXBfdW5rbm93bl9jaHVua3M6IHRvbyBtYW55IGNodW5rcwBDYWxsIHRvIE5VTEwgd3JpdGUgZnVuY3Rpb24AV3JpdGUgRXJyb3IAQ2FuJ3Qgc2V0IGJvdGggcmVhZF9kYXRhX2ZuIGFuZCB3cml0ZV9kYXRhX2ZuIGluIHRoZSBzYW1lIHN0cnVjdHVyZQBXcml0aW5nIHplcm8tbGVuZ3RoIHVua25vd24gY2h1bmsAVmFsaWQgcGFsZXR0ZSByZXF1aXJlZCBmb3IgcGFsZXR0ZWQgaW1hZ2VzAE5vIElEQVRzIHdyaXR0ZW4gaW50byBmaWxlAFdyb3RlIHBhbGV0dGUgaW5kZXggZXhjZWVkaW5nIG51bV9wYWxldHRlAHBuZ193cml0ZV9pbmZvIHdhcyBuZXZlciBjYWxsZWQgYmVmb3JlIHBuZ193cml0ZV9yb3cAaW50ZXJuYWwgd3JpdGUgdHJhbnNmb3JtIGxvZ2ljIGVycm9yAFVua25vd24gcm93IGZpbHRlciBmb3IgbWV0aG9kIDAAcG5nX3NldF9maWx0ZXI6IFVQL0FWRy9QQUVUSCBjYW5ub3QgYmUgYWRkZWQgYWZ0ZXIgc3RhcnQAVW5rbm93biBjdXN0b20gZmlsdGVyIG1ldGhvZABPbmx5IGNvbXByZXNzaW9uIHdpbmRvd3MgPD0gMzJrIHN1cHBvcnRlZCBieSBQTkcAT25seSBjb21wcmVzc2lvbiB3aW5kb3dzID49IDI1NiBzdXBwb3J0ZWQgYnkgUE5HAG5vIHJvd3MgZm9yIHBuZ193cml0ZV9pbWFnZSB0byB3cml0ZQBQTkdfVFJBTlNGT1JNX0lOVkVSVF9NT05PIG5vdCBzdXBwb3J0ZWQAUE5HX1RSQU5TRk9STV9TSElGVCBub3Qgc3VwcG9ydGVkAFBOR19UUkFOU0ZPUk1fUEFDS0lORyBub3Qgc3VwcG9ydGVkAFBOR19UUkFOU0ZPUk1fU1dBUF9BTFBIQSBub3Qgc3VwcG9ydGVkAFBOR19UUkFOU0ZPUk1fU1RSSVBfRklMTEVSIG5vdCBzdXBwb3J0ZWQAUE5HX1RSQU5TRk9STV9CR1Igbm90IHN1cHBvcnRlZABQTkdfVFJBTlNGT1JNX1NXQVBfRU5ESUFOIG5vdCBzdXBwb3J0ZWQAUE5HX1RSQU5TRk9STV9QQUNLU1dBUCBub3Qgc3VwcG9ydGVkAFBOR19UUkFOU0ZPUk1fSU5WRVJUX0FMUEhBIG5vdCBzdXBwb3J0ZWQAbGVuZ3RoIGV4Y2VlZHMgUE5HIG1heGltdW0ASW52YWxpZCBiaXQgZGVwdGggZm9yIGdyYXlzY2FsZSBpbWFnZQBJbnZhbGlkIGJpdCBkZXB0aCBmb3IgUkdCIGltYWdlAEludmFsaWQgYml0IGRlcHRoIGZvciBwYWxldHRlZCBpbWFnZQBJbnZhbGlkIGJpdCBkZXB0aCBmb3IgZ3JheXNjYWxlK2FscGhhIGltYWdlAEludmFsaWQgYml0IGRlcHRoIGZvciBSR0JBIGltYWdlAEludmFsaWQgaW1hZ2UgY29sb3IgdHlwZSBzcGVjaWZpZWQASW52YWxpZCBjb21wcmVzc2lvbiB0eXBlIHNwZWNpZmllZABJbnZhbGlkIGZpbHRlciB0eXBlIHNwZWNpZmllZABJbnZhbGlkIGludGVybGFjZSB0eXBlIHNwZWNpZmllZABJbnZhbGlkIG51bWJlciBvZiBjb2xvcnMgaW4gcGFsZXR0ZQBJZ25vcmluZyByZXF1ZXN0IHRvIHdyaXRlIGEgUExURSBjaHVuayBpbiBncmF5c2NhbGUgUE5HACB1c2luZyB6c3RyZWFtAGluIHVzZSBieSBJREFUAGRlZmxhdGVFbmQgZmFpbGVkIChpZ25vcmVkKQBaX09LIG9uIFpfRklOSVNIIHdpdGggb3V0cHV0IHNwYWNlAEludmFsaWQgc0JJVCBkZXB0aCBzcGVjaWZpZWQASW52YWxpZCBudW1iZXIgb2YgdHJhbnNwYXJlbnQgY29sb3JzIHNwZWNpZmllZABJZ25vcmluZyBhdHRlbXB0IHRvIHdyaXRlIHRSTlMgY2h1bmsgb3V0LW9mLXJhbmdlIGZvciBiaXRfZGVwdGgASWdub3JpbmcgYXR0ZW1wdCB0byB3cml0ZSAxNi1iaXQgdFJOUyBjaHVuayB3aGVuIGJpdF9kZXB0aCBpcyA4AENhbid0IHdyaXRlIHRSTlMgd2l0aCBhbiBhbHBoYSBjaGFubmVsAEludmFsaWQgYmFja2dyb3VuZCBwYWxldHRlIGluZGV4AElnbm9yaW5nIGF0dGVtcHQgdG8gd3JpdGUgMTYtYml0IGJLR0QgY2h1bmsgd2hlbiBiaXRfZGVwdGggaXMgOABJZ25vcmluZyBhdHRlbXB0IHRvIHdyaXRlIGJLR0QgY2h1bmsgb3V0LW9mLXJhbmdlIGZvciBiaXRfZGVwdGgASW52YWxpZCBudW1iZXIgb2YgaGlzdG9ncmFtIGVudHJpZXMgc3BlY2lmaWVkAAgIBAQCAgEABAACAAEACAgIBAQCAgAABAACAAFpbmNvcnJlY3QgaGVhZGVyIGNoZWNrAHVua25vd24gY29tcHJlc3Npb24gbWV0aG9kAGludmFsaWQgd2luZG93IHNpemUAaW52YWxpZCBibG9jayB0eXBlAGludmFsaWQgc3RvcmVkIGJsb2NrIGxlbmd0aHMAdG9vIG1hbnkgbGVuZ3RoIG9yIGRpc3RhbmNlIHN5bWJvbHMAaW52YWxpZCBjb2RlIGxlbmd0aHMgc2V0AGludmFsaWQgYml0IGxlbmd0aCByZXBlYXQAaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrAGludmFsaWQgbGl0ZXJhbC9sZW5ndGhzIHNldABpbnZhbGlkIGRpc3RhbmNlcyBzZXQAaW5jb3JyZWN0IGRhdGEgY2hlY2sAAAECAwQEBQUGBgYGBwcHBwgICAgICAgICQkJCQkJCQkKCgoKCgoKCgoKCgoKCgoKCwsLCwsLCwsLCwsLCwsLCwwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDwAAEBESEhMTFBQUFBUVFRUWFhYWFhYWFhcXFxcXFxcXGBgYGBgYGBgYGBgYGBgYGBkZGRkZGRkZGRkZGRkZGRkaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHB0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0AAQIDBAUGBwgICQkKCgsLDAwMDA0NDQ0ODg4ODw8PDxAQEBAQEBAQERERERERERESEhISEhISEhMTExMTExMTFBQUFBQUFBQUFBQUFBQUFBUVFRUVFRUVFRUVFRUVFRUWFhYWFhYWFhYWFhYWFhYWFxcXFxcXFxcXFxcXFxcXFxgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxscEBESAAgHCQYKBQsEDAMNAg4BD25lZWQgZGljdGlvbmFyeQBzdHJlYW0gZW5kAGZpbGUgZXJyb3IAc3RyZWFtIGVycm9yAGRhdGEgZXJyb3IAaW5zdWZmaWNpZW50IG1lbW9yeQBidWZmZXIgZXJyb3IAaW5jb21wYXRpYmxlIHZlcnNpb24AMS4yLjExLW9wdGlwbmcAaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2sAaW52YWxpZCBkaXN0YW5jZSBjb2RlAGludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZQAlcwoAR0lGAE5vdCBhIEdJRiBmaWxlADg3YQA4OWEASW52YWxpZCBHSUYgdmVyc2lvbiBudW1iZXIsIG5vdCAiODdhIiBvciAiODlhIgBJbnZhbGlkIGRpbWVuc2lvbnMgaW4gR0lGIGltYWdlAEVycm9yIHJlYWRpbmcgR0lGIGZpbGUAVW5leHBlY3RlZCBlbmQgb2YgR0lGIGZpbGUAQm9ndXMgZGF0YSBpbiBHSUYgZmlsZQBPdXQgb2YgbWVtb3J5IGluIEdJRiBkZWNvZGVyAEludmFsaWQgTFpXIGNvZGUgc2l6ZQBFcnJvciBkZWNvZGluZyBHSUYgaW1hZ2UAUGl4ZWwgdmFsdWUgb3V0IG9mIHJhbmdlIGluIEdJRiBpbWFnZQAAAAD/////AAAA//8A/wD/AP8AAP///wBDaXJjdWxhciBkZXBlbmRlbmN5IGZvdW5kIGluIExaVyB0YWJsZQBSYW4gb2ZmIHRoZSBlbmQgb2YgaW5wdXQgYml0cyBpbiBMWlcgZGVjb2RpbmcATm90IGEgZ3JhcGhpYyBjb250cm9sIGV4dGVuc2lvbiBpbiBHSUYgZmlsZQBCcm9rZW4gZ3JhcGhpYyBjb250cm9sIGV4dGVuc2lvbiBpbiBHSUYgZmlsZQBVbnN1cHBvcnRlZCBkYXRhIGluIFRJRkYgZmlsZQBJbnZhbGlkIFRJRkYgZmlsZQBFcnJvciByZWFkaW5nIFRJRkYgZmlsZQBTZWxlY3RlZCBmaXJzdCBpbWFnZSBmcm9tIG11bHRpLWltYWdlIFRJRkYgZmlsZQBVbnJlY29nbml6ZWQgbWV0YWRhdGEgaW4gVElGRiBmaWxlAEVycm9yIGFsbG9jYXRpbmcgbWVtb3J5IGZvciBUSUZGIGZpbGUAVmFsdWUgb3V0IG9mIHRoZSBzdXBwb3J0ZWQgcmFuZ2UgaW4gVElGRiBmaWxlAEVycm9yIHJlcG9zaXRpb25pbmcgVElGRiBmaWxlAE5vdCBhIFRJRkYgZmlsZQBVbnN1cHBvcnRlZCBCaWdUSUZGIGZpbGUATU0AKklJKgBNTQArSUkrAEludmFsaWQgaW1hZ2UgZGltZW5zaW9ucyBpbiBUSUZGIGZpbGUASW52YWxpZCBwaXhlbCBpbmZvIGluIFRJRkYgZmlsZQBJbnZhbGlkIHN0cmlwIGluZm8gaW4gVElGRiBmaWxlAFVuc3VwcG9ydGVkIGNvbXByZXNzaW9uIG1ldGhvZCBpbiBUSUZGIGZpbGUAVW5zdXBwb3J0ZWQgcGhvdG9tZXRyaWMgaW50ZXJwcmV0YXRpb24gaW4gVElGRiBmaWxlAG1pbml0aWZmOiBlcnJvcjogJXMKAG1pbml0aWZmOiB3YXJuaW5nOiAlcwoAEQAKABEREQAAAAAFAAAAAAAACQAAAAALAAAAAAAAAAARAA8KERERAwoHAAETCQsLAAAJBgsAAAsABhEAAAAREREAAAAAAAAAAAAAAAAAAAAACwAAAAAAAAAAEQAKChEREQAKAAACAAkLAAAACQALAAALAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAADAAAAAAJDAAAAAAADAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAANAAAABA0AAAAACQ4AAAAAAA4AAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAADwAAAAAPAAAAAAkQAAAAAAAQAAAQAAASAAAAEhISAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAASEhIAAAAAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALAAAAAAAAAAAAAAAKAAAAAAoAAAAACQsAAAAAAAsAAAsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAMAAAAAAkMAAAAAAAMAAAMAAAtKyAgIDBYMHgAKG51bGwpAC0wWCswWCAwWC0weCsweCAweABpbmYASU5GAG5hbgBOQU4AMDEyMzQ1Njc4OUFCQ0RFRi4AVCEiGQ0BAgMRSxwMEAQLHRIeJ2hub3BxYiAFBg8TFBUaCBYHKCQXGAkKDhsfJSODgn0mKis8PT4/Q0dKTVhZWltcXV5fYGFjZGVmZ2lqa2xyc3R5ent8AElsbGVnYWwgYnl0ZSBzZXF1ZW5jZQBEb21haW4gZXJyb3IAUmVzdWx0IG5vdCByZXByZXNlbnRhYmxlAE5vdCBhIHR0eQBQZXJtaXNzaW9uIGRlbmllZABPcGVyYXRpb24gbm90IHBlcm1pdHRlZABObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5AE5vIHN1Y2ggcHJvY2VzcwBGaWxlIGV4aXN0cwBWYWx1ZSB0b28gbGFyZ2UgZm9yIGRhdGEgdHlwZQBObyBzcGFjZSBsZWZ0IG9uIGRldmljZQBPdXQgb2YgbWVtb3J5AFJlc291cmNlIGJ1c3kASW50ZXJydXB0ZWQgc3lzdGVtIGNhbGwAUmVzb3VyY2UgdGVtcG9yYXJpbHkgdW5hdmFpbGFibGUASW52YWxpZCBzZWVrAENyb3NzLWRldmljZSBsaW5rAFJlYWQtb25seSBmaWxlIHN5c3RlbQBEaXJlY3Rvcnkgbm90IGVtcHR5AENvbm5lY3Rpb24gcmVzZXQgYnkgcGVlcgBPcGVyYXRpb24gdGltZWQgb3V0AENvbm5lY3Rpb24gcmVmdXNlZABIb3N0IGlzIGRvd24ASG9zdCBpcyB1bnJlYWNoYWJsZQBBZGRyZXNzIGluIHVzZQBCcm9rZW4gcGlwZQBJL08gZXJyb3IATm8gc3VjaCBkZXZpY2Ugb3IgYWRkcmVzcwBCbG9jayBkZXZpY2UgcmVxdWlyZWQATm8gc3VjaCBkZXZpY2UATm90IGEgZGlyZWN0b3J5AElzIGEgZGlyZWN0b3J5AFRleHQgZmlsZSBidXN5AEV4ZWMgZm9ybWF0IGVycm9yAEludmFsaWQgYXJndW1lbnQAQXJndW1lbnQgbGlzdCB0b28gbG9uZwBTeW1ib2xpYyBsaW5rIGxvb3AARmlsZW5hbWUgdG9vIGxvbmcAVG9vIG1hbnkgb3BlbiBmaWxlcyBpbiBzeXN0ZW0ATm8gZmlsZSBkZXNjcmlwdG9ycyBhdmFpbGFibGUAQmFkIGZpbGUgZGVzY3JpcHRvcgBObyBjaGlsZCBwcm9jZXNzAEJhZCBhZGRyZXNzAEZpbGUgdG9vIGxhcmdlAFRvbyBtYW55IGxpbmtzAE5vIGxvY2tzIGF2YWlsYWJsZQBSZXNvdXJjZSBkZWFkbG9jayB3b3VsZCBvY2N1cgBTdGF0ZSBub3QgcmVjb3ZlcmFibGUAUHJldmlvdXMgb3duZXIgZGllZABPcGVyYXRpb24gY2FuY2VsZWQARnVuY3Rpb24gbm90IGltcGxlbWVudGVkAE5vIG1lc3NhZ2Ugb2YgZGVzaXJlZCB0eXBlAElkZW50aWZpZXIgcmVtb3ZlZABEZXZpY2Ugbm90IGEgc3RyZWFtAE5vIGRhdGEgYXZhaWxhYmxlAERldmljZSB0aW1lb3V0AE91dCBvZiBzdHJlYW1zIHJlc291cmNlcwBMaW5rIGhhcyBiZWVuIHNldmVyZWQAUHJvdG9jb2wgZXJyb3IAQmFkIG1lc3NhZ2UARmlsZSBkZXNjcmlwdG9yIGluIGJhZCBzdGF0ZQBOb3QgYSBzb2NrZXQARGVzdGluYXRpb24gYWRkcmVzcyByZXF1aXJlZABNZXNzYWdlIHRvbyBsYXJnZQBQcm90b2NvbCB3cm9uZyB0eXBlIGZvciBzb2NrZXQAUHJvdG9jb2wgbm90IGF2YWlsYWJsZQBQcm90b2NvbCBub3Qgc3VwcG9ydGVkAFNvY2tldCB0eXBlIG5vdCBzdXBwb3J0ZWQATm90IHN1cHBvcnRlZABQcm90b2NvbCBmYW1pbHkgbm90IHN1cHBvcnRlZABBZGRyZXNzIGZhbWlseSBub3Qgc3VwcG9ydGVkIGJ5IHByb3RvY29sAEFkZHJlc3Mgbm90IGF2YWlsYWJsZQBOZXR3b3JrIGlzIGRvd24ATmV0d29yayB1bnJlYWNoYWJsZQBDb25uZWN0aW9uIHJlc2V0IGJ5IG5ldHdvcmsAQ29ubmVjdGlvbiBhYm9ydGVkAE5vIGJ1ZmZlciBzcGFjZSBhdmFpbGFibGUAU29ja2V0IGlzIGNvbm5lY3RlZABTb2NrZXQgbm90IGNvbm5lY3RlZABDYW5ub3Qgc2VuZCBhZnRlciBzb2NrZXQgc2h1dGRvd24AT3BlcmF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3MAT3BlcmF0aW9uIGluIHByb2dyZXNzAFN0YWxlIGZpbGUgaGFuZGxlAFJlbW90ZSBJL08gZXJyb3IAUXVvdGEgZXhjZWVkZWQATm8gbWVkaXVtIGZvdW5kAFdyb25nIG1lZGl1bSB0eXBlAE5vIGVycm9yIGluZm9ybWF0aW9uAAD/////////////////////////////////////////////////////////////////AAECAwQFBgcICf////////8KCwwNDg8QERITFBUWFxgZGhscHR4fICEiI////////woLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIj/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wABAgQHAwYFAC9wcm9jL3NlbGYvZmQvAHJ3YQ==" ; /* no memory initializer */ var tempDoublePtr = STATICTOP ; STATICTOP += 16 ; assert ( tempDoublePtr % 8 == 0 ) ; function copyTempFloat ( ptr ) { // functions, because inlining this code increases code size too much HEAP8 [ tempDoublePtr ] = HEAP8 [ ptr ] ; HEAP8 [ tempDoublePtr + 1 ] = HEAP8 [ ptr + 1 ] ; HEAP8 [ tempDoublePtr + 2 ] = HEAP8 [ ptr + 2 ] ; HEAP8 [ tempDoublePtr + 3 ] = HEAP8 [ ptr + 3 ] ; } function copyTempDouble ( ptr ) { HEAP8 [ tempDoublePtr ] = HEAP8 [ ptr ] ; HEAP8 [ tempDoublePtr + 1 ] = HEAP8 [ ptr + 1 ] ; HEAP8 [ tempDoublePtr + 2 ] = HEAP8 [ ptr + 2 ] ; HEAP8 [ tempDoublePtr + 3 ] = HEAP8 [ ptr + 3 ] ; HEAP8 [ tempDoublePtr + 4 ] = HEAP8 [ ptr + 4 ] ; HEAP8 [ tempDoublePtr + 5 ] = HEAP8 [ ptr + 5 ] ; HEAP8 [ tempDoublePtr + 6 ] = HEAP8 [ ptr + 6 ] ; HEAP8 [ tempDoublePtr + 7 ] = HEAP8 [ ptr + 7 ] ; } // {{PRE_LIBRARY}} function ___assert_fail ( condition , filename , line , func ) { abort ( 'Assertion failed: ' + Pointer_stringify ( condition ) + ', at: ' + [ filename ? Pointer_stringify ( filename ) : 'unknown filename' , line , func ? Pointer_stringify ( func ) : 'unknown function' ] ) ; } function ___lock ( ) { } var ERRNO_CODES = { EPERM : 1 , ENOENT : 2 , ESRCH : 3 , EINTR : 4 , EIO : 5 , ENXIO : 6 , E2BIG : 7 , ENOEXEC : 8 , EBADF : 9 , ECHILD : 10 , EAGAIN : 11 , EWOULDBLOCK : 11 , ENOMEM : 12 , EACCES : 13 , EFAULT : 14 , ENOTBLK : 15 , EBUSY : 16 , EEXIST : 17 , EXDEV : 18 , ENODEV : 19 , ENOTDIR : 20 , EISDIR : 21 , EINVAL : 22 , ENFILE : 23 , EMFILE : 24 , ENOTTY : 25 , ETXTBSY : 26 , EFBIG : 27 , ENOSPC : 28 , ESPIPE : 29 , EROFS : 30 , EMLINK : 31 , EPIPE : 32 , EDOM : 33 , ERANGE : 34 , ENOMSG : 42 , EIDRM : 43 , ECHRNG : 44 , EL2NSYNC : 45 , EL3HLT : 46 , EL3RST : 47 , ELNRNG : 48 , EUNATCH : 49 , ENOCSI : 50 , EL2HLT : 51 , EDEADLK : 35 , ENOLCK : 37 , EBADE : 52 , EBADR : 53 , EXFULL : 54 , ENOANO : 55 , EBADRQC : 56 , EBADSLT : 57 , EDEADLOCK : 35 , EBFONT : 59 , ENOSTR : 60 , ENODATA : 61 , ETIME : 62 , ENOSR : 63 , ENONET : 64 , ENOPKG : 65 , EREMOTE : 66 , ENOLINK : 67 , EADV : 68 , ESRMNT : 69 , ECOMM : 70 , EPROTO : 71 , EMULTIHOP : 72 , EDOTDOT : 73 , EBADMSG : 74 , ENOTUNIQ : 76 , EBADFD : 77 , EREMCHG : 78 , ELIBACC : 79 , ELIBBAD : 80 , ELIBSCN : 81 , ELIBMAX : 82 , ELIBEXEC : 83 , ENOSYS : 38 , ENOTEMPTY : 39 , ENAMETOOLONG : 36 , ELOOP : 40 , EOPNOTSUPP : 95 , EPFNOSUPPORT : 96 , ECONNRESET : 104 , ENOBUFS : 105 , EAFNOSUPPORT : 97 , EPROTOTYPE : 91 , ENOTSOCK : 88 , ENOPROTOOPT : 92 , ESHUTDOWN : 108 , ECONNREFUSED : 111 , EADDRINUSE : 98 , ECONNABORTED : 103 , ENETUNREACH : 101 , ENETDOWN : 100 , ETIMEDOUT : 110 , EHOSTDOWN : 112 , EHOSTUNREACH : 113 , EINPROGRESS : 115 , EALREADY : 114 , EDESTADDRREQ : 89 , EMSGSIZE : 90 , EPROTONOSUPPORT : 93 , ESOCKTNOSUPPORT : 94 , EADDRNOTAVAIL : 99 , ENETRESET : 102 , EISCONN : 106 , ENOTCONN : 107 , ETOOMANYREFS : 109 , EUSERS : 87 , EDQUOT : 122 , ESTALE : 116 , ENOTSUP : 95 , ENOMEDIUM : 123 , EILSEQ : 84 , EOVERFLOW : 75 , ECANCELED : 125 , ENOTRECOVERABLE : 131 , EOWNERDEAD : 130 , ESTRPIPE : 86 } ; var ERRNO_MESSAGES = { 0 : "Success" , 1 : "Not super-user" , 2 : "No such file or directory" , 3 : "No such process" , 4 : "Interrupted system call" , 5 : "I/O error" , 6 : "No such device or address" , 7 : "Arg list too long" , 8 : "Exec format error" , 9 : "Bad file number" , 10 : "No children" , 11 : "No more processes" , 12 : "Not enough core" , 13 : "Permission denied" , 14 : "Bad address" , 15 : "Block device required" , 16 : "Mount device busy" , 17 : "File exists" , 18 : "Cross-device link" , 19 : "No such device" , 20 : "Not a directory" , 21 : "Is a directory" , 22 : "Invalid argument" , 23 : "Too many open files in system" , 24 : "Too many open files" , 25 : "Not a typewriter" , 26 : "Text file busy" , 27 : "File too large" , 28 : "No space left on device" , 29 : "Illegal seek" , 30 : "Read only file system" , 31 : "Too many links" , 32 : "Broken pipe" , 33 : "Math arg out of domain of func" , 34 : "Math result not representable" , 35 : "File locking deadlock error" , 36 : "File or path name too long" , 37 : "No record locks available" , 38 : "Function not implemented" , 39 : "Directory not empty" , 40 : "Too many symbolic links" , 42 : "No message of desired type" , 43 : "Identifier removed" , 44 : "Channel number out of range" , 45 : "Level 2 not synchronized" , 46 : "Level 3 halted" , 47 : "Level 3 reset" , 48 : "Link number out of range" , 49 : "Protocol driver not attached" , 50 : "No CSI structure available" , 51 : "Level 2 halted" , 52 : "Invalid exchange" , 53 : "Invalid request descriptor" , 54 : "Exchange full" , 55 : "No anode" , 56 : "Invalid request code" , 57 : "Invalid slot" , 59 : "Bad font file fmt" , 60 : "Device not a stream" , 61 : "No data (for no delay io)" , 62 : "Timer expired" , 63 : "Out of streams resources" , 64 : "Machine is not on the network" , 65 : "Package not installed" , 66 : "The object is remote" , 67 : "The link has been severed" , 68 : "Advertise error" , 69 : "Srmount error" , 70 : "Communication error on send" , 71 : "Protocol error" , 72 : "Multihop attempted" , 73 : "Cross mount point (not really error)" , 74 : "Trying to read unreadable message" , 75 : "Value too large for defined data type" , 76 : "Given log. name not unique" , 77 : "f.d. invalid for this operation" , 78 : "Remote address changed" , 79 : "Can   access a needed shared lib" , 80 : "Accessing a corrupted shared lib" , 81 : ".lib section in a.out corrupted" , 82 : "Attempting to link in too many libs" , 83 : "Attempting to exec a shared library" , 84 : "Illegal byte sequence" , 86 : "Streams pipe error" , 87 : "Too many users" , 88 : "Socket operation on non-socket" , 89 : "Destination address required" , 90 : "Message too long" , 91 : "Protocol wrong type for socket" , 92 : "Protocol not available" , 93 : "Unknown protocol" , 94 : "Socket type not supported" , 95 : "Not supported" , 96 : "Protocol family not supported" , 97 : "Address family not supported by protocol family" , 98 : "Address already in use" , 99 : "Address not available" , 100 : "Network interface is not configured" , 101 : "Network is unreachable" , 102 : "Connection reset by network" , 103 : "Connection aborted" , 104 : "Connection reset by peer" , 105 : "No buffer space available" , 106 : "Socket is already connected" , 107 : "Socket is not connected" , 108 : "Can't send after socket shutdown" , 109 : "Too many references" , 110 : "Connection timed out" , 111 : "Connection refused" , 112 : "Host is down" , 113 : "Host is unreachable" , 114 : "Socket already connected" , 115 : "Connection already in progress" , 116 : "Stale file handle" , 122 : "Quota exceeded" , 123 : "No medium (in tape drive)" , 125 : "Operation canceled" , 130 : "Previous owner died" , 131 : "State not recoverable" } ; function ___setErrNo ( value ) { if ( Module [ '___errno_location' ] ) HEAP32 [ ( ( Module [ '___errno_location' ] ( ) ) >> 2 ) ] = value ; else Module . printErr ( 'failed to set errno from JS' ) ; return value ; } var PATH = { splitPath : function ( filename ) { var splitPathRe = / ^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$ / ; return splitPathRe . exec ( filename ) . slice ( 1 ) ; } , normalizeArray : function ( parts , allowAboveRoot ) { // if the path tries to go above the root, `up` ends up > 0 var up = 0 ; for ( var i = parts . length - 1 ; i >= 0 ; i -- ) { var last = parts [ i ] ; if ( last === '.' ) { parts . splice ( i , 1 ) ; } else if ( last === '..' ) { parts . splice ( i , 1 ) ; up ++ ; } else if ( up ) { parts . splice ( i , 1 ) ; up -- ; } } // if the path is allowed to go above the root, restore leading ..s if ( allowAboveRoot ) { for ( ; up ; up -- ) { parts . unshift ( '..' ) ; } } return parts ; } , normalize : function ( path ) { var isAbsolute = path . charAt ( 0 ) === '/' , trailingSlash = path . substr ( - 1 ) === '/' ; // Normalize the path path = PATH . normalizeArray ( path . split ( '/' ) . filter ( function ( p ) { return ! ! p ; } ) , ! isAbsolute ) . join ( '/' ) ; if ( ! path && ! isAbsolute ) { path = '.' ; } if ( path && trailingSlash ) { path += '/' ; } return ( isAbsolute ? '/' : '' ) + path ; } , dirname : function ( path ) { var result = PATH . splitPath ( path ) , root = result [ 0 ] , dir = result [ 1 ] ; if ( ! root && ! dir ) { // No dirname whatsoever return '.' ; } if ( dir ) { // It has a dirname, strip trailing slash dir = dir . substr ( 0 , dir . length - 1 ) ; } return root + dir ; } , basename : function ( path ) { // EMSCRIPTEN return '/'' for '/', not an empty string if ( path === '/' ) return '/' ; var lastSlash = path . lastIndexOf ( '/' ) ; if ( lastSlash === - 1 ) return path ; return path . substr ( lastSlash + 1 ) ; } , extname : function ( path ) { return PATH . splitPath ( path ) [ 3 ] ; } , join : function ( ) { var paths = Array . prototype . slice . call ( arguments , 0 ) ; return PATH . normalize ( paths . join ( '/' ) ) ; } , join2 : function ( l , r ) { return PATH . normalize ( l + '/' + r ) ; } , resolve : function ( ) { var resolvedPath = '' , resolvedAbsolute = false ; for ( var i = arguments . length - 1 ; i >= - 1 && ! resolvedAbsolute ; i -- ) { var path = ( i >= 0 ) ? arguments [ i ] : FS . cwd ( ) ; // Skip empty and invalid entries if ( typeof path !== 'string' ) { throw new TypeError ( 'Arguments to path.resolve must be strings' ) ; } else if ( ! path ) { return '' ; // an invalid portion invalidates the whole thing } resolvedPath = path + '/' + resolvedPath ; resolvedAbsolute = path . charAt ( 0 ) === '/' ; } // At this point the path should be resolved to a full absolute path, but // handle relative paths to be safe (might happen when process.cwd() fails) resolvedPath = PATH . normalizeArray ( resolvedPath . split ( '/' ) . filter ( function ( p ) { return ! ! p ; } ) , ! resolvedAbsolute ) . join ( '/' ) ; return ( ( resolvedAbsolute ? '/' : '' ) + resolvedPath ) || '.' ; } , relative : function ( from , to ) { from = PATH . resolve ( from ) . substr ( 1 ) ; to = PATH . resolve ( to ) . substr ( 1 ) ; function trim ( arr ) { var start = 0 ; for ( ; start < arr . length ; start ++ ) { if ( arr [ start ] !== '' ) break ; } var end = arr . length - 1 ; for ( ; end >= 0 ; end -- ) { if ( arr [ end ] !== '' ) break ; } if ( start > end ) return [ ] ; return arr . slice ( start , end - start + 1 ) ; } var fromParts = trim ( from . split ( '/' ) ) ; var toParts = trim ( to . split ( '/' ) ) ; var length = Math . min ( fromParts . length , toParts . length ) ; var samePartsLength = length ; for ( var i = 0 ; i < length ; i ++ ) { if ( fromParts [ i ] !== toParts [ i ] ) { samePartsLength = i ; break ; } } var outputParts = [ ] ; for ( var i = samePartsLength ; i < fromParts . length ; i ++ ) { outputParts . push ( '..' ) ; } outputParts = outputParts . concat ( toParts . slice ( samePartsLength ) ) ; return outputParts . join ( '/' ) ; } } ; var TTY = { ttys : [ ] , init : function ( ) { // https://github.com/kripken/emscripten/pull/1555 // if (ENVIRONMENT_IS_NODE) { //   // currently, FS.init does not distinguish if process.stdin is a file or TTY //   // device, it always assumes it's a TTY device. because of this, we're forcing //   // process.stdin to UTF8 encoding to at least make stdin reading compatible //   // with text files until FS.init can be refactored. //   process['stdin']['setEncoding']('utf8'); // } } , shutdown : function ( ) { // https://github.com/kripken/emscripten/pull/1555 // if (ENVIRONMENT_IS_NODE) { //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)? //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists? //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call //   process['stdin']['pause'](); // } } , register : function ( dev , ops ) { TTY . ttys [ dev ] = { input : [ ] , output : [ ] , ops : ops } ; FS . registerDevice ( dev , TTY . stream_ops ) ; } , stream_ops : { open : function ( stream ) { var tty = TTY . ttys [ stream . node . rdev ] ; if ( ! tty ) { throw new FS . ErrnoError ( ERRNO_CODES . ENODEV ) ; } stream . tty = tty ; stream . seekable = false ; } , close : function ( stream ) { // flush any pending line data stream . tty . ops . flush ( stream . tty ) ; } , flush : function ( stream ) { stream . tty . ops . flush ( stream . tty ) ; } , read : function ( stream , buffer , offset , length , pos /* ignored */ ) { if ( ! stream . tty || ! stream . tty . ops . get_char ) { throw new FS . ErrnoError ( ERRNO_CODES . ENXIO ) ; } var bytesRead = 0 ; for ( var i = 0 ; i < length ; i ++ ) { var result ; try { result = stream . tty . ops . get_char ( stream . tty ) ; } catch ( e ) { throw new FS . ErrnoError ( ERRNO_CODES . EIO ) ; } if ( result === undefined && bytesRead === 0 ) { throw new FS . ErrnoError ( ERRNO_CODES . EAGAIN ) ; } if ( result === null || result === undefined ) break ; bytesRead ++ ; buffer [ offset + i ] = result ; } if ( bytesRead ) { stream . node . timestamp = Date . now ( ) ; } return bytesRead ; } , write : function ( stream , buffer , offset , length , pos ) { if ( ! stream . tty || ! stream . tty . ops . put_char ) { throw new FS . ErrnoError ( ERRNO_CODES . ENXIO ) ; } for ( var i = 0 ; i < length ; i ++ ) { try { stream . tty . ops . put_char ( stream . tty , buffer [ offset + i ] ) ; } catch ( e ) { throw new FS . ErrnoError ( ERRNO_CODES . EIO ) ; } } if ( length ) { stream . node . timestamp = Date . now ( ) ; } return i ; } } , default_tty_ops : { get_char : function ( tty ) { if ( ! tty . input . length ) { var result = null ; if ( ENVIRONMENT_IS_NODE ) { // we will read data by chunks of BUFSIZE var BUFSIZE = 256 ; var buf = new Buffer ( BUFSIZE ) ; var bytesRead = 0 ; var isPosixPlatform = ( process . platform != 'win32' ) ; // Node doesn't offer a direct check, so test by exclusion var fd = process . stdin . fd ; if ( isPosixPlatform ) { // Linux and Mac cannot use process.stdin.fd (which isn't set up as sync) var usingDevice = false ; try { fd = fs . openSync ( '/dev/stdin' , 'r' ) ; usingDevice = true ; } catch ( e ) { } } try { bytesRead = fs . readSync ( fd , buf , 0 , BUFSIZE , null ) ; } catch ( e ) { // Cross-platform differences: on Windows, reading EOF throws an exception, but on other OSes, // reading EOF returns 0. Uniformize behavior by treating the EOF exception to return 0. if ( e . toString ( ) . indexOf ( 'EOF' ) != - 1 ) bytesRead = 0 ; else throw e ; } if ( usingDevice ) { fs . closeSync ( fd ) ; } if ( bytesRead > 0 ) { result = buf . slice ( 0 , bytesRead ) . toString ( 'utf-8' ) ; } else { result = null ; } } else if ( typeof window != 'undefined' && typeof window . prompt == 'function' ) { // Browser. result = window . prompt ( 'Input: ' ) ; // returns null on cancel if ( result !== null ) { result += '\n' ; } } else if ( typeof readline == 'function' ) { // Command line. result = readline ( ) ; if ( result !== null ) { result += '\n' ; } } if ( ! result ) { return null ; } tty . input = intArrayFromString ( result , true ) ; } return tty . input . shift ( ) ; } , put_char : function ( tty , val ) { if ( val === null || val === 10 ) { Module [ 'print' ] ( UTF8ArrayToString ( tty . output , 0 ) ) ; tty . output = [ ] ; } else { if ( val != 0 ) tty . output . push ( val ) ; // val == 0 would cut text output off in the middle. } } , flush : function ( tty ) { if ( tty . output && tty . output . length > 0 ) { Module [ 'print' ] ( UTF8ArrayToString ( tty . output , 0 ) ) ; tty . output = [ ] ; } } } , default_tty1_ops : { put_char : function ( tty , val ) { if ( val === null || val === 10 ) { Module [ 'printErr' ] ( UTF8ArrayToString ( tty . output , 0 ) ) ; tty . output = [ ] ; } else { if ( val != 0 ) tty . output . push ( val ) ; } } , flush : function ( tty ) { if ( tty . output && tty . output . length > 0 ) { Module [ 'printErr' ] ( UTF8ArrayToString ( tty . output , 0 ) ) ; tty . output = [ ] ; } } } } ; var MEMFS = { ops_table : null , mount : function ( mount ) { return MEMFS . createNode ( null , '/' , 16384 | 511 /* 0777 */ , 0 ) ; } , createNode : function ( parent , name , mode , dev ) { if ( FS . isBlkdev ( mode ) || FS . isFIFO ( mode ) ) { // no supported throw new FS . ErrnoError ( ERRNO_CODES . EPERM ) ; } if ( ! MEMFS . ops_table ) { MEMFS . ops_table = { dir : { node : { getattr : MEMFS . node_ops . getattr , setattr : MEMFS . node_ops . setattr , lookup : MEMFS . node_ops . lookup , mknod : MEMFS . node_ops . mknod , rename : MEMFS . node_ops . rename , unlink : MEMFS . node_ops . unlink , rmdir : MEMFS . node_ops . rmdir , readdir : MEMFS . node_ops . readdir , symlink : MEMFS . node_ops . symlink } , stream : { llseek : MEMFS . stream_ops . llseek } } , file : { node : { getattr : MEMFS . node_ops . getattr , setattr : MEMFS . node_ops . setattr } , stream : { llseek : MEMFS . stream_ops . llseek , read : MEMFS . stream_ops . read , write : MEMFS . stream_ops . write , allocate : MEMFS . stream_ops . allocate , mmap : MEMFS . stream_ops . mmap , msync : MEMFS . stream_ops . msync } } , link : { node : { getattr : MEMFS . node_ops . getattr , setattr : MEMFS . node_ops . setattr , readlink : MEMFS . node_ops . readlink } , stream : { } } , chrdev : { node : { getattr : MEMFS . node_ops . getattr , setattr : MEMFS . node_ops . setattr } , stream : FS . chrdev_stream_ops } } ; } var node = FS . createNode ( parent , name , mode , dev ) ; if ( FS . isDir ( node . mode ) ) { node . node_ops = MEMFS . ops_table . dir . node ; node . stream_ops = MEMFS . ops_table . dir . stream ; node . contents = { } ; } else if ( FS . isFile ( node . mode ) ) { node . node_ops = MEMFS . ops_table . file . node ; node . stream_ops = MEMFS . ops_table . file . stream ; node . usedBytes = 0 ; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity. // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme. node . contents = null ; } else if ( FS . isLink ( node . mode ) ) { node . node_ops = MEMFS . ops_table . link . node ; node . stream_ops = MEMFS . ops_table . link . stream ; } else if ( FS . isChrdev ( node . mode ) ) { node . node_ops = MEMFS . ops_table . chrdev . node ; node . stream_ops = MEMFS . ops_table . chrdev . stream ; } node . timestamp = Date . now ( ) ; // add the new node to the parent if ( parent ) { parent . contents [ name ] = node ; } return node ; } , getFileDataAsRegularArray : function ( node ) { if ( node . contents && node . contents . subarray ) { var arr = [ ] ; for ( var i = 0 ; i < node . usedBytes ; ++ i ) arr . push ( node . contents [ i ] ) ; return arr ; // Returns a copy of the original data. } return node . contents ; // No-op, the file contents are already in a JS array. Return as-is. } , getFileDataAsTypedArray : function ( node ) { if ( ! node . contents ) return new Uint8Array ; if ( node . contents . subarray ) return node . contents . subarray ( 0 , node . usedBytes ) ; // Make sure to not return excess unused bytes. return new Uint8Array ( node . contents ) ; } , expandFileStorage : function ( node , newCapacity ) { // If we are asked to expand the size of a file that already exists, revert to using a standard JS array to store the file // instead of a typed array. This makes resizing the array more flexible because we can just .push() elements at the back to // increase the size. if ( node . contents && node . contents . subarray && newCapacity > node . contents . length ) { node . contents = MEMFS . getFileDataAsRegularArray ( node ) ; node . usedBytes = node . contents . length ; // We might be writing to a lazy-loaded file which had overridden this property, so force-reset it. } if ( ! node . contents || node . contents . subarray ) { // Keep using a typed array if creating a new storage, or if old one was a typed array as well. var prevCapacity = node . contents ? node . contents . length : 0 ; if ( prevCapacity >= newCapacity ) return ; // No need to expand, the storage was already large enough. // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity. // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to // avoid overshooting the allocation cap by a very large margin. var CAPACITY_DOUBLING_MAX = 1024 * 1024 ; newCapacity = Math . max ( newCapacity , ( prevCapacity * ( prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125 ) ) | 0 ) ; if ( prevCapacity != 0 ) newCapacity = Math . max ( newCapacity , 256 ) ; // At minimum allocate 256b for each file when expanding. var oldContents = node . contents ; node . contents = new Uint8Array ( newCapacity ) ; // Allocate new storage. if ( node . usedBytes > 0 ) node . contents . set ( oldContents . subarray ( 0 , node . usedBytes ) , 0 ) ; // Copy old data over to the new storage. return ; } // Not using a typed array to back the file storage. Use a standard JS array instead. if ( ! node . contents && newCapacity > 0 ) node . contents = [ ] ; while ( node . contents . length < newCapacity ) node . contents . push ( 0 ) ; } , resizeFileStorage : function ( node , newSize ) { if ( node . usedBytes == newSize ) return ; if ( newSize == 0 ) { node . contents = null ; // Fully decommit when requesting a resize to zero. node . usedBytes = 0 ; return ; } if ( ! node . contents || node . contents . subarray ) { // Resize a typed array if that is being used as the backing store. var oldContents = node . contents ; node . contents = new Uint8Array ( new ArrayBuffer ( newSize ) ) ; // Allocate new storage. if ( oldContents ) { node . contents . set ( oldContents . subarray ( 0 , Math . min ( newSize , node . usedBytes ) ) ) ; // Copy old data over to the new storage. } node . usedBytes = newSize ; return ; } // Backing with a JS array. if ( ! node . contents ) node . contents = [ ] ; if ( node . contents . length > newSize ) node . contents . length = newSize ; else while ( node . contents . length < newSize ) node . contents . push ( 0 ) ; node . usedBytes = newSize ; } , node_ops : { getattr : function ( node ) { var attr = { } ; // device numbers reuse inode numbers. attr . dev = FS . isChrdev ( node . mode ) ? node . id : 1 ; attr . ino = node . id ; attr . mode = node . mode ; attr . nlink = 1 ; attr . uid = 0 ; attr . gid = 0 ; attr . rdev = node . rdev ; if ( FS . isDir ( node . mode ) ) { attr . size = 4096 ; } else if ( FS . isFile ( node . mode ) ) { attr . size = node . usedBytes ; } else if ( FS . isLink ( node . mode ) ) { attr . size = node . link . length ; } else { attr . size = 0 ; } attr . atime = new Date ( node . timestamp ) ; attr . mtime = new Date ( node . timestamp ) ; attr . ctime = new Date ( node . timestamp ) ; // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize), //       but this is not required by the standard. attr . blksize = 4096 ; attr . blocks = Math . ceil ( attr . size / attr . blksize ) ; return attr ; } , setattr : function ( node , attr ) { if ( attr . mode !== undefined ) { node . mode = attr . mode ; } if ( attr . timestamp !== undefined ) { node . timestamp = attr . timestamp ; } if ( attr . size !== undefined ) { MEMFS . resizeFileStorage ( node , attr . size ) ; } } , lookup : function ( parent , name ) { throw FS . genericErrors [ ERRNO_CODES . ENOENT ] ; } , mknod : function ( parent , name , mode , dev ) { return MEMFS . createNode ( parent , name , mode , dev ) ; } , rename : function ( old_node , new_dir , new_name ) { // if we're overwriting a directory at new_name, make sure it's empty. if ( FS . isDir ( old_node . mode ) ) { var new_node ; try { new_node = FS . lookupNode ( new_dir , new_name ) ; } catch ( e ) { } if ( new_node ) { for ( var i in new_node . contents ) { throw new FS . ErrnoError ( ERRNO_CODES . ENOTEMPTY ) ; } } } // do the internal rewiring delete old_node . parent . contents [ old_node . name ] ; old_node . name = new_name ; new_dir . contents [ new_name ] = old_node ; old_node . parent = new_dir ; } , unlink : function ( parent , name ) { delete parent . contents [ name ] ; } , rmdir : function ( parent , name ) { var node = FS . lookupNode ( parent , name ) ; for ( var i in node . contents ) { throw new FS . ErrnoError ( ERRNO_CODES . ENOTEMPTY ) ; } delete parent . contents [ name ] ; } , readdir : function ( node ) { var entries = [ '.' , '..' ] for ( var key in node . contents ) { if ( ! node . contents . hasOwnProperty ( key ) ) { continue ; } entries . push ( key ) ; } return entries ; } , symlink : function ( parent , newname , oldpath ) { var node = MEMFS . createNode ( parent , newname , 511 /* 0777 */ | 40960 , 0 ) ; node . link = oldpath ; return node ; } , readlink : function ( node ) { if ( ! FS . isLink ( node . mode ) ) { throw new FS . ErrnoError ( ERRNO_CODES . EINVAL ) ; } return node . link ; } } , stream_ops : { read : function ( stream , buffer , offset , length , position ) { var contents = stream . node . contents ; if ( position >= stream . node . usedBytes ) return 0 ; var size = Math . min ( stream . node . usedBytes - position , length ) ; assert ( size >= 0 ) ; if ( size > 8 && contents . subarray ) { // non-trivial, and typed array buffer . set ( contents . subarray ( position , position + size ) , offset ) ; } else { for ( var i = 0 ; i < size ; i ++ ) buffer [ offset + i ] = contents [ position + i ] ; } return size ; } , write : function ( stream , buffer , offset , length , position , canOwn ) { if ( ! length ) return 0 ; var node = stream . node ; node . timestamp = Date . now ( ) ; if ( buffer . subarray && ( ! node . contents || node . contents . subarray ) ) { // This write is from a typed array to a typed array? if ( canOwn ) { assert ( position === 0 , 'canOwn must imply no weird position inside the file' ) ; node . contents = buffer . subarray ( offset , offset + length ) ; node . usedBytes = length ; return length ; } else if ( node . usedBytes === 0 && position === 0 ) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data. node . contents = new Uint8Array ( buffer . subarray ( offset , offset + length ) ) ; node . usedBytes = length ; return length ; } else if ( position + length <= node . usedBytes ) { // Writing to an already allocated and used subrange of the file? node . contents . set ( buffer . subarray ( offset , offset + length ) , position ) ; return length ; } } // Appending to an existing file and we need to reallocate, or source data did not come as a typed array. MEMFS . expandFileStorage ( node , position + length ) ; if ( node . contents . subarray && buffer . subarray ) node . contents . set ( buffer . subarray ( offset , offset + length ) , position ) ; // Use typed array write if available. else { for ( var i = 0 ; i < length ; i ++ ) { node . contents [ position + i ] = buffer [ offset + i ] ; // Or fall back to manual write if not. } } node . usedBytes = Math . max ( node . usedBytes , position + length ) ; return length ; } , llseek : function ( stream , offset , whence ) { var position = offset ; if ( whence === 1 ) { // SEEK_CUR. position += stream . position ; } else if ( whence === 2 ) { // SEEK_END. if ( FS . isFile ( stream . node . mode ) ) { position += stream . node . usedBytes ; } } if ( position < 0 ) { throw new FS . ErrnoError ( ERRNO_CODES . EINVAL ) ; } return position ; } , allocate : function ( stream , offset , length ) { MEMFS . expandFileStorage ( stream . node , offset + length ) ; stream . node . usedBytes = Math . max ( stream . node . usedBytes , offset + length ) ; } , mmap : function ( stream , buffer , offset , length , position , prot , flags ) { if ( ! FS . isFile ( stream . node . mode ) ) { throw new FS . ErrnoError ( ERRNO_CODES . ENODEV ) ; } var ptr ; var allocated ; var contents = stream . node . contents ; // Only make a new copy when MAP_PRIVATE is specified. if ( ! ( flags & 2 ) && ( contents . buffer === buffer || contents . buffer === buffer . buffer ) ) { // We can't emulate MAP_SHARED when the file is not backed by the buffer // we're mapping to (e.g. the HEAP buffer). allocated = false ; ptr = contents . byteOffset ; } else { // Try to avoid unnecessary slices. if ( position > 0 || position + length < stream . node . usedBytes ) { if ( contents . subarray ) { contents = contents . subarray ( position , position + length ) ; } else { contents = Array . prototype . slice . call ( contents , position , position + length ) ; } } allocated = true ; ptr = _malloc ( length ) ; if ( ! ptr ) { throw new FS . ErrnoError ( ERRNO_CODES . ENOMEM ) ; } buffer . set ( contents , ptr ) ; } return { ptr : ptr , allocated : allocated } ; } , msync : function ( stream , buffer , offset , length , mmapFlags ) { if ( ! FS . isFile ( stream . node . mode ) ) { throw new FS . ErrnoError ( ERRNO_CODES . ENODEV ) ; } if ( mmapFlags & 2 ) { // MAP_PRIVATE calls need not to be synced back to underlying fs return 0 ; } var bytesWritten = MEMFS . stream_ops . write ( stream , buffer , 0 , length , offset , false ) ; // should we check if bytesWritten and length are the same? return 0 ; } } } ; var IDBFS = { dbs : { } , indexedDB : function ( ) { if ( typeof indexedDB !== 'undefined' ) return indexedDB ; var ret = null ; if ( typeof window === 'object' ) ret = window . indexedDB || window . mozIndexedDB || window . webkitIndexedDB || window . msIndexedDB ; assert ( ret , 'IDBFS used, but indexedDB not supported' ) ; return ret ; } , DB_VERSION : 21 , DB_STORE_NAME : "FILE_DATA" , mount : function ( mount ) { // reuse all of the core MEMFS functionality return MEMFS . mount . apply ( null , arguments ) ; } , syncfs : function ( mount , populate , callback ) { IDBFS . getLocalSet ( mount , function ( err , local ) { if ( err ) return callback ( err ) ; IDBFS . getRemoteSet ( mount , function ( err , remote ) { if ( err ) return callback ( err ) ; var src = populate ? remote : local ; var dst = populate ? local : remote ; IDBFS . reconcile ( src , dst , callback ) ; } ) ; } ) ; } , getDB : function ( name , callback ) { // check the cache first var db = IDBFS . dbs [ name ] ; if ( db ) { return callback ( null , db ) ; } var req ; try { req = IDBFS . indexedDB ( ) . open ( name , IDBFS . DB_VERSION ) ; } catch ( e ) { return callback ( e ) ; } if ( ! req ) { return callback ( "Unable to connect to IndexedDB" ) ; } req . onupgradeneeded = function ( e ) { var db = e . target . result ; var transaction = e . target . transaction ; var fileStore ; if ( db . objectStoreNames . contains ( IDBFS . DB_STORE_NAME ) ) { fileStore = transaction . objectStore ( IDBFS . DB_STORE_NAME ) ; } else { fileStore = db . createObjectStore ( IDBFS . DB_STORE_NAME ) ; } if ( ! fileStore . indexNames . contains ( 'timestamp' ) ) { fileStore . createIndex ( 'timestamp' , 'timestamp' , { unique : false } ) ; } } ; req . onsuccess = function ( ) { db = req . result ; // add to the cache IDBFS . dbs [ name ] = db ; callback ( null , db ) ; } ; req . onerror = function ( e ) { callback ( this . error ) ; e . preventDefault ( ) ; } ; } , getLocalSet : function ( mount , callback ) { var entries = { } ; function isRealDir ( p ) { return p !== '.' && p !== '..' ; } ; function toAbsolute ( root ) { return function ( p ) { return PATH . join2 ( root , p ) ; } } ; var check = FS . readdir ( mount . mountpoint ) . filter ( isRealDir ) . map ( toAbsolute ( mount . mountpoint ) ) ; while ( check . length ) { var path = check . pop ( ) ; var stat ; try { stat = FS . stat ( path ) ; } catch ( e ) { return callback ( e ) ; } if ( FS . isDir ( stat . mode ) ) { check . push . apply ( check , FS . readdir ( path ) . filter ( isRealDir ) . map ( toAbsolute ( path ) ) ) ; } entries [ path ] = { timestamp : stat . mtime } ; } return callback ( null , { type : 'local' , entries : entries } ) ; } , getRemoteSet : function ( mount , callback ) { var entries = { } ; IDBFS . getDB ( mount . mountpoint , function ( err , db ) { if ( err ) return callback ( err ) ; try { var transaction = db . transaction ( [ IDBFS . DB_STORE_NAME ] , 'readonly' ) ; transaction . onerror = function ( e ) { callback ( this . error ) ; e . preventDefault ( ) ; } ; var store = transaction . objectStore ( IDBFS . DB_STORE_NAME ) ; var index = store . index ( 'timestamp' ) ; index . openKeyCursor ( ) . onsuccess = function ( event ) { var cursor = event . target . result ; if ( ! cursor ) { return callback ( null , { type : 'remote' , db : db , entries : entries } ) ; } entries [ cursor . primaryKey ] = { timestamp : cursor . key } ; cursor . continue ( ) ; } ; } catch ( e ) { return callback ( e ) ; } } ) ; } , loadLocalEntry : function ( path , callback ) { var stat , node ; try { var lookup = FS . lookupPath ( path ) ; node = lookup . node ; stat = FS . stat ( path ) ; } catch ( e ) { return callback ( e ) ; } if ( FS . isDir ( stat . mode ) ) { return callback ( null , { timestamp : stat . mtime , mode : stat . mode } ) ; } else if ( FS . isFile ( stat . mode ) ) { // Performance consideration: storing a normal JavaScript array to a IndexedDB is much slower than storing a typed array. // Therefore always convert the file contents to a typed array first before writing the data to IndexedDB. node . contents = MEMFS . getFileDataAsTypedArray ( node ) ; return callback ( null , { timestamp : stat . mtime , mode : stat . mode , contents : node . contents } ) ; } else { return callback ( new Error ( 'node type not supported' ) ) ; } } , storeLocalEntry : function ( path , entry , callback ) { try { if ( FS . isDir ( entry . mode ) ) { FS . mkdir ( path , entry . mode ) ; } else if ( FS . isFile ( entry . mode ) ) { FS . writeFile ( path , entry . contents , { canOwn : true } ) ; } else { return callback ( new Error ( 'node type not supported' ) ) ; } FS . chmod ( path , entry . mode ) ; FS . utime ( path , entry . timestamp , entry . timestamp ) ; } catch ( e ) { return callback ( e ) ; } callback ( null ) ; } , removeLocalEntry : function ( path , callback ) { try { var lookup = FS . lookupPath ( path ) ; var stat = FS . stat ( path ) ; if ( FS . isDir ( stat . mode ) ) { FS . rmdir ( path ) ; } else if ( FS . isFile ( stat . mode ) ) { FS . unlink ( path ) ; } } catch ( e ) { return callback ( e ) ; } callback ( null ) ; } , loadRemoteEntry : function ( store , path , callback ) { var req = store . get ( path ) ; req . onsuccess = function ( event ) { callback ( null , event . target . result ) ; } ; req . onerror = function ( e ) { callback ( this . error ) ; e . preventDefault ( ) ; } ; } , storeRemoteEntry : function ( store , path , entry , callback ) { var req = store . put ( entry , path ) ; req . onsuccess = function ( ) { callback ( null ) ; } ; req . onerror = function ( e ) { callback ( this . error ) ; e . preventDefault ( ) ; } ; } , removeRemoteEntry : function ( store , path , callback ) { var req = store . delete ( path ) ; req . onsuccess = function ( ) { callback ( null ) ; } ; req . onerror = function ( e ) { callback ( this . error ) ; e . preventDefault ( ) ; } ; } , reconcile : function ( src , dst , callback ) { var total = 0 ; var create = [ ] ; Object . keys ( src . entries ) . forEach ( function ( key ) { var e = src . entries [ key ] ; var e2 = dst . entries [ key ] ; if ( ! e2 || e . timestamp > e2 . timestamp ) { create . push ( key ) ; total ++ ; } } ) ; var remove = [ ] ; Object . keys ( dst . entries ) . forEach ( function ( key ) { var e = dst . entries [ key ] ; var e2 = src . entries [ key ] ; if ( ! e2 ) { remove . push ( key ) ; total ++ ; } } ) ; if ( ! total ) { return callback ( null ) ; } var errored = false ; var completed = 0 ; var db = src . type === 'remote' ? src . db : dst . db ; var transaction = db . transaction ( [ IDBFS . DB_STORE_NAME ] , 'readwrite' ) ; var store = transaction . objectStore ( IDBFS . DB_STORE_NAME ) ; function done ( err ) { if ( err ) { if ( ! done . errored ) { done . errored = true ; return callback ( err ) ; } return ; } if ( ++ completed >= total ) { return callback ( null ) ; } } ; transaction . onerror = function ( e ) { done ( this . error ) ; e . preventDefault ( ) ; } ; // sort paths in ascending order so directory entries are created // before the files inside them create . sort ( ) . forEach ( function ( path ) { if ( dst . type === 'local' ) { IDBFS . loadRemoteEntry ( store , path , function ( err , entry ) { if ( err ) return done ( err ) ; IDBFS . storeLocalEntry ( path , entry , done ) ; } ) ; } else { IDBFS . loadLocalEntry ( path , function ( err , entry ) { if ( err ) return done ( err ) ; IDBFS . storeRemoteEntry ( store , path , entry , done ) ; } ) ; } } ) ; // sort paths in descending order so files are deleted before their // parent directories remove . sort ( ) . reverse ( ) . forEach ( function ( path ) { if ( dst . type === 'local' ) { IDBFS . removeLocalEntry ( path , done ) ; } else { IDBFS . removeRemoteEntry ( store , path , done ) ; } } ) ; } } ; var NODEFS = { isWindows : false , staticInit : function ( ) { NODEFS . isWindows = ! ! process . platform . match ( / ^win / ) ; var flags = process [ "binding" ] ( "constants" ) ; // Node.js 4 compatibility: it has no namespaces for constants if ( flags [ "fs" ] ) { flags = flags [ "fs" ] ; } NODEFS . flagsForNodeMap = { "1024" : flags [ "O_APPEND" ] , "64" : flags [ "O_CREAT" ] , "128" : flags [ "O_EXCL" ] , "0" : flags [ "O_RDONLY" ] , "2" : flags [ "O_RDWR" ] , "4096" : flags [ "O_SYNC" ] , "512" : flags [ "O_TRUNC" ] , "1" : flags [ "O_WRONLY" ] } ; } , bufferFrom : function ( arrayBuffer ) { // Node.js < 4.5 compatibility: Buffer.from does not support ArrayBuffer // Buffer.from before 4.5 was just a method inherited from Uint8Array // Buffer.alloc has been added with Buffer.from together, so check it instead return Buffer . alloc ? Buffer . from ( arrayBuffer ) : new Buffer ( arrayBuffer ) ; } , mount : function ( mount ) { assert ( ENVIRONMENT_IS_NODE ) ; return NODEFS . createNode ( null , '/' , NODEFS . getMode ( mount . opts . root ) , 0 ) ; } , createNode : function ( parent , name , mode , dev ) { if ( ! FS . isDir ( mode ) && ! FS . isFile ( mode ) && ! FS . isLink ( mode ) ) { throw new FS . ErrnoError ( ERRNO_CODES . EINVAL ) ; } var node = FS . createNode ( parent , name , mode ) ; node . node_ops = NODEFS . node_ops ; node . stream_ops = NODEFS . stream_ops ; return node ; } , getMode : function ( path ) { var stat ; try { stat = fs . lstatSync ( path ) ; if ( NODEFS . isWindows ) { // Node.js on Windows never represents permission bit 'x', so // propagate read bits to execute bits stat . mode = stat . mode | ( ( stat . mode & 292 ) >> 2 ) ; } } catch ( e ) { if ( ! e . code ) throw e ; throw new FS . ErrnoError ( ERRNO_CODES [ e . code ] ) ; } return stat . mode ; } , realPath : function ( node ) { var parts = [ ] ; while ( node . parent !== node ) { parts . push ( node . name ) ; node = node . parent ; } parts . push ( node . mount . opts . root ) ; parts . reverse ( ) ; return PATH . join . apply ( null , parts ) ; } , flagsForNode : function ( flags ) { flags &= ~ 0x200000 /*O_PATH*/ ; // Ignore this flag from musl, otherwise node.js fails to open the file. flags &= ~ 0x800 /*O_NONBLOCK*/ ; // Ignore this flag from musl, otherwise node.js fails to open the file. flags &= ~ 0x8000 /*O_LARGEFILE*/ ; // Ignore this flag from musl, otherwise node.js fails to open the file. flags &= ~ 0x80000 /*O_CLOEXEC*/ ; // Some applications may pass it; it makes no sense for a single process. var newFlags = 0 ; for ( var k in NODEFS . flagsForNodeMap ) { if ( flags & k ) { newFlags |= NODEFS . flagsForNodeMap [ k ] ; flags ^= k ; } } if ( ! flags ) { return newFlags ; } else { throw new FS . ErrnoError ( ERRNO_CODES . EINVAL ) ; } } , node_ops : { getattr : function ( node ) { var path = NODEFS . realPath ( node ) ; var stat ; try { stat = fs . lstatSync ( path ) ; } catch ( e ) { if ( ! e . code ) throw e ; throw new FS . ErrnoError ( ERRNO_CODES [ e . code ] ) ; } // node.js v0.10.20 doesn't report blksize and blocks on Windows. Fake them with default blksize of 4096. // See http://support.microsoft.com/kb/140365 if ( NODEFS . isWindows && ! stat . blksize ) { stat . blksize = 4096 ; } if ( NODEFS . isWindows && ! stat . blocks ) { stat . blocks = ( stat . size + stat . blksize - 1 ) / stat . blksize | 0 ; } return { dev : stat . dev , ino : stat . ino , mode : stat . mode , nlink : stat . nlink , uid : stat . uid , gid : stat . gid , rdev : stat . rdev , size : stat . size , atime : stat . atime , mtime : stat . mtime , ctime : stat . ctime , blksize : stat . blksize , blocks : stat . blocks } ; } , setattr : function ( node , attr ) { var path = NODEFS . realPath ( node ) ; try { if ( attr . mode !== undefined ) { fs . chmodSync ( path , attr . mode ) ; // update the common node structure mode as well node . mode = attr . mode ; } if ( attr . timestamp !== undefined ) { var date = new Date ( attr . timestamp ) ; fs . utimesSync ( path , date , date ) ; } if ( attr . size !== undefined ) { fs . truncateSync ( path , attr . size ) ; } } catch ( e ) { if ( ! e . code ) throw e ; throw new FS . ErrnoError ( ERRNO_CODES [ e . code ] ) ; } } , lookup : function ( parent , name ) { var path = PATH . join2 ( NODEFS . realPath ( parent ) , name ) ; var mode = NODEFS . getMode ( path ) ; return NODEFS . createNode ( parent , name , mode ) ; } , mknod : function ( parent , name , mode , dev ) { var node = NODEFS . createNode ( parent , name , mode , dev ) ; // create the backing node for this in the fs root as well var path = NODEFS . realPath ( node ) ; try { if ( FS . isDir ( node . mode ) ) { fs . mkdirSync ( path , node . mode ) ; } else { fs . writeFileSync ( path , '' , { mode : node . mode } ) ; } } catch ( e ) { if ( ! e . code ) throw e ; throw new FS . ErrnoError ( ERRNO_CODES [ e . code ] ) ; } return node ; } , rename : function ( oldNode , newDir , newName ) { var oldPath = NODEFS . realPath ( oldNode ) ; var newPath = PATH . join2 ( NODEFS . realPath ( newDir ) , newName ) ; try { fs . renameSync ( oldPath , newPath ) ; } catch ( e ) { if ( ! e . code ) throw e ; throw new FS . ErrnoError ( ERRNO_CODES [ e . code ] ) ; } } , unlink : function ( parent , name ) { var path = PATH . join2 ( NODEFS . realPath ( parent ) , name ) ; try { fs . unlinkSync ( path ) ; } catch ( e ) { if ( ! e . code ) throw e ; throw new FS . ErrnoError ( ERRNO_CODES [ e . code ] ) ; } } , rmdir : function ( parent , name ) { var path = PATH . join2 ( NODEFS . realPath ( parent ) , name ) ; try { fs . rmdirSync ( path ) ; } catch ( e ) { if ( ! e . code ) throw e ; throw new FS . ErrnoError ( ERRNO_CODES [ e . code ] ) ; } } , readdir : function ( node ) { var path = NODEFS . realPath ( node ) ; try { return fs . readdirSync ( path ) ; } catch ( e ) { if ( ! e . code ) throw e ; throw new FS . ErrnoError ( ERRNO_CODES [ e . code ] ) ; } } , symlink : function ( parent , newName , oldPath ) { var newPath = PATH . join2 ( NODEFS . realPath ( parent ) , newName ) ; try { fs . symlinkSync ( oldPath , newPath ) ; } catch ( e ) { if ( ! e . code ) throw e ; throw new FS . ErrnoError ( ERRNO_CODES [ e . code ] ) ; } } , readlink : function ( node ) { var path = NODEFS . realPath ( node ) ; try { path = fs . readlinkSync ( path ) ; path = NODEJS_PATH . relative ( NODEJS_PATH . resolve ( node . mount . opts . root ) , path ) ; return path ; } catch ( e ) { if ( ! e . code ) throw e ; throw new FS . ErrnoError ( ERRNO_CODES [ e . code ] ) ; } } } , stream_ops : { open : function ( stream ) { var path = NODEFS . realPath ( stream . node ) ; try { if ( FS . isFile ( stream . node . mode ) ) { stream . nfd = fs . openSync ( path , NODEFS . flagsForNode ( stream . flags ) ) ; } } catch ( e ) { if ( ! e . code ) throw e ; throw new FS . ErrnoError ( ERRNO_CODES [ e . code ] ) ; } } , close : function ( stream ) { try { if ( FS . isFile ( stream . node . mode ) && stream . nfd ) { fs . closeSync ( stream . nfd ) ; } } catch ( e ) { if ( ! e . code ) throw e ; throw new FS . ErrnoError ( ERRNO_CODES [ e . code ] ) ; } } , read : function ( stream , buffer , offset , length , position ) { // Node.js < 6 compatibility: node errors on 0 length reads if ( length === 0 ) return 0 ; try { return fs . readSync ( stream . nfd , NODEFS . bufferFrom ( buffer . buffer ) , offset , length , position ) ; } catch ( e ) { throw new FS . ErrnoError ( ERRNO_CODES [ e . code ] ) ; } } , write : function ( stream , buffer , offset , length , position ) { try { return fs . writeSync ( stream . nfd , NODEFS . bufferFrom ( buffer . buffer ) , offset , length , position ) ; } catch ( e ) { throw new FS . ErrnoError ( ERRNO_CODES [ e . code ] ) ; } } , llseek : function ( stream , offset , whence ) { var position = offset ; if ( whence === 1 ) { // SEEK_CUR. position += stream . position ; } else if ( whence === 2 ) { // SEEK_END. if ( FS . isFile ( stream . node . mode ) ) { try { var stat = fs . fstatSync ( stream . nfd ) ; position += stat . size ; } catch ( e ) { throw new FS . ErrnoError ( ERRNO_CODES [ e . code ] ) ; } } } if ( position < 0 ) { throw new FS . ErrnoError ( ERRNO_CODES . EINVAL ) ; } return position ; } } } ; var WORKERFS = { DIR_MODE : 16895 , FILE_MODE : 33279 , reader : null , mount : function ( mount ) { assert ( ENVIRONMENT_IS_WORKER ) ; if ( ! WORKERFS . reader ) WORKERFS . reader = new FileReaderSync ( ) ; var root = WORKERFS . createNode ( null , '/' , WORKERFS . DIR_MODE , 0 ) ; var createdParents = { } ; function ensureParent ( path ) { // return the parent node, creating subdirs as necessary var parts = path . split ( '/' ) ; var parent = root ; for ( var i = 0 ; i < parts . length - 1 ; i ++ ) { var curr = parts . slice ( 0 , i + 1 ) . join ( '/' ) ; // Issue 4254: Using curr as a node name will prevent the node // from being found in FS.nameTable when FS.open is called on // a path which holds a child of this node, // given that all FS functions assume node names // are just their corresponding parts within their given path, // rather than incremental aggregates which include their parent's // directories. if ( ! createdParents [ curr ] ) { createdParents [ curr ] = WORKERFS . createNode ( parent , parts [ i ] , WORKERFS . DIR_MODE , 0 ) ; } parent = createdParents [ curr ] ; } return parent ; } function base ( path ) { var parts = path . split ( '/' ) ; return parts [ parts . length - 1 ] ; } // We also accept FileList here, by using Array.prototype Array . prototype . forEach . call ( mount . opts [ "files" ] || [ ] , function ( file ) { WORKERFS . createNode ( ensureParent ( file . name ) , base ( file . name ) , WORKERFS . FILE_MODE , 0 , file , file . lastModifiedDate ) ; } ) ; ( mount . opts [ "blobs" ] || [ ] ) . forEach ( function ( obj ) { WORKERFS . createNode ( ensureParent ( obj [ "name" ] ) , base ( obj [ "name" ] ) , WORKERFS . FILE_MODE , 0 , obj [ "data" ] ) ; } ) ; ( mount . opts [ "packages" ] || [ ] ) . forEach ( function ( pack ) { pack [ 'metadata' ] . files . forEach ( function ( file ) { var name = file . filename . substr ( 1 ) ; // remove initial slash WORKERFS . createNode ( ensureParent ( name ) , base ( name ) , WORKERFS . FILE_MODE , 0 , pack [ 'blob' ] . slice ( file . start , file . end ) ) ; } ) ; } ) ; return root ; } , createNode : function ( parent , name , mode , dev , contents , mtime ) { var node = FS . createNode ( parent , name , mode ) ; node . mode = mode ; node . node_ops = WORKERFS . node_ops ; node . stream_ops = WORKERFS . stream_ops ; node . timestamp = ( mtime || new Date ) . getTime ( ) ; assert ( WORKERFS . FILE_MODE !== WORKERFS . DIR_MODE ) ; if ( mode === WORKERFS . FILE_MODE ) { node . size = contents . size ; node . contents = contents ; } else { node . size = 4096 ; node . contents = { } ; } if ( parent ) { parent . contents [ name ] = node ; } return node ; } , node_ops : { getattr : function ( node ) { return { dev : 1 , ino : undefined , mode : node . mode , nlink : 1 , uid : 0 , gid : 0 , rdev : undefined , size : node . size , atime : new Date ( node . timestamp ) , mtime : new Date ( node . timestamp ) , ctime : new Date ( node . timestamp ) , blksize : 4096 , blocks : Math . ceil ( node . size / 4096 ) , } ; } , setattr : function ( node , attr ) { if ( attr . mode !== undefined ) { node . mode = attr . mode ; } if ( attr . timestamp !== undefined ) { node . timestamp = attr . timestamp ; } } , lookup : function ( parent , name ) { throw new FS . ErrnoError ( ERRNO_CODES . ENOENT ) ; } , mknod : function ( parent , name , mode , dev ) { throw new FS . ErrnoError ( ERRNO_CODES . EPERM ) ; } , rename : function ( oldNode , newDir , newName ) { throw new FS . ErrnoError ( ERRNO_CODES . EPERM ) ; } , unlink : function ( parent , name ) { throw new FS . ErrnoError ( ERRNO_CODES . EPERM ) ; } , rmdir : function ( parent , name ) { throw new FS . ErrnoError ( ERRNO_CODES . EPERM ) ; } , readdir : function ( node ) { var entries = [ '.' , '..' ] ; for ( var key in node . contents ) { if ( ! node . contents . hasOwnProperty ( key ) ) { continue ; } entries . push ( key ) ; } return entries ; } , symlink : function ( parent , newName , oldPath ) { throw new FS . ErrnoError ( ERRNO_CODES . EPERM ) ; } , readlink : function ( node ) { throw new FS . ErrnoError ( ERRNO_CODES . EPERM ) ; } } , stream_ops : { read : function ( stream , buffer , offset , length , position ) { if ( position >= stream . node . size ) return 0 ; var chunk = stream . node . contents . slice ( position , position + length ) ; var ab = WORKERFS . reader . readAsArrayBuffer ( chunk ) ; buffer . set ( new Uint8Array ( ab ) , offset ) ; return chunk . size ; } , write : function ( stream , buffer , offset , length , position ) { throw new FS . ErrnoError ( ERRNO_CODES . EIO ) ; } , llseek : function ( stream , offset , whence ) { var position = offset ; if ( whence === 1 ) { // SEEK_CUR. position += stream . position ; } else if ( whence === 2 ) { // SEEK_END. if ( FS . isFile ( stream . node . mode ) ) { position += stream . node . size ; } } if ( position < 0 ) { throw new FS . ErrnoError ( ERRNO_CODES . EINVAL ) ; } return position ; } } } ; var _stdin = STATICTOP ; STATICTOP += 16 ; ; var _stdout = STATICTOP ; STATICTOP += 16 ; ; var _stderr = STATICTOP ; STATICTOP += 16 ; ; var FS = { root : null , mounts : [ ] , devices : { } , streams : [ ] , nextInode : 1 , nameTable : null , currentPath : "/" , initialized : false , ignorePermissions : true , trackingDelegate : { } , tracking : { openFlags : { READ : 1 , WRITE : 2 } } , ErrnoError : null , genericErrors : { } , filesystems : null , syncFSRequests : 0 , handleFSError : function ( e ) { if ( ! ( e instanceof FS . ErrnoError ) ) throw e + ' : ' + stackTrace ( ) ; return ___setErrNo ( e . errno ) ; } , lookupPath : function ( path , opts ) { path = PATH . resolve ( FS . cwd ( ) , path ) ; opts = opts || { } ; if ( ! path ) return { path : '' , node : null } ; var defaults = { follow_mount : true , recurse_count : 0 } ; for ( var key in defaults ) { if ( opts [ key ] === undefined ) { opts [ key ] = defaults [ key ] ; } } if ( opts . recurse_count > 8 ) { // max recursive lookup of 8 throw new FS . ErrnoError ( ERRNO_CODES . ELOOP ) ; } // split the path var parts = PATH . normalizeArray ( path . split ( '/' ) . filter ( function ( p ) { return ! ! p ; } ) , false ) ; // start at the root var current = FS . root ; var current_path = '/' ; for ( var i = 0 ; i < parts . length ; i ++ ) { var islast = ( i === parts . length - 1 ) ; if ( islast && opts . parent ) { // stop resolving break ; } current = FS . lookupNode ( current , parts [ i ] ) ; current_path = PATH . join2 ( current_path , parts [ i ] ) ; // jump to the mount's root node if this is a mountpoint if ( FS . isMountpoint ( current ) ) { if ( ! islast || ( islast && opts . follow_mount ) ) { current = current . mounted . root ; } } // by default, lookupPath will not follow a symlink if it is the final path component. // setting opts.follow = true will override this behavior. if ( ! islast || opts . follow ) { var count = 0 ; while ( FS . isLink ( current . mode ) ) { var link = FS . readlink ( current_path ) ; current_path = PATH . resolve ( PATH . dirname ( current_path ) , link ) ; var lookup = FS . lookupPath ( current_path , { recurse_count : opts . recurse_count } ) ; current = lookup . node ; if ( count ++ > 40 ) { // limit max consecutive symlinks to 40 (SYMLOOP_MAX). throw new FS . ErrnoError ( ERRNO_CODES . ELOOP ) ; } } } } return { path : current_path , node : current } ; } , getPath : function ( node ) { var path ; while ( true ) { if ( FS . isRoot ( node ) ) { var mount = node . mount . mountpoint ; if ( ! path ) return mount ; return mount [ mount . length - 1 ] !== '/' ? mount + '/' + path : mount + path ; } path = path ? node . name + '/' + path : node . name ; node = node . parent ; } } , hashName : function ( parentid , name ) { var hash = 0 ; for ( var i = 0 ; i < name . length ; i ++ ) { hash = ( ( hash << 5 ) - hash + name . charCodeAt ( i ) ) | 0 ; } return ( ( parentid + hash ) >>> 0 ) % FS . nameTable . length ; } , hashAddNode : function ( node ) { var hash = FS . hashName ( node . parent . id , node . name ) ; node . name_next = FS . nameTable [ hash ] ; FS . nameTable [ hash ] = node ; } , hashRemoveNode : function ( node ) { var hash = FS . hashName ( node . parent . id , node . name ) ; if ( FS . nameTable [ hash ] === node ) { FS . nameTable [ hash ] = node . name_next ; } else { var current = FS . nameTable [ hash ] ; while ( current ) { if ( current . name_next === node ) { current . name_next = node . name_next ; break ; } current = current . name_next ; } } } , lookupNode : function ( parent , name ) { var err = FS . mayLookup ( parent ) ; if ( err ) { throw new FS . ErrnoError ( err , parent ) ; } var hash = FS . hashName ( parent . id , name ) ; for ( var node = FS . nameTable [ hash ] ; node ; node = node . name_next ) { var nodeName = node . name ; if ( node . parent . id === parent . id && nodeName === name ) { return node ; } } // if we failed to find it in the cache, call into the VFS return FS . lookup ( parent , name ) ; } , createNode : function ( parent , name , mode , rdev ) { if ( ! FS . FSNode ) { FS . FSNode = function ( parent , name , mode , rdev ) { if ( ! parent ) { parent = this ; // root node sets parent to itself } this . parent = parent ; this . mount = parent . mount ; this . mounted = null ; this . id = FS . nextInode ++ ; this . name = name ; this . mode = mode ; this . node_ops = { } ; this . stream_ops = { } ; this . rdev = rdev ; } ; FS . FSNode . prototype = { } ; // compatibility var readMode = 292 | 73 ; var writeMode = 146 ; // NOTE we must use Object.defineProperties instead of individual calls to // Object.defineProperty in order to make closure compiler happy Object . defineProperties ( FS . FSNode . prototype , { read : { get : function ( ) { return ( this . mode & readMode ) === readMode ; } , set : function ( val ) { val ? this . mode |= readMode : this . mode &= ~ readMode ; } } , write : { get : function ( ) { return ( this . mode & writeMode ) === writeMode ; } , set : function ( val ) { val ? this . mode |= writeMode : this . mode &= ~ writeMode ; } } , isFolder : { get : function ( ) { return FS . isDir ( this . mode ) ; } } , isDevice : { get : function ( ) { return FS . isChrdev ( this . mode ) ; } } } ) ; } var node = new FS . FSNode ( parent , name , mode , rdev ) ; FS . hashAddNode ( node ) ; return node ; } , destroyNode : function ( node ) { FS . hashRemoveNode ( node ) ; } , isRoot : function ( node ) { return node === node . parent ; } , isMountpoint : function ( node ) { return ! ! node . mounted ; } , isFile : function ( mode ) { return ( mode & 61440 ) === 32768 ; } , isDir : function ( mode ) { return ( mode & 61440 ) === 16384 ; } , isLink : function ( mode ) { return ( mode & 61440 ) === 40960 ; } , isChrdev : function ( mode ) { return ( mode & 61440 ) === 8192 ; } , isBlkdev : function ( mode ) { return ( mode & 61440 ) === 24576 ; } , isFIFO : function ( mode ) { return ( mode & 61440 ) === 4096 ; } , isSocket : function ( mode ) { return ( mode & 49152 ) === 49152 ; } , flagModes : { "r" : 0 , "rs" : 1052672 , "r+" : 2 , "w" : 577 , "wx" : 705 , "xw" : 705 , "w+" : 578 , "wx+" : 706 , "xw+" : 706 , "a" : 1089 , "ax" : 1217 , "xa" : 1217 , "a+" : 1090 , "ax+" : 1218 , "xa+" : 1218 } , modeStringToFlags : function ( str ) { var flags = FS . flagModes [ str ] ; if ( typeof flags === 'undefined' ) { throw new Error ( 'Unknown file open mode: ' + str ) ; } return flags ; } , flagsToPermissionString : function ( flag ) { var perms = [ 'r' , 'w' , 'rw' ] [ flag & 3 ] ; if ( ( flag & 512 ) ) { perms += 'w' ; } return perms ; } , nodePermissions : function ( node , perms ) { if ( FS . ignorePermissions ) { return 0 ; } // return 0 if any user, group or owner bits are set. if ( perms . indexOf ( 'r' ) !== - 1 && ! ( node . mode & 292 ) ) { return ERRNO_CODES . EACCES ; } else if ( perms . indexOf ( 'w' ) !== - 1 && ! ( node . mode & 146 ) ) { return ERRNO_CODES . EACCES ; } else if ( perms . indexOf ( 'x' ) !== - 1 && ! ( node . mode & 73 ) ) { return ERRNO_CODES . EACCES ; } return 0 ; } , mayLookup : function ( dir ) { var err = FS . nodePermissions ( dir , 'x' ) ; if ( err ) return err ; if ( ! dir . node_ops . lookup ) return ERRNO_CODES . EACCES ; return 0 ; } , mayCreate : function ( dir , name ) { try { var node = FS . lookupNode ( dir , name ) ; return ERRNO_CODES . EEXIST ; } catch ( e ) { } return FS . nodePermissions ( dir , 'wx' ) ; } , mayDelete : function ( dir , name , isdir ) { var node ; try { node = FS . lookupNode ( dir , name ) ; } catch ( e ) { return e . errno ; } var err = FS . nodePermissions ( dir , 'wx' ) ; if ( err ) { return err ; } if ( isdir ) { if ( ! FS . isDir ( node . mode ) ) { return ERRNO_CODES . ENOTDIR ; } if ( FS . isRoot ( node ) || FS . getPath ( node ) === FS . cwd ( ) ) { return ERRNO_CODES . EBUSY ; } } else { if ( FS . isDir ( node . mode ) ) { return ERRNO_CODES . EISDIR ; } } return 0 ; } , mayOpen : function ( node , flags ) { if ( ! node ) { return ERRNO_CODES . ENOENT ; } if ( FS . isLink ( node . mode ) ) { return ERRNO_CODES . ELOOP ; } else if ( FS . isDir ( node . mode ) ) { if ( FS . flagsToPermissionString ( flags ) !== 'r' || // opening for write ( flags & 512 ) ) { // TODO: check for O_SEARCH? (== search for dir only) return ERRNO_CODES . EISDIR ; } } return FS . nodePermissions ( node , FS . flagsToPermissionString ( flags ) ) ; } , MAX_OPEN_FDS : 4096 , nextfd : function ( fd_start , fd_end ) { fd_start = fd_start || 0 ; fd_end = fd_end || FS . MAX_OPEN_FDS ; for ( var fd = fd_start ; fd <= fd_end ; fd ++ ) { if ( ! FS . streams [ fd ] ) { return fd ; } } throw new FS . ErrnoError ( ERRNO_CODES . EMFILE ) ; } , getStream : function ( fd ) { return FS . streams [ fd ] ; } , createStream : function ( stream , fd_start , fd_end ) { if ( ! FS . FSStream ) { FS . FSStream = function ( ) { } ; FS . FSStream . prototype = { } ; // compatibility Object . defineProperties ( FS . FSStream . prototype , { object : { get : function ( ) { return this . node ; } , set : function ( val ) { this . node = val ; } } , isRead : { get : function ( ) { return ( this . flags & 2097155 ) !== 1 ; } } , isWrite : { get : function ( ) { return ( this . flags & 2097155 ) !== 0 ; } } , isAppend : { get : function ( ) { return ( this . flags & 1024 ) ; } } } ) ; } // clone it, so we can return an instance of FSStream var newStream = new FS . FSStream ( ) ; for ( var p in stream ) { newStream [ p ] = stream [ p ] ; } stream = newStream ; var fd = FS . nextfd ( fd_start , fd_end ) ; stream . fd = fd ; FS . streams [ fd ] = stream ; return stream ; } , closeStream : function ( fd ) { FS . streams [ fd ] = null ; } , chrdev_stream_ops : { open : function ( stream ) { var device = FS . getDevice ( stream . node . rdev ) ; // override node's stream ops with the device's stream . stream_ops = device . stream_ops ; // forward the open call if ( stream . stream_ops . open ) { stream . stream_ops . open ( stream ) ; } } , llseek : function ( ) { throw new FS . ErrnoError ( ERRNO_CODES . ESPIPE ) ; } } , major : function ( dev ) { return ( ( dev ) >> 8 ) ; } , minor : function ( dev ) { return ( ( dev ) & 0xff ) ; } , makedev : function ( ma , mi ) { return ( ( ma ) << 8 | ( mi ) ) ; } , registerDevice : function ( dev , ops ) { FS . devices [ dev ] = { stream_ops : ops } ; } , getDevice : function ( dev ) { return FS . devices [ dev ] ; } , getMounts : function ( mount ) { var mounts = [ ] ; var check = [ mount ] ; while ( check . length ) { var m = check . pop ( ) ; mounts . push ( m ) ; check . push . apply ( check , m . mounts ) ; } return mounts ; } , syncfs : function ( populate , callback ) { if ( typeof ( populate ) === 'function' ) { callback = populate ; populate = false ; } FS . syncFSRequests ++ ; if ( FS . syncFSRequests > 1 ) { console . log ( 'warning: ' + FS . syncFSRequests + ' FS.syncfs operations in flight at once, probably just doing extra work' ) ; } var mounts = FS . getMounts ( FS . root . mount ) ; var completed = 0 ; function doCallback ( err ) { assert ( FS . syncFSRequests > 0 ) ; FS . syncFSRequests -- ; return callback ( err ) ; } function done ( err ) { if ( err ) { if ( ! done . errored ) { done . errored = true ; return doCallback ( err ) ; } return ; } if ( ++ completed >= mounts . length ) { doCallback ( null ) ; } } ; // sync all mounts mounts . forEach ( function ( mount ) { if ( ! mount . type . syncfs ) { return done ( null ) ; } mount . type . syncfs ( mount , populate , done ) ; } ) ; } , mount : function ( type , opts , mountpoint ) { var root = mountpoint === '/' ; var pseudo = ! mountpoint ; var node ; if ( root && FS . root ) { throw new FS . ErrnoError ( ERRNO_CODES . EBUSY ) ; } else if ( ! root && ! pseudo ) { var lookup = FS . lookupPath ( mountpoint , { follow_mount : false } ) ; mountpoint = lookup . path ; // use the absolute path node = lookup . node ; if ( FS . isMountpoint ( node ) ) { throw new FS . ErrnoError ( ERRNO_CODES . EBUSY ) ; } if ( ! FS . isDir ( node . mode ) ) { throw new FS . ErrnoError ( ERRNO_CODES . ENOTDIR ) ; } } var mount = { type : type , opts : opts , mountpoint : mountpoint , mounts : [ ] } ; // create a root node for the fs var mountRoot = type . mount ( mount ) ; mountRoot . mount = mount ; mount . root = mountRoot ; if ( root ) { FS . root = mountRoot ; } else if ( node ) { // set as a mountpoint node . mounted = mount ; // add the new mount to the current mount's children if ( node . mount ) { node . mount . mounts . push ( mount ) ; } } return mountRoot ; } , unmount : function ( mountpoint ) { var lookup = FS . lookupPath ( mountpoint , { follow_mount : false } ) ; if ( ! FS . isMountpoint ( lookup . node ) ) { throw new FS . ErrnoError ( ERRNO_CODES . EINVAL ) ; } // destroy the nodes for this mount, and all its child mounts var node = lookup . node ; var mount = node . mounted ; var mounts = FS . getMounts ( mount ) ; Object . keys ( FS . nameTable ) . forEach ( function ( hash ) { var current = FS . nameTable [ hash ] ; while ( current ) { var next = current . name_next ; if ( mounts . indexOf ( current . mount ) !== - 1 ) { FS . destroyNode ( current ) ; } current = next ; } } ) ; // no longer a mountpoint node . mounted = null ; // remove this mount from the child mounts var idx = node . mount . mounts . indexOf ( mount ) ; assert ( idx !== - 1 ) ; node . mount . mounts . splice ( idx , 1 ) ; } , lookup : function ( parent , name ) { return parent . node_ops . lookup ( parent , name ) ; } , mknod : function ( path , mode , dev ) { var lookup = FS . lookupPath ( path , { parent : true } ) ; var parent = lookup . node ; var name = PATH . basename ( path ) ; if ( ! name || name === '.' || name === '..' ) { throw new FS . ErrnoError ( ERRNO_CODES . EINVAL ) ; } var err = FS . mayCreate ( parent , name ) ; if ( err ) { throw new FS . ErrnoError ( err ) ; } if ( ! parent . node_ops . mknod ) { throw new FS . ErrnoError ( ERRNO_CODES . EPERM ) ; } return parent . node_ops . mknod ( parent , name , mode , dev ) ; } , create : function ( path , mode ) { mode = mode !== undefined ? mode : 438 /* 0666 */ ; mode &= 4095 ; mode |= 32768 ; return FS . mknod ( path , mode , 0 ) ; } , mkdir : function ( path , mode ) { mode = mode !== undefined ? mode : 511 /* 0777 */ ; mode &= 511 | 512 ; mode |= 16384 ; return FS . mknod ( path , mode , 0 ) ; } , mkdirTree : function ( path , mode ) { var dirs = path . split ( '/' ) ; var d = '' ; for ( var i = 0 ; i < dirs . length ; ++ i ) { if ( ! dirs [ i ] ) continue ; d += '/' + dirs [ i ] ; try { FS . mkdir ( d , mode ) ; } catch ( e ) { if ( e . errno != ERRNO_CODES . EEXIST ) throw e ; } } } , mkdev : function ( path , mode , dev ) { if ( typeof ( dev ) === 'undefined' ) { dev = mode ; mode = 438 /* 0666 */ ; } mode |= 8192 ; return FS . mknod ( path , mode , dev ) ; } , symlink : function ( oldpath , newpath ) { if ( ! PATH . resolve ( oldpath ) ) { throw new FS . ErrnoError ( ERRNO_CODES . ENOENT ) ; } var lookup = FS . lookupPath ( newpath , { parent : true } ) ; var parent = lookup . node ; if ( ! parent ) { throw new FS . ErrnoError ( ERRNO_CODES . ENOENT ) ; } var newname = PATH . basename ( newpath ) ; var err = FS . mayCreate ( parent , newname ) ; if ( err ) { throw new FS . ErrnoError ( err ) ; } if ( ! parent . node_ops . symlink ) { throw new FS . ErrnoError ( ERRNO_CODES . EPERM ) ; } return parent . node_ops . symlink ( parent , newname , oldpath ) ; } , rename : function ( old_path , new_path ) { var old_dirname = PATH . dirname ( old_path ) ; var new_dirname = PATH . dirname ( new_path ) ; var old_name = PATH . basename ( old_path ) ; var new_name = PATH . basename ( new_path ) ; // parents must exist var lookup , old_dir , new_dir ; try { lookup = FS . lookupPath ( old_path , { parent : true } ) ; old_dir = lookup . node ; lookup = FS . lookupPath ( new_path , { parent : true } ) ; new_dir = lookup . node ; } catch ( e ) { throw new FS . ErrnoError ( ERRNO_CODES . EBUSY ) ; } if ( ! old_dir || ! new_dir ) throw new FS . ErrnoError ( ERRNO_CODES . ENOENT ) ; // need to be part of the same mount if ( old_dir . mount !== new_dir . mount ) { throw new FS . ErrnoError ( ERRNO_CODES . EXDEV ) ; } // source must exist var old_node = FS . lookupNode ( old_dir , old_name ) ; // old path should not be an ancestor of the new path var relative = PATH . relative ( old_path , new_dirname ) ; if ( relative . charAt ( 0 ) !== '.' ) { throw new FS . ErrnoError ( ERRNO_CODES . EINVAL ) ; } // new path should not be an ancestor of the old path relative = PATH . relative ( new_path , old_dirname ) ; if ( relative . charAt ( 0 ) !== '.' ) { throw new FS . ErrnoError ( ERRNO_CODES . ENOTEMPTY ) ; } // see if the new path already exists var new_node ; try { new_node = FS . lookupNode ( new_dir , new_name ) ; } catch ( e ) { // not fatal } // early out if nothing needs to change if ( old_node === new_node ) { return ; } // we'll need to delete the old entry var isdir = FS . isDir ( old_node . mode ) ; var err = FS . mayDelete ( old_dir , old_name , isdir ) ; if ( err ) { throw new FS . ErrnoError ( err ) ; } // need delete permissions if we'll be overwriting. // need create permissions if new doesn't already exist. err = new_node ? FS . mayDelete ( new_dir , new_name , isdir ) : FS . mayCreate ( new_dir , new_name ) ; if ( err ) { throw new FS . ErrnoError ( err ) ; } if ( ! old_dir . node_ops . rename ) { throw new FS . ErrnoError ( ERRNO_CODES . EPERM ) ; } if ( FS . isMountpoint ( old_node ) || ( new_node && FS . isMountpoint ( new_node ) ) ) { throw new FS . ErrnoError ( ERRNO_CODES . EBUSY ) ; } // if we are going to change the parent, check write permissions if ( new_dir !== old_dir ) { err = FS . nodePermissions ( old_dir , 'w' ) ; if ( err ) { throw new FS . ErrnoError ( err ) ; } } try { if ( FS . trackingDelegate [ 'willMovePath' ] ) { FS . trackingDelegate [ 'willMovePath' ] ( old_path , new_path ) ; } } catch ( e ) { console . log ( "FS.trackingDelegate['willMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e . message ) ; } // remove the node from the lookup hash FS . hashRemoveNode ( old_node ) ; // do the underlying fs rename try { old_dir . node_ops . rename ( old_node , new_dir , new_name ) ; } catch ( e ) { throw e ; } finally { // add the node back to the hash (in case node_ops.rename // changed its name) FS . hashAddNode ( old_node ) ; } try { if ( FS . trackingDelegate [ 'onMovePath' ] ) FS . trackingDelegate [ 'onMovePath' ] ( old_path , new_path ) ; } catch ( e ) { console . log ( "FS.trackingDelegate['onMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e . message ) ; } } , rmdir : function ( path ) { var lookup = FS . lookupPath ( path , { parent : true } ) ; var parent = lookup . node ; var name = PATH . basename ( path ) ; var node = FS . lookupNode ( parent , name ) ; var err = FS . mayDelete ( parent , name , true ) ; if ( err ) { throw new FS . ErrnoError ( err ) ; } if ( ! parent . node_ops . rmdir ) { throw new FS . ErrnoError ( ERRNO_CODES . EPERM ) ; } if ( FS . isMountpoint ( node ) ) { throw new FS . ErrnoError ( ERRNO_CODES . EBUSY ) ; } try { if ( FS . trackingDelegate [ 'willDeletePath' ] ) { FS . trackingDelegate [ 'willDeletePath' ] ( path ) ; } } catch ( e ) { console . log ( "FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e . message ) ; } parent . node_ops . rmdir ( parent , name ) ; FS . destroyNode ( node ) ; try { if ( FS . trackingDelegate [ 'onDeletePath' ] ) FS . trackingDelegate [ 'onDeletePath' ] ( path ) ; } catch ( e ) { console . log ( "FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e . message ) ; } } , readdir : function ( path ) { var lookup = FS . lookupPath ( path , { follow : true } ) ; var node = lookup . node ; if ( ! node . node_ops . readdir ) { throw new FS . ErrnoError ( ERRNO_CODES . ENOTDIR ) ; } return node . node_ops . readdir ( node ) ; } , unlink : function ( path ) { var lookup = FS . lookupPath ( path , { parent : true } ) ; var parent = lookup . node ; var name = PATH . basename ( path ) ; var node = FS . lookupNode ( parent , name ) ; var err = FS . mayDelete ( parent , name , false ) ; if ( err ) { // According to POSIX, we should map EISDIR to EPERM, but // we instead do what Linux does (and we must, as we use // the musl linux libc). throw new FS . ErrnoError ( err ) ; } if ( ! parent . node_ops . unlink ) { throw new FS . ErrnoError ( ERRNO_CODES . EPERM ) ; } if ( FS . isMountpoint ( node ) ) { throw new FS . ErrnoError ( ERRNO_CODES . EBUSY ) ; } try { if ( FS . trackingDelegate [ 'willDeletePath' ] ) { FS . trackingDelegate [ 'willDeletePath' ] ( path ) ; } } catch ( e ) { console . log ( "FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e . message ) ; } parent . node_ops . unlink ( parent , name ) ; FS . destroyNode ( node ) ; try { if ( FS . trackingDelegate [ 'onDeletePath' ] ) FS . trackingDelegate [ 'onDeletePath' ] ( path ) ; } catch ( e ) { console . log ( "FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e . message ) ; } } , readlink : function ( path ) { var lookup = FS . lookupPath ( path ) ; var link = lookup . node ; if ( ! link ) { throw new FS . ErrnoError ( ERRNO_CODES . ENOENT ) ; } if ( ! link . node_ops . readlink ) { throw new FS . ErrnoError ( ERRNO_CODES . EINVAL ) ; } return PATH . resolve ( FS . getPath ( link . parent ) , link . node_ops . readlink ( link ) ) ; } , stat : function ( path , dontFollow ) { var lookup = FS . lookupPath ( path , { follow : ! dontFollow } ) ; var node = lookup . node ; if ( ! node ) { throw new FS . ErrnoError ( ERRNO_CODES . ENOENT ) ; } if ( ! node . node_ops . getattr ) { throw new FS . ErrnoError ( ERRNO_CODES . EPERM ) ; } return node . node_ops . getattr ( node ) ; } , lstat : function ( path ) { return FS . stat ( path , true ) ; } , chmod : function ( path , mode , dontFollow ) { var node ; if ( typeof path === 'string' ) { var lookup = FS . lookupPath ( path , { follow : ! dontFollow } ) ; node = lookup . node ; } else { node = path ; } if ( ! node . node_ops . setattr ) { throw new FS . ErrnoError ( ERRNO_CODES . EPERM ) ; } node . node_ops . setattr ( node , { mode : ( mode & 4095 ) | ( node . mode & ~ 4095 ) , timestamp : Date . now ( ) } ) ; } , lchmod : function ( path , mode ) { FS . chmod ( path , mode , true ) ; } , fchmod : function ( fd , mode ) { var stream = FS . getStream ( fd ) ; if ( ! stream ) { throw new FS . ErrnoError ( ERRNO_CODES . EBADF ) ; } FS . chmod ( stream . node , mode ) ; } , chown : function ( path , uid , gid , dontFollow ) { var node ; if ( typeof path === 'string' ) { var lookup = FS . lookupPath ( path , { follow : ! dontFollow } ) ; node = lookup . node ; } else { node = path ; } if ( ! node . node_ops . setattr ) { throw new FS . ErrnoError ( ERRNO_CODES . EPERM ) ; } node . node_ops . setattr ( node , { timestamp : Date . now ( ) // we ignore the uid / gid for now } ) ; } , lchown : function ( path , uid , gid ) { FS . chown ( path , uid , gid , true ) ; } , fchown : function ( fd , uid , gid ) { var stream = FS . getStream ( fd ) ; if ( ! stream ) { throw new FS . ErrnoError ( ERRNO_CODES . EBADF ) ; } FS . chown ( stream . node , uid , gid ) ; } , truncate : function ( path , len ) { if ( len < 0 ) { throw new FS . ErrnoError ( ERRNO_CODES . EINVAL ) ; } var node ; if ( typeof path === 'string' ) { var lookup = FS . lookupPath ( path , { follow : true } ) ; node = lookup . node ; } else { node = path ; } if ( ! node . node_ops . setattr ) { throw new FS . ErrnoError ( ERRNO_CODES . EPERM ) ; } if ( FS . isDir ( node . mode ) ) { throw new FS . ErrnoError ( ERRNO_CODES . EISDIR ) ; } if ( ! FS . isFile ( node . mode ) ) { throw new FS . ErrnoError ( ERRNO_CODES . EINVAL ) ; } var err = FS . nodePermissions ( node , 'w' ) ; if ( err ) { throw new FS . ErrnoError ( err ) ; } node . node_ops . setattr ( node , { size : len , timestamp : Date . now ( ) } ) ; } , ftruncate : function ( fd , len ) { var stream = FS . getStream ( fd ) ; if ( ! stream ) { throw new FS . ErrnoError ( ERRNO_CODES . EBADF ) ; } if ( ( stream . flags & 2097155 ) === 0 ) { throw new FS . ErrnoError ( ERRNO_CODES . EINVAL ) ; } FS . truncate ( stream . node , len ) ; } , utime : function ( path , atime , mtime ) { var lookup = FS . lookupPath ( path , { follow : true } ) ; var node = lookup . node ; node . node_ops . setattr ( node , { timestamp : Math . max ( atime , mtime ) } ) ; } , open : function ( path , flags , mode , fd_start , fd_end ) { if ( path === "" ) { throw new FS . ErrnoError ( ERRNO_CODES . ENOENT ) ; } flags = typeof flags === 'string' ? FS . modeStringToFlags ( flags ) : flags ; mode = typeof mode === 'undefined' ? 438 /* 0666 */ : mode ; if ( ( flags & 64 ) ) { mode = ( mode & 4095 ) | 32768 ; } else { mode = 0 ; } var node ; if ( typeof path === 'object' ) { node = path ; } else { path = PATH . normalize ( path ) ; try { var lookup = FS . lookupPath ( path , { follow : ! ( flags & 131072 ) } ) ; node = lookup . node ; } catch ( e ) { // ignore } } // perhaps we need to create the node var created = false ; if ( ( flags & 64 ) ) { if ( node ) { // if O_CREAT and O_EXCL are set, error out if the node already exists if ( ( flags & 128 ) ) { throw new FS . ErrnoError ( ERRNO_CODES . EEXIST ) ; } } else { // node doesn't exist, try to create it node = FS . mknod ( path , mode , 0 ) ; created = true ; } } if ( ! node ) { throw new FS . ErrnoError ( ERRNO_CODES . ENOENT ) ; } // can't truncate a device if ( FS . isChrdev ( node . mode ) ) { flags &= ~ 512 ; } // if asked only for a directory, then this must be one if ( ( flags & 65536 ) && ! FS . isDir ( node . mode ) ) { throw new FS . ErrnoError ( ERRNO_CODES . ENOTDIR ) ; } // check permissions, if this is not a file we just created now (it is ok to // create and write to a file with read-only permissions; it is read-only // for later use) if ( ! created ) { var err = FS . mayOpen ( node , flags ) ; if ( err ) { throw new FS . ErrnoError ( err ) ; } } // do truncation if necessary if ( ( flags & 512 ) ) { FS . truncate ( node , 0 ) ; } // we've already handled these, don't pass down to the underlying vfs flags &= ~ ( 128 | 512 ) ; // register the stream with the filesystem var stream = FS . createStream ( { node : node , path : FS . getPath ( node ) , // we want the absolute path to the node flags : flags , seekable : true , position : 0 , stream_ops : node . stream_ops , // used by the file family libc calls (fopen, fwrite, ferror, etc.) ungotten : [ ] , error : false } , fd_start , fd_end ) ; // call the new stream's open function if ( stream . stream_ops . open ) { stream . stream_ops . open ( stream ) ; } if ( Module [ 'logReadFiles' ] && ! ( flags & 1 ) ) { if ( ! FS . readFiles ) FS . readFiles = { } ; if ( ! ( path in FS . readFiles ) ) { FS . readFiles [ path ] = 1 ; Module [ 'printErr' ] ( 'read file: ' + path ) ; } } try { if ( FS . trackingDelegate [ 'onOpenFile' ] ) { var trackingFlags = 0 ; if ( ( flags & 2097155 ) !== 1 ) { trackingFlags |= FS . tracking . openFlags . READ ; } if ( ( flags & 2097155 ) !== 0 ) { trackingFlags |= FS . tracking . openFlags . WRITE ; } FS . trackingDelegate [ 'onOpenFile' ] ( path , trackingFlags ) ; } } catch ( e ) { console . log ( "FS.trackingDelegate['onOpenFile']('" + path + "', flags) threw an exception: " + e . message ) ; } return stream ; } , close : function ( stream ) { if ( FS . isClosed ( stream ) ) { throw new FS . ErrnoError ( ERRNO_CODES . EBADF ) ; } if ( stream . getdents ) stream . getdents = null ; // free readdir state try { if ( stream . stream_ops . close ) { stream . stream_ops . close ( stream ) ; } } catch ( e ) { throw e ; } finally { FS . closeStream ( stream . fd ) ; } stream . fd = null ; } , isClosed : function ( stream ) { return stream . fd === null ; } , llseek : function ( stream , offset , whence ) { if ( FS . isClosed ( stream ) ) { throw new FS . ErrnoError ( ERRNO_CODES . EBADF ) ; } if ( ! stream . seekable || ! stream . stream_ops . llseek ) { throw new FS . ErrnoError ( ERRNO_CODES . ESPIPE ) ; } stream . position = stream . stream_ops . llseek ( stream , offset , whence ) ; stream . ungotten = [ ] ; return stream . position ; } , read : function ( stream , buffer , offset , length , position ) { if ( length < 0 || position < 0 ) { throw new FS . ErrnoError ( ERRNO_CODES . EINVAL ) ; } if ( FS . isClosed ( stream ) ) { throw new FS . ErrnoError ( ERRNO_CODES . EBADF ) ; } if ( ( stream . flags & 2097155 ) === 1 ) { throw new FS . ErrnoError ( ERRNO_CODES . EBADF ) ; } if ( FS . isDir ( stream . node . mode ) ) { throw new FS . ErrnoError ( ERRNO_CODES . EISDIR ) ; } if ( ! stream . stream_ops . read ) { throw new FS . ErrnoError ( ERRNO_CODES . EINVAL ) ; } var seeking = typeof position !== 'undefined' ; if ( ! seeking ) { position = stream . position ; } else if ( ! stream . seekable ) { throw new FS . ErrnoError ( ERRNO_CODES . ESPIPE ) ; } var bytesRead = stream . stream_ops . read ( stream , buffer , offset , length , position ) ; if ( ! seeking ) stream . position += bytesRead ; return bytesRead ; } , write : function ( stream , buffer , offset , length , position , canOwn ) { if ( length < 0 || position < 0 ) { throw new FS . ErrnoError ( ERRNO_CODES . EINVAL ) ; } if ( FS . isClosed ( stream ) ) { throw new FS . ErrnoError ( ERRNO_CODES . EBADF ) ; } if ( ( stream . flags & 2097155 ) === 0 ) { throw new FS . ErrnoError ( ERRNO_CODES . EBADF ) ; } if ( FS . isDir ( stream . node . mode ) ) { throw new FS . ErrnoError ( ERRNO_CODES . EISDIR ) ; } if ( ! stream . stream_ops . write ) { throw new FS . ErrnoError ( ERRNO_CODES . EINVAL ) ; } if ( stream . flags & 1024 ) { // seek to the end before writing in append mode FS . llseek ( stream , 0 , 2 ) ; } var seeking = typeof position !== 'undefined' ; if ( ! seeking ) { position = stream . position ; } else if ( ! stream . seekable ) { throw new FS . ErrnoError ( ERRNO_CODES . ESPIPE ) ; } var bytesWritten = stream . stream_ops . write ( stream , buffer , offset , length , position , canOwn ) ; if ( ! seeking ) stream . position += bytesWritten ; try { if ( stream . path && FS . trackingDelegate [ 'onWriteToFile' ] ) FS . trackingDelegate [ 'onWriteToFile' ] ( stream . path ) ; } catch ( e ) { console . log ( "FS.trackingDelegate['onWriteToFile']('" + path + "') threw an exception: " + e . message ) ; } return bytesWritten ; } , allocate : function ( stream , offset , length ) { if ( FS . isClosed ( stream ) ) { throw new FS . ErrnoError ( ERRNO_CODES . EBADF ) ; } if ( offset < 0 || length <= 0 ) { throw new FS . ErrnoError ( ERRNO_CODES . EINVAL ) ; } if ( ( stream . flags & 2097155 ) === 0 ) { throw new FS . ErrnoError ( ERRNO_CODES . EBADF ) ; } if ( ! FS . isFile ( stream . node . mode ) && ! FS . isDir ( stream . node . mode ) ) { throw new FS . ErrnoError ( ERRNO_CODES . ENODEV ) ; } if ( ! stream . stream_ops . allocate ) { throw new FS . ErrnoError ( ERRNO_CODES . EOPNOTSUPP ) ; } stream . stream_ops . allocate ( stream , offset , length ) ; } , mmap : function ( stream , buffer , offset , length , position , prot , flags ) { // TODO if PROT is PROT_WRITE, make sure we have write access if ( ( stream . flags & 2097155 ) === 1 ) { throw new FS . ErrnoError ( ERRNO_CODES . EACCES ) ; } if ( ! stream . stream_ops . mmap ) { throw new FS . ErrnoError ( ERRNO_CODES . ENODEV ) ; } return stream . stream_ops . mmap ( stream , buffer , offset , length , position , prot , flags ) ; } , msync : function ( stream , buffer , offset , length , mmapFlags ) { if ( ! stream || ! stream . stream_ops . msync ) { return 0 ; } return stream . stream_ops . msync ( stream , buffer , offset , length , mmapFlags ) ; } , munmap : function ( stream ) { return 0 ; } , ioctl : function ( stream , cmd , arg ) { if ( ! stream . stream_ops . ioctl ) { throw new FS . ErrnoError ( ERRNO_CODES . ENOTTY ) ; } return stream . stream_ops . ioctl ( stream , cmd , arg ) ; } , readFile : function ( path , opts ) { opts = opts || { } ; opts . flags = opts . flags || 'r' ; opts . encoding = opts . encoding || 'binary' ; if ( opts . encoding !== 'utf8' && opts . encoding !== 'binary' ) { throw new Error ( 'Invalid encoding type "' + opts . encoding + '"' ) ; } var ret ; var stream = FS . open ( path , opts . flags ) ; var stat = FS . stat ( path ) ; var length = stat . size ; var buf = new Uint8Array ( length ) ; FS . read ( stream , buf , 0 , length , 0 ) ; if ( opts . encoding === 'utf8' ) { ret = UTF8ArrayToString ( buf , 0 ) ; } else if ( opts . encoding === 'binary' ) { ret = buf ; } FS . close ( stream ) ; return ret ; } , writeFile : function ( path , data , opts ) { opts = opts || { } ; opts . flags = opts . flags || 'w' ; var stream = FS . open ( path , opts . flags , opts . mode ) ; if ( typeof data === 'string' ) { var buf = new Uint8Array ( lengthBytesUTF8 ( data ) + 1 ) ; var actualNumBytes = stringToUTF8Array ( data , buf , 0 , buf . length ) ; FS . write ( stream , buf , 0 , actualNumBytes , undefined , opts . canOwn ) ; } else if ( ArrayBuffer . isView ( data ) ) { FS . write ( stream , data , 0 , data . byteLength , undefined , opts . canOwn ) ; } else { throw new Error ( 'Unsupported data type' ) ; } FS . close ( stream ) ; } , cwd : function ( ) { return FS . currentPath ; } , chdir : function ( path ) { var lookup = FS . lookupPath ( path , { follow : true } ) ; if ( lookup . node === null ) { throw new FS . ErrnoError ( ERRNO_CODES . ENOENT ) ; } if ( ! FS . isDir ( lookup . node . mode ) ) { throw new FS . ErrnoError ( ERRNO_CODES . ENOTDIR ) ; } var err = FS . nodePermissions ( lookup . node , 'x' ) ; if ( err ) { throw new FS . ErrnoError ( err ) ; } FS . currentPath = lookup . path ; } , createDefaultDirectories : function ( ) { FS . mkdir ( '/tmp' ) ; FS . mkdir ( '/home' ) ; FS . mkdir ( '/home/web_user' ) ; } , createDefaultDevices : function ( ) { // create /dev FS . mkdir ( '/dev' ) ; // setup /dev/null FS . registerDevice ( FS . makedev ( 1 , 3 ) , { read : function ( ) { return 0 ; } , write : function ( stream , buffer , offset , length , pos ) { return length ; } } ) ; FS . mkdev ( '/dev/null' , FS . makedev ( 1 , 3 ) ) ; // setup /dev/tty and /dev/tty1 // stderr needs to print output using Module['printErr'] // so we register a second tty just for it. TTY . register ( FS . makedev ( 5 , 0 ) , TTY . default_tty_ops ) ; TTY . register ( FS . makedev ( 6 , 0 ) , TTY . default_tty1_ops ) ; FS . mkdev ( '/dev/tty' , FS . makedev ( 5 , 0 ) ) ; FS . mkdev ( '/dev/tty1' , FS . makedev ( 6 , 0 ) ) ; // setup /dev/[u]random var random_device ; if ( typeof crypto !== 'undefined' ) { // for modern web browsers var randomBuffer = new Uint8Array ( 1 ) ; random_device = function ( ) { crypto . getRandomValues ( randomBuffer ) ; return randomBuffer [ 0 ] ; } ; } else if ( ENVIRONMENT_IS_NODE ) { // for nodejs random_device = function ( ) { return require ( 'crypto' ) [ 'randomBytes' ] ( 1 ) [ 0 ] ; } ; } else { // default for ES5 platforms random_device = function ( ) { return ( Math . random ( ) * 256 ) | 0 ; } ; } FS . createDevice ( '/dev' , 'random' , random_device ) ; FS . createDevice ( '/dev' , 'urandom' , random_device ) ; // we're not going to emulate the actual shm device, // just create the tmp dirs that reside in it commonly FS . mkdir ( '/dev/shm' ) ; FS . mkdir ( '/dev/shm/tmp' ) ; } , createSpecialDirectories : function ( ) { // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the name of the stream for fd 6 (see test_unistd_ttyname) FS . mkdir ( '/proc' ) ; FS . mkdir ( '/proc/self' ) ; FS . mkdir ( '/proc/self/fd' ) ; FS . mount ( { mount : function ( ) { var node = FS . createNode ( '/proc/self' , 'fd' , 16384 | 511 /* 0777 */ , 73 ) ; node . node_ops = { lookup : function ( parent , name ) { var fd = + name ; var stream = FS . getStream ( fd ) ; if ( ! stream ) throw new FS . ErrnoError ( ERRNO_CODES . EBADF ) ; var ret = { parent : null , mount : { mountpoint : 'fake' } , node_ops : { readlink : function ( ) { return stream . path } } } ; ret . parent = ret ; // make it look like a simple root node return ret ; } } ; return node ; } } , { } , '/proc/self/fd' ) ; } , createStandardStreams : function ( ) { // TODO deprecate the old functionality of a single // input / output callback and that utilizes FS.createDevice // and instead require a unique set of stream ops // by default, we symlink the standard streams to the // default tty devices. however, if the standard streams // have been overwritten we create a unique device for // them instead. if ( Module [ 'stdin' ] ) { FS . createDevice ( '/dev' , 'stdin' , Module [ 'stdin' ] ) ; } else { FS . symlink ( '/dev/tty' , '/dev/stdin' ) ; } if ( Module [ 'stdout' ] ) { FS . createDevice ( '/dev' , 'stdout' , null , Module [ 'stdout' ] ) ; } else { FS . symlink ( '/dev/tty' , '/dev/stdout' ) ; } if ( Module [ 'stderr' ] ) { FS . createDevice ( '/dev' , 'stderr' , null , Module [ 'stderr' ] ) ; } else { FS . symlink ( '/dev/tty1' , '/dev/stderr' ) ; } // open default streams for the stdin, stdout and stderr devices var stdin = FS . open ( '/dev/stdin' , 'r' ) ; assert ( stdin . fd === 0 , 'invalid handle for stdin (' + stdin . fd + ')' ) ; var stdout = FS . open ( '/dev/stdout' , 'w' ) ; assert ( stdout . fd === 1 , 'invalid handle for stdout (' + stdout . fd + ')' ) ; var stderr = FS . open ( '/dev/stderr' , 'w' ) ; assert ( stderr . fd === 2 , 'invalid handle for stderr (' + stderr . fd + ')' ) ; } , ensureErrnoError : function ( ) { if ( FS . ErrnoError ) return ; FS . ErrnoError = function ErrnoError ( errno , node ) { //Module.printErr(stackTrace()); // useful for debugging this . node = node ; this . setErrno = function ( errno ) { this . errno = errno ; for ( var key in ERRNO_CODES ) { if ( ERRNO_CODES [ key ] === errno ) { this . code = key ; break ; } } } ; this . setErrno ( errno ) ; this . message = ERRNO_MESSAGES [ errno ] ; // Node.js compatibility: assigning on this.stack fails on Node 4 (but fixed on Node 8) if ( this . stack ) Object . defineProperty ( this , "stack" , { value : ( new Error ) . stack , writable : true } ) ; if ( this . stack ) this . stack = demangleAll ( this . stack ) ; } ; FS . ErrnoError . prototype = new Error ( ) ; FS . ErrnoError . prototype . constructor = FS . ErrnoError ; // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info) [ ERRNO_CODES . ENOENT ] . forEach ( function ( code ) { FS . genericErrors [ code ] = new FS . ErrnoError ( code ) ; FS . genericErrors [ code ] . stack = '<generic error, no stack>' ; } ) ; } , staticInit : function ( ) { FS . ensureErrnoError ( ) ; FS . nameTable = new Array ( 4096 ) ; FS . mount ( MEMFS , { } , '/' ) ; FS . createDefaultDirectories ( ) ; FS . createDefaultDevices ( ) ; FS . createSpecialDirectories ( ) ; FS . filesystems = { 'MEMFS' : MEMFS , 'IDBFS' : IDBFS , 'NODEFS' : NODEFS , 'WORKERFS' : WORKERFS , } ; } , init : function ( input , output , error ) { assert ( ! FS . init . initialized , 'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)' ) ; FS . init . initialized = true ; FS . ensureErrnoError ( ) ; // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here Module [ 'stdin' ] = input || Module [ 'stdin' ] ; Module [ 'stdout' ] = output || Module [ 'stdout' ] ; Module [ 'stderr' ] = error || Module [ 'stderr' ] ; FS . createStandardStreams ( ) ; } , quit : function ( ) { FS . init . initialized = false ; // force-flush all streams, so we get musl std streams printed out var fflush = Module [ '_fflush' ] ; if ( fflush ) fflush ( 0 ) ; // close all of our streams for ( var i = 0 ; i < FS . streams . length ; i ++ ) { var stream = FS . streams [ i ] ; if ( ! stream ) { continue ; } FS . close ( stream ) ; } } , getMode : function ( canRead , canWrite ) { var mode = 0 ; if ( canRead ) mode |= 292 | 73 ; if ( canWrite ) mode |= 146 ; return mode ; } , joinPath : function ( parts , forceRelative ) { var path = PATH . join . apply ( null , parts ) ; if ( forceRelative && path [ 0 ] == '/' ) path = path . substr ( 1 ) ; return path ; } , absolutePath : function ( relative , base ) { return PATH . resolve ( base , relative ) ; } , standardizePath : function ( path ) { return PATH . normalize ( path ) ; } , findObject : function ( path , dontResolveLastLink ) { var ret = FS . analyzePath ( path , dontResolveLastLink ) ; if ( ret . exists ) { return ret . object ; } else { ___setErrNo ( ret . error ) ; return null ; } } , analyzePath : function ( path , dontResolveLastLink ) { // operate from within the context of the symlink's target try { var lookup = FS . lookupPath ( path , { follow : ! dontResolveLastLink } ) ; path = lookup . path ; } catch ( e ) { } var ret = { isRoot : false , exists : false , error : 0 , name : null , path : null , object : null , parentExists : false , parentPath : null , parentObject : null } ; try { var lookup = FS . lookupPath ( path , { parent : true } ) ; ret . parentExists = true ; ret . parentPath = lookup . path ; ret . parentObject = lookup . node ; ret . name = PATH . basename ( path ) ; lookup = FS . lookupPath ( path , { follow : ! dontResolveLastLink } ) ; ret . exists = true ; ret . path = lookup . path ; ret . object = lookup . node ; ret . name = lookup . node . name ; ret . isRoot = lookup . path === '/' ; } catch ( e ) { ret . error = e . errno ; } ; return ret ; } , createFolder : function ( parent , name , canRead , canWrite ) { var path = PATH . join2 ( typeof parent === 'string' ? parent : FS . getPath ( parent ) , name ) ; var mode = FS . getMode ( canRead , canWrite ) ; return FS . mkdir ( path , mode ) ; } , createPath : function ( parent , path , canRead , canWrite ) { parent = typeof parent === 'string' ? parent : FS . getPath ( parent ) ; var parts = path . split ( '/' ) . reverse ( ) ; while ( parts . length ) { var part = parts . pop ( ) ; if ( ! part ) continue ; var current = PATH . join2 ( parent , part ) ; try { FS . mkdir ( current ) ; } catch ( e ) { // ignore EEXIST } parent = current ; } return current ; } , createFile : function ( parent , name , properties , canRead , canWrite ) { var path = PATH . join2 ( typeof parent === 'string' ? parent : FS . getPath ( parent ) , name ) ; var mode = FS . getMode ( canRead , canWrite ) ; return FS . create ( path , mode ) ; } , createDataFile : function ( parent , name , data , canRead , canWrite , canOwn ) { var path = name ? PATH . join2 ( typeof parent === 'string' ? parent : FS . getPath ( parent ) , name ) : parent ; var mode = FS . getMode ( canRead , canWrite ) ; var node = FS . create ( path , mode ) ; if ( data ) { if ( typeof data === 'string' ) { var arr = new Array ( data . length ) ; for ( var i = 0 , len = data . length ; i < len ; ++ i ) arr [ i ] = data . charCodeAt ( i ) ; data = arr ; } // make sure we can write to the file FS . chmod ( node , mode | 146 ) ; var stream = FS . open ( node , 'w' ) ; FS . write ( stream , data , 0 , data . length , 0 , canOwn ) ; FS . close ( stream ) ; FS . chmod ( node , mode ) ; } return node ; } , createDevice : function ( parent , name , input , output ) { var path = PATH . join2 ( typeof parent === 'string' ? parent : FS . getPath ( parent ) , name ) ; var mode = FS . getMode ( ! ! input , ! ! output ) ; if ( ! FS . createDevice . major ) FS . createDevice . major = 64 ; var dev = FS . makedev ( FS . createDevice . major ++ , 0 ) ; // Create a fake device that a set of stream ops to emulate // the old behavior. FS . registerDevice ( dev , { open : function ( stream ) { stream . seekable = false ; } , close : function ( stream ) { // flush any pending line data if ( output && output . buffer && output . buffer . length ) { output ( 10 ) ; } } , read : function ( stream , buffer , offset , length , pos /* ignored */ ) { var bytesRead = 0 ; for ( var i = 0 ; i < length ; i ++ ) { var result ; try { result = input ( ) ; } catch ( e ) { throw new FS . ErrnoError ( ERRNO_CODES . EIO ) ; } if ( result === undefined && bytesRead === 0 ) { throw new FS . ErrnoError ( ERRNO_CODES . EAGAIN ) ; } if ( result === null || result === undefined ) break ; bytesRead ++ ; buffer [ offset + i ] = result ; } if ( bytesRead ) { stream . node . timestamp = Date . now ( ) ; } return bytesRead ; } , write : function ( stream , buffer , offset , length , pos ) { for ( var i = 0 ; i < length ; i ++ ) { try { output ( buffer [ offset + i ] ) ; } catch ( e ) { throw new FS . ErrnoError ( ERRNO_CODES . EIO ) ; } } if ( length ) { stream . node . timestamp = Date . now ( ) ; } return i ; } } ) ; return FS . mkdev ( path , mode , dev ) ; } , createLink : function ( parent , name , target , canRead , canWrite ) { var path = PATH . join2 ( typeof parent === 'string' ? parent : FS . getPath ( parent ) , name ) ; return FS . symlink ( target , path ) ; } , forceLoadFile : function ( obj ) { if ( obj . isDevice || obj . isFolder || obj . link || obj . contents ) return true ; var success = true ; if ( typeof XMLHttpRequest !== 'undefined' ) { throw new Error ( "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread." ) ; } else if ( Module [ 'read' ] ) { // Command-line. try { // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as //          read() will try to parse UTF8. obj . contents = intArrayFromString ( Module [ 'read' ] ( obj . url ) , true ) ; obj . usedBytes = obj . contents . length ; } catch ( e ) { success = false ; } } else { throw new Error ( 'Cannot load without read() or XMLHttpRequest.' ) ; } if ( ! success ) ___setErrNo ( ERRNO_CODES . EIO ) ; return success ; } , createLazyFile : function ( parent , name , url , canRead , canWrite ) { // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse. function LazyUint8Array ( ) { this . lengthKnown = false ; this . chunks = [ ] ; // Loaded chunks. Index is the chunk number } LazyUint8Array . prototype . get = function LazyUint8Array_get ( idx ) { if ( idx > this . length - 1 || idx < 0 ) { return undefined ; } var chunkOffset = idx % this . chunkSize ; var chunkNum = ( idx / this . chunkSize ) | 0 ; return this . getter ( chunkNum ) [ chunkOffset ] ; } LazyUint8Array . prototype . setDataGetter = function LazyUint8Array_setDataGetter ( getter ) { this . getter = getter ; } LazyUint8Array . prototype . cacheLength = function LazyUint8Array_cacheLength ( ) { // Find length var xhr = new XMLHttpRequest ( ) ; xhr . open ( 'HEAD' , url , false ) ; xhr . send ( null ) ; if ( ! ( xhr . status >= 200 && xhr . status < 300 || xhr . status === 304 ) ) throw new Error ( "Couldn't load " + url + ". Status: " + xhr . status ) ; var datalength = Number ( xhr . getResponseHeader ( "Content-length" ) ) ; var header ; var hasByteServing = ( header = xhr . getResponseHeader ( "Accept-Ranges" ) ) && header === "bytes" ; var usesGzip = ( header = xhr . getResponseHeader ( "Content-Encoding" ) ) && header === "gzip" ; var chunkSize = 1024 * 1024 ; // Chunk size in bytes if ( ! hasByteServing ) chunkSize = datalength ; // Function to get a range from the remote URL. var doXHR = ( function ( from , to ) { if ( from > to ) throw new Error ( "invalid range (" + from + ", " + to + ") or no bytes requested!" ) ; if ( to > datalength - 1 ) throw new Error ( "only " + datalength + " bytes available! programmer error!" ) ; // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available. var xhr = new XMLHttpRequest ( ) ; xhr . open ( 'GET' , url , false ) ; if ( datalength !== chunkSize ) xhr . setRequestHeader ( "Range" , "bytes=" + from + "-" + to ) ; // Some hints to the browser that we want binary data. if ( typeof Uint8Array != 'undefined' ) xhr . responseType = 'arraybuffer' ; if ( xhr . overrideMimeType ) { xhr . overrideMimeType ( 'text/plain; charset=x-user-defined' ) ; } xhr . send ( null ) ; if ( ! ( xhr . status >= 200 && xhr . status < 300 || xhr . status === 304 ) ) throw new Error ( "Couldn't load " + url + ". Status: " + xhr . status ) ; if ( xhr . response !== undefined ) { return new Uint8Array ( xhr . response || [ ] ) ; } else { return intArrayFromString ( xhr . responseText || '' , true ) ; } } ) ; var lazyArray = this ; lazyArray . setDataGetter ( function ( chunkNum ) { var start = chunkNum * chunkSize ; var end = ( chunkNum + 1 ) * chunkSize - 1 ; // including this byte end = Math . min ( end , datalength - 1 ) ; // if datalength-1 is selected, this is the last block if ( typeof ( lazyArray . chunks [ chunkNum ] ) === "undefined" ) { lazyArray . chunks [ chunkNum ] = doXHR ( start , end ) ; } if ( typeof ( lazyArray . chunks [ chunkNum ] ) === "undefined" ) throw new Error ( "doXHR failed!" ) ; return lazyArray . chunks [ chunkNum ] ; } ) ; if ( usesGzip || ! datalength ) { // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length chunkSize = datalength = 1 ; // this will force getter(0)/doXHR do download the whole file datalength = this . getter ( 0 ) . length ; chunkSize = datalength ; console . log ( "LazyFiles on gzip forces download of the whole file when length is accessed" ) ; } this . _length = datalength ; this . _chunkSize = chunkSize ; this . lengthKnown = true ; } if ( typeof XMLHttpRequest !== 'undefined' ) { if ( ! ENVIRONMENT_IS_WORKER ) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc' ; var lazyArray = new LazyUint8Array ( ) ; Object . defineProperties ( lazyArray , { length : { get : function ( ) { if ( ! this . lengthKnown ) { this . cacheLength ( ) ; } return this . _length ; } } , chunkSize : { get : function ( ) { if ( ! this . lengthKnown ) { this . cacheLength ( ) ; } return this . _chunkSize ; } } } ) ; var properties = { isDevice : false , contents : lazyArray } ; } else { var properties = { isDevice : false , url : url } ; } var node = FS . createFile ( parent , name , properties , canRead , canWrite ) ; // This is a total hack, but I want to get this lazy file code out of the // core of MEMFS. If we want to keep this lazy file concept I feel it should // be its own thin LAZYFS proxying calls to MEMFS. if ( properties . contents ) { node . contents = properties . contents ; } else if ( properties . url ) { node . contents = null ; node . url = properties . url ; } // Add a function that defers querying the file size until it is asked the first time. Object . defineProperties ( node , { usedBytes : { get : function ( ) { return this . contents . length ; } } } ) ; // override each stream op with one that tries to force load the lazy file first var stream_ops = { } ; var keys = Object . keys ( node . stream_ops ) ; keys . forEach ( function ( key ) { var fn = node . stream_ops [ key ] ; stream_ops [ key ] = function forceLoadLazyFile ( ) { if ( ! FS . forceLoadFile ( node ) ) { throw new FS . ErrnoError ( ERRNO_CODES . EIO ) ; } return fn . apply ( null , arguments ) ; } ; } ) ; // use a custom read function stream_ops . read = function stream_ops_read ( stream , buffer , offset , length , position ) { if ( ! FS . forceLoadFile ( node ) ) { throw new FS . ErrnoError ( ERRNO_CODES . EIO ) ; } var contents = stream . node . contents ; if ( position >= contents . length ) return 0 ; var size = Math . min ( contents . length - position , length ) ; assert ( size >= 0 ) ; if ( contents . slice ) { // normal array for ( var i = 0 ; i < size ; i ++ ) { buffer [ offset + i ] = contents [ position + i ] ; } } else { for ( var i = 0 ; i < size ; i ++ ) { // LazyUint8Array from sync binary XHR buffer [ offset + i ] = contents . get ( position + i ) ; } } return size ; } ; node . stream_ops = stream_ops ; return node ; } , createPreloadedFile : function ( parent , name , url , canRead , canWrite , onload , onerror , dontCreateFile , canOwn , preFinish ) { Browser . init ( ) ; // XXX perhaps this method should move onto Browser? // TODO we should allow people to just pass in a complete filename instead // of parent and name being that we just join them anyways var fullname = name ? PATH . resolve ( PATH . join2 ( parent , name ) ) : parent ; var dep = getUniqueRunDependency ( 'cp ' + fullname ) ; // might have several active requests for the same fullname function processData ( byteArray ) { function finish ( byteArray ) { if ( preFinish ) preFinish ( ) ; if ( ! dontCreateFile ) { FS . createDataFile ( parent , name , byteArray , canRead , canWrite , canOwn ) ; } if ( onload ) onload ( ) ; removeRunDependency ( dep ) ; } var handled = false ; Module [ 'preloadPlugins' ] . forEach ( function ( plugin ) { if ( handled ) return ; if ( plugin [ 'canHandle' ] ( fullname ) ) { plugin [ 'handle' ] ( byteArray , fullname , finish , function ( ) { if ( onerror ) onerror ( ) ; removeRunDependency ( dep ) ; } ) ; handled = true ; } } ) ; if ( ! handled ) finish ( byteArray ) ; } addRunDependency ( dep ) ; if ( typeof url == 'string' ) { Browser . asyncLoad ( url , function ( byteArray ) { processData ( byteArray ) ; } , onerror ) ; } else { processData ( url ) ; } } , indexedDB : function ( ) { return window . indexedDB || window . mozIndexedDB || window . webkitIndexedDB || window . msIndexedDB ; } , DB_NAME : function ( ) { return 'EM_FS_' + window . location . pathname ; } , DB_VERSION : 20 , DB_STORE_NAME : "FILE_DATA" , saveFilesToDB : function ( paths , onload , onerror ) { onload = onload || function ( ) { } ; onerror = onerror || function ( ) { } ; var indexedDB = FS . indexedDB ( ) ; try { var openRequest = indexedDB . open ( FS . DB_NAME ( ) , FS . DB_VERSION ) ; } catch ( e ) { return onerror ( e ) ; } openRequest . onupgradeneeded = function openRequest_onupgradeneeded ( ) { console . log ( 'creating db' ) ; var db = openRequest . result ; db . createObjectStore ( FS . DB_STORE_NAME ) ; } ; openRequest . onsuccess = function openRequest_onsuccess ( ) { var db = openRequest . result ; var transaction = db . transaction ( [ FS . DB_STORE_NAME ] , 'readwrite' ) ; var files = transaction . objectStore ( FS . DB_STORE_NAME ) ; var ok = 0 , fail = 0 , total = paths . length ; function finish ( ) { if ( fail == 0 ) onload ( ) ; else onerror ( ) ; } paths . forEach ( function ( path ) { var putRequest = files . put ( FS . analyzePath ( path ) . object . contents , path ) ; putRequest . onsuccess = function putRequest_onsuccess ( ) { ok ++ ; if ( ok + fail == total ) finish ( ) } ; putRequest . onerror = function putRequest_onerror ( ) { fail ++ ; if ( ok + fail == total ) finish ( ) } ; } ) ; transaction . onerror = onerror ; } ; openRequest . onerror = onerror ; } , loadFilesFromDB : function ( paths , onload , onerror ) { onload = onload || function ( ) { } ; onerror = onerror || function ( ) { } ; var indexedDB = FS . indexedDB ( ) ; try { var openRequest = indexedDB . open ( FS . DB_NAME ( ) , FS . DB_VERSION ) ; } catch ( e ) { return onerror ( e ) ; } openRequest . onupgradeneeded = onerror ; // no database to load from openRequest . onsuccess = function openRequest_onsuccess ( ) { var db = openRequest . result ; try { var transaction = db . transaction ( [ FS . DB_STORE_NAME ] , 'readonly' ) ; } catch ( e ) { onerror ( e ) ; return ; } var files = transaction . objectStore ( FS . DB_STORE_NAME ) ; var ok = 0 , fail = 0 , total = paths . length ; function finish ( ) { if ( fail == 0 ) onload ( ) ; else onerror ( ) ; } paths . forEach ( function ( path ) { var getRequest = files . get ( path ) ; getRequest . onsuccess = function getRequest_onsuccess ( ) { if ( FS . analyzePath ( path ) . exists ) { FS . unlink ( path ) ; } FS . createDataFile ( PATH . dirname ( path ) , PATH . basename ( path ) , getRequest . result , true , true , true ) ; ok ++ ; if ( ok + fail == total ) finish ( ) ; } ; getRequest . onerror = function getRequest_onerror ( ) { fail ++ ; if ( ok + fail == total ) finish ( ) } ; } ) ; transaction . onerror = onerror ; } ; openRequest . onerror = onerror ; } } ; var SYSCALLS = { DEFAULT_POLLMASK : 5 , mappings : { } , umask : 511 , calculateAt : function ( dirfd , path ) { if ( path [ 0 ] !== '/' ) { // relative path var dir ; if ( dirfd === - 100 ) { dir = FS . cwd ( ) ; } else { var dirstream = FS . getStream ( dirfd ) ; if ( ! dirstream ) throw new FS . ErrnoError ( ERRNO_CODES . EBADF ) ; dir = dirstream . path ; } path = PATH . join2 ( dir , path ) ; } return path ; } , doStat : function ( func , path , buf ) { try { var stat = func ( path ) ; } catch ( e ) { if ( e && e . node && PATH . normalize ( path ) !== PATH . normalize ( FS . getPath ( e . node ) ) ) { // an error occurred while trying to look up the path; we should just report ENOTDIR return - ERRNO_CODES . ENOTDIR ; } throw e ; } HEAP32 [ ( ( buf ) >> 2 ) ] = stat . dev ; HEAP32 [ ( ( ( buf ) + ( 4 ) ) >> 2 ) ] = 0 ; HEAP32 [ ( ( ( buf ) + ( 8 ) ) >> 2 ) ] = stat . ino ; HEAP32 [ ( ( ( buf ) + ( 12 ) ) >> 2 ) ] = stat . mode ; HEAP32 [ ( ( ( buf ) + ( 16 ) ) >> 2 ) ] = stat . nlink ; HEAP32 [ ( ( ( buf ) + ( 20 ) ) >> 2 ) ] = stat . uid ; HEAP32 [ ( ( ( buf ) + ( 24 ) ) >> 2 ) ] = stat . gid ; HEAP32 [ ( ( ( buf ) + ( 28 ) ) >> 2 ) ] = stat . rdev ; HEAP32 [ ( ( ( buf ) + ( 32 ) ) >> 2 ) ] = 0 ; HEAP32 [ ( ( ( buf ) + ( 36 ) ) >> 2 ) ] = stat . size ; HEAP32 [ ( ( ( buf ) + ( 40 ) ) >> 2 ) ] = 4096 ; HEAP32 [ ( ( ( buf ) + ( 44 ) ) >> 2 ) ] = stat . blocks ; HEAP32 [ ( ( ( buf ) + ( 48 ) ) >> 2 ) ] = ( stat . atime . getTime ( ) / 1000 ) | 0 ; HEAP32 [ ( ( ( buf ) + ( 52 ) ) >> 2 ) ] = 0 ; HEAP32 [ ( ( ( buf ) + ( 56 ) ) >> 2 ) ] = ( stat . mtime . getTime ( ) / 1000 ) | 0 ; HEAP32 [ ( ( ( buf ) + ( 60 ) ) >> 2 ) ] = 0 ; HEAP32 [ ( ( ( buf ) + ( 64 ) ) >> 2 ) ] = ( stat . ctime . getTime ( ) / 1000 ) | 0 ; HEAP32 [ ( ( ( buf ) + ( 68 ) ) >> 2 ) ] = 0 ; HEAP32 [ ( ( ( buf ) + ( 72 ) ) >> 2 ) ] = stat . ino ; return 0 ; } , doMsync : function ( addr , stream , len , flags ) { var buffer = new Uint8Array ( HEAPU8 . subarray ( addr , addr + len ) ) ; FS . msync ( stream , buffer , 0 , len , flags ) ; } , doMkdir : function ( path , mode ) { // remove a trailing slash, if one - /a/b/ has basename of '', but // we want to create b in the context of this function path = PATH . normalize ( path ) ; if ( path [ path . length - 1 ] === '/' ) path = path . substr ( 0 , path . length - 1 ) ; FS . mkdir ( path , mode , 0 ) ; return 0 ; } , doMknod : function ( path , mode , dev ) { // we don't want this in the JS API as it uses mknod to create all nodes. switch ( mode & 61440 ) { case 32768 : case 8192 : case 24576 : case 4096 : case 49152 : break ; default : return - ERRNO_CODES . EINVAL ; } FS . mknod ( path , mode , dev ) ; return 0 ; } , doReadlink : function ( path , buf , bufsize ) { if ( bufsize <= 0 ) return - ERRNO_CODES . EINVAL ; var ret = FS . readlink ( path ) ; var len = Math . min ( bufsize , lengthBytesUTF8 ( ret ) ) ; var endChar = HEAP8 [ buf + len ] ; stringToUTF8 ( ret , buf , bufsize + 1 ) ; // readlink is one of the rare functions that write out a C string, but does never append a null to the output buffer(!) // stringToUTF8() always appends a null byte, so restore the character under the null byte after the write. HEAP8 [ buf + len ] = endChar ; return len ; } , doAccess : function ( path , amode ) { if ( amode & ~ 7 ) { // need a valid mode return - ERRNO_CODES . EINVAL ; } var node ; var lookup = FS . lookupPath ( path , { follow : true } ) ; node = lookup . node ; var perms = '' ; if ( amode & 4 ) perms += 'r' ; if ( amode & 2 ) perms += 'w' ; if ( amode & 1 ) perms += 'x' ; if ( perms /* otherwise, they've just passed F_OK */ && FS . nodePermissions ( node , perms ) ) { return - ERRNO_CODES . EACCES ; } return 0 ; } , doDup : function ( path , flags , suggestFD ) { var suggest = FS . getStream ( suggestFD ) ; if ( suggest ) FS . close ( suggest ) ; return FS . open ( path , flags , 0 , suggestFD , suggestFD ) . fd ; } , doReadv : function ( stream , iov , iovcnt , offset ) { var ret = 0 ; for ( var i = 0 ; i < iovcnt ; i ++ ) { var ptr = HEAP32 [ ( ( ( iov ) + ( i * 8 ) ) >> 2 ) ] ; var len = HEAP32 [ ( ( ( iov ) + ( i * 8 + 4 ) ) >> 2 ) ] ; var curr = FS . read ( stream , HEAP8 , ptr , len , offset ) ; if ( curr < 0 ) return - 1 ; ret += curr ; if ( curr < len ) break ; // nothing more to read } return ret ; } , doWritev : function ( stream , iov , iovcnt , offset ) { var ret = 0 ; for ( var i = 0 ; i < iovcnt ; i ++ ) { var ptr = HEAP32 [ ( ( ( iov ) + ( i * 8 ) ) >> 2 ) ] ; var len = HEAP32 [ ( ( ( iov ) + ( i * 8 + 4 ) ) >> 2 ) ] ; var curr = FS . write ( stream , HEAP8 , ptr , len , offset ) ; if ( curr < 0 ) return - 1 ; ret += curr ; } return ret ; } , varargs : 0 , get : function ( varargs ) { SYSCALLS . varargs += 4 ; var ret = HEAP32 [ ( ( ( SYSCALLS . varargs ) - ( 4 ) ) >> 2 ) ] ; return ret ; } , getStr : function ( ) { var ret = Pointer_stringify ( SYSCALLS . get ( ) ) ; return ret ; } , getStreamFromFD : function ( ) { var stream = FS . getStream ( SYSCALLS . get ( ) ) ; if ( ! stream ) throw new FS . ErrnoError ( ERRNO_CODES . EBADF ) ; return stream ; } , getSocketFromFD : function ( ) { var socket = SOCKFS . getSocket ( SYSCALLS . get ( ) ) ; if ( ! socket ) throw new FS . ErrnoError ( ERRNO_CODES . EBADF ) ; return socket ; } , getSocketAddress : function ( allowNull ) { var addrp = SYSCALLS . get ( ) , addrlen = SYSCALLS . get ( ) ; if ( allowNull && addrp === 0 ) return null ; var info = __read_sockaddr ( addrp , addrlen ) ; if ( info . errno ) throw new FS . ErrnoError ( info . errno ) ; info . addr = DNS . lookup_addr ( info . addr ) || info . addr ; return info ; } , get64 : function ( ) { var low = SYSCALLS . get ( ) , high = SYSCALLS . get ( ) ; if ( low >= 0 ) assert ( high === 0 ) ; else assert ( high === - 1 ) ; return low ; } , getZero : function ( ) { assert ( SYSCALLS . get ( ) === 0 ) ; } } ; function ___syscall10 ( which , varargs ) { SYSCALLS . varargs = varargs ; try { // unlink var path = SYSCALLS . getStr ( ) ; FS . unlink ( path ) ; return 0 ; } catch ( e ) { if ( typeof FS === 'undefined' || ! ( e instanceof FS . ErrnoError ) ) abort ( e ) ; return - e . errno ; } } function ___syscall140 ( which , varargs ) { SYSCALLS . varargs = varargs ; try { // llseek var stream = SYSCALLS . getStreamFromFD ( ) , offset_high = SYSCALLS . get ( ) , offset_low = SYSCALLS . get ( ) , result = SYSCALLS . get ( ) , whence = SYSCALLS . get ( ) ; // NOTE: offset_high is unused - Emscripten's off_t is 32-bit var offset = offset_low ; FS . llseek ( stream , offset , whence ) ; HEAP32 [ ( ( result ) >> 2 ) ] = stream . position ; if ( stream . getdents && offset === 0 && whence === 0 ) stream . getdents = null ; // reset readdir state return 0 ; } catch ( e ) { if ( typeof FS === 'undefined' || ! ( e instanceof FS . ErrnoError ) ) abort ( e ) ; return - e . errno ; } } function ___syscall145 ( which , varargs ) { SYSCALLS . varargs = varargs ; try { // readv var stream = SYSCALLS . getStreamFromFD ( ) , iov = SYSCALLS . get ( ) , iovcnt = SYSCALLS . get ( ) ; return SYSCALLS . doReadv ( stream , iov , iovcnt ) ; } catch ( e ) { if ( typeof FS === 'undefined' || ! ( e instanceof FS . ErrnoError ) ) abort ( e ) ; return - e . errno ; } } function ___syscall146 ( which , varargs ) { SYSCALLS . varargs = varargs ; try { // writev var stream = SYSCALLS . getStreamFromFD ( ) , iov = SYSCALLS . get ( ) , iovcnt = SYSCALLS . get ( ) ; return SYSCALLS . doWritev ( stream , iov , iovcnt ) ; } catch ( e ) { if ( typeof FS === 'undefined' || ! ( e instanceof FS . ErrnoError ) ) abort ( e ) ; return - e . errno ; } } function ___syscall15 ( which , varargs ) { SYSCALLS . varargs = varargs ; try { // chmod var path = SYSCALLS . getStr ( ) , mode = SYSCALLS . get ( ) ; FS . chmod ( path , mode ) ; return 0 ; } catch ( e ) { if ( typeof FS === 'undefined' || ! ( e instanceof FS . ErrnoError ) ) abort ( e ) ; return - e . errno ; } } function ___syscall195 ( which , varargs ) { SYSCALLS . varargs = varargs ; try { // SYS_stat64 var path = SYSCALLS . getStr ( ) , buf = SYSCALLS . get ( ) ; return SYSCALLS . doStat ( FS . stat , path , buf ) ; } catch ( e ) { if ( typeof FS === 'undefined' || ! ( e instanceof FS . ErrnoError ) ) abort ( e ) ; return - e . errno ; } } function ___syscall197 ( which , varargs ) { SYSCALLS . varargs = varargs ; try { // SYS_fstat64 var stream = SYSCALLS . getStreamFromFD ( ) , buf = SYSCALLS . get ( ) ; return SYSCALLS . doStat ( FS . stat , stream . path , buf ) ; } catch ( e ) { if ( typeof FS === 'undefined' || ! ( e instanceof FS . ErrnoError ) ) abort ( e ) ; return - e . errno ; } } function ___syscall212 ( which , varargs ) { SYSCALLS . varargs = varargs ; try { // chown32 var path = SYSCALLS . getStr ( ) , owner = SYSCALLS . get ( ) , group = SYSCALLS . get ( ) ; FS . chown ( path , owner , group ) ; return 0 ; } catch ( e ) { if ( typeof FS === 'undefined' || ! ( e instanceof FS . ErrnoError ) ) abort ( e ) ; return - e . errno ; } } function ___syscall221 ( which , varargs ) { SYSCALLS . varargs = varargs ; try { // fcntl64 var stream = SYSCALLS . getStreamFromFD ( ) , cmd = SYSCALLS . get ( ) ; switch ( cmd ) { case 0 : { var arg = SYSCALLS . get ( ) ; if ( arg < 0 ) { return - ERRNO_CODES . EINVAL ; } var newStream ; newStream = FS . open ( stream . path , stream . flags , 0 , arg ) ; return newStream . fd ; } case 1 : case 2 : return 0 ; // FD_CLOEXEC makes no sense for a single process. case 3 : return stream . flags ; case 4 : { var arg = SYSCALLS . get ( ) ; stream . flags |= arg ; return 0 ; } case 12 : case 12 : { var arg = SYSCALLS . get ( ) ; var offset = 0 ; // We're always unlocked. HEAP16 [ ( ( ( arg ) + ( offset ) ) >> 1 ) ] = 2 ; return 0 ; } case 13 : case 14 : case 13 : case 14 : return 0 ; // Pretend that the locking is successful. case 16 : case 8 : return - ERRNO_CODES . EINVAL ; // These are for sockets. We don't have them fully implemented yet. case 9 : // musl trusts getown return values, due to a bug where they must be, as they overlap with errors. just return -1 here, so fnctl() returns that, and we set errno ourselves. ___setErrNo ( ERRNO_CODES . EINVAL ) ; return - 1 ; default : { return - ERRNO_CODES . EINVAL ; } } } catch ( e ) { if ( typeof FS === 'undefined' || ! ( e instanceof FS . ErrnoError ) ) abort ( e ) ; return - e . errno ; } } function ___syscall320 ( which , varargs ) { SYSCALLS . varargs = varargs ; try { // utimensat var dirfd = SYSCALLS . get ( ) , path = SYSCALLS . getStr ( ) , times = SYSCALLS . get ( ) , flags = SYSCALLS . get ( ) ; assert ( flags === 0 ) ; path = SYSCALLS . calculateAt ( dirfd , path ) ; var seconds = HEAP32 [ ( ( times ) >> 2 ) ] ; var nanoseconds = HEAP32 [ ( ( ( times ) + ( 4 ) ) >> 2 ) ] ; var atime = ( seconds * 1000 ) + ( nanoseconds / ( 1000 * 1000 ) ) ; times += 8 ; seconds = HEAP32 [ ( ( times ) >> 2 ) ] ; nanoseconds = HEAP32 [ ( ( ( times ) + ( 4 ) ) >> 2 ) ] ; var mtime = ( seconds * 1000 ) + ( nanoseconds / ( 1000 * 1000 ) ) ; FS . utime ( path , atime , mtime ) ; return 0 ; } catch ( e ) { if ( typeof FS === 'undefined' || ! ( e instanceof FS . ErrnoError ) ) abort ( e ) ; return - e . errno ; } } function ___syscall33 ( which , varargs ) { SYSCALLS . varargs = varargs ; try { // access var path = SYSCALLS . getStr ( ) , amode = SYSCALLS . get ( ) ; return SYSCALLS . doAccess ( path , amode ) ; } catch ( e ) { if ( typeof FS === 'undefined' || ! ( e instanceof FS . ErrnoError ) ) abort ( e ) ; return - e . errno ; } } function ___syscall38 ( which , varargs ) { SYSCALLS . varargs = varargs ; try { // rename var old_path = SYSCALLS . getStr ( ) , new_path = SYSCALLS . getStr ( ) ; FS . rename ( old_path , new_path ) ; return 0 ; } catch ( e ) { if ( typeof FS === 'undefined' || ! ( e instanceof FS . ErrnoError ) ) abort ( e ) ; return - e . errno ; } } function ___syscall39 ( which , varargs ) { SYSCALLS . varargs = varargs ; try { // mkdir var path = SYSCALLS . getStr ( ) , mode = SYSCALLS . get ( ) ; return SYSCALLS . doMkdir ( path , mode ) ; } catch ( e ) { if ( typeof FS === 'undefined' || ! ( e instanceof FS . ErrnoError ) ) abort ( e ) ; return - e . errno ; } } function ___syscall5 ( which , varargs ) { SYSCALLS . varargs = varargs ; try { // open var pathname = SYSCALLS . getStr ( ) , flags = SYSCALLS . get ( ) , mode = SYSCALLS . get ( ) // optional TODO var stream = FS . open ( pathname , flags , mode ) ; return stream . fd ; } catch ( e ) { if ( typeof FS === 'undefined' || ! ( e instanceof FS . ErrnoError ) ) abort ( e ) ; return - e . errno ; } } function ___syscall54 ( which , varargs ) { SYSCALLS . varargs = varargs ; try { // ioctl var stream = SYSCALLS . getStreamFromFD ( ) , op = SYSCALLS . get ( ) ; switch ( op ) { case 21509 : case 21505 : { if ( ! stream . tty ) return - ERRNO_CODES . ENOTTY ; return 0 ; } case 21510 : case 21511 : case 21512 : case 21506 : case 21507 : case 21508 : { if ( ! stream . tty ) return - ERRNO_CODES . ENOTTY ; return 0 ; // no-op, not actually adjusting terminal settings } case 21519 : { if ( ! stream . tty ) return - ERRNO_CODES . ENOTTY ; var argp = SYSCALLS . get ( ) ; HEAP32 [ ( ( argp ) >> 2 ) ] = 0 ; return 0 ; } case 21520 : { if ( ! stream . tty ) return - ERRNO_CODES . ENOTTY ; return - ERRNO_CODES . EINVAL ; // not supported } case 21531 : { var argp = SYSCALLS . get ( ) ; return FS . ioctl ( stream , op , argp ) ; } case 21523 : { // TODO: in theory we should write to the winsize struct that gets // passed in, but for now musl doesn't read anything on it if ( ! stream . tty ) return - ERRNO_CODES . ENOTTY ; return 0 ; } case 21524 : { // TODO: technically, this ioctl call should change the window size. // but, since emscripten doesn't have any concept of a terminal window // yet, we'll just silently throw it away as we do TIOCGWINSZ if ( ! stream . tty ) return - ERRNO_CODES . ENOTTY ; return 0 ; } default : abort ( 'bad ioctl syscall ' + op ) ; } } catch ( e ) { if ( typeof FS === 'undefined' || ! ( e instanceof FS . ErrnoError ) ) abort ( e ) ; return - e . errno ; } } function ___syscall6 ( which , varargs ) { SYSCALLS . varargs = varargs ; try { // close var stream = SYSCALLS . getStreamFromFD ( ) ; FS . close ( stream ) ; return 0 ; } catch ( e ) { if ( typeof FS === 'undefined' || ! ( e instanceof FS . ErrnoError ) ) abort ( e ) ; return - e . errno ; } } var cttz_i8 = allocate ( [ 8 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 4 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 5 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 4 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 6 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 4 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 5 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 4 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 7 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 4 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 5 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 4 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 6 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 4 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 5 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 4 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 ] , "i8" , ALLOC_STATIC ) ; function ___unlock ( ) { } function _abort ( ) { Module [ 'abort' ] ( ) ; } function _longjmp ( env , value ) { Module [ 'setThrew' ] ( env , value || 1 ) ; throw 'longjmp' ; } function _emscripten_longjmp ( env , value ) { _longjmp ( env , value ) ; } function __exit ( status ) { // void _exit(int status); // http://pubs.opengroup.org/onlinepubs/000095399/functions/exit.html Module [ 'exit' ] ( status ) ; } function _exit ( status ) { __exit ( status ) ; } function _emscripten_memcpy_big ( dest , src , num ) { HEAPU8 . set ( HEAPU8 . subarray ( src , src + num ) , dest ) ; return dest ; } FS . staticInit ( ) ; __ATINIT__ . unshift ( function ( ) { if ( ! Module [ "noFSInit" ] && ! FS . init . initialized ) FS . init ( ) } ) ; __ATMAIN__ . push ( function ( ) { FS . ignorePermissions = false } ) ; __ATEXIT__ . push ( function ( ) { FS . quit ( ) } ) ; ; __ATINIT__ . unshift ( function ( ) { TTY . init ( ) } ) ; __ATEXIT__ . push ( function ( ) { TTY . shutdown ( ) } ) ; ; if ( ENVIRONMENT_IS_NODE ) { var fs = require ( "fs" ) ; var NODEJS_PATH = require ( "path" ) ; NODEFS . staticInit ( ) ; } ; DYNAMICTOP_PTR = staticAlloc ( 4 ) ; STACK_BASE = STACKTOP = alignMemory ( STATICTOP ) ; STACK_MAX = STACK_BASE + TOTAL_STACK ; DYNAMIC_BASE = alignMemory ( STACK_MAX ) ; HEAP32 [ DYNAMICTOP_PTR >> 2 ] = DYNAMIC_BASE ; staticSealed = true ; // seal the static portion of memory assert ( DYNAMIC_BASE < TOTAL_MEMORY , "TOTAL_MEMORY not big enough for stack" ) ; var ASSERTIONS = true ; /** @type {function(string, boolean=, number=)} */ function intArrayFromString ( stringy , dontAddNull , length ) { var len = length > 0 ? length : lengthBytesUTF8 ( stringy ) + 1 ; var u8array = new Array ( len ) ; var numBytesWritten = stringToUTF8Array ( stringy , u8array , 0 , u8array . length ) ; if ( dontAddNull ) u8array . length = numBytesWritten ; return u8array ; } function intArrayToString ( array ) { var ret = [ ] ; for ( var i = 0 ; i < array . length ; i ++ ) { var chr = array [ i ] ; if ( chr > 0xFF ) { if ( ASSERTIONS ) { assert ( false , 'Character code ' + chr + ' (' + String . fromCharCode ( chr ) + ')  at offset ' + i + ' not in 0x00-0xFF.' ) ; } chr &= 0xFF ; } ret . push ( String . fromCharCode ( chr ) ) ; } return ret . join ( '' ) ; } // Copied from https://github.com/strophe/strophejs/blob/e06d027/src/polyfills.js#L149 // This code was written by Tyler Akins and has been placed in the // public domain.  It would be nice if you left this header intact. // Base64 code from Tyler Akins -- http://rumkin.com /**  * Decodes a base64 string.  * @param {String} input The string to decode.  */ var decodeBase64 = typeof atob === 'function' ? atob : function ( input ) { var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' ; var output = '' ; var chr1 , chr2 , chr3 ; var enc1 , enc2 , enc3 , enc4 ; var i = 0 ; // remove all characters that are not A-Z, a-z, 0-9, +, /, or = input = input . replace ( / [^A-Za-z0-9\+\/\=] / g , '' ) ; do { enc1 = keyStr . indexOf ( input . charAt ( i ++ ) ) ; enc2 = keyStr . indexOf ( input . charAt ( i ++ ) ) ; enc3 = keyStr . indexOf ( input . charAt ( i ++ ) ) ; enc4 = keyStr . indexOf ( input . charAt ( i ++ ) ) ; chr1 = ( enc1 << 2 ) | ( enc2 >> 4 ) ; chr2 = ( ( enc2 & 15 ) << 4 ) | ( enc3 >> 2 ) ; chr3 = ( ( enc3 & 3 ) << 6 ) | enc4 ; output = output + String . fromCharCode ( chr1 ) ; if ( enc3 !== 64 ) { output = output + String . fromCharCode ( chr2 ) ; } if ( enc4 !== 64 ) { output = output + String . fromCharCode ( chr3 ) ; } } while ( i < input . length ) ; return output ; } ; // Converts a string of base64 into a byte array. // Throws error on invalid input. function intArrayFromBase64 ( s ) { if ( typeof ENVIRONMENT_IS_NODE === 'boolean' && ENVIRONMENT_IS_NODE ) { var buf ; try { buf = Buffer . from ( s , 'base64' ) ; } catch ( _ ) { buf = new Buffer ( s , 'base64' ) ; } return new Uint8Array ( buf . buffer , buf . byteOffset , buf . byteLength ) ; } try { var decoded = decodeBase64 ( s ) ; var bytes = new Uint8Array ( decoded . length ) ; for ( var i = 0 ; i < decoded . length ; ++ i ) { bytes [ i ] = decoded . charCodeAt ( i ) ; } return bytes ; } catch ( _ ) { throw new Error ( 'Converting base64 string to bytes failed.' ) ; } } // If filename is a base64 data URI, parses and returns data (Buffer on node, // Uint8Array otherwise). If filename is not a base64 data URI, returns undefined. function tryParseAsDataURI ( filename ) { if ( ! isDataURI ( filename ) ) { return ; } return intArrayFromBase64 ( filename . slice ( dataURIPrefix . length ) ) ; } function nullFunc_ii ( x ) { Module [ "printErr" ] ( "Invalid function pointer called with signature 'ii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)" ) ; Module [ "printErr" ] ( "Build with ASSERTIONS=2 for more info." ) ; abort ( x ) } function nullFunc_iii ( x ) { Module [ "printErr" ] ( "Invalid function pointer called with signature 'iii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)" ) ; Module [ "printErr" ] ( "Build with ASSERTIONS=2 for more info." ) ; abort ( x ) } function nullFunc_iiii ( x ) { Module [ "printErr" ] ( "Invalid function pointer called with signature 'iiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)" ) ; Module [ "printErr" ] ( "Build with ASSERTIONS=2 for more info." ) ; abort ( x ) } function nullFunc_iiiii ( x ) { Module [ "printErr" ] ( "Invalid function pointer called with signature 'iiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)" ) ; Module [ "printErr" ] ( "Build with ASSERTIONS=2 for more info." ) ; abort ( x ) } function nullFunc_v ( x ) { Module [ "printErr" ] ( "Invalid function pointer called with signature 'v'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)" ) ; Module [ "printErr" ] ( "Build with ASSERTIONS=2 for more info." ) ; abort ( x ) } function nullFunc_vi ( x ) { Module [ "printErr" ] ( "Invalid function pointer called with signature 'vi'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)" ) ; Module [ "printErr" ] ( "Build with ASSERTIONS=2 for more info." ) ; abort ( x ) } function nullFunc_vii ( x ) { Module [ "printErr" ] ( "Invalid function pointer called with signature 'vii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)" ) ; Module [ "printErr" ] ( "Build with ASSERTIONS=2 for more info." ) ; abort ( x ) } function nullFunc_viii ( x ) { Module [ "printErr" ] ( "Invalid function pointer called with signature 'viii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)" ) ; Module [ "printErr" ] ( "Build with ASSERTIONS=2 for more info." ) ; abort ( x ) } function nullFunc_viiii ( x ) { Module [ "printErr" ] ( "Invalid function pointer called with signature 'viiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)" ) ; Module [ "printErr" ] ( "Build with ASSERTIONS=2 for more info." ) ; abort ( x ) } function nullFunc_viiiii ( x ) { Module [ "printErr" ] ( "Invalid function pointer called with signature 'viiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)" ) ; Module [ "printErr" ] ( "Build with ASSERTIONS=2 for more info." ) ; abort ( x ) } function invoke_ii ( index , a1 ) { try { return Module [ "dynCall_ii" ] ( index , a1 ) ; } catch ( e ) { if ( typeof e !== 'number' && e !== 'longjmp' ) throw e ; Module [ "setThrew" ] ( 1 , 0 ) ; } } function invoke_iii ( index , a1 , a2 ) { try { return Module [ "dynCall_iii" ] ( index , a1 , a2 ) ; } catch ( e ) { if ( typeof e !== 'number' && e !== 'longjmp' ) throw e ; Module [ "setThrew" ] ( 1 , 0 ) ; } } function invoke_iiii ( index , a1 , a2 , a3 ) { try { return Module [ "dynCall_iiii" ] ( index , a1 , a2 , a3 ) ; } catch ( e ) { if ( typeof e !== 'number' && e !== 'longjmp' ) throw e ; Module [ "setThrew" ] ( 1 , 0 ) ; } } function invoke_iiiii ( index , a1 , a2 , a3 , a4 ) { try { return Module [ "dynCall_iiiii" ] ( index , a1 , a2 , a3 , a4 ) ; } catch ( e ) { if ( typeof e !== 'number' && e !== 'longjmp' ) throw e ; Module [ "setThrew" ] ( 1 , 0 ) ; } } function invoke_v ( index ) { try { Module [ "dynCall_v" ] ( index ) ; } catch ( e ) { if ( typeof e !== 'number' && e !== 'longjmp' ) throw e ; Module [ "setThrew" ] ( 1 , 0 ) ; } } function invoke_vi ( index , a1 ) { try { Module [ "dynCall_vi" ] ( index , a1 ) ; } catch ( e ) { if ( typeof e !== 'number' && e !== 'longjmp' ) throw e ; Module [ "setThrew" ] ( 1 , 0 ) ; } } function invoke_vii ( index , a1 , a2 ) { try { Module [ "dynCall_vii" ] ( index , a1 , a2 ) ; } catch ( e ) { if ( typeof e !== 'number' && e !== 'longjmp' ) throw e ; Module [ "setThrew" ] ( 1 , 0 ) ; } } function invoke_viii ( index , a1 , a2 , a3 ) { try { Module [ "dynCall_viii" ] ( index , a1 , a2 , a3 ) ; } catch ( e ) { if ( typeof e !== 'number' && e !== 'longjmp' ) throw e ; Module [ "setThrew" ] ( 1 , 0 ) ; } } function invoke_viiii ( index , a1 , a2 , a3 , a4 ) { try { Module [ "dynCall_viiii" ] ( index , a1 , a2 , a3 , a4 ) ; } catch ( e ) { if ( typeof e !== 'number' && e !== 'longjmp' ) throw e ; Module [ "setThrew" ] ( 1 , 0 ) ; } } function invoke_viiiii ( index , a1 , a2 , a3 , a4 , a5 ) { try { Module [ "dynCall_viiiii" ] ( index , a1 , a2 , a3 , a4 , a5 ) ; } catch ( e ) { if ( typeof e !== 'number' && e !== 'longjmp' ) throw e ; Module [ "setThrew" ] ( 1 , 0 ) ; } } Module . asmGlobalArg = { "Math" : Math , "Int8Array" : Int8Array , "Int16Array" : Int16Array , "Int32Array" : Int32Array , "Uint8Array" : Uint8Array , "Uint16Array" : Uint16Array , "Uint32Array" : Uint32Array , "Float32Array" : Float32Array , "Float64Array" : Float64Array , "NaN" : NaN , "Infinity" : Infinity } ; Module . asmLibraryArg = { "abort" : abort , "assert" : assert , "enlargeMemory" : enlargeMemory , "getTotalMemory" : getTotalMemory , "abortOnCannotGrowMemory" : abortOnCannotGrowMemory , "abortStackOverflow" : abortStackOverflow , "nullFunc_ii" : nullFunc_ii , "nullFunc_iii" : nullFunc_iii , "nullFunc_iiii" : nullFunc_iiii , "nullFunc_iiiii" : nullFunc_iiiii , "nullFunc_v" : nullFunc_v , "nullFunc_vi" : nullFunc_vi , "nullFunc_vii" : nullFunc_vii , "nullFunc_viii" : nullFunc_viii , "nullFunc_viiii" : nullFunc_viiii , "nullFunc_viiiii" : nullFunc_viiiii , "invoke_ii" : invoke_ii , "invoke_iii" : invoke_iii , "invoke_iiii" : invoke_iiii , "invoke_iiiii" : invoke_iiiii , "invoke_v" : invoke_v , "invoke_vi" : invoke_vi , "invoke_vii" : invoke_vii , "invoke_viii" : invoke_viii , "invoke_viiii" : invoke_viiii , "invoke_viiiii" : invoke_viiiii , "___assert_fail" : ___assert_fail , "___lock" : ___lock , "___setErrNo" : ___setErrNo , "___syscall10" : ___syscall10 , "___syscall140" : ___syscall140 , "___syscall145" : ___syscall145 , "___syscall146" : ___syscall146 , "___syscall15" : ___syscall15 , "___syscall195" : ___syscall195 , "___syscall197" : ___syscall197 , "___syscall212" : ___syscall212 , "___syscall221" : ___syscall221 , "___syscall320" : ___syscall320 , "___syscall33" : ___syscall33 , "___syscall38" : ___syscall38 , "___syscall39" : ___syscall39 , "___syscall5" : ___syscall5 , "___syscall54" : ___syscall54 , "___syscall6" : ___syscall6 , "___unlock" : ___unlock , "__exit" : __exit , "_abort" : _abort , "_emscripten_longjmp" : _emscripten_longjmp , "_emscripten_memcpy_big" : _emscripten_memcpy_big , "_exit" : _exit , "_longjmp" : _longjmp , "DYNAMICTOP_PTR" : DYNAMICTOP_PTR , "tempDoublePtr" : tempDoublePtr , "ABORT" : ABORT , "STACKTOP" : STACKTOP , "STACK_MAX" : STACK_MAX , "cttz_i8" : cttz_i8 } ; // EMSCRIPTEN_START_ASM var asm = ( /** @suppress {uselessCode} */ function ( global , env , buffer ) { 'almost asm' ; var HEAP8 = new global . Int8Array ( buffer ) ; var HEAP16 = new global . Int16Array ( buffer ) ; var HEAP32 = new global . Int32Array ( buffer ) ; var HEAPU8 = new global . Uint8Array ( buffer ) ; var HEAPU16 = new global . Uint16Array ( buffer ) ; var HEAPU32 = new global . Uint32Array ( buffer ) ; var HEAPF32 = new global . Float32Array ( buffer ) ; var HEAPF64 = new global . Float64Array ( buffer ) ; var DYNAMICTOP_PTR = env . DYNAMICTOP_PTR | 0 ; var tempDoublePtr = env . tempDoublePtr | 0 ; var ABORT = env . ABORT | 0 ; var STACKTOP = env . STACKTOP | 0 ; var STACK_MAX = env . STACK_MAX | 0 ; var cttz_i8 = env . cttz_i8 | 0 ; var __THREW__ = 0 ; var threwValue = 0 ; var setjmpId = 0 ; var undef = 0 ; var nan = global . NaN , inf = global . Infinity ; var tempInt = 0 , tempBigInt = 0 , tempBigIntS = 0 , tempValue = 0 , tempDouble = 0.0 ; var tempRet0 = 0 ; var Math_floor = global . Math . floor ; var Math_abs = global . Math . abs ; var Math_sqrt = global . Math . sqrt ; var Math_pow = global . Math . pow ; var Math_cos = global . Math . cos ; var Math_sin = global . Math . sin ; var Math_tan = global . Math . tan ; var Math_acos = global . Math . acos ; var Math_asin = global . Math . asin ; var Math_atan = global . Math . atan ; var Math_atan2 = global . Math . atan2 ; var Math_exp = global . Math . exp ; var Math_log = global . Math . log ; var Math_ceil = global . Math . ceil ; var Math_imul = global . Math . imul ; var Math_min = global . Math . min ; var Math_max = global . Math . max ; var Math_clz32 = global . Math . clz32 ; var abort = env . abort ; var assert = env . assert ; var enlargeMemory = env . enlargeMemory ; var getTotalMemory = env . getTotalMemory ; var abortOnCannotGrowMemory = env . abortOnCannotGrowMemory ; var abortStackOverflow = env . abortStackOverflow ; var nullFunc_ii = env . nullFunc_ii ; var nullFunc_iii = env . nullFunc_iii ; var nullFunc_iiii = env . nullFunc_iiii ; var nullFunc_iiiii = env . nullFunc_iiiii ; var nullFunc_v = env . nullFunc_v ; var nullFunc_vi = env . nullFunc_vi ; var nullFunc_vii = env . nullFunc_vii ; var nullFunc_viii = env . nullFunc_viii ; var nullFunc_viiii = env . nullFunc_viiii ; var nullFunc_viiiii = env . nullFunc_viiiii ; var invoke_ii = env . invoke_ii ; var invoke_iii = env . invoke_iii ; var invoke_iiii = env . invoke_iiii ; var invoke_iiiii = env . invoke_iiiii ; var invoke_v = env . invoke_v ; var invoke_vi = env . invoke_vi ; var invoke_vii = env . invoke_vii ; var invoke_viii = env . invoke_viii ; var invoke_viiii = env . invoke_viiii ; var invoke_viiiii = env . invoke_viiiii ; var ___assert_fail = env . ___assert_fail ; var ___lock = env . ___lock ; var ___setErrNo = env . ___setErrNo ; var ___syscall10 = env . ___syscall10 ; var ___syscall140 = env . ___syscall140 ; var ___syscall145 = env . ___syscall145 ; var ___syscall146 = env . ___syscall146 ; var ___syscall15 = env . ___syscall15 ; var ___syscall195 = env . ___syscall195 ; var ___syscall197 = env . ___syscall197 ; var ___syscall212 = env . ___syscall212 ; var ___syscall221 = env . ___syscall221 ; var ___syscall320 = env . ___syscall320 ; var ___syscall33 = env . ___syscall33 ; var ___syscall38 = env . ___syscall38 ; var ___syscall39 = env . ___syscall39 ; var ___syscall5 = env . ___syscall5 ; var ___syscall54 = env . ___syscall54 ; var ___syscall6 = env . ___syscall6 ; var ___unlock = env . ___unlock ; var __exit = env . __exit ; var _abort = env . _abort ; var _emscripten_longjmp = env . _emscripten_longjmp ; var _emscripten_memcpy_big = env . _emscripten_memcpy_big ; var _exit = env . _exit ; var _longjmp = env . _longjmp ; var tempFloat = 0.0 ; // EMSCRIPTEN_START_FUNCS function stackAlloc ( size ) { size = size | 0 ; var ret = 0 ; ret = STACKTOP ; STACKTOP = ( STACKTOP + size ) | 0 ; STACKTOP = ( STACKTOP + 15 ) & - 16 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( size | 0 ) ; return ret | 0 ; } function stackSave ( ) { return STACKTOP | 0 ; } function stackRestore ( top ) { top = top | 0 ; STACKTOP = top ; } function establishStackSpace ( stackBase , stackMax ) { stackBase = stackBase | 0 ; stackMax = stackMax | 0 ; STACKTOP = stackBase ; STACK_MAX = stackMax ; } function setThrew ( threw , value ) { threw = threw | 0 ; value = value | 0 ; if ( ( __THREW__ | 0 ) == 0 ) { __THREW__ = threw ; threwValue = value ; } } function setTempRet0 ( value ) { value = value | 0 ; tempRet0 = value ; } function getTempRet0 ( ) { return tempRet0 | 0 ; } function _main ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $vararg_buffer = 0 , $vararg_buffer1 = 0 , $vararg_buffer12 = 0 ; var $vararg_buffer15 = 0 , $vararg_buffer6 = 0 , $vararg_ptr10 = 0 , $vararg_ptr11 = 0 , $vararg_ptr18 = 0 , $vararg_ptr4 = 0 , $vararg_ptr5 = 0 , $vararg_ptr9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 80 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 80 | 0 ) ; $vararg_buffer15 = sp + 48 | 0 ; $vararg_buffer12 = sp + 40 | 0 ; $vararg_buffer6 = sp + 24 | 0 ; $vararg_buffer1 = sp + 8 | 0 ; $vararg_buffer = sp ; $2 = 0 ; $3 = $0 ; $4 = $1 ; $6 = $3 ; $7 = $4 ; _parse_args ( $6 , $7 ) ; _app_init ( ) ; $5 = 0 ; $8 = HEAP32 [ 16880 ] | 0 ; $9 = ( $8 | 0 ) != ( 0 ) ; if ( $9 ) { HEAP32 [ $vararg_buffer >> 2 ] = 16902 ; _app_printf ( 29758 , $vararg_buffer ) ; } $10 = HEAP32 [ 8416 ] | 0 ; switch ( $10 | 0 ) { case 0 : { $11 = $3 ; $12 = $4 ; $13 = ( _process_files ( $11 , $12 ) | 0 ) ; $5 = $13 ; _app_finish ( ) ; $18 = $5 ; STACKTOP = sp ; return ( $18 | 0 ) ; break ; } case 1 : { $14 = HEAP32 [ 16879 ] | 0 ; $15 = ( $14 | 0 ) != ( 0 ) ; if ( $15 ) { HEAP32 [ $vararg_buffer1 >> 2 ] = 16570 ; $vararg_ptr4 = ( ( ( $vararg_buffer1 ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr4 >> 2 ] = 14525 ; $vararg_ptr5 = ( ( ( $vararg_buffer1 ) ) + 8 | 0 ) ; HEAP32 [ $vararg_ptr5 >> 2 ] = 14395 ; _app_printf ( 13826 , $vararg_buffer1 ) ; _app_finish ( ) ; $18 = $5 ; STACKTOP = sp ; return ( $18 | 0 ) ; } else { HEAP32 [ $vararg_buffer6 >> 2 ] = 16570 ; $vararg_ptr9 = ( ( ( $vararg_buffer6 ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr9 >> 2 ] = 14220 ; $vararg_ptr10 = ( ( ( $vararg_buffer6 ) ) + 8 | 0 ) ; HEAP32 [ $vararg_ptr10 >> 2 ] = 14395 ; $vararg_ptr11 = ( ( ( $vararg_buffer6 ) ) + 12 | 0 ) ; HEAP32 [ $vararg_ptr11 >> 2 ] = 14182 ; _app_printf ( 13833 , $vararg_buffer6 ) ; _app_finish ( ) ; $18 = $5 ; STACKTOP = sp ; return ( $18 | 0 ) ; } break ; } case 2 : { HEAP32 [ $vararg_buffer12 >> 2 ] = 13887 ; _app_printf ( 29758 , $vararg_buffer12 ) ; $16 = ( _png_get_libpng_ver ( 0 ) | 0 ) ; $17 = ( _zlibVersion ( ) | 0 ) ; HEAP32 [ $vararg_buffer15 >> 2 ] = $16 ; $vararg_ptr18 = ( ( ( $vararg_buffer15 ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr18 >> 2 ] = $17 ; _app_printf ( 13842 , $vararg_buffer15 ) ; _app_finish ( ) ; $18 = $5 ; STACKTOP = sp ; return ( $18 | 0 ) ; break ; } default : { $5 = - 1 ; _app_finish ( ) ; $18 = $5 ; STACKTOP = sp ; return ( $18 | 0 ) ; } } return ( 0 ) | 0 ; } function _parse_args ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$sink = 0 , $$sink$sink$sink = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 ; var $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 ; var $134 = 0 , $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 ; var $152 = 0 , $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 ; var $170 = 0 , $171 = 0 , $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 ; var $189 = 0 , $19 = 0 , $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $2 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 ; var $206 = 0 , $207 = 0 , $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 ; var $224 = 0 , $225 = 0 , $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 ; var $242 = 0 , $243 = 0 , $244 = 0 , $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 , $258 = 0 , $259 = 0 , $26 = 0 ; var $260 = 0 , $261 = 0 , $262 = 0 , $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 , $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 , $270 = 0 , $271 = 0 , $272 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 ; var $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 ; var $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 ; var $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 ; var $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $or$cond = 0 , $or$cond11 = 0 , $or$cond13 = 0 , $or$cond15 = 0 , $or$cond17 = 0 , $or$cond19 = 0 , $or$cond3 = 0 ; var $or$cond5 = 0 , $or$cond7 = 0 , $or$cond9 = 0 , $vararg_buffer = 0 , $vararg_buffer20 = 0 , $vararg_buffer22 = 0 , $vararg_buffer24 = 0 , $vararg_buffer26 = 0 , $vararg_buffer28 = 0 , $vararg_buffer30 = 0 , $vararg_buffer32 = 0 , $vararg_buffer35 = 0 , $vararg_buffer37 = 0 , $vararg_buffer39 = 0 , dest = 0 , label = 0 , sp = 0 , stop = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 144 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 144 | 0 ) ; $vararg_buffer39 = sp + 80 | 0 ; $vararg_buffer37 = sp + 72 | 0 ; $vararg_buffer35 = sp + 64 | 0 ; $vararg_buffer32 = sp + 56 | 0 ; $vararg_buffer30 = sp + 48 | 0 ; $vararg_buffer28 = sp + 40 | 0 ; $vararg_buffer26 = sp + 32 | 0 ; $vararg_buffer24 = sp + 24 | 0 ; $vararg_buffer22 = sp + 16 | 0 ; $vararg_buffer20 = sp + 8 | 0 ; $vararg_buffer = sp ; $5 = sp + 128 | 0 ; $7 = sp + 108 | 0 ; $2 = $0 ; $3 = $1 ; dest = 33672 ; stop = dest + 104 | 0 ; do { HEAP32 [ dest >> 2 ] = 0 | 0 ; dest = dest + 4 | 0 ; } while ( ( dest | 0 ) < ( stop | 0 ) ) ; HEAP32 [ ( 33744 ) >> 2 ] = - 1 ; HEAP32 [ ( 33724 ) >> 2 ] = - 1 ; $12 = 0 ; $9 = 0 ; $13 = 1 ; while ( 1 ) { $14 = $13 ; $15 = $2 ; $16 = ( $14 | 0 ) < ( $15 | 0 ) ; if ( ! ( $16 ) ) { break ; } $17 = $3 ; $18 = $13 ; $19 = ( ( $17 ) + ( $18 << 2 ) | 0 ) ; $20 = HEAP32 [ $19 >> 2 ] | 0 ; $4 = $20 ; $21 = $9 ; $22 = ( $21 | 0 ) != ( 0 ) ; do { if ( $22 ) { label = 5 ; } else { $23 = $4 ; $24 = ( _scan_option ( $23 , $5 , 16 , $7 ) | 0 ) ; $25 = ( $24 | 0 ) < ( 1 ) ; if ( $25 ) { label = 5 ; } else { $28 = ( _strlen ( $5 ) | 0 ) ; $6 = $28 ; $29 = $3 ; $30 = $13 ; $31 = ( ( $29 ) + ( $30 << 2 ) | 0 ) ; HEAP32 [ $31 >> 2 ] = 0 ; $32 = HEAP8 [ $5 >> 0 ] | 0 ; $33 = $32 << 24 >> 24 ; $34 = ( _strchr ( 17100 , $33 ) | 0 ) ; $35 = ( $34 | 0 ) != ( 0 | 0 ) ; if ( $35 ) { $36 = ( ( ( $5 ) ) + 1 | 0 ) ; $37 = HEAP8 [ $36 >> 0 ] | 0 ; $38 = $37 << 24 >> 24 ; $39 = ( _isdigit ( $38 ) | 0 ) ; $40 = ( $39 | 0 ) != ( 0 ) ; if ( $40 ) { label = 11 ; } else { label = 8 ; } } else { label = 8 ; } if ( ( label | 0 ) == 8 ) { label = 0 ; $41 = HEAP8 [ $5 >> 0 ] | 0 ; $42 = $41 << 24 >> 24 ; $43 = ( $42 | 0 ) == ( 122 ) ; if ( $43 ) { $44 = ( ( ( $5 ) ) + 1 | 0 ) ; $45 = HEAP8 [ $44 >> 0 ] | 0 ; $46 = $45 << 24 >> 24 ; $47 = ( _isalpha ( $46 ) | 0 ) ; $48 = ( $47 | 0 ) != ( 0 ) ; if ( $48 ) { $49 = ( ( ( $5 ) ) + 2 | 0 ) ; $50 = HEAP8 [ $49 >> 0 ] | 0 ; $51 = $50 << 24 >> 24 ; $52 = ( _isdigit ( $51 ) | 0 ) ; $53 = ( $52 | 0 ) != ( 0 ) ; if ( $53 ) { label = 11 ; } } } } if ( ( label | 0 ) == 11 ) { label = 0 ; $54 = ( _opng_strpbrk_digit ( $5 ) | 0 ) ; $55 = $54 ; $56 = $5 ; $57 = ( ( $55 ) - ( $56 ) ) | 0 ; $6 = $57 ; $58 = $6 ; $59 = ( ( $5 ) + ( $58 ) | 0 ) ; HEAP8 [ $59 >> 0 ] = 0 ; $60 = $4 ; $61 = ( _opng_strpbrk_digit ( $60 ) | 0 ) ; HEAP32 [ $7 >> 2 ] = $61 ; } $8 = 1 ; $62 = ( _strcmp ( 17104 , $5 ) | 0 ) ; $63 = ( $62 | 0 ) == ( 0 ) ; L16 : do { if ( $63 ) { $9 = 1 ; } else { $64 = ( _strcmp ( 17106 , $5 ) | 0 ) ; $65 = ( $64 | 0 ) == ( 0 ) ; if ( ! ( $65 ) ) { $66 = $6 ; $67 = ( _strncmp ( 17108 , $5 , $66 ) | 0 ) ; $68 = ( $67 | 0 ) == ( 0 ) ; if ( ! ( $68 ) ) { $69 = $6 ; $70 = ( _strncmp ( 17113 , $5 , $69 ) | 0 ) ; $71 = ( $70 | 0 ) == ( 0 ) ; if ( ! ( $71 ) ) { $72 = $6 ; $73 = ( _strncmp ( 17120 , $5 , $72 ) | 0 ) ; $74 = ( $73 | 0 ) == ( 0 ) ; if ( ! ( $74 ) ) { $75 = $6 ; $76 = ( _strncmp ( 17125 , $5 , $75 ) | 0 ) ; $77 = ( $76 | 0 ) == ( 0 ) ; if ( $77 ) { HEAP32 [ ( 33676 ) >> 2 ] = 1 ; break ; } $78 = ( _strcmp ( 17133 , $5 ) | 0 ) ; $79 = ( $78 | 0 ) == ( 0 ) ; if ( $79 ) { HEAP32 [ ( 33680 ) >> 2 ] = 1 ; break ; } $80 = $6 ; $81 = ( _strncmp ( 17139 , $5 , $80 ) | 0 ) ; $82 = ( $81 | 0 ) == ( 0 ) ; $83 = $6 ; $84 = ( $83 >>> 0 ) >= ( 2 ) ; $or$cond = $82 & $84 ; if ( $or$cond ) { HEAP32 [ ( 33684 ) >> 2 ] = 1 ; break ; } $85 = $6 ; $86 = ( _strncmp ( 17143 , $5 , $85 ) | 0 ) ; $87 = ( $86 | 0 ) == ( 0 ) ; $88 = $6 ; $89 = ( $88 >>> 0 ) >= ( 2 ) ; $or$cond3 = $87 & $89 ; if ( $or$cond3 ) { HEAP32 [ ( 33688 ) >> 2 ] = 1 ; break ; } $90 = $6 ; $91 = ( _strncmp ( 17149 , $5 , $90 ) | 0 ) ; $92 = ( $91 | 0 ) == ( 0 ) ; $93 = $6 ; $94 = ( $93 >>> 0 ) >= ( 2 ) ; $or$cond5 = $92 & $94 ; if ( $or$cond5 ) { HEAP32 [ ( 33692 ) >> 2 ] = 1 ; break ; } $95 = ( _strcmp ( 17154 , $5 ) | 0 ) ; $96 = ( $95 | 0 ) == ( 0 ) ; if ( $96 ) { HEAP32 [ ( 33728 ) >> 2 ] = 1 ; break ; } $97 = ( _strcmp ( 17157 , $5 ) | 0 ) ; $98 = ( $97 | 0 ) == ( 0 ) ; if ( $98 ) { HEAP32 [ ( 33732 ) >> 2 ] = 1 ; break ; } $99 = ( _strcmp ( 17160 , $5 ) | 0 ) ; $100 = ( $99 | 0 ) == ( 0 ) ; if ( $100 ) { HEAP32 [ ( 33736 ) >> 2 ] = 1 ; break ; } $101 = ( _strcmp ( 17163 , $5 ) | 0 ) ; $102 = ( $101 | 0 ) == ( 0 ) ; if ( $102 ) { HEAP32 [ ( 33736 ) >> 2 ] = 1 ; HEAP32 [ ( 33732 ) >> 2 ] = 1 ; HEAP32 [ ( 33728 ) >> 2 ] = 1 ; break ; } $103 = ( _strcmp ( 17166 , $5 ) | 0 ) ; $104 = ( $103 | 0 ) == ( 0 ) ; if ( $104 ) { HEAP32 [ ( 33740 ) >> 2 ] = 1 ; break ; } $105 = $6 ; $106 = ( _strncmp ( 17169 , $5 , $105 ) | 0 ) ; $107 = ( $106 | 0 ) == ( 0 ) ; if ( $107 ) { HEAP32 [ ( 33696 ) >> 2 ] = 1 ; break ; } $108 = $6 ; $109 = ( _strncmp ( 17178 , $5 , $108 ) | 0 ) ; $110 = ( $109 | 0 ) == ( 0 ) ; do { if ( ! ( $110 ) ) { $111 = $6 ; $112 = ( _strncmp ( 17184 , $5 , $111 ) | 0 ) ; $113 = ( $112 | 0 ) == ( 0 ) ; $114 = $6 ; $115 = ( $114 >>> 0 ) >= ( 3 ) ; $or$cond7 = $113 & $115 ; if ( $or$cond7 ) { break ; } $116 = $6 ; $117 = ( _strncmp ( 17191 , $5 , $116 ) | 0 ) ; $118 = ( $117 | 0 ) == ( 0 ) ; $119 = $6 ; $120 = ( $119 >>> 0 ) >= ( 3 ) ; $or$cond9 = $118 & $120 ; if ( $or$cond9 ) { HEAP32 [ ( 33704 ) >> 2 ] = 1 ; break L16 ; } $121 = $6 ; $122 = ( _strncmp ( 17200 , $5 , $121 ) | 0 ) ; $123 = ( $122 | 0 ) == ( 0 ) ; $124 = $6 ; $125 = ( $124 >>> 0 ) >= ( 2 ) ; $or$cond11 = $123 & $125 ; if ( $or$cond11 ) { HEAP32 [ ( 33768 ) >> 2 ] = 1 ; break L16 ; } $126 = ( _strcmp ( 17205 , $5 ) | 0 ) ; $127 = ( $126 | 0 ) == ( 0 ) ; if ( $127 ) { HEAP32 [ ( 33708 ) >> 2 ] = 1 ; HEAP32 [ 16880 ] = 1 ; break L16 ; } $128 = $6 ; $129 = ( _strncmp ( 17207 , $5 , $128 ) | 0 ) ; $130 = ( $129 | 0 ) == ( 0 ) ; $131 = $6 ; $132 = ( $131 >>> 0 ) >= ( 4 ) ; $or$cond13 = $130 & $132 ; if ( $or$cond13 ) { HEAP32 [ ( 33708 ) >> 2 ] = 1 ; break L16 ; } $133 = $6 ; $134 = ( _strncmp ( 17215 , $5 , $133 ) | 0 ) ; $135 = ( $134 | 0 ) == ( 0 ) ; $136 = $6 ; $137 = ( $136 >>> 0 ) >= ( 4 ) ; $or$cond15 = $135 & $137 ; if ( $or$cond15 ) { HEAP32 [ 16880 ] = 1 ; break L16 ; } $8 = 0 ; $138 = HEAP32 [ $7 >> 2 ] | 0 ; $139 = ( $138 | 0 ) == ( 0 | 0 ) ; if ( ! ( $139 ) ) { break L16 ; } $140 = $13 ; $141 = ( ( $140 ) + 1 ) | 0 ; $13 = $141 ; $142 = $2 ; $143 = ( $141 | 0 ) < ( $142 | 0 ) ; if ( $143 ) { $144 = $3 ; $145 = $13 ; $146 = ( ( $144 ) + ( $145 << 2 ) | 0 ) ; $147 = HEAP32 [ $146 >> 2 ] | 0 ; HEAP32 [ $7 >> 2 ] = $147 ; $148 = $3 ; $149 = $13 ; $150 = ( ( $148 ) + ( $149 << 2 ) | 0 ) ; HEAP32 [ $150 >> 2 ] = 0 ; break L16 ; } else { HEAP32 [ $7 >> 2 ] = 100296 ; break L16 ; } } } while ( 0 ) ; HEAP32 [ ( 33700 ) >> 2 ] = 1 ; break ; } } HEAP32 [ 8418 ] = 1 ; break ; } } HEAP32 [ 16879 ] = 1 ; } } while ( 0 ) ; $151 = $8 ; $152 = ( $151 | 0 ) != ( 0 ) ; if ( $152 ) { $153 = HEAP32 [ $7 >> 2 ] | 0 ; $154 = ( $153 | 0 ) != ( 0 | 0 ) ; if ( ! ( $154 ) ) { break ; } $155 = $4 ; HEAP32 [ $vararg_buffer >> 2 ] = $155 ; _error ( 17223 , $vararg_buffer ) ; break ; } $156 = ( _strcmp ( 17258 , $5 ) | 0 ) ; $157 = ( $156 | 0 ) == ( 0 ) ; if ( $157 ) { $158 = HEAP32 [ $7 >> 2 ] | 0 ; $159 = ( _check_num_option ( 17260 , $158 , 0 , 2147483647 ) | 0 ) ; $11 = $159 ; $160 = HEAP32 [ ( 33744 ) >> 2 ] | 0 ; $161 = ( $160 | 0 ) < ( 0 ) ; if ( $161 ) { $162 = $11 ; HEAP32 [ ( 33744 ) >> 2 ] = $162 ; break ; } $163 = HEAP32 [ ( 33744 ) >> 2 ] | 0 ; $164 = $11 ; $165 = ( $163 | 0 ) != ( $164 | 0 ) ; if ( ! ( $165 ) ) { break ; } _error ( 17263 , $vararg_buffer20 ) ; break ; } $166 = ( _strcmp ( 17310 , $5 ) | 0 ) ; $167 = ( $166 | 0 ) == ( 0 ) ; if ( $167 ) { $168 = HEAP32 [ $7 >> 2 ] | 0 ; $169 = ( _check_num_option ( 17312 , $168 , 0 , 1 ) | 0 ) ; $11 = $169 ; $170 = HEAP32 [ ( 33724 ) >> 2 ] | 0 ; $171 = ( $170 | 0 ) < ( 0 ) ; if ( $171 ) { $172 = $11 ; HEAP32 [ ( 33724 ) >> 2 ] = $172 ; break ; } $173 = HEAP32 [ ( 33724 ) >> 2 ] | 0 ; $174 = $11 ; $175 = ( $173 | 0 ) != ( $174 | 0 ) ; if ( ! ( $175 ) ) { break ; } _error ( 17315 , $vararg_buffer22 ) ; break ; } $176 = ( _strcmp ( 17358 , $5 ) | 0 ) ; $177 = ( $176 | 0 ) == ( 0 ) ; if ( $177 ) { $178 = HEAP32 [ $7 >> 2 ] | 0 ; $179 = ( _check_rangeset_option ( 17360 , $178 , 63 ) | 0 ) ; $10 = $179 ; $180 = $10 ; $181 = HEAP32 [ ( 33760 ) >> 2 ] | 0 ; $182 = $181 | $180 ; HEAP32 [ ( 33760 ) >> 2 ] = $182 ; break ; } $183 = ( _strcmp ( 17363 , $5 ) | 0 ) ; $184 = ( $183 | 0 ) == ( 0 ) ; if ( $184 ) { $185 = HEAP32 [ $7 >> 2 ] | 0 ; $186 = ( _check_rangeset_option ( 17366 , $185 , 1022 ) | 0 ) ; $10 = $186 ; $187 = $10 ; $188 = HEAP32 [ ( 33748 ) >> 2 ] | 0 ; $189 = $188 | $187 ; HEAP32 [ ( 33748 ) >> 2 ] = $189 ; break ; } $190 = ( _strcmp ( 17370 , $5 ) | 0 ) ; $191 = ( $190 | 0 ) == ( 0 ) ; if ( $191 ) { $192 = HEAP32 [ $7 >> 2 ] | 0 ; $193 = ( _check_rangeset_option ( 17373 , $192 , 1022 ) | 0 ) ; $10 = $193 ; $194 = $10 ; $195 = HEAP32 [ ( 33752 ) >> 2 ] | 0 ; $196 = $195 | $194 ; HEAP32 [ ( 33752 ) >> 2 ] = $196 ; break ; } $197 = ( _strcmp ( 17377 , $5 ) | 0 ) ; $198 = ( $197 | 0 ) == ( 0 ) ; if ( $198 ) { $199 = HEAP32 [ $7 >> 2 ] | 0 ; $200 = ( _check_rangeset_option ( 17380 , $199 , 15 ) | 0 ) ; $10 = $200 ; $201 = $10 ; $202 = HEAP32 [ ( 33756 ) >> 2 ] | 0 ; $203 = $202 | $201 ; HEAP32 [ ( 33756 ) >> 2 ] = $203 ; break ; } $204 = ( _strcmp ( 17384 , $5 ) | 0 ) ; $205 = ( $204 | 0 ) == ( 0 ) ; if ( $205 ) { $206 = HEAP32 [ $7 >> 2 ] | 0 ; $207 = ( _check_power2_option ( 17387 , $206 , 8 , 15 ) | 0 ) ; $11 = $207 ; $208 = HEAP32 [ ( 33764 ) >> 2 ] | 0 ; $209 = ( $208 | 0 ) == ( 0 ) ; if ( $209 ) { $210 = $11 ; HEAP32 [ ( 33764 ) >> 2 ] = $210 ; break ; } $211 = HEAP32 [ ( 33764 ) >> 2 ] | 0 ; $212 = $11 ; $213 = ( $211 | 0 ) != ( $212 | 0 ) ; if ( ! ( $213 ) ) { break ; } _error ( 17391 , $vararg_buffer24 ) ; break ; } $214 = $6 ; $215 = ( _strncmp ( 17431 , $5 , $214 ) | 0 ) ; $216 = ( $215 | 0 ) == ( 0 ) ; $217 = $6 ; $218 = ( $217 >>> 0 ) >= ( 2 ) ; $or$cond17 = $216 & $218 ; if ( $or$cond17 ) { $219 = HEAP32 [ $7 >> 2 ] | 0 ; _check_obj_option ( 17437 , $219 ) ; HEAP32 [ ( 33772 ) >> 2 ] = 1 ; break ; } $220 = $6 ; $221 = ( _strncmp ( 17444 , $5 , $220 ) | 0 ) ; $222 = ( $221 | 0 ) == ( 0 ) ; $223 = $6 ; $224 = ( $223 >>> 0 ) >= ( 2 ) ; $or$cond19 = $222 & $224 ; if ( $or$cond19 ) { $225 = HEAP32 [ ( 33712 ) >> 2 ] | 0 ; $226 = ( $225 | 0 ) != ( 0 | 0 ) ; if ( $226 ) { _error ( 17448 , $vararg_buffer26 ) ; } $227 = HEAP32 [ $7 >> 2 ] | 0 ; $228 = HEAP8 [ $227 >> 0 ] | 0 ; $229 = $228 << 24 >> 24 ; $230 = ( $229 | 0 ) == ( 0 ) ; if ( $230 ) { _err_option_arg ( 17493 , 0 ) ; } $231 = HEAP32 [ $7 >> 2 ] | 0 ; HEAP32 [ ( 33712 ) >> 2 ] = $231 ; break ; } $232 = $6 ; $233 = ( _strncmp ( 17498 , $5 , $232 ) | 0 ) ; $234 = ( $233 | 0 ) == ( 0 ) ; if ( $234 ) { $235 = HEAP32 [ ( 33716 ) >> 2 ] | 0 ; $236 = ( $235 | 0 ) != ( 0 | 0 ) ; if ( $236 ) { _error ( 17502 , $vararg_buffer28 ) ; } $237 = HEAP32 [ $7 >> 2 ] | 0 ; $238 = HEAP8 [ $237 >> 0 ] | 0 ; $239 = $238 << 24 >> 24 ; $240 = ( $239 | 0 ) == ( 0 ) ; if ( $240 ) { _err_option_arg ( 17546 , 0 ) ; } $241 = HEAP32 [ $7 >> 2 ] | 0 ; HEAP32 [ ( 33716 ) >> 2 ] = $241 ; break ; } $242 = $6 ; $243 = ( _strncmp ( 17551 , $5 , $242 ) | 0 ) ; $244 = ( $243 | 0 ) == ( 0 ) ; if ( ! ( $244 ) ) { $252 = $4 ; HEAP32 [ $vararg_buffer32 >> 2 ] = $252 ; _error ( 17602 , $vararg_buffer32 ) ; break ; } $245 = HEAP32 [ ( 33720 ) >> 2 ] | 0 ; $246 = ( $245 | 0 ) != ( 0 | 0 ) ; if ( $246 ) { _error ( 17555 , $vararg_buffer30 ) ; } $247 = HEAP32 [ $7 >> 2 ] | 0 ; $248 = HEAP8 [ $247 >> 0 ] | 0 ; $249 = $248 << 24 >> 24 ; $250 = ( $249 | 0 ) == ( 0 ) ; if ( $250 ) { _err_option_arg ( 17597 , 0 ) ; } $251 = HEAP32 [ $7 >> 2 ] | 0 ; HEAP32 [ ( 33720 ) >> 2 ] = $251 ; } } } while ( 0 ) ; if ( ( label | 0 ) == 5 ) { label = 0 ; $26 = $12 ; $27 = ( ( $26 ) + 1 ) | 0 ; $12 = $27 ; } $253 = $13 ; $254 = ( ( $253 ) + 1 ) | 0 ; $13 = $254 ; } $255 = HEAP32 [ ( 33712 ) >> 2 ] | 0 ; $256 = ( $255 | 0 ) != ( 0 | 0 ) ; if ( $256 ) { $257 = $12 ; $258 = ( $257 >>> 0 ) > ( 1 ) ; if ( $258 ) { _error ( 17626 , $vararg_buffer35 ) ; } $259 = HEAP32 [ ( 33716 ) >> 2 ] | 0 ; $260 = ( $259 | 0 ) != ( 0 | 0 ) ; if ( $260 ) { _error ( 17666 , $vararg_buffer37 ) ; } } $261 = HEAP32 [ ( 33720 ) >> 2 ] | 0 ; $262 = ( $261 | 0 ) != ( 0 | 0 ) ; if ( $262 ) { $263 = HEAP32 [ ( 33720 ) >> 2 ] | 0 ; $264 = ( _opng_strtail ( $263 , 4 ) | 0 ) ; $265 = ( _opng_strcasecmp ( 17715 , $264 ) | 0 ) ; $266 = ( $265 | 0 ) != ( 0 ) ; if ( $266 ) { _error ( 17720 , $vararg_buffer39 ) ; } } $267 = HEAP32 [ 16879 ] | 0 ; $268 = ( $267 | 0 ) != ( 0 ) ; if ( $268 ) { $$sink$sink$sink = 1 ; HEAP32 [ 8416 ] = $$sink$sink$sink ; STACKTOP = sp ; return ; } $269 = $12 ; $270 = ( $269 | 0 ) != ( 0 ) ; if ( $270 ) { $$sink$sink$sink = 0 ; HEAP32 [ 8416 ] = $$sink$sink$sink ; STACKTOP = sp ; return ; } $271 = HEAP32 [ 16880 ] | 0 ; $272 = ( $271 | 0 ) != ( 0 ) ; $$sink = $272 ? 2 : 1 ; $$sink$sink$sink = $$sink ; HEAP32 [ 8416 ] = $$sink$sink$sink ; STACKTOP = sp ; return ; } function _app_init ( ) { var $$sink = 0 , $$sink$sink = 0 , $0 = 0 , $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , $vararg_buffer = 0 , $vararg_buffer2 = 0 ; var label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $vararg_buffer2 = sp + 8 | 0 ; $vararg_buffer = sp ; HEAP32 [ 8445 ] = 1 ; $0 = HEAP32 [ 8416 ] | 0 ; $1 = ( $0 | 0 ) == ( 1 ) ; $2 = HEAP32 [ 8416 ] | 0 ; $3 = ( $2 | 0 ) == ( 2 ) ; $or$cond = $1 | $3 ; if ( $or$cond ) { $4 = HEAP32 [ 2365 ] | 0 ; $$sink$sink = $4 ; } else { $5 = HEAP32 [ ( 33700 ) >> 2 ] | 0 ; $6 = ( $5 | 0 ) != ( 0 ) ; $7 = HEAP32 [ 2398 ] | 0 ; $$sink = $6 ? 0 : $7 ; $$sink$sink = $$sink ; } HEAP32 [ 8444 ] = $$sink$sink ; $8 = HEAP32 [ ( 33720 ) >> 2 ] | 0 ; $9 = ( $8 | 0 ) != ( 0 | 0 ) ; if ( ! ( $9 ) ) { STACKTOP = sp ; return ; } $10 = HEAP32 [ ( 33720 ) >> 2 ] | 0 ; $11 = ( _fopen ( $10 , 16992 ) | 0 ) ; HEAP32 [ 8417 ] = $11 ; $12 = ( $11 | 0 ) == ( 0 | 0 ) ; if ( $12 ) { $13 = HEAP32 [ ( 33720 ) >> 2 ] | 0 ; HEAP32 [ $vararg_buffer >> 2 ] = $13 ; _error ( 16994 , $vararg_buffer ) ; } $14 = HEAP32 [ 8417 ] | 0 ; ( _setvbuf ( $14 , 0 , 1 , 1024 ) | 0 ) ; HEAP32 [ $vararg_buffer2 >> 2 ] = 17036 ; _app_printf ( 17019 , $vararg_buffer2 ) ; STACKTOP = sp ; return ; } function _app_printf ( $0 , $varargs ) { $0 = $0 | 0 ; $varargs = $varargs | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 ; var $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $2 = sp ; $1 = $0 ; $3 = $1 ; $4 = HEAP8 [ $3 >> 0 ] | 0 ; $5 = $4 << 24 >> 24 ; $6 = ( $5 | 0 ) == ( 0 ) ; if ( $6 ) { STACKTOP = sp ; return ; } $7 = $1 ; $8 = $1 ; $9 = ( _strlen ( $8 ) | 0 ) ; $10 = ( ( $9 ) - 1 ) | 0 ; $11 = ( ( $7 ) + ( $10 ) | 0 ) ; $12 = HEAP8 [ $11 >> 0 ] | 0 ; $13 = $12 << 24 >> 24 ; $14 = ( $13 | 0 ) == ( 10 ) ; $15 = $14 ? 1 : 0 ; HEAP32 [ 8445 ] = $15 ; $16 = HEAP32 [ 8444 ] | 0 ; $17 = ( $16 | 0 ) != ( 0 | 0 ) ; if ( $17 ) { HEAP32 [ $2 >> 2 ] = $varargs ; $18 = HEAP32 [ 8444 ] | 0 ; $19 = $1 ; ( _vfprintf ( $18 , $19 , $2 ) | 0 ) ; } $20 = HEAP32 [ 8417 ] | 0 ; $21 = ( $20 | 0 ) != ( 0 | 0 ) ; if ( ! ( $21 ) ) { STACKTOP = sp ; return ; } HEAP32 [ $2 >> 2 ] = $varargs ; $22 = HEAP32 [ 8417 ] | 0 ; $23 = $1 ; ( _vfprintf ( $22 , $23 , $2 ) | 0 ) ; STACKTOP = sp ; return ; } function _process_files ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 ; var $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 48 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 48 | 0 ) ; $5 = sp + 8 | 0 ; $2 = $0 ; $3 = $1 ; HEAP32 [ $5 >> 2 ] = 11 ; $7 = ( ( ( $5 ) ) + 4 | 0 ) ; HEAP32 [ $7 >> 2 ] = 12 ; $8 = ( ( ( $5 ) ) + 8 | 0 ) ; HEAP32 [ $8 >> 2 ] = 13 ; $9 = ( ( ( $5 ) ) + 12 | 0 ) ; HEAP32 [ $9 >> 2 ] = 14 ; $10 = ( _opng_initialize ( 33672 , $5 ) | 0 ) ; $11 = ( $10 | 0 ) != ( 0 ) ; if ( $11 ) { _panic ( 16672 ) ; } $4 = 0 ; $6 = 1 ; while ( 1 ) { $12 = $6 ; $13 = $2 ; $14 = ( $12 | 0 ) < ( $13 | 0 ) ; if ( ! ( $14 ) ) { break ; } $15 = $3 ; $16 = $6 ; $17 = ( ( $15 ) + ( $16 << 2 ) | 0 ) ; $18 = HEAP32 [ $17 >> 2 ] | 0 ; $19 = ( $18 | 0 ) == ( 0 | 0 ) ; if ( ! ( $19 ) ) { $20 = $3 ; $21 = $6 ; $22 = ( ( $20 ) + ( $21 << 2 ) | 0 ) ; $23 = HEAP32 [ $22 >> 2 ] | 0 ; $24 = HEAP8 [ $23 >> 0 ] | 0 ; $25 = $24 << 24 >> 24 ; $26 = ( $25 | 0 ) == ( 0 ) ; if ( ! ( $26 ) ) { $27 = $3 ; $28 = $6 ; $29 = ( ( $27 ) + ( $28 << 2 ) | 0 ) ; $30 = HEAP32 [ $29 >> 2 ] | 0 ; $31 = ( _opng_optimize ( $30 ) | 0 ) ; $32 = ( $31 | 0 ) != ( 0 ) ; if ( $32 ) { $4 = 1 ; } } } $33 = $6 ; $34 = ( ( $33 ) + 1 ) | 0 ; $6 = $34 ; } $35 = ( _opng_finalize ( ) | 0 ) ; $36 = ( $35 | 0 ) != ( 0 ) ; if ( ! ( $36 ) ) { $37 = $4 ; STACKTOP = sp ; return ( $37 | 0 ) ; } _panic ( 16709 ) ; $37 = $4 ; STACKTOP = sp ; return ( $37 | 0 ) ; } function _app_finish ( ) { var $0 = 0 , $1 = 0 , $2 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $0 = HEAP32 [ 8417 ] | 0 ; $1 = ( $0 | 0 ) != ( 0 | 0 ) ; if ( ! ( $1 ) ) { return ; } $2 = HEAP32 [ 8417 ] | 0 ; ( _fclose ( $2 ) | 0 ) ; return ; } function _app_print_cntrl ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 ; var $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , $or$cond3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $5 = $1 ; $6 = ( $5 | 0 ) == ( 13 ) ; do { if ( $6 ) { $2 = 16896 ; $3 = 17974 ; HEAP32 [ 8445 ] = 1 ; } else { $7 = $1 ; $8 = ( $7 | 0 ) == ( 11 ) ; if ( $8 ) { $9 = HEAP32 [ 8445 ] | 0 ; $10 = ( $9 | 0 ) != ( 0 ) ; if ( $10 ) { $3 = 100296 ; $2 = 100296 ; break ; } else { $3 = 17974 ; $2 = 17974 ; HEAP32 [ 8445 ] = 1 ; break ; } } $11 = $1 ; $12 = ( $11 | 0 ) < ( 0 ) ; $13 = $1 ; $14 = ( $13 | 0 ) > ( - 80 ) ; $or$cond = $12 & $14 ; $15 = HEAP32 [ 8445 ] | 0 ; $16 = ( $15 | 0 ) != ( 0 ) ; $or$cond3 = $or$cond & $16 ; if ( ! ( $or$cond3 ) ) { $3 = 16898 ; $2 = 16898 ; break ; } $17 = HEAP32 [ 8444 ] | 0 ; $18 = ( $17 | 0 ) != ( 0 | 0 ) ; L13 : do { if ( $18 ) { $4 = 0 ; while ( 1 ) { $19 = $4 ; $20 = $1 ; $21 = ( $19 | 0 ) > ( $20 | 0 ) ; if ( ! ( $21 ) ) { break L13 ; } $22 = HEAP32 [ 8444 ] | 0 ; ( _fputc ( 32 , $22 ) | 0 ) ; $23 = $4 ; $24 = ( ( $23 ) + - 1 ) | 0 ; $4 = $24 ; } } } while ( 0 ) ; $2 = 16896 ; $3 = 100296 ; } } while ( 0 ) ; $25 = HEAP32 [ 8444 ] | 0 ; $26 = ( $25 | 0 ) != ( 0 | 0 ) ; if ( $26 ) { $27 = $2 ; $28 = HEAP32 [ 8444 ] | 0 ; ( _fputs ( $27 , $28 ) | 0 ) ; } $29 = HEAP32 [ 8417 ] | 0 ; $30 = ( $29 | 0 ) != ( 0 | 0 ) ; if ( ! ( $30 ) ) { STACKTOP = sp ; return ; } $31 = $3 ; $32 = HEAP32 [ 8417 ] | 0 ; ( _fputs ( $31 , $32 ) | 0 ) ; STACKTOP = sp ; return ; } function _app_progress ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = $0 ; $3 = $1 ; $4 = HEAP32 [ 8444 ] | 0 ; $5 = ( $4 | 0 ) != ( 0 | 0 ) ; if ( ! ( $5 ) ) { STACKTOP = sp ; return ; } $6 = HEAP32 [ 8444 ] | 0 ; ( _fflush ( $6 ) | 0 ) ; STACKTOP = sp ; return ; } function _panic ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $vararg_buffer = 0 , $vararg_buffer1 = 0 , $vararg_buffer3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $vararg_buffer3 = sp + 16 | 0 ; $vararg_buffer1 = sp + 8 | 0 ; $vararg_buffer = sp ; $1 = $0 ; $2 = HEAP32 [ 2398 ] | 0 ; $3 = $1 ; HEAP32 [ $vararg_buffer >> 2 ] = $3 ; ( _fprintf ( $2 , 16744 , $vararg_buffer ) | 0 ) ; $4 = HEAP32 [ 2398 ] | 0 ; ( _fprintf ( $4 , 16768 , $vararg_buffer1 ) | 0 ) ; $5 = HEAP32 [ 2398 ] | 0 ; ( _fflush ( $5 ) | 0 ) ; $6 = HEAP32 [ ( 33680 ) >> 2 ] | 0 ; $7 = ( $6 | 0 ) != ( 0 ) ; if ( $7 ) { _abort ( ) ; // unreachable; } else { $8 = HEAP32 [ 2398 ] | 0 ; ( _fprintf ( $8 , 16833 , $vararg_buffer3 ) | 0 ) ; _exit ( 70 ) ; // unreachable; } } function _error ( $0 , $varargs ) { $0 = $0 | 0 ; $varargs = $varargs | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $vararg_buffer = 0 , $vararg_buffer1 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 48 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 48 | 0 ) ; $vararg_buffer1 = sp + 8 | 0 ; $vararg_buffer = sp ; $2 = sp + 16 | 0 ; $1 = $0 ; $3 = HEAP32 [ 2398 ] | 0 ; ( _fprintf ( $3 , 17089 , $vararg_buffer ) | 0 ) ; HEAP32 [ $2 >> 2 ] = $varargs ; $4 = HEAP32 [ 2398 ] | 0 ; $5 = $1 ; ( _vfprintf ( $4 , $5 , $2 ) | 0 ) ; $6 = HEAP32 [ 2398 ] | 0 ; ( _fprintf ( $6 , 17974 , $vararg_buffer1 ) | 0 ) ; _exit ( 1 ) ; // unreachable; } function _scan_option ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $$sink1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 ; var $29 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 ; var $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 ; var $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 ; var $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $5 = $0 ; $6 = $1 ; $7 = $2 ; $8 = $3 ; $11 = $5 ; $12 = HEAP8 [ $11 >> 0 ] | 0 ; $13 = $12 << 24 >> 24 ; $14 = ( $13 | 0 ) != ( 45 ) ; if ( ! ( $14 ) ) { $15 = $5 ; $16 = ( ( ( $15 ) ) + 1 | 0 ) ; $17 = HEAP8 [ $16 >> 0 ] | 0 ; $18 = $17 << 24 >> 24 ; $19 = ( $18 | 0 ) == ( 0 ) ; if ( ! ( $19 ) ) { $10 = 0 ; $20 = $5 ; $21 = ( ( ( $20 ) ) + 1 | 0 ) ; $9 = $21 ; while ( 1 ) { $22 = $9 ; $23 = HEAP8 [ $22 >> 0 ] | 0 ; $24 = $23 << 24 >> 24 ; $25 = ( $24 | 0 ) == ( 45 ) ; $26 = $9 ; if ( ! ( $25 ) ) { break ; } $27 = ( ( ( $26 ) ) + 1 | 0 ) ; $9 = $27 ; } $28 = HEAP8 [ $26 >> 0 ] | 0 ; $29 = $28 << 24 >> 24 ; $30 = ( $29 | 0 ) == ( 0 ) ; if ( $30 ) { $31 = $9 ; $32 = ( ( ( $31 ) ) + - 1 | 0 ) ; $9 = $32 ; } while ( 1 ) { $33 = $10 ; $34 = $7 ; $35 = ( $33 >>> 0 ) < ( $34 >>> 0 ) ; if ( $35 ) { $36 = $9 ; $37 = HEAP8 [ $36 >> 0 ] | 0 ; $38 = $37 << 24 >> 24 ; $39 = ( _tolower ( $38 ) | 0 ) ; $40 = $39 & 255 ; $41 = $6 ; $42 = $10 ; $43 = ( ( $41 ) + ( $42 ) | 0 ) ; HEAP8 [ $43 >> 0 ] = $40 ; } $44 = $10 ; $45 = ( ( $44 ) + 1 ) | 0 ; $10 = $45 ; $46 = $9 ; $47 = ( ( ( $46 ) ) + 1 | 0 ) ; $9 = $47 ; $48 = $9 ; $49 = HEAP8 [ $48 >> 0 ] | 0 ; $50 = $49 << 24 >> 24 ; $51 = ( $50 | 0 ) == ( 0 ) ; if ( $51 ) { label = 13 ; break ; } $52 = $9 ; $53 = HEAP8 [ $52 >> 0 ] | 0 ; $54 = $53 << 24 >> 24 ; $55 = ( _isspace ( $54 ) | 0 ) ; $56 = ( $55 | 0 ) != ( 0 ) ; if ( $56 ) { label = 13 ; break ; } $70 = $9 ; $71 = HEAP8 [ $70 >> 0 ] | 0 ; $72 = $71 << 24 >> 24 ; $73 = ( $72 | 0 ) == ( 61 ) ; if ( $73 ) { label = 17 ; break ; } } if ( ( label | 0 ) == 13 ) { while ( 1 ) { label = 0 ; $57 = $9 ; $58 = HEAP8 [ $57 >> 0 ] | 0 ; $59 = $58 << 24 >> 24 ; $60 = ( _isspace ( $59 ) | 0 ) ; $61 = ( $60 | 0 ) != ( 0 ) ; $62 = $9 ; if ( ! ( $61 ) ) { break ; } $63 = ( ( ( $62 ) ) + 1 | 0 ) ; $9 = $63 ; label = 13 ; } $64 = HEAP8 [ $62 >> 0 ] | 0 ; $65 = $64 << 24 >> 24 ; $66 = ( $65 | 0 ) != ( 0 ) ; $67 = $9 ; $68 = $66 ? $67 : 0 ; $69 = $8 ; HEAP32 [ $69 >> 2 ] = $68 ; } else if ( ( label | 0 ) == 17 ) { $74 = $9 ; $75 = ( ( ( $74 ) ) + 1 | 0 ) ; $9 = $75 ; $76 = $9 ; $77 = $8 ; HEAP32 [ $77 >> 2 ] = $76 ; } $78 = $7 ; $79 = ( $78 >>> 0 ) > ( 0 ) ; if ( $79 ) { $80 = $10 ; $81 = $7 ; $82 = ( $80 >>> 0 ) < ( $81 >>> 0 ) ; $83 = $6 ; $84 = $7 ; $85 = ( ( $84 ) - 1 ) | 0 ; $86 = $10 ; $$sink1 = $82 ? $86 : $85 ; $87 = ( ( $83 ) + ( $$sink1 ) | 0 ) ; HEAP8 [ $87 >> 0 ] = 0 ; } $4 = 1 ; $88 = $4 ; STACKTOP = sp ; return ( $88 | 0 ) ; } } $4 = 0 ; $88 = $4 ; STACKTOP = sp ; return ( $88 | 0 ) ; } function _opng_strpbrk_digit ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = $0 ; while ( 1 ) { $3 = $2 ; $4 = HEAP8 [ $3 >> 0 ] | 0 ; $5 = $4 << 24 >> 24 ; $6 = ( $5 | 0 ) == ( 0 ) ; if ( $6 ) { label = 3 ; break ; } $7 = $2 ; $8 = HEAP8 [ $7 >> 0 ] | 0 ; $9 = $8 << 24 >> 24 ; $10 = ( _isdigit ( $9 ) | 0 ) ; $11 = ( $10 | 0 ) != ( 0 ) ; $12 = $2 ; if ( $11 ) { label = 5 ; break ; } $13 = ( ( ( $12 ) ) + 1 | 0 ) ; $2 = $13 ; } if ( ( label | 0 ) == 3 ) { $1 = 0 ; $14 = $1 ; STACKTOP = sp ; return ( $14 | 0 ) ; } else if ( ( label | 0 ) == 5 ) { $1 = $12 ; $14 = $1 ; STACKTOP = sp ; return ( $14 | 0 ) ; } return ( 0 ) | 0 ; } function _check_num_option ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 ; var label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $8 = sp ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $7 = $3 ; $9 = $5 ; $10 = ( _opng_str2ulong ( $8 , $9 , 0 ) | 0 ) ; $11 = ( $10 | 0 ) != ( 0 ) ; $12 = HEAP32 [ $8 >> 2 ] | 0 ; $13 = ( $12 >>> 0 ) > ( 2147483647 ) ; $or$cond = $11 | $13 ; if ( ! ( $or$cond ) ) { $14 = HEAP32 [ $8 >> 2 ] | 0 ; $15 = $6 ; $16 = ( $14 | 0 ) < ( $15 | 0 ) ; if ( ! ( $16 ) ) { $17 = HEAP32 [ $8 >> 2 ] | 0 ; $18 = $7 ; $19 = ( $17 | 0 ) > ( $18 | 0 ) ; if ( ! ( $19 ) ) { $22 = HEAP32 [ $8 >> 2 ] | 0 ; STACKTOP = sp ; return ( $22 | 0 ) ; } } } $20 = $4 ; $21 = $5 ; _err_option_arg ( $20 , $21 ) ; $22 = HEAP32 [ $8 >> 2 ] | 0 ; STACKTOP = sp ; return ( $22 | 0 ) ; } function _check_rangeset_option ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $6 = sp ; $3 = $0 ; $4 = $1 ; $5 = $2 ; $7 = $4 ; $8 = $5 ; $9 = ( _opng_strparse_rangeset_to_bitset ( $6 , $7 , $8 ) | 0 ) ; $10 = ( $9 | 0 ) != ( 0 ) ; if ( $10 ) { HEAP32 [ $6 >> 2 ] = 0 ; } $11 = HEAP32 [ $6 >> 2 ] | 0 ; $12 = $5 ; $13 = $11 & $12 ; $14 = HEAP32 [ $6 >> 2 ] | 0 ; $15 = ( $13 | 0 ) != ( $14 | 0 ) ; if ( $15 ) { HEAP32 [ $6 >> 2 ] = 0 ; } $16 = HEAP32 [ $6 >> 2 ] | 0 ; $17 = ( $16 | 0 ) == ( 0 ) ; if ( ! ( $17 ) ) { $20 = HEAP32 [ $6 >> 2 ] | 0 ; STACKTOP = sp ; return ( $20 | 0 ) ; } $18 = $3 ; $19 = $4 ; _err_option_arg ( $18 , $19 ) ; $20 = HEAP32 [ $6 >> 2 ] | 0 ; STACKTOP = sp ; return ( $20 | 0 ) ; } function _check_power2_option ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $30 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $9 = sp + 4 | 0 ; $5 = $0 ; $6 = $1 ; $7 = $2 ; $8 = $3 ; $11 = $6 ; $12 = ( _opng_str2ulong ( $9 , $11 , 1 ) | 0 ) ; $13 = ( $12 | 0 ) == ( 0 ) ; L1 : do { if ( $13 ) { $14 = $7 ; $15 = ( $14 | 0 ) < ( 0 ) ; if ( $15 ) { $7 = 0 ; } $16 = $8 ; $17 = ( $16 | 0 ) > ( 30 ) ; if ( $17 ) { $8 = 30 ; } $18 = $7 ; $10 = $18 ; while ( 1 ) { $19 = $10 ; $20 = $8 ; $21 = ( $19 | 0 ) <= ( $20 | 0 ) ; if ( ! ( $21 ) ) { break L1 ; } $22 = $10 ; $23 = 1 << $22 ; $24 = HEAP32 [ $9 >> 2 ] | 0 ; $25 = ( $23 | 0 ) == ( $24 | 0 ) ; $26 = $10 ; if ( $25 ) { break ; } $27 = ( ( $26 ) + 1 ) | 0 ; $10 = $27 ; } $4 = $26 ; $30 = $4 ; STACKTOP = sp ; return ( $30 | 0 ) ; } } while ( 0 ) ; $28 = $5 ; $29 = $6 ; _err_option_arg ( $28 , $29 ) ; $4 = - 1 ; $30 = $4 ; STACKTOP = sp ; return ( $30 | 0 ) ; } function _check_obj_option ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 ; var $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $5 = 0 ; var $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $vararg_buffer = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $vararg_buffer = sp ; $2 = $0 ; $3 = $1 ; $5 = $3 ; $6 = ( _strcmp ( 17864 , $5 ) | 0 ) ; $7 = ( $6 | 0 ) == ( 0 ) ; if ( $7 ) { STACKTOP = sp ; return ; } $4 = 0 ; while ( 1 ) { $8 = $4 ; $9 = ( $8 >>> 0 ) < ( 4 ) ; if ( ! ( $9 ) ) { break ; } $10 = $3 ; $11 = $4 ; $12 = ( ( $10 ) + ( $11 ) | 0 ) ; $13 = HEAP8 [ $12 >> 0 ] | 0 ; $14 = $13 << 24 >> 24 ; $15 = ( $14 | 0 ) >= ( 65 ) ; if ( $15 ) { $16 = $3 ; $17 = $4 ; $18 = ( ( $16 ) + ( $17 ) | 0 ) ; $19 = HEAP8 [ $18 >> 0 ] | 0 ; $20 = $19 << 24 >> 24 ; $21 = ( $20 | 0 ) <= ( 90 ) ; if ( ! ( $21 ) ) { label = 6 ; } } else { label = 6 ; } if ( ( label | 0 ) == 6 ) { label = 0 ; $22 = $3 ; $23 = $4 ; $24 = ( ( $22 ) + ( $23 ) | 0 ) ; $25 = HEAP8 [ $24 >> 0 ] | 0 ; $26 = $25 << 24 >> 24 ; $27 = ( $26 | 0 ) >= ( 97 ) ; if ( ! ( $27 ) ) { break ; } $28 = $3 ; $29 = $4 ; $30 = ( ( $28 ) + ( $29 ) | 0 ) ; $31 = HEAP8 [ $30 >> 0 ] | 0 ; $32 = $31 << 24 >> 24 ; $33 = ( $32 | 0 ) <= ( 122 ) ; if ( ! ( $33 ) ) { break ; } } $34 = $4 ; $35 = ( ( $34 ) + 1 ) | 0 ; $4 = $35 ; } $36 = $4 ; $37 = ( $36 | 0 ) == ( 4 ) ; if ( $37 ) { $38 = $3 ; $39 = $4 ; $40 = ( ( $38 ) + ( $39 ) | 0 ) ; $41 = HEAP8 [ $40 >> 0 ] | 0 ; $42 = $41 << 24 >> 24 ; $43 = ( $42 | 0 ) == ( 0 ) ; if ( $43 ) { _error ( 17868 , $vararg_buffer ) ; STACKTOP = sp ; return ; } } $44 = $2 ; $45 = $3 ; _err_option_arg ( $44 , $45 ) ; STACKTOP = sp ; return ; } function _err_option_arg ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $vararg_buffer = 0 , $vararg_buffer1 = 0 , $vararg_ptr4 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $vararg_buffer1 = sp + 8 | 0 ; $vararg_buffer = sp ; $2 = $0 ; $3 = $1 ; $4 = $3 ; $5 = ( $4 | 0 ) == ( 0 | 0 ) ; if ( ! ( $5 ) ) { $6 = $3 ; $7 = ( _opng_strltrim ( $6 ) | 0 ) ; $8 = HEAP8 [ $7 >> 0 ] | 0 ; $9 = $8 << 24 >> 24 ; $10 = ( $9 | 0 ) == ( 0 ) ; if ( ! ( $10 ) ) { $12 = $2 ; $13 = $3 ; HEAP32 [ $vararg_buffer1 >> 2 ] = $12 ; $vararg_ptr4 = ( ( ( $vararg_buffer1 ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr4 >> 2 ] = $13 ; _error ( 17829 , $vararg_buffer1 ) ; STACKTOP = sp ; return ; } } $11 = $2 ; HEAP32 [ $vararg_buffer >> 2 ] = $11 ; _error ( 17798 , $vararg_buffer ) ; STACKTOP = sp ; return ; } function _opng_strtail ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $3 = $0 ; $4 = $1 ; $6 = $3 ; $7 = ( _strlen ( $6 ) | 0 ) ; $5 = $7 ; $8 = $5 ; $9 = $4 ; $10 = ( $8 >>> 0 ) <= ( $9 >>> 0 ) ; $11 = $3 ; if ( $10 ) { $2 = $11 ; $17 = $2 ; STACKTOP = sp ; return ( $17 | 0 ) ; } else { $12 = $5 ; $13 = ( ( $11 ) + ( $12 ) | 0 ) ; $14 = $4 ; $15 = ( 0 - ( $14 ) ) | 0 ; $16 = ( ( $13 ) + ( $15 ) | 0 ) ; $2 = $16 ; $17 = $2 ; STACKTOP = sp ; return ( $17 | 0 ) ; } return ( 0 ) | 0 ; } function _opng_strcasecmp ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 ; var $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $3 = $0 ; $4 = $1 ; while ( 1 ) { $7 = $3 ; $8 = ( ( ( $7 ) ) + 1 | 0 ) ; $3 = $8 ; $9 = HEAP8 [ $7 >> 0 ] | 0 ; $10 = $9 << 24 >> 24 ; $11 = ( _tolower ( $10 ) | 0 ) ; $5 = $11 ; $12 = $4 ; $13 = ( ( ( $12 ) ) + 1 | 0 ) ; $4 = $13 ; $14 = HEAP8 [ $12 >> 0 ] | 0 ; $15 = $14 << 24 >> 24 ; $16 = ( _tolower ( $15 ) | 0 ) ; $6 = $16 ; $17 = $5 ; $18 = $6 ; $19 = ( $17 | 0 ) != ( $18 | 0 ) ; $20 = $5 ; if ( $19 ) { label = 3 ; break ; } $23 = ( $20 | 0 ) == ( 0 ) ; if ( $23 ) { label = 5 ; break ; } } if ( ( label | 0 ) == 3 ) { $21 = $6 ; $22 = ( ( $20 ) - ( $21 ) ) | 0 ; $2 = $22 ; $24 = $2 ; STACKTOP = sp ; return ( $24 | 0 ) ; } else if ( ( label | 0 ) == 5 ) { $2 = 0 ; $24 = $2 ; STACKTOP = sp ; return ( $24 | 0 ) ; } return ( 0 ) | 0 ; } function _opng_strltrim ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; while ( 1 ) { $2 = $1 ; $3 = HEAP8 [ $2 >> 0 ] | 0 ; $4 = $3 << 24 >> 24 ; $5 = ( _isspace ( $4 ) | 0 ) ; $6 = ( $5 | 0 ) != ( 0 ) ; $7 = $1 ; if ( ! ( $6 ) ) { break ; } $8 = ( ( ( $7 ) ) + 1 | 0 ) ; $1 = $8 ; } STACKTOP = sp ; return ( $7 | 0 ) ; } function _opng_str2ulong ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 ; var $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 ; var $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $8 = sp + 4 | 0 ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $10 = $5 ; $11 = ( _opng_strltrim ( $10 ) | 0 ) ; HEAP32 [ $8 >> 2 ] = $11 ; $7 = $11 ; $12 = $7 ; $13 = HEAP8 [ $12 >> 0 ] | 0 ; $14 = $13 << 24 >> 24 ; $15 = ( $14 | 0 ) >= ( 48 ) ; if ( $15 ) { $16 = $7 ; $17 = HEAP8 [ $16 >> 0 ] | 0 ; $18 = $17 << 24 >> 24 ; $19 = ( $18 | 0 ) <= ( 57 ) ; if ( $19 ) { $20 = $7 ; $21 = ( _strtoul ( $20 , $8 , 10 ) | 0 ) ; $22 = $4 ; HEAP32 [ $22 >> 2 ] = $21 ; } } $23 = $7 ; $24 = HEAP32 [ $8 >> 2 ] | 0 ; $25 = ( $23 | 0 ) == ( $24 | 0 ) ; if ( $25 ) { $26 = ( ___errno_location ( ) | 0 ) ; HEAP32 [ $26 >> 2 ] = 22 ; $27 = $4 ; HEAP32 [ $27 >> 2 ] = 0 ; $3 = - 1 ; $70 = $3 ; STACKTOP = sp ; return ( $70 | 0 ) ; } $28 = $6 ; $29 = ( $28 | 0 ) != ( 0 ) ; do { if ( $29 ) { $30 = HEAP32 [ $8 >> 2 ] | 0 ; $31 = HEAP8 [ $30 >> 0 ] | 0 ; $32 = $31 << 24 >> 24 ; $33 = ( $32 | 0 ) == ( 107 ) ; do { if ( $33 ) { label = 9 ; } else { $34 = HEAP32 [ $8 >> 2 ] | 0 ; $35 = HEAP8 [ $34 >> 0 ] | 0 ; $36 = $35 << 24 >> 24 ; $37 = ( $36 | 0 ) == ( 75 ) ; if ( $37 ) { label = 9 ; } else { $40 = HEAP32 [ $8 >> 2 ] | 0 ; $41 = HEAP8 [ $40 >> 0 ] | 0 ; $42 = $41 << 24 >> 24 ; $43 = ( $42 | 0 ) == ( 77 ) ; $44 = HEAP32 [ $8 >> 2 ] | 0 ; if ( $43 ) { $45 = ( ( ( $44 ) ) + 1 | 0 ) ; HEAP32 [ $8 >> 2 ] = $45 ; $9 = 1048576 ; break ; } $46 = HEAP8 [ $44 >> 0 ] | 0 ; $47 = $46 << 24 >> 24 ; $48 = ( $47 | 0 ) == ( 71 ) ; if ( $48 ) { $49 = HEAP32 [ $8 >> 2 ] | 0 ; $50 = ( ( ( $49 ) ) + 1 | 0 ) ; HEAP32 [ $8 >> 2 ] = $50 ; $9 = 1073741824 ; break ; } else { $9 = 1 ; break ; } } } } while ( 0 ) ; if ( ( label | 0 ) == 9 ) { $38 = HEAP32 [ $8 >> 2 ] | 0 ; $39 = ( ( ( $38 ) ) + 1 | 0 ) ; HEAP32 [ $8 >> 2 ] = $39 ; $9 = 1024 ; } $51 = $9 ; $52 = ( $51 >>> 0 ) > ( 1 ) ; if ( $52 ) { $53 = $4 ; $54 = HEAP32 [ $53 >> 2 ] | 0 ; $55 = $9 ; $56 = ( 4294967295 / ( $55 >>> 0 ) ) & - 1 ; $57 = ( $54 >>> 0 ) > ( $56 >>> 0 ) ; if ( $57 ) { $58 = ( ___errno_location ( ) | 0 ) ; HEAP32 [ $58 >> 2 ] = 34 ; $59 = $4 ; HEAP32 [ $59 >> 2 ] = - 1 ; break ; } else { $60 = $9 ; $61 = $4 ; $62 = HEAP32 [ $61 >> 2 ] | 0 ; $63 = Math_imul ( $62 , $60 ) | 0 ; HEAP32 [ $61 >> 2 ] = $63 ; break ; } } } } while ( 0 ) ; $64 = HEAP32 [ $8 >> 2 ] | 0 ; $65 = ( _opng_strltrim ( $64 ) | 0 ) ; $66 = HEAP8 [ $65 >> 0 ] | 0 ; $67 = $66 << 24 >> 24 ; $68 = ( $67 | 0 ) != ( 0 ) ; if ( $68 ) { $69 = ( ___errno_location ( ) | 0 ) ; HEAP32 [ $69 >> 2 ] = 22 ; $3 = - 1 ; $70 = $3 ; STACKTOP = sp ; return ( $70 | 0 ) ; } else { $3 = 0 ; $70 = $3 ; STACKTOP = sp ; return ( $70 | 0 ) ; } return ( 0 ) | 0 ; } function _opng_initialize ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $3 = 0 ; var $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , $or$cond3 = 0 , $or$cond5 = 0 , dest = 0 , label = 0 , sp = 0 , src = 0 , stop = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $3 = $0 ; $4 = $1 ; $5 = $4 ; $6 = HEAP32 [ $5 >> 2 ] | 0 ; HEAP32 [ 8449 ] = $6 ; $7 = $4 ; $8 = ( ( ( $7 ) ) + 4 | 0 ) ; $9 = HEAP32 [ $8 >> 2 ] | 0 ; HEAP32 [ 8450 ] = $9 ; $10 = $4 ; $11 = ( ( ( $10 ) ) + 8 | 0 ) ; $12 = HEAP32 [ $11 >> 2 ] | 0 ; HEAP32 [ 8451 ] = $12 ; $13 = $4 ; $14 = ( ( ( $13 ) ) + 12 | 0 ) ; $15 = HEAP32 [ $14 >> 2 ] | 0 ; HEAP32 [ 8452 ] = $15 ; $16 = HEAP32 [ 8449 ] | 0 ; $17 = ( $16 | 0 ) == ( 0 | 0 ) ; $18 = HEAP32 [ 8450 ] | 0 ; $19 = ( $18 | 0 ) == ( 0 | 0 ) ; $or$cond = $17 | $19 ; $20 = HEAP32 [ 8451 ] | 0 ; $21 = ( $20 | 0 ) == ( 0 | 0 ) ; $or$cond3 = $or$cond | $21 ; $22 = HEAP32 [ 8452 ] | 0 ; $23 = ( $22 | 0 ) == ( 0 | 0 ) ; $or$cond5 = $or$cond3 | $23 ; if ( $or$cond5 ) { $2 = - 1 ; $27 = $2 ; STACKTOP = sp ; return ( $27 | 0 ) ; } $24 = $3 ; dest = 33812 ; src = $24 ; stop = dest + 104 | 0 ; do { HEAP32 [ dest >> 2 ] = HEAP32 [ src >> 2 ] | 0 ; dest = dest + 4 | 0 ; src = src + 4 | 0 ; } while ( ( dest | 0 ) < ( stop | 0 ) ) ; $25 = HEAP32 [ ( 33884 ) >> 2 ] | 0 ; $26 = ( $25 | 0 ) == ( 0 ) ; if ( $26 ) { HEAP32 [ ( 33876 ) >> 2 ] = 1 ; HEAP32 [ ( 33872 ) >> 2 ] = 1 ; HEAP32 [ ( 33868 ) >> 2 ] = 1 ; HEAP32 [ ( 33880 ) >> 2 ] = 1 ; } ; HEAP32 [ 33916 >> 2 ] = 0 | 0 ; HEAP32 [ 33916 + 4 >> 2 ] = 0 | 0 ; HEAP32 [ 33916 + 8 >> 2 ] = 0 | 0 ; HEAP32 [ 33916 + 12 >> 2 ] = 0 | 0 ; HEAP32 [ 16881 ] = 1 ; $2 = 0 ; $27 = $2 ; STACKTOP = sp ; return ( $27 | 0 ) ; } function _opng_optimize ( $0 ) { $0 = $0 | 0 ; var $$reg2mem21$0 = 0 , $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 ; var $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 ; var $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 ; var $cond = 0 , $cond28 = 0 , $cond29 = 0 , $cond30 = 0 , $cond31 = 0 , $cond32 = 0 , $cond33 = 0 , $cond34 = 0 , $or$cond = 0 , $vararg_buffer = 0 , $vararg_buffer23 = 0 , _setjmpTable = 0 , _setjmpTableSize = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 176 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 176 | 0 ) ; $vararg_buffer23 = sp + 8 | 0 ; $vararg_buffer = sp ; _setjmpTableSize = 4 ; _setjmpTable = _malloc ( 40 ) | 0 ; HEAP32 [ _setjmpTable >> 2 ] = 0 ; $3 = sp + 12 | 0 ; $4 = HEAP32 [ 16881 ] | 0 ; $5 = ( $4 | 0 ) != ( 0 ) ; if ( $5 ) { label = 4 ; } else { $6 = HEAP32 [ 8452 ] | 0 ; __THREW__ = 0 ; invoke_vi ( $6 | 0 , ( 17921 | 0 ) ) ; $7 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $7 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $8 = _testSetjmp ( HEAP32 [ $7 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $8 | 0 ) == 0 ) { _longjmp ( $7 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $8 = - 1 ; } ; $9 = tempRet0 ; $cond = ( $8 | 0 ) == ( 1 ) ; if ( $cond ) { $$reg2mem21$0 = $9 ; } else { label = 4 ; } } if ( ( label | 0 ) == 4 ) { $10 = HEAP32 [ 8449 ] | 0 ; __THREW__ = 0 ; HEAP32 [ $vararg_buffer >> 2 ] = $0 ; invoke_vii ( $10 | 0 , ( 17955 | 0 ) , ( $vararg_buffer | 0 ) ) ; $11 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $11 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $12 = _testSetjmp ( HEAP32 [ $11 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $12 | 0 ) == 0 ) { _longjmp ( $11 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $12 = - 1 ; } ; $13 = tempRet0 ; $cond32 = ( $12 | 0 ) == ( 1 ) ; if ( $cond32 ) { $$reg2mem21$0 = $13 ; } else { $14 = HEAP32 [ 8479 ] | 0 ; $15 = ( ( $14 ) + 1 ) | 0 ; HEAP32 [ 8479 ] = $15 ; __THREW__ = 0 ; invoke_v ( 15 ) ; $16 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $16 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $17 = _testSetjmp ( HEAP32 [ $16 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $17 | 0 ) == 0 ) { _longjmp ( $16 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $17 = - 1 ; } ; $18 = tempRet0 ; $cond33 = ( $17 | 0 ) == ( 1 ) ; if ( $cond33 ) { $$reg2mem21$0 = $18 ; } else { $19 = HEAP32 [ 8446 ] | 0 ; $2 = $19 ; HEAP32 [ 8446 ] = $3 ; _setjmpTable = _saveSetjmp ( $3 , 1 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; _setjmpTableSize = tempRet0 ; __THREW__ = 0 ; $20 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $20 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $21 = _testSetjmp ( HEAP32 [ $20 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $21 | 0 ) == 0 ) { _longjmp ( $20 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $21 = - 1 ; } ; $22 = tempRet0 ; $cond34 = ( $21 | 0 ) == ( 1 ) ; if ( $cond34 ) { $$reg2mem21$0 = $22 ; } else { $$reg2mem21$0 = 0 ; } } } } L9 : while ( 1 ) { $23 = ( $$reg2mem21$0 | 0 ) == ( 0 ) ; if ( $23 ) { while ( 1 ) { __THREW__ = 0 ; invoke_vi ( 16 , ( $0 | 0 ) ) ; $24 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $24 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $25 = _testSetjmp ( HEAP32 [ $24 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $25 | 0 ) == 0 ) { _longjmp ( $24 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $25 = - 1 ; } ; $26 = tempRet0 ; $cond31 = ( $25 | 0 ) == ( 1 ) ; if ( $cond31 ) { $$reg2mem21$0 = $26 ; continue L9 ; } $27 = HEAP32 [ 8384 ] | 0 ; $28 = $27 & 256 ; $29 = ( $28 | 0 ) != ( 0 ) ; if ( $29 ) { $30 = HEAP32 [ ( 33920 ) >> 2 ] | 0 ; $31 = ( ( $30 ) + 1 ) | 0 ; HEAP32 [ ( 33920 ) >> 2 ] = $31 ; $32 = HEAP32 [ ( 33924 ) >> 2 ] | 0 ; $33 = ( ( $32 ) + 1 ) | 0 ; HEAP32 [ ( 33924 ) >> 2 ] = $33 ; } $34 = HEAP32 [ 8384 ] | 0 ; $35 = $34 & 16 ; $36 = ( $35 | 0 ) != ( 0 ) ; $37 = HEAP32 [ ( 33908 ) >> 2 ] | 0 ; $38 = ( $37 | 0 ) != ( 0 ) ; $or$cond = $36 & $38 ; if ( $or$cond ) { $39 = HEAP32 [ ( 33928 ) >> 2 ] | 0 ; $40 = ( ( $39 ) + 1 ) | 0 ; HEAP32 [ ( 33928 ) >> 2 ] = $40 ; } $1 = 0 ; HEAP32 [ ( 33788 ) >> 2 ] = 0 ; $41 = HEAP32 [ ( 33788 ) >> 2 ] | 0 ; $42 = ( $41 | 0 ) != ( 0 ) ; if ( ! ( $42 ) ) { break ; } } } else { HEAP32 [ ( 33788 ) >> 2 ] = 1 ; } $43 = $2 ; HEAP32 [ 8446 ] = $43 ; $44 = HEAP32 [ ( 33788 ) >> 2 ] | 0 ; $45 = ( $44 | 0 ) != ( 0 ) ; if ( $45 ) { $46 = HEAP32 [ ( 33792 ) >> 2 ] | 0 ; $47 = HEAP32 [ ( 33920 ) >> 2 ] | 0 ; $48 = ( ( $47 ) + 1 ) | 0 ; HEAP32 [ ( 33920 ) >> 2 ] = $48 ; __THREW__ = 0 ; invoke_vi ( 17 , ( $46 | 0 ) ) ; $49 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $49 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $50 = _testSetjmp ( HEAP32 [ $49 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $50 | 0 ) == 0 ) { _longjmp ( $49 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $50 = - 1 ; } ; $51 = tempRet0 ; $cond30 = ( $50 | 0 ) == ( 1 ) ; if ( $cond30 ) { $$reg2mem21$0 = $51 ; continue ; } $1 = - 1 ; } __THREW__ = 0 ; invoke_v ( 18 ) ; $52 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $52 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $53 = _testSetjmp ( HEAP32 [ $52 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $53 | 0 ) == 0 ) { _longjmp ( $52 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $53 = - 1 ; } ; $54 = tempRet0 ; $cond28 = ( $53 | 0 ) == ( 1 ) ; if ( $cond28 ) { $$reg2mem21$0 = $54 ; continue ; } $55 = HEAP32 [ 8449 ] | 0 ; __THREW__ = 0 ; invoke_vii ( $55 | 0 , ( 17974 | 0 ) , ( $vararg_buffer23 | 0 ) ) ; $56 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $56 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $57 = _testSetjmp ( HEAP32 [ $56 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $57 | 0 ) == 0 ) { _longjmp ( $56 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $57 = - 1 ; } ; $58 = tempRet0 ; $cond29 = ( $57 | 0 ) == ( 1 ) ; if ( $cond29 ) { $$reg2mem21$0 = $58 ; } else { break ; } } $59 = $1 ; _free ( _setjmpTable | 0 ) ; STACKTOP = sp ; return ( $59 | 0 ) ; } function _opng_clear_image_info ( ) { var dest = 0 , label = 0 , sp = 0 , stop = 0 ; sp = STACKTOP ; dest = 33932 ; stop = dest + 104 | 0 ; do { HEAP32 [ dest >> 2 ] = 0 | 0 ; dest = dest + 4 | 0 ; } while ( ( dest | 0 ) < ( stop | 0 ) ) ; return ; } function _opng_optimize_impl ( $0 ) { $0 = $0 | 0 ; var $$0 = 0 , $$reg2mem467$0 = 0 , $$reg2mem469$0 = 0 , $$reg2mem471$0 = 0 , $$sink$reg2mem$0 = 0 , $$sink2$reg2mem$0 = 0 , $1 = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 ; var $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 ; var $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 ; var $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 ; var $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 , $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 ; var $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 , $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $2 = 0 , $20 = 0 , $200 = 0 ; var $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 , $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 ; var $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 , $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 ; var $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 , $244 = 0 , $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 ; var $256 = 0 , $257 = 0 , $258 = 0 , $259 = 0 , $26 = 0 , $260 = 0 , $261 = 0 , $262 = 0 , $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 , $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 , $270 = 0 , $271 = 0 , $272 = 0 , $273 = 0 ; var $274 = 0 , $275 = 0 , $276 = 0 , $277 = 0 , $278 = 0 , $279 = 0 , $28 = 0 , $280 = 0 , $281 = 0 , $282 = 0 , $283 = 0 , $284 = 0 , $285 = 0 , $286 = 0 , $287 = 0 , $288 = 0 , $289 = 0 , $29 = 0 , $290 = 0 , $291 = 0 ; var $292 = 0 , $293 = 0 , $294 = 0 , $295 = 0 , $296 = 0 , $297 = 0 , $298 = 0 , $299 = 0 , $3 = 0 , $30 = 0 , $300 = 0 , $301 = 0 , $302 = 0 , $303 = 0 , $304 = 0 , $305 = 0 , $306 = 0 , $307 = 0 , $308 = 0 , $309 = 0 ; var $31 = 0 , $310 = 0 , $311 = 0 , $312 = 0 , $313 = 0 , $314 = 0 , $315 = 0 , $316 = 0 , $317 = 0 , $318 = 0 , $319 = 0 , $32 = 0 , $320 = 0 , $321 = 0 , $322 = 0 , $323 = 0 , $324 = 0 , $325 = 0 , $326 = 0 , $327 = 0 ; var $328 = 0 , $329 = 0 , $33 = 0 , $330 = 0 , $331 = 0 , $332 = 0 , $333 = 0 , $334 = 0 , $335 = 0 , $336 = 0 , $337 = 0 , $338 = 0 , $339 = 0 , $34 = 0 , $340 = 0 , $341 = 0 , $342 = 0 , $343 = 0 , $344 = 0 , $345 = 0 ; var $346 = 0 , $347 = 0 , $348 = 0 , $349 = 0 , $35 = 0 , $350 = 0 , $351 = 0 , $352 = 0 , $353 = 0 , $354 = 0 , $355 = 0 , $356 = 0 , $357 = 0 , $358 = 0 , $359 = 0 , $36 = 0 , $360 = 0 , $361 = 0 , $362 = 0 , $363 = 0 ; var $364 = 0 , $365 = 0 , $366 = 0 , $367 = 0 , $368 = 0 , $369 = 0 , $37 = 0 , $370 = 0 , $371 = 0 , $372 = 0 , $373 = 0 , $374 = 0 , $375 = 0 , $376 = 0 , $377 = 0 , $378 = 0 , $379 = 0 , $38 = 0 , $380 = 0 , $381 = 0 ; var $382 = 0 , $383 = 0 , $384 = 0 , $385 = 0 , $386 = 0 , $387 = 0 , $388 = 0 , $389 = 0 , $39 = 0 , $390 = 0 , $391 = 0 , $392 = 0 , $393 = 0 , $394 = 0 , $395 = 0 , $396 = 0 , $397 = 0 , $398 = 0 , $399 = 0 , $4 = 0 ; var $40 = 0 , $400 = 0 , $401 = 0 , $402 = 0 , $403 = 0 , $404 = 0 , $405 = 0 , $406 = 0 , $407 = 0 , $408 = 0 , $409 = 0 , $41 = 0 , $410 = 0 , $411 = 0 , $412 = 0 , $413 = 0 , $414 = 0 , $415 = 0 , $416 = 0 , $417 = 0 ; var $418 = 0 , $419 = 0 , $42 = 0 , $420 = 0 , $421 = 0 , $422 = 0 , $423 = 0 , $424 = 0 , $425 = 0 , $426 = 0 , $427 = 0 , $428 = 0 , $429 = 0 , $43 = 0 , $430 = 0 , $431 = 0 , $432 = 0 , $433 = 0 , $434 = 0 , $435 = 0 ; var $436 = 0 , $437 = 0 , $438 = 0 , $439 = 0 , $44 = 0 , $440 = 0 , $441 = 0 , $442 = 0 , $443 = 0 , $444 = 0 , $445 = 0 , $446 = 0 , $447 = 0 , $448 = 0 , $449 = 0 , $45 = 0 , $450 = 0 , $451 = 0 , $452 = 0 , $453 = 0 ; var $454 = 0 , $455 = 0 , $456 = 0 , $457 = 0 , $458 = 0 , $459 = 0 , $46 = 0 , $460 = 0 , $461 = 0 , $462 = 0 , $463 = 0 , $464 = 0 , $465 = 0 , $466 = 0 , $467 = 0 , $468 = 0 , $469 = 0 , $47 = 0 , $470 = 0 , $471 = 0 ; var $472 = 0 , $473 = 0 , $474 = 0 , $475 = 0 , $476 = 0 , $477 = 0 , $478 = 0 , $479 = 0 , $48 = 0 , $480 = 0 , $481 = 0 , $482 = 0 , $483 = 0 , $484 = 0 , $485 = 0 , $486 = 0 , $487 = 0 , $488 = 0 , $489 = 0 , $49 = 0 ; var $490 = 0 , $491 = 0 , $492 = 0 , $493 = 0 , $494 = 0 , $495 = 0 , $496 = 0 , $497 = 0 , $498 = 0 , $499 = 0 , $5 = 0 , $50 = 0 , $500 = 0 , $501 = 0 , $502 = 0 , $503 = 0 , $504 = 0 , $505 = 0 , $506 = 0 , $507 = 0 ; var $508 = 0 , $509 = 0 , $51 = 0 , $510 = 0 , $511 = 0 , $512 = 0 , $513 = 0 , $514 = 0 , $515 = 0 , $516 = 0 , $517 = 0 , $518 = 0 , $519 = 0 , $52 = 0 , $520 = 0 , $521 = 0 , $522 = 0 , $523 = 0 , $524 = 0 , $525 = 0 ; var $526 = 0 , $527 = 0 , $528 = 0 , $529 = 0 , $53 = 0 , $530 = 0 , $531 = 0 , $532 = 0 , $533 = 0 , $534 = 0 , $535 = 0 , $536 = 0 , $537 = 0 , $538 = 0 , $539 = 0 , $54 = 0 , $540 = 0 , $541 = 0 , $542 = 0 , $543 = 0 ; var $544 = 0 , $545 = 0 , $546 = 0 , $547 = 0 , $548 = 0 , $549 = 0 , $55 = 0 , $550 = 0 , $551 = 0 , $552 = 0 , $553 = 0 , $554 = 0 , $555 = 0 , $556 = 0 , $557 = 0 , $558 = 0 , $559 = 0 , $56 = 0 , $560 = 0 , $561 = 0 ; var $562 = 0 , $563 = 0 , $564 = 0 , $565 = 0 , $566 = 0 , $567 = 0 , $568 = 0 , $569 = 0 , $57 = 0 , $570 = 0 , $571 = 0 , $572 = 0 , $573 = 0 , $574 = 0 , $575 = 0 , $576 = 0 , $577 = 0 , $578 = 0 , $579 = 0 , $58 = 0 ; var $580 = 0 , $581 = 0 , $582 = 0 , $583 = 0 , $584 = 0 , $585 = 0 , $586 = 0 , $587 = 0 , $588 = 0 , $589 = 0 , $59 = 0 , $590 = 0 , $591 = 0 , $592 = 0 , $593 = 0 , $594 = 0 , $595 = 0 , $596 = 0 , $597 = 0 , $598 = 0 ; var $599 = 0 , $6 = 0 , $60 = 0 , $600 = 0 , $601 = 0 , $602 = 0 , $603 = 0 , $604 = 0 , $605 = 0 , $606 = 0 , $607 = 0 , $608 = 0 , $609 = 0 , $61 = 0 , $610 = 0 , $611 = 0 , $612 = 0 , $613 = 0 , $614 = 0 , $615 = 0 ; var $616 = 0 , $617 = 0 , $618 = 0 , $619 = 0 , $62 = 0 , $620 = 0 , $621 = 0 , $622 = 0 , $623 = 0 , $624 = 0 , $625 = 0 , $626 = 0 , $627 = 0 , $628 = 0 , $629 = 0 , $63 = 0 , $630 = 0 , $631 = 0 , $632 = 0 , $633 = 0 ; var $634 = 0 , $635 = 0 , $636 = 0 , $637 = 0 , $638 = 0 , $639 = 0 , $64 = 0 , $640 = 0 , $641 = 0 , $642 = 0 , $643 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 ; var $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 ; var $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $opng_optimize_impl$bakfile_name$sink = 0 , $opng_optimize_impl$bakfile_name$sink7 = 0 , $opng_optimize_impl$infile_name_local$sink = 0 , $or$cond = 0 , $or$cond11 = 0 , $or$cond4 = 0 , $or$cond6 = 0 , $or$cond9 = 0 , $vararg_buffer = 0 , $vararg_buffer473 = 0 , $vararg_buffer476 = 0 ; var $vararg_buffer479 = 0 , $vararg_buffer482 = 0 , $vararg_buffer485 = 0 , $vararg_buffer488 = 0 , $vararg_buffer491 = 0 , $vararg_buffer494 = 0 , $vararg_buffer497 = 0 , $vararg_buffer500 = 0 , $vararg_buffer503 = 0 , $vararg_buffer507 = 0 , $vararg_buffer511 = 0 , $vararg_buffer514 = 0 , $vararg_buffer518 = 0 , $vararg_buffer522 = 0 , $vararg_buffer525 = 0 , $vararg_buffer528 = 0 , $vararg_buffer532 = 0 , _setjmpTable = 0 , _setjmpTableSize = 0 , dest = 0 ; var label = 0 , sp = 0 , stop = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 8832 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 8832 | 0 ) ; $vararg_buffer532 = sp + 152 | 0 ; $vararg_buffer528 = sp + 144 | 0 ; $vararg_buffer525 = sp + 136 | 0 ; $vararg_buffer522 = sp + 128 | 0 ; $vararg_buffer518 = sp + 120 | 0 ; $vararg_buffer514 = sp + 112 | 0 ; $vararg_buffer511 = sp + 104 | 0 ; $vararg_buffer507 = sp + 96 | 0 ; $vararg_buffer503 = sp + 88 | 0 ; $vararg_buffer500 = sp + 80 | 0 ; $vararg_buffer497 = sp + 72 | 0 ; $vararg_buffer494 = sp + 64 | 0 ; $vararg_buffer491 = sp + 56 | 0 ; $vararg_buffer488 = sp + 48 | 0 ; $vararg_buffer485 = sp + 40 | 0 ; $vararg_buffer482 = sp + 32 | 0 ; $vararg_buffer479 = sp + 24 | 0 ; $vararg_buffer476 = sp + 16 | 0 ; $vararg_buffer473 = sp + 8 | 0 ; $vararg_buffer = sp ; _setjmpTableSize = 4 ; _setjmpTable = _malloc ( 40 ) | 0 ; HEAP32 [ _setjmpTable >> 2 ] = 0 ; $1 = sp + 4736 | 0 ; $2 = sp + 640 | 0 ; $5 = sp + 476 | 0 ; $7 = sp + 316 | 0 ; $9 = sp + 156 | 0 ; dest = 33536 ; stop = dest + 112 | 0 ; do { HEAP32 [ dest >> 2 ] = 0 | 0 ; dest = dest + 4 | 0 ; } while ( ( dest | 0 ) < ( stop | 0 ) ) ; $10 = HEAP32 [ ( 33828 ) >> 2 ] | 0 ; $11 = ( $10 | 0 ) != ( 0 ) ; if ( $11 ) { $12 = HEAP32 [ 8384 ] | 0 ; $13 = $12 | 8192 ; HEAP32 [ 8384 ] = $13 ; } $3 = 0 ; HEAP32 [ 8509 ] = $0 ; $14 = HEAP32 [ 8509 ] | 0 ; __THREW__ = 0 ; $15 = ( invoke_iii ( 19 , ( $14 | 0 ) , ( 17987 | 0 ) ) | 0 ) ; $16 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $16 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $17 = _testSetjmp ( HEAP32 [ $16 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $17 | 0 ) == 0 ) { _longjmp ( $16 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $17 = - 1 ; } ; $18 = tempRet0 ; L4 : do { switch ( $17 | 0 ) { case 1 : { $$reg2mem467$0 = $18 ; label = 159 ; break ; } case 2 : { $$reg2mem469$0 = $18 ; label = 146 ; break ; } case 3 : { $$reg2mem471$0 = $18 ; label = 9 ; break ; } default : { HEAP32 [ 8510 ] = $15 ; $19 = ( $15 | 0 ) == ( 0 | 0 ) ; if ( $19 ) { HEAP32 [ ( 33792 ) >> 2 ] = 17990 ; $20 = HEAP32 [ 8446 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 20 , ( $20 | 0 ) , 1 ) ; $21 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $21 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $22 = _testSetjmp ( HEAP32 [ $21 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $22 | 0 ) == 0 ) { _longjmp ( $21 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $22 = - 1 ; } ; $23 = tempRet0 ; switch ( $22 | 0 ) { case 1 : { $$reg2mem467$0 = $23 ; label = 159 ; break L4 ; break ; } case 2 : { $$reg2mem469$0 = $23 ; label = 146 ; break L4 ; break ; } case 3 : { $$reg2mem471$0 = $23 ; label = 9 ; break L4 ; break ; } default : { } } // unreachable; } else { $24 = HEAP32 [ 8446 ] | 0 ; $4 = $24 ; HEAP32 [ 8446 ] = $5 ; _setjmpTable = _saveSetjmp ( $5 , 3 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; _setjmpTableSize = tempRet0 ; __THREW__ = 0 ; $25 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $25 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $26 = _testSetjmp ( HEAP32 [ $25 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $26 | 0 ) == 0 ) { _longjmp ( $25 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $26 = - 1 ; } ; $27 = tempRet0 ; switch ( $26 | 0 ) { case 1 : { $$reg2mem467$0 = $27 ; label = 159 ; break L4 ; break ; } case 2 : { $$reg2mem469$0 = $27 ; label = 146 ; break L4 ; break ; } case 3 : { $$reg2mem471$0 = $27 ; label = 9 ; break L4 ; break ; } default : { } } $$reg2mem471$0 = 0 ; label = 9 ; break L4 ; } } } } while ( 0 ) ; L11 : while ( 1 ) { if ( ( label | 0 ) == 9 ) { label = 0 ; $28 = ( $$reg2mem471$0 | 0 ) == ( 0 ) ; L35 : do { if ( $28 ) { while ( 1 ) { $29 = HEAP32 [ 8510 ] | 0 ; __THREW__ = 0 ; invoke_vi ( 21 , ( $29 | 0 ) ) ; $30 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $30 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $31 = _testSetjmp ( HEAP32 [ $30 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $31 | 0 ) == 0 ) { _longjmp ( $30 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $31 = - 1 ; } ; $32 = tempRet0 ; switch ( $31 | 0 ) { case 1 : { $$reg2mem467$0 = $32 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $32 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $32 ; label = 9 ; continue L11 ; break ; } default : { } } HEAP32 [ ( 33788 ) >> 2 ] = 0 ; $33 = HEAP32 [ ( 33788 ) >> 2 ] | 0 ; $34 = ( $33 | 0 ) != ( 0 ) ; if ( ! ( $34 ) ) { break L35 ; } } } else { HEAP32 [ ( 33788 ) >> 2 ] = 1 ; } } while ( 0 ) ; $35 = $4 ; HEAP32 [ 8446 ] = $35 ; $36 = HEAP32 [ ( 33788 ) >> 2 ] | 0 ; $37 = ( $36 | 0 ) != ( 0 ) ; if ( $37 ) { $38 = HEAP32 [ ( 33792 ) >> 2 ] | 0 ; $3 = $38 ; $39 = $3 ; $40 = ( $39 | 0 ) != ( 0 | 0 ) ; if ( ! ( $40 ) ) { $41 = HEAP32 [ 8452 ] | 0 ; __THREW__ = 0 ; invoke_vi ( $41 | 0 , ( 18016 | 0 ) ) ; $42 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $42 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $43 = _testSetjmp ( HEAP32 [ $42 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $43 | 0 ) == 0 ) { _longjmp ( $42 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $43 = - 1 ; } ; $44 = tempRet0 ; switch ( $43 | 0 ) { case 1 : { $$reg2mem467$0 = $44 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $44 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $44 ; label = 9 ; continue L11 ; break ; } default : { } } } } $45 = HEAP32 [ 8510 ] | 0 ; __THREW__ = 0 ; ( invoke_ii ( 22 , ( $45 | 0 ) ) | 0 ) ; $46 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $46 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $47 = _testSetjmp ( HEAP32 [ $46 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $47 | 0 ) == 0 ) { _longjmp ( $46 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $47 = - 1 ; } ; $48 = tempRet0 ; switch ( $47 | 0 ) { case 1 : { $$reg2mem467$0 = $48 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $48 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $48 ; label = 9 ; continue L11 ; break ; } default : { } } $49 = $3 ; $50 = ( $49 | 0 ) != ( 0 | 0 ) ; if ( $50 ) { $51 = $3 ; HEAP32 [ ( 33792 ) >> 2 ] = $51 ; $52 = HEAP32 [ 8446 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 20 , ( $52 | 0 ) , 1 ) ; $53 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $53 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $54 = _testSetjmp ( HEAP32 [ $53 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $54 | 0 ) == 0 ) { _longjmp ( $53 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $54 = - 1 ; } ; $55 = tempRet0 ; switch ( $54 | 0 ) { case 1 : { $$reg2mem467$0 = $55 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $55 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $55 ; label = 9 ; continue L11 ; break ; } default : { label = 20 ; break L11 ; } } } $56 = HEAP32 [ 8384 ] | 0 ; $57 = $56 & 256 ; $58 = ( $57 | 0 ) != ( 0 ) ; do { if ( $58 ) { $59 = HEAP32 [ 8449 ] | 0 ; __THREW__ = 0 ; invoke_vii ( $59 | 0 , ( 18051 | 0 ) , ( $vararg_buffer | 0 ) ) ; $60 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $60 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $61 = _testSetjmp ( HEAP32 [ $60 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $61 | 0 ) == 0 ) { _longjmp ( $60 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $61 = - 1 ; } ; $62 = tempRet0 ; switch ( $61 | 0 ) { case 1 : { $$reg2mem467$0 = $62 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $62 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $62 ; label = 9 ; continue L11 ; break ; } default : { } } $63 = HEAP32 [ ( 33824 ) >> 2 ] | 0 ; $64 = ( $63 | 0 ) != ( 0 ) ; $65 = HEAP32 [ 8449 ] | 0 ; if ( $64 ) { __THREW__ = 0 ; invoke_vii ( $65 | 0 , ( 18086 | 0 ) , ( $vararg_buffer473 | 0 ) ) ; $66 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $66 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $67 = _testSetjmp ( HEAP32 [ $66 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $67 | 0 ) == 0 ) { _longjmp ( $66 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $67 = - 1 ; } ; $68 = tempRet0 ; switch ( $67 | 0 ) { case 1 : { $$reg2mem467$0 = $68 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $68 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $68 ; label = 9 ; continue L11 ; break ; } default : { } } $69 = HEAP32 [ 8384 ] | 0 ; $70 = $69 | 4096 ; HEAP32 [ 8384 ] = $70 ; break ; } else { __THREW__ = 0 ; invoke_vii ( $65 | 0 , ( 18098 | 0 ) , ( $vararg_buffer476 | 0 ) ) ; $71 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $71 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $72 = _testSetjmp ( HEAP32 [ $71 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $72 | 0 ) == 0 ) { _longjmp ( $71 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $72 = - 1 ; } ; $73 = tempRet0 ; switch ( $72 | 0 ) { case 1 : { $$reg2mem467$0 = $73 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $73 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $73 ; label = 9 ; continue L11 ; break ; } default : { } } HEAP32 [ ( 33792 ) >> 2 ] = 18133 ; $74 = HEAP32 [ 8446 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 20 , ( $74 | 0 ) , 1 ) ; $75 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $75 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $76 = _testSetjmp ( HEAP32 [ $75 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $76 | 0 ) == 0 ) { _longjmp ( $75 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $76 = - 1 ; } ; $77 = tempRet0 ; switch ( $76 | 0 ) { case 1 : { $$reg2mem467$0 = $77 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $77 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $77 ; label = 9 ; continue L11 ; break ; } default : { label = 28 ; break L11 ; } } } } } while ( 0 ) ; $78 = HEAP32 [ 8384 ] | 0 ; $79 = $78 & 128 ; $80 = ( $79 | 0 ) != ( 0 ) ; if ( $80 ) { $81 = HEAP32 [ 8384 ] | 0 ; $82 = $81 | 4096 ; HEAP32 [ 8384 ] = $82 ; } $83 = HEAP32 [ 8384 ] | 0 ; $84 = $83 & 4 ; $85 = ( $84 | 0 ) != ( 0 ) ; if ( ! ( $85 ) ) { $86 = HEAP32 [ 8384 ] | 0 ; $87 = $86 | 4096 ; HEAP32 [ 8384 ] = $87 ; } $88 = HEAP32 [ 8384 ] | 0 ; $89 = $88 & 2 ; $90 = ( $89 | 0 ) != ( 0 ) ; if ( $90 ) { $91 = HEAP32 [ ( 33880 ) >> 2 ] | 0 ; $92 = ( $91 | 0 ) != ( 0 ) ; if ( $92 ) { $93 = HEAP32 [ 8384 ] | 0 ; $94 = $93 & 8192 ; $95 = ( $94 | 0 ) != ( 0 ) ; if ( $95 ) { $96 = HEAP32 [ 8449 ] | 0 ; __THREW__ = 0 ; invoke_vii ( $96 | 0 , ( 18161 | 0 ) , ( $vararg_buffer479 | 0 ) ) ; $97 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $97 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $98 = _testSetjmp ( HEAP32 [ $97 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $98 | 0 ) == 0 ) { _longjmp ( $97 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $98 = - 1 ; } ; $99 = tempRet0 ; switch ( $98 | 0 ) { case 1 : { $$reg2mem467$0 = $99 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $99 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $99 ; label = 9 ; continue L11 ; break ; } default : { } } HEAP32 [ ( 33792 ) >> 2 ] = 18219 ; $100 = HEAP32 [ 8446 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 20 , ( $100 | 0 ) , 1 ) ; $101 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $101 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $102 = _testSetjmp ( HEAP32 [ $101 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $102 | 0 ) == 0 ) { _longjmp ( $101 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $102 = - 1 ; } ; $103 = tempRet0 ; switch ( $102 | 0 ) { case 1 : { $$reg2mem467$0 = $103 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $103 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $103 ; label = 9 ; continue L11 ; break ; } default : { label = 38 ; break L11 ; } } } } } else { $104 = HEAP32 [ 8384 ] | 0 ; $105 = $104 | 8192 ; HEAP32 [ 8384 ] = $105 ; } $106 = HEAP32 [ 8384 ] | 0 ; $107 = $106 & 8 ; $108 = ( $107 | 0 ) != ( 0 ) ; do { if ( $108 ) { $109 = HEAP32 [ 8449 ] | 0 ; __THREW__ = 0 ; invoke_vii ( $109 | 0 , ( 18234 | 0 ) , ( $vararg_buffer482 | 0 ) ) ; $110 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $110 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $111 = _testSetjmp ( HEAP32 [ $110 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $111 | 0 ) == 0 ) { _longjmp ( $110 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $111 = - 1 ; } ; $112 = tempRet0 ; switch ( $111 | 0 ) { case 1 : { $$reg2mem467$0 = $112 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $112 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $112 ; label = 9 ; continue L11 ; break ; } default : { } } $113 = HEAP32 [ ( 33828 ) >> 2 ] | 0 ; $114 = ( $113 | 0 ) != ( 0 ) ; $115 = HEAP32 [ 8449 ] | 0 ; if ( $114 ) { __THREW__ = 0 ; invoke_vii ( $115 | 0 , ( 18268 | 0 ) , ( $vararg_buffer485 | 0 ) ) ; $116 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $116 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $117 = _testSetjmp ( HEAP32 [ $116 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $117 | 0 ) == 0 ) { _longjmp ( $116 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $117 = - 1 ; } ; $118 = tempRet0 ; switch ( $117 | 0 ) { case 1 : { $$reg2mem467$0 = $118 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $118 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $118 ; label = 9 ; continue L11 ; break ; } default : { } } $119 = HEAP32 [ 8384 ] | 0 ; $120 = $119 | 4096 ; HEAP32 [ 8384 ] = $120 ; break ; } else { __THREW__ = 0 ; invoke_vii ( $115 | 0 , ( 18281 | 0 ) , ( $vararg_buffer488 | 0 ) ) ; $121 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $121 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $122 = _testSetjmp ( HEAP32 [ $121 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $122 | 0 ) == 0 ) { _longjmp ( $121 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $122 = - 1 ; } ; $123 = tempRet0 ; switch ( $122 | 0 ) { case 1 : { $$reg2mem467$0 = $123 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $123 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $123 ; label = 9 ; continue L11 ; break ; } default : { } } HEAP32 [ ( 33792 ) >> 2 ] = 18318 ; $124 = HEAP32 [ 8446 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 20 , ( $124 | 0 ) , 1 ) ; $125 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $125 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $126 = _testSetjmp ( HEAP32 [ $125 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $126 | 0 ) == 0 ) { _longjmp ( $125 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $126 = - 1 ; } ; $127 = tempRet0 ; switch ( $126 | 0 ) { case 1 : { $$reg2mem467$0 = $127 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $127 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $127 ; label = 9 ; continue L11 ; break ; } default : { label = 47 ; break L11 ; } } } } } while ( 0 ) ; $128 = HEAP32 [ 8384 ] | 0 ; $129 = $128 & 16 ; $130 = ( $129 | 0 ) == ( 0 ) ; $131 = HEAP32 [ ( 33908 ) >> 2 ] | 0 ; $132 = ( $131 | 0 ) != ( 0 ) ; $or$cond11 = $130 | $132 ; if ( ! ( $or$cond11 ) ) { $133 = HEAP32 [ 8384 ] | 0 ; $134 = $133 & 1 ; $135 = ( $134 | 0 ) != ( 0 ) ; if ( ! ( $135 ) ) { $136 = HEAP32 [ 8449 ] | 0 ; __THREW__ = 0 ; invoke_vii ( $136 | 0 , ( 18356 | 0 ) , ( $vararg_buffer491 | 0 ) ) ; $137 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $137 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $138 = _testSetjmp ( HEAP32 [ $137 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $138 | 0 ) == 0 ) { _longjmp ( $137 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $138 = - 1 ; } ; $139 = tempRet0 ; switch ( $138 | 0 ) { case 1 : { $$reg2mem467$0 = $139 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $139 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $139 ; label = 9 ; continue L11 ; break ; } default : { } } HEAP32 [ ( 33792 ) >> 2 ] = 18428 ; $140 = HEAP32 [ 8446 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 20 , ( $140 | 0 ) , 1 ) ; $141 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $141 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $142 = _testSetjmp ( HEAP32 [ $141 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $142 | 0 ) == 0 ) { _longjmp ( $141 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $142 = - 1 ; } ; $143 = tempRet0 ; switch ( $142 | 0 ) { case 1 : { $$reg2mem467$0 = $143 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $143 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $143 ; label = 9 ; continue L11 ; break ; } default : { label = 52 ; break L11 ; } } } } $144 = HEAP32 [ 8384 ] | 0 ; $145 = $144 & 32 ; $146 = ( $145 | 0 ) != ( 0 ) ; $147 = HEAP32 [ ( 33908 ) >> 2 ] | 0 ; $148 = ( $147 | 0 ) != ( 0 ) ; $or$cond = $146 & $148 ; if ( $or$cond ) { $149 = HEAP32 [ 8384 ] | 0 ; $150 = $149 | 4096 ; HEAP32 [ 8384 ] = $150 ; } $151 = HEAP32 [ 8384 ] | 0 ; $152 = $151 & 64 ; $153 = ( $152 | 0 ) != ( 0 ) ; if ( $153 ) { $154 = HEAP32 [ 8449 ] | 0 ; __THREW__ = 0 ; invoke_vii ( $154 | 0 , ( 18454 | 0 ) , ( $vararg_buffer494 | 0 ) ) ; $155 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $155 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $156 = _testSetjmp ( HEAP32 [ $155 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $156 | 0 ) == 0 ) { _longjmp ( $155 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $156 = - 1 ; } ; $157 = tempRet0 ; switch ( $156 | 0 ) { case 1 : { $$reg2mem467$0 = $157 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $157 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $157 ; label = 9 ; continue L11 ; break ; } default : { } } } HEAP32 [ 8511 ] = 0 ; $158 = HEAP32 [ 8384 ] | 0 ; $159 = $158 & 1 ; $160 = ( $159 | 0 ) != ( 0 ) ; do { if ( ! ( $160 ) ) { $161 = HEAP32 [ 8509 ] | 0 ; __THREW__ = 0 ; $162 = ( invoke_iiiii ( 23 , ( $1 | 0 ) , 4096 , ( $161 | 0 ) , ( 18477 | 0 ) ) | 0 ) ; $163 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $163 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $164 = _testSetjmp ( HEAP32 [ $163 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $164 | 0 ) == 0 ) { _longjmp ( $163 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $164 = - 1 ; } ; $165 = tempRet0 ; switch ( $164 | 0 ) { case 1 : { $$reg2mem467$0 = $165 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $165 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $165 ; label = 9 ; continue L11 ; break ; } default : { } } $166 = ( $162 | 0 ) == ( 0 | 0 ) ; if ( $166 ) { HEAP32 [ ( 33792 ) >> 2 ] = 18482 ; $167 = HEAP32 [ 8446 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 20 , ( $167 | 0 ) , 1 ) ; $168 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $168 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $169 = _testSetjmp ( HEAP32 [ $168 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $169 | 0 ) == 0 ) { _longjmp ( $168 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $169 = - 1 ; } ; $170 = tempRet0 ; switch ( $169 | 0 ) { case 1 : { $$reg2mem467$0 = $170 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $170 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $170 ; label = 9 ; continue L11 ; break ; } default : { label = 62 ; break L11 ; } } } else { HEAP32 [ 8511 ] = $1 ; break ; } } } while ( 0 ) ; $171 = HEAP32 [ ( 33852 ) >> 2 ] | 0 ; $172 = ( $171 | 0 ) != ( 0 | 0 ) ; if ( $172 ) { $173 = HEAP32 [ ( 33852 ) >> 2 ] | 0 ; HEAP32 [ 8511 ] = $173 ; } $174 = HEAP32 [ ( 33856 ) >> 2 ] | 0 ; $175 = ( $174 | 0 ) != ( 0 | 0 ) ; do { if ( $175 ) { $176 = HEAP32 [ 8511 ] | 0 ; $177 = ( $176 | 0 ) != ( 0 | 0 ) ; if ( $177 ) { $178 = HEAP32 [ 8511 ] | 0 ; __THREW__ = 0 ; ( invoke_iii ( 24 , ( $2 | 0 ) , ( $178 | 0 ) ) | 0 ) ; $179 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $179 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $180 = _testSetjmp ( HEAP32 [ $179 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $180 | 0 ) == 0 ) { _longjmp ( $179 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $180 = - 1 ; } ; $181 = tempRet0 ; switch ( $180 | 0 ) { case 1 : { $$reg2mem467$0 = $181 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $181 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $181 ; label = 9 ; continue L11 ; break ; } default : { } } $$0 = $2 ; } else { $182 = HEAP32 [ 8509 ] | 0 ; $$0 = $182 ; } $183 = HEAP32 [ ( 33856 ) >> 2 ] | 0 ; __THREW__ = 0 ; $184 = ( invoke_iiiii ( 25 , ( $1 | 0 ) , 4096 , ( $$0 | 0 ) , ( $183 | 0 ) ) | 0 ) ; $185 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $185 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $186 = _testSetjmp ( HEAP32 [ $185 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $186 | 0 ) == 0 ) { _longjmp ( $185 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $186 = - 1 ; } ; $187 = tempRet0 ; switch ( $186 | 0 ) { case 1 : { $$reg2mem467$0 = $187 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $187 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $187 ; label = 9 ; continue L11 ; break ; } default : { } } $188 = ( $184 | 0 ) == ( 0 | 0 ) ; if ( $188 ) { HEAP32 [ ( 33792 ) >> 2 ] = 18482 ; $189 = HEAP32 [ 8446 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 20 , ( $189 | 0 ) , 1 ) ; $190 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $190 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $191 = _testSetjmp ( HEAP32 [ $190 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $191 | 0 ) == 0 ) { _longjmp ( $190 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $191 = - 1 ; } ; $192 = tempRet0 ; switch ( $191 | 0 ) { case 1 : { $$reg2mem467$0 = $192 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $192 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $192 ; label = 9 ; continue L11 ; break ; } default : { label = 74 ; break L11 ; } } } else { HEAP32 [ 8511 ] = $1 ; break ; } } } while ( 0 ) ; $193 = HEAP32 [ 8511 ] | 0 ; $194 = ( $193 | 0 ) == ( 0 | 0 ) ; $195 = HEAP32 [ 8509 ] | 0 ; if ( $194 ) { HEAP32 [ 8511 ] = $195 ; $$sink$reg2mem$0 = 0 ; } else { $196 = HEAP32 [ 8511 ] | 0 ; __THREW__ = 0 ; $197 = ( invoke_iii ( 26 , ( $195 | 0 ) , ( $196 | 0 ) ) | 0 ) ; $198 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $198 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $199 = _testSetjmp ( HEAP32 [ $198 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $199 | 0 ) == 0 ) { _longjmp ( $198 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $199 = - 1 ; } ; $200 = tempRet0 ; switch ( $199 | 0 ) { case 1 : { $$reg2mem467$0 = $200 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $200 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $200 ; label = 9 ; continue L11 ; break ; } default : { } } $201 = ( $197 | 0 ) >= ( 0 ) ; if ( $201 ) { $202 = ( $197 | 0 ) == ( 0 ) ; $$sink2$reg2mem$0 = $202 ; } else { $203 = HEAP32 [ 8509 ] | 0 ; $204 = HEAP32 [ 8511 ] | 0 ; __THREW__ = 0 ; $205 = ( invoke_iii ( 27 , ( $203 | 0 ) , ( $204 | 0 ) ) | 0 ) ; $206 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $206 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $207 = _testSetjmp ( HEAP32 [ $206 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $207 | 0 ) == 0 ) { _longjmp ( $206 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $207 = - 1 ; } ; $208 = tempRet0 ; switch ( $207 | 0 ) { case 1 : { $$reg2mem467$0 = $208 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $208 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $208 ; label = 9 ; continue L11 ; break ; } default : { } } $209 = ( $205 | 0 ) != ( 0 ) ; $$sink2$reg2mem$0 = $209 ; } $210 = $$sink2$reg2mem$0 & 1 ; $$sink$reg2mem$0 = $210 ; } HEAP32 [ 8512 ] = $$sink$reg2mem$0 ; HEAP32 [ 8513 ] = $2 ; $211 = HEAP32 [ 8512 ] | 0 ; $212 = ( $211 | 0 ) != ( 0 ) ; do { if ( $212 ) { $213 = HEAP32 [ 8511 ] | 0 ; __THREW__ = 0 ; $214 = ( invoke_iiii ( 28 , ( $2 | 0 ) , 4096 , ( $213 | 0 ) ) | 0 ) ; $215 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $215 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $216 = _testSetjmp ( HEAP32 [ $215 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $216 | 0 ) == 0 ) { _longjmp ( $215 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $216 = - 1 ; } ; $217 = tempRet0 ; switch ( $216 | 0 ) { case 1 : { $$reg2mem467$0 = $217 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $217 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $217 ; label = 9 ; continue L11 ; break ; } default : { } } $218 = ( $214 | 0 ) == ( 0 | 0 ) ; if ( ! ( $218 ) ) { break ; } HEAP32 [ 8513 ] = 0 ; } else { $219 = HEAP32 [ 8509 ] | 0 ; __THREW__ = 0 ; $220 = ( invoke_iiii ( 28 , ( $2 | 0 ) , 4096 , ( $219 | 0 ) ) | 0 ) ; $221 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $221 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $222 = _testSetjmp ( HEAP32 [ $221 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $222 | 0 ) == 0 ) { _longjmp ( $221 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $222 = - 1 ; } ; $223 = tempRet0 ; switch ( $222 | 0 ) { case 1 : { $$reg2mem467$0 = $223 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $223 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $223 ; label = 9 ; continue L11 ; break ; } default : { } } $224 = ( $220 | 0 ) == ( 0 | 0 ) ; if ( ! ( $224 ) ) { break ; } HEAP32 [ 8513 ] = 0 ; } } while ( 0 ) ; $225 = HEAP32 [ 8513 ] | 0 ; $226 = ( $225 | 0 ) == ( 0 | 0 ) ; if ( $226 ) { HEAP32 [ ( 33792 ) >> 2 ] = 18527 ; $227 = HEAP32 [ 8446 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 20 , ( $227 | 0 ) , 1 ) ; $228 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $228 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $229 = _testSetjmp ( HEAP32 [ $228 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $229 | 0 ) == 0 ) { _longjmp ( $228 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $229 = - 1 ; } ; $230 = tempRet0 ; switch ( $229 | 0 ) { case 1 : { $$reg2mem467$0 = $230 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $230 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $230 ; label = 9 ; continue L11 ; break ; } default : { label = 93 ; break L11 ; } } } $231 = HEAP32 [ ( 33844 ) >> 2 ] | 0 ; $232 = ( $231 | 0 ) != ( 0 ) ; do { if ( ! ( $232 ) ) { $233 = HEAP32 [ 8511 ] | 0 ; __THREW__ = 0 ; $234 = ( invoke_iii ( 29 , ( $233 | 0 ) , ( 18568 | 0 ) ) | 0 ) ; $235 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $235 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $236 = _testSetjmp ( HEAP32 [ $235 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $236 | 0 ) == 0 ) { _longjmp ( $235 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $236 = - 1 ; } ; $237 = tempRet0 ; switch ( $236 | 0 ) { case 1 : { $$reg2mem467$0 = $237 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $237 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $237 ; label = 9 ; continue L11 ; break ; } default : { } } $238 = ( $234 | 0 ) == ( 0 ) ; if ( ! ( $238 ) ) { break ; } $239 = HEAP32 [ 8512 ] | 0 ; $240 = ( $239 | 0 ) == ( 0 ) ; $241 = HEAP32 [ 8453 ] | 0 ; $242 = ( $241 | 0 ) != ( 0 ) ; $or$cond4 = $240 | $242 ; $243 = HEAP32 [ ( 33816 ) >> 2 ] | 0 ; $244 = ( $243 | 0 ) != ( 0 ) ; $or$cond6 = $or$cond4 | $244 ; if ( ! ( $or$cond6 ) ) { $245 = HEAP32 [ 8449 ] | 0 ; __THREW__ = 0 ; invoke_vii ( $245 | 0 , ( 18570 | 0 ) , ( $vararg_buffer497 | 0 ) ) ; $246 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $246 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $247 = _testSetjmp ( HEAP32 [ $246 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $247 | 0 ) == 0 ) { _longjmp ( $246 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $247 = - 1 ; } ; $248 = tempRet0 ; switch ( $247 | 0 ) { case 1 : { $$reg2mem467$0 = $248 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $248 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $248 ; label = 9 ; continue L11 ; break ; } default : { } } HEAP32 [ ( 33792 ) >> 2 ] = 18631 ; $249 = HEAP32 [ 8446 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 20 , ( $249 | 0 ) , 1 ) ; $250 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $250 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $251 = _testSetjmp ( HEAP32 [ $250 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $251 | 0 ) == 0 ) { _longjmp ( $250 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $251 = - 1 ; } ; $252 = tempRet0 ; switch ( $251 | 0 ) { case 1 : { $$reg2mem467$0 = $252 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $252 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $252 ; label = 9 ; continue L11 ; break ; } default : { label = 100 ; break L11 ; } } } $253 = HEAP32 [ 8511 ] | 0 ; __THREW__ = 0 ; $254 = ( invoke_iii ( 29 , ( $253 | 0 ) , ( 18663 | 0 ) ) | 0 ) ; $255 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $255 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $256 = _testSetjmp ( HEAP32 [ $255 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $256 | 0 ) == 0 ) { _longjmp ( $255 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $256 = - 1 ; } ; $257 = tempRet0 ; switch ( $256 | 0 ) { case 1 : { $$reg2mem467$0 = $257 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $257 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $257 ; label = 9 ; continue L11 ; break ; } default : { } } $258 = ( $254 | 0 ) != ( 0 ) ; if ( ! ( $258 ) ) { $259 = HEAP32 [ ( 33816 ) >> 2 ] | 0 ; $260 = ( $259 | 0 ) != ( 0 ) ; if ( $260 ) { break ; } $261 = HEAP32 [ 8513 ] | 0 ; __THREW__ = 0 ; $262 = ( invoke_iii ( 29 , ( $261 | 0 ) , ( 18568 | 0 ) ) | 0 ) ; $263 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $263 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $264 = _testSetjmp ( HEAP32 [ $263 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $264 | 0 ) == 0 ) { _longjmp ( $263 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $264 = - 1 ; } ; $265 = tempRet0 ; switch ( $264 | 0 ) { case 1 : { $$reg2mem467$0 = $265 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $265 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $265 ; label = 9 ; continue L11 ; break ; } default : { } } $266 = ( $262 | 0 ) == ( 0 ) ; if ( ! ( $266 ) ) { break ; } } HEAP32 [ ( 33792 ) >> 2 ] = 18666 ; $267 = HEAP32 [ 8446 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 20 , ( $267 | 0 ) , 1 ) ; $268 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $268 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $269 = _testSetjmp ( HEAP32 [ $268 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $269 | 0 ) == 0 ) { _longjmp ( $268 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $269 = - 1 ; } ; $270 = tempRet0 ; switch ( $269 | 0 ) { case 1 : { $$reg2mem467$0 = $270 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $270 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $270 ; label = 9 ; continue L11 ; break ; } default : { label = 107 ; break L11 ; } } } } while ( 0 ) ; $271 = HEAP32 [ 8384 ] | 0 ; $272 = $271 & 2 ; $273 = ( $272 | 0 ) != ( 0 ) ; if ( $273 ) { $274 = HEAP32 [ 8449 ] | 0 ; $275 = ( 33568 ) ; $276 = $275 ; $277 = HEAP32 [ $276 >> 2 ] | 0 ; $278 = ( ( $275 ) + 4 ) | 0 ; $279 = $278 ; $280 = HEAP32 [ $279 >> 2 ] | 0 ; __THREW__ = 0 ; $281 = $vararg_buffer500 ; $282 = $281 ; HEAP32 [ $282 >> 2 ] = $277 ; $283 = ( ( $281 ) + 4 ) | 0 ; $284 = $283 ; HEAP32 [ $284 >> 2 ] = $280 ; invoke_vii ( $274 | 0 , ( 18705 | 0 ) , ( $vararg_buffer500 | 0 ) ) ; $285 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $285 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $286 = _testSetjmp ( HEAP32 [ $285 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $286 | 0 ) == 0 ) { _longjmp ( $285 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $286 = - 1 ; } ; $287 = tempRet0 ; switch ( $286 | 0 ) { case 1 : { $$reg2mem467$0 = $287 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $287 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $287 ; label = 9 ; continue L11 ; break ; } default : { } } } $288 = HEAP32 [ 8449 ] | 0 ; $289 = ( 33552 ) ; $290 = $289 ; $291 = HEAP32 [ $290 >> 2 ] | 0 ; $292 = ( ( $289 ) + 4 ) | 0 ; $293 = $292 ; $294 = HEAP32 [ $293 >> 2 ] | 0 ; __THREW__ = 0 ; $295 = $vararg_buffer503 ; $296 = $295 ; HEAP32 [ $296 >> 2 ] = $291 ; $297 = ( ( $295 ) + 4 ) | 0 ; $298 = $297 ; HEAP32 [ $298 >> 2 ] = $294 ; invoke_vii ( $288 | 0 , ( 18735 | 0 ) , ( $vararg_buffer503 | 0 ) ) ; $299 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $299 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $300 = _testSetjmp ( HEAP32 [ $299 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $300 | 0 ) == 0 ) { _longjmp ( $299 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $300 = - 1 ; } ; $301 = tempRet0 ; switch ( $300 | 0 ) { case 1 : { $$reg2mem467$0 = $301 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $301 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $301 ; label = 9 ; continue L11 ; break ; } default : { } } $302 = HEAP32 [ ( 33880 ) >> 2 ] | 0 ; $303 = ( $302 | 0 ) != ( 0 ) ; if ( $303 ) { $304 = HEAP32 [ 8384 ] | 0 ; $305 = $304 & 8192 ; $306 = ( $305 | 0 ) != ( 0 ) ; if ( $306 ) { label = 114 ; } } else { label = 114 ; } if ( ( label | 0 ) == 114 ) { label = 0 ; __THREW__ = 0 ; invoke_v ( 30 ) ; $307 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $307 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $308 = _testSetjmp ( HEAP32 [ $307 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $308 | 0 ) == 0 ) { _longjmp ( $307 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $308 = - 1 ; } ; $309 = tempRet0 ; switch ( $308 | 0 ) { case 1 : { $$reg2mem467$0 = $309 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $309 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $309 ; label = 9 ; continue L11 ; break ; } default : { } } __THREW__ = 0 ; invoke_v ( 31 ) ; $310 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $310 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $311 = _testSetjmp ( HEAP32 [ $310 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $311 | 0 ) == 0 ) { _longjmp ( $310 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $311 = - 1 ; } ; $312 = tempRet0 ; switch ( $311 | 0 ) { case 1 : { $$reg2mem467$0 = $312 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $312 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $312 ; label = 9 ; continue L11 ; break ; } default : { } } __THREW__ = 0 ; invoke_v ( 32 ) ; $313 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $313 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $314 = _testSetjmp ( HEAP32 [ $313 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $314 | 0 ) == 0 ) { _longjmp ( $313 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $314 = - 1 ; } ; $315 = tempRet0 ; switch ( $314 | 0 ) { case 1 : { $$reg2mem467$0 = $315 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $315 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $315 ; label = 9 ; continue L11 ; break ; } default : { } } } $316 = HEAP32 [ 8384 ] | 0 ; $317 = $316 & 8192 ; $318 = ( $317 | 0 ) != ( 0 ) ; if ( $318 ) { $319 = HEAP32 [ 8384 ] | 0 ; $320 = $319 | 4096 ; HEAP32 [ 8384 ] = $320 ; $321 = ( 33584 ) ; $322 = $321 ; $323 = HEAP32 [ $322 >> 2 ] | 0 ; $324 = ( ( $321 ) + 4 ) | 0 ; $325 = $324 ; $326 = HEAP32 [ $325 >> 2 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 33 , ( $323 | 0 ) , ( $326 | 0 ) ) ; $327 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $327 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $328 = _testSetjmp ( HEAP32 [ $327 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $328 | 0 ) == 0 ) { _longjmp ( $327 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $328 = - 1 ; } ; $329 = tempRet0 ; switch ( $328 | 0 ) { case 1 : { $$reg2mem467$0 = $329 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $329 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $329 ; label = 9 ; continue L11 ; break ; } default : { } } } $330 = HEAP32 [ 8384 ] | 0 ; $331 = $330 & 4096 ; $332 = ( $331 | 0 ) != ( 0 ) ; if ( ! ( $332 ) ) { $333 = HEAP32 [ 8449 ] | 0 ; $334 = HEAP32 [ 8509 ] | 0 ; __THREW__ = 0 ; HEAP32 [ $vararg_buffer507 >> 2 ] = $334 ; invoke_vii ( $333 | 0 , ( 18765 | 0 ) , ( $vararg_buffer507 | 0 ) ) ; $335 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $335 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $336 = _testSetjmp ( HEAP32 [ $335 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $336 | 0 ) == 0 ) { _longjmp ( $335 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $336 = - 1 ; } ; $337 = tempRet0 ; switch ( $336 | 0 ) { case 1 : { $$reg2mem467$0 = $337 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $337 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $337 ; label = 9 ; continue L11 ; break ; } default : { } } $338 = HEAP32 [ 8512 ] | 0 ; $339 = ( $338 | 0 ) != ( 0 ) ; if ( ! ( $339 ) ) { label = 215 ; break ; } } $340 = HEAP32 [ ( 33844 ) >> 2 ] | 0 ; $341 = ( $340 | 0 ) != ( 0 ) ; if ( $341 ) { $342 = HEAP32 [ 8449 ] | 0 ; __THREW__ = 0 ; invoke_vii ( $342 | 0 , ( 18792 | 0 ) , ( $vararg_buffer511 | 0 ) ) ; $343 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $343 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $344 = _testSetjmp ( HEAP32 [ $343 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $344 | 0 ) == 0 ) { _longjmp ( $343 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $344 = - 1 ; } ; $345 = tempRet0 ; switch ( $344 | 0 ) { case 1 : { $$reg2mem467$0 = $345 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $345 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $345 ; label = 9 ; continue L11 ; break ; } default : { label = 126 ; break L11 ; } } } $346 = HEAP32 [ 8512 ] | 0 ; $347 = ( $346 | 0 ) != ( 0 ) ; do { if ( $347 ) { $348 = HEAP32 [ 8449 ] | 0 ; $349 = HEAP32 [ 8511 ] | 0 ; __THREW__ = 0 ; HEAP32 [ $vararg_buffer514 >> 2 ] = $349 ; invoke_vii ( $348 | 0 , ( 18822 | 0 ) , ( $vararg_buffer514 | 0 ) ) ; $350 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $350 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $351 = _testSetjmp ( HEAP32 [ $350 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $351 | 0 ) == 0 ) { _longjmp ( $350 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $351 = - 1 ; } ; $352 = tempRet0 ; switch ( $351 | 0 ) { case 1 : { $$reg2mem467$0 = $352 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $352 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $352 ; label = 9 ; continue L11 ; break ; } default : { } } $353 = HEAP32 [ ( 33856 ) >> 2 ] | 0 ; $354 = ( $353 | 0 ) != ( 0 | 0 ) ; if ( $354 ) { $355 = HEAP32 [ ( 33856 ) >> 2 ] | 0 ; __THREW__ = 0 ; ( invoke_ii ( 34 , ( $355 | 0 ) ) | 0 ) ; $356 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $356 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $357 = _testSetjmp ( HEAP32 [ $356 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $357 | 0 ) == 0 ) { _longjmp ( $356 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $357 = - 1 ; } ; $358 = tempRet0 ; switch ( $357 | 0 ) { case 1 : { $$reg2mem467$0 = $358 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $358 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $358 ; label = 9 ; continue L11 ; break ; } default : { } } } HEAP32 [ 8514 ] = 0 ; $359 = HEAP32 [ 8511 ] | 0 ; __THREW__ = 0 ; $360 = ( invoke_iii ( 29 , ( $359 | 0 ) , ( 18568 | 0 ) ) | 0 ) ; $361 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $361 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $362 = _testSetjmp ( HEAP32 [ $361 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $362 | 0 ) == 0 ) { _longjmp ( $361 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $362 = - 1 ; } ; $363 = tempRet0 ; switch ( $362 | 0 ) { case 1 : { $$reg2mem467$0 = $363 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $363 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $363 ; label = 9 ; continue L11 ; break ; } default : { } } $364 = ( $360 | 0 ) == ( 0 ) ; if ( ! ( $364 ) ) { break ; } $365 = HEAP32 [ 8511 ] | 0 ; $366 = HEAP32 [ 8513 ] | 0 ; $367 = HEAP32 [ ( 33816 ) >> 2 ] | 0 ; __THREW__ = 0 ; $368 = ( invoke_iiii ( 35 , ( $365 | 0 ) , ( $366 | 0 ) , ( $367 | 0 ) ) | 0 ) ; $369 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $369 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $370 = _testSetjmp ( HEAP32 [ $369 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $370 | 0 ) == 0 ) { _longjmp ( $369 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $370 = - 1 ; } ; $371 = tempRet0 ; switch ( $370 | 0 ) { case 1 : { $$reg2mem467$0 = $371 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $371 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $371 ; label = 9 ; continue L11 ; break ; } default : { } } $372 = ( $368 | 0 ) != ( 0 ) ; if ( ! ( $372 ) ) { label = 142 ; break ; } HEAP32 [ ( 33792 ) >> 2 ] = 18840 ; $373 = HEAP32 [ 8446 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 20 , ( $373 | 0 ) , 1 ) ; $374 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $374 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $375 = _testSetjmp ( HEAP32 [ $374 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $375 | 0 ) == 0 ) { _longjmp ( $374 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $375 = - 1 ; } ; $376 = tempRet0 ; switch ( $375 | 0 ) { case 1 : { $$reg2mem467$0 = $376 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $376 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $376 ; label = 9 ; continue L11 ; break ; } default : { label = 137 ; break L11 ; } } } else { $377 = HEAP32 [ 8509 ] | 0 ; $378 = HEAP32 [ 8513 ] | 0 ; $379 = HEAP32 [ ( 33816 ) >> 2 ] | 0 ; __THREW__ = 0 ; $380 = ( invoke_iiii ( 35 , ( $377 | 0 ) , ( $378 | 0 ) , ( $379 | 0 ) ) | 0 ) ; $381 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $381 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $382 = _testSetjmp ( HEAP32 [ $381 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $382 | 0 ) == 0 ) { _longjmp ( $381 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $382 = - 1 ; } ; $383 = tempRet0 ; switch ( $382 | 0 ) { case 1 : { $$reg2mem467$0 = $383 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $383 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $383 ; label = 9 ; continue L11 ; break ; } default : { } } $384 = ( $380 | 0 ) != ( 0 ) ; if ( ! ( $384 ) ) { label = 142 ; break ; } HEAP32 [ ( 33792 ) >> 2 ] = 18870 ; $385 = HEAP32 [ 8446 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 20 , ( $385 | 0 ) , 1 ) ; $386 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $386 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $387 = _testSetjmp ( HEAP32 [ $386 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $387 | 0 ) == 0 ) { _longjmp ( $386 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $387 = - 1 ; } ; $388 = tempRet0 ; switch ( $387 | 0 ) { case 1 : { $$reg2mem467$0 = $388 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $388 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $388 ; label = 9 ; continue L11 ; break ; } default : { label = 141 ; break L11 ; } } } } while ( 0 ) ; if ( ( label | 0 ) == 142 ) { label = 0 ; HEAP32 [ 8514 ] = 1 ; } $389 = HEAP32 [ 8511 ] | 0 ; __THREW__ = 0 ; $390 = ( invoke_iii ( 19 , ( $389 | 0 ) , ( 18899 | 0 ) ) | 0 ) ; $391 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $391 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $392 = _testSetjmp ( HEAP32 [ $391 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $392 | 0 ) == 0 ) { _longjmp ( $391 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $392 = - 1 ; } ; $393 = tempRet0 ; switch ( $392 | 0 ) { case 1 : { $$reg2mem467$0 = $393 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $393 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $393 ; label = 9 ; continue L11 ; break ; } default : { } } HEAP32 [ 8515 ] = $390 ; $394 = HEAP32 [ 8446 ] | 0 ; $6 = $394 ; HEAP32 [ 8446 ] = $7 ; _setjmpTable = _saveSetjmp ( $7 , 2 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; _setjmpTableSize = tempRet0 ; __THREW__ = 0 ; $395 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $395 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $396 = _testSetjmp ( HEAP32 [ $395 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $396 | 0 ) == 0 ) { _longjmp ( $395 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $396 = - 1 ; } ; $397 = tempRet0 ; switch ( $396 | 0 ) { case 1 : { $$reg2mem467$0 = $397 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $397 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $397 ; label = 9 ; continue L11 ; break ; } default : { } } $$reg2mem469$0 = 0 ; label = 146 ; continue ; } else if ( ( label | 0 ) == 146 ) { label = 0 ; $398 = ( $$reg2mem469$0 | 0 ) == ( 0 ) ; if ( $398 ) { label = 147 ; } else { HEAP32 [ ( 33788 ) >> 2 ] = 1 ; label = 178 ; } } else if ( ( label | 0 ) == 159 ) { label = 0 ; $433 = ( $$reg2mem467$0 | 0 ) == ( 0 ) ; L14 : do { if ( $433 ) { while ( 1 ) { $434 = ( 33544 ) ; $435 = $434 ; $436 = HEAP32 [ $435 >> 2 ] | 0 ; $437 = ( ( $434 ) + 4 ) | 0 ; $438 = $437 ; $439 = HEAP32 [ $438 >> 2 ] | 0 ; $440 = ( $439 | 0 ) > ( 0 ) ; $441 = ( $436 >>> 0 ) > ( 0 ) ; $442 = ( $439 | 0 ) == ( 0 ) ; $443 = $442 & $441 ; $444 = $440 | $443 ; if ( $444 ) { $445 = HEAP32 [ 8510 ] | 0 ; $446 = ( 33544 ) ; $447 = $446 ; $448 = HEAP32 [ $447 >> 2 ] | 0 ; $449 = ( ( $446 ) + 4 ) | 0 ; $450 = $449 ; $451 = HEAP32 [ $450 >> 2 ] | 0 ; __THREW__ = 0 ; $452 = ( invoke_iiiii ( 37 , ( $445 | 0 ) , ( $448 | 0 ) , ( $451 | 0 ) , 0 ) | 0 ) ; $453 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $453 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $454 = _testSetjmp ( HEAP32 [ $453 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $454 | 0 ) == 0 ) { _longjmp ( $453 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $454 = - 1 ; } ; $455 = tempRet0 ; switch ( $454 | 0 ) { case 1 : { $$reg2mem467$0 = $455 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $455 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $455 ; label = 9 ; continue L11 ; break ; } default : { } } $456 = ( $452 | 0 ) != ( 0 ) ; if ( $456 ) { break ; } } $461 = ( 33568 ) ; $462 = $461 ; $463 = HEAP32 [ $462 >> 2 ] | 0 ; $464 = ( ( $461 ) + 4 ) | 0 ; $465 = $464 ; $466 = HEAP32 [ $465 >> 2 ] | 0 ; $467 = ( 33584 ) ; $468 = $467 ; HEAP32 [ $468 >> 2 ] = $463 ; $469 = ( ( $467 ) + 4 ) | 0 ; $470 = $469 ; HEAP32 [ $470 >> 2 ] = $466 ; $471 = HEAP32 [ 8510 ] | 0 ; $472 = HEAP32 [ 8515 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 38 , ( $471 | 0 ) , ( $472 | 0 ) ) ; $473 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $473 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $474 = _testSetjmp ( HEAP32 [ $473 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $474 | 0 ) == 0 ) { _longjmp ( $473 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $474 = - 1 ; } ; $475 = tempRet0 ; switch ( $474 | 0 ) { case 1 : { $$reg2mem467$0 = $475 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $475 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $475 ; label = 9 ; continue L11 ; break ; } default : { } } HEAP32 [ ( 33788 ) >> 2 ] = 0 ; $476 = HEAP32 [ ( 33788 ) >> 2 ] | 0 ; $477 = ( $476 | 0 ) != ( 0 ) ; if ( ! ( $477 ) ) { break L14 ; } } HEAP32 [ ( 33792 ) >> 2 ] = 18957 ; $457 = HEAP32 [ 8446 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 20 , ( $457 | 0 ) , 1 ) ; $458 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $458 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $459 = _testSetjmp ( HEAP32 [ $458 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $459 | 0 ) == 0 ) { _longjmp ( $458 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $459 = - 1 ; } ; $460 = tempRet0 ; switch ( $459 | 0 ) { case 1 : { $$reg2mem467$0 = $460 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $460 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $460 ; label = 9 ; continue L11 ; break ; } default : { label = 164 ; break L11 ; } } } else { HEAP32 [ ( 33788 ) >> 2 ] = 1 ; } } while ( 0 ) ; $478 = $8 ; HEAP32 [ 8446 ] = $478 ; $479 = HEAP32 [ ( 33788 ) >> 2 ] | 0 ; $480 = ( $479 | 0 ) != ( 0 ) ; if ( $480 ) { $481 = HEAP32 [ ( 33792 ) >> 2 ] | 0 ; $3 = $481 ; $482 = $3 ; $483 = ( $482 | 0 ) != ( 0 | 0 ) ; if ( ! ( $483 ) ) { $484 = HEAP32 [ 8452 ] | 0 ; __THREW__ = 0 ; invoke_vi ( $484 | 0 , ( 18989 | 0 ) ) ; $485 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $485 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $486 = _testSetjmp ( HEAP32 [ $485 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $486 | 0 ) == 0 ) { _longjmp ( $485 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $486 = - 1 ; } ; $487 = tempRet0 ; switch ( $486 | 0 ) { case 1 : { $$reg2mem467$0 = $487 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $487 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $487 ; label = 9 ; continue L11 ; break ; } default : { } } } } $488 = HEAP32 [ 8510 ] | 0 ; __THREW__ = 0 ; ( invoke_ii ( 22 , ( $488 | 0 ) ) | 0 ) ; $489 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $489 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $490 = _testSetjmp ( HEAP32 [ $489 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $490 | 0 ) == 0 ) { _longjmp ( $489 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $490 = - 1 ; } ; $491 = tempRet0 ; switch ( $490 | 0 ) { case 1 : { $$reg2mem467$0 = $491 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $491 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $491 ; label = 9 ; continue L11 ; break ; } default : { } } $492 = $3 ; $493 = ( $492 | 0 ) != ( 0 | 0 ) ; if ( $493 ) { $494 = $3 ; HEAP32 [ ( 33792 ) >> 2 ] = $494 ; $495 = HEAP32 [ 8446 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 20 , ( $495 | 0 ) , 1 ) ; $496 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $496 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $497 = _testSetjmp ( HEAP32 [ $496 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $497 | 0 ) == 0 ) { _longjmp ( $496 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $497 = - 1 ; } ; $498 = tempRet0 ; switch ( $497 | 0 ) { case 1 : { $$reg2mem467$0 = $498 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $498 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $498 ; label = 9 ; continue L11 ; break ; } default : { label = 175 ; break L11 ; } } } else { label = 176 ; } } while ( 1 ) { if ( ( label | 0 ) == 147 ) { label = 0 ; $399 = HEAP32 [ 8515 ] | 0 ; $400 = ( $399 | 0 ) == ( 0 | 0 ) ; if ( $400 ) { label = 148 ; break ; } $405 = HEAP32 [ 8384 ] | 0 ; $406 = $405 & 8192 ; $407 = ( $406 | 0 ) != ( 0 ) ; if ( ! ( $407 ) ) { label = 153 ; break ; } $408 = HEAP32 [ 8515 ] | 0 ; $409 = HEAP32 [ ( 33628 ) >> 2 ] | 0 ; $410 = HEAP32 [ ( 33632 ) >> 2 ] | 0 ; $411 = HEAP32 [ ( 33636 ) >> 2 ] | 0 ; $412 = HEAP32 [ ( 33640 ) >> 2 ] | 0 ; __THREW__ = 0 ; invoke_viiiii ( 36 , ( $408 | 0 ) , ( $409 | 0 ) , ( $410 | 0 ) , ( $411 | 0 ) , ( $412 | 0 ) ) ; $413 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $413 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $414 = _testSetjmp ( HEAP32 [ $413 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $414 | 0 ) == 0 ) { _longjmp ( $413 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $414 = - 1 ; } ; $415 = tempRet0 ; switch ( $414 | 0 ) { case 1 : { $$reg2mem467$0 = $415 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $415 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $415 ; label = 9 ; continue L11 ; break ; } default : { } } label = 176 ; continue ; } else if ( ( label | 0 ) == 176 ) { label = 0 ; HEAP32 [ ( 33788 ) >> 2 ] = 0 ; $499 = HEAP32 [ ( 33788 ) >> 2 ] | 0 ; $500 = ( $499 | 0 ) != ( 0 ) ; if ( $500 ) { label = 147 ; continue ; } else { label = 178 ; continue ; } } else if ( ( label | 0 ) == 178 ) { label = 0 ; $501 = $6 ; HEAP32 [ 8446 ] = $501 ; $502 = HEAP32 [ ( 33788 ) >> 2 ] | 0 ; $503 = ( $502 | 0 ) != ( 0 ) ; if ( $503 ) { label = 179 ; break ; } else { label = 196 ; break ; } } } if ( ( label | 0 ) == 148 ) { label = 0 ; HEAP32 [ ( 33792 ) >> 2 ] = 18902 ; $401 = HEAP32 [ 8446 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 20 , ( $401 | 0 ) , 1 ) ; $402 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $402 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $403 = _testSetjmp ( HEAP32 [ $402 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $403 | 0 ) == 0 ) { _longjmp ( $402 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $403 = - 1 ; } ; $404 = tempRet0 ; switch ( $403 | 0 ) { case 1 : { $$reg2mem467$0 = $404 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $404 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $404 ; label = 9 ; continue L11 ; break ; } default : { label = 149 ; break L11 ; } } } else if ( ( label | 0 ) == 153 ) { label = 0 ; $416 = HEAP32 [ 8512 ] | 0 ; $417 = ( $416 | 0 ) != ( 0 ) ; $opng_optimize_impl$bakfile_name$sink = $417 ? 34036 : 34052 ; $418 = HEAP32 [ $opng_optimize_impl$bakfile_name$sink >> 2 ] | 0 ; __THREW__ = 0 ; $419 = ( invoke_iii ( 19 , ( $418 | 0 ) , ( 17987 | 0 ) ) | 0 ) ; $420 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $420 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $421 = _testSetjmp ( HEAP32 [ $420 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $421 | 0 ) == 0 ) { _longjmp ( $420 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $421 = - 1 ; } ; $422 = tempRet0 ; switch ( $421 | 0 ) { case 1 : { $$reg2mem467$0 = $422 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $422 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $422 ; label = 9 ; continue L11 ; break ; } default : { } } HEAP32 [ 8510 ] = $419 ; $423 = HEAP32 [ 8510 ] | 0 ; $424 = ( $423 | 0 ) == ( 0 | 0 ) ; if ( $424 ) { HEAP32 [ ( 33792 ) >> 2 ] = 18929 ; $425 = HEAP32 [ 8446 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 20 , ( $425 | 0 ) , 1 ) ; $426 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $426 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $427 = _testSetjmp ( HEAP32 [ $426 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $427 | 0 ) == 0 ) { _longjmp ( $426 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $427 = - 1 ; } ; $428 = tempRet0 ; switch ( $427 | 0 ) { case 1 : { $$reg2mem467$0 = $428 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $428 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $428 ; label = 9 ; continue L11 ; break ; } default : { label = 156 ; break L11 ; } } } $429 = HEAP32 [ 8446 ] | 0 ; $8 = $429 ; HEAP32 [ 8446 ] = $9 ; _setjmpTable = _saveSetjmp ( $9 , 1 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; _setjmpTableSize = tempRet0 ; __THREW__ = 0 ; $430 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $430 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $431 = _testSetjmp ( HEAP32 [ $430 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $431 | 0 ) == 0 ) { _longjmp ( $430 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $431 = - 1 ; } ; $432 = tempRet0 ; switch ( $431 | 0 ) { case 1 : { $$reg2mem467$0 = $432 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $432 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $432 ; label = 9 ; continue L11 ; break ; } default : { } } $$reg2mem467$0 = 0 ; label = 159 ; continue ; } else if ( ( label | 0 ) == 179 ) { label = 0 ; $504 = HEAP32 [ ( 33792 ) >> 2 ] | 0 ; $3 = $504 ; $505 = HEAP32 [ 8515 ] | 0 ; $506 = ( $505 | 0 ) != ( 0 | 0 ) ; if ( $506 ) { $507 = HEAP32 [ 8515 ] | 0 ; __THREW__ = 0 ; ( invoke_ii ( 22 , ( $507 | 0 ) ) | 0 ) ; $508 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $508 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $509 = _testSetjmp ( HEAP32 [ $508 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $509 | 0 ) == 0 ) { _longjmp ( $508 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $509 = - 1 ; } ; $510 = tempRet0 ; switch ( $509 | 0 ) { case 1 : { $$reg2mem467$0 = $510 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $510 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $510 ; label = 9 ; continue L11 ; break ; } default : { } } } $511 = HEAP32 [ 8514 ] | 0 ; $512 = ( $511 | 0 ) != ( 0 ) ; if ( $512 ) { $513 = HEAP32 [ 8513 ] | 0 ; $514 = HEAP32 [ 8512 ] | 0 ; $515 = ( $514 | 0 ) != ( 0 ) ; $opng_optimize_impl$infile_name_local$sink = $515 ? 34044 : 34036 ; $516 = HEAP32 [ $opng_optimize_impl$infile_name_local$sink >> 2 ] | 0 ; __THREW__ = 0 ; $517 = ( invoke_iiii ( 35 , ( $513 | 0 ) , ( $516 | 0 ) , 1 ) | 0 ) ; $518 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $518 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $519 = _testSetjmp ( HEAP32 [ $518 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $519 | 0 ) == 0 ) { _longjmp ( $518 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $519 = - 1 ; } ; $520 = tempRet0 ; switch ( $519 | 0 ) { case 1 : { $$reg2mem467$0 = $520 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $520 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $520 ; label = 9 ; continue L11 ; break ; } default : { } } $521 = ( $517 | 0 ) != ( 0 ) ; if ( $521 ) { __THREW__ = 0 ; invoke_vi ( 39 , ( 19024 | 0 ) ) ; $522 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $522 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $523 = _testSetjmp ( HEAP32 [ $522 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $523 | 0 ) == 0 ) { _longjmp ( $522 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $523 = - 1 ; } ; $524 = tempRet0 ; switch ( $523 | 0 ) { case 1 : { $$reg2mem467$0 = $524 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $524 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $524 ; label = 9 ; continue L11 ; break ; } default : { } } } } else { $525 = HEAP32 [ 8512 ] | 0 ; $526 = ( $525 | 0 ) != ( 0 ) ; if ( ! ( $526 ) ) { $527 = HEAP32 [ 8452 ] | 0 ; __THREW__ = 0 ; invoke_vi ( $527 | 0 , ( 19068 | 0 ) ) ; $528 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $528 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $529 = _testSetjmp ( HEAP32 [ $528 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $529 | 0 ) == 0 ) { _longjmp ( $528 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $529 = - 1 ; } ; $530 = tempRet0 ; switch ( $529 | 0 ) { case 1 : { $$reg2mem467$0 = $530 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $530 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $530 ; label = 9 ; continue L11 ; break ; } default : { } } } $531 = HEAP32 [ 8511 ] | 0 ; __THREW__ = 0 ; $532 = ( invoke_ii ( 40 , ( $531 | 0 ) ) | 0 ) ; $533 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $533 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $534 = _testSetjmp ( HEAP32 [ $533 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $534 | 0 ) == 0 ) { _longjmp ( $533 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $534 = - 1 ; } ; $535 = tempRet0 ; switch ( $534 | 0 ) { case 1 : { $$reg2mem467$0 = $535 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $535 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $535 ; label = 9 ; continue L11 ; break ; } default : { } } $536 = ( $532 | 0 ) != ( 0 ) ; if ( $536 ) { __THREW__ = 0 ; invoke_vi ( 39 , ( 19109 | 0 ) ) ; $537 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $537 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $538 = _testSetjmp ( HEAP32 [ $537 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $538 | 0 ) == 0 ) { _longjmp ( $537 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $538 = - 1 ; } ; $539 = tempRet0 ; switch ( $538 | 0 ) { case 1 : { $$reg2mem467$0 = $539 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $539 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $539 ; label = 9 ; continue L11 ; break ; } default : { } } } } $540 = $3 ; HEAP32 [ ( 33792 ) >> 2 ] = $540 ; $541 = HEAP32 [ 8446 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 20 , ( $541 | 0 ) , 1 ) ; $542 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $542 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $543 = _testSetjmp ( HEAP32 [ $542 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $543 | 0 ) == 0 ) { _longjmp ( $542 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $543 = - 1 ; } ; $544 = tempRet0 ; switch ( $543 | 0 ) { case 1 : { $$reg2mem467$0 = $544 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $544 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $544 ; label = 9 ; continue L11 ; break ; } default : { label = 195 ; break L11 ; } } } else if ( ( label | 0 ) == 196 ) { label = 0 ; $545 = HEAP32 [ 8515 ] | 0 ; __THREW__ = 0 ; ( invoke_ii ( 22 , ( $545 | 0 ) ) | 0 ) ; $546 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $546 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $547 = _testSetjmp ( HEAP32 [ $546 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $547 | 0 ) == 0 ) { _longjmp ( $546 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $547 = - 1 ; } ; $548 = tempRet0 ; switch ( $547 | 0 ) { case 1 : { $$reg2mem467$0 = $548 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $548 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $548 ; label = 9 ; continue L11 ; break ; } default : { } } $549 = HEAP32 [ ( 33836 ) >> 2 ] | 0 ; $550 = ( $549 | 0 ) != ( 0 ) ; if ( $550 ) { $551 = HEAP32 [ 8512 ] | 0 ; $552 = ( $551 | 0 ) != ( 0 ) ; $opng_optimize_impl$bakfile_name$sink7 = $552 ? 34036 : 34052 ; $553 = HEAP32 [ $opng_optimize_impl$bakfile_name$sink7 >> 2 ] | 0 ; $554 = HEAP32 [ 8511 ] | 0 ; __THREW__ = 0 ; ( invoke_iii ( 41 , ( $553 | 0 ) , ( $554 | 0 ) ) | 0 ) ; $555 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $555 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $556 = _testSetjmp ( HEAP32 [ $555 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $556 | 0 ) == 0 ) { _longjmp ( $555 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $556 = - 1 ; } ; $557 = tempRet0 ; switch ( $556 | 0 ) { case 1 : { $$reg2mem467$0 = $557 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $557 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $557 ; label = 9 ; continue L11 ; break ; } default : { } } } $558 = HEAP32 [ 8512 ] | 0 ; $559 = ( $558 | 0 ) != ( 0 ) ; $560 = HEAP32 [ 8453 ] | 0 ; $561 = ( $560 | 0 ) != ( 0 ) ; $or$cond9 = $559 | $561 ; if ( ! ( $or$cond9 ) ) { $562 = HEAP32 [ 8513 ] | 0 ; __THREW__ = 0 ; $563 = ( invoke_ii ( 40 , ( $562 | 0 ) ) | 0 ) ; $564 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $564 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $565 = _testSetjmp ( HEAP32 [ $564 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $565 | 0 ) == 0 ) { _longjmp ( $564 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $565 = - 1 ; } ; $566 = tempRet0 ; switch ( $565 | 0 ) { case 1 : { $$reg2mem467$0 = $566 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $566 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $566 ; label = 9 ; continue L11 ; break ; } default : { } } $567 = ( $563 | 0 ) != ( 0 ) ; if ( $567 ) { __THREW__ = 0 ; invoke_vi ( 39 , ( 19145 | 0 ) ) ; $568 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $568 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $569 = _testSetjmp ( HEAP32 [ $568 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $569 | 0 ) == 0 ) { _longjmp ( $568 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $569 = - 1 ; } ; $570 = tempRet0 ; switch ( $569 | 0 ) { case 1 : { $$reg2mem467$0 = $570 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $570 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $570 ; label = 9 ; continue L11 ; break ; } default : { } } } } $571 = HEAP32 [ 8449 ] | 0 ; $572 = ( 33576 ) ; $573 = $572 ; $574 = HEAP32 [ $573 >> 2 ] | 0 ; $575 = ( ( $572 ) + 4 ) | 0 ; $576 = $575 ; $577 = HEAP32 [ $576 >> 2 ] | 0 ; __THREW__ = 0 ; $578 = $vararg_buffer518 ; $579 = $578 ; HEAP32 [ $579 >> 2 ] = $574 ; $580 = ( ( $578 ) + 4 ) | 0 ; $581 = $580 ; HEAP32 [ $581 >> 2 ] = $577 ; invoke_vii ( $571 | 0 , ( 19174 | 0 ) , ( $vararg_buffer518 | 0 ) ) ; $582 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $582 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $583 = _testSetjmp ( HEAP32 [ $582 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $583 | 0 ) == 0 ) { _longjmp ( $582 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $583 = - 1 ; } ; $584 = tempRet0 ; switch ( $583 | 0 ) { case 1 : { $$reg2mem467$0 = $584 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $584 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $584 ; label = 9 ; continue L11 ; break ; } default : { } } $585 = HEAP32 [ 8384 ] | 0 ; $586 = $585 & 2 ; $587 = ( $586 | 0 ) != ( 0 ) ; if ( $587 ) { $588 = HEAP32 [ 8449 ] | 0 ; __THREW__ = 0 ; invoke_vii ( $588 | 0 , ( 19205 | 0 ) , ( $vararg_buffer522 | 0 ) ) ; $589 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $589 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $590 = _testSetjmp ( HEAP32 [ $589 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $590 | 0 ) == 0 ) { _longjmp ( $589 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $590 = - 1 ; } ; $591 = tempRet0 ; switch ( $590 | 0 ) { case 1 : { $$reg2mem467$0 = $591 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $591 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $591 ; label = 9 ; continue L11 ; break ; } default : { } } $592 = ( 33568 ) ; $593 = $592 ; $594 = HEAP32 [ $593 >> 2 ] | 0 ; $595 = ( ( $592 ) + 4 ) | 0 ; $596 = $595 ; $597 = HEAP32 [ $596 >> 2 ] | 0 ; $598 = ( 33576 ) ; $599 = $598 ; $600 = HEAP32 [ $599 >> 2 ] | 0 ; $601 = ( ( $598 ) + 4 ) | 0 ; $602 = $601 ; $603 = HEAP32 [ $602 >> 2 ] | 0 ; __THREW__ = 0 ; invoke_viiiii ( 42 , ( $594 | 0 ) , ( $597 | 0 ) , ( $600 | 0 ) , ( $603 | 0 ) , 0 ) ; $604 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $604 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $605 = _testSetjmp ( HEAP32 [ $604 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $605 | 0 ) == 0 ) { _longjmp ( $604 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $605 = - 1 ; } ; $606 = tempRet0 ; switch ( $605 | 0 ) { case 1 : { $$reg2mem467$0 = $606 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $606 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $606 ; label = 9 ; continue L11 ; break ; } default : { } } $607 = HEAP32 [ 8449 ] | 0 ; __THREW__ = 0 ; invoke_vii ( $607 | 0 , ( 19208 | 0 ) , ( $vararg_buffer525 | 0 ) ) ; $608 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $608 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $609 = _testSetjmp ( HEAP32 [ $608 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $609 | 0 ) == 0 ) { _longjmp ( $608 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $609 = - 1 ; } ; $610 = tempRet0 ; switch ( $609 | 0 ) { case 1 : { $$reg2mem467$0 = $610 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $610 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $610 ; label = 9 ; continue L11 ; break ; } default : { } } } $611 = HEAP32 [ 8449 ] | 0 ; $612 = ( 33560 ) ; $613 = $612 ; $614 = HEAP32 [ $613 >> 2 ] | 0 ; $615 = ( ( $612 ) + 4 ) | 0 ; $616 = $615 ; $617 = HEAP32 [ $616 >> 2 ] | 0 ; __THREW__ = 0 ; $618 = $vararg_buffer528 ; $619 = $618 ; HEAP32 [ $619 >> 2 ] = $614 ; $620 = ( ( $618 ) + 4 ) | 0 ; $621 = $620 ; HEAP32 [ $621 >> 2 ] = $617 ; invoke_vii ( $611 | 0 , ( 19210 | 0 ) , ( $vararg_buffer528 | 0 ) ) ; $622 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $622 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $623 = _testSetjmp ( HEAP32 [ $622 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $623 | 0 ) == 0 ) { _longjmp ( $622 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $623 = - 1 ; } ; $624 = tempRet0 ; switch ( $623 | 0 ) { case 1 : { $$reg2mem467$0 = $624 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $624 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $624 ; label = 9 ; continue L11 ; break ; } default : { } } $625 = ( 33552 ) ; $626 = $625 ; $627 = HEAP32 [ $626 >> 2 ] | 0 ; $628 = ( ( $625 ) + 4 ) | 0 ; $629 = $628 ; $630 = HEAP32 [ $629 >> 2 ] | 0 ; $631 = ( 33560 ) ; $632 = $631 ; $633 = HEAP32 [ $632 >> 2 ] | 0 ; $634 = ( ( $631 ) + 4 ) | 0 ; $635 = $634 ; $636 = HEAP32 [ $635 >> 2 ] | 0 ; __THREW__ = 0 ; invoke_viiiii ( 42 , ( $627 | 0 ) , ( $630 | 0 ) , ( $633 | 0 ) , ( $636 | 0 ) , 1 ) ; $637 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $637 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $638 = _testSetjmp ( HEAP32 [ $637 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $638 | 0 ) == 0 ) { _longjmp ( $637 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $638 = - 1 ; } ; $639 = tempRet0 ; switch ( $638 | 0 ) { case 1 : { $$reg2mem467$0 = $639 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $639 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $639 ; label = 9 ; continue L11 ; break ; } default : { } } $640 = HEAP32 [ 8449 ] | 0 ; __THREW__ = 0 ; invoke_vii ( $640 | 0 , ( 19243 | 0 ) , ( $vararg_buffer532 | 0 ) ) ; $641 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $641 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $642 = _testSetjmp ( HEAP32 [ $641 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $642 | 0 ) == 0 ) { _longjmp ( $641 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $642 = - 1 ; } ; $643 = tempRet0 ; switch ( $642 | 0 ) { case 1 : { $$reg2mem467$0 = $643 ; label = 159 ; continue L11 ; break ; } case 2 : { $$reg2mem469$0 = $643 ; label = 146 ; continue L11 ; break ; } case 3 : { $$reg2mem471$0 = $643 ; label = 9 ; continue L11 ; break ; } default : { label = 214 ; break L11 ; } } } } switch ( label | 0 ) { case 20 : { // unreachable; break ; } case 28 : { // unreachable; break ; } case 38 : { // unreachable; break ; } case 47 : { // unreachable; break ; } case 52 : { // unreachable; break ; } case 62 : { // unreachable; break ; } case 74 : { // unreachable; break ; } case 93 : { // unreachable; break ; } case 100 : { // unreachable; break ; } case 107 : { // unreachable; break ; } case 126 : { _free ( _setjmpTable | 0 ) ; STACKTOP = sp ; return ; break ; } case 137 : { // unreachable; break ; } case 141 : { // unreachable; break ; } case 149 : { // unreachable; break ; } case 156 : { // unreachable; break ; } case 164 : { // unreachable; break ; } case 175 : { // unreachable; break ; } case 195 : { // unreachable; break ; } case 214 : { _free ( _setjmpTable | 0 ) ; STACKTOP = sp ; return ; break ; } case 215 : { _free ( _setjmpTable | 0 ) ; STACKTOP = sp ; return ; break ; } } } function _opng_print_error ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $vararg_buffer = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $vararg_buffer = sp ; $1 = $0 ; $2 = HEAP32 [ 8450 ] | 0 ; FUNCTION_TABLE_vi [ $2 & 127 ] ( 11 ) ; $3 = HEAP32 [ 8449 ] | 0 ; $4 = $1 ; HEAP32 [ $vararg_buffer >> 2 ] = $4 ; FUNCTION_TABLE_vii [ $3 & 127 ] ( 17976 , $vararg_buffer ) ; STACKTOP = sp ; return ; } function _opng_destroy_image_info ( ) { var $0 = 0 , $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $3 = 0 ; var $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , dest = 0 , label = 0 , sp = 0 , stop = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = HEAP32 [ ( 33960 ) >> 2 ] | 0 ; $3 = ( $2 | 0 ) == ( 0 | 0 ) ; if ( $3 ) { STACKTOP = sp ; return ; } $0 = 0 ; while ( 1 ) { $4 = $0 ; $5 = HEAP32 [ ( 33936 ) >> 2 ] | 0 ; $6 = ( $4 >>> 0 ) < ( $5 >>> 0 ) ; $7 = HEAP32 [ ( 33960 ) >> 2 ] | 0 ; if ( ! ( $6 ) ) { break ; } $8 = $0 ; $9 = ( ( $7 ) + ( $8 << 2 ) | 0 ) ; $10 = HEAP32 [ $9 >> 2 ] | 0 ; _opng_free ( $10 ) ; $11 = $0 ; $12 = ( ( $11 ) + 1 ) | 0 ; $0 = $12 ; } _opng_free ( $7 ) ; $13 = HEAP32 [ ( 33964 ) >> 2 ] | 0 ; _opng_free ( $13 ) ; $14 = HEAP32 [ ( 34004 ) >> 2 ] | 0 ; _opng_free ( $14 ) ; $15 = HEAP32 [ ( 33988 ) >> 2 ] | 0 ; _opng_free ( $15 ) ; $1 = 0 ; while ( 1 ) { $16 = $1 ; $17 = HEAP32 [ ( 34032 ) >> 2 ] | 0 ; $18 = ( $16 | 0 ) < ( $17 | 0 ) ; $19 = HEAP32 [ ( 34028 ) >> 2 ] | 0 ; if ( ! ( $18 ) ) { break ; } $20 = $1 ; $21 = ( ( $19 ) + ( ( $20 * 20 ) | 0 ) | 0 ) ; $22 = ( ( ( $21 ) ) + 8 | 0 ) ; $23 = HEAP32 [ $22 >> 2 ] | 0 ; _opng_free ( $23 ) ; $24 = $1 ; $25 = ( ( $24 ) + 1 ) | 0 ; $1 = $25 ; } _opng_free ( $19 ) ; dest = 33932 ; stop = dest + 104 | 0 ; do { HEAP32 [ dest >> 2 ] = 0 | 0 ; dest = dest + 4 | 0 ; } while ( ( dest | 0 ) < ( stop | 0 ) ) ; STACKTOP = sp ; return ; } function _opng_free ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $2 = $1 ; _free ( $2 ) ; STACKTOP = sp ; return ; } function _opng_read_file ( $0 ) { $0 = $0 | 0 ; var $$0 = 0 , $$1 = 0 , $$2 = 0 , $$3 = 0 , $$4 = 0 , $$5 = 0 , $$reg2mem148$0 = 0 , $$reg2mem150$0 = 0 , $1 = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 ; var $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 ; var $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 ; var $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 ; var $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 , $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 ; var $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 , $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $2 = 0 ; var $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 , $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 ; var $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 , $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 ; var $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 , $244 = 0 , $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 ; var $254 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 ; var $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 ; var $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 ; var $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 ; var $98 = 0 , $99 = 0 , $or$cond = 0 , $or$cond$not = 0 , $or$cond3 = 0 , $vararg_buffer = 0 , $vararg_buffer152 = 0 , $vararg_buffer155 = 0 , $vararg_buffer158 = 0 , $vararg_buffer161 = 0 , $vararg_buffer164 = 0 , $vararg_buffer167 = 0 , $vararg_buffer170 = 0 , _setjmpTable = 0 , _setjmpTableSize = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 400 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 400 | 0 ) ; $vararg_buffer170 = sp + 56 | 0 ; $vararg_buffer167 = sp + 48 | 0 ; $vararg_buffer164 = sp + 40 | 0 ; $vararg_buffer161 = sp + 32 | 0 ; $vararg_buffer158 = sp + 24 | 0 ; $vararg_buffer155 = sp + 16 | 0 ; $vararg_buffer152 = sp + 8 | 0 ; $vararg_buffer = sp ; _setjmpTableSize = 4 ; _setjmpTable = _malloc ( 40 ) | 0 ; HEAP32 [ _setjmpTable >> 2 ] = 0 ; $1 = sp + 384 | 0 ; $4 = sp + 220 | 0 ; $6 = sp + 60 | 0 ; $7 = HEAP32 [ 8446 ] | 0 ; $3 = $7 ; HEAP32 [ 8446 ] = $4 ; _setjmpTable = _saveSetjmp ( $4 , 2 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; _setjmpTableSize = tempRet0 ; __THREW__ = 0 ; $8 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $8 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $9 = _testSetjmp ( HEAP32 [ $8 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $9 | 0 ) == 0 ) { _longjmp ( $8 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $9 = - 1 ; } ; $10 = tempRet0 ; switch ( $9 | 0 ) { case 1 : { $$reg2mem148$0 = $10 ; break ; } case 2 : { $$reg2mem150$0 = $10 ; label = 3 ; break ; } default : { $$reg2mem150$0 = 0 ; label = 3 ; } } L3 : while ( 1 ) { if ( ( label | 0 ) == 3 ) { label = 0 ; $11 = ( $$reg2mem150$0 | 0 ) == ( 0 ) ; L6 : do { if ( $11 ) { while ( 1 ) { __THREW__ = 0 ; $12 = ( invoke_iiiii ( 43 , ( 23589 | 0 ) , ( 0 | 0 ) , ( 44 | 0 ) , ( 45 | 0 ) ) | 0 ) ; $13 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $13 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $14 = _testSetjmp ( HEAP32 [ $13 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $14 | 0 ) == 0 ) { _longjmp ( $13 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $14 = - 1 ; } ; $15 = tempRet0 ; switch ( $14 | 0 ) { case 2 : { $$reg2mem150$0 = $15 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $15 ; continue L3 ; break ; } default : { } } HEAP32 [ 8520 ] = $12 ; $16 = HEAP32 [ 8520 ] | 0 ; __THREW__ = 0 ; $17 = ( invoke_ii ( 46 , ( $16 | 0 ) ) | 0 ) ; $18 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $18 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $19 = _testSetjmp ( HEAP32 [ $18 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $19 | 0 ) == 0 ) { _longjmp ( $18 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $19 = - 1 ; } ; $20 = tempRet0 ; switch ( $19 | 0 ) { case 2 : { $$reg2mem150$0 = $20 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $20 ; continue L3 ; break ; } default : { } } HEAP32 [ 8522 ] = $17 ; $21 = HEAP32 [ 8522 ] | 0 ; $22 = ( $21 | 0 ) == ( 0 | 0 ) ; if ( $22 ) { label = 7 ; break ; } $27 = HEAP32 [ 8520 ] | 0 ; __THREW__ = 0 ; invoke_viiii ( 47 , ( $27 | 0 ) , 3 , ( 0 | 0 ) , 0 ) ; $28 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $28 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $29 = _testSetjmp ( HEAP32 [ $28 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $29 | 0 ) == 0 ) { _longjmp ( $28 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $29 = - 1 ; } ; $30 = tempRet0 ; switch ( $29 | 0 ) { case 2 : { $$reg2mem150$0 = $30 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $30 ; continue L3 ; break ; } default : { } } $31 = HEAP32 [ 8520 ] | 0 ; __THREW__ = 0 ; invoke_viii ( 48 , ( $31 | 0 ) , 2147483647 , 2147483647 ) ; $32 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $32 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $33 = _testSetjmp ( HEAP32 [ $32 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $33 | 0 ) == 0 ) { _longjmp ( $32 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $33 = - 1 ; } ; $34 = tempRet0 ; switch ( $33 | 0 ) { case 2 : { $$reg2mem150$0 = $34 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $34 ; continue L3 ; break ; } default : { } } __THREW__ = 0 ; invoke_v ( 49 ) ; $35 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $35 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $36 = _testSetjmp ( HEAP32 [ $35 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $36 | 0 ) == 0 ) { _longjmp ( $35 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $36 = - 1 ; } ; $37 = tempRet0 ; switch ( $36 | 0 ) { case 2 : { $$reg2mem150$0 = $37 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $37 ; continue L3 ; break ; } default : { } } $38 = HEAP32 [ 8520 ] | 0 ; __THREW__ = 0 ; invoke_viii ( 50 , ( $38 | 0 ) , ( $0 | 0 ) , ( 51 | 0 ) ) ; $39 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $39 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $40 = _testSetjmp ( HEAP32 [ $39 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $40 | 0 ) == 0 ) { _longjmp ( $39 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $40 = - 1 ; } ; $41 = tempRet0 ; switch ( $40 | 0 ) { case 2 : { $$reg2mem150$0 = $41 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $41 ; continue L3 ; break ; } default : { } } HEAP32 [ $1 >> 2 ] = 0 ; $42 = HEAP32 [ 8520 ] | 0 ; $43 = HEAP32 [ 8522 ] | 0 ; __THREW__ = 0 ; $44 = ( invoke_iiiii ( 52 , ( $42 | 0 ) , ( $43 | 0 ) , ( $1 | 0 ) , ( 0 | 0 ) ) | 0 ) ; $45 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $45 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $46 = _testSetjmp ( HEAP32 [ $45 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $46 | 0 ) == 0 ) { _longjmp ( $45 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $46 = - 1 ; } ; $47 = tempRet0 ; switch ( $46 | 0 ) { case 2 : { $$reg2mem150$0 = $47 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $47 ; continue L3 ; break ; } default : { } } $48 = ( $44 | 0 ) <= ( 0 ) ; if ( $48 ) { label = 15 ; break ; } $53 = ( $44 | 0 ) > ( 1 ) ; if ( $53 ) { $54 = HEAP32 [ 8384 ] | 0 ; $55 = $54 | 16 ; HEAP32 [ 8384 ] = $55 ; } $56 = HEAP32 [ 8384 ] | 0 ; $57 = $56 & 1 ; $58 = ( $57 | 0 ) != ( 0 ) ; if ( $58 ) { $59 = HEAP32 [ 8384 ] | 0 ; $60 = $59 & 16 ; $61 = ( $60 | 0 ) != ( 0 ) ; if ( $61 ) { $62 = HEAP32 [ 8384 ] | 0 ; $63 = $62 & 4 ; $64 = ( $63 | 0 ) != ( 0 ) ; $65 = $64 ? 20082 : 20087 ; HEAP32 [ $1 >> 2 ] = $65 ; } } $66 = HEAP32 [ $1 >> 2 ] | 0 ; $67 = ( $66 | 0 ) != ( 0 | 0 ) ; if ( ! ( $67 ) ) { $68 = HEAP32 [ 8452 ] | 0 ; __THREW__ = 0 ; invoke_vi ( $68 | 0 , ( 20103 | 0 ) ) ; $69 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $69 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $70 = _testSetjmp ( HEAP32 [ $69 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $70 | 0 ) == 0 ) { _longjmp ( $69 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $70 = - 1 ; } ; $71 = tempRet0 ; switch ( $70 | 0 ) { case 2 : { $$reg2mem150$0 = $71 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $71 ; continue L3 ; break ; } default : { } } } $72 = ( 33552 ) ; $73 = $72 ; $74 = HEAP32 [ $73 >> 2 ] | 0 ; $75 = ( ( $72 ) + 4 ) | 0 ; $76 = $75 ; $77 = HEAP32 [ $76 >> 2 ] | 0 ; $78 = ( $74 | 0 ) == ( 0 ) ; $79 = ( $77 | 0 ) == ( 0 ) ; $80 = $78 & $79 ; if ( $80 ) { __THREW__ = 0 ; $81 = ( invoke_iii ( 53 , ( $0 | 0 ) , ( ( 33552 ) | 0 ) ) | 0 ) ; $82 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $82 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $83 = _testSetjmp ( HEAP32 [ $82 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $83 | 0 ) == 0 ) { _longjmp ( $82 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $83 = - 1 ; } ; $84 = tempRet0 ; switch ( $83 | 0 ) { case 2 : { $$reg2mem150$0 = $84 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $84 ; continue L3 ; break ; } default : { } } $85 = ( $81 | 0 ) < ( 0 ) ; if ( $85 ) { __THREW__ = 0 ; invoke_vi ( 39 , ( 20132 | 0 ) ) ; $86 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $86 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $87 = _testSetjmp ( HEAP32 [ $86 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $87 | 0 ) == 0 ) { _longjmp ( $86 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $87 = - 1 ; } ; $88 = tempRet0 ; switch ( $87 | 0 ) { case 2 : { $$reg2mem150$0 = $88 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $88 ; continue L3 ; break ; } default : { } } $89 = ( 33552 ) ; $90 = $89 ; HEAP32 [ $90 >> 2 ] = 0 ; $91 = ( ( $89 ) + 4 ) | 0 ; $92 = $91 ; HEAP32 [ $92 >> 2 ] = 0 ; } } $2 = 0 ; HEAP32 [ ( 33788 ) >> 2 ] = 0 ; $93 = HEAP32 [ ( 33788 ) >> 2 ] | 0 ; $94 = ( $93 | 0 ) != ( 0 ) ; if ( ! ( $94 ) ) { break L6 ; } } if ( ( label | 0 ) == 7 ) { label = 0 ; HEAP32 [ ( 33792 ) >> 2 ] = 24383 ; $23 = HEAP32 [ 8446 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 20 , ( $23 | 0 ) , 1 ) ; $24 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $24 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $25 = _testSetjmp ( HEAP32 [ $24 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $25 | 0 ) == 0 ) { _longjmp ( $24 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $25 = - 1 ; } ; $26 = tempRet0 ; switch ( $25 | 0 ) { case 2 : { $$reg2mem150$0 = $26 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $26 ; continue L3 ; break ; } default : { label = 8 ; break L3 ; } } } else if ( ( label | 0 ) == 15 ) { label = 0 ; HEAP32 [ ( 33792 ) >> 2 ] = 20051 ; $49 = HEAP32 [ 8446 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 20 , ( $49 | 0 ) , 1 ) ; $50 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $50 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $51 = _testSetjmp ( HEAP32 [ $50 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $51 | 0 ) == 0 ) { _longjmp ( $50 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $51 = - 1 ; } ; $52 = tempRet0 ; switch ( $51 | 0 ) { case 2 : { $$reg2mem150$0 = $52 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $52 ; continue L3 ; break ; } default : { label = 16 ; break L3 ; } } } } else { HEAP32 [ ( 33788 ) >> 2 ] = 1 ; } } while ( 0 ) ; $95 = $3 ; HEAP32 [ 8446 ] = $95 ; $96 = HEAP32 [ ( 33788 ) >> 2 ] | 0 ; $97 = ( $96 | 0 ) != ( 0 ) ; if ( $97 ) { $98 = HEAP32 [ ( 33792 ) >> 2 ] | 0 ; $2 = $98 ; $99 = HEAP32 [ 8520 ] | 0 ; $100 = HEAP32 [ 8522 ] | 0 ; __THREW__ = 0 ; $101 = ( invoke_iii ( 54 , ( $99 | 0 ) , ( $100 | 0 ) ) | 0 ) ; $102 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $102 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $103 = _testSetjmp ( HEAP32 [ $102 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $103 | 0 ) == 0 ) { _longjmp ( $102 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $103 = - 1 ; } ; $104 = tempRet0 ; switch ( $103 | 0 ) { case 2 : { $$reg2mem150$0 = $104 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $104 ; continue L3 ; break ; } default : { } } $105 = ( $101 | 0 ) != ( 0 ) ; if ( $105 ) { $106 = HEAP32 [ 8520 ] | 0 ; $107 = $2 ; __THREW__ = 0 ; invoke_vii ( 55 , ( $106 | 0 ) , ( $107 | 0 ) ) ; $108 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $108 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $109 = _testSetjmp ( HEAP32 [ $108 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $109 | 0 ) == 0 ) { _longjmp ( $108 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $109 = - 1 ; } ; $110 = tempRet0 ; switch ( $109 | 0 ) { case 2 : { $$reg2mem150$0 = $110 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $110 ; continue L3 ; break ; } default : { } } $2 = 0 ; } } $111 = HEAP32 [ 8446 ] | 0 ; $5 = $111 ; HEAP32 [ 8446 ] = $6 ; _setjmpTable = _saveSetjmp ( $6 , 1 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; _setjmpTableSize = tempRet0 ; __THREW__ = 0 ; $112 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $112 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $113 = _testSetjmp ( HEAP32 [ $112 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $113 | 0 ) == 0 ) { _longjmp ( $112 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $113 = - 1 ; } ; $114 = tempRet0 ; switch ( $113 | 0 ) { case 2 : { $$reg2mem150$0 = $114 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $114 ; continue L3 ; break ; } default : { } } $$reg2mem148$0 = 0 ; } $115 = ( $$reg2mem148$0 | 0 ) == ( 0 ) ; L48 : do { if ( $115 ) { while ( 1 ) { $116 = $2 ; $117 = ( $116 | 0 ) != ( 0 | 0 ) ; if ( $117 ) { break ; } $123 = HEAP32 [ $1 >> 2 ] | 0 ; __THREW__ = 0 ; $124 = ( invoke_iii ( 27 , ( $123 | 0 ) , ( 20164 | 0 ) ) | 0 ) ; $125 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $125 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $126 = _testSetjmp ( HEAP32 [ $125 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $126 | 0 ) == 0 ) { _longjmp ( $125 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $126 = - 1 ; } ; $127 = tempRet0 ; switch ( $126 | 0 ) { case 2 : { $$reg2mem150$0 = $127 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $127 ; continue L3 ; break ; } default : { } } $128 = ( $124 | 0 ) != ( 0 ) ; if ( $128 ) { $129 = HEAP32 [ 8449 ] | 0 ; $130 = HEAP32 [ $1 >> 2 ] | 0 ; __THREW__ = 0 ; HEAP32 [ $vararg_buffer >> 2 ] = $130 ; invoke_vii ( $129 | 0 , ( 20168 | 0 ) , ( $vararg_buffer | 0 ) ) ; $131 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $131 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $132 = _testSetjmp ( HEAP32 [ $131 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $132 | 0 ) == 0 ) { _longjmp ( $131 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $132 = - 1 ; } ; $133 = tempRet0 ; switch ( $132 | 0 ) { case 2 : { $$reg2mem150$0 = $133 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $133 ; continue L3 ; break ; } default : { } } $134 = HEAP32 [ 8384 ] | 0 ; $135 = $134 & 16 ; $136 = ( $135 | 0 ) != ( 0 ) ; if ( $136 ) { $137 = HEAP32 [ 8384 ] | 0 ; $138 = $137 & 1 ; $139 = ( $138 | 0 ) != ( 0 ) ; if ( ! ( $139 ) ) { $140 = HEAP32 [ 8449 ] | 0 ; __THREW__ = 0 ; invoke_vii ( $140 | 0 , ( 20181 | 0 ) , ( $vararg_buffer152 | 0 ) ) ; $141 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $141 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $142 = _testSetjmp ( HEAP32 [ $141 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $142 | 0 ) == 0 ) { _longjmp ( $141 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $142 = - 1 ; } ; $143 = tempRet0 ; switch ( $142 | 0 ) { case 2 : { $$reg2mem150$0 = $143 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $143 ; continue L3 ; break ; } default : { } } } $144 = HEAP32 [ ( 33908 ) >> 2 ] | 0 ; $145 = ( $144 | 0 ) != ( 0 ) ; if ( $145 ) { $146 = HEAP32 [ 8449 ] | 0 ; __THREW__ = 0 ; invoke_vii ( $146 | 0 , ( 20209 | 0 ) , ( $vararg_buffer155 | 0 ) ) ; $147 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $147 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $148 = _testSetjmp ( HEAP32 [ $147 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $148 | 0 ) == 0 ) { _longjmp ( $147 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $148 = - 1 ; } ; $149 = tempRet0 ; switch ( $148 | 0 ) { case 2 : { $$reg2mem150$0 = $149 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $149 ; continue L3 ; break ; } default : { } } } } $150 = HEAP32 [ 8449 ] | 0 ; __THREW__ = 0 ; invoke_vii ( $150 | 0 , ( 17974 | 0 ) , ( $vararg_buffer158 | 0 ) ) ; $151 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $151 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $152 = _testSetjmp ( HEAP32 [ $151 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $152 | 0 ) == 0 ) { _longjmp ( $151 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $152 = - 1 ; } ; $153 = tempRet0 ; switch ( $152 | 0 ) { case 2 : { $$reg2mem150$0 = $153 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $153 ; continue L3 ; break ; } default : { } } } $154 = HEAP32 [ 8520 ] | 0 ; $155 = HEAP32 [ 8522 ] | 0 ; __THREW__ = 0 ; invoke_viii ( 56 , ( $154 | 0 ) , ( $155 | 0 ) , 1 ) ; $156 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $156 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $157 = _testSetjmp ( HEAP32 [ $156 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $157 | 0 ) == 0 ) { _longjmp ( $156 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $157 = - 1 ; } ; $158 = tempRet0 ; switch ( $157 | 0 ) { case 2 : { $$reg2mem150$0 = $158 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $158 ; continue L3 ; break ; } default : { } } __THREW__ = 0 ; invoke_viiii ( 57 , 1 , 1 , 1 , 1 ) ; $159 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $159 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $160 = _testSetjmp ( HEAP32 [ $159 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $160 | 0 ) == 0 ) { _longjmp ( $159 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $160 = - 1 ; } ; $161 = tempRet0 ; switch ( $160 | 0 ) { case 2 : { $$reg2mem150$0 = $161 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $161 ; continue L3 ; break ; } default : { } } $162 = HEAP32 [ 8449 ] | 0 ; __THREW__ = 0 ; invoke_vii ( $162 | 0 , ( 17974 | 0 ) , ( $vararg_buffer161 | 0 ) ) ; $163 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $163 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $164 = _testSetjmp ( HEAP32 [ $163 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $164 | 0 ) == 0 ) { _longjmp ( $163 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $164 = - 1 ; } ; $165 = tempRet0 ; switch ( $164 | 0 ) { case 2 : { $$reg2mem150$0 = $165 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $165 ; continue L3 ; break ; } default : { } } $166 = HEAP32 [ ( 33868 ) >> 2 ] | 0 ; $167 = ( $166 | 0 ) != ( 0 ) ; if ( $167 ) { $168 = 1023 & - 4 ; $$0 = $168 ; } else { $$0 = 1023 ; } $169 = HEAP32 [ ( 33872 ) >> 2 ] | 0 ; $170 = ( $169 | 0 ) != ( 0 ) ; if ( $170 ) { $171 = $$0 & - 253 ; $$1 = $171 ; } else { $$1 = $$0 ; } $172 = HEAP32 [ ( 33876 ) >> 2 ] | 0 ; $173 = ( $172 | 0 ) != ( 0 ) ; if ( $173 ) { $174 = $$1 & - 769 ; $$2 = $174 ; } else { $$2 = $$1 ; } $175 = HEAP32 [ ( 33880 ) >> 2 ] | 0 ; $176 = ( $175 | 0 ) != ( 0 ) ; if ( $176 ) { $177 = HEAP32 [ 8384 ] | 0 ; $178 = $177 & 2 ; $179 = ( $178 | 0 ) != ( 0 ) ; if ( $179 ) { $$3 = 0 ; } else { $$3 = $$2 ; } } else { $$3 = $$2 ; } $180 = HEAP32 [ 8384 ] | 0 ; $181 = $180 & 8 ; $182 = ( $181 | 0 ) != ( 0 ) ; if ( $182 ) { $$4 = 0 ; } else { $$4 = $$3 ; } $183 = HEAP32 [ 8384 ] | 0 ; $184 = $183 & 1 ; $185 = ( $184 | 0 ) != ( 0 ) ; if ( $185 ) { $186 = HEAP32 [ 8384 ] | 0 ; $187 = $186 & 16 ; $188 = ( $187 | 0 ) != ( 0 ) ; $189 = ( $$4 | 0 ) != ( 0 ) ; $or$cond = $188 & $189 ; $or$cond$not = $or$cond ^ 1 ; $190 = HEAP32 [ ( 33908 ) >> 2 ] | 0 ; $191 = ( $190 | 0 ) != ( 0 ) ; $or$cond3 = $or$cond$not | $191 ; if ( $or$cond3 ) { $$5 = $$4 ; } else { $192 = HEAP32 [ 8449 ] | 0 ; __THREW__ = 0 ; invoke_vii ( $192 | 0 , ( 20223 | 0 ) , ( $vararg_buffer164 | 0 ) ) ; $193 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $193 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $194 = _testSetjmp ( HEAP32 [ $193 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $194 | 0 ) == 0 ) { _longjmp ( $193 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $194 = - 1 ; } ; $195 = tempRet0 ; switch ( $194 | 0 ) { case 2 : { $$reg2mem150$0 = $195 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $195 ; continue L3 ; break ; } default : { } } $$5 = 0 ; } } else { $$5 = $$4 ; } $196 = HEAP32 [ 8520 ] | 0 ; $197 = HEAP32 [ 8522 ] | 0 ; __THREW__ = 0 ; $198 = ( invoke_iiii ( 58 , ( $196 | 0 ) , ( $197 | 0 ) , ( $$5 | 0 ) ) | 0 ) ; $199 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $199 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $200 = _testSetjmp ( HEAP32 [ $199 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $200 | 0 ) == 0 ) { _longjmp ( $199 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $200 = - 1 ; } ; $201 = tempRet0 ; switch ( $200 | 0 ) { case 2 : { $$reg2mem150$0 = $201 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $201 ; continue L3 ; break ; } default : { } } HEAP32 [ ( 33608 ) >> 2 ] = $198 ; $202 = HEAP32 [ ( 33608 ) >> 2 ] | 0 ; $203 = ( $202 | 0 ) != ( 0 ) ; if ( $203 ) { $204 = HEAP32 [ 8520 ] | 0 ; $205 = HEAP32 [ 8522 ] | 0 ; __THREW__ = 0 ; invoke_viii ( 56 , ( $204 | 0 ) , ( $205 | 0 ) , 1 ) ; $206 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $206 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $207 = _testSetjmp ( HEAP32 [ $206 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $207 | 0 ) == 0 ) { _longjmp ( $206 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $207 = - 1 ; } ; $208 = tempRet0 ; switch ( $207 | 0 ) { case 2 : { $$reg2mem150$0 = $208 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $208 ; continue L3 ; break ; } default : { } } $209 = HEAP32 [ 8449 ] | 0 ; __THREW__ = 0 ; invoke_vii ( $209 | 0 , ( 20333 | 0 ) , ( $vararg_buffer167 | 0 ) ) ; $210 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $210 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $211 = _testSetjmp ( HEAP32 [ $210 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $211 | 0 ) == 0 ) { _longjmp ( $210 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $211 = - 1 ; } ; $212 = tempRet0 ; switch ( $211 | 0 ) { case 2 : { $$reg2mem150$0 = $212 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $212 ; continue L3 ; break ; } default : { } } __THREW__ = 0 ; invoke_viiii ( 57 , 0 , 1 , 1 , 0 ) ; $213 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $213 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $214 = _testSetjmp ( HEAP32 [ $213 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $214 | 0 ) == 0 ) { _longjmp ( $213 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $214 = - 1 ; } ; $215 = tempRet0 ; switch ( $214 | 0 ) { case 2 : { $$reg2mem150$0 = $215 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $215 ; continue L3 ; break ; } default : { } } $216 = HEAP32 [ 8449 ] | 0 ; __THREW__ = 0 ; invoke_vii ( $216 | 0 , ( 17974 | 0 ) , ( $vararg_buffer170 | 0 ) ) ; $217 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $217 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $218 = _testSetjmp ( HEAP32 [ $217 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $218 | 0 ) == 0 ) { _longjmp ( $217 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $218 = - 1 ; } ; $219 = tempRet0 ; switch ( $218 | 0 ) { case 2 : { $$reg2mem150$0 = $219 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $219 ; continue L3 ; break ; } default : { } } } $220 = HEAP32 [ ( 33864 ) >> 2 ] | 0 ; $221 = ( $220 | 0 ) >= ( 0 ) ; if ( $221 ) { $222 = HEAP32 [ ( 33956 ) >> 2 ] | 0 ; $223 = HEAP32 [ ( 33864 ) >> 2 ] | 0 ; $224 = ( $222 | 0 ) != ( $223 | 0 ) ; if ( $224 ) { $225 = HEAP32 [ ( 33864 ) >> 2 ] | 0 ; HEAP32 [ ( 33956 ) >> 2 ] = $225 ; $226 = HEAP32 [ 8384 ] | 0 ; $227 = $226 | 8192 ; HEAP32 [ 8384 ] = $227 ; } } HEAP32 [ ( 33788 ) >> 2 ] = 0 ; $228 = HEAP32 [ ( 33788 ) >> 2 ] | 0 ; $229 = ( $228 | 0 ) != ( 0 ) ; if ( ! ( $229 ) ) { break L48 ; } } $118 = $2 ; HEAP32 [ ( 33792 ) >> 2 ] = $118 ; $119 = HEAP32 [ 8446 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 20 , ( $119 | 0 ) , 1 ) ; $120 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $120 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $121 = _testSetjmp ( HEAP32 [ $120 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $121 | 0 ) == 0 ) { _longjmp ( $120 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $121 = - 1 ; } ; $122 = tempRet0 ; switch ( $121 | 0 ) { case 2 : { $$reg2mem150$0 = $122 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $122 ; continue L3 ; break ; } default : { label = 42 ; break L3 ; } } } else { HEAP32 [ ( 33788 ) >> 2 ] = 1 ; } } while ( 0 ) ; $230 = $5 ; HEAP32 [ 8446 ] = $230 ; $231 = HEAP32 [ ( 33788 ) >> 2 ] | 0 ; $232 = ( $231 | 0 ) != ( 0 ) ; if ( ! ( $232 ) ) { $247 = HEAP32 [ 8520 ] | 0 ; $248 = HEAP32 [ 8522 ] | 0 ; __THREW__ = 0 ; invoke_viiii ( 59 , ( $247 | 0 ) , ( $248 | 0 ) , 2 , 65535 ) ; $249 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $249 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $250 = _testSetjmp ( HEAP32 [ $249 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $250 | 0 ) == 0 ) { _longjmp ( $249 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $250 = - 1 ; } ; $251 = tempRet0 ; switch ( $250 | 0 ) { case 2 : { $$reg2mem150$0 = $251 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $251 ; continue L3 ; break ; } default : { } } __THREW__ = 0 ; invoke_viii ( 60 , ( 34080 | 0 ) , ( 34088 | 0 ) , ( 0 | 0 ) ) ; $252 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $252 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $253 = _testSetjmp ( HEAP32 [ $252 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $253 | 0 ) == 0 ) { _longjmp ( $252 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $253 = - 1 ; } ; $254 = tempRet0 ; switch ( $253 | 0 ) { case 2 : { $$reg2mem150$0 = $254 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $254 ; continue L3 ; break ; } default : { label = 92 ; break L3 ; } } } $233 = HEAP32 [ ( 33792 ) >> 2 ] | 0 ; $2 = $233 ; $234 = HEAP32 [ 8520 ] | 0 ; $235 = HEAP32 [ 8522 ] | 0 ; __THREW__ = 0 ; invoke_viiii ( 59 , ( $234 | 0 ) , ( $235 | 0 ) , 1 , 65535 ) ; $236 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $236 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $237 = _testSetjmp ( HEAP32 [ $236 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $237 | 0 ) == 0 ) { _longjmp ( $236 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $237 = - 1 ; } ; $238 = tempRet0 ; switch ( $237 | 0 ) { case 2 : { $$reg2mem150$0 = $238 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $238 ; continue L3 ; break ; } default : { } } __THREW__ = 0 ; invoke_viii ( 60 , ( 34080 | 0 ) , ( 34088 | 0 ) , ( 0 | 0 ) ) ; $239 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $239 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $240 = _testSetjmp ( HEAP32 [ $239 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $240 | 0 ) == 0 ) { _longjmp ( $239 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $240 = - 1 ; } ; $241 = tempRet0 ; switch ( $240 | 0 ) { case 2 : { $$reg2mem150$0 = $241 ; label = 3 ; continue L3 ; break ; } case 1 : { $$reg2mem148$0 = $241 ; continue L3 ; break ; } default : { } } $242 = $2 ; HEAP32 [ ( 33792 ) >> 2 ] = $242 ; $243 = HEAP32 [ 8446 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 20 , ( $243 | 0 ) , 1 ) ; $244 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $244 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $245 = _testSetjmp ( HEAP32 [ $244 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $245 | 0 ) == 0 ) { _longjmp ( $244 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $245 = - 1 ; } ; $246 = tempRet0 ; switch ( $245 | 0 ) { case 2 : { $$reg2mem150$0 = $246 ; label = 3 ; break ; } case 1 : { $$reg2mem148$0 = $246 ; break ; } default : { label = 89 ; break L3 ; } } } if ( ( label | 0 ) == 8 ) { // unreachable; } else if ( ( label | 0 ) == 16 ) { // unreachable; } else if ( ( label | 0 ) == 42 ) { // unreachable; } else if ( ( label | 0 ) == 89 ) { // unreachable; } else if ( ( label | 0 ) == 92 ) { _free ( _setjmpTable | 0 ) ; STACKTOP = sp ; return ; } } function _opng_init_iterations ( ) { var $0 = 0 , $1 = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 ; var $116 = 0 , $117 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 ; var $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 ; var $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 ; var $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 ; var $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $or$cond = 0 , $or$cond3 = 0 ; var label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $0 = sp + 28 | 0 ; $1 = sp + 24 | 0 ; $2 = sp + 20 | 0 ; $3 = sp + 16 | 0 ; $8 = HEAP32 [ 8384 ] | 0 ; $9 = $8 & 8192 ; $10 = ( $9 | 0 ) != ( 0 ) ; $11 = HEAP32 [ ( 33832 ) >> 2 ] | 0 ; $12 = ( $11 | 0 ) != ( 0 ) ; $or$cond = $10 | $12 ; if ( $or$cond ) { $36 = 2147483647 ; $39 = 0 ; } else { $13 = ( 33568 ) ; $14 = $13 ; $15 = HEAP32 [ $14 >> 2 ] | 0 ; $16 = ( ( $13 ) + 4 ) | 0 ; $17 = $16 ; $18 = HEAP32 [ $17 >> 2 ] | 0 ; $19 = ( $18 >>> 0 ) > ( 0 ) ; $20 = ( $15 >>> 0 ) > ( 0 ) ; $21 = ( $18 | 0 ) == ( 0 ) ; $22 = $21 & $20 ; $23 = $19 | $22 ; if ( ! ( $23 ) ) { $24 = HEAP32 [ 8452 ] | 0 ; FUNCTION_TABLE_vi [ $24 & 127 ] ( 19924 ) ; } $25 = ( 33568 ) ; $26 = $25 ; $27 = HEAP32 [ $26 >> 2 ] | 0 ; $28 = ( ( $25 ) + 4 ) | 0 ; $29 = $28 ; $30 = HEAP32 [ $29 >> 2 ] | 0 ; $31 = HEAP32 [ ( 33600 ) >> 2 ] | 0 ; $32 = ( _i64Add ( ( $27 | 0 ) , ( $30 | 0 ) , ( $31 | 0 ) , 0 ) | 0 ) ; $33 = tempRet0 ; $36 = $32 ; $39 = $33 ; } $34 = ( 33592 ) ; $35 = $34 ; HEAP32 [ $35 >> 2 ] = $36 ; $37 = ( ( $34 ) + 4 ) | 0 ; $38 = $37 ; HEAP32 [ $38 >> 2 ] = $39 ; $40 = HEAP32 [ ( 33884 ) >> 2 ] | 0 ; $5 = $40 ; $41 = $5 ; $42 = ( $41 | 0 ) < ( 0 ) ; if ( $42 ) { $5 = 2 ; } else { $43 = $5 ; $44 = ( $43 | 0 ) > ( 7 ) ; if ( $44 ) { $5 = 7 ; } } $45 = HEAP32 [ ( 33888 ) >> 2 ] | 0 ; $46 = $5 ; $47 = ( 32 + ( $46 << 4 ) | 0 ) ; $48 = HEAP32 [ $47 >> 2 ] | 0 ; _opng_init_iteration ( $45 , 1022 , $48 , $0 ) ; $49 = HEAP32 [ ( 33892 ) >> 2 ] | 0 ; $50 = $5 ; $51 = ( 32 + ( $50 << 4 ) | 0 ) ; $52 = ( ( ( $51 ) ) + 4 | 0 ) ; $53 = HEAP32 [ $52 >> 2 ] | 0 ; _opng_init_iteration ( $49 , 1022 , $53 , $1 ) ; $54 = HEAP32 [ ( 33896 ) >> 2 ] | 0 ; $55 = $5 ; $56 = ( 32 + ( $55 << 4 ) | 0 ) ; $57 = ( ( ( $56 ) ) + 8 | 0 ) ; $58 = HEAP32 [ $57 >> 2 ] | 0 ; _opng_init_iteration ( $54 , 15 , $58 , $2 ) ; $59 = HEAP32 [ ( 33900 ) >> 2 ] | 0 ; $60 = $5 ; $61 = ( 32 + ( $60 << 4 ) | 0 ) ; $62 = ( ( ( $61 ) ) + 12 | 0 ) ; $63 = HEAP32 [ $62 >> 2 ] | 0 ; _opng_init_iteration ( $59 , 63 , $63 , $3 ) ; $64 = HEAP32 [ $0 >> 2 ] | 0 ; $65 = ( $64 | 0 ) == ( 0 ) ; if ( $65 ) { $66 = HEAP32 [ $0 >> 2 ] | 0 ; $67 = $66 | 512 ; HEAP32 [ $0 >> 2 ] = $67 ; } $68 = HEAP32 [ $1 >> 2 ] | 0 ; $69 = ( $68 | 0 ) == ( 0 ) ; if ( $69 ) { $70 = HEAP32 [ $1 >> 2 ] | 0 ; $71 = $70 | 256 ; HEAP32 [ $1 >> 2 ] = $71 ; } $72 = HEAP32 [ ( 33940 ) >> 2 ] | 0 ; $73 = ( $72 | 0 ) < ( 8 ) ; $74 = HEAP32 [ ( 33964 ) >> 2 ] | 0 ; $75 = ( $74 | 0 ) != ( 0 | 0 ) ; $or$cond3 = $73 | $75 ; $76 = HEAP32 [ $2 >> 2 ] | 0 ; $77 = ( $76 | 0 ) == ( 0 ) ; if ( $or$cond3 ) { if ( $77 ) { $78 = HEAP32 [ $2 >> 2 ] | 0 ; $79 = $78 | 1 ; HEAP32 [ $2 >> 2 ] = $79 ; } $80 = HEAP32 [ $3 >> 2 ] | 0 ; $81 = ( $80 | 0 ) == ( 0 ) ; if ( $81 ) { $82 = HEAP32 [ $3 >> 2 ] | 0 ; $83 = $82 | 1 ; HEAP32 [ $3 >> 2 ] = $83 ; } } else { if ( $77 ) { $84 = HEAP32 [ $2 >> 2 ] | 0 ; $85 = $84 | 2 ; HEAP32 [ $2 >> 2 ] = $85 ; } $86 = HEAP32 [ $3 >> 2 ] | 0 ; $87 = ( $86 | 0 ) == ( 0 ) ; if ( $87 ) { $88 = HEAP32 [ $3 >> 2 ] | 0 ; $89 = $88 | 32 ; HEAP32 [ $3 >> 2 ] = $89 ; } } $90 = HEAP32 [ $0 >> 2 ] | 0 ; HEAP32 [ ( 33612 ) >> 2 ] = $90 ; $91 = HEAP32 [ $1 >> 2 ] | 0 ; HEAP32 [ ( 33616 ) >> 2 ] = $91 ; $92 = HEAP32 [ $2 >> 2 ] | 0 ; HEAP32 [ ( 33620 ) >> 2 ] = $92 ; $93 = HEAP32 [ $3 >> 2 ] | 0 ; HEAP32 [ ( 33624 ) >> 2 ] = $93 ; $4 = 12 ; $94 = HEAP32 [ $0 >> 2 ] | 0 ; $95 = ( _opng_bitset_count ( $94 ) | 0 ) ; $96 = HEAP32 [ $2 >> 2 ] | 0 ; $97 = $4 ; $98 = $97 ^ - 1 ; $99 = $96 & $98 ; $100 = ( _opng_bitset_count ( $99 ) | 0 ) ; $101 = Math_imul ( $95 , $100 ) | 0 ; $6 = $101 ; $102 = HEAP32 [ $2 >> 2 ] | 0 ; $103 = $4 ; $104 = $102 & $103 ; $105 = ( _opng_bitset_count ( $104 ) | 0 ) ; $7 = $105 ; $106 = $6 ; $107 = $7 ; $108 = ( ( $106 ) + ( $107 ) ) | 0 ; $109 = HEAP32 [ $1 >> 2 ] | 0 ; $110 = ( _opng_bitset_count ( $109 ) | 0 ) ; $111 = Math_imul ( $108 , $110 ) | 0 ; $112 = HEAP32 [ $3 >> 2 ] | 0 ; $113 = ( _opng_bitset_count ( $112 ) | 0 ) ; $114 = Math_imul ( $111 , $113 ) | 0 ; HEAP32 [ ( 33540 ) >> 2 ] = $114 ; $115 = HEAP32 [ ( 33540 ) >> 2 ] | 0 ; $116 = ( $115 | 0 ) > ( 0 ) ; if ( $116 ) { STACKTOP = sp ; return ; } $117 = HEAP32 [ 8452 ] | 0 ; FUNCTION_TABLE_vi [ $117 & 127 ] ( 19941 ) ; STACKTOP = sp ; return ; } function _opng_iterate ( ) { var $0 = 0 , $1 = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 ; var $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 ; var $134 = 0 , $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 ; var $152 = 0 , $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 ; var $170 = 0 , $171 = 0 , $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 ; var $189 = 0 , $19 = 0 , $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 ; var $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 ; var $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 ; var $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 ; var $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $or$cond = 0 , $vararg_buffer = 0 , $vararg_buffer11 = 0 , $vararg_buffer2 = 0 ; var $vararg_buffer8 = 0 , $vararg_ptr4 = 0 , $vararg_ptr5 = 0 , $vararg_ptr6 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 80 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 80 | 0 ) ; $vararg_buffer11 = sp + 32 | 0 ; $vararg_buffer8 = sp + 24 | 0 ; $vararg_buffer2 = sp + 8 | 0 ; $vararg_buffer = sp ; $10 = HEAP32 [ ( 33540 ) >> 2 ] | 0 ; $11 = ( $10 | 0 ) > ( 0 ) ; if ( ! ( $11 ) ) { $12 = HEAP32 [ 8452 ] | 0 ; FUNCTION_TABLE_vi [ $12 & 127 ] ( 19820 ) ; } $13 = HEAP32 [ ( 33612 ) >> 2 ] | 0 ; $0 = $13 ; $14 = HEAP32 [ ( 33616 ) >> 2 ] | 0 ; $1 = $14 ; $15 = HEAP32 [ ( 33620 ) >> 2 ] | 0 ; $2 = $15 ; $16 = HEAP32 [ ( 33624 ) >> 2 ] | 0 ; $3 = $16 ; $17 = HEAP32 [ ( 33540 ) >> 2 ] | 0 ; $18 = ( $17 | 0 ) == ( 1 ) ; if ( $18 ) { $19 = HEAP32 [ 8384 ] | 0 ; $20 = $19 & 8192 ; $21 = ( $20 | 0 ) != ( 0 ) ; if ( $21 ) { $22 = ( 33584 ) ; $23 = $22 ; HEAP32 [ $23 >> 2 ] = 0 ; $24 = ( ( $22 ) + 4 ) | 0 ; $25 = $24 ; HEAP32 [ $25 >> 2 ] = 0 ; $26 = $0 ; $27 = ( _opng_bitset_find_first ( $26 ) | 0 ) ; HEAP32 [ ( 33628 ) >> 2 ] = $27 ; $28 = $1 ; $29 = ( _opng_bitset_find_first ( $28 ) | 0 ) ; HEAP32 [ ( 33632 ) >> 2 ] = $29 ; $30 = $2 ; $31 = ( _opng_bitset_find_first ( $30 ) | 0 ) ; HEAP32 [ ( 33636 ) >> 2 ] = $31 ; $32 = $3 ; $33 = ( _opng_bitset_find_first ( $32 ) | 0 ) ; HEAP32 [ ( 33640 ) >> 2 ] = $33 ; STACKTOP = sp ; return ; } } $34 = ( 33584 ) ; $35 = $34 ; HEAP32 [ $35 >> 2 ] = - 2147483648 ; $36 = ( ( $34 ) + 4 ) | 0 ; $37 = $36 ; HEAP32 [ $37 >> 2 ] = 0 ; HEAP32 [ ( 33628 ) >> 2 ] = - 1 ; HEAP32 [ ( 33632 ) >> 2 ] = - 1 ; HEAP32 [ ( 33636 ) >> 2 ] = - 1 ; HEAP32 [ ( 33640 ) >> 2 ] = - 1 ; $38 = HEAP32 [ 8449 ] | 0 ; FUNCTION_TABLE_vii [ $38 & 127 ] ( 19847 , $vararg_buffer ) ; $9 = 0 ; $8 = 0 ; $7 = 0 ; while ( 1 ) { $39 = $7 ; $40 = ( $39 | 0 ) <= ( 5 ) ; if ( ! ( $40 ) ) { break ; } $41 = $3 ; $42 = $7 ; $43 = 1 << $42 ; $44 = $41 & $43 ; $45 = ( $44 | 0 ) != ( 0 ) ; L12 : do { if ( $45 ) { $6 = 0 ; while ( 1 ) { $46 = $6 ; $47 = ( $46 | 0 ) <= ( 3 ) ; if ( ! ( $47 ) ) { break L12 ; } $48 = $2 ; $49 = $6 ; $50 = 1 << $49 ; $51 = $48 & $50 ; $52 = ( $51 | 0 ) != ( 0 ) ; L17 : do { if ( $52 ) { $53 = $6 ; $54 = ( $53 | 0 ) == ( 2 ) ; do { if ( $54 ) { $0 = 0 ; $55 = $0 ; $56 = $55 | 2 ; $0 = $56 ; } else { $57 = $6 ; $58 = ( $57 | 0 ) == ( 3 ) ; if ( $58 ) { $0 = 0 ; $59 = $0 ; $60 = $59 | 512 ; $0 = $60 ; break ; } else { $61 = HEAP32 [ ( 33612 ) >> 2 ] | 0 ; $0 = $61 ; break ; } } } while ( 0 ) ; $4 = 9 ; while ( 1 ) { $62 = $4 ; $63 = ( $62 | 0 ) >= ( 1 ) ; if ( ! ( $63 ) ) { break L17 ; } $64 = $0 ; $65 = $4 ; $66 = 1 << $65 ; $67 = $64 & $66 ; $68 = ( $67 | 0 ) != ( 0 ) ; L29 : do { if ( $68 ) { $5 = 9 ; while ( 1 ) { $69 = $5 ; $70 = ( $69 | 0 ) >= ( 1 ) ; if ( ! ( $70 ) ) { break L29 ; } $71 = $1 ; $72 = $5 ; $73 = 1 << $72 ; $74 = $71 & $73 ; $75 = ( $74 | 0 ) != ( 0 ) ; do { if ( $75 ) { $76 = HEAP32 [ 8449 ] | 0 ; $77 = $4 ; $78 = $5 ; $79 = $6 ; $80 = $7 ; HEAP32 [ $vararg_buffer2 >> 2 ] = $77 ; $vararg_ptr4 = ( ( ( $vararg_buffer2 ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr4 >> 2 ] = $78 ; $vararg_ptr5 = ( ( ( $vararg_buffer2 ) ) + 8 | 0 ) ; HEAP32 [ $vararg_ptr5 >> 2 ] = $79 ; $vararg_ptr6 = ( ( ( $vararg_buffer2 ) ) + 12 | 0 ) ; HEAP32 [ $vararg_ptr6 >> 2 ] = $80 ; FUNCTION_TABLE_vii [ $76 & 127 ] ( 19712 , $vararg_buffer2 ) ; $81 = HEAP32 [ 8451 ] | 0 ; $82 = $8 ; $83 = HEAP32 [ ( 33540 ) >> 2 ] | 0 ; FUNCTION_TABLE_vii [ $81 & 127 ] ( $82 , $83 ) ; $84 = $8 ; $85 = ( ( $84 ) + 1 ) | 0 ; $8 = $85 ; $86 = $4 ; $87 = $5 ; $88 = $6 ; $89 = $7 ; _opng_write_file ( 0 , $86 , $87 , $88 , $89 ) ; $90 = ( 33576 ) ; $91 = $90 ; $92 = HEAP32 [ $91 >> 2 ] | 0 ; $93 = ( ( $90 ) + 4 ) | 0 ; $94 = $93 ; $95 = HEAP32 [ $94 >> 2 ] | 0 ; $96 = ( $95 >>> 0 ) > ( 0 ) ; $97 = ( $92 >>> 0 ) > ( 2147483647 ) ; $98 = ( $95 | 0 ) == ( 0 ) ; $99 = $98 & $97 ; $100 = $96 | $99 ; if ( $100 ) { $101 = HEAP32 [ ( 33848 ) >> 2 ] | 0 ; $102 = ( $101 | 0 ) != ( 0 ) ; if ( $102 ) { $103 = HEAP32 [ 8449 ] | 0 ; FUNCTION_TABLE_vii [ $103 & 127 ] ( 19857 , $vararg_buffer8 ) ; $9 = 0 ; break ; } else { $104 = HEAP32 [ 8450 ] | 0 ; FUNCTION_TABLE_vi [ $104 & 127 ] ( 13 ) ; $9 = 1 ; break ; } } $105 = HEAP32 [ 8449 ] | 0 ; $106 = ( 33576 ) ; $107 = $106 ; $108 = HEAP32 [ $107 >> 2 ] | 0 ; $109 = ( ( $106 ) + 4 ) | 0 ; $110 = $109 ; $111 = HEAP32 [ $110 >> 2 ] | 0 ; $112 = $vararg_buffer11 ; $113 = $112 ; HEAP32 [ $113 >> 2 ] = $108 ; $114 = ( ( $112 ) + 4 ) | 0 ; $115 = $114 ; HEAP32 [ $115 >> 2 ] = $111 ; FUNCTION_TABLE_vii [ $105 & 127 ] ( 19873 , $vararg_buffer11 ) ; $9 = 0 ; $116 = ( 33584 ) ; $117 = $116 ; $118 = HEAP32 [ $117 >> 2 ] | 0 ; $119 = ( ( $116 ) + 4 ) | 0 ; $120 = $119 ; $121 = HEAP32 [ $120 >> 2 ] | 0 ; $122 = ( 33576 ) ; $123 = $122 ; $124 = HEAP32 [ $123 >> 2 ] | 0 ; $125 = ( ( $122 ) + 4 ) | 0 ; $126 = $125 ; $127 = HEAP32 [ $126 >> 2 ] | 0 ; $128 = ( $121 >>> 0 ) < ( $127 >>> 0 ) ; $129 = ( $118 >>> 0 ) < ( $124 >>> 0 ) ; $130 = ( $121 | 0 ) == ( $127 | 0 ) ; $131 = $130 & $129 ; $132 = $128 | $131 ; if ( $132 ) { break ; } $133 = ( 33584 ) ; $134 = $133 ; $135 = HEAP32 [ $134 >> 2 ] | 0 ; $136 = ( ( $133 ) + 4 ) | 0 ; $137 = $136 ; $138 = HEAP32 [ $137 >> 2 ] | 0 ; $139 = ( 33576 ) ; $140 = $139 ; $141 = HEAP32 [ $140 >> 2 ] | 0 ; $142 = ( ( $139 ) + 4 ) | 0 ; $143 = $142 ; $144 = HEAP32 [ $143 >> 2 ] | 0 ; $145 = ( $135 | 0 ) == ( $141 | 0 ) ; $146 = ( $138 | 0 ) == ( $144 | 0 ) ; $147 = $145 & $146 ; if ( $147 ) { $148 = HEAP32 [ ( 33636 ) >> 2 ] | 0 ; $149 = ( $148 | 0 ) == ( 2 ) ; $150 = HEAP32 [ ( 33636 ) >> 2 ] | 0 ; $151 = ( $150 | 0 ) == ( 3 ) ; $or$cond = $149 | $151 ; if ( $or$cond ) { break ; } } $152 = $4 ; HEAP32 [ ( 33628 ) >> 2 ] = $152 ; $153 = $5 ; HEAP32 [ ( 33632 ) >> 2 ] = $153 ; $154 = $6 ; HEAP32 [ ( 33636 ) >> 2 ] = $154 ; $155 = $7 ; HEAP32 [ ( 33640 ) >> 2 ] = $155 ; $156 = ( 33576 ) ; $157 = $156 ; $158 = HEAP32 [ $157 >> 2 ] | 0 ; $159 = ( ( $156 ) + 4 ) | 0 ; $160 = $159 ; $161 = HEAP32 [ $160 >> 2 ] | 0 ; $162 = ( 33584 ) ; $163 = $162 ; HEAP32 [ $163 >> 2 ] = $158 ; $164 = ( ( $162 ) + 4 ) | 0 ; $165 = $164 ; HEAP32 [ $165 >> 2 ] = $161 ; $166 = HEAP32 [ ( 33832 ) >> 2 ] | 0 ; $167 = ( $166 | 0 ) != ( 0 ) ; if ( $167 ) { break ; } $168 = ( 33576 ) ; $169 = $168 ; $170 = HEAP32 [ $169 >> 2 ] | 0 ; $171 = ( ( $168 ) + 4 ) | 0 ; $172 = $171 ; $173 = HEAP32 [ $172 >> 2 ] | 0 ; $174 = ( 33592 ) ; $175 = $174 ; HEAP32 [ $175 >> 2 ] = $170 ; $176 = ( ( $174 ) + 4 ) | 0 ; $177 = $176 ; HEAP32 [ $177 >> 2 ] = $173 ; } } while ( 0 ) ; $178 = $5 ; $179 = ( ( $178 ) + - 1 ) | 0 ; $5 = $179 ; } } } while ( 0 ) ; $180 = $4 ; $181 = ( ( $180 ) + - 1 ) | 0 ; $4 = $181 ; } } } while ( 0 ) ; $182 = $6 ; $183 = ( ( $182 ) + 1 ) | 0 ; $6 = $183 ; } } } while ( 0 ) ; $184 = $7 ; $185 = ( ( $184 ) + 1 ) | 0 ; $7 = $185 ; } $186 = $9 ; $187 = ( $186 | 0 ) != ( 0 ) ; if ( $187 ) { $188 = HEAP32 [ 8450 ] | 0 ; FUNCTION_TABLE_vi [ $188 & 127 ] ( - 31 ) ; } $189 = $8 ; $190 = HEAP32 [ ( 33540 ) >> 2 ] | 0 ; $191 = ( $189 | 0 ) == ( $190 | 0 ) ; if ( ! ( $191 ) ) { $192 = HEAP32 [ 8452 ] | 0 ; FUNCTION_TABLE_vi [ $192 & 127 ] ( 19893 ) ; } $193 = HEAP32 [ 8451 ] | 0 ; $194 = $8 ; $195 = HEAP32 [ ( 33540 ) >> 2 ] | 0 ; FUNCTION_TABLE_vii [ $193 & 127 ] ( $194 , $195 ) ; STACKTOP = sp ; return ; } function _opng_finish_iterations ( ) { var $0 = 0 , $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 ; var $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 ; var $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 ; var $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $vararg_buffer = 0 , $vararg_buffer1 = 0 , $vararg_buffer11 = 0 , $vararg_buffer14 = 0 , $vararg_buffer7 = 0 , $vararg_ptr3 = 0 , $vararg_ptr4 = 0 , $vararg_ptr5 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 48 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 48 | 0 ) ; $vararg_buffer14 = sp + 40 | 0 ; $vararg_buffer11 = sp + 32 | 0 ; $vararg_buffer7 = sp + 24 | 0 ; $vararg_buffer1 = sp + 8 | 0 ; $vararg_buffer = sp ; $0 = ( 33584 ) ; $1 = $0 ; $2 = HEAP32 [ $1 >> 2 ] | 0 ; $3 = ( ( $0 ) + 4 ) | 0 ; $4 = $3 ; $5 = HEAP32 [ $4 >> 2 ] | 0 ; $6 = HEAP32 [ ( 33604 ) >> 2 ] | 0 ; $7 = ( _i64Add ( ( $2 | 0 ) , ( $5 | 0 ) , ( $6 | 0 ) , 0 ) | 0 ) ; $8 = tempRet0 ; $9 = ( 33568 ) ; $10 = $9 ; $11 = HEAP32 [ $10 >> 2 ] | 0 ; $12 = ( ( $9 ) + 4 ) | 0 ; $13 = $12 ; $14 = HEAP32 [ $13 >> 2 ] | 0 ; $15 = HEAP32 [ ( 33600 ) >> 2 ] | 0 ; $16 = ( _i64Add ( ( $11 | 0 ) , ( $14 | 0 ) , ( $15 | 0 ) , 0 ) | 0 ) ; $17 = tempRet0 ; $18 = ( $8 >>> 0 ) < ( $17 >>> 0 ) ; $19 = ( $7 >>> 0 ) < ( $16 >>> 0 ) ; $20 = ( $8 | 0 ) == ( $17 | 0 ) ; $21 = $20 & $19 ; $22 = $18 | $21 ; if ( $22 ) { $23 = HEAP32 [ 8384 ] | 0 ; $24 = $23 | 8192 ; HEAP32 [ 8384 ] = $24 ; } $25 = HEAP32 [ 8384 ] | 0 ; $26 = $25 & 8192 ; $27 = ( $26 | 0 ) != ( 0 ) ; if ( ! ( $27 ) ) { STACKTOP = sp ; return ; } $28 = ( 33584 ) ; $29 = $28 ; $30 = HEAP32 [ $29 >> 2 ] | 0 ; $31 = ( ( $28 ) + 4 ) | 0 ; $32 = $31 ; $33 = HEAP32 [ $32 >> 2 ] | 0 ; $34 = ( $33 >>> 0 ) < ( 0 ) ; $35 = ( $30 >>> 0 ) <= ( 2147483647 ) ; $36 = ( $33 | 0 ) == ( 0 ) ; $37 = $36 & $35 ; $38 = $34 | $37 ; $39 = HEAP32 [ 8449 ] | 0 ; if ( ! ( $38 ) ) { HEAP32 [ $vararg_buffer14 >> 2 ] = 19816 ; FUNCTION_TABLE_vii [ $39 & 127 ] ( 19767 , $vararg_buffer14 ) ; STACKTOP = sp ; return ; } FUNCTION_TABLE_vii [ $39 & 127 ] ( 19688 , $vararg_buffer ) ; $40 = HEAP32 [ 8449 ] | 0 ; $41 = HEAP32 [ ( 33628 ) >> 2 ] | 0 ; $42 = HEAP32 [ ( 33632 ) >> 2 ] | 0 ; $43 = HEAP32 [ ( 33636 ) >> 2 ] | 0 ; $44 = HEAP32 [ ( 33640 ) >> 2 ] | 0 ; HEAP32 [ $vararg_buffer1 >> 2 ] = $41 ; $vararg_ptr3 = ( ( ( $vararg_buffer1 ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr3 >> 2 ] = $42 ; $vararg_ptr4 = ( ( ( $vararg_buffer1 ) ) + 8 | 0 ) ; HEAP32 [ $vararg_ptr4 >> 2 ] = $43 ; $vararg_ptr5 = ( ( ( $vararg_buffer1 ) ) + 12 | 0 ) ; HEAP32 [ $vararg_ptr5 >> 2 ] = $44 ; FUNCTION_TABLE_vii [ $40 & 127 ] ( 19712 , $vararg_buffer1 ) ; $45 = ( 33584 ) ; $46 = $45 ; $47 = HEAP32 [ $46 >> 2 ] | 0 ; $48 = ( ( $45 ) + 4 ) | 0 ; $49 = $48 ; $50 = HEAP32 [ $49 >> 2 ] | 0 ; $51 = ( $50 >>> 0 ) > ( 0 ) ; $52 = ( $47 >>> 0 ) > ( 0 ) ; $53 = ( $50 | 0 ) == ( 0 ) ; $54 = $53 & $52 ; $55 = $51 | $54 ; if ( $55 ) { $56 = HEAP32 [ 8449 ] | 0 ; $57 = ( 33584 ) ; $58 = $57 ; $59 = HEAP32 [ $58 >> 2 ] | 0 ; $60 = ( ( $57 ) + 4 ) | 0 ; $61 = $60 ; $62 = HEAP32 [ $61 >> 2 ] | 0 ; $63 = $vararg_buffer7 ; $64 = $63 ; HEAP32 [ $64 >> 2 ] = $59 ; $65 = ( ( $63 ) + 4 ) | 0 ; $66 = $65 ; HEAP32 [ $66 >> 2 ] = $62 ; FUNCTION_TABLE_vii [ $56 & 127 ] ( 19748 , $vararg_buffer7 ) ; } $67 = HEAP32 [ 8449 ] | 0 ; FUNCTION_TABLE_vii [ $67 & 127 ] ( 17974 , $vararg_buffer11 ) ; STACKTOP = sp ; return ; } function _opng_check_idat_size ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = sp ; $3 = $2 ; $4 = $3 ; HEAP32 [ $4 >> 2 ] = $0 ; $5 = ( ( $3 ) + 4 ) | 0 ; $6 = $5 ; HEAP32 [ $6 >> 2 ] = $1 ; $7 = $2 ; $8 = $7 ; $9 = HEAP32 [ $8 >> 2 ] | 0 ; $10 = ( ( $7 ) + 4 ) | 0 ; $11 = $10 ; $12 = HEAP32 [ $11 >> 2 ] | 0 ; $13 = ( $12 >>> 0 ) > ( 0 ) ; $14 = ( $9 >>> 0 ) > ( 2147483647 ) ; $15 = ( $12 | 0 ) == ( 0 ) ; $16 = $15 & $14 ; $17 = $13 | $16 ; if ( $17 ) { HEAP32 [ ( 33792 ) >> 2 ] = 19616 ; $18 = HEAP32 [ 8446 ] | 0 ; _longjmp ( ( $18 | 0 ) , 1 ) ; // unreachable; } else { STACKTOP = sp ; return ; } } function _opng_write_file ( $0 , $1 , $2 , $3 , $4 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; $4 = $4 | 0 ; var $$reg2mem66$0 = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 ; var $117 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $30 = 0 ; var $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 ; var $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 ; var $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 ; var $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $cond = 0 , $cond70 = 0 , $cond71 = 0 , $cond72 = 0 , $cond73 = 0 , $cond74 = 0 ; var $cond75 = 0 , $cond76 = 0 , $cond77 = 0 , $cond78 = 0 , $cond79 = 0 , $cond80 = 0 , $cond81 = 0 , $cond82 = 0 , $cond83 = 0 , $cond84 = 0 , $cond85 = 0 , $or$cond = 0 , $or$cond11 = 0 , $or$cond13 = 0 , $or$cond15 = 0 , $or$cond3 = 0 , $or$cond5 = 0 , $or$cond7 = 0 , $or$cond9 = 0 , _setjmpTable = 0 ; var _setjmpTableSize = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 176 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 176 | 0 ) ; _setjmpTableSize = 4 ; _setjmpTable = _malloc ( 40 ) | 0 ; HEAP32 [ _setjmpTable >> 2 ] = 0 ; $7 = sp ; $8 = ( $1 | 0 ) >= ( 1 ) ; $9 = ( $1 | 0 ) <= ( 9 ) ; $or$cond = $8 & $9 ; $10 = ( $2 | 0 ) >= ( 1 ) ; $or$cond3 = $or$cond & $10 ; $11 = ( $2 | 0 ) <= ( 9 ) ; $or$cond5 = $or$cond3 & $11 ; $12 = ( $3 | 0 ) >= ( 0 ) ; $or$cond7 = $or$cond5 & $12 ; $13 = ( $3 | 0 ) <= ( 3 ) ; $or$cond9 = $or$cond7 & $13 ; $14 = ( $4 | 0 ) >= ( 0 ) ; $or$cond11 = $or$cond9 & $14 ; $15 = ( $4 | 0 ) <= ( 5 ) ; $or$cond13 = $or$cond11 & $15 ; if ( $or$cond13 ) { label = 4 ; } else { $16 = HEAP32 [ 8452 ] | 0 ; __THREW__ = 0 ; invoke_vi ( $16 | 0 , ( 19571 | 0 ) ) ; $17 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $17 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $18 = _testSetjmp ( HEAP32 [ $17 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $18 | 0 ) == 0 ) { _longjmp ( $17 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $18 = - 1 ; } ; $19 = tempRet0 ; $cond = ( $18 | 0 ) == ( 1 ) ; if ( $cond ) { $$reg2mem66$0 = $19 ; } else { label = 4 ; } } if ( ( label | 0 ) == 4 ) { $20 = HEAP32 [ 8446 ] | 0 ; $6 = $20 ; HEAP32 [ 8446 ] = $7 ; _setjmpTable = _saveSetjmp ( $7 , 1 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; _setjmpTableSize = tempRet0 ; __THREW__ = 0 ; $21 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $21 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $22 = _testSetjmp ( HEAP32 [ $21 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $22 | 0 ) == 0 ) { _longjmp ( $21 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $22 = - 1 ; } ; $23 = tempRet0 ; $cond85 = ( $22 | 0 ) == ( 1 ) ; if ( $cond85 ) { $$reg2mem66$0 = $23 ; } else { $$reg2mem66$0 = 0 ; } } L7 : while ( 1 ) { $24 = ( $$reg2mem66$0 | 0 ) == ( 0 ) ; L9 : do { if ( $24 ) { while ( 1 ) { __THREW__ = 0 ; $25 = ( invoke_iiiii ( 61 , ( 23589 | 0 ) , ( 0 | 0 ) , ( 44 | 0 ) , ( 45 | 0 ) ) | 0 ) ; $26 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $26 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $27 = _testSetjmp ( HEAP32 [ $26 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $27 | 0 ) == 0 ) { _longjmp ( $26 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $27 = - 1 ; } ; $28 = tempRet0 ; $cond71 = ( $27 | 0 ) == ( 1 ) ; if ( $cond71 ) { $$reg2mem66$0 = $28 ; continue L7 ; } HEAP32 [ 8516 ] = $25 ; $29 = HEAP32 [ 8516 ] | 0 ; __THREW__ = 0 ; $30 = ( invoke_ii ( 46 , ( $29 | 0 ) ) | 0 ) ; $31 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $31 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $32 = _testSetjmp ( HEAP32 [ $31 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $32 | 0 ) == 0 ) { _longjmp ( $31 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $32 = - 1 ; } ; $33 = tempRet0 ; $cond72 = ( $32 | 0 ) == ( 1 ) ; if ( $cond72 ) { $$reg2mem66$0 = $33 ; continue L7 ; } HEAP32 [ 8521 ] = $30 ; $34 = HEAP32 [ 8521 ] | 0 ; $35 = ( $34 | 0 ) == ( 0 | 0 ) ; if ( $35 ) { break ; } $40 = HEAP32 [ 8516 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 62 , ( $40 | 0 ) , ( $1 | 0 ) ) ; $41 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $41 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $42 = _testSetjmp ( HEAP32 [ $41 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $42 | 0 ) == 0 ) { _longjmp ( $41 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $42 = - 1 ; } ; $43 = tempRet0 ; $cond73 = ( $42 | 0 ) == ( 1 ) ; if ( $cond73 ) { $$reg2mem66$0 = $43 ; continue L7 ; } $44 = HEAP32 [ 8516 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 63 , ( $44 | 0 ) , ( $2 | 0 ) ) ; $45 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $45 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $46 = _testSetjmp ( HEAP32 [ $45 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $46 | 0 ) == 0 ) { _longjmp ( $45 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $46 = - 1 ; } ; $47 = tempRet0 ; $cond74 = ( $46 | 0 ) == ( 1 ) ; if ( $cond74 ) { $$reg2mem66$0 = $47 ; continue L7 ; } $48 = HEAP32 [ 8516 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 64 , ( $48 | 0 ) , ( $3 | 0 ) ) ; $49 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $49 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $50 = _testSetjmp ( HEAP32 [ $49 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $50 | 0 ) == 0 ) { _longjmp ( $49 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $50 = - 1 ; } ; $51 = tempRet0 ; $cond75 = ( $50 | 0 ) == ( 1 ) ; if ( $cond75 ) { $$reg2mem66$0 = $51 ; continue L7 ; } $52 = HEAP32 [ 8516 ] | 0 ; $53 = ( 8 + ( $4 << 2 ) | 0 ) ; $54 = HEAP32 [ $53 >> 2 ] | 0 ; __THREW__ = 0 ; invoke_viii ( 65 , ( $52 | 0 ) , 0 , ( $54 | 0 ) ) ; $55 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $55 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $56 = _testSetjmp ( HEAP32 [ $55 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $56 | 0 ) == 0 ) { _longjmp ( $55 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $56 = - 1 ; } ; $57 = tempRet0 ; $cond76 = ( $56 | 0 ) == ( 1 ) ; if ( $cond76 ) { $$reg2mem66$0 = $57 ; continue L7 ; } $58 = ( $3 | 0 ) != ( 2 ) ; $59 = ( $3 | 0 ) != ( 3 ) ; $or$cond15 = $58 & $59 ; if ( $or$cond15 ) { $60 = HEAP32 [ ( 33904 ) >> 2 ] | 0 ; $61 = ( $60 | 0 ) > ( 0 ) ; if ( $61 ) { $62 = HEAP32 [ 8516 ] | 0 ; $63 = HEAP32 [ ( 33904 ) >> 2 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 66 , ( $62 | 0 ) , ( $63 | 0 ) ) ; $64 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $64 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $65 = _testSetjmp ( HEAP32 [ $64 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $65 | 0 ) == 0 ) { _longjmp ( $64 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $65 = - 1 ; } ; $66 = tempRet0 ; $cond84 = ( $65 | 0 ) == ( 1 ) ; if ( $cond84 ) { $$reg2mem66$0 = $66 ; continue L7 ; } } } else { $67 = HEAP32 [ 8516 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 66 , ( $67 | 0 ) , 9 ) ; $68 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $68 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $69 = _testSetjmp ( HEAP32 [ $68 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $69 | 0 ) == 0 ) { _longjmp ( $68 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $69 = - 1 ; } ; $70 = tempRet0 ; $cond77 = ( $69 | 0 ) == ( 1 ) ; if ( $cond77 ) { $$reg2mem66$0 = $70 ; continue L7 ; } } $71 = HEAP32 [ 8516 ] | 0 ; __THREW__ = 0 ; invoke_viiii ( 47 , ( $71 | 0 ) , 3 , ( 0 | 0 ) , 0 ) ; $72 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $72 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $73 = _testSetjmp ( HEAP32 [ $72 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $73 | 0 ) == 0 ) { _longjmp ( $72 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $73 = - 1 ; } ; $74 = tempRet0 ; $cond78 = ( $73 | 0 ) == ( 1 ) ; if ( $cond78 ) { $$reg2mem66$0 = $74 ; continue L7 ; } $75 = HEAP32 [ 8516 ] | 0 ; __THREW__ = 0 ; invoke_viii ( 48 , ( $75 | 0 ) , 2147483647 , 2147483647 ) ; $76 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $76 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $77 = _testSetjmp ( HEAP32 [ $76 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $77 | 0 ) == 0 ) { _longjmp ( $76 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $77 = - 1 ; } ; $78 = tempRet0 ; $cond79 = ( $77 | 0 ) == ( 1 ) ; if ( $cond79 ) { $$reg2mem66$0 = $78 ; continue L7 ; } $79 = HEAP32 [ 8516 ] | 0 ; $80 = HEAP32 [ 8521 ] | 0 ; $81 = ( $0 | 0 ) != ( 0 | 0 ) ; $82 = $81 & 1 ; __THREW__ = 0 ; invoke_viii ( 67 , ( $79 | 0 ) , ( $80 | 0 ) , ( $82 | 0 ) ) ; $83 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $83 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $84 = _testSetjmp ( HEAP32 [ $83 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $84 | 0 ) == 0 ) { _longjmp ( $83 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $84 = - 1 ; } ; $85 = tempRet0 ; $cond80 = ( $84 | 0 ) == ( 1 ) ; if ( $cond80 ) { $$reg2mem66$0 = $85 ; continue L7 ; } __THREW__ = 0 ; invoke_v ( 68 ) ; $86 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $86 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $87 = _testSetjmp ( HEAP32 [ $86 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $87 | 0 ) == 0 ) { _longjmp ( $86 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $87 = - 1 ; } ; $88 = tempRet0 ; $cond81 = ( $87 | 0 ) == ( 1 ) ; if ( $cond81 ) { $$reg2mem66$0 = $88 ; continue L7 ; } $89 = HEAP32 [ 8516 ] | 0 ; __THREW__ = 0 ; invoke_viiii ( 69 , ( $89 | 0 ) , ( $0 | 0 ) , ( 70 | 0 ) , ( 0 | 0 ) ) ; $90 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $90 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $91 = _testSetjmp ( HEAP32 [ $90 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $91 | 0 ) == 0 ) { _longjmp ( $90 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $91 = - 1 ; } ; $92 = tempRet0 ; $cond82 = ( $91 | 0 ) == ( 1 ) ; if ( $cond82 ) { $$reg2mem66$0 = $92 ; continue L7 ; } $93 = HEAP32 [ 8516 ] | 0 ; $94 = HEAP32 [ 8521 ] | 0 ; __THREW__ = 0 ; invoke_viiii ( 71 , ( $93 | 0 ) , ( $94 | 0 ) , 0 , ( 0 | 0 ) ) ; $95 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $95 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $96 = _testSetjmp ( HEAP32 [ $95 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $96 | 0 ) == 0 ) { _longjmp ( $95 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $96 = - 1 ; } ; $97 = tempRet0 ; $cond83 = ( $96 | 0 ) == ( 1 ) ; if ( $cond83 ) { $$reg2mem66$0 = $97 ; continue L7 ; } $5 = 0 ; HEAP32 [ ( 33788 ) >> 2 ] = 0 ; $98 = HEAP32 [ ( 33788 ) >> 2 ] | 0 ; $99 = ( $98 | 0 ) != ( 0 ) ; if ( ! ( $99 ) ) { break L9 ; } } HEAP32 [ ( 33792 ) >> 2 ] = 24383 ; $36 = HEAP32 [ 8446 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 20 , ( $36 | 0 ) , 1 ) ; $37 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $37 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $38 = _testSetjmp ( HEAP32 [ $37 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $38 | 0 ) == 0 ) { _longjmp ( $37 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $38 = - 1 ; } ; $39 = tempRet0 ; $$reg2mem66$0 = $39 ; continue L7 ; } else { HEAP32 [ ( 33788 ) >> 2 ] = 1 ; } } while ( 0 ) ; $100 = $6 ; HEAP32 [ 8446 ] = $100 ; $101 = HEAP32 [ ( 33788 ) >> 2 ] | 0 ; $102 = ( $101 | 0 ) != ( 0 ) ; if ( $102 ) { $103 = HEAP32 [ ( 33792 ) >> 2 ] | 0 ; $5 = $103 ; $104 = ( 33576 ) ; $105 = $104 ; HEAP32 [ $105 >> 2 ] = - 2147483648 ; $106 = ( ( $104 ) + 4 ) | 0 ; $107 = $106 ; HEAP32 [ $107 >> 2 ] = 0 ; } __THREW__ = 0 ; invoke_vii ( 72 , ( 34064 | 0 ) , ( 34084 | 0 ) ) ; $108 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $108 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $109 = _testSetjmp ( HEAP32 [ $108 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $109 | 0 ) == 0 ) { _longjmp ( $108 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $109 = - 1 ; } ; $110 = tempRet0 ; $cond70 = ( $109 | 0 ) == ( 1 ) ; if ( $cond70 ) { $$reg2mem66$0 = $110 ; continue ; } $111 = $5 ; $112 = ( $111 | 0 ) != ( 0 | 0 ) ; if ( ! ( $112 ) ) { break ; } $113 = $5 ; HEAP32 [ ( 33792 ) >> 2 ] = $113 ; $114 = HEAP32 [ 8446 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 20 , ( $114 | 0 ) , 1 ) ; $115 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $115 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $116 = _testSetjmp ( HEAP32 [ $115 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $116 | 0 ) == 0 ) { _longjmp ( $115 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $116 = - 1 ; } ; $117 = tempRet0 ; $$reg2mem66$0 = $117 ; } _free ( _setjmpTable | 0 ) ; STACKTOP = sp ; return ; } function _opng_copy_file ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$0 = 0 , $$1 = 0 , $$2 = 0 , $$reg2mem60$0 = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 ; var $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 ; var $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 ; var $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 ; var $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 ; var $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 ; var $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $cond = 0 , $cond66 = 0 , $cond67 = 0 , $cond68 = 0 , $cond69 = 0 , $cond70 = 0 , $cond71 = 0 , $cond72 = 0 , $cond73 = 0 , $cond74 = 0 , $cond75 = 0 ; var $cond76 = 0 , $cond77 = 0 , $or$cond = 0 , _setjmpTable = 0 , _setjmpTableSize = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 176 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 176 | 0 ) ; _setjmpTableSize = 4 ; _setjmpTable = _malloc ( 40 ) | 0 ; HEAP32 [ _setjmpTable >> 2 ] = 0 ; $3 = sp + 168 | 0 ; $6 = sp ; __THREW__ = 0 ; $7 = ( invoke_iiiii ( 61 , ( 23589 | 0 ) , ( 0 | 0 ) , ( 44 | 0 ) , ( 45 | 0 ) ) | 0 ) ; $8 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $8 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $9 = _testSetjmp ( HEAP32 [ $8 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $9 | 0 ) == 0 ) { _longjmp ( $8 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $9 = - 1 ; } ; $10 = tempRet0 ; $cond = ( $9 | 0 ) == ( 1 ) ; do { if ( $cond ) { $$reg2mem60$0 = $10 ; } else { HEAP32 [ 8516 ] = $7 ; $11 = HEAP32 [ 8516 ] | 0 ; $12 = ( $11 | 0 ) == ( 0 | 0 ) ; if ( $12 ) { HEAP32 [ ( 33792 ) >> 2 ] = 24383 ; $13 = HEAP32 [ 8446 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 20 , ( $13 | 0 ) , 1 ) ; $14 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $14 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $15 = _testSetjmp ( HEAP32 [ $14 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $15 | 0 ) == 0 ) { _longjmp ( $14 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $15 = - 1 ; } ; $16 = tempRet0 ; $$reg2mem60$0 = $16 ; break ; } __THREW__ = 0 ; invoke_v ( 68 ) ; $17 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $17 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $18 = _testSetjmp ( HEAP32 [ $17 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $18 | 0 ) == 0 ) { _longjmp ( $17 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $18 = - 1 ; } ; $19 = tempRet0 ; $cond66 = ( $18 | 0 ) == ( 1 ) ; if ( $cond66 ) { $$reg2mem60$0 = $19 ; } else { $20 = HEAP32 [ 8516 ] | 0 ; __THREW__ = 0 ; invoke_viiii ( 69 , ( $20 | 0 ) , ( $1 | 0 ) , ( 70 | 0 ) , ( 0 | 0 ) ) ; $21 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $21 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $22 = _testSetjmp ( HEAP32 [ $21 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $22 | 0 ) == 0 ) { _longjmp ( $21 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $22 = - 1 ; } ; $23 = tempRet0 ; $cond67 = ( $22 | 0 ) == ( 1 ) ; if ( $cond67 ) { $$reg2mem60$0 = $23 ; } else { $24 = HEAP32 [ 8446 ] | 0 ; $5 = $24 ; HEAP32 [ 8446 ] = $6 ; _setjmpTable = _saveSetjmp ( $6 , 1 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; _setjmpTableSize = tempRet0 ; __THREW__ = 0 ; $25 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $25 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $26 = _testSetjmp ( HEAP32 [ $25 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $26 | 0 ) == 0 ) { _longjmp ( $25 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $26 = - 1 ; } ; $27 = tempRet0 ; $cond68 = ( $26 | 0 ) == ( 1 ) ; if ( $cond68 ) { $$reg2mem60$0 = $27 ; } else { $$reg2mem60$0 = 0 ; } } } } } while ( 0 ) ; L9 : while ( 1 ) { $28 = ( $$reg2mem60$0 | 0 ) == ( 0 ) ; L11 : do { if ( $28 ) { L12 : while ( 1 ) { $2 = 0 ; $29 = HEAP32 [ 8516 ] | 0 ; __THREW__ = 0 ; invoke_vi ( 73 , ( $29 | 0 ) ) ; $30 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $30 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $31 = _testSetjmp ( HEAP32 [ $30 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $31 | 0 ) == 0 ) { _longjmp ( $30 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $31 = - 1 ; } ; $32 = tempRet0 ; $cond71 = ( $31 | 0 ) == ( 1 ) ; if ( $cond71 ) { $$reg2mem60$0 = $32 ; continue L9 ; } $$0 = 0 ; while ( 1 ) { __THREW__ = 0 ; $33 = ( invoke_iiiii ( 74 , ( $3 | 0 ) , 8 , 1 , ( $0 | 0 ) ) | 0 ) ; $34 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $34 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $35 = _testSetjmp ( HEAP32 [ $34 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $35 | 0 ) == 0 ) { _longjmp ( $34 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $35 = - 1 ; } ; $36 = tempRet0 ; $cond72 = ( $35 | 0 ) == ( 1 ) ; if ( $cond72 ) { $$reg2mem60$0 = $36 ; continue L9 ; } $37 = ( $33 | 0 ) != ( 1 ) ; if ( $37 ) { label = 13 ; break L12 ; } $42 = HEAP8 [ $3 >> 0 ] | 0 ; $43 = $42 & 255 ; $44 = $43 << 24 ; $45 = ( ( ( $3 ) ) + 1 | 0 ) ; $46 = HEAP8 [ $45 >> 0 ] | 0 ; $47 = $46 & 255 ; $48 = $47 << 16 ; $49 = ( ( $44 ) + ( $48 ) ) | 0 ; $50 = ( ( ( $3 ) ) + 2 | 0 ) ; $51 = HEAP8 [ $50 >> 0 ] | 0 ; $52 = $51 & 255 ; $53 = $52 << 8 ; $54 = ( ( $49 ) + ( $53 ) ) | 0 ; $55 = ( ( ( $3 ) ) + 3 | 0 ) ; $56 = HEAP8 [ $55 >> 0 ] | 0 ; $57 = $56 & 255 ; $58 = ( ( $54 ) + ( $57 ) ) | 0 ; $59 = ( $58 >>> 0 ) > ( 2147483647 ) ; if ( $59 ) { $60 = $2 ; $61 = ( $60 | 0 ) == ( 0 | 0 ) ; $62 = ( $58 | 0 ) == ( - 1991225785 ) ; $or$cond = $61 & $62 ; if ( $or$cond ) { $$2 = $$0 ; } else { label = 16 ; break L12 ; } } else { $67 = ( ( $58 ) + 4 ) | 0 ; $68 = ( $67 >>> 0 ) > ( $$0 >>> 0 ) ; if ( $68 ) { $69 = HEAP32 [ 8516 ] | 0 ; $70 = $2 ; __THREW__ = 0 ; invoke_vii ( 75 , ( $69 | 0 ) , ( $70 | 0 ) ) ; $71 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $71 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $72 = _testSetjmp ( HEAP32 [ $71 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $72 | 0 ) == 0 ) { _longjmp ( $71 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $72 = - 1 ; } ; $73 = tempRet0 ; $cond76 = ( $72 | 0 ) == ( 1 ) ; if ( $cond76 ) { $$reg2mem60$0 = $73 ; continue L9 ; } $74 = ( ( $58 ) + 4 ) | 0 ; $75 = ( ( $74 ) + 4095 ) | 0 ; $76 = ( ( $75 >>> 0 ) / 4096 ) & - 1 ; $77 = $76 << 12 ; $78 = HEAP32 [ 8516 ] | 0 ; __THREW__ = 0 ; $79 = ( invoke_iii ( 76 , ( $78 | 0 ) , ( $77 | 0 ) ) | 0 ) ; $80 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $80 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $81 = _testSetjmp ( HEAP32 [ $80 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $81 | 0 ) == 0 ) { _longjmp ( $80 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $81 = - 1 ; } ; $82 = tempRet0 ; $cond77 = ( $81 | 0 ) == ( 1 ) ; if ( $cond77 ) { $$reg2mem60$0 = $82 ; continue L9 ; } $2 = $79 ; $$1 = $77 ; } else { $$1 = $$0 ; } $83 = $2 ; $84 = ( ( $58 ) + 4 ) | 0 ; __THREW__ = 0 ; $85 = ( invoke_iiiii ( 74 , ( $83 | 0 ) , ( $84 | 0 ) , 1 , ( $0 | 0 ) ) | 0 ) ; $86 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $86 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $87 = _testSetjmp ( HEAP32 [ $86 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $87 | 0 ) == 0 ) { _longjmp ( $86 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $87 = - 1 ; } ; $88 = tempRet0 ; $cond73 = ( $87 | 0 ) == ( 1 ) ; if ( $cond73 ) { $$reg2mem60$0 = $88 ; continue L9 ; } $89 = ( $85 | 0 ) != ( 1 ) ; if ( $89 ) { label = 23 ; break L12 ; } $94 = HEAP32 [ 8516 ] | 0 ; $95 = ( ( ( $3 ) ) + 4 | 0 ) ; $96 = $2 ; __THREW__ = 0 ; invoke_viiii ( 77 , ( $94 | 0 ) , ( $95 | 0 ) , ( $96 | 0 ) , ( $58 | 0 ) ) ; $97 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $97 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $98 = _testSetjmp ( HEAP32 [ $97 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $98 | 0 ) == 0 ) { _longjmp ( $97 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $98 = - 1 ; } ; $99 = tempRet0 ; $cond74 = ( $98 | 0 ) == ( 1 ) ; if ( $cond74 ) { $$reg2mem60$0 = $99 ; continue L9 ; } $$2 = $$1 ; } $100 = ( ( ( $3 ) ) + 4 | 0 ) ; __THREW__ = 0 ; $101 = ( invoke_iiii ( 78 , ( $100 | 0 ) , ( 19342 | 0 ) , 4 ) | 0 ) ; $102 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $102 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $103 = _testSetjmp ( HEAP32 [ $102 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $103 | 0 ) == 0 ) { _longjmp ( $102 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $103 = - 1 ; } ; $104 = tempRet0 ; $cond75 = ( $103 | 0 ) == ( 1 ) ; if ( $cond75 ) { $$reg2mem60$0 = $104 ; continue L9 ; } $105 = ( $101 | 0 ) != ( 0 ) ; if ( $105 ) { $$0 = $$2 ; } else { break ; } } $4 = 0 ; HEAP32 [ ( 33788 ) >> 2 ] = 0 ; $106 = HEAP32 [ ( 33788 ) >> 2 ] | 0 ; $107 = ( $106 | 0 ) != ( 0 ) ; if ( ! ( $107 ) ) { break L11 ; } } if ( ( label | 0 ) == 13 ) { label = 0 ; HEAP32 [ ( 33792 ) >> 2 ] = 19320 ; $38 = HEAP32 [ 8446 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 20 , ( $38 | 0 ) , 1 ) ; $39 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $39 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $40 = _testSetjmp ( HEAP32 [ $39 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $40 | 0 ) == 0 ) { _longjmp ( $39 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $40 = - 1 ; } ; $41 = tempRet0 ; $$reg2mem60$0 = $41 ; continue L9 ; } else if ( ( label | 0 ) == 16 ) { label = 0 ; HEAP32 [ ( 33792 ) >> 2 ] = 19331 ; $63 = HEAP32 [ 8446 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 20 , ( $63 | 0 ) , 1 ) ; $64 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $64 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $65 = _testSetjmp ( HEAP32 [ $64 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $65 | 0 ) == 0 ) { _longjmp ( $64 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $65 = - 1 ; } ; $66 = tempRet0 ; $$reg2mem60$0 = $66 ; continue L9 ; } else if ( ( label | 0 ) == 23 ) { label = 0 ; HEAP32 [ ( 33792 ) >> 2 ] = 19320 ; $90 = HEAP32 [ 8446 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 20 , ( $90 | 0 ) , 1 ) ; $91 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $91 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $92 = _testSetjmp ( HEAP32 [ $91 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $92 | 0 ) == 0 ) { _longjmp ( $91 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $92 = - 1 ; } ; $93 = tempRet0 ; $$reg2mem60$0 = $93 ; continue L9 ; } } else { HEAP32 [ ( 33788 ) >> 2 ] = 1 ; } } while ( 0 ) ; $108 = $5 ; HEAP32 [ 8446 ] = $108 ; $109 = HEAP32 [ ( 33788 ) >> 2 ] | 0 ; $110 = ( $109 | 0 ) != ( 0 ) ; if ( $110 ) { $111 = HEAP32 [ ( 33792 ) >> 2 ] | 0 ; $4 = $111 ; } $112 = HEAP32 [ 8516 ] | 0 ; $113 = $2 ; __THREW__ = 0 ; invoke_vii ( 75 , ( $112 | 0 ) , ( $113 | 0 ) ) ; $114 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $114 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $115 = _testSetjmp ( HEAP32 [ $114 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $115 | 0 ) == 0 ) { _longjmp ( $114 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $115 = - 1 ; } ; $116 = tempRet0 ; $cond69 = ( $115 | 0 ) == ( 1 ) ; if ( $cond69 ) { $$reg2mem60$0 = $116 ; continue ; } __THREW__ = 0 ; invoke_vii ( 72 , ( 34064 | 0 ) , ( 0 | 0 ) ) ; $117 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $117 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $118 = _testSetjmp ( HEAP32 [ $117 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $118 | 0 ) == 0 ) { _longjmp ( $117 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $118 = - 1 ; } ; $119 = tempRet0 ; $cond70 = ( $118 | 0 ) == ( 1 ) ; if ( $cond70 ) { $$reg2mem60$0 = $119 ; continue ; } $120 = $4 ; $121 = ( $120 | 0 ) != ( 0 | 0 ) ; if ( ! ( $121 ) ) { break ; } $122 = $4 ; HEAP32 [ ( 33792 ) >> 2 ] = $122 ; $123 = HEAP32 [ 8446 ] | 0 ; __THREW__ = 0 ; invoke_vii ( 20 , ( $123 | 0 ) , 1 ) ; $124 = __THREW__ ; __THREW__ = 0 ; if ( ( ( $124 | 0 ) != 0 ) & ( ( threwValue | 0 ) != 0 ) ) { $125 = _testSetjmp ( HEAP32 [ $124 >> 2 ] | 0 , _setjmpTable | 0 , _setjmpTableSize | 0 ) | 0 ; if ( ( $125 | 0 ) == 0 ) { _longjmp ( $124 | 0 , threwValue | 0 ) ; } tempRet0 = ( threwValue ) ; } else { $125 = - 1 ; } ; $126 = tempRet0 ; $$reg2mem60$0 = $126 ; } _free ( _setjmpTable | 0 ) ; STACKTOP = sp ; return ; } function _opng_print_warning ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $vararg_buffer = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $vararg_buffer = sp ; $1 = $0 ; $2 = HEAP32 [ 8450 ] | 0 ; FUNCTION_TABLE_vi [ $2 & 127 ] ( 11 ) ; $3 = HEAP32 [ 8449 ] | 0 ; $4 = $1 ; HEAP32 [ $vararg_buffer >> 2 ] = $4 ; FUNCTION_TABLE_vii [ $3 & 127 ] ( 19307 , $vararg_buffer ) ; STACKTOP = sp ; return ; } function _opng_print_fsize_difference ( $0 , $1 , $2 , $3 , $4 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; $4 = $4 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 ; var $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 ; var $39 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 ; var $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 ; var $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 ; var $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $or$cond = 0 , $vararg_buffer = 0 , $vararg_buffer11 = 0 , $vararg_buffer2 = 0 , $vararg_buffer5 = 0 , $vararg_buffer8 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 80 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 80 | 0 ) ; $vararg_buffer11 = sp + 56 | 0 ; $vararg_buffer8 = sp + 48 | 0 ; $vararg_buffer5 = sp + 40 | 0 ; $vararg_buffer2 = sp + 32 | 0 ; $vararg_buffer = sp + 24 | 0 ; $5 = sp + 16 | 0 ; $6 = sp + 8 | 0 ; $8 = sp ; $10 = $5 ; $11 = $10 ; HEAP32 [ $11 >> 2 ] = $0 ; $12 = ( ( $10 ) + 4 ) | 0 ; $13 = $12 ; HEAP32 [ $13 >> 2 ] = $1 ; $14 = $6 ; $15 = $14 ; HEAP32 [ $15 >> 2 ] = $2 ; $16 = ( ( $14 ) + 4 ) | 0 ; $17 = $16 ; HEAP32 [ $17 >> 2 ] = $3 ; $7 = $4 ; $18 = $5 ; $19 = $18 ; $20 = HEAP32 [ $19 >> 2 ] | 0 ; $21 = ( ( $18 ) + 4 ) | 0 ; $22 = $21 ; $23 = HEAP32 [ $22 >> 2 ] | 0 ; $24 = $6 ; $25 = $24 ; $26 = HEAP32 [ $25 >> 2 ] | 0 ; $27 = ( ( $24 ) + 4 ) | 0 ; $28 = $27 ; $29 = HEAP32 [ $28 >> 2 ] | 0 ; $30 = ( $23 >>> 0 ) < ( $29 >>> 0 ) ; $31 = ( $20 >>> 0 ) <= ( $26 >>> 0 ) ; $32 = ( $23 | 0 ) == ( $29 | 0 ) ; $33 = $32 & $31 ; $34 = $30 | $33 ; if ( $34 ) { $9 = 0 ; $35 = $6 ; $36 = $35 ; $37 = HEAP32 [ $36 >> 2 ] | 0 ; $38 = ( ( $35 ) + 4 ) | 0 ; $39 = $38 ; $40 = HEAP32 [ $39 >> 2 ] | 0 ; $41 = $5 ; $42 = $41 ; $43 = HEAP32 [ $42 >> 2 ] | 0 ; $44 = ( ( $41 ) + 4 ) | 0 ; $45 = $44 ; $46 = HEAP32 [ $45 >> 2 ] | 0 ; $47 = ( _i64Subtract ( ( $37 | 0 ) , ( $40 | 0 ) , ( $43 | 0 ) , ( $46 | 0 ) ) | 0 ) ; $48 = tempRet0 ; $49 = $8 ; $50 = $49 ; HEAP32 [ $50 >> 2 ] = $47 ; $51 = ( ( $49 ) + 4 ) | 0 ; $52 = $51 ; HEAP32 [ $52 >> 2 ] = $48 ; } else { $9 = 1 ; $53 = $5 ; $54 = $53 ; $55 = HEAP32 [ $54 >> 2 ] | 0 ; $56 = ( ( $53 ) + 4 ) | 0 ; $57 = $56 ; $58 = HEAP32 [ $57 >> 2 ] | 0 ; $59 = $6 ; $60 = $59 ; $61 = HEAP32 [ $60 >> 2 ] | 0 ; $62 = ( ( $59 ) + 4 ) | 0 ; $63 = $62 ; $64 = HEAP32 [ $63 >> 2 ] | 0 ; $65 = ( _i64Subtract ( ( $55 | 0 ) , ( $58 | 0 ) , ( $61 | 0 ) , ( $64 | 0 ) ) | 0 ) ; $66 = tempRet0 ; $67 = $8 ; $68 = $67 ; HEAP32 [ $68 >> 2 ] = $65 ; $69 = ( ( $67 ) + 4 ) | 0 ; $70 = $69 ; HEAP32 [ $70 >> 2 ] = $66 ; } $71 = $8 ; $72 = $71 ; $73 = HEAP32 [ $72 >> 2 ] | 0 ; $74 = ( ( $71 ) + 4 ) | 0 ; $75 = $74 ; $76 = HEAP32 [ $75 >> 2 ] | 0 ; $77 = ( $73 | 0 ) == ( 0 ) ; $78 = ( $76 | 0 ) == ( 0 ) ; $79 = $77 & $78 ; if ( $79 ) { $80 = HEAP32 [ 8449 ] | 0 ; FUNCTION_TABLE_vii [ $80 & 127 ] ( 19246 , $vararg_buffer ) ; STACKTOP = sp ; return ; } $81 = $8 ; $82 = $81 ; $83 = HEAP32 [ $82 >> 2 ] | 0 ; $84 = ( ( $81 ) + 4 ) | 0 ; $85 = $84 ; $86 = HEAP32 [ $85 >> 2 ] | 0 ; $87 = ( $83 | 0 ) == ( 1 ) ; $88 = ( $86 | 0 ) == ( 0 ) ; $89 = $87 & $88 ; $90 = HEAP32 [ 8449 ] | 0 ; if ( $89 ) { FUNCTION_TABLE_vii [ $90 & 127 ] ( 19256 , $vararg_buffer2 ) ; } else { $91 = $8 ; $92 = $91 ; $93 = HEAP32 [ $92 >> 2 ] | 0 ; $94 = ( ( $91 ) + 4 ) | 0 ; $95 = $94 ; $96 = HEAP32 [ $95 >> 2 ] | 0 ; $97 = $vararg_buffer5 ; $98 = $97 ; HEAP32 [ $98 >> 2 ] = $93 ; $99 = ( ( $97 ) + 4 ) | 0 ; $100 = $99 ; HEAP32 [ $100 >> 2 ] = $96 ; FUNCTION_TABLE_vii [ $90 & 127 ] ( 19263 , $vararg_buffer5 ) ; } $101 = $7 ; $102 = ( $101 | 0 ) != ( 0 ) ; $103 = $5 ; $104 = $103 ; $105 = HEAP32 [ $104 >> 2 ] | 0 ; $106 = ( ( $103 ) + 4 ) | 0 ; $107 = $106 ; $108 = HEAP32 [ $107 >> 2 ] | 0 ; $109 = ( $108 >>> 0 ) > ( 0 ) ; $110 = ( $105 >>> 0 ) > ( 0 ) ; $111 = ( $108 | 0 ) == ( 0 ) ; $112 = $111 & $110 ; $113 = $109 | $112 ; $or$cond = $102 & $113 ; if ( $or$cond ) { $114 = HEAP32 [ 8449 ] | 0 ; FUNCTION_TABLE_vii [ $114 & 127 ] ( 19274 , $vararg_buffer8 ) ; $115 = $8 ; $116 = $115 ; $117 = HEAP32 [ $116 >> 2 ] | 0 ; $118 = ( ( $115 ) + 4 ) | 0 ; $119 = $118 ; $120 = HEAP32 [ $119 >> 2 ] | 0 ; $121 = $5 ; $122 = $121 ; $123 = HEAP32 [ $122 >> 2 ] | 0 ; $124 = ( ( $121 ) + 4 ) | 0 ; $125 = $124 ; $126 = HEAP32 [ $125 >> 2 ] | 0 ; _opng_print_fsize_ratio ( $117 , $120 , $123 , $126 ) ; } $127 = HEAP32 [ 8449 ] | 0 ; $128 = $9 ; $129 = ( $128 | 0 ) == ( 0 ) ; $130 = $129 ? 19278 : 19288 ; FUNCTION_TABLE_vii [ $127 & 127 ] ( $130 , $vararg_buffer11 ) ; STACKTOP = sp ; return ; } function _opng_print_fsize_ratio ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $vararg_buffer = 0 ; var $vararg_ptr1 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 80 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 80 | 0 ) ; $vararg_buffer = sp + 32 | 0 ; $4 = sp + 24 | 0 ; $5 = sp + 16 | 0 ; $6 = sp + 48 | 0 ; $7 = sp ; $9 = $4 ; $10 = $9 ; HEAP32 [ $10 >> 2 ] = $0 ; $11 = ( ( $9 ) + 4 ) | 0 ; $12 = $11 ; HEAP32 [ $12 >> 2 ] = $1 ; $13 = $5 ; $14 = $13 ; HEAP32 [ $14 >> 2 ] = $2 ; $15 = ( ( $13 ) + 4 ) | 0 ; $16 = $15 ; HEAP32 [ $16 >> 2 ] = $3 ; $17 = $4 ; $18 = $17 ; $19 = HEAP32 [ $18 >> 2 ] | 0 ; $20 = ( ( $17 ) + 4 ) | 0 ; $21 = $20 ; $22 = HEAP32 [ $21 >> 2 ] | 0 ; $23 = $7 ; $24 = $23 ; HEAP32 [ $24 >> 2 ] = $19 ; $25 = ( ( $23 ) + 4 ) | 0 ; $26 = $25 ; HEAP32 [ $26 >> 2 ] = $22 ; $27 = $5 ; $28 = $27 ; $29 = HEAP32 [ $28 >> 2 ] | 0 ; $30 = ( ( $27 ) + 4 ) | 0 ; $31 = $30 ; $32 = HEAP32 [ $31 >> 2 ] | 0 ; $33 = ( ( ( $7 ) ) + 8 | 0 ) ; $34 = $33 ; $35 = $34 ; HEAP32 [ $35 >> 2 ] = $29 ; $36 = ( ( $34 ) + 4 ) | 0 ; $37 = $36 ; HEAP32 [ $37 >> 2 ] = $32 ; $38 = ( _opng_ullratio_to_factor_string ( $6 , 32 , $7 ) | 0 ) ; $8 = $38 ; $39 = HEAP32 [ 8449 ] | 0 ; $40 = $8 ; $41 = ( $40 | 0 ) > ( 0 ) ; $42 = $41 ? 100296 : 19298 ; HEAP32 [ $vararg_buffer >> 2 ] = $6 ; $vararg_ptr1 = ( ( ( $vararg_buffer ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr1 >> 2 ] = $42 ; FUNCTION_TABLE_vii [ $39 & 127 ] ( 19302 , $vararg_buffer ) ; STACKTOP = sp ; return ; } function _opng_error ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = $0 ; $3 = $1 ; $4 = $2 ; $5 = HEAP32 [ 8520 ] | 0 ; $6 = ( $4 | 0 ) == ( $5 | 0 ) ; if ( $6 ) { $7 = HEAP32 [ 8384 ] | 0 ; $8 = $7 | 8448 ; HEAP32 [ 8384 ] = $8 ; } $9 = $3 ; HEAP32 [ ( 33792 ) >> 2 ] = $9 ; $10 = HEAP32 [ 8446 ] | 0 ; _longjmp ( ( $10 | 0 ) , 1 ) ; // unreachable; } function _opng_warning ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = $0 ; $3 = $1 ; $4 = $2 ; $5 = HEAP32 [ 8520 ] | 0 ; $6 = ( $4 | 0 ) == ( $5 | 0 ) ; if ( $6 ) { $7 = HEAP32 [ 8384 ] | 0 ; $8 = $7 | 8448 ; HEAP32 [ 8384 ] = $8 ; } $9 = $3 ; _opng_print_warning ( $9 ) ; STACKTOP = sp ; return ; } function _opng_init_write_data ( ) { var $0 = 0 , $1 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $0 = ( 33560 ) ; $1 = $0 ; HEAP32 [ $1 >> 2 ] = 0 ; $2 = ( ( $0 ) + 4 ) | 0 ; $3 = $2 ; HEAP32 [ $3 >> 2 ] = 0 ; HEAP32 [ ( 33604 ) >> 2 ] = 0 ; $4 = ( 33576 ) ; $5 = $4 ; HEAP32 [ $5 >> 2 ] = 0 ; $6 = ( ( $4 ) + 4 ) | 0 ; $7 = $6 ; HEAP32 [ $7 >> 2 ] = 0 ; return ; } function _opng_write_data ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 ; var $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 ; var $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 ; var $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 ; var $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 , $208 = 0 ; var $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 , $226 = 0 ; var $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 , $244 = 0 ; var $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 , $258 = 0 , $259 = 0 , $26 = 0 , $260 = 0 , $261 = 0 , $262 = 0 ; var $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 , $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 , $270 = 0 , $271 = 0 , $272 = 0 , $273 = 0 , $274 = 0 , $275 = 0 , $276 = 0 , $277 = 0 , $278 = 0 , $279 = 0 , $28 = 0 , $29 = 0 ; var $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 ; var $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 ; var $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 ; var $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $or$cond = 0 , $or$cond3 = 0 , $or$cond5 = 0 ; var label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $10 = sp + 28 | 0 ; $3 = $0 ; $4 = $1 ; $5 = $2 ; $11 = $3 ; $12 = ( _png_get_io_ptr ( $11 ) | 0 ) ; $6 = $12 ; $13 = $3 ; $14 = ( _png_get_io_state ( $13 ) | 0 ) ; $7 = $14 ; $15 = $7 ; $16 = $15 & 240 ; $8 = $16 ; $17 = $7 ; $18 = $17 & 2 ; $19 = ( $18 | 0 ) != ( 0 ) ; $20 = $8 ; $21 = ( $20 | 0 ) != ( 0 ) ; $or$cond = $19 & $21 ; if ( ! ( $or$cond ) ) { $22 = HEAP32 [ 8452 ] | 0 ; FUNCTION_TABLE_vi [ $22 & 127 ] ( 19346 ) ; } $23 = $8 ; $24 = ( $23 | 0 ) == ( 32 ) ; do { if ( $24 ) { $25 = $5 ; $26 = ( $25 | 0 ) == ( 8 ) ; if ( ! ( $26 ) ) { $27 = HEAP32 [ 8452 ] | 0 ; FUNCTION_TABLE_vi [ $27 & 127 ] ( 19382 ) ; } $28 = $4 ; $29 = ( ( ( $28 ) ) + 4 | 0 ) ; $9 = $29 ; $30 = $9 ; $31 = ( _opng_allow_chunk ( $30 ) | 0 ) ; HEAP32 [ 8517 ] = $31 ; $32 = $9 ; $33 = ( _memcmp ( $32 , 19422 , 4 ) | 0 ) ; $34 = ( $33 | 0 ) == ( 0 ) ; if ( $34 ) { HEAP32 [ 8518 ] = 1 ; $35 = $4 ; $36 = HEAP8 [ $35 >> 0 ] | 0 ; $37 = $36 & 255 ; $38 = $37 << 24 ; $39 = $4 ; $40 = ( ( ( $39 ) ) + 1 | 0 ) ; $41 = HEAP8 [ $40 >> 0 ] | 0 ; $42 = $41 & 255 ; $43 = $42 << 16 ; $44 = ( ( $38 ) + ( $43 ) ) | 0 ; $45 = $4 ; $46 = ( ( ( $45 ) ) + 2 | 0 ) ; $47 = HEAP8 [ $46 >> 0 ] | 0 ; $48 = $47 & 255 ; $49 = $48 << 8 ; $50 = ( ( $44 ) + ( $49 ) ) | 0 ; $51 = $4 ; $52 = ( ( ( $51 ) ) + 3 | 0 ) ; $53 = HEAP8 [ $52 >> 0 ] | 0 ; $54 = $53 & 255 ; $55 = ( ( $50 ) + ( $54 ) ) | 0 ; $56 = ( 33576 ) ; $57 = $56 ; $58 = HEAP32 [ $57 >> 2 ] | 0 ; $59 = ( ( $56 ) + 4 ) | 0 ; $60 = $59 ; $61 = HEAP32 [ $60 >> 2 ] | 0 ; $62 = ( _i64Add ( ( $58 | 0 ) , ( $61 | 0 ) , ( $55 | 0 ) , 0 ) | 0 ) ; $63 = tempRet0 ; $64 = ( 33576 ) ; $65 = $64 ; HEAP32 [ $65 >> 2 ] = $62 ; $66 = ( ( $64 ) + 4 ) | 0 ; $67 = $66 ; HEAP32 [ $67 >> 2 ] = $63 ; $68 = $6 ; $69 = ( $68 | 0 ) == ( 0 | 0 ) ; if ( ! ( $69 ) ) { break ; } $70 = ( 33576 ) ; $71 = $70 ; $72 = HEAP32 [ $71 >> 2 ] | 0 ; $73 = ( ( $70 ) + 4 ) | 0 ; $74 = $73 ; $75 = HEAP32 [ $74 >> 2 ] | 0 ; $76 = ( 33592 ) ; $77 = $76 ; $78 = HEAP32 [ $77 >> 2 ] | 0 ; $79 = ( ( $76 ) + 4 ) | 0 ; $80 = $79 ; $81 = HEAP32 [ $80 >> 2 ] | 0 ; $82 = ( $75 >>> 0 ) > ( $81 >>> 0 ) ; $83 = ( $72 >>> 0 ) > ( $78 >>> 0 ) ; $84 = ( $75 | 0 ) == ( $81 | 0 ) ; $85 = $84 & $83 ; $86 = $82 | $85 ; if ( ! ( $86 ) ) { break ; } HEAP32 [ ( 33792 ) >> 2 ] = 0 ; $87 = HEAP32 [ 8446 ] | 0 ; _longjmp ( ( $87 | 0 ) , 1 ) ; // unreachable; } else { HEAP32 [ 8518 ] = 0 ; $88 = $9 ; $89 = ( _memcmp ( $88 , 19426 , 4 ) | 0 ) ; $90 = ( $89 | 0 ) == ( 0 ) ; if ( ! ( $90 ) ) { $91 = $9 ; $92 = ( _memcmp ( $91 , 19430 , 4 ) | 0 ) ; $93 = ( $92 | 0 ) == ( 0 ) ; if ( ! ( $93 ) ) { break ; } } $94 = $4 ; $95 = HEAP8 [ $94 >> 0 ] | 0 ; $96 = $95 & 255 ; $97 = $96 << 24 ; $98 = $4 ; $99 = ( ( ( $98 ) ) + 1 | 0 ) ; $100 = HEAP8 [ $99 >> 0 ] | 0 ; $101 = $100 & 255 ; $102 = $101 << 16 ; $103 = ( ( $97 ) + ( $102 ) ) | 0 ; $104 = $4 ; $105 = ( ( ( $104 ) ) + 2 | 0 ) ; $106 = HEAP8 [ $105 >> 0 ] | 0 ; $107 = $106 & 255 ; $108 = $107 << 8 ; $109 = ( ( $103 ) + ( $108 ) ) | 0 ; $110 = $4 ; $111 = ( ( ( $110 ) ) + 3 | 0 ) ; $112 = HEAP8 [ $111 >> 0 ] | 0 ; $113 = $112 & 255 ; $114 = ( ( $109 ) + ( $113 ) ) | 0 ; $115 = ( ( $114 ) + 12 ) | 0 ; $116 = HEAP32 [ ( 33604 ) >> 2 ] | 0 ; $117 = ( ( $116 ) + ( $115 ) ) | 0 ; HEAP32 [ ( 33604 ) >> 2 ] = $117 ; break ; } } else { $118 = $8 ; $119 = ( $118 | 0 ) != ( 128 ) ; $120 = $5 ; $121 = ( $120 | 0 ) == ( 4 ) ; $or$cond5 = $119 | $121 ; if ( ! ( $or$cond5 ) ) { $122 = HEAP32 [ 8452 ] | 0 ; FUNCTION_TABLE_vi [ $122 & 127 ] ( 19434 ) ; } } } while ( 0 ) ; $123 = $6 ; $124 = ( $123 | 0 ) == ( 0 | 0 ) ; if ( $124 ) { STACKTOP = sp ; return ; } $125 = $8 ; $126 = ( $125 | 0 ) == ( 16 ) ; $127 = HEAP32 [ 8517 ] | 0 ; $128 = ( $127 | 0 ) != ( 0 ) ; $or$cond3 = $126 | $128 ; if ( ! ( $or$cond3 ) ) { STACKTOP = sp ; return ; } $129 = $8 ; L26 : do { switch ( $129 | 0 ) { case 32 : { $130 = HEAP32 [ 8518 ] | 0 ; $131 = ( $130 | 0 ) != ( 0 ) ; $132 = 33648 ; $133 = $132 ; $134 = HEAP32 [ $133 >> 2 ] | 0 ; $135 = ( ( $132 ) + 4 ) | 0 ; $136 = $135 ; $137 = HEAP32 [ $136 >> 2 ] | 0 ; if ( $131 ) { $138 = ( $134 | 0 ) == ( 0 ) ; $139 = ( $137 | 0 ) == ( 0 ) ; $140 = $138 & $139 ; if ( $140 ) { $141 = $6 ; $142 = ( _opng_ftello ( $141 ) | 0 ) ; $143 = tempRet0 ; $144 = 33648 ; $145 = $144 ; HEAP32 [ $145 >> 2 ] = $142 ; $146 = ( ( $144 ) + 4 ) | 0 ; $147 = $146 ; HEAP32 [ $147 >> 2 ] = $143 ; $148 = ( 33584 ) ; $149 = $148 ; $150 = HEAP32 [ $149 >> 2 ] | 0 ; $151 = ( ( $148 ) + 4 ) | 0 ; $152 = $151 ; $153 = HEAP32 [ $152 >> 2 ] | 0 ; $154 = ( $153 >>> 0 ) > ( 0 ) ; $155 = ( $150 >>> 0 ) > ( 0 ) ; $156 = ( $153 | 0 ) == ( 0 ) ; $157 = $156 & $155 ; $158 = $154 | $157 ; $159 = $5 ; $160 = ( 33584 ) ; $161 = $160 ; $162 = HEAP32 [ $161 >> 2 ] | 0 ; $163 = ( ( $160 ) + 4 ) | 0 ; $164 = $163 ; $165 = HEAP32 [ $164 >> 2 ] | 0 ; $166 = $158 ? $162 : $159 ; $167 = $158 ? $165 : 0 ; $168 = 33656 ; $169 = $168 ; HEAP32 [ $169 >> 2 ] = $166 ; $170 = ( ( $168 ) + 4 ) | 0 ; $171 = $170 ; HEAP32 [ $171 >> 2 ] = $167 ; $172 = $4 ; $173 = 33656 ; $174 = $173 ; $175 = HEAP32 [ $174 >> 2 ] | 0 ; $176 = ( ( $173 ) + 4 ) | 0 ; $177 = $176 ; $178 = HEAP32 [ $177 >> 2 ] | 0 ; _png_save_uint_32 ( $172 , $175 ) ; $179 = ( _crc32 ( 0 , 19422 , 4 ) | 0 ) ; HEAP32 [ 8519 ] = $179 ; break L26 ; } else { STACKTOP = sp ; return ; } } $180 = ( $134 | 0 ) != ( 0 ) ; $181 = ( $137 | 0 ) != ( 0 ) ; $182 = $180 | $181 ; if ( $182 ) { $183 = HEAP32 [ 8519 ] | 0 ; _png_save_uint_32 ( $10 , $183 ) ; $184 = $6 ; $185 = ( _fwrite ( $10 , 1 , 4 , $184 ) | 0 ) ; $186 = ( $185 | 0 ) != ( 4 ) ; if ( $186 ) { $7 = 0 ; } $187 = ( 33560 ) ; $188 = $187 ; $189 = HEAP32 [ $188 >> 2 ] | 0 ; $190 = ( ( $187 ) + 4 ) | 0 ; $191 = $190 ; $192 = HEAP32 [ $191 >> 2 ] | 0 ; $193 = ( _i64Add ( ( $189 | 0 ) , ( $192 | 0 ) , 4 , 0 ) | 0 ) ; $194 = tempRet0 ; $195 = ( 33560 ) ; $196 = $195 ; HEAP32 [ $196 >> 2 ] = $193 ; $197 = ( ( $195 ) + 4 ) | 0 ; $198 = $197 ; HEAP32 [ $198 >> 2 ] = $194 ; $199 = ( 33576 ) ; $200 = $199 ; $201 = HEAP32 [ $200 >> 2 ] | 0 ; $202 = ( ( $199 ) + 4 ) | 0 ; $203 = $202 ; $204 = HEAP32 [ $203 >> 2 ] | 0 ; $205 = 33656 ; $206 = $205 ; $207 = HEAP32 [ $206 >> 2 ] | 0 ; $208 = ( ( $205 ) + 4 ) | 0 ; $209 = $208 ; $210 = HEAP32 [ $209 >> 2 ] | 0 ; $211 = ( $201 | 0 ) != ( $207 | 0 ) ; $212 = ( $204 | 0 ) != ( $210 | 0 ) ; $213 = $211 | $212 ; if ( $213 ) { $214 = ( 33584 ) ; $215 = $214 ; $216 = HEAP32 [ $215 >> 2 ] | 0 ; $217 = ( ( $214 ) + 4 ) | 0 ; $218 = $217 ; $219 = HEAP32 [ $218 >> 2 ] | 0 ; $220 = ( $216 | 0 ) == ( 0 ) ; $221 = ( $219 | 0 ) == ( 0 ) ; $222 = $220 & $221 ; if ( ! ( $222 ) ) { $223 = HEAP32 [ 8452 ] | 0 ; FUNCTION_TABLE_vi [ $223 & 127 ] ( 19471 ) ; } $224 = ( 33576 ) ; $225 = $224 ; $226 = HEAP32 [ $225 >> 2 ] | 0 ; $227 = ( ( $224 ) + 4 ) | 0 ; $228 = $227 ; $229 = HEAP32 [ $228 >> 2 ] | 0 ; _opng_check_idat_size ( $226 , $229 ) ; $230 = ( 33576 ) ; $231 = $230 ; $232 = HEAP32 [ $231 >> 2 ] | 0 ; $233 = ( ( $230 ) + 4 ) | 0 ; $234 = $233 ; $235 = HEAP32 [ $234 >> 2 ] | 0 ; _png_save_uint_32 ( $10 , $232 ) ; $236 = $6 ; $237 = 33648 ; $238 = $237 ; $239 = HEAP32 [ $238 >> 2 ] | 0 ; $240 = ( ( $237 ) + 4 ) | 0 ; $241 = $240 ; $242 = HEAP32 [ $241 >> 2 ] | 0 ; $243 = ( _opng_fwriteo ( $236 , $239 , $242 , 0 , $10 , 4 ) | 0 ) ; $244 = ( $243 | 0 ) != ( 4 ) ; if ( $244 ) { $7 = 0 ; } } $245 = $7 ; $246 = ( $245 | 0 ) == ( 0 ) ; if ( $246 ) { $247 = $3 ; _png_error ( $247 , 19507 ) ; // unreachable; } else { $248 = 33648 ; $249 = $248 ; HEAP32 [ $249 >> 2 ] = 0 ; $250 = ( ( $248 ) + 4 ) | 0 ; $251 = $250 ; HEAP32 [ $251 >> 2 ] = 0 ; break L26 ; } } break ; } case 64 : { $252 = HEAP32 [ 8518 ] | 0 ; $253 = ( $252 | 0 ) != ( 0 ) ; if ( $253 ) { $254 = HEAP32 [ 8519 ] | 0 ; $255 = $4 ; $256 = $5 ; $257 = ( _crc32 ( $254 , $255 , $256 ) | 0 ) ; HEAP32 [ 8519 ] = $257 ; } break ; } case 128 : { $258 = HEAP32 [ 8518 ] | 0 ; $259 = ( $258 | 0 ) != ( 0 ) ; if ( $259 ) { STACKTOP = sp ; return ; } break ; } default : { } } } while ( 0 ) ; $260 = $4 ; $261 = $5 ; $262 = $6 ; $263 = ( _fwrite ( $260 , 1 , $261 , $262 ) | 0 ) ; $264 = $5 ; $265 = ( $263 | 0 ) != ( $264 | 0 ) ; if ( $265 ) { $266 = $3 ; _png_error ( $266 , 19527 ) ; // unreachable; } $267 = $5 ; $268 = ( 33560 ) ; $269 = $268 ; $270 = HEAP32 [ $269 >> 2 ] | 0 ; $271 = ( ( $268 ) + 4 ) | 0 ; $272 = $271 ; $273 = HEAP32 [ $272 >> 2 ] | 0 ; $274 = ( _i64Add ( ( $270 | 0 ) , ( $273 | 0 ) , ( $267 | 0 ) , 0 ) | 0 ) ; $275 = tempRet0 ; $276 = ( 33560 ) ; $277 = $276 ; HEAP32 [ $277 >> 2 ] = $274 ; $278 = ( ( $276 ) + 4 ) | 0 ; $279 = $278 ; HEAP32 [ $279 >> 2 ] = $275 ; STACKTOP = sp ; return ; } function _opng_allow_chunk ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = $0 ; $3 = $2 ; $4 = ( _opng_is_image_chunk ( $3 ) | 0 ) ; $5 = ( $4 | 0 ) != ( 0 ) ; do { if ( $5 ) { $1 = 1 ; } else { $6 = HEAP32 [ ( 33912 ) >> 2 ] | 0 ; $7 = ( $6 | 0 ) != ( 0 ) ; if ( $7 ) { $1 = 0 ; break ; } $8 = $2 ; $9 = ( _memcmp ( $8 , 19555 , 4 ) | 0 ) ; $10 = ( $9 | 0 ) == ( 0 ) ; if ( $10 ) { $1 = 0 ; break ; } $11 = HEAP32 [ ( 33908 ) >> 2 ] | 0 ; $12 = ( $11 | 0 ) != ( 0 ) ; if ( $12 ) { $13 = $2 ; $14 = ( _opng_is_apng_chunk ( $13 ) | 0 ) ; $15 = ( $14 | 0 ) != ( 0 ) ; if ( $15 ) { $1 = 0 ; break ; } } $1 = 1 ; } } while ( 0 ) ; $16 = $1 ; STACKTOP = sp ; return ( $16 | 0 ) ; } function _opng_is_image_chunk ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = $0 ; $3 = $2 ; $4 = HEAP8 [ $3 >> 0 ] | 0 ; $5 = $4 & 255 ; $6 = $5 & 32 ; $7 = ( $6 | 0 ) == ( 0 ) ; do { if ( $7 ) { $1 = 1 ; } else { $8 = $2 ; $9 = ( _memcmp ( $8 , 19430 , 4 ) | 0 ) ; $10 = ( $9 | 0 ) == ( 0 ) ; if ( $10 ) { $1 = 1 ; break ; } else { $1 = 0 ; break ; } } } while ( 0 ) ; $11 = $1 ; STACKTOP = sp ; return ( $11 | 0 ) ; } function _opng_is_apng_chunk ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = $0 ; $3 = $2 ; $4 = ( _memcmp ( $3 , 19559 , 4 ) | 0 ) ; $5 = ( $4 | 0 ) == ( 0 ) ; if ( ! ( $5 ) ) { $6 = $2 ; $7 = ( _memcmp ( $6 , 19563 , 4 ) | 0 ) ; $8 = ( $7 | 0 ) == ( 0 ) ; if ( ! ( $8 ) ) { $9 = $2 ; $10 = ( _memcmp ( $9 , 19567 , 4 ) | 0 ) ; $11 = ( $10 | 0 ) == ( 0 ) ; if ( ! ( $11 ) ) { $1 = 0 ; $12 = $1 ; STACKTOP = sp ; return ( $12 | 0 ) ; } } } $1 = 1 ; $12 = $1 ; STACKTOP = sp ; return ( $12 | 0 ) ; } function _opng_store_image_info ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 ; var $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 ; var $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $3 = $0 ; $4 = $1 ; $5 = $2 ; $7 = HEAP32 [ ( 33960 ) >> 2 ] | 0 ; $8 = ( $7 | 0 ) != ( 0 | 0 ) ; if ( ! ( $8 ) ) { $9 = HEAP32 [ 8452 ] | 0 ; FUNCTION_TABLE_vi [ $9 & 127 ] ( 19599 ) ; } $10 = $3 ; $11 = $4 ; $12 = HEAP32 [ 8483 ] | 0 ; $13 = HEAP32 [ ( 33936 ) >> 2 ] | 0 ; $14 = HEAP32 [ ( 33940 ) >> 2 ] | 0 ; $15 = HEAP32 [ ( 33944 ) >> 2 ] | 0 ; $16 = HEAP32 [ ( 33956 ) >> 2 ] | 0 ; $17 = HEAP32 [ ( 33948 ) >> 2 ] | 0 ; $18 = HEAP32 [ ( 33952 ) >> 2 ] | 0 ; _png_set_IHDR ( $10 , $11 , $12 , $13 , $14 , $15 , $16 , $17 , $18 ) ; $19 = HEAP32 [ 8516 ] | 0 ; $20 = HEAP32 [ 8521 ] | 0 ; $21 = HEAP32 [ ( 33960 ) >> 2 ] | 0 ; _png_set_rows ( $19 , $20 , $21 ) ; $22 = HEAP32 [ ( 33964 ) >> 2 ] | 0 ; $23 = ( $22 | 0 ) != ( 0 | 0 ) ; if ( $23 ) { $24 = $3 ; $25 = $4 ; $26 = HEAP32 [ ( 33964 ) >> 2 ] | 0 ; $27 = HEAP32 [ ( 33968 ) >> 2 ] | 0 ; _png_set_PLTE ( $24 , $25 , $26 , $27 ) ; } $28 = HEAP32 [ ( 34004 ) >> 2 ] | 0 ; $29 = ( $28 | 0 ) != ( 0 | 0 ) ; $30 = HEAP32 [ ( 34012 ) >> 2 ] | 0 ; $31 = ( $30 | 0 ) != ( 0 | 0 ) ; $or$cond = $29 | $31 ; if ( $or$cond ) { $32 = $3 ; $33 = $4 ; $34 = HEAP32 [ ( 34004 ) >> 2 ] | 0 ; $35 = HEAP32 [ ( 34008 ) >> 2 ] | 0 ; $36 = HEAP32 [ ( 34012 ) >> 2 ] | 0 ; _png_set_tRNS ( $32 , $33 , $34 , $35 , $36 ) ; } $37 = $5 ; $38 = ( $37 | 0 ) != ( 0 ) ; if ( ! ( $38 ) ) { STACKTOP = sp ; return ; } $39 = HEAP32 [ ( 33972 ) >> 2 ] | 0 ; $40 = ( $39 | 0 ) != ( 0 | 0 ) ; if ( $40 ) { $41 = $3 ; $42 = $4 ; $43 = HEAP32 [ ( 33972 ) >> 2 ] | 0 ; _png_set_bKGD ( $41 , $42 , $43 ) ; } $44 = HEAP32 [ ( 33988 ) >> 2 ] | 0 ; $45 = ( $44 | 0 ) != ( 0 | 0 ) ; if ( $45 ) { $46 = $3 ; $47 = $4 ; $48 = HEAP32 [ ( 33988 ) >> 2 ] | 0 ; _png_set_hIST ( $46 , $47 , $48 ) ; } $49 = HEAP32 [ ( 33992 ) >> 2 ] | 0 ; $50 = ( $49 | 0 ) != ( 0 | 0 ) ; if ( $50 ) { $51 = $3 ; $52 = $4 ; $53 = HEAP32 [ ( 33992 ) >> 2 ] | 0 ; _png_set_sBIT ( $51 , $52 , $53 ) ; } $54 = HEAP32 [ ( 34032 ) >> 2 ] | 0 ; $55 = ( $54 | 0 ) != ( 0 ) ; if ( ! ( $55 ) ) { STACKTOP = sp ; return ; } $56 = $3 ; $57 = $4 ; $58 = HEAP32 [ ( 34028 ) >> 2 ] | 0 ; $59 = HEAP32 [ ( 34032 ) >> 2 ] | 0 ; _png_set_unknown_chunks ( $56 , $57 , $58 , $59 ) ; $6 = 0 ; while ( 1 ) { $60 = $6 ; $61 = HEAP32 [ ( 34032 ) >> 2 ] | 0 ; $62 = ( $60 | 0 ) < ( $61 | 0 ) ; if ( ! ( $62 ) ) { break ; } $63 = $3 ; $64 = $4 ; $65 = $6 ; $66 = HEAP32 [ ( 34028 ) >> 2 ] | 0 ; $67 = $6 ; $68 = ( ( $66 ) + ( ( $67 * 20 ) | 0 ) | 0 ) ; $69 = ( ( ( $68 ) ) + 16 | 0 ) ; $70 = HEAP8 [ $69 >> 0 ] | 0 ; $71 = $70 & 255 ; _png_set_unknown_chunk_location ( $63 , $64 , $65 , $71 ) ; $72 = $6 ; $73 = ( ( $72 ) + 1 ) | 0 ; $6 = $73 ; } STACKTOP = sp ; return ; } function _opng_init_iteration ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , $or$cond3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $8 = sp + 4 | 0 ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $7 = $3 ; $10 = $4 ; $11 = $5 ; $12 = $10 & $11 ; $13 = $7 ; HEAP32 [ $13 >> 2 ] = $12 ; $14 = $7 ; $15 = HEAP32 [ $14 >> 2 ] | 0 ; $16 = ( $15 | 0 ) == ( 0 ) ; $17 = $4 ; $18 = ( $17 | 0 ) != ( 0 ) ; $or$cond = $16 & $18 ; if ( $or$cond ) { HEAP32 [ ( 33792 ) >> 2 ] = 19970 ; $19 = HEAP32 [ 8446 ] | 0 ; _longjmp ( ( $19 | 0 ) , 1 ) ; // unreachable; } $20 = $7 ; $21 = HEAP32 [ $20 >> 2 ] | 0 ; $22 = ( $21 | 0 ) == ( 0 ) ; $23 = HEAP32 [ ( 33884 ) >> 2 ] | 0 ; $24 = ( $23 | 0 ) >= ( 0 ) ; $or$cond3 = $22 | $24 ; if ( ! ( $or$cond3 ) ) { STACKTOP = sp ; return ; } $25 = $6 ; $26 = $5 ; $27 = ( _opng_strparse_rangeset_to_bitset ( $8 , $25 , $26 ) | 0 ) ; $9 = $27 ; $28 = $9 ; $29 = ( $28 | 0 ) == ( 0 ) ; if ( ! ( $29 ) ) { $30 = HEAP32 [ 8452 ] | 0 ; FUNCTION_TABLE_vi [ $30 & 127 ] ( 20006 ) ; } $31 = HEAP32 [ $8 >> 2 ] | 0 ; $32 = $5 ; $33 = $31 & $32 ; $34 = $7 ; $35 = HEAP32 [ $34 >> 2 ] | 0 ; $36 = $35 | $33 ; HEAP32 [ $34 >> 2 ] = $36 ; STACKTOP = sp ; return ; } function _opng_init_read_data ( ) { var label = 0 , sp = 0 ; sp = STACKTOP ; return ; } function _opng_read_data ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 ; var $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 ; var $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 ; var $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 ; var $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 , $208 = 0 ; var $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 ; var $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 ; var $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 ; var $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 ; var $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $or$cond = 0 , $or$cond3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $3 = $0 ; $4 = $1 ; $5 = $2 ; $10 = $3 ; $11 = ( _png_get_io_ptr ( $10 ) | 0 ) ; $6 = $11 ; $12 = $3 ; $13 = ( _png_get_io_state ( $12 ) | 0 ) ; $7 = $13 ; $14 = $7 ; $15 = $14 & 240 ; $8 = $15 ; $16 = $4 ; $17 = $5 ; $18 = $6 ; $19 = ( _fread ( $16 , 1 , $17 , $18 ) | 0 ) ; $20 = $5 ; $21 = ( $19 | 0 ) != ( $20 | 0 ) ; if ( $21 ) { $22 = $3 ; _png_error ( $22 , 20507 ) ; // unreachable; } $23 = ( 33552 ) ; $24 = $23 ; $25 = HEAP32 [ $24 >> 2 ] | 0 ; $26 = ( ( $23 ) + 4 ) | 0 ; $27 = $26 ; $28 = HEAP32 [ $27 >> 2 ] | 0 ; $29 = ( $25 | 0 ) == ( 0 ) ; $30 = ( $28 | 0 ) == ( 0 ) ; $31 = $29 & $30 ; if ( $31 ) { $32 = $5 ; $33 = ( $32 | 0 ) == ( 8 ) ; if ( ! ( $33 ) ) { $34 = HEAP32 [ 8452 ] | 0 ; FUNCTION_TABLE_vi [ $34 & 127 ] ( 20559 ) ; } $35 = $6 ; $36 = ( _opng_ftello ( $35 ) | 0 ) ; $37 = tempRet0 ; $38 = ( _i64Subtract ( ( $36 | 0 ) , ( $37 | 0 ) , 8 , 0 ) | 0 ) ; $39 = tempRet0 ; $40 = ( 33544 ) ; $41 = $40 ; HEAP32 [ $41 >> 2 ] = $38 ; $42 = ( ( $40 ) + 4 ) | 0 ; $43 = $42 ; HEAP32 [ $43 >> 2 ] = $39 ; $44 = HEAP32 [ 8384 ] | 0 ; $45 = $44 | 2 ; HEAP32 [ 8384 ] = $45 ; $46 = $8 ; $47 = ( $46 | 0 ) == ( 16 ) ; if ( $47 ) { $48 = HEAP32 [ 8384 ] | 0 ; $49 = $48 | 4 ; HEAP32 [ 8384 ] = $49 ; } $50 = ( 33544 ) ; $51 = $50 ; $52 = HEAP32 [ $51 >> 2 ] | 0 ; $53 = ( ( $50 ) + 4 ) | 0 ; $54 = $53 ; $55 = HEAP32 [ $54 >> 2 ] | 0 ; $56 = ( $52 | 0 ) == ( 0 ) ; $57 = ( $55 | 0 ) == ( 0 ) ; $58 = $56 & $57 ; if ( $58 ) { $59 = HEAP32 [ 8384 ] | 0 ; $60 = $59 | 1 ; HEAP32 [ 8384 ] = $60 ; } else { $61 = ( 33544 ) ; $62 = $61 ; $63 = HEAP32 [ $62 >> 2 ] | 0 ; $64 = ( ( $61 ) + 4 ) | 0 ; $65 = $64 ; $66 = HEAP32 [ $65 >> 2 ] | 0 ; $67 = ( $66 | 0 ) < ( 0 ) ; if ( $67 ) { $68 = $3 ; _png_error ( $68 , 20601 ) ; // unreachable; } } $69 = ( 33544 ) ; $70 = $69 ; $71 = HEAP32 [ $70 >> 2 ] | 0 ; $72 = ( ( $69 ) + 4 ) | 0 ; $73 = $72 ; $74 = HEAP32 [ $73 >> 2 ] | 0 ; $75 = ( 33552 ) ; $76 = $75 ; HEAP32 [ $76 >> 2 ] = $71 ; $77 = ( ( $75 ) + 4 ) | 0 ; $78 = $77 ; HEAP32 [ $78 >> 2 ] = $74 ; } $79 = $5 ; $80 = ( 33552 ) ; $81 = $80 ; $82 = HEAP32 [ $81 >> 2 ] | 0 ; $83 = ( ( $80 ) + 4 ) | 0 ; $84 = $83 ; $85 = HEAP32 [ $84 >> 2 ] | 0 ; $86 = ( _i64Add ( ( $82 | 0 ) , ( $85 | 0 ) , ( $79 | 0 ) , 0 ) | 0 ) ; $87 = tempRet0 ; $88 = ( 33552 ) ; $89 = $88 ; HEAP32 [ $89 >> 2 ] = $86 ; $90 = ( ( $88 ) + 4 ) | 0 ; $91 = $90 ; HEAP32 [ $91 >> 2 ] = $87 ; $92 = $7 ; $93 = $92 & 1 ; $94 = ( $93 | 0 ) != ( 0 ) ; $95 = $8 ; $96 = ( $95 | 0 ) != ( 0 ) ; $or$cond = $94 & $96 ; if ( ! ( $or$cond ) ) { $97 = HEAP32 [ 8452 ] | 0 ; FUNCTION_TABLE_vi [ $97 & 127 ] ( 19346 ) ; } $98 = $8 ; $99 = ( $98 | 0 ) == ( 32 ) ; if ( ! ( $99 ) ) { $204 = $8 ; $205 = ( $204 | 0 ) != ( 128 ) ; $206 = $5 ; $207 = ( $206 | 0 ) == ( 4 ) ; $or$cond3 = $205 | $207 ; if ( $or$cond3 ) { STACKTOP = sp ; return ; } $208 = HEAP32 [ 8452 ] | 0 ; FUNCTION_TABLE_vi [ $208 & 127 ] ( 20802 ) ; STACKTOP = sp ; return ; } $100 = $5 ; $101 = ( $100 | 0 ) == ( 8 ) ; if ( ! ( $101 ) ) { $102 = HEAP32 [ 8452 ] | 0 ; FUNCTION_TABLE_vi [ $102 & 127 ] ( 20653 ) ; } $103 = $4 ; $104 = ( ( ( $103 ) ) + 4 | 0 ) ; $9 = $104 ; $105 = $9 ; $106 = ( _memcmp ( $105 , 19422 , 4 ) | 0 ) ; $107 = ( $106 | 0 ) == ( 0 ) ; if ( ! ( $107 ) ) { $172 = $9 ; $173 = ( _memcmp ( $172 , 19426 , 4 ) | 0 ) ; $174 = ( $173 | 0 ) == ( 0 ) ; if ( ! ( $174 ) ) { $175 = $9 ; $176 = ( _memcmp ( $175 , 19430 , 4 ) | 0 ) ; $177 = ( $176 | 0 ) == ( 0 ) ; if ( ! ( $177 ) ) { $202 = $3 ; $203 = $9 ; _opng_handle_chunk ( $202 , $203 ) ; STACKTOP = sp ; return ; } } $178 = $4 ; $179 = HEAP8 [ $178 >> 0 ] | 0 ; $180 = $179 & 255 ; $181 = $180 << 24 ; $182 = $4 ; $183 = ( ( ( $182 ) ) + 1 | 0 ) ; $184 = HEAP8 [ $183 >> 0 ] | 0 ; $185 = $184 & 255 ; $186 = $185 << 16 ; $187 = ( ( $181 ) + ( $186 ) ) | 0 ; $188 = $4 ; $189 = ( ( ( $188 ) ) + 2 | 0 ) ; $190 = HEAP8 [ $189 >> 0 ] | 0 ; $191 = $190 & 255 ; $192 = $191 << 8 ; $193 = ( ( $187 ) + ( $192 ) ) | 0 ; $194 = $4 ; $195 = ( ( ( $194 ) ) + 3 | 0 ) ; $196 = HEAP8 [ $195 >> 0 ] | 0 ; $197 = $196 & 255 ; $198 = ( ( $193 ) + ( $197 ) ) | 0 ; $199 = ( ( $198 ) + 12 ) | 0 ; $200 = HEAP32 [ ( 33600 ) >> 2 ] | 0 ; $201 = ( ( $200 ) + ( $199 ) ) | 0 ; HEAP32 [ ( 33600 ) >> 2 ] = $201 ; STACKTOP = sp ; return ; } $108 = $3 ; $109 = HEAP32 [ 8520 ] | 0 ; $110 = ( $108 | 0 ) == ( $109 | 0 ) ; if ( ! ( $110 ) ) { $111 = HEAP32 [ 8452 ] | 0 ; FUNCTION_TABLE_vi [ $111 & 127 ] ( 20693 ) ; } $112 = HEAP32 [ 8520 ] | 0 ; $113 = HEAP32 [ 8522 ] | 0 ; $114 = ( _png_get_rows ( $112 , $113 ) | 0 ) ; $115 = ( $114 | 0 ) == ( 0 | 0 ) ; if ( $115 ) { $116 = ( 33568 ) ; $117 = $116 ; $118 = HEAP32 [ $117 >> 2 ] | 0 ; $119 = ( ( $116 ) + 4 ) | 0 ; $120 = $119 ; $121 = HEAP32 [ $120 >> 2 ] | 0 ; $122 = ( $118 | 0 ) == ( 0 ) ; $123 = ( $121 | 0 ) == ( 0 ) ; $124 = $122 & $123 ; if ( ! ( $124 ) ) { $125 = HEAP32 [ 8452 ] | 0 ; FUNCTION_TABLE_vi [ $125 & 127 ] ( 20721 ) ; } $126 = HEAP32 [ 8520 ] | 0 ; $127 = HEAP32 [ 8522 ] | 0 ; $128 = ( _png_get_image_height ( $126 , $127 ) | 0 ) ; $129 = ( $128 | 0 ) == ( 0 ) ; if ( $129 ) { STACKTOP = sp ; return ; } $130 = HEAP32 [ 8520 ] | 0 ; $131 = HEAP32 [ 8522 ] | 0 ; $132 = ( _pngx_malloc_rows ( $130 , $131 , 0 ) | 0 ) ; $133 = ( $132 | 0 ) != ( 0 | 0 ) ; if ( ! ( $133 ) ) { $134 = HEAP32 [ 8452 ] | 0 ; FUNCTION_TABLE_vi [ $134 & 127 ] ( 20745 ) ; } $135 = HEAP32 [ 8520 ] | 0 ; $136 = HEAP32 [ 8522 ] | 0 ; _png_data_freer ( $135 , $136 , 2 , 64 ) ; } else { $137 = HEAP32 [ 8384 ] | 0 ; $138 = $137 | 128 ; HEAP32 [ 8384 ] = $138 ; } $139 = $4 ; $140 = HEAP8 [ $139 >> 0 ] | 0 ; $141 = $140 & 255 ; $142 = $141 << 24 ; $143 = $4 ; $144 = ( ( ( $143 ) ) + 1 | 0 ) ; $145 = HEAP8 [ $144 >> 0 ] | 0 ; $146 = $145 & 255 ; $147 = $146 << 16 ; $148 = ( ( $142 ) + ( $147 ) ) | 0 ; $149 = $4 ; $150 = ( ( ( $149 ) ) + 2 | 0 ) ; $151 = HEAP8 [ $150 >> 0 ] | 0 ; $152 = $151 & 255 ; $153 = $152 << 8 ; $154 = ( ( $148 ) + ( $153 ) ) | 0 ; $155 = $4 ; $156 = ( ( ( $155 ) ) + 3 | 0 ) ; $157 = HEAP8 [ $156 >> 0 ] | 0 ; $158 = $157 & 255 ; $159 = ( ( $154 ) + ( $158 ) ) | 0 ; $160 = ( 33568 ) ; $161 = $160 ; $162 = HEAP32 [ $161 >> 2 ] | 0 ; $163 = ( ( $160 ) + 4 ) | 0 ; $164 = $163 ; $165 = HEAP32 [ $164 >> 2 ] | 0 ; $166 = ( _i64Add ( ( $162 | 0 ) , ( $165 | 0 ) , ( $159 | 0 ) , 0 ) | 0 ) ; $167 = tempRet0 ; $168 = ( 33568 ) ; $169 = $168 ; HEAP32 [ $169 >> 2 ] = $166 ; $170 = ( ( $168 ) + 4 ) | 0 ; $171 = $170 ; HEAP32 [ $171 >> 2 ] = $167 ; STACKTOP = sp ; return ; } function _opng_load_image_info ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , dest = 0 , label = 0 , sp = 0 , stop = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $3 = $0 ; $4 = $1 ; $5 = $2 ; dest = 33932 ; stop = dest + 104 | 0 ; do { HEAP32 [ dest >> 2 ] = 0 | 0 ; dest = dest + 4 | 0 ; } while ( ( dest | 0 ) < ( stop | 0 ) ) ; $6 = $3 ; $7 = $4 ; ( _png_get_IHDR ( $6 , $7 , 33932 , ( 33936 ) , ( 33940 ) , ( 33944 ) , ( 33956 ) , ( 33948 ) , ( 33952 ) ) | 0 ) ; $8 = $3 ; $9 = $4 ; $10 = ( _png_get_rows ( $8 , $9 ) | 0 ) ; HEAP32 [ ( 33960 ) >> 2 ] = $10 ; $11 = $3 ; $12 = $4 ; ( _png_get_PLTE ( $11 , $12 , ( 33964 ) , ( 33968 ) ) | 0 ) ; $13 = $3 ; $14 = $4 ; $15 = ( _png_get_tRNS ( $13 , $14 , ( 34004 ) , ( 34008 ) , ( 34012 ) ) | 0 ) ; $16 = ( $15 | 0 ) != ( 0 ) ; $17 = HEAP32 [ ( 34012 ) >> 2 ] | 0 ; $18 = ( $17 | 0 ) != ( 0 | 0 ) ; $or$cond = $16 & $18 ; if ( $or$cond ) { $19 = HEAP32 [ ( 34012 ) >> 2 ] | 0 ; ; HEAP16 [ ( 34016 ) >> 1 ] = HEAP16 [ $19 >> 1 ] | 0 ; HEAP16 [ ( 34016 ) + 2 >> 1 ] = HEAP16 [ $19 + 2 >> 1 ] | 0 ; HEAP16 [ ( 34016 ) + 4 >> 1 ] = HEAP16 [ $19 + 4 >> 1 ] | 0 ; HEAP16 [ ( 34016 ) + 6 >> 1 ] = HEAP16 [ $19 + 6 >> 1 ] | 0 ; HEAP16 [ ( 34016 ) + 8 >> 1 ] = HEAP16 [ $19 + 8 >> 1 ] | 0 ; HEAP32 [ ( 34012 ) >> 2 ] = ( 34016 ) ; } $20 = $5 ; $21 = ( $20 | 0 ) != ( 0 ) ; if ( ! ( $21 ) ) { STACKTOP = sp ; return ; } $22 = $3 ; $23 = $4 ; $24 = ( _png_get_bKGD ( $22 , $23 , ( 33972 ) ) | 0 ) ; $25 = ( $24 | 0 ) != ( 0 ) ; if ( $25 ) { $26 = HEAP32 [ ( 33972 ) >> 2 ] | 0 ; ; HEAP16 [ ( 33976 ) >> 1 ] = HEAP16 [ $26 >> 1 ] | 0 ; HEAP16 [ ( 33976 ) + 2 >> 1 ] = HEAP16 [ $26 + 2 >> 1 ] | 0 ; HEAP16 [ ( 33976 ) + 4 >> 1 ] = HEAP16 [ $26 + 4 >> 1 ] | 0 ; HEAP16 [ ( 33976 ) + 6 >> 1 ] = HEAP16 [ $26 + 6 >> 1 ] | 0 ; HEAP16 [ ( 33976 ) + 8 >> 1 ] = HEAP16 [ $26 + 8 >> 1 ] | 0 ; HEAP32 [ ( 33972 ) >> 2 ] = ( 33976 ) ; } $27 = $3 ; $28 = $4 ; ( _png_get_hIST ( $27 , $28 , ( 33988 ) ) | 0 ) ; $29 = $3 ; $30 = $4 ; $31 = ( _png_get_sBIT ( $29 , $30 , ( 33992 ) ) | 0 ) ; $32 = ( $31 | 0 ) != ( 0 ) ; if ( $32 ) { $33 = HEAP32 [ ( 33992 ) >> 2 ] | 0 ; ; HEAP8 [ ( 33996 ) >> 0 ] = HEAP8 [ $33 >> 0 ] | 0 ; HEAP8 [ ( 33996 ) + 1 >> 0 ] = HEAP8 [ $33 + 1 >> 0 ] | 0 ; HEAP8 [ ( 33996 ) + 2 >> 0 ] = HEAP8 [ $33 + 2 >> 0 ] | 0 ; HEAP8 [ ( 33996 ) + 3 >> 0 ] = HEAP8 [ $33 + 3 >> 0 ] | 0 ; HEAP8 [ ( 33996 ) + 4 >> 0 ] = HEAP8 [ $33 + 4 >> 0 ] | 0 ; HEAP32 [ ( 33992 ) >> 2 ] = ( 33996 ) ; } $34 = $3 ; $35 = $4 ; $36 = ( _png_get_unknown_chunks ( $34 , $35 , ( 34028 ) ) | 0 ) ; HEAP32 [ ( 34032 ) >> 2 ] = $36 ; STACKTOP = sp ; return ; } function _opng_print_image_info ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 ; var $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 ; var $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , $vararg_buffer = 0 , $vararg_buffer11 = 0 , $vararg_buffer15 = 0 , $vararg_buffer18 = 0 , $vararg_buffer21 = 0 , $vararg_buffer24 = 0 , $vararg_buffer28 = 0 , $vararg_buffer3 = 0 , $vararg_buffer32 = 0 , $vararg_buffer35 = 0 , $vararg_buffer38 = 0 , $vararg_buffer41 = 0 , $vararg_buffer44 = 0 ; var $vararg_buffer47 = 0 , $vararg_buffer6 = 0 , $vararg_ptr2 = 0 , $vararg_ptr9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 144 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 144 | 0 ) ; $vararg_buffer47 = sp + 112 | 0 ; $vararg_buffer44 = sp + 104 | 0 ; $vararg_buffer41 = sp + 96 | 0 ; $vararg_buffer38 = sp + 88 | 0 ; $vararg_buffer35 = sp + 80 | 0 ; $vararg_buffer32 = sp + 72 | 0 ; $vararg_buffer28 = sp + 64 | 0 ; $vararg_buffer24 = sp + 56 | 0 ; $vararg_buffer21 = sp + 48 | 0 ; $vararg_buffer18 = sp + 40 | 0 ; $vararg_buffer15 = sp + 32 | 0 ; $vararg_buffer11 = sp + 24 | 0 ; $vararg_buffer6 = sp + 16 | 0 ; $vararg_buffer3 = sp + 8 | 0 ; $vararg_buffer = sp ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $7 = $3 ; $9 = 0 ; $10 = $4 ; $11 = ( $10 | 0 ) != ( 0 ) ; if ( $11 ) { $9 = 1 ; $12 = HEAP32 [ 8449 ] | 0 ; $13 = HEAP32 [ 8483 ] | 0 ; $14 = HEAP32 [ ( 33936 ) >> 2 ] | 0 ; HEAP32 [ $vararg_buffer >> 2 ] = $13 ; $vararg_ptr2 = ( ( ( $vararg_buffer ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr2 >> 2 ] = $14 ; FUNCTION_TABLE_vii [ $12 & 127 ] ( 20352 , $vararg_buffer ) ; } $15 = $5 ; $16 = ( $15 | 0 ) != ( 0 ) ; do { if ( $16 ) { $17 = $9 ; $18 = ( $17 | 0 ) != ( 0 ) ; if ( $18 ) { $19 = HEAP32 [ 8449 ] | 0 ; FUNCTION_TABLE_vii [ $19 & 127 ] ( 20367 , $vararg_buffer3 ) ; } $9 = 1 ; $20 = HEAP32 [ ( 33944 ) >> 2 ] | 0 ; $21 = $20 & 7 ; $22 = ( 160 + ( $21 << 2 ) | 0 ) ; $23 = HEAP32 [ $22 >> 2 ] | 0 ; $8 = $23 ; $24 = $8 ; $25 = ( $24 | 0 ) != ( 1 ) ; if ( $25 ) { $26 = HEAP32 [ 8449 ] | 0 ; $27 = $8 ; $28 = HEAP32 [ ( 33940 ) >> 2 ] | 0 ; HEAP32 [ $vararg_buffer6 >> 2 ] = $27 ; $vararg_ptr9 = ( ( ( $vararg_buffer6 ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr9 >> 2 ] = $28 ; FUNCTION_TABLE_vii [ $26 & 127 ] ( 20370 , $vararg_buffer6 ) ; break ; } $29 = HEAP32 [ ( 33940 ) >> 2 ] | 0 ; $30 = ( $29 | 0 ) != ( 1 ) ; $31 = HEAP32 [ 8449 ] | 0 ; if ( $30 ) { $32 = HEAP32 [ ( 33940 ) >> 2 ] | 0 ; HEAP32 [ $vararg_buffer11 >> 2 ] = $32 ; FUNCTION_TABLE_vii [ $31 & 127 ] ( 20387 , $vararg_buffer11 ) ; break ; } else { FUNCTION_TABLE_vii [ $31 & 127 ] ( 20401 , $vararg_buffer15 ) ; break ; } } } while ( 0 ) ; $33 = $6 ; $34 = ( $33 | 0 ) != ( 0 ) ; do { if ( $34 ) { $35 = $9 ; $36 = ( $35 | 0 ) != ( 0 ) ; if ( $36 ) { $37 = HEAP32 [ 8449 ] | 0 ; FUNCTION_TABLE_vii [ $37 & 127 ] ( 20367 , $vararg_buffer18 ) ; } $9 = 1 ; $38 = HEAP32 [ ( 33944 ) >> 2 ] | 0 ; $39 = $38 & 1 ; $40 = ( $39 | 0 ) != ( 0 ) ; if ( ! ( $40 ) ) { $50 = HEAP32 [ 8449 ] | 0 ; $51 = HEAP32 [ ( 33944 ) >> 2 ] | 0 ; $52 = $51 & 2 ; $53 = ( $52 | 0 ) != ( 0 ) ; $54 = $53 ? 20461 : 20465 ; FUNCTION_TABLE_vii [ $50 & 127 ] ( $54 , $vararg_buffer35 ) ; $55 = HEAP32 [ ( 33944 ) >> 2 ] | 0 ; $56 = $55 & 4 ; $57 = ( $56 | 0 ) != ( 0 ) ; if ( $57 ) { $58 = HEAP32 [ 8449 ] | 0 ; FUNCTION_TABLE_vii [ $58 & 127 ] ( 20475 , $vararg_buffer38 ) ; break ; } $59 = HEAP32 [ ( 34012 ) >> 2 ] | 0 ; $60 = ( $59 | 0 ) != ( 0 | 0 ) ; if ( ! ( $60 ) ) { break ; } $61 = HEAP32 [ 8449 ] | 0 ; FUNCTION_TABLE_vii [ $61 & 127 ] ( 20482 , $vararg_buffer41 ) ; break ; } $41 = HEAP32 [ ( 33968 ) >> 2 ] | 0 ; $42 = ( $41 | 0 ) == ( 1 ) ; $43 = HEAP32 [ 8449 ] | 0 ; if ( $42 ) { FUNCTION_TABLE_vii [ $43 & 127 ] ( 20413 , $vararg_buffer21 ) ; } else { $44 = HEAP32 [ ( 33968 ) >> 2 ] | 0 ; HEAP32 [ $vararg_buffer24 >> 2 ] = $44 ; FUNCTION_TABLE_vii [ $43 & 127 ] ( 20421 , $vararg_buffer24 ) ; } $45 = HEAP32 [ ( 34008 ) >> 2 ] | 0 ; $46 = ( $45 | 0 ) > ( 0 ) ; if ( $46 ) { $47 = HEAP32 [ 8449 ] | 0 ; $48 = HEAP32 [ ( 34008 ) >> 2 ] | 0 ; HEAP32 [ $vararg_buffer28 >> 2 ] = $48 ; FUNCTION_TABLE_vii [ $47 & 127 ] ( 20431 , $vararg_buffer28 ) ; } $49 = HEAP32 [ 8449 ] | 0 ; FUNCTION_TABLE_vii [ $49 & 127 ] ( 20449 , $vararg_buffer32 ) ; } } while ( 0 ) ; $62 = $7 ; $63 = ( $62 | 0 ) != ( 0 ) ; $64 = HEAP32 [ ( 33956 ) >> 2 ] | 0 ; $65 = ( $64 | 0 ) != ( 0 ) ; $or$cond = $63 & $65 ; if ( ! ( $or$cond ) ) { STACKTOP = sp ; return ; } $66 = $9 ; $67 = ( $66 | 0 ) != ( 0 ) ; if ( $67 ) { $68 = HEAP32 [ 8449 ] | 0 ; FUNCTION_TABLE_vii [ $68 & 127 ] ( 20367 , $vararg_buffer44 ) ; } $69 = HEAP32 [ 8449 ] | 0 ; FUNCTION_TABLE_vii [ $69 & 127 ] ( 20496 , $vararg_buffer47 ) ; STACKTOP = sp ; return ; } function _opng_handle_chunk ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 ; var $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $5 = 0 , $6 = 0 ; var $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = $0 ; $3 = $1 ; $5 = $3 ; $6 = ( _opng_is_image_chunk ( $5 ) | 0 ) ; $7 = ( $6 | 0 ) != ( 0 ) ; if ( $7 ) { STACKTOP = sp ; return ; } $8 = HEAP32 [ ( 33912 ) >> 2 ] | 0 ; $9 = ( $8 | 0 ) != ( 0 ) ; if ( $9 ) { $10 = HEAP32 [ 8384 ] | 0 ; $11 = $10 | 192 ; HEAP32 [ 8384 ] = $11 ; $12 = $2 ; $13 = $3 ; _opng_set_keep_unknown_chunk ( $12 , 1 , $13 ) ; STACKTOP = sp ; return ; } $14 = $3 ; $15 = ( _memcmp ( $14 , 20839 , 4 ) | 0 ) ; $16 = ( $15 | 0 ) == ( 0 ) ; if ( $16 ) { STACKTOP = sp ; return ; } $17 = $3 ; $18 = ( _memcmp ( $17 , 20843 , 4 ) | 0 ) ; $19 = ( $18 | 0 ) == ( 0 ) ; if ( $19 ) { STACKTOP = sp ; return ; } $20 = $3 ; $21 = ( _memcmp ( $20 , 20847 , 4 ) | 0 ) ; $22 = ( $21 | 0 ) == ( 0 ) ; if ( $22 ) { STACKTOP = sp ; return ; } $4 = 3 ; $23 = $3 ; $24 = ( _memcmp ( $23 , 19555 , 4 ) | 0 ) ; $25 = ( $24 | 0 ) == ( 0 ) ; if ( $25 ) { $26 = HEAP32 [ 8384 ] | 0 ; $27 = $26 | 8 ; HEAP32 [ 8384 ] = $27 ; } else { $28 = $3 ; $29 = ( _opng_is_apng_chunk ( $28 ) | 0 ) ; $30 = ( $29 | 0 ) != ( 0 ) ; if ( $30 ) { $31 = HEAP32 [ 8384 ] | 0 ; $32 = $31 | 32 ; HEAP32 [ 8384 ] = $32 ; $33 = $3 ; $34 = ( _memcmp ( $33 , 19567 , 4 ) | 0 ) ; $35 = ( $34 | 0 ) == ( 0 ) ; if ( $35 ) { $36 = HEAP32 [ 8384 ] | 0 ; $37 = $36 | 16 ; HEAP32 [ 8384 ] = $37 ; } $38 = HEAP32 [ ( 33908 ) >> 2 ] | 0 ; $39 = ( $38 | 0 ) != ( 0 ) ; if ( $39 ) { $40 = HEAP32 [ 8384 ] | 0 ; $41 = $40 | 128 ; HEAP32 [ 8384 ] = $41 ; $4 = 1 ; } } } $42 = $2 ; $43 = $4 ; $44 = $3 ; _opng_set_keep_unknown_chunk ( $42 , $43 , $44 ) ; STACKTOP = sp ; return ; } function _opng_set_keep_unknown_chunk ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $6 = sp + 12 | 0 ; $3 = $0 ; $4 = $1 ; $5 = $2 ; $7 = $5 ; ; HEAP8 [ $6 >> 0 ] = HEAP8 [ $7 >> 0 ] | 0 ; HEAP8 [ $6 + 1 >> 0 ] = HEAP8 [ $7 + 1 >> 0 ] | 0 ; HEAP8 [ $6 + 2 >> 0 ] = HEAP8 [ $7 + 2 >> 0 ] | 0 ; HEAP8 [ $6 + 3 >> 0 ] = HEAP8 [ $7 + 3 >> 0 ] | 0 ; $8 = ( ( ( $6 ) ) + 4 | 0 ) ; HEAP8 [ $8 >> 0 ] = 0 ; $9 = $3 ; $10 = ( _png_handle_as_unknown ( $9 , $6 ) | 0 ) ; $11 = ( $10 | 0 ) != ( 0 ) ; if ( $11 ) { STACKTOP = sp ; return ; } $12 = $3 ; $13 = $4 ; _png_set_keep_unknown_chunks ( $12 , $13 , $6 , 1 ) ; STACKTOP = sp ; return ; } function _opng_finalize ( ) { var $0 = 0 , $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 ; var $9 = 0 , $or$cond = 0 , $or$cond3 = 0 , $vararg_buffer = 0 , $vararg_buffer11 = 0 , $vararg_buffer15 = 0 , $vararg_buffer4 = 0 , $vararg_buffer7 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 48 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 48 | 0 ) ; $vararg_buffer15 = sp + 32 | 0 ; $vararg_buffer11 = sp + 24 | 0 ; $vararg_buffer7 = sp + 16 | 0 ; $vararg_buffer4 = sp + 8 | 0 ; $vararg_buffer = sp ; $0 = HEAP32 [ ( 33848 ) >> 2 ] | 0 ; $1 = ( $0 | 0 ) != ( 0 ) ; $2 = HEAP32 [ ( 33928 ) >> 2 ] | 0 ; $3 = ( $2 >>> 0 ) > ( 0 ) ; $or$cond = $1 | $3 ; $4 = HEAP32 [ ( 33920 ) >> 2 ] | 0 ; $5 = ( $4 >>> 0 ) > ( 0 ) ; $or$cond3 = $or$cond | $5 ; if ( ! ( $or$cond3 ) ) { HEAP32 [ 16881 ] = 0 ; STACKTOP = sp ; return 0 ; } $6 = HEAP32 [ 8449 ] | 0 ; FUNCTION_TABLE_vii [ $6 & 127 ] ( 20851 , $vararg_buffer ) ; $7 = HEAP32 [ 8449 ] | 0 ; $8 = HEAP32 [ 8479 ] | 0 ; HEAP32 [ $vararg_buffer4 >> 2 ] = $8 ; FUNCTION_TABLE_vii [ $7 & 127 ] ( 20869 , $vararg_buffer4 ) ; $9 = HEAP32 [ ( 33928 ) >> 2 ] | 0 ; $10 = ( $9 >>> 0 ) > ( 0 ) ; if ( $10 ) { $11 = HEAP32 [ 8449 ] | 0 ; $12 = HEAP32 [ ( 33928 ) >> 2 ] | 0 ; HEAP32 [ $vararg_buffer7 >> 2 ] = $12 ; FUNCTION_TABLE_vii [ $11 & 127 ] ( 20902 , $vararg_buffer7 ) ; } $13 = HEAP32 [ ( 33920 ) >> 2 ] | 0 ; $14 = ( $13 >>> 0 ) > ( 0 ) ; if ( ! ( $14 ) ) { HEAP32 [ 16881 ] = 0 ; STACKTOP = sp ; return 0 ; } $15 = HEAP32 [ 8449 ] | 0 ; $16 = HEAP32 [ ( 33920 ) >> 2 ] | 0 ; HEAP32 [ $vararg_buffer11 >> 2 ] = $16 ; FUNCTION_TABLE_vii [ $15 & 127 ] ( 20945 , $vararg_buffer11 ) ; $17 = HEAP32 [ ( 33924 ) >> 2 ] | 0 ; $18 = ( $17 >>> 0 ) > ( 0 ) ; if ( ! ( $18 ) ) { HEAP32 [ 16881 ] = 0 ; STACKTOP = sp ; return 0 ; } $19 = HEAP32 [ 8449 ] | 0 ; $20 = HEAP32 [ ( 33924 ) >> 2 ] | 0 ; HEAP32 [ $vararg_buffer15 >> 2 ] = $20 ; FUNCTION_TABLE_vii [ $19 & 127 ] ( 20981 , $vararg_buffer15 ) ; HEAP32 [ 16881 ] = 0 ; STACKTOP = sp ; return 0 ; } function _opng_bitset_count ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $2 = 0 ; while ( 1 ) { $3 = $1 ; $4 = ( $3 | 0 ) != ( 0 ) ; if ( ! ( $4 ) ) { break ; } $5 = $1 ; $6 = ( ( $5 ) - 1 ) | 0 ; $7 = $1 ; $8 = $7 & $6 ; $1 = $8 ; $9 = $2 ; $10 = ( ( $9 ) + 1 ) | 0 ; $2 = $10 ; } $11 = $2 ; STACKTOP = sp ; return ( $11 | 0 ) ; } function _opng_bitset_find_first ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = $0 ; $3 = 0 ; while ( 1 ) { $4 = $3 ; $5 = ( $4 | 0 ) <= ( 31 ) ; if ( ! ( $5 ) ) { label = 6 ; break ; } $6 = $2 ; $7 = $3 ; $8 = 1 << $7 ; $9 = $6 & $8 ; $10 = ( $9 | 0 ) != ( 0 ) ; $11 = $3 ; if ( $10 ) { label = 4 ; break ; } $12 = ( ( $11 ) + 1 ) | 0 ; $3 = $12 ; } if ( ( label | 0 ) == 4 ) { $1 = $11 ; $13 = $1 ; STACKTOP = sp ; return ( $13 | 0 ) ; } else if ( ( label | 0 ) == 6 ) { $1 = - 1 ; $13 = $1 ; STACKTOP = sp ; return ( $13 | 0 ) ; } return ( 0 ) | 0 ; } function _opng_strparse_rangeset_to_bitset ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 ; var $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 ; var $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 ; var $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 ; var $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 ; var $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 48 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 48 | 0 ) ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $7 = 0 ; $15 = $5 ; $8 = $15 ; $9 = 0 ; $14 = 0 ; $13 = 0 ; $12 = - 1 ; $11 = - 1 ; L1 : while ( 1 ) { while ( 1 ) { $16 = $8 ; $17 = HEAP8 [ $16 >> 0 ] | 0 ; $18 = $17 << 24 >> 24 ; $19 = ( _isspace ( $18 ) | 0 ) ; $20 = ( $19 | 0 ) != ( 0 ) ; if ( ! ( $20 ) ) { break ; } $21 = $8 ; $22 = ( ( ( $21 ) ) + 1 | 0 ) ; $8 = $22 ; } $23 = $9 ; switch ( $23 | 0 ) { case 2 : case 0 : { $24 = $8 ; $25 = HEAP8 [ $24 >> 0 ] | 0 ; $26 = $25 << 24 >> 24 ; $27 = ( $26 | 0 ) >= ( 48 ) ; if ( $27 ) { $28 = $8 ; $29 = HEAP8 [ $28 >> 0 ] | 0 ; $30 = $29 << 24 >> 24 ; $31 = ( $30 | 0 ) <= ( 57 ) ; if ( $31 ) { $10 = 0 ; while ( 1 ) { $32 = $10 ; $33 = ( $32 * 10 ) | 0 ; $34 = $8 ; $35 = HEAP8 [ $34 >> 0 ] | 0 ; $36 = $35 << 24 >> 24 ; $37 = ( ( $36 ) - 48 ) | 0 ; $38 = ( ( $33 ) + ( $37 ) ) | 0 ; $10 = $38 ; $39 = $10 ; $40 = ( $39 | 0 ) > ( 31 ) ; if ( $40 ) { $10 = 31 ; $14 = 1 ; } $41 = $8 ; $42 = ( ( ( $41 ) ) + 1 | 0 ) ; $8 = $42 ; $43 = $8 ; $44 = HEAP8 [ $43 >> 0 ] | 0 ; $45 = $44 << 24 >> 24 ; $46 = ( $45 | 0 ) >= ( 48 ) ; if ( ! ( $46 ) ) { break ; } $47 = $8 ; $48 = HEAP8 [ $47 >> 0 ] | 0 ; $49 = $48 << 24 >> 24 ; $50 = ( $49 | 0 ) <= ( 57 ) ; if ( ! ( $50 ) ) { break ; } } $51 = $6 ; $52 = $10 ; $53 = 1 << $52 ; $54 = $51 & $53 ; $55 = ( $54 | 0 ) != ( 0 ) ; if ( ! ( $55 ) ) { $14 = 1 ; } $56 = $9 ; $57 = ( $56 | 0 ) == ( 0 ) ; if ( $57 ) { $58 = $10 ; $11 = $58 ; } $59 = $10 ; $12 = $59 ; $60 = $9 ; $61 = ( ( $60 ) + 1 ) | 0 ; $9 = $61 ; continue L1 ; } } break ; } case 1 : { $62 = $8 ; $63 = HEAP8 [ $62 >> 0 ] | 0 ; $64 = $63 << 24 >> 24 ; $65 = ( $64 | 0 ) == ( 45 ) ; if ( $65 ) { $66 = $8 ; $67 = ( ( ( $66 ) ) + 1 | 0 ) ; $8 = $67 ; $12 = 31 ; $68 = $9 ; $69 = ( ( $68 ) + 1 ) | 0 ; $9 = $69 ; continue L1 ; } break ; } default : { } } $70 = $9 ; $71 = ( $70 | 0 ) > ( 0 ) ; if ( $71 ) { $72 = $11 ; $73 = $12 ; $74 = ( $72 | 0 ) <= ( $73 | 0 ) ; if ( $74 ) { $75 = $11 ; $76 = $12 ; $77 = ( $75 | 0 ) <= ( $76 | 0 ) ; if ( $77 ) { $78 = $12 ; $79 = $11 ; $80 = ( ( $78 ) - ( $79 ) ) | 0 ; $81 = 1 << $80 ; $82 = $81 << 1 ; $83 = ( ( $82 ) - 1 ) | 0 ; $84 = $11 ; $85 = $83 << $84 ; $88 = $85 ; } else { $88 = 0 ; } $86 = $7 ; $87 = $86 | $88 ; $7 = $87 ; $89 = $6 ; $90 = $7 ; $91 = $90 & $89 ; $7 = $91 ; } else { $14 = 1 ; } $9 = 0 ; } $92 = $8 ; $93 = HEAP8 [ $92 >> 0 ] | 0 ; $94 = $93 << 24 >> 24 ; $95 = ( $94 | 0 ) == ( 44 ) ; if ( ! ( $95 ) ) { $96 = $8 ; $97 = HEAP8 [ $96 >> 0 ] | 0 ; $98 = $97 << 24 >> 24 ; $99 = ( $98 | 0 ) == ( 59 ) ; if ( ! ( $99 ) ) { break ; } } $100 = $8 ; $101 = ( ( ( $100 ) ) + 1 | 0 ) ; $8 = $101 ; } $102 = $8 ; $103 = HEAP8 [ $102 >> 0 ] | 0 ; $104 = $103 << 24 >> 24 ; $105 = ( $104 | 0 ) == ( 45 ) ; if ( $105 ) { $13 = 1 ; } while ( 1 ) { $106 = $8 ; $107 = HEAP8 [ $106 >> 0 ] | 0 ; $108 = $107 << 24 >> 24 ; $109 = ( _isspace ( $108 ) | 0 ) ; $110 = ( $109 | 0 ) != ( 0 ) ; $111 = $8 ; if ( ! ( $110 ) ) { break ; } $112 = ( ( ( $111 ) ) + 1 | 0 ) ; $8 = $112 ; } $113 = HEAP8 [ $111 >> 0 ] | 0 ; $114 = $113 << 24 >> 24 ; $115 = ( $114 | 0 ) != ( 0 ) ; if ( $115 ) { $13 = 1 ; } $116 = $13 ; $117 = ( $116 | 0 ) != ( 0 ) ; if ( $117 ) { $118 = ( ___errno_location ( ) | 0 ) ; HEAP32 [ $118 >> 2 ] = 22 ; $119 = $4 ; HEAP32 [ $119 >> 2 ] = 0 ; $3 = - 1 ; $126 = $3 ; STACKTOP = sp ; return ( $126 | 0 ) ; } $120 = $14 ; $121 = ( $120 | 0 ) != ( 0 ) ; if ( $121 ) { $122 = ( ___errno_location ( ) | 0 ) ; HEAP32 [ $122 >> 2 ] = 34 ; $123 = $4 ; HEAP32 [ $123 >> 2 ] = - 1 ; $3 = - 1 ; $126 = $3 ; STACKTOP = sp ; return ( $126 | 0 ) ; } else { $124 = $7 ; $125 = $4 ; HEAP32 [ $125 >> 2 ] = $124 ; $3 = 0 ; $126 = $3 ; STACKTOP = sp ; return ( $126 | 0 ) ; } return ( 0 ) | 0 ; } function _opng_ftello ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $2 = $1 ; $3 = ( ___ftello ( $2 ) | 0 ) ; $4 = ( $3 | 0 ) < ( 0 ) ; $5 = $4 << 31 >> 31 ; tempRet0 = ( $5 ) ; STACKTOP = sp ; return ( $3 | 0 ) ; } function _opng_fseeko ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $5 = sp ; $4 = $0 ; $7 = $5 ; $8 = $7 ; HEAP32 [ $8 >> 2 ] = $1 ; $9 = ( ( $7 ) + 4 ) | 0 ; $10 = $9 ; HEAP32 [ $10 >> 2 ] = $2 ; $6 = $3 ; $11 = $4 ; $12 = $5 ; $13 = $12 ; $14 = HEAP32 [ $13 >> 2 ] | 0 ; $15 = ( ( $12 ) + 4 ) | 0 ; $16 = $15 ; $17 = HEAP32 [ $16 >> 2 ] | 0 ; $18 = $6 ; $19 = ( ___fseeko ( $11 , $14 , $18 ) | 0 ) ; STACKTOP = sp ; return ( $19 | 0 ) ; } function _opng_fwriteo ( $0 , $1 , $2 , $3 , $4 , $5 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; $4 = $4 | 0 ; $5 = $5 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 ; var label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 48 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 48 | 0 ) ; $8 = sp + 16 | 0 ; $12 = sp ; $7 = $0 ; $14 = $8 ; $15 = $14 ; HEAP32 [ $15 >> 2 ] = $1 ; $16 = ( ( $14 ) + 4 ) | 0 ; $17 = $16 ; HEAP32 [ $17 >> 2 ] = $2 ; $9 = $3 ; $10 = $4 ; $11 = $5 ; $18 = $7 ; $19 = ( _fgetpos ( $18 , $12 ) | 0 ) ; $20 = ( $19 | 0 ) != ( 0 ) ; if ( ! ( $20 ) ) { $21 = $7 ; $22 = ( _fflush ( $21 ) | 0 ) ; $23 = ( $22 | 0 ) != ( 0 ) ; if ( ! ( $23 ) ) { $24 = $7 ; $25 = $8 ; $26 = $25 ; $27 = HEAP32 [ $26 >> 2 ] | 0 ; $28 = ( ( $25 ) + 4 ) | 0 ; $29 = $28 ; $30 = HEAP32 [ $29 >> 2 ] | 0 ; $31 = $9 ; $32 = ( _opng_fseeko ( $24 , $27 , $30 , $31 ) | 0 ) ; $33 = ( $32 | 0 ) == ( 0 ) ; if ( $33 ) { $34 = $10 ; $35 = $11 ; $36 = $7 ; $37 = ( _fwrite ( $34 , 1 , $35 , $36 ) | 0 ) ; $13 = $37 ; } else { $13 = 0 ; } $38 = $7 ; $39 = ( _fflush ( $38 ) | 0 ) ; $40 = ( $39 | 0 ) != ( 0 ) ; if ( $40 ) { $13 = 0 ; } $41 = $7 ; $42 = ( _fsetpos ( $41 , $12 ) | 0 ) ; $43 = ( $42 | 0 ) != ( 0 ) ; if ( $43 ) { $13 = 0 ; } $44 = $13 ; $6 = $44 ; $45 = $6 ; STACKTOP = sp ; return ( $45 | 0 ) ; } } $6 = 0 ; $45 = $6 ; STACKTOP = sp ; return ( $45 | 0 ) ; } function _opng_fgetsize ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 ; var $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 96 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 96 | 0 ) ; $5 = sp ; $3 = $0 ; $4 = $1 ; $6 = $3 ; $7 = ( _fileno ( $6 ) | 0 ) ; $8 = ( _fstat ( $7 , $5 ) | 0 ) ; $9 = ( $8 | 0 ) != ( 0 ) ; if ( $9 ) { $2 = - 1 ; $22 = $2 ; STACKTOP = sp ; return ( $22 | 0 ) ; } $10 = ( ( ( $5 ) ) + 36 | 0 ) ; $11 = HEAP32 [ $10 >> 2 ] | 0 ; $12 = ( $11 | 0 ) < ( 0 ) ; if ( $12 ) { $2 = - 1 ; $22 = $2 ; STACKTOP = sp ; return ( $22 | 0 ) ; } else { $13 = ( ( ( $5 ) ) + 36 | 0 ) ; $14 = HEAP32 [ $13 >> 2 ] | 0 ; $15 = ( $14 | 0 ) < ( 0 ) ; $16 = $15 << 31 >> 31 ; $17 = $4 ; $18 = $17 ; $19 = $18 ; HEAP32 [ $19 >> 2 ] = $14 ; $20 = ( ( $18 ) + 4 ) | 0 ; $21 = $20 ; HEAP32 [ $21 >> 2 ] = $16 ; $2 = 0 ; $22 = $2 ; STACKTOP = sp ; return ( $22 | 0 ) ; } return ( 0 ) | 0 ; } function _opng_path_replace_dir ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 ; var $49 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $5 = $0 ; $6 = $1 ; $7 = $2 ; $8 = $3 ; $12 = $7 ; $9 = $12 ; while ( 1 ) { $13 = $9 ; $14 = ( _strpbrk ( $13 , 21020 ) | 0 ) ; $10 = $14 ; $15 = $10 ; $16 = ( $15 | 0 ) == ( 0 | 0 ) ; if ( $16 ) { break ; } $17 = $10 ; $18 = ( ( ( $17 ) ) + 1 | 0 ) ; $9 = $18 ; } $19 = $8 ; $20 = ( _strlen ( $19 ) | 0 ) ; $11 = $20 ; $21 = $11 ; $22 = $9 ; $23 = ( _strlen ( $22 ) | 0 ) ; $24 = ( ( $21 ) + ( $23 ) ) | 0 ; $25 = ( ( $24 ) + 2 ) | 0 ; $26 = $6 ; $27 = ( $25 >>> 0 ) >= ( $26 >>> 0 ) ; if ( $27 ) { $4 = 0 ; $49 = $4 ; STACKTOP = sp ; return ( $49 | 0 ) ; } $28 = $11 ; $29 = ( $28 >>> 0 ) > ( 0 ) ; if ( $29 ) { $30 = $5 ; $31 = $8 ; ( _strcpy ( $30 , $31 ) | 0 ) ; $32 = $5 ; $33 = $11 ; $34 = ( ( $33 ) - 1 ) | 0 ; $35 = ( ( $32 ) + ( $34 ) | 0 ) ; $36 = HEAP8 [ $35 >> 0 ] | 0 ; $37 = $36 << 24 >> 24 ; $38 = ( _strchr ( 21020 , $37 ) | 0 ) ; $39 = ( $38 | 0 ) == ( 0 | 0 ) ; if ( $39 ) { $40 = $5 ; $41 = $11 ; $42 = ( ( $41 ) + 1 ) | 0 ; $11 = $42 ; $43 = ( ( $40 ) + ( $41 ) | 0 ) ; HEAP8 [ $43 >> 0 ] = 47 ; } } $44 = $5 ; $45 = $11 ; $46 = ( ( $44 ) + ( $45 ) | 0 ) ; $47 = $9 ; ( _strcpy ( $46 , $47 ) | 0 ) ; $48 = $5 ; $4 = $48 ; $49 = $4 ; STACKTOP = sp ; return ( $49 | 0 ) ; } function _opng_path_replace_ext ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 ; var $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $5 = $0 ; $6 = $1 ; $7 = $2 ; $8 = $3 ; $11 = $8 ; $12 = HEAP8 [ $11 >> 0 ] | 0 ; $13 = $12 << 24 >> 24 ; $14 = ( $13 | 0 ) != ( 46 ) ; if ( $14 ) { $4 = 0 ; $54 = $4 ; STACKTOP = sp ; return ( $54 | 0 ) ; } $9 = 0 ; $10 = - 1 ; while ( 1 ) { $15 = $7 ; $16 = $9 ; $17 = ( ( $15 ) + ( $16 ) | 0 ) ; $18 = HEAP8 [ $17 >> 0 ] | 0 ; $19 = $18 << 24 >> 24 ; $20 = ( $19 | 0 ) != ( 0 ) ; $21 = $9 ; if ( ! ( $20 ) ) { break ; } $22 = $6 ; $23 = ( $21 >>> 0 ) >= ( $22 >>> 0 ) ; if ( $23 ) { label = 6 ; break ; } $24 = $7 ; $25 = $9 ; $26 = ( ( $24 ) + ( $25 ) | 0 ) ; $27 = HEAP8 [ $26 >> 0 ] | 0 ; $28 = $5 ; $29 = $9 ; $30 = ( ( $28 ) + ( $29 ) | 0 ) ; HEAP8 [ $30 >> 0 ] = $27 ; $31 = $27 << 24 >> 24 ; $32 = ( $31 | 0 ) == ( 46 ) ; if ( $32 ) { $33 = $9 ; $10 = $33 ; } $34 = $9 ; $35 = ( ( $34 ) + 1 ) | 0 ; $9 = $35 ; } if ( ( label | 0 ) == 6 ) { $4 = 0 ; $54 = $4 ; STACKTOP = sp ; return ( $54 | 0 ) ; } $36 = $10 ; $37 = ( $21 >>> 0 ) > ( $36 >>> 0 ) ; if ( $37 ) { $38 = $10 ; $9 = $38 ; } while ( 1 ) { $39 = $9 ; $40 = $6 ; $41 = ( $39 >>> 0 ) >= ( $40 >>> 0 ) ; if ( $41 ) { label = 13 ; break ; } $42 = $8 ; $43 = HEAP8 [ $42 >> 0 ] | 0 ; $44 = $5 ; $45 = $9 ; $46 = ( ( $44 ) + ( $45 ) | 0 ) ; HEAP8 [ $46 >> 0 ] = $43 ; $47 = $43 << 24 >> 24 ; $48 = ( $47 | 0 ) == ( 0 ) ; if ( $48 ) { label = 15 ; break ; } $50 = $9 ; $51 = ( ( $50 ) + 1 ) | 0 ; $9 = $51 ; $52 = $8 ; $53 = ( ( ( $52 ) ) + 1 | 0 ) ; $8 = $53 ; } if ( ( label | 0 ) == 13 ) { $4 = 0 ; $54 = $4 ; STACKTOP = sp ; return ( $54 | 0 ) ; } else if ( ( label | 0 ) == 15 ) { $49 = $5 ; $4 = $49 ; $54 = $4 ; STACKTOP = sp ; return ( $54 | 0 ) ; } return ( 0 ) | 0 ; } function _opng_path_make_backup ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $7 = $6 ; $8 = ( _strlen ( $7 ) | 0 ) ; $9 = ( ( $8 ) + 5 ) | 0 ; $10 = $5 ; $11 = ( $9 >>> 0 ) > ( $10 >>> 0 ) ; if ( $11 ) { $3 = 0 ; $16 = $3 ; STACKTOP = sp ; return ( $16 | 0 ) ; } else { $12 = $4 ; $13 = $6 ; ( _strcpy ( $12 , $13 ) | 0 ) ; $14 = $4 ; ( _strcat ( $14 , 21022 ) | 0 ) ; $15 = $4 ; $3 = $15 ; $16 = $3 ; STACKTOP = sp ; return ( $16 | 0 ) ; } return ( 0 ) | 0 ; } function _opng_os_rename ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $7 = $6 ; $8 = ( $7 | 0 ) != ( 0 ) ; if ( ! ( $8 ) ) { $9 = $5 ; $10 = ( _access ( $9 , 0 ) | 0 ) ; $11 = ( $10 | 0 ) >= ( 0 ) ; if ( $11 ) { $3 = - 1 ; $15 = $3 ; STACKTOP = sp ; return ( $15 | 0 ) ; } } $12 = $4 ; $13 = $5 ; $14 = ( _rename ( $12 , $13 ) | 0 ) ; $3 = $14 ; $15 = $3 ; STACKTOP = sp ; return ( $15 | 0 ) ; } function _opng_os_copy_attr ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 ; var $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 112 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 112 | 0 ) ; $5 = sp + 20 | 0 ; $7 = sp ; $3 = $0 ; $4 = $1 ; $8 = $3 ; $9 = ( _stat ( $8 , $5 ) | 0 ) ; $10 = ( $9 | 0 ) != ( 0 ) ; if ( $10 ) { $2 = - 1 ; $28 = $2 ; STACKTOP = sp ; return ( $28 | 0 ) ; } $6 = 0 ; $11 = $4 ; $12 = ( ( ( $5 ) ) + 20 | 0 ) ; $13 = HEAP32 [ $12 >> 2 ] | 0 ; $14 = ( ( ( $5 ) ) + 24 | 0 ) ; $15 = HEAP32 [ $14 >> 2 ] | 0 ; ( _chown ( $11 , $13 , $15 ) | 0 ) ; $16 = $4 ; $17 = ( ( ( $5 ) ) + 12 | 0 ) ; $18 = HEAP32 [ $17 >> 2 ] | 0 ; $19 = ( _chmod ( $16 , $18 ) | 0 ) ; $20 = ( $19 | 0 ) != ( 0 ) ; if ( $20 ) { $6 = - 1 ; } $21 = ( ( ( $5 ) ) + 48 | 0 ) ; ; HEAP32 [ $7 >> 2 ] = HEAP32 [ $21 >> 2 ] | 0 ; HEAP32 [ $7 + 4 >> 2 ] = HEAP32 [ $21 + 4 >> 2 ] | 0 ; $22 = ( ( ( $7 ) ) + 8 | 0 ) ; $23 = ( ( ( $5 ) ) + 56 | 0 ) ; ; HEAP32 [ $22 >> 2 ] = HEAP32 [ $23 >> 2 ] | 0 ; HEAP32 [ $22 + 4 >> 2 ] = HEAP32 [ $23 + 4 >> 2 ] | 0 ; $24 = $4 ; $25 = ( _utimensat ( - 100 , $24 , $7 , 0 ) | 0 ) ; $26 = ( $25 | 0 ) != ( 0 ) ; if ( $26 ) { $6 = - 1 ; } $27 = $6 ; $2 = $27 ; $28 = $2 ; STACKTOP = sp ; return ( $28 | 0 ) ; } function _opng_os_create_dir ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 96 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 96 | 0 ) ; $3 = sp ; $2 = $0 ; $4 = $2 ; $5 = HEAP8 [ $4 >> 0 ] | 0 ; $6 = $5 << 24 >> 24 ; $7 = ( $6 | 0 ) == ( 0 ) ; do { if ( $7 ) { $1 = 0 ; } else { $8 = $2 ; $9 = ( _stat ( $8 , $3 ) | 0 ) ; $10 = ( $9 | 0 ) == ( 0 ) ; if ( $10 ) { $11 = ( ( ( $3 ) ) + 12 | 0 ) ; $12 = HEAP32 [ $11 >> 2 ] | 0 ; $13 = $12 & 16384 ; $14 = ( $13 | 0 ) != ( 0 ) ; $15 = $14 ? 0 : - 1 ; $1 = $15 ; break ; } else { $16 = $2 ; $17 = ( _mkdir ( $16 , 511 ) | 0 ) ; $1 = $17 ; break ; } } } while ( 0 ) ; $18 = $1 ; STACKTOP = sp ; return ( $18 | 0 ) ; } function _opng_os_test ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 ; var $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 ; var $47 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 96 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 96 | 0 ) ; $7 = sp ; $3 = $0 ; $4 = $1 ; $6 = 0 ; $5 = 0 ; $8 = $4 ; $9 = ( _strchr ( $8 , 102 ) | 0 ) ; $10 = ( $9 | 0 ) != ( 0 | 0 ) ; if ( $10 ) { $6 = 1 ; } $11 = $4 ; $12 = ( _strchr ( $11 , 114 ) | 0 ) ; $13 = ( $12 | 0 ) != ( 0 | 0 ) ; if ( $13 ) { $14 = $5 ; $15 = $14 | 4 ; $5 = $15 ; } $16 = $4 ; $17 = ( _strchr ( $16 , 119 ) | 0 ) ; $18 = ( $17 | 0 ) != ( 0 | 0 ) ; if ( $18 ) { $19 = $5 ; $20 = $19 | 2 ; $5 = $20 ; } $21 = $4 ; $22 = ( _strchr ( $21 , 120 ) | 0 ) ; $23 = ( $22 | 0 ) != ( 0 | 0 ) ; if ( $23 ) { $24 = $5 ; $25 = $24 | 1 ; $5 = $25 ; } $26 = $5 ; $27 = ( $26 | 0 ) != ( 0 ) ; $28 = $6 ; $29 = ( $28 | 0 ) != ( 0 ) ; $or$cond = $27 | $29 ; if ( ! ( $or$cond ) ) { $30 = $4 ; $31 = ( _strchr ( $30 , 101 ) | 0 ) ; $32 = ( $31 | 0 ) == ( 0 | 0 ) ; if ( $32 ) { $2 = 0 ; $47 = $2 ; STACKTOP = sp ; return ( $47 | 0 ) ; } } $33 = $3 ; $34 = ( _stat ( $33 , $7 ) | 0 ) ; $35 = ( $34 | 0 ) != ( 0 ) ; if ( $35 ) { $2 = - 1 ; $47 = $2 ; STACKTOP = sp ; return ( $47 | 0 ) ; } $36 = $6 ; $37 = ( $36 | 0 ) != ( 0 ) ; if ( $37 ) { $38 = ( ( ( $7 ) ) + 12 | 0 ) ; $39 = HEAP32 [ $38 >> 2 ] | 0 ; $40 = $39 & 32768 ; $41 = ( $40 | 0 ) != ( 32768 ) ; if ( $41 ) { $2 = - 1 ; $47 = $2 ; STACKTOP = sp ; return ( $47 | 0 ) ; } } $42 = $5 ; $43 = ( $42 | 0 ) == ( 0 ) ; if ( $43 ) { $2 = 0 ; $47 = $2 ; STACKTOP = sp ; return ( $47 | 0 ) ; } else { $44 = $3 ; $45 = $5 ; $46 = ( _access ( $44 , $45 ) | 0 ) ; $2 = $46 ; $47 = $2 ; STACKTOP = sp ; return ( $47 | 0 ) ; } return ( 0 ) | 0 ; } function _opng_os_test_eq ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $3 = 0 , $4 = 0 , $5 = 0 ; var $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 176 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 176 | 0 ) ; $5 = sp + 76 | 0 ; $6 = sp ; $3 = $0 ; $4 = $1 ; $7 = $3 ; $8 = ( _stat ( $7 , $5 ) | 0 ) ; $9 = ( $8 | 0 ) != ( 0 ) ; if ( ! ( $9 ) ) { $10 = $4 ; $11 = ( _stat ( $10 , $6 ) | 0 ) ; $12 = ( $11 | 0 ) != ( 0 ) ; if ( ! ( $12 ) ) { $13 = HEAP32 [ $5 >> 2 ] | 0 ; $14 = HEAP32 [ $6 >> 2 ] | 0 ; $15 = ( $13 | 0 ) == ( $14 | 0 ) ; if ( $15 ) { $16 = ( ( ( $5 ) ) + 72 | 0 ) ; $17 = HEAP32 [ $16 >> 2 ] | 0 ; $18 = ( ( ( $6 ) ) + 72 | 0 ) ; $19 = HEAP32 [ $18 >> 2 ] | 0 ; $20 = ( $17 | 0 ) == ( $19 | 0 ) ; if ( $20 ) { $21 = ( ( ( $5 ) ) + 72 | 0 ) ; $22 = HEAP32 [ $21 >> 2 ] | 0 ; $23 = ( $22 | 0 ) != ( 0 ) ; $24 = $23 ? 1 : - 1 ; $2 = $24 ; $25 = $2 ; STACKTOP = sp ; return ( $25 | 0 ) ; } } $2 = 0 ; $25 = $2 ; STACKTOP = sp ; return ( $25 | 0 ) ; } } $2 = - 1 ; $25 = $2 ; STACKTOP = sp ; return ( $25 | 0 ) ; } function _opng_os_unlink ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $2 = $1 ; $3 = ( _unlink ( $2 ) | 0 ) ; STACKTOP = sp ; return ( $3 | 0 ) ; } function _opng_sprint_uratio_impl ( $0 , $1 , $2 , $3 , $4 , $5 , $6 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; $4 = $4 | 0 ; $5 = $5 | 0 ; $6 = $6 | 0 ; var $10 = 0 , $100 = 0.0 , $101 = 0.0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0.0 , $109 = 0.0 , $11 = 0 , $110 = 0.0 , $111 = 0.0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 ; var $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 ; var $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0.0 , $168 = 0 , $169 = 0.0 , $17 = 0.0 , $170 = 0.0 , $171 = 0 ; var $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0.0 , $178 = 0.0 , $179 = 0.0 , $18 = 0 , $180 = 0.0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 ; var $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 , $208 = 0 ; var $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 , $226 = 0 ; var $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 , $244 = 0 ; var $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 , $258 = 0 , $259 = 0 , $26 = 0 , $260 = 0 , $261 = 0 , $262 = 0 ; var $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 , $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 , $270 = 0 , $271 = 0 , $272 = 0 , $273 = 0 , $274 = 0 , $275 = 0 , $276 = 0 , $277 = 0 , $278 = 0 , $279 = 0 , $28 = 0 , $280 = 0 ; var $281 = 0 , $282 = 0 , $283 = 0 , $284 = 0 , $285 = 0 , $286 = 0 , $287 = 0 , $288 = 0 , $289 = 0 , $29 = 0 , $290 = 0 , $291 = 0 , $292 = 0 , $293 = 0 , $294 = 0 , $295 = 0 , $296 = 0 , $297 = 0 , $298 = 0 , $299 = 0 ; var $30 = 0 , $300 = 0 , $301 = 0 , $302 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 ; var $47 = 0 , $48 = 0 , $49 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 ; var $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 ; var $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0.0 , $99 = 0 , $vararg_buffer = 0 , $vararg_buffer1 = 0 , $vararg_buffer12 = 0 , $vararg_buffer4 = 0 ; var $vararg_buffer8 = 0 , $vararg_ptr11 = 0 , $vararg_ptr3 = 0 , $vararg_ptr7 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 128 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 128 | 0 ) ; $vararg_buffer12 = sp + 88 | 0 ; $vararg_buffer8 = sp + 72 | 0 ; $vararg_buffer4 = sp + 56 | 0 ; $vararg_buffer1 = sp + 48 | 0 ; $vararg_buffer = sp + 40 | 0 ; $10 = sp + 32 | 0 ; $11 = sp + 24 | 0 ; $13 = sp + 16 | 0 ; $14 = sp + 8 | 0 ; $8 = $0 ; $9 = $1 ; $18 = $10 ; $19 = $18 ; HEAP32 [ $19 >> 2 ] = $2 ; $20 = ( ( $18 ) + 4 ) | 0 ; $21 = $20 ; HEAP32 [ $21 >> 2 ] = $3 ; $22 = $11 ; $23 = $22 ; HEAP32 [ $23 >> 2 ] = $4 ; $24 = ( ( $22 ) + 4 ) | 0 ; $25 = $24 ; HEAP32 [ $25 >> 2 ] = $5 ; $12 = $6 ; $26 = $11 ; $27 = $26 ; $28 = HEAP32 [ $27 >> 2 ] | 0 ; $29 = ( ( $26 ) + 4 ) | 0 ; $30 = $29 ; $31 = HEAP32 [ $30 >> 2 ] | 0 ; $32 = ( $28 | 0 ) == ( 0 ) ; $33 = ( $31 | 0 ) == ( 0 ) ; $34 = $32 & $33 ; if ( $34 ) { $35 = $8 ; $36 = $9 ; $37 = $10 ; $38 = $37 ; $39 = HEAP32 [ $38 >> 2 ] | 0 ; $40 = ( ( $37 ) + 4 ) | 0 ; $41 = $40 ; $42 = HEAP32 [ $41 >> 2 ] | 0 ; $43 = ( $39 | 0 ) == ( 0 ) ; $44 = ( $42 | 0 ) == ( 0 ) ; $45 = $43 & $44 ; $46 = $45 ? 21027 : 21032 ; $47 = ( _opng_snprintf_impl ( $35 , $36 , $46 , $vararg_buffer ) | 0 ) ; $7 = $47 ; $302 = $7 ; STACKTOP = sp ; return ( $302 | 0 ) ; } $48 = $10 ; $49 = $48 ; $50 = HEAP32 [ $49 >> 2 ] | 0 ; $51 = ( ( $48 ) + 4 ) | 0 ; $52 = $51 ; $53 = HEAP32 [ $52 >> 2 ] | 0 ; $54 = $11 ; $55 = $54 ; $56 = HEAP32 [ $55 >> 2 ] | 0 ; $57 = ( ( $54 ) + 4 ) | 0 ; $58 = $57 ; $59 = HEAP32 [ $58 >> 2 ] | 0 ; $60 = ( $53 >>> 0 ) < ( $59 >>> 0 ) ; $61 = ( $50 >>> 0 ) < ( $56 >>> 0 ) ; $62 = ( $53 | 0 ) == ( $59 | 0 ) ; $63 = $62 & $61 ; $64 = $60 | $63 ; if ( $64 ) { $65 = $11 ; $66 = $65 ; $67 = HEAP32 [ $66 >> 2 ] | 0 ; $68 = ( ( $65 ) + 4 ) | 0 ; $69 = $68 ; $70 = HEAP32 [ $69 >> 2 ] | 0 ; $71 = $11 ; $72 = $71 ; $73 = HEAP32 [ $72 >> 2 ] | 0 ; $74 = ( ( $71 ) + 4 ) | 0 ; $75 = $74 ; $76 = HEAP32 [ $75 >> 2 ] | 0 ; $77 = $10 ; $78 = $77 ; $79 = HEAP32 [ $78 >> 2 ] | 0 ; $80 = ( ( $77 ) + 4 ) | 0 ; $81 = $80 ; $82 = HEAP32 [ $81 >> 2 ] | 0 ; $83 = ( _i64Subtract ( ( $73 | 0 ) , ( $76 | 0 ) , ( $79 | 0 ) , ( $82 | 0 ) ) | 0 ) ; $84 = tempRet0 ; $85 = ( ___udivdi3 ( ( $67 | 0 ) , ( $70 | 0 ) , ( $83 | 0 ) , ( $84 | 0 ) ) | 0 ) ; $86 = tempRet0 ; $87 = ( $86 >>> 0 ) < ( 0 ) ; $88 = ( $85 >>> 0 ) < ( 20000 ) ; $89 = ( $86 | 0 ) == ( 0 ) ; $90 = $89 & $88 ; $91 = $87 | $90 ; if ( $91 ) { $16 = 10000 ; $92 = $10 ; $93 = $92 ; $94 = HEAP32 [ $93 >> 2 ] | 0 ; $95 = ( ( $92 ) + 4 ) | 0 ; $96 = $95 ; $97 = HEAP32 [ $96 >> 2 ] | 0 ; $98 = ( + ( $94 >>> 0 ) ) + ( 4294967296.0 * ( + ( $97 >>> 0 ) ) ) ; $99 = $16 ; $100 = ( + ( $99 >>> 0 ) ) ; $101 = $98 * $100 ; $102 = $11 ; $103 = $102 ; $104 = HEAP32 [ $103 >> 2 ] | 0 ; $105 = ( ( $102 ) + 4 ) | 0 ; $106 = $105 ; $107 = HEAP32 [ $106 >> 2 ] | 0 ; $108 = ( + ( $104 >>> 0 ) ) + ( 4294967296.0 * ( + ( $107 >>> 0 ) ) ) ; $109 = $101 / $108 ; $17 = $109 ; $110 = $17 ; $111 = $110 + 0.5 ; $112 = ( ~ ~ ( ( $111 ) ) >>> 0 ) ; $15 = $112 ; $113 = $15 ; $114 = $16 ; $115 = ( $113 >>> 0 ) >= ( $114 >>> 0 ) ; if ( $115 ) { $116 = $16 ; $117 = ( ( $116 ) - 1 ) | 0 ; $15 = $117 ; } $118 = $8 ; $119 = $9 ; $120 = $15 ; $121 = ( ( $120 >>> 0 ) / 100 ) & - 1 ; $122 = $15 ; $123 = ( ( $122 >>> 0 ) % 100 ) & - 1 ; HEAP32 [ $vararg_buffer1 >> 2 ] = $121 ; $vararg_ptr3 = ( ( ( $vararg_buffer1 ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr3 >> 2 ] = $123 ; $124 = ( _opng_snprintf_impl ( $118 , $119 , 21043 , $vararg_buffer1 ) | 0 ) ; $7 = $124 ; $302 = $7 ; STACKTOP = sp ; return ( $302 | 0 ) ; } } $125 = $10 ; $126 = $125 ; $127 = HEAP32 [ $126 >> 2 ] | 0 ; $128 = ( ( $125 ) + 4 ) | 0 ; $129 = $128 ; $130 = HEAP32 [ $129 >> 2 ] | 0 ; $131 = $11 ; $132 = $131 ; $133 = HEAP32 [ $132 >> 2 ] | 0 ; $134 = ( ( $131 ) + 4 ) | 0 ; $135 = $134 ; $136 = HEAP32 [ $135 >> 2 ] | 0 ; $137 = ( ___udivdi3 ( ( $127 | 0 ) , ( $130 | 0 ) , ( $133 | 0 ) , ( $136 | 0 ) ) | 0 ) ; $138 = tempRet0 ; $139 = $13 ; $140 = $139 ; HEAP32 [ $140 >> 2 ] = $137 ; $141 = ( ( $139 ) + 4 ) | 0 ; $142 = $141 ; HEAP32 [ $142 >> 2 ] = $138 ; $143 = $10 ; $144 = $143 ; $145 = HEAP32 [ $144 >> 2 ] | 0 ; $146 = ( ( $143 ) + 4 ) | 0 ; $147 = $146 ; $148 = HEAP32 [ $147 >> 2 ] | 0 ; $149 = $11 ; $150 = $149 ; $151 = HEAP32 [ $150 >> 2 ] | 0 ; $152 = ( ( $149 ) + 4 ) | 0 ; $153 = $152 ; $154 = HEAP32 [ $153 >> 2 ] | 0 ; $155 = ( ___uremdi3 ( ( $145 | 0 ) , ( $148 | 0 ) , ( $151 | 0 ) , ( $154 | 0 ) ) | 0 ) ; $156 = tempRet0 ; $157 = $14 ; $158 = $157 ; HEAP32 [ $158 >> 2 ] = $155 ; $159 = ( ( $157 ) + 4 ) | 0 ; $160 = $159 ; HEAP32 [ $160 >> 2 ] = $156 ; $16 = 100 ; $161 = $14 ; $162 = $161 ; $163 = HEAP32 [ $162 >> 2 ] | 0 ; $164 = ( ( $161 ) + 4 ) | 0 ; $165 = $164 ; $166 = HEAP32 [ $165 >> 2 ] | 0 ; $167 = ( + ( $163 >>> 0 ) ) + ( 4294967296.0 * ( + ( $166 >>> 0 ) ) ) ; $168 = $16 ; $169 = ( + ( $168 >>> 0 ) ) ; $170 = $167 * $169 ; $171 = $11 ; $172 = $171 ; $173 = HEAP32 [ $172 >> 2 ] | 0 ; $174 = ( ( $171 ) + 4 ) | 0 ; $175 = $174 ; $176 = HEAP32 [ $175 >> 2 ] | 0 ; $177 = ( + ( $173 >>> 0 ) ) + ( 4294967296.0 * ( + ( $176 >>> 0 ) ) ) ; $178 = $170 / $177 ; $17 = $178 ; $179 = $17 ; $180 = $179 + 0.5 ; $181 = ( ~ ~ ( ( $180 ) ) >>> 0 ) ; $15 = $181 ; $182 = $15 ; $183 = $16 ; $184 = ( $182 >>> 0 ) >= ( $183 >>> 0 ) ; if ( $184 ) { $15 = 0 ; $185 = $13 ; $186 = $185 ; $187 = HEAP32 [ $186 >> 2 ] | 0 ; $188 = ( ( $185 ) + 4 ) | 0 ; $189 = $188 ; $190 = HEAP32 [ $189 >> 2 ] | 0 ; $191 = ( _i64Add ( ( $187 | 0 ) , ( $190 | 0 ) , 1 , 0 ) | 0 ) ; $192 = tempRet0 ; $193 = $13 ; $194 = $193 ; HEAP32 [ $194 >> 2 ] = $191 ; $195 = ( ( $193 ) + 4 ) | 0 ; $196 = $195 ; HEAP32 [ $196 >> 2 ] = $192 ; } $197 = $12 ; $198 = ( $197 | 0 ) != ( 0 ) ; if ( $198 ) { $199 = $8 ; $200 = $9 ; $201 = $13 ; $202 = $201 ; $203 = HEAP32 [ $202 >> 2 ] | 0 ; $204 = ( ( $201 ) + 4 ) | 0 ; $205 = $204 ; $206 = HEAP32 [ $205 >> 2 ] | 0 ; $207 = $15 ; $208 = $vararg_buffer4 ; $209 = $208 ; HEAP32 [ $209 >> 2 ] = $203 ; $210 = ( ( $208 ) + 4 ) | 0 ; $211 = $210 ; HEAP32 [ $211 >> 2 ] = $206 ; $vararg_ptr7 = ( ( ( $vararg_buffer4 ) ) + 8 | 0 ) ; HEAP32 [ $vararg_ptr7 >> 2 ] = $207 ; $212 = ( _opng_snprintf_impl ( $199 , $200 , 21053 , $vararg_buffer4 ) | 0 ) ; $7 = $212 ; $302 = $7 ; STACKTOP = sp ; return ( $302 | 0 ) ; } $213 = $13 ; $214 = $213 ; $215 = HEAP32 [ $214 >> 2 ] | 0 ; $216 = ( ( $213 ) + 4 ) | 0 ; $217 = $216 ; $218 = HEAP32 [ $217 >> 2 ] | 0 ; $219 = ( $218 >>> 0 ) < ( 0 ) ; $220 = ( $215 >>> 0 ) < ( 100 ) ; $221 = ( $218 | 0 ) == ( 0 ) ; $222 = $221 & $220 ; $223 = $219 | $222 ; if ( $223 ) { $224 = $8 ; $225 = $9 ; $226 = $13 ; $227 = $226 ; $228 = HEAP32 [ $227 >> 2 ] | 0 ; $229 = ( ( $226 ) + 4 ) | 0 ; $230 = $229 ; $231 = HEAP32 [ $230 >> 2 ] | 0 ; $232 = $15 ; $233 = $vararg_buffer8 ; $234 = $233 ; HEAP32 [ $234 >> 2 ] = $228 ; $235 = ( ( $233 ) + 4 ) | 0 ; $236 = $235 ; HEAP32 [ $236 >> 2 ] = $231 ; $vararg_ptr11 = ( ( ( $vararg_buffer8 ) ) + 8 | 0 ) ; HEAP32 [ $vararg_ptr11 >> 2 ] = $232 ; $237 = ( _opng_snprintf_impl ( $224 , $225 , 21064 , $vararg_buffer8 ) | 0 ) ; $7 = $237 ; $302 = $7 ; STACKTOP = sp ; return ( $302 | 0 ) ; } $238 = $10 ; $239 = $238 ; $240 = HEAP32 [ $239 >> 2 ] | 0 ; $241 = ( ( $238 ) + 4 ) | 0 ; $242 = $241 ; $243 = HEAP32 [ $242 >> 2 ] | 0 ; $244 = $11 ; $245 = $244 ; $246 = HEAP32 [ $245 >> 2 ] | 0 ; $247 = ( ( $244 ) + 4 ) | 0 ; $248 = $247 ; $249 = HEAP32 [ $248 >> 2 ] | 0 ; $250 = ( ___udivdi3 ( ( $240 | 0 ) , ( $243 | 0 ) , ( $246 | 0 ) , ( $249 | 0 ) ) | 0 ) ; $251 = tempRet0 ; $252 = $13 ; $253 = $252 ; HEAP32 [ $253 >> 2 ] = $250 ; $254 = ( ( $252 ) + 4 ) | 0 ; $255 = $254 ; HEAP32 [ $255 >> 2 ] = $251 ; $256 = $14 ; $257 = $256 ; $258 = HEAP32 [ $257 >> 2 ] | 0 ; $259 = ( ( $256 ) + 4 ) | 0 ; $260 = $259 ; $261 = HEAP32 [ $260 >> 2 ] | 0 ; $262 = $11 ; $263 = $262 ; $264 = HEAP32 [ $263 >> 2 ] | 0 ; $265 = ( ( $262 ) + 4 ) | 0 ; $266 = $265 ; $267 = HEAP32 [ $266 >> 2 ] | 0 ; $268 = ( _i64Subtract ( ( $264 | 0 ) , ( $267 | 0 ) , 1 , 0 ) | 0 ) ; $269 = tempRet0 ; $270 = ( ___udivdi3 ( ( $268 | 0 ) , ( $269 | 0 ) , 2 , 0 ) | 0 ) ; $271 = tempRet0 ; $272 = ( $261 >>> 0 ) > ( $271 >>> 0 ) ; $273 = ( $258 >>> 0 ) > ( $270 >>> 0 ) ; $274 = ( $261 | 0 ) == ( $271 | 0 ) ; $275 = $274 & $273 ; $276 = $272 | $275 ; if ( $276 ) { $277 = $13 ; $278 = $277 ; $279 = HEAP32 [ $278 >> 2 ] | 0 ; $280 = ( ( $277 ) + 4 ) | 0 ; $281 = $280 ; $282 = HEAP32 [ $281 >> 2 ] | 0 ; $283 = ( _i64Add ( ( $279 | 0 ) , ( $282 | 0 ) , 1 , 0 ) | 0 ) ; $284 = tempRet0 ; $285 = $13 ; $286 = $285 ; HEAP32 [ $286 >> 2 ] = $283 ; $287 = ( ( $285 ) + 4 ) | 0 ; $288 = $287 ; HEAP32 [ $288 >> 2 ] = $284 ; } $289 = $8 ; $290 = $9 ; $291 = $13 ; $292 = $291 ; $293 = HEAP32 [ $292 >> 2 ] | 0 ; $294 = ( ( $291 ) + 4 ) | 0 ; $295 = $294 ; $296 = HEAP32 [ $295 >> 2 ] | 0 ; $297 = $vararg_buffer12 ; $298 = $297 ; HEAP32 [ $298 >> 2 ] = $293 ; $299 = ( ( $297 ) + 4 ) | 0 ; $300 = $299 ; HEAP32 [ $300 >> 2 ] = $296 ; $301 = ( _opng_snprintf_impl ( $289 , $290 , 21075 , $vararg_buffer12 ) | 0 ) ; $7 = $301 ; $302 = $7 ; STACKTOP = sp ; return ( $302 | 0 ) ; } function _opng_snprintf_impl ( $0 , $1 , $2 , $varargs ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $varargs = $varargs | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 ; var $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 48 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 48 | 0 ) ; $7 = sp + 8 | 0 ; $4 = $0 ; $5 = $1 ; $6 = $2 ; HEAP32 [ $7 >> 2 ] = $varargs ; $9 = $4 ; $10 = $5 ; $11 = $6 ; $12 = ( _vsnprintf ( $9 , $10 , $11 , $7 ) | 0 ) ; $8 = $12 ; $13 = $8 ; $14 = ( $13 | 0 ) < ( 0 ) ; if ( ! ( $14 ) ) { $15 = $8 ; $16 = $5 ; $17 = ( $15 >>> 0 ) >= ( $16 >>> 0 ) ; if ( ! ( $17 ) ) { $24 = $8 ; $3 = $24 ; $25 = $3 ; STACKTOP = sp ; return ( $25 | 0 ) ; } } $18 = $5 ; $19 = ( $18 >>> 0 ) > ( 0 ) ; if ( $19 ) { $20 = $4 ; $21 = $5 ; $22 = ( ( $21 ) - 1 ) | 0 ; $23 = ( ( $20 ) + ( $22 ) | 0 ) ; HEAP8 [ $23 >> 0 ] = 0 ; } $3 = - 1 ; $25 = $3 ; STACKTOP = sp ; return ( $25 | 0 ) ; } function _opng_ullratio_to_factor_string ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $5 = 0 , $6 = 0 ; var $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $6 = sp + 8 | 0 ; $7 = sp ; $3 = $0 ; $4 = $1 ; $5 = $2 ; $8 = $5 ; $9 = $8 ; $10 = $9 ; $11 = HEAP32 [ $10 >> 2 ] | 0 ; $12 = ( ( $9 ) + 4 ) | 0 ; $13 = $12 ; $14 = HEAP32 [ $13 >> 2 ] | 0 ; $15 = $6 ; $16 = $15 ; HEAP32 [ $16 >> 2 ] = $11 ; $17 = ( ( $15 ) + 4 ) | 0 ; $18 = $17 ; HEAP32 [ $18 >> 2 ] = $14 ; $19 = $5 ; $20 = ( ( ( $19 ) ) + 8 | 0 ) ; $21 = $20 ; $22 = $21 ; $23 = HEAP32 [ $22 >> 2 ] | 0 ; $24 = ( ( $21 ) + 4 ) | 0 ; $25 = $24 ; $26 = HEAP32 [ $25 >> 2 ] | 0 ; $27 = $7 ; $28 = $27 ; HEAP32 [ $28 >> 2 ] = $23 ; $29 = ( ( $27 ) + 4 ) | 0 ; $30 = $29 ; HEAP32 [ $30 >> 2 ] = $26 ; $31 = $3 ; $32 = $4 ; $33 = $6 ; $34 = $33 ; $35 = HEAP32 [ $34 >> 2 ] | 0 ; $36 = ( ( $33 ) + 4 ) | 0 ; $37 = $36 ; $38 = HEAP32 [ $37 >> 2 ] | 0 ; $39 = $7 ; $40 = $39 ; $41 = HEAP32 [ $40 >> 2 ] | 0 ; $42 = ( ( $39 ) + 4 ) | 0 ; $43 = $42 ; $44 = HEAP32 [ $43 >> 2 ] | 0 ; $45 = ( _opng_sprint_uratio_impl ( $31 , $32 , $35 , $38 , $41 , $44 , 0 ) | 0 ) ; STACKTOP = sp ; return ( $45 | 0 ) ; } function _opng_validate_image ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 ; var $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $3 = $0 ; $4 = $1 ; $5 = $3 ; $6 = $4 ; $7 = ( _png_get_bit_depth ( $5 , $6 ) | 0 ) ; $8 = $7 & 255 ; $9 = ( $8 | 0 ) == ( 0 ) ; do { if ( $9 ) { $2 = 0 ; } else { $10 = $3 ; $11 = $4 ; $12 = ( _png_get_color_type ( $10 , $11 ) | 0 ) ; $13 = $12 & 255 ; $14 = $13 & 1 ; $15 = ( $14 | 0 ) != ( 0 ) ; if ( $15 ) { $16 = $3 ; $17 = $4 ; $18 = ( _png_get_valid ( $16 , $17 , 8 ) | 0 ) ; $19 = ( $18 | 0 ) != ( 0 ) ; if ( ! ( $19 ) ) { $2 = 0 ; break ; } } $20 = $3 ; $21 = $4 ; $22 = ( _png_get_valid ( $20 , $21 , 32768 ) | 0 ) ; $23 = ( $22 | 0 ) != ( 0 ) ; if ( $23 ) { $2 = 1 ; break ; } else { $2 = 0 ; break ; } } } while ( 0 ) ; $24 = $2 ; STACKTOP = sp ; return ( $24 | 0 ) ; } function _opng_reduce_image ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 ; var $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $9 = $4 ; $10 = $5 ; $11 = ( _opng_validate_image ( $9 , $10 ) | 0 ) ; $12 = ( $11 | 0 ) != ( 0 ) ; $13 = $4 ; if ( ! ( $12 ) ) { _png_warning ( $13 , 21081 ) ; $3 = 0 ; $54 = $3 ; STACKTOP = sp ; return ( $54 | 0 ) ; } $14 = $5 ; $15 = ( _png_get_color_type ( $13 , $14 ) | 0 ) ; $16 = $15 & 255 ; $8 = $16 ; $17 = $4 ; $18 = $5 ; $19 = $6 ; $20 = ( _opng_reduce_bits ( $17 , $18 , $19 ) | 0 ) ; $7 = $20 ; $21 = $8 ; $22 = ( $21 | 0 ) == ( 3 ) ; if ( $22 ) { $23 = $6 ; $24 = $23 & 642 ; $25 = ( $24 | 0 ) != ( 0 ) ; if ( $25 ) { $26 = $4 ; $27 = $5 ; $28 = $6 ; $29 = ( _opng_reduce_palette ( $26 , $27 , $28 ) | 0 ) ; $30 = $7 ; $31 = $30 | $29 ; $7 = $31 ; } } $32 = $8 ; $33 = $32 & - 5 ; $34 = ( $33 | 0 ) == ( 0 ) ; if ( $34 ) { $35 = $6 ; $36 = $35 & 64 ; $37 = ( $36 | 0 ) != ( 0 ) ; if ( $37 ) { label = 10 ; } else { label = 8 ; } } else { label = 8 ; } if ( ( label | 0 ) == 8 ) { $38 = $8 ; $39 = $38 & - 5 ; $40 = ( $39 | 0 ) == ( 2 ) ; if ( $40 ) { $41 = $6 ; $42 = $41 & 16 ; $43 = ( $42 | 0 ) != ( 0 ) ; if ( $43 ) { label = 10 ; } } } if ( ( label | 0 ) == 10 ) { $44 = $7 ; $45 = $44 & 128 ; $46 = ( $45 | 0 ) != ( 0 ) ; if ( ! ( $46 ) ) { $47 = $4 ; $48 = $5 ; $49 = $6 ; $50 = ( _opng_reduce_to_palette ( $47 , $48 , $49 ) | 0 ) ; $51 = $7 ; $52 = $51 | $50 ; $7 = $52 ; } } $53 = $7 ; $3 = $53 ; $54 = $3 ; STACKTOP = sp ; return ( $54 | 0 ) ; } function _opng_reduce_bits ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 ; var $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 ; var $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 ; var $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 ; var $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 , $208 = 0 ; var $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 , $226 = 0 ; var $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 , $244 = 0 ; var $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 , $258 = 0 , $259 = 0 , $26 = 0 , $260 = 0 , $261 = 0 , $262 = 0 ; var $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 , $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 , $270 = 0 , $271 = 0 , $272 = 0 , $273 = 0 , $274 = 0 , $275 = 0 , $276 = 0 , $277 = 0 , $278 = 0 , $279 = 0 , $28 = 0 , $280 = 0 ; var $281 = 0 , $282 = 0 , $283 = 0 , $284 = 0 , $285 = 0 , $286 = 0 , $287 = 0 , $288 = 0 , $289 = 0 , $29 = 0 , $290 = 0 , $291 = 0 , $292 = 0 , $293 = 0 , $294 = 0 , $295 = 0 , $296 = 0 , $297 = 0 , $298 = 0 , $299 = 0 ; var $3 = 0 , $30 = 0 , $300 = 0 , $301 = 0 , $302 = 0 , $303 = 0 , $304 = 0 , $305 = 0 , $306 = 0 , $307 = 0 , $308 = 0 , $309 = 0 , $31 = 0 , $310 = 0 , $311 = 0 , $312 = 0 , $313 = 0 , $314 = 0 , $315 = 0 , $316 = 0 ; var $317 = 0 , $318 = 0 , $319 = 0 , $32 = 0 , $320 = 0 , $321 = 0 , $322 = 0 , $323 = 0 , $324 = 0 , $325 = 0 , $326 = 0 , $327 = 0 , $328 = 0 , $329 = 0 , $33 = 0 , $330 = 0 , $331 = 0 , $332 = 0 , $333 = 0 , $334 = 0 ; var $335 = 0 , $336 = 0 , $337 = 0 , $338 = 0 , $339 = 0 , $34 = 0 , $340 = 0 , $341 = 0 , $342 = 0 , $343 = 0 , $344 = 0 , $345 = 0 , $346 = 0 , $347 = 0 , $348 = 0 , $349 = 0 , $35 = 0 , $350 = 0 , $351 = 0 , $352 = 0 ; var $353 = 0 , $354 = 0 , $355 = 0 , $356 = 0 , $357 = 0 , $358 = 0 , $359 = 0 , $36 = 0 , $360 = 0 , $361 = 0 , $362 = 0 , $363 = 0 , $364 = 0 , $365 = 0 , $366 = 0 , $367 = 0 , $368 = 0 , $369 = 0 , $37 = 0 , $38 = 0 ; var $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 ; var $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 ; var $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 ; var $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 160 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 160 | 0 ) ; $10 = sp + 112 | 0 ; $11 = sp + 108 | 0 ; $12 = sp + 104 | 0 ; $13 = sp + 100 | 0 ; $14 = sp + 96 | 0 ; $15 = sp + 92 | 0 ; $19 = sp + 76 | 0 ; $25 = sp + 24 | 0 ; $26 = sp + 20 | 0 ; $27 = sp + 16 | 0 ; $28 = sp + 12 | 0 ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $33 = $4 ; $34 = $5 ; $35 = $6 ; $36 = ( _opng_analyze_bits ( $33 , $34 , $35 ) | 0 ) ; $6 = $36 ; $37 = $6 ; $38 = ( $37 | 0 ) == ( 0 ) ; if ( $38 ) { $3 = 0 ; $369 = $3 ; STACKTOP = sp ; return ( $369 | 0 ) ; } $39 = $4 ; $40 = $5 ; ( _png_get_IHDR ( $39 , $40 , $10 , $11 , $15 , $19 , $12 , $13 , $14 ) | 0 ) ; $41 = HEAP32 [ $15 >> 2 ] | 0 ; $42 = ( $41 | 0 ) >= ( 8 ) ; if ( ! ( $42 ) ) { ___assert_fail ( ( 21977 | 0 ) , ( 21165 | 0 ) , 506 , ( 21996 | 0 ) ) ; // unreachable; } $43 = $6 ; $44 = $43 & 1 ; $45 = ( $44 | 0 ) != ( 0 ) ; $46 = HEAP32 [ $15 >> 2 ] | 0 ; do { if ( $45 ) { $47 = ( $46 | 0 ) == ( 16 ) ; if ( $47 ) { $16 = 8 ; break ; } else { ___assert_fail ( ( 22013 | 0 ) , ( 21165 | 0 ) , 509 , ( 21996 | 0 ) ) ; // unreachable; } } else { $16 = $46 ; } } while ( 0 ) ; $48 = HEAP32 [ $15 >> 2 ] | 0 ; $49 = ( ( $48 | 0 ) / 8 ) & - 1 ; $17 = $49 ; $50 = $16 ; $51 = ( ( $50 | 0 ) / 8 ) & - 1 ; $18 = $51 ; $52 = HEAP32 [ $19 >> 2 ] | 0 ; $20 = $52 ; $53 = $6 ; $54 = $53 & 4 ; $55 = ( $54 | 0 ) != ( 0 ) ; do { if ( $55 ) { $56 = HEAP32 [ $19 >> 2 ] | 0 ; $57 = $56 & 2 ; $58 = ( $57 | 0 ) != ( 0 ) ; if ( $58 ) { $59 = $20 ; $60 = $59 & - 3 ; $20 = $60 ; break ; } else { ___assert_fail ( ( 22033 | 0 ) , ( 21165 | 0 ) , 521 , ( 21996 | 0 ) ) ; // unreachable; } } } while ( 0 ) ; $61 = $6 ; $62 = $61 & 8 ; $63 = ( $62 | 0 ) != ( 0 ) ; do { if ( $63 ) { $64 = HEAP32 [ $19 >> 2 ] | 0 ; $65 = $64 & 4 ; $66 = ( $65 | 0 ) != ( 0 ) ; if ( $66 ) { $67 = $20 ; $68 = $67 & - 5 ; $20 = $68 ; break ; } else { ___assert_fail ( ( 22052 | 0 ) , ( 21165 | 0 ) , 526 , ( 21996 | 0 ) ) ; // unreachable; } } } while ( 0 ) ; $69 = $4 ; $70 = $5 ; $71 = ( _png_get_channels ( $69 , $70 ) | 0 ) ; $72 = $71 & 255 ; $21 = $72 ; $73 = $20 ; $74 = $73 & 2 ; $75 = ( $74 | 0 ) != ( 0 ) ; $76 = $75 ? 3 : 1 ; $77 = $20 ; $78 = $77 & 4 ; $79 = ( $78 | 0 ) != ( 0 ) ; $80 = $79 ? 1 : 0 ; $81 = ( ( $76 ) + ( $80 ) ) | 0 ; $22 = $81 ; $82 = $21 ; $83 = $17 ; $84 = Math_imul ( $82 , $83 ) | 0 ; $23 = $84 ; $85 = $22 ; $86 = $18 ; $87 = Math_imul ( $85 , $86 ) | 0 ; $24 = $87 ; $31 = 0 ; while ( 1 ) { $88 = $31 ; $89 = $18 ; $90 = $89 << 2 ; $91 = ( $88 | 0 ) < ( $90 | 0 ) ; if ( ! ( $91 ) ) { break ; } $92 = $31 ; $93 = HEAP32 [ $15 >> 2 ] | 0 ; $94 = Math_imul ( $92 , $93 ) | 0 ; $95 = $16 ; $96 = ( ( $94 | 0 ) / ( $95 | 0 ) ) & - 1 ; $97 = $31 ; $98 = ( ( $25 ) + ( $97 << 2 ) | 0 ) ; HEAP32 [ $98 >> 2 ] = $96 ; $99 = $31 ; $100 = ( ( $99 ) + 1 ) | 0 ; $31 = $100 ; } $101 = $6 ; $102 = $101 & 4 ; $103 = ( $102 | 0 ) != ( 0 ) ; if ( $103 ) { $104 = $20 ; $105 = $104 & 4 ; $106 = ( $105 | 0 ) != ( 0 ) ; if ( $106 ) { $107 = $18 ; $108 = ( $107 * 3 ) | 0 ; $109 = ( ( $25 ) + ( $108 << 2 ) | 0 ) ; $110 = HEAP32 [ $109 >> 2 ] | 0 ; $111 = $18 ; $112 = ( ( $25 ) + ( $111 << 2 ) | 0 ) ; HEAP32 [ $112 >> 2 ] = $110 ; $113 = $18 ; $114 = ( $113 | 0 ) == ( 2 ) ; if ( $114 ) { $115 = $18 ; $116 = ( $115 * 3 ) | 0 ; $117 = ( ( $116 ) + 1 ) | 0 ; $118 = ( ( $25 ) + ( $117 << 2 ) | 0 ) ; $119 = HEAP32 [ $118 >> 2 ] | 0 ; $120 = $18 ; $121 = ( ( $120 ) + 1 ) | 0 ; $122 = ( ( $25 ) + ( $121 << 2 ) | 0 ) ; HEAP32 [ $122 >> 2 ] = $119 ; } } } $123 = $23 ; $124 = $24 ; $125 = ( $123 | 0 ) > ( $124 | 0 ) ; if ( ! ( $125 ) ) { ___assert_fail ( ( 22071 | 0 ) , ( 21165 | 0 ) , 551 , ( 21996 | 0 ) ) ; // unreachable; } $126 = $4 ; $127 = $5 ; $128 = ( _png_get_rows ( $126 , $127 ) | 0 ) ; $7 = $128 ; $29 = 0 ; while ( 1 ) { $129 = $29 ; $130 = HEAP32 [ $11 >> 2 ] | 0 ; $131 = ( $129 >>> 0 ) < ( $130 >>> 0 ) ; if ( ! ( $131 ) ) { break ; } $132 = $7 ; $133 = HEAP32 [ $132 >> 2 ] | 0 ; $9 = $133 ; $8 = $133 ; $30 = 0 ; while ( 1 ) { $134 = $30 ; $135 = HEAP32 [ $10 >> 2 ] | 0 ; $136 = ( $134 >>> 0 ) < ( $135 >>> 0 ) ; if ( ! ( $136 ) ) { break ; } $31 = 0 ; while ( 1 ) { $137 = $31 ; $138 = $24 ; $139 = ( $137 | 0 ) < ( $138 | 0 ) ; if ( ! ( $139 ) ) { break ; } $140 = $8 ; $141 = $31 ; $142 = ( ( $25 ) + ( $141 << 2 ) | 0 ) ; $143 = HEAP32 [ $142 >> 2 ] | 0 ; $144 = ( ( $140 ) + ( $143 ) | 0 ) ; $145 = HEAP8 [ $144 >> 0 ] | 0 ; $146 = $9 ; $147 = $31 ; $148 = ( ( $146 ) + ( $147 ) | 0 ) ; HEAP8 [ $148 >> 0 ] = $145 ; $149 = $31 ; $150 = ( ( $149 ) + 1 ) | 0 ; $31 = $150 ; } $151 = $23 ; $152 = $8 ; $153 = ( ( $152 ) + ( $151 ) | 0 ) ; $8 = $153 ; $154 = $24 ; $155 = $9 ; $156 = ( ( $155 ) + ( $154 ) | 0 ) ; $9 = $156 ; $157 = $30 ; $158 = ( ( $157 ) + 1 ) | 0 ; $30 = $158 ; } $159 = $29 ; $160 = ( ( $159 ) + 1 ) | 0 ; $29 = $160 ; $161 = $7 ; $162 = ( ( ( $161 ) ) + 4 | 0 ) ; $7 = $162 ; } $163 = $4 ; $164 = $5 ; $165 = ( _png_get_tRNS ( $163 , $164 , 0 , 0 , $26 ) | 0 ) ; $166 = ( $165 | 0 ) != ( 0 ) ; do { if ( $166 ) { $167 = $6 ; $168 = $167 & 1 ; $169 = ( $168 | 0 ) != ( 0 ) ; do { if ( $169 ) { $170 = HEAP32 [ $26 >> 2 ] | 0 ; $171 = ( ( ( $170 ) ) + 2 | 0 ) ; $172 = HEAP16 [ $171 >> 1 ] | 0 ; $173 = $172 & 65535 ; $174 = ( ( $173 | 0 ) % 257 ) & - 1 ; $175 = ( $174 | 0 ) == ( 0 ) ; if ( $175 ) { $176 = HEAP32 [ $26 >> 2 ] | 0 ; $177 = ( ( ( $176 ) ) + 4 | 0 ) ; $178 = HEAP16 [ $177 >> 1 ] | 0 ; $179 = $178 & 65535 ; $180 = ( ( $179 | 0 ) % 257 ) & - 1 ; $181 = ( $180 | 0 ) == ( 0 ) ; if ( $181 ) { $182 = HEAP32 [ $26 >> 2 ] | 0 ; $183 = ( ( ( $182 ) ) + 6 | 0 ) ; $184 = HEAP16 [ $183 >> 1 ] | 0 ; $185 = $184 & 65535 ; $186 = ( ( $185 | 0 ) % 257 ) & - 1 ; $187 = ( $186 | 0 ) == ( 0 ) ; if ( $187 ) { $188 = HEAP32 [ $26 >> 2 ] | 0 ; $189 = ( ( ( $188 ) ) + 8 | 0 ) ; $190 = HEAP16 [ $189 >> 1 ] | 0 ; $191 = $190 & 65535 ; $192 = ( ( $191 | 0 ) % 257 ) & - 1 ; $193 = ( $192 | 0 ) == ( 0 ) ; if ( $193 ) { $194 = HEAP32 [ $26 >> 2 ] | 0 ; $195 = ( ( ( $194 ) ) + 2 | 0 ) ; $196 = HEAP16 [ $195 >> 1 ] | 0 ; $197 = $196 & 65535 ; $198 = $197 & 255 ; $199 = $198 & 65535 ; HEAP16 [ $195 >> 1 ] = $199 ; $200 = HEAP32 [ $26 >> 2 ] | 0 ; $201 = ( ( ( $200 ) ) + 4 | 0 ) ; $202 = HEAP16 [ $201 >> 1 ] | 0 ; $203 = $202 & 65535 ; $204 = $203 & 255 ; $205 = $204 & 65535 ; HEAP16 [ $201 >> 1 ] = $205 ; $206 = HEAP32 [ $26 >> 2 ] | 0 ; $207 = ( ( ( $206 ) ) + 6 | 0 ) ; $208 = HEAP16 [ $207 >> 1 ] | 0 ; $209 = $208 & 65535 ; $210 = $209 & 255 ; $211 = $210 & 65535 ; HEAP16 [ $207 >> 1 ] = $211 ; $212 = HEAP32 [ $26 >> 2 ] | 0 ; $213 = ( ( ( $212 ) ) + 8 | 0 ) ; $214 = HEAP16 [ $213 >> 1 ] | 0 ; $215 = $214 & 65535 ; $216 = $215 & 255 ; $217 = $216 & 65535 ; HEAP16 [ $213 >> 1 ] = $217 ; break ; } } } } $218 = $4 ; $219 = $5 ; _png_free_data ( $218 , $219 , 8192 , - 1 ) ; $220 = $4 ; $221 = $5 ; _png_set_invalid ( $220 , $221 , 16 ) ; } } while ( 0 ) ; $222 = $6 ; $223 = $222 & 4 ; $224 = ( $223 | 0 ) != ( 0 ) ; if ( $224 ) { $225 = HEAP32 [ $26 >> 2 ] | 0 ; $226 = ( ( ( $225 ) ) + 2 | 0 ) ; $227 = HEAP16 [ $226 >> 1 ] | 0 ; $228 = $227 & 65535 ; $229 = HEAP32 [ $26 >> 2 ] | 0 ; $230 = ( ( ( $229 ) ) + 4 | 0 ) ; $231 = HEAP16 [ $230 >> 1 ] | 0 ; $232 = $231 & 65535 ; $233 = ( $228 | 0 ) == ( $232 | 0 ) ; if ( ! ( $233 ) ) { $234 = HEAP32 [ $26 >> 2 ] | 0 ; $235 = ( ( ( $234 ) ) + 2 | 0 ) ; $236 = HEAP16 [ $235 >> 1 ] | 0 ; $237 = $236 & 65535 ; $238 = HEAP32 [ $26 >> 2 ] | 0 ; $239 = ( ( ( $238 ) ) + 6 | 0 ) ; $240 = HEAP16 [ $239 >> 1 ] | 0 ; $241 = $240 & 65535 ; $242 = ( $237 | 0 ) == ( $241 | 0 ) ; if ( ! ( $242 ) ) { $248 = $4 ; $249 = $5 ; _png_free_data ( $248 , $249 , 8192 , - 1 ) ; $250 = $4 ; $251 = $5 ; _png_set_invalid ( $250 , $251 , 16 ) ; break ; } } $243 = HEAP32 [ $26 >> 2 ] | 0 ; $244 = ( ( ( $243 ) ) + 2 | 0 ) ; $245 = HEAP16 [ $244 >> 1 ] | 0 ; $246 = HEAP32 [ $26 >> 2 ] | 0 ; $247 = ( ( ( $246 ) ) + 8 | 0 ) ; HEAP16 [ $247 >> 1 ] = $245 ; } } } while ( 0 ) ; $252 = $4 ; $253 = $5 ; $254 = ( _png_get_bKGD ( $252 , $253 , $27 ) | 0 ) ; $255 = ( $254 | 0 ) != ( 0 ) ; if ( $255 ) { $256 = $6 ; $257 = $256 & 1 ; $258 = ( $257 | 0 ) != ( 0 ) ; if ( $258 ) { $259 = HEAP32 [ $27 >> 2 ] | 0 ; $260 = ( ( ( $259 ) ) + 2 | 0 ) ; $261 = HEAP16 [ $260 >> 1 ] | 0 ; $262 = $261 & 65535 ; $263 = $262 & 255 ; $264 = $263 & 65535 ; HEAP16 [ $260 >> 1 ] = $264 ; $265 = HEAP32 [ $27 >> 2 ] | 0 ; $266 = ( ( ( $265 ) ) + 4 | 0 ) ; $267 = HEAP16 [ $266 >> 1 ] | 0 ; $268 = $267 & 65535 ; $269 = $268 & 255 ; $270 = $269 & 65535 ; HEAP16 [ $266 >> 1 ] = $270 ; $271 = HEAP32 [ $27 >> 2 ] | 0 ; $272 = ( ( ( $271 ) ) + 6 | 0 ) ; $273 = HEAP16 [ $272 >> 1 ] | 0 ; $274 = $273 & 65535 ; $275 = $274 & 255 ; $276 = $275 & 65535 ; HEAP16 [ $272 >> 1 ] = $276 ; $277 = HEAP32 [ $27 >> 2 ] | 0 ; $278 = ( ( ( $277 ) ) + 8 | 0 ) ; $279 = HEAP16 [ $278 >> 1 ] | 0 ; $280 = $279 & 65535 ; $281 = $280 & 255 ; $282 = $281 & 65535 ; HEAP16 [ $278 >> 1 ] = $282 ; } $283 = $6 ; $284 = $283 & 4 ; $285 = ( $284 | 0 ) != ( 0 ) ; if ( $285 ) { $286 = HEAP32 [ $27 >> 2 ] | 0 ; $287 = ( ( ( $286 ) ) + 2 | 0 ) ; $288 = HEAP16 [ $287 >> 1 ] | 0 ; $289 = HEAP32 [ $27 >> 2 ] | 0 ; $290 = ( ( ( $289 ) ) + 8 | 0 ) ; HEAP16 [ $290 >> 1 ] = $288 ; } } $291 = $4 ; $292 = $5 ; $293 = ( _png_get_sBIT ( $291 , $292 , $28 ) | 0 ) ; $294 = ( $293 | 0 ) != ( 0 ) ; if ( $294 ) { $295 = $6 ; $296 = $295 & 1 ; $297 = ( $296 | 0 ) != ( 0 ) ; if ( $297 ) { $298 = HEAP32 [ $28 >> 2 ] | 0 ; $299 = HEAP8 [ $298 >> 0 ] | 0 ; $300 = $299 & 255 ; $301 = ( $300 | 0 ) > ( 8 ) ; if ( $301 ) { $302 = HEAP32 [ $28 >> 2 ] | 0 ; HEAP8 [ $302 >> 0 ] = 8 ; } $303 = HEAP32 [ $28 >> 2 ] | 0 ; $304 = ( ( ( $303 ) ) + 1 | 0 ) ; $305 = HEAP8 [ $304 >> 0 ] | 0 ; $306 = $305 & 255 ; $307 = ( $306 | 0 ) > ( 8 ) ; if ( $307 ) { $308 = HEAP32 [ $28 >> 2 ] | 0 ; $309 = ( ( ( $308 ) ) + 1 | 0 ) ; HEAP8 [ $309 >> 0 ] = 8 ; } $310 = HEAP32 [ $28 >> 2 ] | 0 ; $311 = ( ( ( $310 ) ) + 2 | 0 ) ; $312 = HEAP8 [ $311 >> 0 ] | 0 ; $313 = $312 & 255 ; $314 = ( $313 | 0 ) > ( 8 ) ; if ( $314 ) { $315 = HEAP32 [ $28 >> 2 ] | 0 ; $316 = ( ( ( $315 ) ) + 2 | 0 ) ; HEAP8 [ $316 >> 0 ] = 8 ; } $317 = HEAP32 [ $28 >> 2 ] | 0 ; $318 = ( ( ( $317 ) ) + 3 | 0 ) ; $319 = HEAP8 [ $318 >> 0 ] | 0 ; $320 = $319 & 255 ; $321 = ( $320 | 0 ) > ( 8 ) ; if ( $321 ) { $322 = HEAP32 [ $28 >> 2 ] | 0 ; $323 = ( ( ( $322 ) ) + 3 | 0 ) ; HEAP8 [ $323 >> 0 ] = 8 ; } $324 = HEAP32 [ $28 >> 2 ] | 0 ; $325 = ( ( ( $324 ) ) + 4 | 0 ) ; $326 = HEAP8 [ $325 >> 0 ] | 0 ; $327 = $326 & 255 ; $328 = ( $327 | 0 ) > ( 8 ) ; if ( $328 ) { $329 = HEAP32 [ $28 >> 2 ] | 0 ; $330 = ( ( ( $329 ) ) + 4 | 0 ) ; HEAP8 [ $330 >> 0 ] = 8 ; } } $331 = $6 ; $332 = $331 & 4 ; $333 = ( $332 | 0 ) != ( 0 ) ; if ( $333 ) { $334 = HEAP32 [ $28 >> 2 ] | 0 ; $335 = HEAP8 [ $334 >> 0 ] | 0 ; $32 = $335 ; $336 = $32 ; $337 = $336 & 255 ; $338 = HEAP32 [ $28 >> 2 ] | 0 ; $339 = ( ( ( $338 ) ) + 1 | 0 ) ; $340 = HEAP8 [ $339 >> 0 ] | 0 ; $341 = $340 & 255 ; $342 = ( $337 | 0 ) < ( $341 | 0 ) ; if ( $342 ) { $343 = HEAP32 [ $28 >> 2 ] | 0 ; $344 = ( ( ( $343 ) ) + 1 | 0 ) ; $345 = HEAP8 [ $344 >> 0 ] | 0 ; $32 = $345 ; } $346 = $32 ; $347 = $346 & 255 ; $348 = HEAP32 [ $28 >> 2 ] | 0 ; $349 = ( ( ( $348 ) ) + 2 | 0 ) ; $350 = HEAP8 [ $349 >> 0 ] | 0 ; $351 = $350 & 255 ; $352 = ( $347 | 0 ) < ( $351 | 0 ) ; if ( $352 ) { $353 = HEAP32 [ $28 >> 2 ] | 0 ; $354 = ( ( ( $353 ) ) + 2 | 0 ) ; $355 = HEAP8 [ $354 >> 0 ] | 0 ; $32 = $355 ; } $356 = $32 ; $357 = HEAP32 [ $28 >> 2 ] | 0 ; $358 = ( ( ( $357 ) ) + 3 | 0 ) ; HEAP8 [ $358 >> 0 ] = $356 ; } } $359 = $4 ; $360 = $5 ; $361 = HEAP32 [ $10 >> 2 ] | 0 ; $362 = HEAP32 [ $11 >> 2 ] | 0 ; $363 = $16 ; $364 = $20 ; $365 = HEAP32 [ $12 >> 2 ] | 0 ; $366 = HEAP32 [ $13 >> 2 ] | 0 ; $367 = HEAP32 [ $14 >> 2 ] | 0 ; _png_set_IHDR ( $359 , $360 , $361 , $362 , $363 , $364 , $365 , $366 , $367 ) ; $368 = $6 ; $3 = $368 ; $369 = $3 ; STACKTOP = sp ; return ( $369 | 0 ) ; } function _opng_reduce_palette ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 ; var $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 ; var $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 ; var $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 ; var $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 , $208 = 0 ; var $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 , $226 = 0 ; var $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 , $244 = 0 ; var $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 , $258 = 0 , $259 = 0 , $26 = 0 , $260 = 0 , $261 = 0 , $262 = 0 ; var $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 , $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 , $270 = 0 , $271 = 0 , $272 = 0 , $273 = 0 , $274 = 0 , $275 = 0 , $276 = 0 , $277 = 0 , $278 = 0 , $279 = 0 , $28 = 0 , $280 = 0 ; var $281 = 0 , $282 = 0 , $283 = 0 , $284 = 0 , $285 = 0 , $286 = 0 , $287 = 0 , $288 = 0 , $289 = 0 , $29 = 0 , $290 = 0 , $291 = 0 , $292 = 0 , $293 = 0 , $294 = 0 , $295 = 0 , $296 = 0 , $297 = 0 , $298 = 0 , $299 = 0 ; var $3 = 0 , $30 = 0 , $300 = 0 , $301 = 0 , $302 = 0 , $303 = 0 , $304 = 0 , $305 = 0 , $306 = 0 , $307 = 0 , $308 = 0 , $309 = 0 , $31 = 0 , $310 = 0 , $311 = 0 , $312 = 0 , $313 = 0 , $314 = 0 , $315 = 0 , $316 = 0 ; var $317 = 0 , $318 = 0 , $319 = 0 , $32 = 0 , $320 = 0 , $321 = 0 , $322 = 0 , $323 = 0 , $324 = 0 , $325 = 0 , $326 = 0 , $327 = 0 , $328 = 0 , $329 = 0 , $33 = 0 , $330 = 0 , $331 = 0 , $332 = 0 , $333 = 0 , $334 = 0 ; var $335 = 0 , $336 = 0 , $337 = 0 , $338 = 0 , $339 = 0 , $34 = 0 , $340 = 0 , $341 = 0 , $342 = 0 , $343 = 0 , $344 = 0 , $345 = 0 , $346 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 ; var $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 ; var $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 ; var $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 ; var $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $or$cond = 0 , $or$cond3 = 0 , $or$cond5 = 0 , $or$cond7 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 384 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 384 | 0 ) ; $8 = sp + 80 | 0 ; $9 = sp + 76 | 0 ; $11 = sp + 68 | 0 ; $12 = sp + 64 | 0 ; $13 = sp + 60 | 0 ; $14 = sp + 56 | 0 ; $15 = sp + 52 | 0 ; $16 = sp + 48 | 0 ; $17 = sp + 44 | 0 ; $18 = sp + 40 | 0 ; $19 = sp + 36 | 0 ; $24 = sp + 120 | 0 ; $25 = sp + 104 | 0 ; $27 = sp + 20 | 0 ; $28 = sp + 16 | 0 ; $29 = sp + 12 | 0 ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $7 = 0 ; $34 = $4 ; $35 = $5 ; ( _png_get_IHDR ( $34 , $35 , $11 , $12 , $13 , $14 , $15 , $16 , $17 ) | 0 ) ; $36 = $4 ; $37 = $5 ; $38 = ( _png_get_rows ( $36 , $37 ) | 0 ) ; $10 = $38 ; $39 = $4 ; $40 = $5 ; $41 = ( _png_get_PLTE ( $39 , $40 , $8 , $18 ) | 0 ) ; $42 = ( $41 | 0 ) != ( 0 ) ; if ( ! ( $42 ) ) { HEAP32 [ $8 >> 2 ] = 0 ; HEAP32 [ $18 >> 2 ] = 0 ; } $43 = $4 ; $44 = $5 ; $45 = ( _png_get_tRNS ( $43 , $44 , $9 , $19 , 0 ) | 0 ) ; $46 = ( $45 | 0 ) != ( 0 ) ; do { if ( $46 ) { $47 = HEAP32 [ $9 >> 2 ] | 0 ; $48 = ( $47 | 0 ) != ( 0 | 0 ) ; $49 = HEAP32 [ $19 >> 2 ] | 0 ; $50 = ( $49 | 0 ) > ( 0 ) ; $or$cond = $48 & $50 ; if ( $or$cond ) { break ; } else { ___assert_fail ( ( 21642 | 0 ) , ( 21165 | 0 ) , 1117 , ( 21685 | 0 ) ) ; // unreachable; } } else { HEAP32 [ $9 >> 2 ] = 0 ; HEAP32 [ $19 >> 2 ] = 0 ; } } while ( 0 ) ; $51 = $4 ; $52 = $5 ; _opng_analyze_sample_usage ( $51 , $52 , $24 ) ; $53 = $6 ; $54 = $53 & 128 ; $55 = ( $54 | 0 ) != ( 0 ) ; $56 = HEAP32 [ $13 >> 2 ] | 0 ; $57 = ( $56 | 0 ) == ( 8 ) ; $58 = $55 ? $57 : 0 ; $59 = $58 & 1 ; $26 = $59 ; $21 = - 1 ; $20 = - 1 ; $32 = 0 ; while ( 1 ) { $60 = $32 ; $61 = ( $60 | 0 ) < ( 256 ) ; if ( ! ( $61 ) ) { break ; } $62 = $32 ; $63 = ( ( $24 ) + ( $62 ) | 0 ) ; $64 = HEAP8 [ $63 >> 0 ] | 0 ; $65 = ( $64 << 24 >> 24 ) != ( 0 ) ; do { if ( $65 ) { $66 = $32 ; $20 = $66 ; $67 = $32 ; $68 = HEAP32 [ $19 >> 2 ] | 0 ; $69 = ( $67 | 0 ) < ( $68 | 0 ) ; if ( $69 ) { $70 = HEAP32 [ $9 >> 2 ] | 0 ; $71 = $32 ; $72 = ( ( $70 ) + ( $71 ) | 0 ) ; $73 = HEAP8 [ $72 >> 0 ] | 0 ; $74 = $73 & 255 ; $75 = ( $74 | 0 ) < ( 255 ) ; if ( $75 ) { $76 = $32 ; $21 = $76 ; } } $77 = $26 ; $78 = ( $77 | 0 ) != ( 0 ) ; if ( $78 ) { $79 = HEAP32 [ $8 >> 2 ] | 0 ; $80 = $32 ; $81 = ( ( $79 ) + ( ( $80 * 3 ) | 0 ) | 0 ) ; $82 = HEAP8 [ $81 >> 0 ] | 0 ; $83 = $82 & 255 ; $84 = HEAP32 [ $8 >> 2 ] | 0 ; $85 = $32 ; $86 = ( ( $84 ) + ( ( $85 * 3 ) | 0 ) | 0 ) ; $87 = ( ( ( $86 ) ) + 1 | 0 ) ; $88 = HEAP8 [ $87 >> 0 ] | 0 ; $89 = $88 & 255 ; $90 = ( $83 | 0 ) != ( $89 | 0 ) ; if ( ! ( $90 ) ) { $91 = HEAP32 [ $8 >> 2 ] | 0 ; $92 = $32 ; $93 = ( ( $91 ) + ( ( $92 * 3 ) | 0 ) | 0 ) ; $94 = HEAP8 [ $93 >> 0 ] | 0 ; $95 = $94 & 255 ; $96 = HEAP32 [ $8 >> 2 ] | 0 ; $97 = $32 ; $98 = ( ( $96 ) + ( ( $97 * 3 ) | 0 ) | 0 ) ; $99 = ( ( ( $98 ) ) + 2 | 0 ) ; $100 = HEAP8 [ $99 >> 0 ] | 0 ; $101 = $100 & 255 ; $102 = ( $95 | 0 ) != ( $101 | 0 ) ; if ( ! ( $102 ) ) { break ; } } $26 = 0 ; } } } while ( 0 ) ; $103 = $32 ; $104 = ( ( $103 ) + 1 ) | 0 ; $32 = $104 ; } $105 = $20 ; $106 = ( $105 | 0 ) >= ( 0 ) ; if ( ! ( $106 ) ) { ___assert_fail ( ( 21705 | 0 ) , ( 21165 | 0 ) , 1135 , ( 21685 | 0 ) ) ; // unreachable; } $107 = $20 ; $108 = $21 ; $109 = ( $107 | 0 ) >= ( $108 | 0 ) ; if ( ! ( $109 ) ) { ___assert_fail ( ( 21727 | 0 ) , ( 21165 | 0 ) , 1136 , ( 21685 | 0 ) ) ; // unreachable; } $110 = $20 ; $111 = HEAP32 [ $18 >> 2 ] | 0 ; $112 = ( $110 | 0 ) >= ( $111 | 0 ) ; do { if ( $112 ) { $113 = $4 ; _png_warning ( $113 , 21764 ) ; $114 = $4 ; $115 = $5 ; $116 = $20 ; $117 = ( ( $116 ) + 1 ) | 0 ; _opng_realloc_PLTE ( $114 , $115 , $117 ) ; $118 = $4 ; $119 = $5 ; ( _png_get_PLTE ( $118 , $119 , $8 , $18 ) | 0 ) ; $120 = HEAP32 [ $18 >> 2 ] | 0 ; $121 = $20 ; $122 = ( ( $121 ) + 1 ) | 0 ; $123 = ( $120 | 0 ) == ( $122 | 0 ) ; if ( $123 ) { $124 = $7 ; $125 = $124 | 8192 ; $7 = $125 ; break ; } else { ___assert_fail ( ( 21787 | 0 ) , ( 21165 | 0 ) , 1145 , ( 21685 | 0 ) ) ; // unreachable; } } } while ( 0 ) ; $126 = HEAP32 [ $19 >> 2 ] | 0 ; $127 = HEAP32 [ $18 >> 2 ] | 0 ; $128 = ( $126 | 0 ) > ( $127 | 0 ) ; if ( $128 ) { $129 = $4 ; _png_warning ( $129 , 21823 ) ; $130 = $7 ; $131 = $130 | 8192 ; $7 = $131 ; } $132 = $26 ; $133 = ( $132 | 0 ) != ( 0 ) ; $134 = $21 ; $135 = ( $134 | 0 ) >= ( 0 ) ; $or$cond3 = $133 & $135 ; L41 : do { if ( $or$cond3 ) { $136 = HEAP32 [ $8 >> 2 ] | 0 ; $137 = $21 ; $138 = ( ( $136 ) + ( ( $137 * 3 ) | 0 ) | 0 ) ; $139 = HEAP8 [ $138 >> 0 ] | 0 ; $140 = $139 & 255 ; $141 = ( ( ( $25 ) ) + 8 | 0 ) ; HEAP16 [ $141 >> 1 ] = $140 ; $142 = HEAP32 [ $9 >> 2 ] | 0 ; $143 = $21 ; $144 = ( ( $142 ) + ( $143 ) | 0 ) ; $145 = HEAP8 [ $144 >> 0 ] | 0 ; $23 = $145 ; $32 = 0 ; while ( 1 ) { $146 = $32 ; $147 = $20 ; $148 = ( $146 | 0 ) <= ( $147 | 0 ) ; if ( ! ( $148 ) ) { break L41 ; } $149 = $32 ; $150 = ( ( $24 ) + ( $149 ) | 0 ) ; $151 = HEAP8 [ $150 >> 0 ] | 0 ; $152 = ( $151 << 24 >> 24 ) != ( 0 ) ; if ( $152 ) { $153 = $32 ; $154 = $21 ; $155 = ( $153 | 0 ) <= ( $154 | 0 ) ; if ( $155 ) { $156 = HEAP32 [ $9 >> 2 ] | 0 ; $157 = $32 ; $158 = ( ( $156 ) + ( $157 ) | 0 ) ; $159 = HEAP8 [ $158 >> 0 ] | 0 ; $22 = $159 ; $160 = $22 ; $161 = $160 & 255 ; $162 = ( $161 | 0 ) < ( 255 ) ; if ( $162 ) { $163 = HEAP32 [ $8 >> 2 ] | 0 ; $164 = $32 ; $165 = ( ( $163 ) + ( ( $164 * 3 ) | 0 ) | 0 ) ; $166 = HEAP8 [ $165 >> 0 ] | 0 ; $167 = $166 & 255 ; $168 = ( ( ( $25 ) ) + 8 | 0 ) ; $169 = HEAP16 [ $168 >> 1 ] | 0 ; $170 = $169 & 65535 ; $171 = ( $167 | 0 ) != ( $170 | 0 ) ; if ( $171 ) { label = 36 ; break ; } } } else { $22 = - 1 ; } $172 = HEAP32 [ $8 >> 2 ] | 0 ; $173 = $32 ; $174 = ( ( $172 ) + ( ( $173 * 3 ) | 0 ) | 0 ) ; $175 = HEAP8 [ $174 >> 0 ] | 0 ; $176 = $175 & 255 ; $177 = ( ( ( $25 ) ) + 8 | 0 ) ; $178 = HEAP16 [ $177 >> 1 ] | 0 ; $179 = $178 & 65535 ; $180 = ( $176 | 0 ) == ( $179 | 0 ) ; if ( $180 ) { $181 = $22 ; $182 = $181 & 255 ; $183 = $23 ; $184 = $183 & 255 ; $185 = ( $182 | 0 ) != ( $184 | 0 ) ; if ( $185 ) { label = 40 ; break ; } } } $186 = $32 ; $187 = ( ( $186 ) + 1 ) | 0 ; $32 = $187 ; } if ( ( label | 0 ) == 36 ) { $26 = 0 ; break ; } else if ( ( label | 0 ) == 40 ) { $26 = 0 ; break ; } } } while ( 0 ) ; $188 = HEAP32 [ $19 >> 2 ] | 0 ; $189 = ( $188 | 0 ) > ( 0 ) ; $190 = $21 ; $191 = ( $190 | 0 ) < ( 0 ) ; $or$cond5 = $189 & $191 ; if ( $or$cond5 ) { HEAP32 [ $19 >> 2 ] = 0 ; $192 = $4 ; $193 = $5 ; _png_free_data ( $192 , $193 , 8192 , - 1 ) ; $194 = $4 ; $195 = $5 ; _png_set_invalid ( $194 , $195 , 16 ) ; $196 = $7 ; $197 = $196 | 512 ; $7 = $197 ; } $198 = $6 ; $199 = $198 & 512 ; $200 = ( $199 | 0 ) != ( 0 ) ; do { if ( $200 ) { $201 = HEAP32 [ $18 >> 2 ] | 0 ; $202 = $20 ; $203 = ( ( $202 ) + 1 ) | 0 ; $204 = ( $201 | 0 ) != ( $203 | 0 ) ; do { if ( $204 ) { $205 = $4 ; $206 = $5 ; $207 = $20 ; $208 = ( ( $207 ) + 1 ) | 0 ; _opng_realloc_PLTE ( $205 , $206 , $208 ) ; $209 = $4 ; $210 = $5 ; ( _png_get_PLTE ( $209 , $210 , $8 , $18 ) | 0 ) ; $211 = HEAP32 [ $18 >> 2 ] | 0 ; $212 = $20 ; $213 = ( ( $212 ) + 1 ) | 0 ; $214 = ( $211 | 0 ) == ( $213 | 0 ) ; if ( $214 ) { $215 = $7 ; $216 = $215 | 512 ; $7 = $216 ; break ; } else { ___assert_fail ( ( 21787 | 0 ) , ( 21165 | 0 ) , 1203 , ( 21685 | 0 ) ) ; // unreachable; } } } while ( 0 ) ; $217 = HEAP32 [ $19 >> 2 ] | 0 ; $218 = ( $217 | 0 ) > ( 0 ) ; if ( $218 ) { $219 = HEAP32 [ $19 >> 2 ] | 0 ; $220 = $21 ; $221 = ( ( $220 ) + 1 ) | 0 ; $222 = ( $219 | 0 ) != ( $221 | 0 ) ; if ( $222 ) { $223 = $4 ; $224 = $5 ; $225 = $21 ; $226 = ( ( $225 ) + 1 ) | 0 ; _opng_realloc_tRNS ( $223 , $224 , $226 ) ; $227 = $4 ; $228 = $5 ; ( _png_get_tRNS ( $227 , $228 , $9 , $19 , 0 ) | 0 ) ; $229 = HEAP32 [ $19 >> 2 ] | 0 ; $230 = $21 ; $231 = ( ( $230 ) + 1 ) | 0 ; $232 = ( $229 | 0 ) == ( $231 | 0 ) ; if ( $232 ) { $233 = $7 ; $234 = $233 | 512 ; $7 = $234 ; break ; } else { ___assert_fail ( ( 21853 | 0 ) , ( 21165 | 0 ) , 1212 , ( 21685 | 0 ) ) ; // unreachable; } } } } } while ( 0 ) ; $235 = $6 ; $236 = $235 & 2 ; $237 = ( $236 | 0 ) != ( 0 ) ; if ( $237 ) { $238 = $4 ; $239 = $5 ; $240 = $6 ; $241 = ( _opng_reduce_palette_bits ( $238 , $239 , $240 ) | 0 ) ; $242 = $7 ; $243 = $242 | $241 ; $7 = $243 ; $244 = $4 ; $245 = $5 ; $246 = ( _png_get_bit_depth ( $244 , $245 ) | 0 ) ; $247 = $246 & 255 ; HEAP32 [ $13 >> 2 ] = $247 ; } $248 = HEAP32 [ $13 >> 2 ] | 0 ; $249 = ( $248 | 0 ) >= ( 8 ) ; $250 = $26 ; $251 = ( $250 | 0 ) != ( 0 ) ; $or$cond7 = $249 & $251 ; if ( ! ( $or$cond7 ) ) { $252 = $7 ; $3 = $252 ; $346 = $3 ; STACKTOP = sp ; return ( $346 | 0 ) ; } $30 = 0 ; while ( 1 ) { $253 = $30 ; $254 = HEAP32 [ $12 >> 2 ] | 0 ; $255 = ( $253 >>> 0 ) < ( $254 >>> 0 ) ; if ( ! ( $255 ) ) { break ; } $31 = 0 ; while ( 1 ) { $256 = $31 ; $257 = HEAP32 [ $11 >> 2 ] | 0 ; $258 = ( $256 >>> 0 ) < ( $257 >>> 0 ) ; if ( ! ( $258 ) ) { break ; } $259 = HEAP32 [ $8 >> 2 ] | 0 ; $260 = $10 ; $261 = $30 ; $262 = ( ( $260 ) + ( $261 << 2 ) | 0 ) ; $263 = HEAP32 [ $262 >> 2 ] | 0 ; $264 = $31 ; $265 = ( ( $263 ) + ( $264 ) | 0 ) ; $266 = HEAP8 [ $265 >> 0 ] | 0 ; $267 = $266 & 255 ; $268 = ( ( $259 ) + ( ( $267 * 3 ) | 0 ) | 0 ) ; $269 = HEAP8 [ $268 >> 0 ] | 0 ; $270 = $10 ; $271 = $30 ; $272 = ( ( $270 ) + ( $271 << 2 ) | 0 ) ; $273 = HEAP32 [ $272 >> 2 ] | 0 ; $274 = $31 ; $275 = ( ( $273 ) + ( $274 ) | 0 ) ; HEAP8 [ $275 >> 0 ] = $269 ; $276 = $31 ; $277 = ( ( $276 ) + 1 ) | 0 ; $31 = $277 ; } $278 = $30 ; $279 = ( ( $278 ) + 1 ) | 0 ; $30 = $279 ; } $280 = HEAP32 [ $19 >> 2 ] | 0 ; $281 = ( $280 | 0 ) > ( 0 ) ; if ( $281 ) { $282 = $4 ; $283 = $5 ; _png_set_tRNS ( $282 , $283 , 0 , 0 , $25 ) ; } $284 = $4 ; $285 = $5 ; $286 = ( _png_get_bKGD ( $284 , $285 , $27 ) | 0 ) ; $287 = ( $286 | 0 ) != ( 0 ) ; if ( $287 ) { $288 = HEAP32 [ $8 >> 2 ] | 0 ; $289 = HEAP32 [ $27 >> 2 ] | 0 ; $290 = HEAP8 [ $289 >> 0 ] | 0 ; $291 = $290 & 255 ; $292 = ( ( $288 ) + ( ( $291 * 3 ) | 0 ) | 0 ) ; $293 = HEAP8 [ $292 >> 0 ] | 0 ; $294 = $293 & 255 ; $295 = HEAP32 [ $27 >> 2 ] | 0 ; $296 = ( ( ( $295 ) ) + 8 | 0 ) ; HEAP16 [ $296 >> 1 ] = $294 ; } $297 = $4 ; $298 = $5 ; $299 = ( _png_get_hIST ( $297 , $298 , $28 ) | 0 ) ; $300 = ( $299 | 0 ) != ( 0 ) ; if ( $300 ) { $301 = $4 ; $302 = $5 ; _png_free_data ( $301 , $302 , 8 , - 1 ) ; $303 = $4 ; $304 = $5 ; _png_set_invalid ( $303 , $304 , 64 ) ; } $305 = $4 ; $306 = $5 ; $307 = ( _png_get_sBIT ( $305 , $306 , $29 ) | 0 ) ; $308 = ( $307 | 0 ) != ( 0 ) ; if ( $308 ) { $309 = HEAP32 [ $29 >> 2 ] | 0 ; $310 = HEAP8 [ $309 >> 0 ] | 0 ; $33 = $310 ; $311 = $33 ; $312 = $311 & 255 ; $313 = HEAP32 [ $29 >> 2 ] | 0 ; $314 = ( ( ( $313 ) ) + 1 | 0 ) ; $315 = HEAP8 [ $314 >> 0 ] | 0 ; $316 = $315 & 255 ; $317 = ( $312 | 0 ) < ( $316 | 0 ) ; if ( $317 ) { $318 = HEAP32 [ $29 >> 2 ] | 0 ; $319 = ( ( ( $318 ) ) + 1 | 0 ) ; $320 = HEAP8 [ $319 >> 0 ] | 0 ; $33 = $320 ; } $321 = $33 ; $322 = $321 & 255 ; $323 = HEAP32 [ $29 >> 2 ] | 0 ; $324 = ( ( ( $323 ) ) + 2 | 0 ) ; $325 = HEAP8 [ $324 >> 0 ] | 0 ; $326 = $325 & 255 ; $327 = ( $322 | 0 ) < ( $326 | 0 ) ; if ( $327 ) { $328 = HEAP32 [ $29 >> 2 ] | 0 ; $329 = ( ( ( $328 ) ) + 2 | 0 ) ; $330 = HEAP8 [ $329 >> 0 ] | 0 ; $33 = $330 ; } $331 = $33 ; $332 = HEAP32 [ $29 >> 2 ] | 0 ; $333 = ( ( ( $332 ) ) + 3 | 0 ) ; HEAP8 [ $333 >> 0 ] = $331 ; } $334 = $4 ; $335 = $5 ; $336 = HEAP32 [ $11 >> 2 ] | 0 ; $337 = HEAP32 [ $12 >> 2 ] | 0 ; $338 = HEAP32 [ $13 >> 2 ] | 0 ; $339 = HEAP32 [ $15 >> 2 ] | 0 ; $340 = HEAP32 [ $16 >> 2 ] | 0 ; $341 = HEAP32 [ $17 >> 2 ] | 0 ; _png_set_IHDR ( $334 , $335 , $336 , $337 , $338 , 0 , $339 , $340 , $341 ) ; $342 = $4 ; $343 = $5 ; _png_free_data ( $342 , $343 , 4096 , - 1 ) ; $344 = $4 ; $345 = $5 ; _png_set_invalid ( $344 , $345 , 8 ) ; $3 = 128 ; $346 = $3 ; STACKTOP = sp ; return ( $346 | 0 ) ; } function _opng_reduce_to_palette ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 ; var $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 ; var $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 ; var $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 ; var $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 , $208 = 0 ; var $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 , $226 = 0 ; var $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 , $244 = 0 ; var $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 , $258 = 0 , $259 = 0 , $26 = 0 , $260 = 0 , $261 = 0 , $262 = 0 ; var $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 , $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 , $270 = 0 , $271 = 0 , $272 = 0 , $273 = 0 , $274 = 0 , $275 = 0 , $276 = 0 , $277 = 0 , $278 = 0 , $279 = 0 , $28 = 0 , $280 = 0 ; var $281 = 0 , $282 = 0 , $283 = 0 , $284 = 0 , $285 = 0 , $286 = 0 , $287 = 0 , $288 = 0 , $289 = 0 , $29 = 0 , $290 = 0 , $291 = 0 , $292 = 0 , $293 = 0 , $294 = 0 , $295 = 0 , $296 = 0 , $297 = 0 , $298 = 0 , $299 = 0 ; var $3 = 0 , $30 = 0 , $300 = 0 , $301 = 0 , $302 = 0 , $303 = 0 , $304 = 0 , $305 = 0 , $306 = 0 , $307 = 0 , $308 = 0 , $309 = 0 , $31 = 0 , $310 = 0 , $311 = 0 , $312 = 0 , $313 = 0 , $314 = 0 , $315 = 0 , $316 = 0 ; var $317 = 0 , $318 = 0 , $319 = 0 , $32 = 0 , $320 = 0 , $321 = 0 , $322 = 0 , $323 = 0 , $324 = 0 , $325 = 0 , $326 = 0 , $327 = 0 , $328 = 0 , $329 = 0 , $33 = 0 , $330 = 0 , $331 = 0 , $332 = 0 , $333 = 0 , $334 = 0 ; var $335 = 0 , $336 = 0 , $337 = 0 , $338 = 0 , $339 = 0 , $34 = 0 , $340 = 0 , $341 = 0 , $342 = 0 , $343 = 0 , $344 = 0 , $345 = 0 , $346 = 0 , $347 = 0 , $348 = 0 , $349 = 0 , $35 = 0 , $350 = 0 , $351 = 0 , $352 = 0 ; var $353 = 0 , $354 = 0 , $355 = 0 , $356 = 0 , $357 = 0 , $358 = 0 , $359 = 0 , $36 = 0 , $360 = 0 , $361 = 0 , $362 = 0 , $363 = 0 , $364 = 0 , $365 = 0 , $366 = 0 , $367 = 0 , $368 = 0 , $369 = 0 , $37 = 0 , $370 = 0 ; var $371 = 0 , $372 = 0 , $373 = 0 , $374 = 0 , $375 = 0 , $376 = 0 , $377 = 0 , $378 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 ; var $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 ; var $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 ; var $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 1184 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 1184 | 0 ) ; $8 = sp + 116 | 0 ; $12 = sp + 100 | 0 ; $13 = sp + 96 | 0 ; $14 = sp + 92 | 0 ; $15 = sp + 88 | 0 ; $16 = sp + 84 | 0 ; $17 = sp + 80 | 0 ; $18 = sp + 76 | 0 ; $21 = sp + 408 | 0 ; $22 = sp + 152 | 0 ; $23 = sp + 64 | 0 ; $24 = sp + 60 | 0 ; $25 = sp + 56 | 0 ; $26 = sp + 52 | 0 ; $37 = sp + 8 | 0 ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $40 = $4 ; $41 = $5 ; ( _png_get_IHDR ( $40 , $41 , $13 , $12 , $18 , $14 , $15 , $16 , $17 ) | 0 ) ; $42 = HEAP32 [ $18 >> 2 ] | 0 ; $43 = ( $42 | 0 ) != ( 8 ) ; if ( $43 ) { $3 = 0 ; $378 = $3 ; STACKTOP = sp ; return ( $378 | 0 ) ; } $44 = HEAP32 [ $14 >> 2 ] | 0 ; $45 = $44 & 1 ; $46 = ( $45 | 0 ) != ( 0 ) ; if ( $46 ) { ___assert_fail ( ( 21147 | 0 ) , ( 21165 | 0 ) , 802 , ( 21177 | 0 ) ) ; // unreachable; } $47 = $4 ; $48 = $5 ; $49 = ( _png_get_rows ( $47 , $48 ) | 0 ) ; $9 = $49 ; $50 = $4 ; $51 = $5 ; $52 = ( _png_get_channels ( $50 , $51 ) | 0 ) ; $53 = $52 & 255 ; $20 = $53 ; $54 = $4 ; $55 = HEAP32 [ $13 >> 2 ] | 0 ; $56 = ( _png_malloc ( $54 , $55 ) | 0 ) ; $11 = $56 ; $57 = HEAP32 [ $13 >> 2 ] | 0 ; HEAP32 [ $8 >> 2 ] = $57 ; $58 = ( ( ( $8 ) ) + 4 | 0 ) ; HEAP32 [ $58 >> 2 ] = 0 ; $59 = HEAP32 [ $14 >> 2 ] | 0 ; $60 = $59 & 255 ; $61 = ( ( ( $8 ) ) + 8 | 0 ) ; HEAP8 [ $61 >> 0 ] = $60 ; $62 = HEAP32 [ $18 >> 2 ] | 0 ; $63 = $62 & 255 ; $64 = ( ( ( $8 ) ) + 9 | 0 ) ; HEAP8 [ $64 >> 0 ] = $63 ; $65 = $20 ; $66 = $65 & 255 ; $67 = ( ( ( $8 ) ) + 10 | 0 ) ; HEAP8 [ $67 >> 0 ] = $66 ; $68 = ( ( ( $8 ) ) + 11 | 0 ) ; HEAP8 [ $68 >> 0 ] = 0 ; HEAP32 [ $25 >> 2 ] = 0 ; HEAP32 [ $24 >> 2 ] = 0 ; HEAP32 [ $23 >> 2 ] = 0 ; $69 = $4 ; $70 = $5 ; ( _png_get_tRNS ( $69 , $70 , 0 , 0 , $23 ) | 0 ) ; $36 = 256 ; $35 = 256 ; $34 = 256 ; $33 = 256 ; $32 = 256 ; $38 = 0 ; L8 : while ( 1 ) { $71 = $38 ; $72 = HEAP32 [ $12 >> 2 ] | 0 ; $73 = ( $71 >>> 0 ) < ( $72 >>> 0 ) ; if ( ! ( $73 ) ) { label = 27 ; break ; } $74 = $9 ; $75 = HEAP32 [ $74 >> 2 ] | 0 ; $10 = $75 ; $76 = HEAP32 [ $23 >> 2 ] | 0 ; $77 = $9 ; $78 = HEAP32 [ $77 >> 2 ] | 0 ; $79 = $11 ; _opng_get_alpha_row ( $8 , $76 , $78 , $79 ) ; $80 = HEAP32 [ $14 >> 2 ] | 0 ; $81 = $80 & 2 ; $82 = ( $81 | 0 ) != ( 0 ) ; $39 = 0 ; L11 : do { if ( $82 ) { while ( 1 ) { $83 = $39 ; $84 = HEAP32 [ $13 >> 2 ] | 0 ; $85 = ( $83 >>> 0 ) < ( $84 >>> 0 ) ; if ( ! ( $85 ) ) { break L11 ; } $86 = $10 ; $87 = HEAP8 [ $86 >> 0 ] | 0 ; $88 = $87 & 255 ; $28 = $88 ; $89 = $10 ; $90 = ( ( ( $89 ) ) + 1 | 0 ) ; $91 = HEAP8 [ $90 >> 0 ] | 0 ; $92 = $91 & 255 ; $29 = $92 ; $93 = $10 ; $94 = ( ( ( $93 ) ) + 2 | 0 ) ; $95 = HEAP8 [ $94 >> 0 ] | 0 ; $96 = $95 & 255 ; $30 = $96 ; $97 = $11 ; $98 = $39 ; $99 = ( ( $97 ) + ( $98 ) | 0 ) ; $100 = HEAP8 [ $99 >> 0 ] | 0 ; $101 = $100 & 255 ; $31 = $101 ; $102 = $28 ; $103 = $33 ; $104 = ( $102 | 0 ) != ( $103 | 0 ) ; if ( $104 ) { label = 13 ; } else { $105 = $29 ; $106 = $34 ; $107 = ( $105 | 0 ) != ( $106 | 0 ) ; if ( $107 ) { label = 13 ; } else { $108 = $30 ; $109 = $35 ; $110 = ( $108 | 0 ) != ( $109 | 0 ) ; if ( $110 ) { label = 13 ; } else { $111 = $31 ; $112 = $36 ; $113 = ( $111 | 0 ) != ( $112 | 0 ) ; if ( $113 ) { label = 13 ; } } } } if ( ( label | 0 ) == 13 ) { label = 0 ; $114 = $28 ; $33 = $114 ; $115 = $29 ; $34 = $115 ; $116 = $30 ; $35 = $116 ; $117 = $31 ; $36 = $117 ; $118 = $28 ; $119 = $29 ; $120 = $30 ; $121 = $31 ; $122 = ( _opng_insert_palette_entry ( $21 , $24 , $22 , $25 , 256 , $118 , $119 , $120 , $121 , $26 ) | 0 ) ; $123 = ( $122 | 0 ) < ( 0 ) ; if ( $123 ) { break ; } } $127 = $39 ; $128 = ( ( $127 ) + 1 ) | 0 ; $39 = $128 ; $129 = $20 ; $130 = $10 ; $131 = ( ( $130 ) + ( $129 ) | 0 ) ; $10 = $131 ; } $124 = HEAP32 [ $24 >> 2 ] | 0 ; $125 = ( $124 | 0 ) < ( 0 ) ; if ( ! ( $125 ) ) { label = 15 ; break L8 ; } $126 = HEAP32 [ $12 >> 2 ] | 0 ; $38 = $126 ; } else { while ( 1 ) { $132 = $39 ; $133 = HEAP32 [ $13 >> 2 ] | 0 ; $134 = ( $132 >>> 0 ) < ( $133 >>> 0 ) ; if ( ! ( $134 ) ) { break L11 ; } $135 = $10 ; $136 = HEAP8 [ $135 >> 0 ] | 0 ; $137 = $136 & 255 ; $27 = $137 ; $138 = $11 ; $139 = $39 ; $140 = ( ( $138 ) + ( $139 ) | 0 ) ; $141 = HEAP8 [ $140 >> 0 ] | 0 ; $142 = $141 & 255 ; $31 = $142 ; $143 = $27 ; $144 = $32 ; $145 = ( $143 | 0 ) != ( $144 | 0 ) ; if ( $145 ) { label = 21 ; } else { $146 = $31 ; $147 = $36 ; $148 = ( $146 | 0 ) != ( $147 | 0 ) ; if ( $148 ) { label = 21 ; } } if ( ( label | 0 ) == 21 ) { label = 0 ; $149 = $27 ; $32 = $149 ; $150 = $31 ; $36 = $150 ; $151 = $27 ; $152 = $27 ; $153 = $27 ; $154 = $31 ; $155 = ( _opng_insert_palette_entry ( $21 , $24 , $22 , $25 , 256 , $151 , $152 , $153 , $154 , $26 ) | 0 ) ; $156 = ( $155 | 0 ) < ( 0 ) ; if ( $156 ) { break ; } } $160 = $39 ; $161 = ( ( $160 ) + 1 ) | 0 ; $39 = $161 ; $162 = $20 ; $163 = $10 ; $164 = ( ( $163 ) + ( $162 ) | 0 ) ; $10 = $164 ; } $157 = HEAP32 [ $24 >> 2 ] | 0 ; $158 = ( $157 | 0 ) < ( 0 ) ; if ( ! ( $158 ) ) { label = 23 ; break L8 ; } $159 = HEAP32 [ $12 >> 2 ] | 0 ; $38 = $159 ; } } while ( 0 ) ; $165 = $38 ; $166 = ( ( $165 ) + 1 ) | 0 ; $38 = $166 ; $167 = $9 ; $168 = ( ( ( $167 ) ) + 4 | 0 ) ; $9 = $168 ; } if ( ( label | 0 ) == 15 ) { ___assert_fail ( ( 21200 | 0 ) , ( 21165 | 0 ) , 844 , ( 21177 | 0 ) ) ; // unreachable; } else if ( ( label | 0 ) == 23 ) { ___assert_fail ( ( 21200 | 0 ) , ( 21165 | 0 ) , 866 , ( 21177 | 0 ) ) ; // unreachable; } else if ( ( label | 0 ) == 27 ) { $169 = HEAP32 [ $24 >> 2 ] | 0 ; $170 = ( $169 | 0 ) >= ( 0 ) ; if ( $170 ) { $171 = $4 ; $172 = $5 ; $173 = ( _png_get_bKGD ( $171 , $172 , $37 ) | 0 ) ; $174 = ( $173 | 0 ) != ( 0 ) ; if ( $174 ) { $175 = HEAP32 [ $14 >> 2 ] | 0 ; $176 = $175 & 2 ; $177 = ( $176 | 0 ) != ( 0 ) ; $178 = HEAP32 [ $37 >> 2 ] | 0 ; if ( $177 ) { $179 = ( ( ( $178 ) ) + 2 | 0 ) ; $180 = HEAP16 [ $179 >> 1 ] | 0 ; $181 = $180 & 65535 ; $28 = $181 ; $182 = HEAP32 [ $37 >> 2 ] | 0 ; $183 = ( ( ( $182 ) ) + 4 | 0 ) ; $184 = HEAP16 [ $183 >> 1 ] | 0 ; $185 = $184 & 65535 ; $29 = $185 ; $186 = HEAP32 [ $37 >> 2 ] | 0 ; $187 = ( ( ( $186 ) ) + 6 | 0 ) ; $188 = HEAP16 [ $187 >> 1 ] | 0 ; $189 = $188 & 65535 ; $30 = $189 ; } else { $190 = ( ( ( $178 ) ) + 8 | 0 ) ; $191 = HEAP16 [ $190 >> 1 ] | 0 ; $192 = $191 & 65535 ; $30 = $192 ; $29 = $192 ; $28 = $192 ; } $193 = $28 ; $194 = $29 ; $195 = $30 ; ( _opng_insert_palette_entry ( $21 , $24 , $22 , $25 , 256 , $193 , $194 , $195 , 256 , $26 ) | 0 ) ; $196 = HEAP32 [ $26 >> 2 ] | 0 ; $197 = ( $196 | 0 ) >= ( 0 ) ; if ( $197 ) { $198 = HEAP32 [ $26 >> 2 ] | 0 ; $199 = $198 & 255 ; $200 = HEAP32 [ $37 >> 2 ] | 0 ; HEAP8 [ $200 >> 0 ] = $199 ; } } } $201 = HEAP32 [ $24 >> 2 ] | 0 ; $202 = ( $201 | 0 ) >= ( 0 ) ; do { if ( $202 ) { $203 = HEAP32 [ $24 >> 2 ] | 0 ; $204 = ( $203 | 0 ) > ( 0 ) ; $205 = HEAP32 [ $24 >> 2 ] | 0 ; $206 = ( $205 | 0 ) <= ( 256 ) ; $or$cond = $204 & $206 ; if ( ! ( $or$cond ) ) { ___assert_fail ( ( 21216 | 0 ) , ( 21165 | 0 ) , 905 , ( 21177 | 0 ) ) ; // unreachable; } $207 = HEAP32 [ $25 >> 2 ] | 0 ; $208 = ( $207 | 0 ) >= ( 0 ) ; if ( ! ( $208 ) ) { ___assert_fail ( ( 21254 | 0 ) , ( 21165 | 0 ) , 906 , ( 21177 | 0 ) ) ; // unreachable; } $209 = HEAP32 [ $25 >> 2 ] | 0 ; $210 = HEAP32 [ $24 >> 2 ] | 0 ; $211 = ( $209 | 0 ) <= ( $210 | 0 ) ; if ( ! ( $211 ) ) { ___assert_fail ( ( 21254 | 0 ) , ( 21165 | 0 ) , 906 , ( 21177 | 0 ) ) ; // unreachable; } $212 = HEAP32 [ $24 >> 2 ] | 0 ; $213 = ( $212 | 0 ) <= ( 2 ) ; do { if ( $213 ) { $19 = 1 ; } else { $214 = HEAP32 [ $24 >> 2 ] | 0 ; $215 = ( $214 | 0 ) <= ( 4 ) ; if ( $215 ) { $19 = 2 ; break ; } $216 = HEAP32 [ $24 >> 2 ] | 0 ; $217 = ( $216 | 0 ) <= ( 16 ) ; if ( $217 ) { $19 = 4 ; break ; } else { $19 = 8 ; break ; } } } while ( 0 ) ; $218 = $20 ; $219 = $218 << 3 ; $220 = $19 ; $221 = ( $219 | 0 ) == ( $220 | 0 ) ; if ( ! ( $221 ) ) { $222 = HEAP32 [ $24 >> 2 ] | 0 ; $223 = ( $222 * 3 ) | 0 ; $224 = HEAP32 [ $25 >> 2 ] | 0 ; $225 = ( ( $223 ) + ( $224 ) ) | 0 ; $226 = $225 << 3 ; $227 = $20 ; $228 = $227 << 3 ; $229 = $19 ; $230 = ( ( $228 ) - ( $229 ) ) | 0 ; $231 = ( ( $226 | 0 ) / ( $230 | 0 ) ) & - 1 ; $232 = HEAP32 [ $13 >> 2 ] | 0 ; $233 = ( ( $231 >>> 0 ) / ( $232 >>> 0 ) ) & - 1 ; $234 = HEAP32 [ $12 >> 2 ] | 0 ; $235 = ( ( $233 >>> 0 ) / ( $234 >>> 0 ) ) & - 1 ; $236 = ( $235 >>> 0 ) >= ( 1 ) ; if ( ! ( $236 ) ) { break ; } } HEAP32 [ $24 >> 2 ] = - 1 ; } } while ( 0 ) ; $237 = HEAP32 [ $24 >> 2 ] | 0 ; $238 = ( $237 | 0 ) < ( 0 ) ; $239 = $4 ; if ( $238 ) { $240 = $11 ; _png_free ( $239 , $240 ) ; $3 = 0 ; $378 = $3 ; STACKTOP = sp ; return ( $378 | 0 ) ; } $241 = $5 ; $242 = ( _png_get_rows ( $239 , $241 ) | 0 ) ; $9 = $242 ; HEAP32 [ $26 >> 2 ] = - 1 ; $36 = - 1 ; $35 = - 1 ; $34 = - 1 ; $33 = - 1 ; $38 = 0 ; L75 : while ( 1 ) { $243 = $38 ; $244 = HEAP32 [ $12 >> 2 ] | 0 ; $245 = ( $243 >>> 0 ) < ( $244 >>> 0 ) ; if ( ! ( $245 ) ) { label = 74 ; break ; } $246 = $9 ; $247 = HEAP32 [ $246 >> 2 ] | 0 ; $10 = $247 ; $248 = HEAP32 [ $23 >> 2 ] | 0 ; $249 = $9 ; $250 = HEAP32 [ $249 >> 2 ] | 0 ; $251 = $11 ; _opng_get_alpha_row ( $8 , $248 , $250 , $251 ) ; $252 = HEAP32 [ $14 >> 2 ] | 0 ; $253 = $252 & 2 ; $254 = ( $253 | 0 ) != ( 0 ) ; $39 = 0 ; L78 : do { if ( $254 ) { while ( 1 ) { $255 = $39 ; $256 = HEAP32 [ $13 >> 2 ] | 0 ; $257 = ( $255 >>> 0 ) < ( $256 >>> 0 ) ; if ( ! ( $257 ) ) { break L78 ; } $258 = $10 ; $259 = HEAP8 [ $258 >> 0 ] | 0 ; $260 = $259 & 255 ; $28 = $260 ; $261 = $10 ; $262 = ( ( ( $261 ) ) + 1 | 0 ) ; $263 = HEAP8 [ $262 >> 0 ] | 0 ; $264 = $263 & 255 ; $29 = $264 ; $265 = $10 ; $266 = ( ( ( $265 ) ) + 2 | 0 ) ; $267 = HEAP8 [ $266 >> 0 ] | 0 ; $268 = $267 & 255 ; $30 = $268 ; $269 = $11 ; $270 = $39 ; $271 = ( ( $269 ) + ( $270 ) | 0 ) ; $272 = HEAP8 [ $271 >> 0 ] | 0 ; $273 = $272 & 255 ; $31 = $273 ; $274 = $28 ; $275 = $33 ; $276 = ( $274 | 0 ) != ( $275 | 0 ) ; if ( $276 ) { label = 60 ; } else { $277 = $29 ; $278 = $34 ; $279 = ( $277 | 0 ) != ( $278 | 0 ) ; if ( $279 ) { label = 60 ; } else { $280 = $30 ; $281 = $35 ; $282 = ( $280 | 0 ) != ( $281 | 0 ) ; if ( $282 ) { label = 60 ; } else { $283 = $31 ; $284 = $36 ; $285 = ( $283 | 0 ) != ( $284 | 0 ) ; if ( $285 ) { label = 60 ; } } } } if ( ( label | 0 ) == 60 ) { label = 0 ; $286 = $28 ; $33 = $286 ; $287 = $29 ; $34 = $287 ; $288 = $30 ; $35 = $288 ; $289 = $31 ; $36 = $289 ; $290 = $28 ; $291 = $29 ; $292 = $30 ; $293 = $31 ; $294 = ( _opng_insert_palette_entry ( $21 , $24 , $22 , $25 , 256 , $290 , $291 , $292 , $293 , $26 ) | 0 ) ; $295 = ( $294 | 0 ) != ( 0 ) ; if ( $295 ) { HEAP32 [ $26 >> 2 ] = - 1 ; } } $296 = HEAP32 [ $26 >> 2 ] | 0 ; $297 = ( $296 | 0 ) >= ( 0 ) ; if ( ! ( $297 ) ) { label = 63 ; break L75 ; } $298 = HEAP32 [ $26 >> 2 ] | 0 ; $299 = $298 & 255 ; $300 = $9 ; $301 = HEAP32 [ $300 >> 2 ] | 0 ; $302 = $39 ; $303 = ( ( $301 ) + ( $302 ) | 0 ) ; HEAP8 [ $303 >> 0 ] = $299 ; $304 = $39 ; $305 = ( ( $304 ) + 1 ) | 0 ; $39 = $305 ; $306 = $20 ; $307 = $10 ; $308 = ( ( $307 ) + ( $306 ) | 0 ) ; $10 = $308 ; } } else { while ( 1 ) { $309 = $39 ; $310 = HEAP32 [ $13 >> 2 ] | 0 ; $311 = ( $309 >>> 0 ) < ( $310 >>> 0 ) ; if ( ! ( $311 ) ) { break L78 ; } $312 = $10 ; $313 = HEAP8 [ $312 >> 0 ] | 0 ; $314 = $313 & 255 ; $27 = $314 ; $315 = $11 ; $316 = $39 ; $317 = ( ( $315 ) + ( $316 ) | 0 ) ; $318 = HEAP8 [ $317 >> 0 ] | 0 ; $319 = $318 & 255 ; $31 = $319 ; $320 = $27 ; $321 = $32 ; $322 = ( $320 | 0 ) != ( $321 | 0 ) ; if ( $322 ) { label = 68 ; } else { $323 = $31 ; $324 = $36 ; $325 = ( $323 | 0 ) != ( $324 | 0 ) ; if ( $325 ) { label = 68 ; } } if ( ( label | 0 ) == 68 ) { label = 0 ; $326 = $27 ; $32 = $326 ; $327 = $31 ; $36 = $327 ; $328 = $27 ; $329 = $27 ; $330 = $27 ; $331 = $31 ; $332 = ( _opng_insert_palette_entry ( $21 , $24 , $22 , $25 , 256 , $328 , $329 , $330 , $331 , $26 ) | 0 ) ; $333 = ( $332 | 0 ) != ( 0 ) ; if ( $333 ) { HEAP32 [ $26 >> 2 ] = - 1 ; } } $334 = HEAP32 [ $26 >> 2 ] | 0 ; $335 = ( $334 | 0 ) >= ( 0 ) ; if ( ! ( $335 ) ) { label = 71 ; break L75 ; } $336 = HEAP32 [ $26 >> 2 ] | 0 ; $337 = $336 & 255 ; $338 = $9 ; $339 = HEAP32 [ $338 >> 2 ] | 0 ; $340 = $39 ; $341 = ( ( $339 ) + ( $340 ) | 0 ) ; HEAP8 [ $341 >> 0 ] = $337 ; $342 = $39 ; $343 = ( ( $342 ) + 1 ) | 0 ; $39 = $343 ; $344 = $20 ; $345 = $10 ; $346 = ( ( $345 ) + ( $344 ) | 0 ) ; $10 = $346 ; } } } while ( 0 ) ; $347 = $38 ; $348 = ( ( $347 ) + 1 ) | 0 ; $38 = $348 ; $349 = $9 ; $350 = ( ( ( $349 ) ) + 4 | 0 ) ; $9 = $350 ; } if ( ( label | 0 ) == 63 ) { ___assert_fail ( ( 21297 | 0 ) , ( 21165 | 0 ) , 957 , ( 21177 | 0 ) ) ; // unreachable; } else if ( ( label | 0 ) == 71 ) { ___assert_fail ( ( 21297 | 0 ) , ( 21165 | 0 ) , 977 , ( 21177 | 0 ) ) ; // unreachable; } else if ( ( label | 0 ) == 74 ) { $351 = $4 ; $352 = $5 ; $353 = HEAP32 [ $13 >> 2 ] | 0 ; $354 = HEAP32 [ $12 >> 2 ] | 0 ; $355 = HEAP32 [ $15 >> 2 ] | 0 ; $356 = HEAP32 [ $16 >> 2 ] | 0 ; $357 = HEAP32 [ $17 >> 2 ] | 0 ; _png_set_IHDR ( $351 , $352 , $353 , $354 , 8 , 3 , $355 , $356 , $357 ) ; $358 = $4 ; $359 = $5 ; $360 = HEAP32 [ $24 >> 2 ] | 0 ; _png_set_PLTE ( $358 , $359 , $21 , $360 ) ; $361 = HEAP32 [ $25 >> 2 ] | 0 ; $362 = ( $361 | 0 ) > ( 0 ) ; if ( $362 ) { $363 = $4 ; $364 = $5 ; $365 = HEAP32 [ $25 >> 2 ] | 0 ; _png_set_tRNS ( $363 , $364 , $22 , $365 , 0 ) ; } $366 = $4 ; $367 = $11 ; _png_free ( $366 , $367 ) ; $7 = 16 ; $368 = $6 ; $369 = $368 & 2 ; $370 = ( $369 | 0 ) != ( 0 ) ; if ( $370 ) { $371 = $4 ; $372 = $5 ; $373 = $6 ; $374 = ( _opng_reduce_palette_bits ( $371 , $372 , $373 ) | 0 ) ; $375 = $7 ; $376 = $375 | $374 ; $7 = $376 ; } $377 = $7 ; $3 = $377 ; $378 = $3 ; STACKTOP = sp ; return ( $378 | 0 ) ; } } return ( 0 ) | 0 ; } function _opng_get_alpha_row ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 ; var $136 = 0 , $137 = 0 , $138 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $30 = 0 ; var $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 ; var $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 ; var $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 ; var $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 48 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 48 | 0 ) ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $7 = $3 ; $18 = $4 ; $19 = HEAP32 [ $18 >> 2 ] | 0 ; $9 = $19 ; $20 = $4 ; $21 = ( ( ( $20 ) ) + 8 | 0 ) ; $22 = HEAP8 [ $21 >> 0 ] | 0 ; $23 = $22 & 255 ; $10 = $23 ; $24 = $4 ; $25 = ( ( ( $24 ) ) + 9 | 0 ) ; $26 = HEAP8 [ $25 >> 0 ] | 0 ; $27 = $26 & 255 ; $11 = $27 ; $28 = $4 ; $29 = ( ( ( $28 ) ) + 10 | 0 ) ; $30 = HEAP8 [ $29 >> 0 ] | 0 ; $31 = $30 & 255 ; $12 = $31 ; $32 = $10 ; $33 = $32 & 1 ; $34 = ( $33 | 0 ) != ( 0 ) ; if ( $34 ) { ___assert_fail ( ( 21147 | 0 ) , ( 21165 | 0 ) , 267 , ( 21551 | 0 ) ) ; // unreachable; } $35 = $11 ; $36 = ( $35 | 0 ) == ( 8 ) ; if ( ! ( $36 ) ) { ___assert_fail ( ( 21570 | 0 ) , ( 21165 | 0 ) , 268 , ( 21551 | 0 ) ) ; // unreachable; } $37 = $10 ; $38 = $37 & 4 ; $39 = ( $38 | 0 ) != ( 0 ) ; if ( $39 ) { $120 = $12 ; $121 = ( $120 | 0 ) > ( 1 ) ; if ( ! ( $121 ) ) { ___assert_fail ( ( 21629 | 0 ) , ( 21165 | 0 ) , 303 , ( 21551 | 0 ) ) ; // unreachable; } $122 = $6 ; $123 = $12 ; $124 = ( ( $123 ) - 1 ) | 0 ; $125 = ( ( $122 ) + ( $124 ) | 0 ) ; $8 = $125 ; $17 = 0 ; while ( 1 ) { $126 = $17 ; $127 = $9 ; $128 = ( $126 >>> 0 ) < ( $127 >>> 0 ) ; if ( ! ( $128 ) ) { break ; } $129 = $8 ; $130 = HEAP8 [ $129 >> 0 ] | 0 ; $131 = $7 ; HEAP8 [ $131 >> 0 ] = $130 ; $132 = $17 ; $133 = ( ( $132 ) + 1 ) | 0 ; $17 = $133 ; $134 = $12 ; $135 = $8 ; $136 = ( ( $135 ) + ( $134 ) | 0 ) ; $8 = $136 ; $137 = $7 ; $138 = ( ( ( $137 ) ) + 1 | 0 ) ; $7 = $138 ; } STACKTOP = sp ; return ; } $40 = $5 ; $41 = ( $40 | 0 ) == ( 0 | 0 ) ; if ( $41 ) { $42 = $7 ; $43 = $9 ; _memset ( ( $42 | 0 ) , - 1 , ( $43 | 0 ) ) | 0 ; STACKTOP = sp ; return ; } $44 = $10 ; $45 = ( $44 | 0 ) == ( 2 ) ; if ( ! ( $45 ) ) { $94 = $10 ; $95 = ( $94 | 0 ) == ( 0 ) ; if ( ! ( $95 ) ) { ___assert_fail ( ( 21599 | 0 ) , ( 21165 | 0 ) , 293 , ( 21551 | 0 ) ) ; // unreachable; } $96 = $12 ; $97 = ( $96 | 0 ) == ( 1 ) ; if ( ! ( $97 ) ) { ___assert_fail ( ( 21615 | 0 ) , ( 21165 | 0 ) , 294 , ( 21551 | 0 ) ) ; // unreachable; } $98 = $5 ; $99 = ( ( ( $98 ) ) + 8 | 0 ) ; $100 = HEAP16 [ $99 >> 1 ] | 0 ; $101 = $100 & 255 ; $16 = $101 ; $17 = 0 ; while ( 1 ) { $102 = $17 ; $103 = $9 ; $104 = ( $102 >>> 0 ) < ( $103 >>> 0 ) ; if ( ! ( $104 ) ) { break ; } $105 = $6 ; $106 = $17 ; $107 = ( ( $105 ) + ( $106 ) | 0 ) ; $108 = HEAP8 [ $107 >> 0 ] | 0 ; $109 = $108 & 255 ; $110 = $16 ; $111 = $110 & 255 ; $112 = ( $109 | 0 ) == ( $111 | 0 ) ; $113 = $112 ? 0 : 255 ; $114 = $113 & 255 ; $115 = $7 ; $116 = $17 ; $117 = ( ( $115 ) + ( $116 ) | 0 ) ; HEAP8 [ $117 >> 0 ] = $114 ; $118 = $17 ; $119 = ( ( $118 ) + 1 ) | 0 ; $17 = $119 ; } STACKTOP = sp ; return ; } $46 = $12 ; $47 = ( $46 | 0 ) == ( 3 ) ; if ( ! ( $47 ) ) { ___assert_fail ( ( 21585 | 0 ) , ( 21165 | 0 ) , 280 , ( 21551 | 0 ) ) ; // unreachable; } $48 = $5 ; $49 = ( ( ( $48 ) ) + 2 | 0 ) ; $50 = HEAP16 [ $49 >> 1 ] | 0 ; $51 = $50 & 255 ; $13 = $51 ; $52 = $5 ; $53 = ( ( ( $52 ) ) + 4 | 0 ) ; $54 = HEAP16 [ $53 >> 1 ] | 0 ; $55 = $54 & 255 ; $14 = $55 ; $56 = $5 ; $57 = ( ( ( $56 ) ) + 6 | 0 ) ; $58 = HEAP16 [ $57 >> 1 ] | 0 ; $59 = $58 & 255 ; $15 = $59 ; $60 = $6 ; $8 = $60 ; $17 = 0 ; while ( 1 ) { $61 = $17 ; $62 = $9 ; $63 = ( $61 >>> 0 ) < ( $62 >>> 0 ) ; if ( ! ( $63 ) ) { break ; } $64 = $8 ; $65 = HEAP8 [ $64 >> 0 ] | 0 ; $66 = $65 & 255 ; $67 = $13 ; $68 = $67 & 255 ; $69 = ( $66 | 0 ) == ( $68 | 0 ) ; if ( $69 ) { $70 = $8 ; $71 = ( ( ( $70 ) ) + 1 | 0 ) ; $72 = HEAP8 [ $71 >> 0 ] | 0 ; $73 = $72 & 255 ; $74 = $14 ; $75 = $74 & 255 ; $76 = ( $73 | 0 ) == ( $75 | 0 ) ; if ( $76 ) { $77 = $8 ; $78 = ( ( ( $77 ) ) + 2 | 0 ) ; $79 = HEAP8 [ $78 >> 0 ] | 0 ; $80 = $79 & 255 ; $81 = $15 ; $82 = $81 & 255 ; $83 = ( $80 | 0 ) == ( $82 | 0 ) ; $84 = $83 ; } else { $84 = 0 ; } } else { $84 = 0 ; } $85 = $84 ? 0 : 255 ; $86 = $85 & 255 ; $87 = $7 ; $88 = $17 ; $89 = ( ( $87 ) + ( $88 ) | 0 ) ; HEAP8 [ $89 >> 0 ] = $86 ; $90 = $17 ; $91 = ( ( $90 ) + 1 ) | 0 ; $17 = $91 ; $92 = $8 ; $93 = ( ( ( $92 ) ) + 3 | 0 ) ; $8 = $93 ; } STACKTOP = sp ; return ; } function _opng_insert_palette_entry ( $0 , $1 , $2 , $3 , $4 , $5 , $6 , $7 , $8 , $9 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; $4 = $4 | 0 ; $5 = $5 | 0 ; $6 = $6 | 0 ; $7 = $7 | 0 ; $8 = $8 | 0 ; $9 = $9 | 0 ; var $$sink$sink$sink = 0 , $$sink11$sink = 0 , $$sink14$sink = 0 , $$sink17$sink = 0 , $$sink3$sink$sink = 0 , $$sink8$sink = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 ; var $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 ; var $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 ; var $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 ; var $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 , $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 ; var $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 , $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 ; var $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 , $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 ; var $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 , $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 ; var $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 , $244 = 0 , $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 ; var $258 = 0 , $259 = 0 , $26 = 0 , $260 = 0 , $261 = 0 , $262 = 0 , $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 , $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 , $270 = 0 , $271 = 0 , $272 = 0 , $273 = 0 , $274 = 0 , $275 = 0 ; var $276 = 0 , $277 = 0 , $278 = 0 , $279 = 0 , $28 = 0 , $29 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 ; var $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 ; var $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 ; var $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 64 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 64 | 0 ) ; $11 = $0 ; $12 = $1 ; $13 = $2 ; $14 = $3 ; $15 = $4 ; $16 = $5 ; $17 = $6 ; $18 = $7 ; $19 = $8 ; $20 = $9 ; $26 = $12 ; $27 = HEAP32 [ $26 >> 2 ] | 0 ; $28 = ( $27 | 0 ) >= ( 0 ) ; if ( ! ( $28 ) ) { ___assert_fail ( ( 21381 | 0 ) , ( 21165 | 0 ) , 109 , ( 21429 | 0 ) ) ; // unreachable; } $29 = $12 ; $30 = HEAP32 [ $29 >> 2 ] | 0 ; $31 = $15 ; $32 = ( $30 | 0 ) <= ( $31 | 0 ) ; if ( ! ( $32 ) ) { ___assert_fail ( ( 21381 | 0 ) , ( 21165 | 0 ) , 109 , ( 21429 | 0 ) ) ; // unreachable; } $33 = $14 ; $34 = HEAP32 [ $33 >> 2 ] | 0 ; $35 = ( $34 | 0 ) >= ( 0 ) ; if ( ! ( $35 ) ) { ___assert_fail ( ( 21455 | 0 ) , ( 21165 | 0 ) , 110 , ( 21429 | 0 ) ) ; // unreachable; } $36 = $14 ; $37 = HEAP32 [ $36 >> 2 ] | 0 ; $38 = $12 ; $39 = HEAP32 [ $38 >> 2 ] | 0 ; $40 = ( $37 | 0 ) <= ( $39 | 0 ) ; if ( ! ( $40 ) ) { ___assert_fail ( ( 21455 | 0 ) , ( 21165 | 0 ) , 110 , ( 21429 | 0 ) ) ; // unreachable; } $41 = $19 ; $42 = ( $41 >>> 0 ) < ( 255 ) ; L13 : do { if ( $42 ) { $21 = 0 ; $43 = $14 ; $44 = HEAP32 [ $43 >> 2 ] | 0 ; $45 = ( ( $44 ) - 1 ) | 0 ; $22 = $45 ; while ( 1 ) { $46 = $21 ; $47 = $22 ; $48 = ( $46 | 0 ) <= ( $47 | 0 ) ; if ( ! ( $48 ) ) { break L13 ; } $49 = $21 ; $50 = $22 ; $51 = ( ( $49 ) + ( $50 ) ) | 0 ; $52 = ( ( $51 | 0 ) / 2 ) & - 1 ; $23 = $52 ; $53 = $19 ; $54 = $13 ; $55 = $23 ; $56 = ( ( $54 ) + ( $55 ) | 0 ) ; $57 = HEAP8 [ $56 >> 0 ] | 0 ; $58 = $57 & 255 ; $59 = ( $53 | 0 ) != ( $58 | 0 ) ; do { if ( $59 ) { $60 = $19 ; $61 = $13 ; $62 = $23 ; $63 = ( ( $61 ) + ( $62 ) | 0 ) ; $$sink$sink$sink = $60 ; $$sink3$sink$sink = $63 ; } else { $64 = $16 ; $65 = $11 ; $66 = $23 ; $67 = ( ( $65 ) + ( ( $66 * 3 ) | 0 ) | 0 ) ; $68 = HEAP8 [ $67 >> 0 ] | 0 ; $69 = $68 & 255 ; $70 = ( $64 | 0 ) != ( $69 | 0 ) ; if ( $70 ) { $71 = $16 ; $72 = $11 ; $73 = $23 ; $74 = ( ( $72 ) + ( ( $73 * 3 ) | 0 ) | 0 ) ; $$sink$sink$sink = $71 ; $$sink3$sink$sink = $74 ; break ; } $75 = $17 ; $76 = $11 ; $77 = $23 ; $78 = ( ( $76 ) + ( ( $77 * 3 ) | 0 ) | 0 ) ; $79 = ( ( ( $78 ) ) + 1 | 0 ) ; $80 = HEAP8 [ $79 >> 0 ] | 0 ; $81 = $80 & 255 ; $82 = ( $75 | 0 ) != ( $81 | 0 ) ; if ( $82 ) { $83 = $17 ; $84 = $11 ; $85 = $23 ; $86 = ( ( $84 ) + ( ( $85 * 3 ) | 0 ) | 0 ) ; $87 = ( ( ( $86 ) ) + 1 | 0 ) ; $$sink$sink$sink = $83 ; $$sink3$sink$sink = $87 ; break ; } else { $88 = $18 ; $89 = $11 ; $90 = $23 ; $91 = ( ( $89 ) + ( ( $90 * 3 ) | 0 ) | 0 ) ; $92 = ( ( ( $91 ) ) + 2 | 0 ) ; $$sink$sink$sink = $88 ; $$sink3$sink$sink = $92 ; break ; } } } while ( 0 ) ; $93 = HEAP8 [ $$sink3$sink$sink >> 0 ] | 0 ; $94 = $93 & 255 ; $95 = ( ( $$sink$sink$sink ) - ( $94 ) ) | 0 ; $24 = $95 ; $96 = $24 ; $97 = ( $96 | 0 ) < ( 0 ) ; if ( $97 ) { $98 = $23 ; $99 = ( ( $98 ) - 1 ) | 0 ; $22 = $99 ; continue ; } $100 = $24 ; $101 = ( $100 | 0 ) > ( 0 ) ; $102 = $23 ; if ( ! ( $101 ) ) { break ; } $103 = ( ( $102 ) + 1 ) | 0 ; $21 = $103 ; } $104 = $20 ; HEAP32 [ $104 >> 2 ] = $102 ; $10 = 0 ; $279 = $10 ; STACKTOP = sp ; return ( $279 | 0 ) ; } else { $105 = $14 ; $106 = HEAP32 [ $105 >> 2 ] | 0 ; $21 = $106 ; $107 = $12 ; $108 = HEAP32 [ $107 >> 2 ] | 0 ; $109 = ( ( $108 ) - 1 ) | 0 ; $22 = $109 ; while ( 1 ) { $110 = $21 ; $111 = $22 ; $112 = ( $110 | 0 ) <= ( $111 | 0 ) ; if ( ! ( $112 ) ) { break L13 ; } $113 = $21 ; $114 = $22 ; $115 = ( ( $113 ) + ( $114 ) ) | 0 ; $116 = ( ( $115 | 0 ) / 2 ) & - 1 ; $23 = $116 ; $117 = $16 ; $118 = $11 ; $119 = $23 ; $120 = ( ( $118 ) + ( ( $119 * 3 ) | 0 ) | 0 ) ; $121 = HEAP8 [ $120 >> 0 ] | 0 ; $122 = $121 & 255 ; $123 = ( $117 | 0 ) != ( $122 | 0 ) ; do { if ( $123 ) { $124 = $16 ; $125 = $11 ; $126 = $23 ; $127 = ( ( $125 ) + ( ( $126 * 3 ) | 0 ) | 0 ) ; $$sink11$sink = $127 ; $$sink8$sink = $124 ; } else { $128 = $17 ; $129 = $11 ; $130 = $23 ; $131 = ( ( $129 ) + ( ( $130 * 3 ) | 0 ) | 0 ) ; $132 = ( ( ( $131 ) ) + 1 | 0 ) ; $133 = HEAP8 [ $132 >> 0 ] | 0 ; $134 = $133 & 255 ; $135 = ( $128 | 0 ) != ( $134 | 0 ) ; if ( $135 ) { $136 = $17 ; $137 = $11 ; $138 = $23 ; $139 = ( ( $137 ) + ( ( $138 * 3 ) | 0 ) | 0 ) ; $140 = ( ( ( $139 ) ) + 1 | 0 ) ; $$sink11$sink = $140 ; $$sink8$sink = $136 ; break ; } else { $141 = $18 ; $142 = $11 ; $143 = $23 ; $144 = ( ( $142 ) + ( ( $143 * 3 ) | 0 ) | 0 ) ; $145 = ( ( ( $144 ) ) + 2 | 0 ) ; $$sink11$sink = $145 ; $$sink8$sink = $141 ; break ; } } } while ( 0 ) ; $146 = HEAP8 [ $$sink11$sink >> 0 ] | 0 ; $147 = $146 & 255 ; $148 = ( ( $$sink8$sink ) - ( $147 ) ) | 0 ; $24 = $148 ; $149 = $24 ; $150 = ( $149 | 0 ) < ( 0 ) ; if ( $150 ) { $151 = $23 ; $152 = ( ( $151 ) - 1 ) | 0 ; $22 = $152 ; continue ; } $153 = $24 ; $154 = ( $153 | 0 ) > ( 0 ) ; $155 = $23 ; if ( ! ( $154 ) ) { break ; } $156 = ( ( $155 ) + 1 ) | 0 ; $21 = $156 ; } $157 = $20 ; HEAP32 [ $157 >> 2 ] = $155 ; $10 = 0 ; $279 = $10 ; STACKTOP = sp ; return ( $279 | 0 ) ; } } while ( 0 ) ; $158 = $19 ; $159 = ( $158 >>> 0 ) > ( 255 ) ; L52 : do { if ( $159 ) { $25 = 0 ; while ( 1 ) { $160 = $25 ; $161 = $14 ; $162 = HEAP32 [ $161 >> 2 ] | 0 ; $163 = ( $160 | 0 ) < ( $162 | 0 ) ; if ( ! ( $163 ) ) { break L52 ; } $164 = $16 ; $165 = $11 ; $166 = $25 ; $167 = ( ( $165 ) + ( ( $166 * 3 ) | 0 ) | 0 ) ; $168 = HEAP8 [ $167 >> 0 ] | 0 ; $169 = $168 & 255 ; $170 = ( $164 | 0 ) != ( $169 | 0 ) ; do { if ( $170 ) { $171 = $16 ; $172 = $11 ; $173 = $25 ; $174 = ( ( $172 ) + ( ( $173 * 3 ) | 0 ) | 0 ) ; $$sink14$sink = $171 ; $$sink17$sink = $174 ; } else { $175 = $17 ; $176 = $11 ; $177 = $25 ; $178 = ( ( $176 ) + ( ( $177 * 3 ) | 0 ) | 0 ) ; $179 = ( ( ( $178 ) ) + 1 | 0 ) ; $180 = HEAP8 [ $179 >> 0 ] | 0 ; $181 = $180 & 255 ; $182 = ( $175 | 0 ) != ( $181 | 0 ) ; if ( $182 ) { $183 = $17 ; $184 = $11 ; $185 = $25 ; $186 = ( ( $184 ) + ( ( $185 * 3 ) | 0 ) | 0 ) ; $187 = ( ( ( $186 ) ) + 1 | 0 ) ; $$sink14$sink = $183 ; $$sink17$sink = $187 ; break ; } else { $188 = $18 ; $189 = $11 ; $190 = $25 ; $191 = ( ( $189 ) + ( ( $190 * 3 ) | 0 ) | 0 ) ; $192 = ( ( ( $191 ) ) + 2 | 0 ) ; $$sink14$sink = $188 ; $$sink17$sink = $192 ; break ; } } } while ( 0 ) ; $193 = HEAP8 [ $$sink17$sink >> 0 ] | 0 ; $194 = $193 & 255 ; $195 = ( ( $$sink14$sink ) - ( $194 ) ) | 0 ; $24 = $195 ; $196 = $24 ; $197 = ( $196 | 0 ) == ( 0 ) ; $198 = $25 ; if ( $197 ) { break ; } $200 = ( ( $198 ) + 1 ) | 0 ; $25 = $200 ; } $199 = $20 ; HEAP32 [ $199 >> 2 ] = $198 ; $10 = 0 ; $279 = $10 ; STACKTOP = sp ; return ( $279 | 0 ) ; } } while ( 0 ) ; $201 = $12 ; $202 = HEAP32 [ $201 >> 2 ] | 0 ; $203 = $15 ; $204 = ( $202 | 0 ) >= ( $203 | 0 ) ; if ( $204 ) { $205 = $20 ; HEAP32 [ $205 >> 2 ] = - 1 ; $206 = $14 ; HEAP32 [ $206 >> 2 ] = - 1 ; $207 = $12 ; HEAP32 [ $207 >> 2 ] = - 1 ; $10 = - 1 ; $279 = $10 ; STACKTOP = sp ; return ( $279 | 0 ) ; } $208 = $21 ; $209 = ( $208 | 0 ) >= ( 0 ) ; if ( ! ( $209 ) ) { ___assert_fail ( ( 21501 | 0 ) , ( 21165 | 0 ) , 179 , ( 21429 | 0 ) ) ; // unreachable; } $210 = $21 ; $211 = $12 ; $212 = HEAP32 [ $211 >> 2 ] | 0 ; $213 = ( $210 | 0 ) <= ( $212 | 0 ) ; if ( ! ( $213 ) ) { ___assert_fail ( ( 21501 | 0 ) , ( 21165 | 0 ) , 179 , ( 21429 | 0 ) ) ; // unreachable; } $214 = $12 ; $215 = HEAP32 [ $214 >> 2 ] | 0 ; $25 = $215 ; while ( 1 ) { $216 = $25 ; $217 = $21 ; $218 = ( $216 | 0 ) > ( $217 | 0 ) ; if ( ! ( $218 ) ) { break ; } $219 = $11 ; $220 = $25 ; $221 = ( ( $219 ) + ( ( $220 * 3 ) | 0 ) | 0 ) ; $222 = $11 ; $223 = $25 ; $224 = ( ( $223 ) - 1 ) | 0 ; $225 = ( ( $222 ) + ( ( $224 * 3 ) | 0 ) | 0 ) ; ; HEAP8 [ $221 >> 0 ] = HEAP8 [ $225 >> 0 ] | 0 ; HEAP8 [ $221 + 1 >> 0 ] = HEAP8 [ $225 + 1 >> 0 ] | 0 ; HEAP8 [ $221 + 2 >> 0 ] = HEAP8 [ $225 + 2 >> 0 ] | 0 ; $226 = $25 ; $227 = ( ( $226 ) + - 1 ) | 0 ; $25 = $227 ; } $228 = $16 ; $229 = $228 & 255 ; $230 = $11 ; $231 = $21 ; $232 = ( ( $230 ) + ( ( $231 * 3 ) | 0 ) | 0 ) ; HEAP8 [ $232 >> 0 ] = $229 ; $233 = $17 ; $234 = $233 & 255 ; $235 = $11 ; $236 = $21 ; $237 = ( ( $235 ) + ( ( $236 * 3 ) | 0 ) | 0 ) ; $238 = ( ( ( $237 ) ) + 1 | 0 ) ; HEAP8 [ $238 >> 0 ] = $234 ; $239 = $18 ; $240 = $239 & 255 ; $241 = $11 ; $242 = $21 ; $243 = ( ( $241 ) + ( ( $242 * 3 ) | 0 ) | 0 ) ; $244 = ( ( ( $243 ) ) + 2 | 0 ) ; HEAP8 [ $244 >> 0 ] = $240 ; $245 = $12 ; $246 = HEAP32 [ $245 >> 2 ] | 0 ; $247 = ( ( $246 ) + 1 ) | 0 ; HEAP32 [ $245 >> 2 ] = $247 ; $248 = $19 ; $249 = ( $248 >>> 0 ) < ( 255 ) ; if ( $249 ) { $250 = $21 ; $251 = $14 ; $252 = HEAP32 [ $251 >> 2 ] | 0 ; $253 = ( $250 | 0 ) <= ( $252 | 0 ) ; if ( ! ( $253 ) ) { ___assert_fail ( ( 21533 | 0 ) , ( 21165 | 0 ) , 188 , ( 21429 | 0 ) ) ; // unreachable; } $254 = $14 ; $255 = HEAP32 [ $254 >> 2 ] | 0 ; $25 = $255 ; while ( 1 ) { $256 = $25 ; $257 = $21 ; $258 = ( $256 | 0 ) > ( $257 | 0 ) ; if ( ! ( $258 ) ) { break ; } $259 = $13 ; $260 = $25 ; $261 = ( ( $260 ) - 1 ) | 0 ; $262 = ( ( $259 ) + ( $261 ) | 0 ) ; $263 = HEAP8 [ $262 >> 0 ] | 0 ; $264 = $13 ; $265 = $25 ; $266 = ( ( $264 ) + ( $265 ) | 0 ) ; HEAP8 [ $266 >> 0 ] = $263 ; $267 = $25 ; $268 = ( ( $267 ) + - 1 ) | 0 ; $25 = $268 ; } $269 = $19 ; $270 = $269 & 255 ; $271 = $13 ; $272 = $21 ; $273 = ( ( $271 ) + ( $272 ) | 0 ) ; HEAP8 [ $273 >> 0 ] = $270 ; $274 = $14 ; $275 = HEAP32 [ $274 >> 2 ] | 0 ; $276 = ( ( $275 ) + 1 ) | 0 ; HEAP32 [ $274 >> 2 ] = $276 ; } $277 = $21 ; $278 = $20 ; HEAP32 [ $278 >> 2 ] = $277 ; $10 = 1 ; $279 = $10 ; STACKTOP = sp ; return ( $279 | 0 ) ; } function _opng_reduce_palette_bits ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 ; var $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 ; var $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 ; var $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 ; var $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 ; var $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 ; var $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 ; var $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 112 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 112 | 0 ) ; $10 = sp + 68 | 0 ; $11 = sp + 64 | 0 ; $12 = sp + 60 | 0 ; $13 = sp + 56 | 0 ; $14 = sp + 52 | 0 ; $15 = sp + 48 | 0 ; $16 = sp + 44 | 0 ; $24 = sp + 12 | 0 ; $25 = sp + 8 | 0 ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $28 = $6 ; $29 = $28 & 2 ; $30 = ( $29 | 0 ) != ( 0 ) ; if ( ! ( $30 ) ) { $3 = 0 ; $166 = $3 ; STACKTOP = sp ; return ( $166 | 0 ) ; } $31 = $4 ; $32 = $5 ; ( _png_get_IHDR ( $31 , $32 , $10 , $11 , $16 , $12 , $13 , $14 , $15 ) | 0 ) ; $33 = HEAP32 [ $12 >> 2 ] | 0 ; $34 = ( $33 | 0 ) != ( 3 ) ; if ( $34 ) { $3 = 0 ; $166 = $3 ; STACKTOP = sp ; return ( $166 | 0 ) ; } $35 = $4 ; $36 = $5 ; $37 = ( _png_get_PLTE ( $35 , $36 , $24 , $25 ) | 0 ) ; $38 = ( $37 | 0 ) != ( 0 ) ; if ( ! ( $38 ) ) { HEAP32 [ $25 >> 2 ] = 0 ; } $39 = HEAP32 [ $25 >> 2 ] | 0 ; $40 = ( $39 | 0 ) > ( 16 ) ; if ( $40 ) { $3 = 0 ; $166 = $3 ; STACKTOP = sp ; return ( $166 | 0 ) ; } $41 = HEAP32 [ $25 >> 2 ] | 0 ; $42 = ( $41 | 0 ) > ( 4 ) ; do { if ( $42 ) { $17 = 4 ; } else { $43 = HEAP32 [ $25 >> 2 ] | 0 ; $44 = ( $43 | 0 ) > ( 2 ) ; if ( $44 ) { $17 = 2 ; break ; } $45 = HEAP32 [ $25 >> 2 ] | 0 ; $46 = ( $45 | 0 ) > ( 0 ) ; if ( $46 ) { $17 = 1 ; break ; } else { ___assert_fail ( ( 21308 | 0 ) , ( 21165 | 0 ) , 691 , ( 21324 | 0 ) ) ; // unreachable; } } } while ( 0 ) ; $47 = HEAP32 [ $16 >> 2 ] | 0 ; $48 = $17 ; $49 = ( $47 | 0 ) <= ( $48 | 0 ) ; if ( $49 ) { $50 = HEAP32 [ $16 >> 2 ] | 0 ; $51 = $17 ; $52 = ( $50 | 0 ) == ( $51 | 0 ) ; if ( ! ( $52 ) ) { ___assert_fail ( ( 21349 | 0 ) , ( 21165 | 0 ) , 697 , ( 21324 | 0 ) ) ; // unreachable; } $3 = 0 ; $166 = $3 ; STACKTOP = sp ; return ( $166 | 0 ) ; } $53 = $4 ; $54 = $5 ; $55 = ( _png_get_rows ( $53 , $54 ) | 0 ) ; $7 = $55 ; $56 = HEAP32 [ $16 >> 2 ] | 0 ; $57 = ( $56 | 0 ) == ( 8 ) ; L33 : do { if ( $57 ) { $26 = 0 ; while ( 1 ) { $58 = $26 ; $59 = HEAP32 [ $11 >> 2 ] | 0 ; $60 = ( $58 >>> 0 ) < ( $59 >>> 0 ) ; if ( ! ( $60 ) ) { break L33 ; } $61 = $7 ; $62 = HEAP32 [ $61 >> 2 ] | 0 ; $9 = $62 ; $8 = $62 ; $21 = 8 ; $23 = 0 ; $27 = 0 ; while ( 1 ) { $63 = $27 ; $64 = HEAP32 [ $10 >> 2 ] | 0 ; $65 = ( $63 >>> 0 ) < ( $64 >>> 0 ) ; if ( ! ( $65 ) ) { break ; } $66 = $17 ; $67 = $21 ; $68 = ( ( $67 ) - ( $66 ) ) | 0 ; $21 = $68 ; $69 = $21 ; $70 = ( $69 >>> 0 ) > ( 0 ) ; if ( $70 ) { $71 = $8 ; $72 = HEAP8 [ $71 >> 0 ] | 0 ; $73 = $72 & 255 ; $74 = $21 ; $75 = $73 << $74 ; $76 = $23 ; $77 = $76 | $75 ; $23 = $77 ; } else { $78 = $23 ; $79 = $8 ; $80 = HEAP8 [ $79 >> 0 ] | 0 ; $81 = $80 & 255 ; $82 = $78 | $81 ; $83 = $82 & 255 ; $84 = $9 ; $85 = ( ( ( $84 ) ) + 1 | 0 ) ; $9 = $85 ; HEAP8 [ $84 >> 0 ] = $83 ; $21 = 8 ; $23 = 0 ; } $86 = $8 ; $87 = ( ( ( $86 ) ) + 1 | 0 ) ; $8 = $87 ; $88 = $27 ; $89 = ( ( $88 ) + 1 ) | 0 ; $27 = $89 ; } $90 = $21 ; $91 = ( $90 | 0 ) != ( 0 ) ; if ( $91 ) { $92 = $23 ; $93 = $92 & 255 ; $94 = $9 ; HEAP8 [ $94 >> 0 ] = $93 ; } $95 = $26 ; $96 = ( ( $95 ) + 1 ) | 0 ; $26 = $96 ; $97 = $7 ; $98 = ( ( ( $97 ) ) + 4 | 0 ) ; $7 = $98 ; } } else { $99 = HEAP32 [ $16 >> 2 ] | 0 ; $100 = ( 8 + ( $99 ) ) | 0 ; $101 = 1 << $100 ; $102 = ( ( $101 ) - 256 ) | 0 ; $18 = $102 ; $26 = 0 ; while ( 1 ) { $103 = $26 ; $104 = HEAP32 [ $11 >> 2 ] | 0 ; $105 = ( $103 >>> 0 ) < ( $104 >>> 0 ) ; if ( ! ( $105 ) ) { break L33 ; } $106 = $7 ; $107 = HEAP32 [ $106 >> 2 ] | 0 ; $9 = $107 ; $8 = $107 ; $21 = 8 ; $20 = 8 ; $108 = $18 ; $19 = $108 ; $23 = 0 ; $27 = 0 ; while ( 1 ) { $109 = $27 ; $110 = HEAP32 [ $10 >> 2 ] | 0 ; $111 = ( $109 >>> 0 ) < ( $110 >>> 0 ) ; if ( ! ( $111 ) ) { break ; } $112 = HEAP32 [ $16 >> 2 ] | 0 ; $113 = $20 ; $114 = ( ( $113 ) - ( $112 ) ) | 0 ; $20 = $114 ; $115 = HEAP32 [ $16 >> 2 ] | 0 ; $116 = $19 ; $117 = $116 >>> $115 ; $19 = $117 ; $118 = $8 ; $119 = HEAP8 [ $118 >> 0 ] | 0 ; $120 = $119 & 255 ; $121 = $19 ; $122 = $120 & $121 ; $123 = $20 ; $124 = $122 >>> $123 ; $22 = $124 ; $125 = $17 ; $126 = $21 ; $127 = ( ( $126 ) - ( $125 ) ) | 0 ; $21 = $127 ; $128 = $21 ; $129 = ( $128 >>> 0 ) > ( 0 ) ; if ( $129 ) { $130 = $22 ; $131 = $21 ; $132 = $130 << $131 ; $133 = $23 ; $134 = $133 | $132 ; $23 = $134 ; } else { $135 = $23 ; $136 = $22 ; $137 = $135 | $136 ; $138 = $137 & 255 ; $139 = $9 ; $140 = ( ( ( $139 ) ) + 1 | 0 ) ; $9 = $140 ; HEAP8 [ $139 >> 0 ] = $138 ; $21 = 8 ; $23 = 0 ; } $141 = $20 ; $142 = ( $141 | 0 ) == ( 0 ) ; if ( $142 ) { $20 = 8 ; $143 = $18 ; $19 = $143 ; $144 = $8 ; $145 = ( ( ( $144 ) ) + 1 | 0 ) ; $8 = $145 ; } $146 = $27 ; $147 = ( ( $146 ) + 1 ) | 0 ; $27 = $147 ; } $148 = $21 ; $149 = ( $148 | 0 ) != ( 0 ) ; if ( $149 ) { $150 = $23 ; $151 = $150 & 255 ; $152 = $9 ; HEAP8 [ $152 >> 0 ] = $151 ; } $153 = $26 ; $154 = ( ( $153 ) + 1 ) | 0 ; $26 = $154 ; $155 = $7 ; $156 = ( ( ( $155 ) ) + 4 | 0 ) ; $7 = $156 ; } } } while ( 0 ) ; $157 = $4 ; $158 = $5 ; $159 = HEAP32 [ $10 >> 2 ] | 0 ; $160 = HEAP32 [ $11 >> 2 ] | 0 ; $161 = $17 ; $162 = HEAP32 [ $12 >> 2 ] | 0 ; $163 = HEAP32 [ $13 >> 2 ] | 0 ; $164 = HEAP32 [ $14 >> 2 ] | 0 ; $165 = HEAP32 [ $15 >> 2 ] | 0 ; _png_set_IHDR ( $157 , $158 , $159 , $160 , $161 , $162 , $163 , $164 , $165 ) ; $3 = 2 ; $166 = $3 ; STACKTOP = sp ; return ( $166 | 0 ) ; } function _opng_analyze_sample_usage ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 ; var $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 ; var $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 ; var $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 ; var $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 ; var $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 64 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 64 | 0 ) ; $15 = sp + 8 | 0 ; $3 = $0 ; $4 = $1 ; $5 = $2 ; $18 = $3 ; $19 = $4 ; $20 = ( _png_get_image_height ( $18 , $19 ) | 0 ) ; $9 = $20 ; $21 = $3 ; $22 = $4 ; $23 = ( _png_get_image_width ( $21 , $22 ) | 0 ) ; $8 = $23 ; $24 = $3 ; $25 = $4 ; $26 = ( _png_get_bit_depth ( $24 , $25 ) | 0 ) ; $27 = $26 & 255 ; $10 = $27 ; $28 = $3 ; $29 = $4 ; $30 = ( _png_get_rows ( $28 , $29 ) | 0 ) ; $6 = $30 ; $31 = $5 ; _memset ( ( $31 | 0 ) , 0 , 256 ) | 0 ; $32 = $10 ; $33 = ( $32 | 0 ) == ( 8 ) ; L1 : do { if ( $33 ) { $16 = 0 ; while ( 1 ) { $34 = $16 ; $35 = $9 ; $36 = ( $34 >>> 0 ) < ( $35 >>> 0 ) ; if ( ! ( $36 ) ) { break L1 ; } $17 = 0 ; $37 = $6 ; $38 = HEAP32 [ $37 >> 2 ] | 0 ; $7 = $38 ; while ( 1 ) { $39 = $17 ; $40 = $8 ; $41 = ( $39 >>> 0 ) < ( $40 >>> 0 ) ; if ( ! ( $41 ) ) { break ; } $42 = $5 ; $43 = $7 ; $44 = HEAP8 [ $43 >> 0 ] | 0 ; $45 = $44 & 255 ; $46 = ( ( $42 ) + ( $45 ) | 0 ) ; HEAP8 [ $46 >> 0 ] = 1 ; $47 = $17 ; $48 = ( ( $47 ) + 1 ) | 0 ; $17 = $48 ; $49 = $7 ; $50 = ( ( ( $49 ) ) + 1 | 0 ) ; $7 = $50 ; } $51 = $16 ; $52 = ( ( $51 ) + 1 ) | 0 ; $16 = $52 ; $53 = $6 ; $54 = ( ( ( $53 ) ) + 4 | 0 ) ; $6 = $54 ; } } else { $55 = $10 ; $56 = ( $55 | 0 ) < ( 8 ) ; if ( ! ( $56 ) ) { ___assert_fail ( ( 21937 | 0 ) , ( 21165 | 0 ) , 1039 , ( 21951 | 0 ) ) ; // unreachable; } $57 = $10 ; $58 = ( 8 - ( $57 ) ) | 0 ; $11 = $58 ; $59 = $11 ; $60 = 1 << $59 ; $61 = ( 256 - ( $60 ) ) | 0 ; $12 = $61 ; $16 = 0 ; while ( 1 ) { $62 = $16 ; $63 = $9 ; $64 = ( $62 >>> 0 ) < ( $63 >>> 0 ) ; if ( ! ( $64 ) ) { break L1 ; } $17 = 0 ; $65 = $6 ; $66 = HEAP32 [ $65 >> 2 ] | 0 ; $7 = $66 ; while ( 1 ) { $67 = $17 ; $68 = $8 ; $69 = ( $67 >>> 0 ) < ( $68 >>> 0 ) ; if ( ! ( $69 ) ) { break ; } $70 = $12 ; $14 = $70 ; $71 = $11 ; $13 = $71 ; while ( 1 ) { $72 = $5 ; $73 = $7 ; $74 = HEAP8 [ $73 >> 0 ] | 0 ; $75 = $74 & 255 ; $76 = $14 ; $77 = $75 & $76 ; $78 = $13 ; $79 = $77 >> $78 ; $80 = ( ( $72 ) + ( $79 ) | 0 ) ; HEAP8 [ $80 >> 0 ] = 1 ; $81 = $10 ; $82 = $14 ; $83 = $82 >> $81 ; $14 = $83 ; $84 = $10 ; $85 = $13 ; $86 = ( ( $85 ) - ( $84 ) ) | 0 ; $13 = $86 ; $87 = $17 ; $88 = ( ( $87 ) + 1 ) | 0 ; $17 = $88 ; $89 = $14 ; $90 = ( $89 | 0 ) > ( 0 ) ; if ( ! ( $90 ) ) { break ; } $91 = $17 ; $92 = $8 ; $93 = ( $91 >>> 0 ) < ( $92 >>> 0 ) ; if ( ! ( $93 ) ) { break ; } } $94 = $7 ; $95 = ( ( ( $94 ) ) + 1 | 0 ) ; $7 = $95 ; } $96 = $16 ; $97 = ( ( $96 ) + 1 ) | 0 ; $16 = $97 ; $98 = $6 ; $99 = ( ( ( $98 ) ) + 4 | 0 ) ; $6 = $99 ; } } } while ( 0 ) ; $100 = $3 ; $101 = $4 ; $102 = ( _png_get_bKGD ( $100 , $101 , $15 ) | 0 ) ; $103 = ( $102 | 0 ) != ( 0 ) ; if ( ! ( $103 ) ) { STACKTOP = sp ; return ; } $104 = $5 ; $105 = HEAP32 [ $15 >> 2 ] | 0 ; $106 = HEAP8 [ $105 >> 0 ] | 0 ; $107 = $106 & 255 ; $108 = ( ( $104 ) + ( $107 ) | 0 ) ; HEAP8 [ $108 >> 0 ] = 1 ; STACKTOP = sp ; return ; } function _opng_realloc_PLTE ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $3 = 0 , $30 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 800 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 800 | 0 ) ; $6 = sp + 24 | 0 ; $7 = sp + 4 | 0 ; $8 = sp ; $3 = $0 ; $4 = $1 ; $5 = $2 ; $9 = $5 ; $10 = ( $9 | 0 ) > ( 0 ) ; if ( ! ( $10 ) ) { ___assert_fail ( ( 21308 | 0 ) , ( 21165 | 0 ) , 212 , ( 21919 | 0 ) ) ; // unreachable; } HEAP32 [ $8 >> 2 ] = 0 ; $11 = $3 ; $12 = $4 ; ( _png_get_PLTE ( $11 , $12 , $7 , $8 ) | 0 ) ; $13 = $5 ; $14 = HEAP32 [ $8 >> 2 ] | 0 ; $15 = ( $13 | 0 ) == ( $14 | 0 ) ; if ( $15 ) { STACKTOP = sp ; return ; } $16 = HEAP32 [ $7 >> 2 ] | 0 ; $17 = $5 ; $18 = ( $17 * 3 ) | 0 ; _memcpy ( ( $6 | 0 ) , ( $16 | 0 ) , ( $18 | 0 ) ) | 0 ; $19 = $5 ; $20 = HEAP32 [ $8 >> 2 ] | 0 ; $21 = ( $19 | 0 ) > ( $20 | 0 ) ; if ( $21 ) { $22 = HEAP32 [ $8 >> 2 ] | 0 ; $23 = ( ( $6 ) + ( ( $22 * 3 ) | 0 ) | 0 ) ; $24 = $5 ; $25 = HEAP32 [ $8 >> 2 ] | 0 ; $26 = ( ( $24 ) - ( $25 ) ) | 0 ; $27 = ( $26 * 3 ) | 0 ; _memset ( ( $23 | 0 ) , 0 , ( $27 | 0 ) ) | 0 ; } $28 = $3 ; $29 = $4 ; $30 = $5 ; _png_set_PLTE ( $28 , $29 , $6 , $30 ) ; STACKTOP = sp ; return ; } function _opng_realloc_tRNS ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $3 = 0 ; var $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 288 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 288 | 0 ) ; $6 = sp + 24 | 0 ; $7 = sp + 4 | 0 ; $8 = sp ; $3 = $0 ; $4 = $1 ; $5 = $2 ; $9 = $5 ; $10 = ( $9 | 0 ) > ( 0 ) ; if ( ! ( $10 ) ) { ___assert_fail ( ( 21887 | 0 ) , ( 21165 | 0 ) , 238 , ( 21901 | 0 ) ) ; // unreachable; } HEAP32 [ $8 >> 2 ] = 0 ; $11 = $3 ; $12 = $4 ; ( _png_get_tRNS ( $11 , $12 , $7 , $8 , 0 ) | 0 ) ; $13 = $5 ; $14 = HEAP32 [ $8 >> 2 ] | 0 ; $15 = ( $13 | 0 ) == ( $14 | 0 ) ; if ( $15 ) { STACKTOP = sp ; return ; } $16 = HEAP32 [ $7 >> 2 ] | 0 ; $17 = $5 ; _memcpy ( ( $6 | 0 ) , ( $16 | 0 ) , ( $17 | 0 ) ) | 0 ; $18 = $5 ; $19 = HEAP32 [ $8 >> 2 ] | 0 ; $20 = ( $18 | 0 ) > ( $19 | 0 ) ; if ( $20 ) { $21 = HEAP32 [ $8 >> 2 ] | 0 ; $22 = ( ( $6 ) + ( $21 ) | 0 ) ; $23 = $5 ; $24 = HEAP32 [ $8 >> 2 ] | 0 ; $25 = ( ( $23 ) - ( $24 ) ) | 0 ; _memset ( ( $22 | 0 ) , 0 , ( $25 | 0 ) ) | 0 ; } $26 = $3 ; $27 = $4 ; $28 = $5 ; _png_set_tRNS ( $26 , $27 , $6 , $28 , 0 ) ; STACKTOP = sp ; return ; } function _opng_analyze_bits ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 ; var $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 ; var $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 ; var $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 ; var $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 , $208 = 0 ; var $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 , $226 = 0 ; var $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 , $244 = 0 ; var $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 , $258 = 0 , $259 = 0 , $26 = 0 , $260 = 0 , $261 = 0 , $262 = 0 ; var $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 , $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 , $270 = 0 , $271 = 0 , $272 = 0 , $273 = 0 , $274 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 ; var $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 ; var $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 ; var $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 ; var $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 80 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 80 | 0 ) ; $9 = sp + 40 | 0 ; $10 = sp + 36 | 0 ; $11 = sp + 32 | 0 ; $12 = sp + 28 | 0 ; $17 = sp + 8 | 0 ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $20 = $4 ; $21 = $5 ; ( _png_get_IHDR ( $20 , $21 , $10 , $9 , $11 , $12 , 0 , 0 , 0 ) | 0 ) ; $22 = HEAP32 [ $11 >> 2 ] | 0 ; $23 = ( $22 | 0 ) < ( 8 ) ; if ( $23 ) { $3 = 0 ; $274 = $3 ; STACKTOP = sp ; return ( $274 | 0 ) ; } $24 = HEAP32 [ $12 >> 2 ] | 0 ; $25 = $24 & 1 ; $26 = ( $25 | 0 ) != ( 0 ) ; if ( $26 ) { $3 = 0 ; $274 = $3 ; STACKTOP = sp ; return ( $274 | 0 ) ; } $27 = HEAP32 [ $11 >> 2 ] | 0 ; $28 = ( ( $27 | 0 ) / 8 ) & - 1 ; $13 = $28 ; $29 = $4 ; $30 = $5 ; $31 = ( _png_get_channels ( $29 , $30 ) | 0 ) ; $32 = $31 & 255 ; $14 = $32 ; $33 = $14 ; $34 = $13 ; $35 = Math_imul ( $33 , $34 ) | 0 ; $15 = $35 ; $36 = $14 ; $37 = ( ( $36 ) - 1 ) | 0 ; $38 = $13 ; $39 = Math_imul ( $37 , $38 ) | 0 ; $16 = $39 ; $40 = $6 ; $41 = $40 & 13 ; $6 = $41 ; $42 = HEAP32 [ $11 >> 2 ] | 0 ; $43 = ( $42 | 0 ) <= ( 8 ) ; if ( $43 ) { $44 = $6 ; $45 = $44 & - 2 ; $6 = $45 ; } $46 = HEAP32 [ $12 >> 2 ] | 0 ; $47 = $46 & 2 ; $48 = ( $47 | 0 ) != ( 0 ) ; if ( ! ( $48 ) ) { $49 = $6 ; $50 = $49 & - 5 ; $6 = $50 ; } $51 = HEAP32 [ $12 >> 2 ] | 0 ; $52 = $51 & 4 ; $53 = ( $52 | 0 ) != ( 0 ) ; if ( ! ( $53 ) ) { $54 = $6 ; $55 = $54 & - 9 ; $6 = $55 ; } $56 = $4 ; $57 = $5 ; $58 = ( _png_get_bKGD ( $56 , $57 , $17 ) | 0 ) ; $59 = ( $58 | 0 ) != ( 0 ) ; do { if ( $59 ) { $60 = $6 ; $61 = $60 & 1 ; $62 = ( $61 | 0 ) != ( 0 ) ; do { if ( $62 ) { $63 = HEAP32 [ $17 >> 2 ] | 0 ; $64 = ( ( ( $63 ) ) + 2 | 0 ) ; $65 = HEAP16 [ $64 >> 1 ] | 0 ; $66 = $65 & 65535 ; $67 = ( ( $66 | 0 ) % 257 ) & - 1 ; $68 = ( $67 | 0 ) != ( 0 ) ; if ( ! ( $68 ) ) { $69 = HEAP32 [ $17 >> 2 ] | 0 ; $70 = ( ( ( $69 ) ) + 4 | 0 ) ; $71 = HEAP16 [ $70 >> 1 ] | 0 ; $72 = $71 & 65535 ; $73 = ( ( $72 | 0 ) % 257 ) & - 1 ; $74 = ( $73 | 0 ) != ( 0 ) ; if ( ! ( $74 ) ) { $75 = HEAP32 [ $17 >> 2 ] | 0 ; $76 = ( ( ( $75 ) ) + 6 | 0 ) ; $77 = HEAP16 [ $76 >> 1 ] | 0 ; $78 = $77 & 65535 ; $79 = ( ( $78 | 0 ) % 257 ) & - 1 ; $80 = ( $79 | 0 ) != ( 0 ) ; if ( ! ( $80 ) ) { $81 = HEAP32 [ $17 >> 2 ] | 0 ; $82 = ( ( ( $81 ) ) + 8 | 0 ) ; $83 = HEAP16 [ $82 >> 1 ] | 0 ; $84 = $83 & 65535 ; $85 = ( ( $84 | 0 ) % 257 ) & - 1 ; $86 = ( $85 | 0 ) != ( 0 ) ; if ( ! ( $86 ) ) { break ; } } } } $87 = $6 ; $88 = $87 & - 2 ; $6 = $88 ; } } while ( 0 ) ; $89 = $6 ; $90 = $89 & 4 ; $91 = ( $90 | 0 ) != ( 0 ) ; if ( $91 ) { $92 = HEAP32 [ $17 >> 2 ] | 0 ; $93 = ( ( ( $92 ) ) + 2 | 0 ) ; $94 = HEAP16 [ $93 >> 1 ] | 0 ; $95 = $94 & 65535 ; $96 = HEAP32 [ $17 >> 2 ] | 0 ; $97 = ( ( ( $96 ) ) + 4 | 0 ) ; $98 = HEAP16 [ $97 >> 1 ] | 0 ; $99 = $98 & 65535 ; $100 = ( $95 | 0 ) != ( $99 | 0 ) ; if ( ! ( $100 ) ) { $101 = HEAP32 [ $17 >> 2 ] | 0 ; $102 = ( ( ( $101 ) ) + 2 | 0 ) ; $103 = HEAP16 [ $102 >> 1 ] | 0 ; $104 = $103 & 65535 ; $105 = HEAP32 [ $17 >> 2 ] | 0 ; $106 = ( ( ( $105 ) ) + 6 | 0 ) ; $107 = HEAP16 [ $106 >> 1 ] | 0 ; $108 = $107 & 65535 ; $109 = ( $104 | 0 ) != ( $108 | 0 ) ; if ( ! ( $109 ) ) { break ; } } $110 = $6 ; $111 = $110 & - 5 ; $6 = $111 ; } } } while ( 0 ) ; $112 = $4 ; $113 = $5 ; $114 = ( _png_get_rows ( $112 , $113 ) | 0 ) ; $7 = $114 ; $18 = 0 ; while ( 1 ) { $115 = $18 ; $116 = HEAP32 [ $9 >> 2 ] | 0 ; $117 = ( $115 >>> 0 ) < ( $116 >>> 0 ) ; $118 = $6 ; if ( ! ( $117 ) ) { label = 63 ; break ; } $119 = ( $118 | 0 ) == ( 0 ) ; if ( $119 ) { label = 25 ; break ; } $120 = $6 ; $121 = $120 & 1 ; $122 = ( $121 | 0 ) != ( 0 ) ; L37 : do { if ( $122 ) { $123 = $7 ; $124 = HEAP32 [ $123 >> 2 ] | 0 ; $8 = $124 ; $19 = 0 ; while ( 1 ) { $125 = $19 ; $126 = $14 ; $127 = HEAP32 [ $10 >> 2 ] | 0 ; $128 = Math_imul ( $126 , $127 ) | 0 ; $129 = ( $125 >>> 0 ) < ( $128 >>> 0 ) ; if ( ! ( $129 ) ) { break L37 ; } $130 = $8 ; $131 = HEAP8 [ $130 >> 0 ] | 0 ; $132 = $131 & 255 ; $133 = $8 ; $134 = ( ( ( $133 ) ) + 1 | 0 ) ; $135 = HEAP8 [ $134 >> 0 ] | 0 ; $136 = $135 & 255 ; $137 = ( $132 | 0 ) != ( $136 | 0 ) ; if ( $137 ) { break ; } $140 = $19 ; $141 = ( ( $140 ) + 1 ) | 0 ; $19 = $141 ; $142 = $8 ; $143 = ( ( ( $142 ) ) + 2 | 0 ) ; $8 = $143 ; } $138 = $6 ; $139 = $138 & - 2 ; $6 = $139 ; } } while ( 0 ) ; $144 = HEAP32 [ $11 >> 2 ] | 0 ; $145 = ( $144 | 0 ) == ( 8 ) ; $146 = $6 ; $147 = $146 & 4 ; $148 = ( $147 | 0 ) != ( 0 ) ; L45 : do { if ( $145 ) { L47 : do { if ( $148 ) { $149 = $7 ; $150 = HEAP32 [ $149 >> 2 ] | 0 ; $8 = $150 ; $19 = 0 ; while ( 1 ) { $151 = $19 ; $152 = HEAP32 [ $10 >> 2 ] | 0 ; $153 = ( $151 >>> 0 ) < ( $152 >>> 0 ) ; if ( ! ( $153 ) ) { break L47 ; } $154 = $8 ; $155 = HEAP8 [ $154 >> 0 ] | 0 ; $156 = $155 & 255 ; $157 = $8 ; $158 = ( ( ( $157 ) ) + 1 | 0 ) ; $159 = HEAP8 [ $158 >> 0 ] | 0 ; $160 = $159 & 255 ; $161 = ( $156 | 0 ) != ( $160 | 0 ) ; if ( $161 ) { break ; } $162 = $8 ; $163 = HEAP8 [ $162 >> 0 ] | 0 ; $164 = $163 & 255 ; $165 = $8 ; $166 = ( ( ( $165 ) ) + 2 | 0 ) ; $167 = HEAP8 [ $166 >> 0 ] | 0 ; $168 = $167 & 255 ; $169 = ( $164 | 0 ) != ( $168 | 0 ) ; if ( $169 ) { break ; } $172 = $19 ; $173 = ( ( $172 ) + 1 ) | 0 ; $19 = $173 ; $174 = $15 ; $175 = $8 ; $176 = ( ( $175 ) + ( $174 ) | 0 ) ; $8 = $176 ; } $170 = $6 ; $171 = $170 & - 5 ; $6 = $171 ; } } while ( 0 ) ; $177 = $6 ; $178 = $177 & 8 ; $179 = ( $178 | 0 ) != ( 0 ) ; if ( $179 ) { $180 = $7 ; $181 = HEAP32 [ $180 >> 2 ] | 0 ; $182 = $16 ; $183 = ( ( $181 ) + ( $182 ) | 0 ) ; $8 = $183 ; $19 = 0 ; while ( 1 ) { $184 = $19 ; $185 = HEAP32 [ $10 >> 2 ] | 0 ; $186 = ( $184 >>> 0 ) < ( $185 >>> 0 ) ; if ( ! ( $186 ) ) { break L45 ; } $187 = $8 ; $188 = HEAP8 [ $187 >> 0 ] | 0 ; $189 = $188 & 255 ; $190 = ( $189 | 0 ) != ( 255 ) ; if ( $190 ) { break ; } $193 = $19 ; $194 = ( ( $193 ) + 1 ) | 0 ; $19 = $194 ; $195 = $15 ; $196 = $8 ; $197 = ( ( $196 ) + ( $195 ) | 0 ) ; $8 = $197 ; } $191 = $6 ; $192 = $191 & - 9 ; $6 = $192 ; } } else { L63 : do { if ( $148 ) { $198 = $7 ; $199 = HEAP32 [ $198 >> 2 ] | 0 ; $8 = $199 ; $19 = 0 ; while ( 1 ) { $200 = $19 ; $201 = HEAP32 [ $10 >> 2 ] | 0 ; $202 = ( $200 >>> 0 ) < ( $201 >>> 0 ) ; if ( ! ( $202 ) ) { break L63 ; } $203 = $8 ; $204 = HEAP8 [ $203 >> 0 ] | 0 ; $205 = $204 & 255 ; $206 = $8 ; $207 = ( ( ( $206 ) ) + 2 | 0 ) ; $208 = HEAP8 [ $207 >> 0 ] | 0 ; $209 = $208 & 255 ; $210 = ( $205 | 0 ) != ( $209 | 0 ) ; if ( $210 ) { break ; } $211 = $8 ; $212 = HEAP8 [ $211 >> 0 ] | 0 ; $213 = $212 & 255 ; $214 = $8 ; $215 = ( ( ( $214 ) ) + 4 | 0 ) ; $216 = HEAP8 [ $215 >> 0 ] | 0 ; $217 = $216 & 255 ; $218 = ( $213 | 0 ) != ( $217 | 0 ) ; if ( $218 ) { break ; } $219 = $8 ; $220 = ( ( ( $219 ) ) + 1 | 0 ) ; $221 = HEAP8 [ $220 >> 0 ] | 0 ; $222 = $221 & 255 ; $223 = $8 ; $224 = ( ( ( $223 ) ) + 3 | 0 ) ; $225 = HEAP8 [ $224 >> 0 ] | 0 ; $226 = $225 & 255 ; $227 = ( $222 | 0 ) != ( $226 | 0 ) ; if ( $227 ) { break ; } $228 = $8 ; $229 = ( ( ( $228 ) ) + 1 | 0 ) ; $230 = HEAP8 [ $229 >> 0 ] | 0 ; $231 = $230 & 255 ; $232 = $8 ; $233 = ( ( ( $232 ) ) + 5 | 0 ) ; $234 = HEAP8 [ $233 >> 0 ] | 0 ; $235 = $234 & 255 ; $236 = ( $231 | 0 ) != ( $235 | 0 ) ; if ( $236 ) { break ; } $239 = $19 ; $240 = ( ( $239 ) + 1 ) | 0 ; $19 = $240 ; $241 = $15 ; $242 = $8 ; $243 = ( ( $242 ) + ( $241 ) | 0 ) ; $8 = $243 ; } $237 = $6 ; $238 = $237 & - 5 ; $6 = $238 ; } } while ( 0 ) ; $244 = $6 ; $245 = $244 & 8 ; $246 = ( $245 | 0 ) != ( 0 ) ; if ( $246 ) { $247 = $7 ; $248 = HEAP32 [ $247 >> 2 ] | 0 ; $249 = $16 ; $250 = ( ( $248 ) + ( $249 ) | 0 ) ; $8 = $250 ; $19 = 0 ; while ( 1 ) { $251 = $19 ; $252 = HEAP32 [ $10 >> 2 ] | 0 ; $253 = ( $251 >>> 0 ) < ( $252 >>> 0 ) ; if ( ! ( $253 ) ) { break L45 ; } $254 = $8 ; $255 = HEAP8 [ $254 >> 0 ] | 0 ; $256 = $255 & 255 ; $257 = ( $256 | 0 ) != ( 255 ) ; if ( $257 ) { break ; } $258 = $8 ; $259 = ( ( ( $258 ) ) + 1 | 0 ) ; $260 = HEAP8 [ $259 >> 0 ] | 0 ; $261 = $260 & 255 ; $262 = ( $261 | 0 ) != ( 255 ) ; if ( $262 ) { break ; } $265 = $19 ; $266 = ( ( $265 ) + 1 ) | 0 ; $19 = $266 ; $267 = $15 ; $268 = $8 ; $269 = ( ( $268 ) + ( $267 ) | 0 ) ; $8 = $269 ; } $263 = $6 ; $264 = $263 & - 9 ; $6 = $264 ; } } } while ( 0 ) ; $270 = $18 ; $271 = ( ( $270 ) + 1 ) | 0 ; $18 = $271 ; $272 = $7 ; $273 = ( ( ( $272 ) ) + 4 | 0 ) ; $7 = $273 ; } if ( ( label | 0 ) == 25 ) { $3 = 0 ; $274 = $3 ; STACKTOP = sp ; return ( $274 | 0 ) ; } else if ( ( label | 0 ) == 63 ) { $3 = $118 ; $274 = $3 ; STACKTOP = sp ; return ( $274 | 0 ) ; } return ( 0 ) | 0 ; } function _pngx_read_image ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 ; var $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 ; var $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 192 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 192 | 0 ) ; $9 = sp + 56 | 0 ; $13 = sp ; $5 = $0 ; $6 = $1 ; $7 = $2 ; $8 = $3 ; $15 = $5 ; $16 = ( _png_get_io_ptr ( $15 ) | 0 ) ; $12 = $16 ; $17 = $12 ; $18 = ( _fgetpos ( $17 , $13 ) | 0 ) ; $19 = ( $18 | 0 ) != ( 0 ) ; if ( $19 ) { $20 = $5 ; _png_error ( $20 , 22106 ) ; // unreachable; } $21 = $12 ; $22 = ( _fread ( $9 , 1 , 128 , $21 ) | 0 ) ; $10 = $22 ; $23 = $12 ; $24 = ( _fsetpos ( $23 , $13 ) | 0 ) ; $25 = ( $24 | 0 ) != ( 0 ) ; $26 = $5 ; if ( $25 ) { _png_error ( $26 , 22139 ) ; // unreachable; } $27 = $10 ; $28 = $7 ; $29 = $8 ; $30 = ( _pngx_sig_is_png ( $26 , $9 , $27 , $28 , $29 ) | 0 ) ; $31 = ( $30 | 0 ) > ( 0 ) ; if ( $31 ) { $32 = $5 ; $33 = $6 ; _png_read_png ( $32 , $33 , 0 , 0 ) ; $34 = $12 ; $35 = ( _getc ( $34 ) | 0 ) ; $36 = ( $35 | 0 ) != ( - 1 ) ; if ( $36 ) { $37 = $5 ; _png_warning ( $37 , 22172 ) ; $38 = $12 ; ( _fseek ( $38 , 0 , 2 ) | 0 ) ; } $4 = 1 ; $76 = $4 ; STACKTOP = sp ; return ( $76 | 0 ) ; } $39 = $10 ; $40 = $7 ; $41 = $8 ; $42 = ( _pngx_sig_is_bmp ( $9 , $39 , $40 , $41 ) | 0 ) ; $43 = ( $42 | 0 ) > ( 0 ) ; do { if ( $43 ) { $11 = 79 ; } else { $44 = $10 ; $45 = $7 ; $46 = $8 ; $47 = ( _pngx_sig_is_gif ( $9 , $44 , $45 , $46 ) | 0 ) ; $48 = ( $47 | 0 ) > ( 0 ) ; if ( $48 ) { $11 = 80 ; break ; } $49 = $10 ; $50 = $7 ; $51 = $8 ; $52 = ( _pngx_sig_is_jpeg ( $9 , $49 , $50 , $51 ) | 0 ) ; $53 = ( $52 | 0 ) > ( 0 ) ; if ( $53 ) { $11 = 81 ; break ; } $54 = $10 ; $55 = $7 ; $56 = $8 ; $57 = ( _pngx_sig_is_pnm ( $9 , $54 , $55 , $56 ) | 0 ) ; $58 = ( $57 | 0 ) > ( 0 ) ; if ( $58 ) { $11 = 82 ; break ; } $59 = $10 ; $60 = $7 ; $61 = $8 ; $62 = ( _pngx_sig_is_tiff ( $9 , $59 , $60 , $61 ) | 0 ) ; $63 = ( $62 | 0 ) > ( 0 ) ; if ( $63 ) { $11 = 83 ; break ; } $4 = 0 ; $76 = $4 ; STACKTOP = sp ; return ( $76 | 0 ) ; } } while ( 0 ) ; $64 = $11 ; $65 = $5 ; $66 = $6 ; $67 = $12 ; $68 = ( FUNCTION_TABLE_iiii [ $64 & 127 ] ( $65 , $66 , $67 ) | 0 ) ; $14 = $68 ; $69 = $14 ; $70 = ( $69 | 0 ) <= ( 0 ) ; if ( $70 ) { $71 = $12 ; $72 = ( _fsetpos ( $71 , $13 ) | 0 ) ; $73 = ( $72 | 0 ) != ( 0 ) ; if ( $73 ) { $74 = $5 ; _png_error ( $74 , 22139 ) ; // unreachable; } } $75 = $14 ; $4 = $75 ; $76 = $4 ; STACKTOP = sp ; return ( $76 | 0 ) ; } function _pngx_sig_is_png ( $0 , $1 , $2 , $3 , $4 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; $4 = $4 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 ; var $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $6 = $0 ; $7 = $1 ; $8 = $2 ; $9 = $3 ; $10 = $4 ; $12 = $8 ; $13 = ( $12 >>> 0 ) <= ( 43 ) ; if ( $13 ) { $5 = - 1 ; $55 = $5 ; STACKTOP = sp ; return ( $55 | 0 ) ; } $14 = $7 ; $15 = ( _memcmp ( $14 , 23546 , 8 ) | 0 ) ; $16 = ( $15 | 0 ) == ( 0 ) ; $17 = $16 & 1 ; $11 = $17 ; $18 = $7 ; $19 = $11 ; $20 = ( $19 | 0 ) != ( 0 ) ; $21 = $20 ? 8 : 0 ; $22 = ( ( $18 ) + ( $21 ) | 0 ) ; $23 = ( _memcmp ( $22 , 22205 , 8 ) | 0 ) ; $24 = ( $23 | 0 ) != ( 0 ) ; if ( ! ( $24 ) ) { $43 = $9 ; $44 = ( $43 | 0 ) != ( 0 | 0 ) ; if ( $44 ) { $45 = $11 ; $46 = ( $45 | 0 ) != ( 0 ) ; $47 = $46 ? 20164 : 22309 ; $48 = $9 ; HEAP32 [ $48 >> 2 ] = $47 ; } $49 = $10 ; $50 = ( $49 | 0 ) != ( 0 | 0 ) ; if ( $50 ) { $51 = $11 ; $52 = ( $51 | 0 ) != ( 0 ) ; $53 = $52 ? 22324 : 22350 ; $54 = $10 ; HEAP32 [ $54 >> 2 ] = $53 ; } $5 = 1 ; $55 = $5 ; STACKTOP = sp ; return ( $55 | 0 ) ; } $25 = $7 ; $26 = ( _memcmp ( $25 , 23546 , 4 ) | 0 ) ; $27 = ( $26 | 0 ) == ( 0 ) ; if ( $27 ) { $28 = $7 ; $29 = ( ( ( $28 ) ) + 4 | 0 ) ; $30 = HEAP8 [ $29 >> 0 ] | 0 ; $31 = $30 & 255 ; $32 = ( $31 | 0 ) == ( 10 ) ; if ( $32 ) { $38 = $6 ; _png_error ( $38 , 22213 ) ; // unreachable; } $33 = $7 ; $34 = ( ( ( $33 ) ) + 4 | 0 ) ; $35 = HEAP8 [ $34 >> 0 ] | 0 ; $36 = $35 & 255 ; $37 = ( $36 | 0 ) == ( 13 ) ; if ( $37 ) { $38 = $6 ; _png_error ( $38 , 22213 ) ; // unreachable; } } $39 = $7 ; $40 = ( _memcmp ( $39 , 22271 , 8 ) | 0 ) ; $41 = ( $40 | 0 ) == ( 0 ) ; if ( $41 ) { $42 = $6 ; _png_error ( $42 , 22279 ) ; // unreachable; } $5 = 0 ; $55 = $5 ; STACKTOP = sp ; return ( $55 | 0 ) ; } function _pngx_sig_is_bmp ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $$sink = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 ; var $29 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $5 = $0 ; $6 = $1 ; $7 = $2 ; $8 = $3 ; $10 = $6 ; $11 = ( $10 >>> 0 ) < ( 18 ) ; do { if ( $11 ) { $4 = - 1 ; } else { $12 = $5 ; $13 = ( _bmp_get_word ( $12 ) | 0 ) ; $14 = ( $13 | 0 ) != ( 19778 ) ; if ( $14 ) { $4 = 0 ; break ; } $15 = $5 ; $16 = ( ( ( $15 ) ) + 14 | 0 ) ; $17 = ( _bmp_get_dword ( $16 ) | 0 ) ; $9 = $17 ; $18 = $9 ; $19 = ( $18 >>> 0 ) > ( 2147483647 ) ; if ( ! ( $19 ) ) { $20 = $9 ; $21 = ( $20 | 0 ) != ( 12 ) ; $22 = $9 ; $23 = ( $22 >>> 0 ) < ( 40 ) ; $or$cond = $21 & $23 ; if ( ! ( $or$cond ) ) { $24 = $7 ; $25 = ( $24 | 0 ) != ( 0 | 0 ) ; if ( $25 ) { $26 = $7 ; HEAP32 [ $26 >> 2 ] = 22396 ; } $27 = $8 ; $28 = ( $27 | 0 ) != ( 0 | 0 ) ; if ( $28 ) { $29 = $9 ; $30 = ( $29 | 0 ) == ( 12 ) ; $31 = $8 ; $$sink = $30 ? 22400 : 22412 ; HEAP32 [ $31 >> 2 ] = $$sink ; } $4 = 1 ; break ; } } $4 = 0 ; } } while ( 0 ) ; $32 = $4 ; STACKTOP = sp ; return ( $32 | 0 ) ; } function _bmp_get_word ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $2 = $1 ; $3 = HEAP8 [ $2 >> 0 ] | 0 ; $4 = $3 & 255 ; $5 = $1 ; $6 = ( ( ( $5 ) ) + 1 | 0 ) ; $7 = HEAP8 [ $6 >> 0 ] | 0 ; $8 = $7 & 255 ; $9 = $8 << 8 ; $10 = ( ( $4 ) + ( $9 ) ) | 0 ; STACKTOP = sp ; return ( $10 | 0 ) ; } function _bmp_get_dword ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 ; var $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $2 = $1 ; $3 = HEAP8 [ $2 >> 0 ] | 0 ; $4 = $3 & 255 ; $5 = $1 ; $6 = ( ( ( $5 ) ) + 1 | 0 ) ; $7 = HEAP8 [ $6 >> 0 ] | 0 ; $8 = $7 & 255 ; $9 = $8 << 8 ; $10 = ( ( $4 ) + ( $9 ) ) | 0 ; $11 = $1 ; $12 = ( ( ( $11 ) ) + 2 | 0 ) ; $13 = HEAP8 [ $12 >> 0 ] | 0 ; $14 = $13 & 255 ; $15 = $14 << 16 ; $16 = ( ( $10 ) + ( $15 ) ) | 0 ; $17 = $1 ; $18 = ( ( ( $17 ) ) + 3 | 0 ) ; $19 = HEAP8 [ $18 >> 0 ] | 0 ; $20 = $19 & 255 ; $21 = $20 << 24 ; $22 = ( ( $16 ) + ( $21 ) ) | 0 ; STACKTOP = sp ; return ( $22 | 0 ) ; } function _pngx_read_bmp ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$ = 0 , $$sink = 0 , $$sink19 = 0 , $$sink7 = 0 , $$sink9 = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 ; var $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 ; var $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 ; var $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 ; var $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 , $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 ; var $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 , $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 ; var $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 , $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 ; var $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 , $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 ; var $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 , $244 = 0 , $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 , $258 = 0 ; var $259 = 0 , $26 = 0 , $260 = 0 , $261 = 0 , $262 = 0 , $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 , $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 , $270 = 0 , $271 = 0 , $272 = 0 , $273 = 0 , $274 = 0 , $275 = 0 , $276 = 0 ; var $277 = 0 , $278 = 0 , $279 = 0 , $28 = 0 , $280 = 0 , $281 = 0 , $282 = 0 , $283 = 0 , $284 = 0 , $285 = 0 , $286 = 0 , $287 = 0 , $288 = 0 , $289 = 0 , $29 = 0 , $290 = 0 , $291 = 0 , $292 = 0 , $293 = 0 , $294 = 0 ; var $295 = 0 , $296 = 0 , $297 = 0 , $298 = 0 , $299 = 0 , $3 = 0 , $30 = 0 , $300 = 0 , $301 = 0 , $302 = 0 , $303 = 0 , $304 = 0 , $305 = 0 , $306 = 0 , $307 = 0 , $308 = 0 , $309 = 0 , $31 = 0 , $310 = 0 , $311 = 0 ; var $312 = 0 , $313 = 0 , $314 = 0 , $315 = 0 , $316 = 0 , $317 = 0 , $318 = 0 , $319 = 0 , $32 = 0 , $320 = 0 , $321 = 0 , $322 = 0 , $323 = 0 , $324 = 0 , $325 = 0 , $326 = 0 , $327 = 0 , $328 = 0 , $329 = 0 , $33 = 0 ; var $330 = 0 , $331 = 0 , $332 = 0 , $333 = 0 , $334 = 0 , $335 = 0 , $336 = 0 , $337 = 0 , $338 = 0 , $339 = 0 , $34 = 0 , $340 = 0 , $341 = 0 , $342 = 0 , $343 = 0 , $344 = 0 , $345 = 0 , $346 = 0 , $347 = 0 , $348 = 0 ; var $349 = 0 , $35 = 0 , $350 = 0 , $351 = 0 , $352 = 0 , $353 = 0 , $354 = 0 , $355 = 0 , $356 = 0 , $357 = 0 , $358 = 0 , $359 = 0 , $36 = 0 , $360 = 0 , $361 = 0 , $362 = 0 , $363 = 0 , $364 = 0 , $365 = 0 , $366 = 0 ; var $367 = 0 , $368 = 0 , $369 = 0 , $37 = 0 , $370 = 0 , $371 = 0 , $372 = 0 , $373 = 0 , $374 = 0 , $375 = 0 , $376 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 ; var $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 ; var $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 ; var $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $or$cond = 0 ; var $or$cond12 = 0 , $or$cond14 = 0 , $or$cond16 = 0 , $or$cond18 = 0 , $or$cond3 = 0 , $or$cond5 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 1040 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 1040 | 0 ) ; $7 = sp + 900 | 0 ; $9 = sp + 896 | 0 ; $21 = sp + 32 | 0 ; $22 = sp + 892 | 0 ; $23 = sp + 888 | 0 ; $26 = sp + 120 | 0 ; $27 = sp + 112 | 0 ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $33 = ( ( ( $7 ) ) + 14 | 0 ) ; $8 = $33 ; $31 = 0 ; while ( 1 ) { $34 = $6 ; $35 = ( _fread ( $7 , 18 , 1 , $34 ) | 0 ) ; $36 = ( $35 | 0 ) != ( 1 ) ; if ( $36 ) { $37 = $31 ; $38 = ( ( $37 ) + 1 ) | 0 ; $31 = $38 ; } else { $39 = ( _bmp_get_word ( $7 ) | 0 ) ; $40 = ( $39 | 0 ) == ( 19778 ) ; if ( $40 ) { break ; } } $41 = $6 ; $42 = ( _fread ( $7 , 110 , 1 , $41 ) | 0 ) ; $43 = ( $42 | 0 ) != ( 1 ) ; if ( $43 ) { $44 = $31 ; $45 = ( ( $44 ) + 1 ) | 0 ; $31 = $45 ; } $46 = $31 ; $47 = ( $46 >>> 0 ) > ( 0 ) ; if ( $47 ) { label = 8 ; break ; } $48 = $31 ; $49 = ( ( $48 ) + 1 ) | 0 ; $31 = $49 ; } if ( ( label | 0 ) == 8 ) { $3 = 0 ; $376 = $3 ; STACKTOP = sp ; return ( $376 | 0 ) ; } $50 = ( ( ( $7 ) ) + 10 | 0 ) ; $51 = ( _bmp_get_dword ( $50 ) | 0 ) ; $10 = $51 ; $52 = ( ( ( $7 ) ) + 14 | 0 ) ; $53 = ( _bmp_get_dword ( $52 ) | 0 ) ; $11 = $53 ; $54 = $10 ; $55 = ( $54 >>> 0 ) > ( 2147483647 ) ; $56 = $11 ; $57 = ( $56 >>> 0 ) > ( 2147483647 ) ; $or$cond = $55 | $57 ; if ( ! ( $or$cond ) ) { $58 = $10 ; $59 = $11 ; $60 = ( ( $59 ) + 14 ) | 0 ; $61 = ( $58 >>> 0 ) < ( $60 >>> 0 ) ; if ( ! ( $61 ) ) { $62 = $11 ; $63 = ( $62 | 0 ) != ( 12 ) ; $64 = $11 ; $65 = ( $64 >>> 0 ) < ( 40 ) ; $or$cond3 = $63 & $65 ; if ( ! ( $or$cond3 ) ) { $66 = $11 ; $67 = ( $66 >>> 0 ) > ( 124 ) ; if ( $67 ) { $68 = $11 ; $69 = ( ( $68 ) - 124 ) | 0 ; $12 = $69 ; $11 = 124 ; } else { $12 = 0 ; } $70 = $8 ; $71 = ( ( ( $70 ) ) + 4 | 0 ) ; $72 = $11 ; $73 = ( ( $72 ) - 4 ) | 0 ; $74 = $6 ; $75 = ( _fread ( $71 , $73 , 1 , $74 ) | 0 ) ; $76 = ( $75 | 0 ) != ( 1 ) ; if ( $76 ) { $3 = 0 ; $376 = $3 ; STACKTOP = sp ; return ( $376 | 0 ) ; } $77 = $12 ; $78 = ( $77 >>> 0 ) > ( 0 ) ; if ( $78 ) { $79 = $6 ; $80 = $12 ; $81 = ( _fseek ( $79 , $80 , 1 ) | 0 ) ; $82 = ( $81 | 0 ) != ( 0 ) ; if ( $82 ) { $3 = 0 ; $376 = $3 ; STACKTOP = sp ; return ( $376 | 0 ) ; } } $83 = $10 ; $84 = $11 ; $85 = ( ( $83 ) - ( $84 ) ) | 0 ; $86 = ( ( $85 ) - 14 ) | 0 ; $12 = $86 ; $16 = 0 ; $87 = $11 ; $88 = ( $87 >>> 0 ) < ( 40 ) ; $89 = $8 ; $90 = ( ( ( $89 ) ) + 4 | 0 ) ; do { if ( $88 ) { $91 = ( _bmp_get_word ( $90 ) | 0 ) ; $13 = $91 ; $92 = $8 ; $93 = ( ( ( $92 ) ) + 6 | 0 ) ; $94 = ( _bmp_get_word ( $93 ) | 0 ) ; $14 = $94 ; $95 = $8 ; $96 = ( ( ( $95 ) ) + 10 | 0 ) ; $97 = ( _bmp_get_word ( $96 ) | 0 ) ; $17 = $97 ; $18 = 0 ; $19 = 3 ; } else { $98 = ( _bmp_get_dword ( $90 ) | 0 ) ; $13 = $98 ; $99 = $8 ; $100 = ( ( ( $99 ) ) + 8 | 0 ) ; $101 = ( _bmp_get_dword ( $100 ) | 0 ) ; $14 = $101 ; $102 = $8 ; $103 = ( ( ( $102 ) ) + 14 | 0 ) ; $104 = ( _bmp_get_word ( $103 ) | 0 ) ; $17 = $104 ; $105 = $8 ; $106 = ( ( ( $105 ) ) + 16 | 0 ) ; $107 = ( _bmp_get_dword ( $106 ) | 0 ) ; $18 = $107 ; $19 = 4 ; $108 = $14 ; $109 = ( $108 >>> 0 ) > ( 2147483647 ) ; if ( $109 ) { $110 = $14 ; $111 = ( - 1 - ( $110 ) ) | 0 ; $112 = ( ( $111 ) + 1 ) | 0 ; $14 = $112 ; $16 = 1 ; } $113 = $11 ; $114 = ( $113 | 0 ) == ( 40 ) ; $115 = $18 ; $116 = ( $115 | 0 ) == ( 3 ) ; $or$cond5 = $114 & $116 ; if ( $or$cond5 ) { $117 = $12 ; $118 = ( $117 >>> 0 ) <= ( 16 ) ; $119 = $12 ; $120 = $118 ? $119 : 16 ; $31 = $120 ; $121 = $8 ; $122 = ( ( ( $121 ) ) + 40 | 0 ) ; $123 = $31 ; $124 = $6 ; $125 = ( _fread ( $122 , $123 , 1 , $124 ) | 0 ) ; $126 = ( $125 | 0 ) != ( 1 ) ; if ( ! ( $126 ) ) { $127 = $31 ; $128 = $11 ; $129 = ( ( $128 ) + ( $127 ) ) | 0 ; $11 = $129 ; $130 = $31 ; $131 = $12 ; $132 = ( ( $131 ) - ( $130 ) ) | 0 ; $12 = $132 ; break ; } $3 = 0 ; $376 = $3 ; STACKTOP = sp ; return ( $376 | 0 ) ; } } } while ( 0 ) ; ; HEAP32 [ $21 >> 2 ] = 0 | 0 ; HEAP32 [ $21 + 4 >> 2 ] = 0 | 0 ; HEAP32 [ $21 + 8 >> 2 ] = 0 | 0 ; HEAP32 [ $21 + 12 >> 2 ] = 0 | 0 ; $133 = $17 ; $134 = ( $133 >>> 0 ) > ( 8 ) ; if ( $134 ) { $135 = $18 ; $136 = ( $135 | 0 ) == ( 0 ) ; do { if ( $136 ) { $137 = $17 ; $138 = ( $137 | 0 ) == ( 16 ) ; if ( $138 ) { $18 = 3 ; $$sink = 31 ; $$sink7 = 992 ; $$sink9 = 31744 ; } else { $$sink = 255 ; $$sink7 = 65280 ; $$sink9 = 16711680 ; } HEAP32 [ $21 >> 2 ] = $$sink9 ; $139 = ( ( ( $21 ) ) + 4 | 0 ) ; HEAP32 [ $139 >> 2 ] = $$sink7 ; $$sink19 = $$sink ; label = 39 ; } else { $140 = $18 ; $141 = ( $140 | 0 ) == ( 3 ) ; if ( $141 ) { $142 = $11 ; $143 = ( $142 >>> 0 ) >= ( 52 ) ; if ( $143 ) { $144 = $8 ; $145 = ( ( ( $144 ) ) + 40 | 0 ) ; $146 = ( _bmp_get_dword ( $145 ) | 0 ) ; HEAP32 [ $21 >> 2 ] = $146 ; $147 = $8 ; $148 = ( ( ( $147 ) ) + 44 | 0 ) ; $149 = ( _bmp_get_dword ( $148 ) | 0 ) ; $150 = ( ( ( $21 ) ) + 4 | 0 ) ; HEAP32 [ $150 >> 2 ] = $149 ; $151 = $8 ; $152 = ( ( ( $151 ) ) + 48 | 0 ) ; $153 = ( _bmp_get_dword ( $152 ) | 0 ) ; $$sink19 = $153 ; label = 39 ; break ; } else { $154 = $4 ; _png_error ( $154 , 22427 ) ; // unreachable; } } } } while ( 0 ) ; if ( ( label | 0 ) == 39 ) { $155 = ( ( ( $21 ) ) + 8 | 0 ) ; HEAP32 [ $155 >> 2 ] = $$sink19 ; } $156 = $11 ; $157 = ( $156 >>> 0 ) >= ( 56 ) ; if ( $157 ) { $158 = $8 ; $159 = ( ( ( $158 ) ) + 52 | 0 ) ; $160 = ( _bmp_get_dword ( $159 ) | 0 ) ; $161 = ( ( ( $21 ) ) + 12 | 0 ) ; HEAP32 [ $161 >> 2 ] = $160 ; } } $162 = $18 ; switch ( $162 | 0 ) { case 0 : { $163 = $17 ; $164 = ( $163 >>> 0 ) > ( 0 ) ; if ( $164 ) { $165 = $17 ; $166 = ( 32 % ( $165 >>> 0 ) ) & - 1 ; $167 = ( $166 | 0 ) != ( 0 ) ; $168 = $17 ; $169 = ( $168 | 0 ) != ( 24 ) ; $or$cond12 = $167 & $169 ; if ( $or$cond12 ) { $17 = 0 ; } } break ; } case 1 : { $170 = $17 ; $171 = ( $170 | 0 ) != ( 8 ) ; if ( $171 ) { $17 = 0 ; } break ; } case 2 : { $172 = $17 ; $173 = ( $172 | 0 ) != ( 4 ) ; if ( $173 ) { $17 = 0 ; } break ; } case 3 : { $174 = $17 ; $175 = ( $174 | 0 ) != ( 16 ) ; $176 = $17 ; $177 = ( $176 | 0 ) != ( 32 ) ; $or$cond14 = $175 & $177 ; if ( $or$cond14 ) { $17 = 0 ; } break ; } case 4 : { $178 = $4 ; _png_error ( $178 , 22458 ) ; // unreachable; break ; } case 5 : { $179 = $6 ; $180 = ( _getc ( $179 ) | 0 ) ; $181 = $6 ; $182 = ( _ungetc ( $180 , $181 ) | 0 ) ; $183 = ( $182 | 0 ) == ( 0 ) ; if ( $183 ) { $184 = $4 ; _png_set_sig_bytes ( $184 , 8 ) ; } $185 = $4 ; $186 = $6 ; _png_set_read_fn ( $185 , $186 , 0 ) ; $187 = $4 ; $188 = $5 ; _png_read_png ( $187 , $188 , 0 , 0 ) ; $3 = 1 ; $376 = $3 ; STACKTOP = sp ; return ( $376 | 0 ) ; break ; } default : { $189 = $4 ; _png_error ( $189 , 22502 ) ; // unreachable; } } $190 = $13 ; $191 = ( $190 | 0 ) == ( 0 ) ; $192 = $13 ; $193 = ( $192 >>> 0 ) > ( 2147483647 ) ; $or$cond16 = $191 | $193 ; $194 = $14 ; $195 = ( $194 | 0 ) == ( 0 ) ; $or$cond18 = $or$cond16 | $195 ; if ( $or$cond18 ) { $196 = $4 ; _png_error ( $196 , 22545 ) ; // unreachable; } $197 = $17 ; $198 = ( $197 | 0 ) == ( 0 ) ; if ( $198 ) { $199 = $4 ; _png_error ( $199 , 22582 ) ; // unreachable; } $200 = $17 ; $201 = ( $200 >>> 0 ) <= ( 8 ) ; if ( $201 ) { $202 = $12 ; $203 = $19 ; $204 = ( ( $202 >>> 0 ) / ( $203 >>> 0 ) ) & - 1 ; $20 = $204 ; $205 = $20 ; $206 = ( $205 >>> 0 ) > ( 256 ) ; $$ = $206 ? 256 : $204 ; $20 = $$ ; $207 = $19 ; $208 = $20 ; $209 = Math_imul ( $207 , $208 ) | 0 ; $210 = $12 ; $211 = ( ( $210 ) - ( $209 ) ) | 0 ; $12 = $211 ; $212 = $13 ; $213 = $17 ; $214 = ( 32 / ( $213 >>> 0 ) ) & - 1 ; $215 = ( ( $212 ) + ( $214 ) ) | 0 ; $216 = ( ( $215 ) - 1 ) | 0 ; $217 = $17 ; $218 = ( 32 / ( $217 >>> 0 ) ) & - 1 ; $219 = ( ( $216 >>> 0 ) / ( $218 >>> 0 ) ) & - 1 ; $220 = $219 << 2 ; $15 = $220 ; $221 = $17 ; $24 = $221 ; $222 = $20 ; $223 = ( $222 >>> 0 ) > ( 0 ) ; $224 = $223 ? 3 : 0 ; $25 = $224 ; } else { $20 = 0 ; $24 = 8 ; $225 = $17 ; switch ( $225 | 0 ) { case 16 : { $226 = $13 ; $227 = $226 << 1 ; $228 = ( ( $227 ) + 3 ) | 0 ; $229 = $228 & - 4 ; $15 = $229 ; break ; } case 24 : { $230 = $13 ; $231 = ( $230 * 3 ) | 0 ; $232 = ( ( $231 ) + 3 ) | 0 ; $233 = $232 & - 4 ; $15 = $233 ; break ; } case 32 : { $234 = $13 ; $235 = $234 << 2 ; $15 = $235 ; break ; } default : { $24 = 0 ; $15 = 0 ; } } $236 = $15 ; $237 = $13 ; $238 = ( ( $236 >>> 0 ) / ( $237 >>> 0 ) ) & - 1 ; $239 = $17 ; $240 = ( ( $239 >>> 0 ) / 8 ) & - 1 ; $241 = ( $238 >>> 0 ) < ( $240 >>> 0 ) ; if ( $241 ) { $15 = 0 ; } $242 = ( ( ( $21 ) ) + 12 | 0 ) ; $243 = HEAP32 [ $242 >> 2 ] | 0 ; $244 = ( $243 | 0 ) != ( 0 ) ; $245 = $244 ? 6 : 2 ; $25 = $245 ; } $246 = $15 ; $247 = ( $246 | 0 ) == ( 0 ) ; $248 = $4 ; if ( $247 ) { _png_error ( $248 , 22614 ) ; // unreachable; } $249 = $5 ; $250 = $13 ; $251 = $14 ; $252 = $24 ; $253 = $25 ; _png_set_IHDR ( $248 , $249 , $250 , $251 , $252 , $253 , 0 , 0 , 0 ) ; $254 = $17 ; $255 = ( $254 >>> 0 ) > ( 8 ) ; L101 : do { if ( $255 ) { $31 = 0 ; while ( 1 ) { $256 = $31 ; $257 = ( $256 >>> 0 ) < ( 4 ) ; if ( ! ( $257 ) ) { break ; } $258 = $31 ; $259 = ( ( $21 ) + ( $258 << 2 ) | 0 ) ; $260 = HEAP32 [ $259 >> 2 ] | 0 ; $261 = $31 ; $262 = ( ( $22 ) + ( $261 ) | 0 ) ; $263 = $31 ; $264 = ( ( $23 ) + ( $263 ) | 0 ) ; _bmp_process_mask ( $260 , $262 , $264 ) ; $265 = $31 ; $266 = ( ( $265 ) + 1 ) | 0 ; $31 = $266 ; } $267 = HEAP8 [ $22 >> 0 ] | 0 ; $268 = $267 & 255 ; $269 = ( $268 | 0 ) == ( 0 ) ; if ( $269 ) { $278 = $4 ; _png_error ( $278 , 22660 ) ; // unreachable; } $270 = ( ( ( $22 ) ) + 1 | 0 ) ; $271 = HEAP8 [ $270 >> 0 ] | 0 ; $272 = $271 & 255 ; $273 = ( $272 | 0 ) == ( 0 ) ; if ( $273 ) { $278 = $4 ; _png_error ( $278 , 22660 ) ; // unreachable; } $274 = ( ( ( $22 ) ) + 2 | 0 ) ; $275 = HEAP8 [ $274 >> 0 ] | 0 ; $276 = $275 & 255 ; $277 = ( $276 | 0 ) == ( 0 ) ; if ( $277 ) { $278 = $4 ; _png_error ( $278 , 22660 ) ; // unreachable; } $279 = HEAP8 [ $22 >> 0 ] | 0 ; $280 = $279 & 255 ; $281 = ( $280 | 0 ) != ( 8 ) ; do { if ( ! ( $281 ) ) { $282 = ( ( ( $22 ) ) + 1 | 0 ) ; $283 = HEAP8 [ $282 >> 0 ] | 0 ; $284 = $283 & 255 ; $285 = ( $284 | 0 ) != ( 8 ) ; if ( $285 ) { break ; } $286 = ( ( ( $22 ) ) + 2 | 0 ) ; $287 = HEAP8 [ $286 >> 0 ] | 0 ; $288 = $287 & 255 ; $289 = ( $288 | 0 ) != ( 8 ) ; if ( $289 ) { break ; } $290 = ( ( ( $22 ) ) + 3 | 0 ) ; $291 = HEAP8 [ $290 >> 0 ] | 0 ; $292 = $291 & 255 ; $293 = ( $292 | 0 ) != ( 0 ) ; if ( ! ( $293 ) ) { break L101 ; } $294 = ( ( ( $22 ) ) + 3 | 0 ) ; $295 = HEAP8 [ $294 >> 0 ] | 0 ; $296 = $295 & 255 ; $297 = ( $296 | 0 ) != ( 8 ) ; if ( ! ( $297 ) ) { break L101 ; } } } while ( 0 ) ; $298 = HEAP8 [ $22 >> 0 ] | 0 ; HEAP8 [ $27 >> 0 ] = $298 ; $299 = ( ( ( $22 ) ) + 1 | 0 ) ; $300 = HEAP8 [ $299 >> 0 ] | 0 ; $301 = ( ( ( $27 ) ) + 1 | 0 ) ; HEAP8 [ $301 >> 0 ] = $300 ; $302 = ( ( ( $22 ) ) + 2 | 0 ) ; $303 = HEAP8 [ $302 >> 0 ] | 0 ; $304 = ( ( ( $27 ) ) + 2 | 0 ) ; HEAP8 [ $304 >> 0 ] = $303 ; $305 = ( ( ( $22 ) ) + 3 | 0 ) ; $306 = HEAP8 [ $305 >> 0 ] | 0 ; $307 = ( ( ( $27 ) ) + 4 | 0 ) ; HEAP8 [ $307 >> 0 ] = $306 ; $308 = $4 ; $309 = $5 ; _png_set_sBIT ( $308 , $309 , $27 ) ; } } while ( 0 ) ; $310 = $20 ; $311 = ( $310 >>> 0 ) > ( 0 ) ; if ( $311 ) { $31 = 0 ; while ( 1 ) { $312 = $31 ; $313 = $20 ; $314 = ( $312 >>> 0 ) < ( $313 >>> 0 ) ; if ( ! ( $314 ) ) { break ; } $315 = $19 ; $316 = $6 ; $317 = ( _fread ( $9 , $315 , 1 , $316 ) | 0 ) ; $318 = ( $317 | 0 ) != ( 1 ) ; if ( $318 ) { break ; } $319 = ( ( ( $9 ) ) + 2 | 0 ) ; $320 = HEAP8 [ $319 >> 0 ] | 0 ; $321 = $31 ; $322 = ( ( $26 ) + ( ( $321 * 3 ) | 0 ) | 0 ) ; HEAP8 [ $322 >> 0 ] = $320 ; $323 = ( ( ( $9 ) ) + 1 | 0 ) ; $324 = HEAP8 [ $323 >> 0 ] | 0 ; $325 = $31 ; $326 = ( ( $26 ) + ( ( $325 * 3 ) | 0 ) | 0 ) ; $327 = ( ( ( $326 ) ) + 1 | 0 ) ; HEAP8 [ $327 >> 0 ] = $324 ; $328 = HEAP8 [ $9 >> 0 ] | 0 ; $329 = $31 ; $330 = ( ( $26 ) + ( ( $329 * 3 ) | 0 ) | 0 ) ; $331 = ( ( ( $330 ) ) + 2 | 0 ) ; HEAP8 [ $331 >> 0 ] = $328 ; $332 = $31 ; $333 = ( ( $332 ) + 1 ) | 0 ; $31 = $333 ; } $334 = $4 ; $335 = $5 ; $336 = $31 ; _png_set_PLTE ( $334 , $335 , $26 , $336 ) ; $337 = $31 ; $338 = $20 ; $339 = ( $337 | 0 ) != ( $338 | 0 ) ; if ( $339 ) { $340 = $4 ; _png_error ( $340 , 22691 ) ; // unreachable; } } $341 = $4 ; $342 = $5 ; $343 = $15 ; $344 = ( _pngx_malloc_rows_extended ( $341 , $342 , $343 , - 1 ) | 0 ) ; $28 = $344 ; $345 = $16 ; $346 = ( $345 | 0 ) != ( 0 ) ; $347 = $28 ; if ( $346 ) { $29 = $347 ; $348 = $28 ; $349 = $14 ; $350 = ( ( $348 ) + ( $349 << 2 ) | 0 ) ; $30 = $350 ; } else { $351 = $14 ; $352 = ( ( $347 ) + ( $351 << 2 ) | 0 ) ; $353 = ( ( ( $352 ) ) + - 4 | 0 ) ; $29 = $353 ; $354 = $28 ; $355 = ( ( ( $354 ) ) + - 4 | 0 ) ; $30 = $355 ; } $356 = $12 ; $357 = ( $356 >>> 0 ) > ( 0 ) ; if ( $357 ) { $358 = $6 ; $359 = $12 ; ( _fseek ( $358 , $359 , 1 ) | 0 ) ; } $360 = $29 ; $361 = $30 ; $362 = $15 ; $363 = $18 ; $364 = $6 ; $365 = ( _bmp_read_rows ( $360 , $361 , $362 , $363 , $364 ) | 0 ) ; $32 = $365 ; $366 = $17 ; $367 = ( $366 >>> 0 ) > ( 8 ) ; if ( $367 ) { $368 = $28 ; $369 = $13 ; $370 = $14 ; $371 = $17 ; _bmp_to_png_rows ( $368 , $369 , $370 , $371 , $22 , $23 ) ; } $372 = $32 ; $373 = $14 ; $374 = ( $372 | 0 ) != ( $373 | 0 ) ; if ( $374 ) { $375 = $4 ; _png_error ( $375 , 22731 ) ; // unreachable; } $3 = 1 ; $376 = $3 ; STACKTOP = sp ; return ( $376 | 0 ) ; } } } $3 = 0 ; $376 = $3 ; STACKTOP = sp ; return ( $376 | 0 ) ; } function _bmp_process_mask ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $3 = $0 ; $4 = $1 ; $5 = $2 ; $6 = $5 ; HEAP8 [ $6 >> 0 ] = 0 ; $7 = $4 ; HEAP8 [ $7 >> 0 ] = 0 ; $8 = $3 ; $9 = ( $8 | 0 ) == ( 0 ) ; if ( $9 ) { STACKTOP = sp ; return ; } while ( 1 ) { $10 = $3 ; $11 = $10 & 1 ; $12 = ( $11 | 0 ) == ( 0 ) ; if ( ! ( $12 ) ) { break ; } $13 = $3 ; $14 = $13 >>> 1 ; $3 = $14 ; $15 = $5 ; $16 = HEAP8 [ $15 >> 0 ] | 0 ; $17 = ( ( $16 ) + 1 ) << 24 >> 24 ; HEAP8 [ $15 >> 0 ] = $17 ; } while ( 1 ) { $18 = $3 ; $19 = ( $18 | 0 ) != ( 0 ) ; if ( ! ( $19 ) ) { label = 9 ; break ; } $20 = $3 ; $21 = $20 & 1 ; $22 = ( $21 | 0 ) == ( 0 ) ; if ( $22 ) { break ; } $23 = $4 ; $24 = HEAP8 [ $23 >> 0 ] | 0 ; $25 = $24 & 255 ; $26 = ( $25 | 0 ) >= ( 8 ) ; if ( $26 ) { break ; } $28 = $3 ; $29 = $28 >>> 1 ; $3 = $29 ; $30 = $4 ; $31 = HEAP8 [ $30 >> 0 ] | 0 ; $32 = ( ( $31 ) + 1 ) << 24 >> 24 ; HEAP8 [ $30 >> 0 ] = $32 ; } if ( ( label | 0 ) == 9 ) { STACKTOP = sp ; return ; } $27 = $4 ; HEAP8 [ $27 >> 0 ] = 0 ; STACKTOP = sp ; return ; } function _bmp_read_rows ( $0 , $1 , $2 , $3 , $4 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; $4 = $4 | 0 ; var $$sink = 0 , $$sink8 = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 ; var $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 ; var $134 = 0 , $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 ; var $152 = 0 , $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 ; var $170 = 0 , $171 = 0 , $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 ; var $189 = 0 , $19 = 0 , $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 ; var $207 = 0 , $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 ; var $225 = 0 , $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $30 = 0 ; var $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 ; var $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 ; var $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 ; var $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $or$cond = 0 , $or$cond3 = 0 , $or$cond5 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 80 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 80 | 0 ) ; $6 = $0 ; $7 = $1 ; $8 = $2 ; $9 = $3 ; $10 = $4 ; $23 = $8 ; $24 = ( $23 | 0 ) == ( 0 ) ; if ( $24 ) { $5 = 0 ; $236 = $5 ; STACKTOP = sp ; return ( $236 | 0 ) ; } $25 = $6 ; $26 = $7 ; $27 = ( $25 >>> 0 ) <= ( $26 >>> 0 ) ; $28 = $27 ? 1 : - 1 ; $13 = $28 ; $14 = 0 ; $11 = 0 ; $29 = $9 ; $30 = ( $29 | 0 ) == ( 2 ) ; $31 = $8 ; do { if ( $30 ) { $32 = $31 << 1 ; $16 = $32 ; $33 = $16 ; $34 = $8 ; $35 = ( $33 >>> 0 ) <= ( $34 >>> 0 ) ; if ( ! ( $35 ) ) { $21 = 84 ; $22 = 85 ; break ; } $5 = 0 ; $236 = $5 ; STACKTOP = sp ; return ( $236 | 0 ) ; } else { $16 = $31 ; $21 = 86 ; $22 = 87 ; } } while ( 0 ) ; $36 = $9 ; $37 = ( $36 | 0 ) == ( 0 ) ; $38 = $9 ; $39 = ( $38 | 0 ) == ( 3 ) ; $or$cond = $37 | $39 ; L13 : do { if ( $or$cond ) { $40 = $6 ; $12 = $40 ; while ( 1 ) { $41 = $12 ; $42 = $7 ; $43 = ( $41 | 0 ) != ( $42 | 0 ) ; if ( ! ( $43 ) ) { break L13 ; } $44 = $22 ; $45 = $12 ; $46 = HEAP32 [ $45 >> 2 ] | 0 ; $47 = $16 ; $48 = $10 ; $49 = ( FUNCTION_TABLE_iiiii [ $44 & 127 ] ( $46 , 0 , $47 , $48 ) | 0 ) ; $14 = $49 ; $50 = $14 ; $51 = $16 ; $52 = ( $50 | 0 ) != ( $51 | 0 ) ; if ( $52 ) { break L13 ; } $53 = $11 ; $54 = ( ( $53 ) + 1 ) | 0 ; $11 = $54 ; $55 = $13 ; $56 = $12 ; $57 = ( ( $56 ) + ( $55 << 2 ) | 0 ) ; $12 = $57 ; } } else { $58 = $9 ; $59 = ( $58 | 0 ) == ( 1 ) ; $60 = $9 ; $61 = ( $60 | 0 ) == ( 2 ) ; $or$cond3 = $59 | $61 ; if ( ! ( $or$cond3 ) ) { $5 = 0 ; $236 = $5 ; STACKTOP = sp ; return ( $236 | 0 ) ; } $62 = $9 ; $63 = ( $62 | 0 ) == ( 1 ) ; $64 = $8 ; if ( $63 ) { $16 = $64 ; } else { $65 = $64 << 1 ; $16 = $65 ; $66 = $16 ; $67 = $8 ; $68 = ( $66 >>> 0 ) <= ( $67 >>> 0 ) ; if ( $68 ) { $5 = 0 ; $236 = $5 ; STACKTOP = sp ; return ( $236 | 0 ) ; } } $69 = $6 ; $12 = $69 ; while ( 1 ) { $70 = $12 ; $71 = $7 ; $72 = ( $70 | 0 ) != ( $71 | 0 ) ; if ( ! ( $72 ) ) { break L13 ; } $73 = $10 ; $74 = ( _getc ( $73 ) | 0 ) ; $20 = $74 ; $75 = $20 ; $18 = $75 ; $76 = $10 ; $77 = ( _getc ( $76 ) | 0 ) ; $20 = $77 ; $78 = $20 ; $19 = $78 ; $79 = $20 ; $80 = ( $79 | 0 ) == ( - 1 ) ; if ( $80 ) { break L13 ; } $81 = $18 ; $82 = ( $81 | 0 ) == ( 0 ) ; if ( ! ( $82 ) ) { $203 = $18 ; $204 = $16 ; $205 = $14 ; $206 = ( ( $204 ) - ( $205 ) ) | 0 ; $207 = ( $203 >>> 0 ) <= ( $206 >>> 0 ) ; if ( $207 ) { $208 = $18 ; $212 = $208 ; } else { $209 = $16 ; $210 = $14 ; $211 = ( ( $209 ) - ( $210 ) ) | 0 ; $212 = $211 ; } $17 = $212 ; $213 = $21 ; $214 = $12 ; $215 = HEAP32 [ $214 >> 2 ] | 0 ; $216 = $14 ; $217 = $19 ; $218 = $17 ; FUNCTION_TABLE_viiii [ $213 & 127 ] ( $215 , $216 , $217 , $218 ) ; $219 = $17 ; $220 = $14 ; $221 = ( ( $220 ) + ( $219 ) ) | 0 ; $14 = $221 ; continue ; } $83 = $19 ; $84 = ( $83 | 0 ) == ( 0 ) ; if ( $84 ) { $85 = $21 ; $86 = $12 ; $87 = HEAP32 [ $86 >> 2 ] | 0 ; $88 = $14 ; $89 = $16 ; $90 = $14 ; $91 = ( ( $89 ) - ( $90 ) ) | 0 ; FUNCTION_TABLE_viiii [ $85 & 127 ] ( $87 , $88 , 0 , $91 ) ; $92 = $13 ; $93 = $12 ; $94 = ( ( $93 ) + ( $92 << 2 ) | 0 ) ; $12 = $94 ; $14 = 0 ; $95 = $11 ; $96 = ( ( $95 ) + 1 ) | 0 ; $11 = $96 ; $97 = $12 ; $98 = $7 ; $99 = ( $97 | 0 ) == ( $98 | 0 ) ; if ( $99 ) { break ; } else { continue ; } } $109 = $19 ; $110 = ( $109 | 0 ) == ( 1 ) ; if ( $110 ) { label = 28 ; break ; } $132 = $19 ; $133 = ( $132 | 0 ) == ( 2 ) ; if ( ! ( $133 ) ) { $181 = $19 ; $182 = $16 ; $183 = $14 ; $184 = ( ( $182 ) - ( $183 ) ) | 0 ; $185 = ( $181 >>> 0 ) <= ( $184 >>> 0 ) ; if ( $185 ) { $186 = $19 ; $190 = $186 ; } else { $187 = $16 ; $188 = $14 ; $189 = ( ( $187 ) - ( $188 ) ) | 0 ; $190 = $189 ; } $17 = $190 ; $191 = $22 ; $192 = $12 ; $193 = HEAP32 [ $192 >> 2 ] | 0 ; $194 = $14 ; $195 = $17 ; $196 = $10 ; $197 = ( FUNCTION_TABLE_iiiii [ $191 & 127 ] ( $193 , $194 , $195 , $196 ) | 0 ) ; $198 = $17 ; $199 = ( $197 | 0 ) != ( $198 | 0 ) ; if ( $199 ) { break L13 ; } $200 = $17 ; $201 = $14 ; $202 = ( ( $201 ) + ( $200 ) ) | 0 ; $14 = $202 ; continue ; } $134 = $10 ; $135 = ( _getc ( $134 ) | 0 ) ; $20 = $135 ; $136 = $20 ; $18 = $136 ; $137 = $10 ; $138 = ( _getc ( $137 ) | 0 ) ; $20 = $138 ; $139 = $20 ; $19 = $139 ; $140 = $20 ; $141 = ( $140 | 0 ) == ( - 1 ) ; if ( $141 ) { break L13 ; } $142 = $18 ; $143 = $16 ; $144 = $14 ; $145 = ( ( $143 ) - ( $144 ) ) | 0 ; $146 = ( $142 >>> 0 ) < ( $145 >>> 0 ) ; if ( $146 ) { $147 = $14 ; $148 = $18 ; $149 = ( ( $147 ) + ( $148 ) ) | 0 ; $151 = $149 ; } else { $150 = $16 ; $151 = $150 ; } $15 = $151 ; while ( 1 ) { $152 = $19 ; $153 = ( $152 >>> 0 ) > ( 0 ) ; if ( ! ( $153 ) ) { break ; } $154 = $21 ; $155 = $12 ; $156 = HEAP32 [ $155 >> 2 ] | 0 ; $157 = $14 ; $158 = $16 ; $159 = $14 ; $160 = ( ( $158 ) - ( $159 ) ) | 0 ; FUNCTION_TABLE_viiii [ $154 & 127 ] ( $156 , $157 , 0 , $160 ) ; $161 = $13 ; $162 = $12 ; $163 = ( ( $162 ) + ( $161 << 2 ) | 0 ) ; $12 = $163 ; $14 = 0 ; $164 = $11 ; $165 = ( ( $164 ) + 1 ) | 0 ; $11 = $165 ; $166 = $12 ; $167 = $7 ; $168 = ( $166 | 0 ) == ( $167 | 0 ) ; if ( $168 ) { break ; } $169 = $19 ; $170 = ( ( $169 ) + - 1 ) | 0 ; $19 = $170 ; } $171 = $12 ; $172 = $7 ; $173 = ( $171 | 0 ) != ( $172 | 0 ) ; if ( ! ( $173 ) ) { continue ; } $174 = $21 ; $175 = $12 ; $176 = HEAP32 [ $175 >> 2 ] | 0 ; $177 = $14 ; $178 = $15 ; $179 = $14 ; $180 = ( ( $178 ) - ( $179 ) ) | 0 ; FUNCTION_TABLE_viiii [ $174 & 127 ] ( $176 , $177 , 0 , $180 ) ; } if ( ( label | 0 ) == 28 ) { $111 = $21 ; $112 = $12 ; $113 = HEAP32 [ $112 >> 2 ] | 0 ; $114 = $14 ; $115 = $16 ; $116 = $14 ; $117 = ( ( $115 ) - ( $116 ) ) | 0 ; FUNCTION_TABLE_viiii [ $111 & 127 ] ( $113 , $114 , 0 , $117 ) ; $118 = $13 ; $119 = $12 ; $120 = ( ( $119 ) + ( $118 << 2 ) | 0 ) ; $12 = $120 ; $14 = 0 ; $121 = $6 ; $122 = $7 ; $123 = ( $121 >>> 0 ) <= ( $122 >>> 0 ) ; $124 = $6 ; $125 = $7 ; $126 = $7 ; $127 = $6 ; $$sink8 = $123 ? $126 : $124 ; $$sink = $123 ? $127 : $125 ; $128 = $$sink8 ; $129 = $$sink ; $130 = ( ( $128 ) - ( $129 ) ) | 0 ; $131 = ( ( $130 | 0 ) / 4 ) & - 1 ; $11 = $131 ; break ; } $100 = $10 ; $101 = ( _getc ( $100 ) | 0 ) ; $20 = $101 ; $102 = $20 ; $103 = ( $102 | 0 ) != ( - 1 ) ; $104 = $20 ; $105 = ( $104 | 0 ) != ( 0 ) ; $or$cond5 = $103 & $105 ; if ( $or$cond5 ) { $106 = $20 ; $107 = $10 ; ( _ungetc ( $106 , $107 ) | 0 ) ; break ; } else { $108 = $10 ; ( _getc ( $108 ) | 0 ) ; break ; } } } while ( 0 ) ; while ( 1 ) { $222 = $12 ; $223 = $7 ; $224 = ( $222 | 0 ) != ( $223 | 0 ) ; if ( ! ( $224 ) ) { break ; } $225 = $21 ; $226 = $12 ; $227 = HEAP32 [ $226 >> 2 ] | 0 ; $228 = $14 ; $229 = $16 ; $230 = $14 ; $231 = ( ( $229 ) - ( $230 ) ) | 0 ; FUNCTION_TABLE_viiii [ $225 & 127 ] ( $227 , $228 , 0 , $231 ) ; $14 = 0 ; $232 = $13 ; $233 = $12 ; $234 = ( ( $233 ) + ( $232 << 2 ) | 0 ) ; $12 = $234 ; } $235 = $11 ; $5 = $235 ; $236 = $5 ; STACKTOP = sp ; return ( $236 | 0 ) ; } function _bmp_to_png_rows ( $0 , $1 , $2 , $3 , $4 , $5 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; $4 = $4 | 0 ; $5 = $5 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 ; var $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 ; var $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 ; var $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 ; var $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 , $208 = 0 ; var $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 ; var $37 = 0 , $38 = 0 , $39 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 ; var $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 ; var $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 ; var $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 96 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 96 | 0 ) ; $14 = sp + 32 | 0 ; $6 = $0 ; $7 = $1 ; $8 = $2 ; $9 = $3 ; $10 = $4 ; $11 = $5 ; $24 = $9 ; $25 = ( $24 | 0 ) == ( 24 ) ; if ( $25 ) { $21 = 0 ; while ( 1 ) { $26 = $21 ; $27 = $8 ; $28 = ( $26 >>> 0 ) < ( $27 >>> 0 ) ; if ( ! ( $28 ) ) { break ; } $29 = $6 ; $30 = $21 ; $31 = ( ( $29 ) + ( $30 << 2 ) | 0 ) ; $32 = HEAP32 [ $31 >> 2 ] | 0 ; $12 = $32 ; $20 = 0 ; while ( 1 ) { $33 = $20 ; $34 = $7 ; $35 = ( $33 >>> 0 ) < ( $34 >>> 0 ) ; if ( ! ( $35 ) ) { break ; } $36 = $12 ; $37 = HEAP8 [ $36 >> 0 ] | 0 ; $23 = $37 ; $38 = $12 ; $39 = ( ( ( $38 ) ) + 2 | 0 ) ; $40 = HEAP8 [ $39 >> 0 ] | 0 ; $41 = $12 ; HEAP8 [ $41 >> 0 ] = $40 ; $42 = $23 ; $43 = $12 ; $44 = ( ( ( $43 ) ) + 2 | 0 ) ; HEAP8 [ $44 >> 0 ] = $42 ; $45 = $20 ; $46 = ( ( $45 ) + 1 ) | 0 ; $20 = $46 ; $47 = $12 ; $48 = ( ( ( $47 ) ) + 3 | 0 ) ; $12 = $48 ; } $49 = $21 ; $50 = ( ( $49 ) + 1 ) | 0 ; $21 = $50 ; } STACKTOP = sp ; return ; } $51 = $10 ; $52 = ( ( ( $51 ) ) + 3 | 0 ) ; $53 = HEAP8 [ $52 >> 0 ] | 0 ; $54 = $53 & 255 ; $55 = ( $54 | 0 ) != ( 0 ) ; $56 = $55 ? 4 : 3 ; $15 = $56 ; $22 = 0 ; while ( 1 ) { $57 = $22 ; $58 = $15 ; $59 = ( $57 >>> 0 ) < ( $58 >>> 0 ) ; if ( ! ( $59 ) ) { break ; } $60 = $10 ; $61 = $22 ; $62 = ( ( $60 ) + ( $61 ) | 0 ) ; $63 = HEAP8 [ $62 >> 0 ] | 0 ; $64 = $63 & 255 ; $65 = 1 << $64 ; $66 = ( ( $65 ) - 1 ) | 0 ; $67 = $22 ; $68 = ( ( $14 ) + ( $67 << 2 ) | 0 ) ; HEAP32 [ $68 >> 2 ] = $66 ; $69 = $22 ; $70 = ( ( $69 ) + 1 ) | 0 ; $22 = $70 ; } $71 = $9 ; $72 = ( $71 | 0 ) == ( 16 ) ; if ( $72 ) { $21 = 0 ; while ( 1 ) { $73 = $21 ; $74 = $8 ; $75 = ( $73 >>> 0 ) < ( $74 >>> 0 ) ; if ( ! ( $75 ) ) { break ; } $76 = $6 ; $77 = $21 ; $78 = ( ( $76 ) + ( $77 << 2 ) | 0 ) ; $79 = HEAP32 [ $78 >> 2 ] | 0 ; $80 = $7 ; $81 = ( ( $80 ) - 1 ) | 0 ; $82 = $81 << 1 ; $83 = ( ( $79 ) + ( $82 ) | 0 ) ; $12 = $83 ; $84 = $6 ; $85 = $21 ; $86 = ( ( $84 ) + ( $85 << 2 ) | 0 ) ; $87 = HEAP32 [ $86 >> 2 ] | 0 ; $88 = $7 ; $89 = ( ( $88 ) - 1 ) | 0 ; $90 = $15 ; $91 = Math_imul ( $89 , $90 ) | 0 ; $92 = ( ( $87 ) + ( $91 ) | 0 ) ; $13 = $92 ; $20 = 0 ; while ( 1 ) { $93 = $20 ; $94 = $7 ; $95 = ( $93 >>> 0 ) < ( $94 >>> 0 ) ; if ( ! ( $95 ) ) { break ; } $96 = $12 ; $97 = HEAP8 [ $96 >> 0 ] | 0 ; $98 = $97 & 255 ; $99 = $12 ; $100 = ( ( ( $99 ) ) + 1 | 0 ) ; $101 = HEAP8 [ $100 >> 0 ] | 0 ; $102 = $101 & 255 ; $103 = $102 << 8 ; $104 = ( ( $98 ) + ( $103 ) ) | 0 ; $18 = $104 ; $22 = 0 ; while ( 1 ) { $105 = $22 ; $106 = $15 ; $107 = ( $105 >>> 0 ) < ( $106 >>> 0 ) ; if ( ! ( $107 ) ) { break ; } $108 = $22 ; $109 = ( ( $14 ) + ( $108 << 2 ) | 0 ) ; $110 = HEAP32 [ $109 >> 2 ] | 0 ; $17 = $110 ; $111 = $18 ; $112 = $11 ; $113 = $22 ; $114 = ( ( $112 ) + ( $113 ) | 0 ) ; $115 = HEAP8 [ $114 >> 0 ] | 0 ; $116 = $115 & 255 ; $117 = $111 >>> $116 ; $118 = $17 ; $119 = $117 & $118 ; $16 = $119 ; $120 = $16 ; $121 = ( $120 * 255 ) | 0 ; $122 = $17 ; $123 = ( ( $122 >>> 0 ) / 2 ) & - 1 ; $124 = ( ( $121 ) + ( $123 ) ) | 0 ; $125 = $17 ; $126 = ( ( $124 >>> 0 ) / ( $125 >>> 0 ) ) & - 1 ; $127 = $126 & 255 ; $128 = $13 ; $129 = $22 ; $130 = ( ( $128 ) + ( $129 ) | 0 ) ; HEAP8 [ $130 >> 0 ] = $127 ; $131 = $22 ; $132 = ( ( $131 ) + 1 ) | 0 ; $22 = $132 ; } $133 = $20 ; $134 = ( ( $133 ) + 1 ) | 0 ; $20 = $134 ; $135 = $12 ; $136 = ( ( ( $135 ) ) + - 2 | 0 ) ; $12 = $136 ; $137 = $15 ; $138 = $13 ; $139 = ( 0 - ( $137 ) ) | 0 ; $140 = ( ( $138 ) + ( $139 ) | 0 ) ; $13 = $140 ; } $141 = $21 ; $142 = ( ( $141 ) + 1 ) | 0 ; $21 = $142 ; } STACKTOP = sp ; return ; } $143 = $9 ; $144 = ( $143 | 0 ) == ( 32 ) ; if ( ! ( $144 ) ) { STACKTOP = sp ; return ; } $21 = 0 ; while ( 1 ) { $145 = $21 ; $146 = $8 ; $147 = ( $145 >>> 0 ) < ( $146 >>> 0 ) ; if ( ! ( $147 ) ) { break ; } $148 = $6 ; $149 = $21 ; $150 = ( ( $148 ) + ( $149 << 2 ) | 0 ) ; $151 = HEAP32 [ $150 >> 2 ] | 0 ; $13 = $151 ; $12 = $151 ; $20 = 0 ; while ( 1 ) { $152 = $20 ; $153 = $7 ; $154 = ( $152 >>> 0 ) < ( $153 >>> 0 ) ; if ( ! ( $154 ) ) { break ; } $155 = $12 ; $156 = HEAP8 [ $155 >> 0 ] | 0 ; $157 = $156 & 255 ; $158 = $12 ; $159 = ( ( ( $158 ) ) + 1 | 0 ) ; $160 = HEAP8 [ $159 >> 0 ] | 0 ; $161 = $160 & 255 ; $162 = $161 << 8 ; $163 = ( ( $157 ) + ( $162 ) ) | 0 ; $164 = $12 ; $165 = ( ( ( $164 ) ) + 2 | 0 ) ; $166 = HEAP8 [ $165 >> 0 ] | 0 ; $167 = $166 & 255 ; $168 = $167 << 16 ; $169 = ( ( $163 ) + ( $168 ) ) | 0 ; $170 = $12 ; $171 = ( ( ( $170 ) ) + 3 | 0 ) ; $172 = HEAP8 [ $171 >> 0 ] | 0 ; $173 = $172 & 255 ; $174 = $173 << 24 ; $175 = ( ( $169 ) + ( $174 ) ) | 0 ; $19 = $175 ; $22 = 0 ; while ( 1 ) { $176 = $22 ; $177 = $15 ; $178 = ( $176 >>> 0 ) < ( $177 >>> 0 ) ; if ( ! ( $178 ) ) { break ; } $179 = $22 ; $180 = ( ( $14 ) + ( $179 << 2 ) | 0 ) ; $181 = HEAP32 [ $180 >> 2 ] | 0 ; $17 = $181 ; $182 = $19 ; $183 = $11 ; $184 = $22 ; $185 = ( ( $183 ) + ( $184 ) | 0 ) ; $186 = HEAP8 [ $185 >> 0 ] | 0 ; $187 = $186 & 255 ; $188 = $182 >>> $187 ; $189 = $17 ; $190 = $188 & $189 ; $16 = $190 ; $191 = $16 ; $192 = ( $191 * 255 ) | 0 ; $193 = $17 ; $194 = ( ( $193 >>> 0 ) / 2 ) & - 1 ; $195 = ( ( $192 ) + ( $194 ) ) | 0 ; $196 = $17 ; $197 = ( ( $195 >>> 0 ) / ( $196 >>> 0 ) ) & - 1 ; $198 = $197 & 255 ; $199 = $13 ; $200 = $22 ; $201 = ( ( $199 ) + ( $200 ) | 0 ) ; HEAP8 [ $201 >> 0 ] = $198 ; $202 = $22 ; $203 = ( ( $202 ) + 1 ) | 0 ; $22 = $203 ; } $204 = $20 ; $205 = ( ( $204 ) + 1 ) | 0 ; $20 = $205 ; $206 = $12 ; $207 = ( ( ( $206 ) ) + 4 | 0 ) ; $12 = $207 ; $208 = $15 ; $209 = $13 ; $210 = ( ( $209 ) + ( $208 ) | 0 ) ; $13 = $210 ; } $211 = $21 ; $212 = ( ( $211 ) + 1 ) | 0 ; $21 = $212 ; } STACKTOP = sp ; return ; } function _bmp_memset_halfbytes ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 ; var $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $7 = $3 ; $8 = $7 ; $9 = ( $8 | 0 ) == ( 0 ) ; if ( $9 ) { STACKTOP = sp ; return ; } $10 = $5 ; $11 = ( ( $10 >>> 0 ) / 2 ) & - 1 ; $12 = $4 ; $13 = ( ( $12 ) + ( $11 ) | 0 ) ; $4 = $13 ; $14 = $5 ; $15 = $14 & 1 ; $16 = ( $15 | 0 ) != ( 0 ) ; if ( $16 ) { $17 = $4 ; $18 = HEAP8 [ $17 >> 0 ] | 0 ; $19 = $18 & 255 ; $20 = $19 & 240 ; $21 = $6 ; $22 = $21 & 15 ; $23 = $20 | $22 ; $24 = $23 & 255 ; $25 = $4 ; HEAP8 [ $25 >> 0 ] = $24 ; $26 = $6 ; $27 = $26 & 240 ; $28 = $27 >> 4 ; $29 = $6 ; $30 = $29 & 15 ; $31 = $30 << 4 ; $32 = $28 | $31 ; $6 = $32 ; $33 = $4 ; $34 = ( ( ( $33 ) ) + 1 | 0 ) ; $4 = $34 ; $35 = $7 ; $36 = ( ( $35 ) + - 1 ) | 0 ; $7 = $36 ; } $37 = $4 ; $38 = $6 ; $39 = $38 & 255 ; $40 = $7 ; $41 = ( ( $40 >>> 0 ) / 2 ) & - 1 ; _memset ( ( $37 | 0 ) , ( $39 | 0 ) , ( $41 | 0 ) ) | 0 ; $42 = $7 ; $43 = $42 & 1 ; $44 = ( $43 | 0 ) != ( 0 ) ; if ( ! ( $44 ) ) { STACKTOP = sp ; return ; } $45 = $6 ; $46 = $45 & 240 ; $47 = $46 & 255 ; $48 = $4 ; $49 = $7 ; $50 = ( ( $49 >>> 0 ) / 2 ) & - 1 ; $51 = ( ( $48 ) + ( $50 ) | 0 ) ; HEAP8 [ $51 >> 0 ] = $47 ; STACKTOP = sp ; return ; } function _bmp_fread_halfbytes ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 ; var $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $7 = 0 , $8 = 0 ; var $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $5 = $0 ; $6 = $1 ; $7 = $2 ; $8 = $3 ; $11 = $7 ; $12 = ( $11 | 0 ) == ( 0 ) ; if ( $12 ) { $4 = 0 ; $64 = $4 ; STACKTOP = sp ; return ( $64 | 0 ) ; } $13 = $6 ; $14 = ( ( $13 >>> 0 ) / 2 ) & - 1 ; $15 = $5 ; $16 = ( ( $15 ) + ( $14 ) | 0 ) ; $5 = $16 ; $17 = $6 ; $18 = $17 & 1 ; $19 = ( $18 | 0 ) != ( 0 ) ; L5 : do { if ( $19 ) { $9 = 0 ; while ( 1 ) { $20 = $9 ; $21 = $7 ; $22 = ( ( $21 ) - 1 ) | 0 ; $23 = ( $20 >>> 0 ) < ( $22 >>> 0 ) ; if ( ! ( $23 ) ) { break L5 ; } $24 = $8 ; $25 = ( _getc ( $24 ) | 0 ) ; $10 = $25 ; $26 = $10 ; $27 = ( $26 | 0 ) == ( - 1 ) ; if ( $27 ) { break L5 ; } $28 = $5 ; $29 = HEAP8 [ $28 >> 0 ] | 0 ; $30 = $29 & 255 ; $31 = $30 & 240 ; $32 = $10 ; $33 = $32 & 240 ; $34 = $33 >> 4 ; $35 = $31 | $34 ; $36 = $35 & 255 ; $37 = $5 ; HEAP8 [ $37 >> 0 ] = $36 ; $38 = $5 ; $39 = ( ( ( $38 ) ) + 1 | 0 ) ; $5 = $39 ; $40 = $10 ; $41 = $40 & 15 ; $42 = $41 << 4 ; $43 = $42 & 255 ; $44 = $5 ; HEAP8 [ $44 >> 0 ] = $43 ; $45 = $9 ; $46 = ( ( $45 ) + 2 ) | 0 ; $9 = $46 ; } } else { $47 = $5 ; $48 = $7 ; $49 = ( ( $48 ) + 1 ) | 0 ; $50 = ( ( $49 >>> 0 ) / 2 ) & - 1 ; $51 = $8 ; $52 = ( _fread ( $47 , 1 , $50 , $51 ) | 0 ) ; $53 = $52 << 1 ; $9 = $53 ; } } while ( 0 ) ; $54 = $7 ; $55 = $54 & 2 ; $56 = ( $55 | 0 ) != ( 0 ) ; if ( $56 ) { $57 = $8 ; ( _getc ( $57 ) | 0 ) ; } $58 = $9 ; $59 = $7 ; $60 = ( $58 >>> 0 ) <= ( $59 >>> 0 ) ; $61 = $9 ; $62 = $7 ; $63 = $60 ? $61 : $62 ; $4 = $63 ; $64 = $4 ; STACKTOP = sp ; return ( $64 | 0 ) ; } function _bmp_memset_bytes ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $7 = $3 ; $8 = $4 ; $9 = $5 ; $10 = ( ( $8 ) + ( $9 ) | 0 ) ; $11 = $6 ; $12 = $11 & 255 ; $13 = $7 ; _memset ( ( $10 | 0 ) , ( $12 | 0 ) , ( $13 | 0 ) ) | 0 ; STACKTOP = sp ; return ; } function _bmp_fread_bytes ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $7 = $3 ; $9 = $4 ; $10 = $5 ; $11 = ( ( $9 ) + ( $10 ) | 0 ) ; $12 = $6 ; $13 = $7 ; $14 = ( _fread ( $11 , 1 , $12 , $13 ) | 0 ) ; $8 = $14 ; $15 = $6 ; $16 = $15 & 1 ; $17 = ( $16 | 0 ) != ( 0 ) ; if ( ! ( $17 ) ) { $19 = $8 ; STACKTOP = sp ; return ( $19 | 0 ) ; } $18 = $7 ; ( _getc ( $18 ) | 0 ) ; $19 = $8 ; STACKTOP = sp ; return ( $19 | 0 ) ; } function _pngx_sig_is_gif ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 ; var label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $5 = $0 ; $6 = $1 ; $7 = $2 ; $8 = $3 ; $9 = $6 ; $10 = ( $9 >>> 0 ) < ( 13 ) ; do { if ( $10 ) { $4 = - 1 ; } else { $11 = $5 ; $12 = ( _memcmp ( $11 , 22754 , 6 ) | 0 ) ; $13 = ( $12 | 0 ) != ( 0 ) ; if ( $13 ) { $14 = $5 ; $15 = ( _memcmp ( $14 , 22760 , 6 ) | 0 ) ; $16 = ( $15 | 0 ) != ( 0 ) ; if ( $16 ) { $4 = 0 ; break ; } } $17 = $7 ; $18 = ( $17 | 0 ) != ( 0 | 0 ) ; if ( $18 ) { $19 = $7 ; HEAP32 [ $19 >> 2 ] = 29762 ; } $20 = $8 ; $21 = ( $20 | 0 ) != ( 0 | 0 ) ; if ( $21 ) { $22 = $8 ; HEAP32 [ $22 >> 2 ] = 22766 ; } $4 = 1 ; } } while ( 0 ) ; $23 = $4 ; STACKTOP = sp ; return ( $23 | 0 ) ; } function _pngx_read_gif ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 ; var $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 ; var $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 1696 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 1696 | 0 ) ; $6 = sp + 880 | 0 ; $7 = sp + 72 | 0 ; $8 = sp + 56 | 0 ; $9 = sp + 32 | 0 ; $11 = sp + 24 | 0 ; $12 = sp + 20 | 0 ; $3 = $0 ; $4 = $1 ; $5 = $2 ; HEAP32 [ 2363 ] = 88 ; HEAP32 [ 2364 ] = 89 ; $18 = $3 ; HEAP32 [ 8523 ] = $18 ; HEAP32 [ 8524 ] = 0 ; HEAP32 [ 8525 ] = 0 ; $19 = $5 ; _GIFReadScreen ( $6 , $19 ) ; $20 = HEAP32 [ $6 >> 2 ] | 0 ; $15 = $20 ; $21 = ( ( ( $6 ) ) + 4 | 0 ) ; $22 = HEAP32 [ $21 >> 2 ] | 0 ; $16 = $22 ; $23 = $3 ; $24 = $4 ; $25 = $15 ; $26 = $16 ; _png_set_IHDR ( $23 , $24 , $25 , $26 , 8 , 3 , 0 , 0 , 0 ) ; $27 = $3 ; $28 = $4 ; $29 = ( ( ( $6 ) ) + 24 | 0 ) ; $30 = HEAP32 [ $29 >> 2 ] | 0 ; $31 = ( _pngx_malloc_rows ( $27 , $28 , $30 ) | 0 ) ; $17 = $31 ; $32 = $17 ; _GIFInitImage ( $7 , $6 , $32 ) ; HEAP32 [ 8524 ] = $7 ; _GIFInitExtension ( $8 , $6 , 256 ) ; HEAP32 [ 8525 ] = $8 ; $14 = 0 ; $13 = - 1 ; while ( 1 ) { $33 = $5 ; $34 = ( _GIFReadNextBlock ( $7 , $8 , $33 ) | 0 ) ; $10 = $34 ; $35 = $10 ; $36 = ( $35 | 0 ) == ( 44 ) ; if ( ! ( $36 ) ) { $57 = $10 ; $58 = ( $57 | 0 ) == ( 33 ) ; if ( ! ( $58 ) ) { $73 = $10 ; $74 = ( $73 | 0 ) == ( 59 ) ; if ( $74 ) { break ; } else { continue ; } } $59 = ( ( ( $8 ) ) + 12 | 0 ) ; $60 = HEAP8 [ $59 >> 0 ] | 0 ; $61 = $60 & 255 ; $62 = ( $61 | 0 ) == ( 249 ) ; if ( ! ( $62 ) ) { continue ; } _GIFGetGraphicCtl ( $9 , $8 ) ; $63 = ( ( ( $7 ) ) + 804 | 0 ) ; $64 = HEAP32 [ $63 >> 2 ] | 0 ; $65 = ( $64 | 0 ) != ( 0 | 0 ) ; if ( ! ( $65 ) ) { continue ; } $66 = ( ( ( $9 ) ) + 8 | 0 ) ; $67 = HEAP32 [ $66 >> 2 ] | 0 ; $68 = ( $67 | 0 ) != ( 0 ) ; $69 = $13 ; $70 = ( $69 >>> 0 ) >= ( 256 ) ; $or$cond = $68 & $70 ; if ( ! ( $or$cond ) ) { continue ; } $71 = ( ( ( $9 ) ) + 16 | 0 ) ; $72 = HEAP32 [ $71 >> 2 ] | 0 ; $13 = $72 ; continue ; } $37 = ( ( ( $7 ) ) + 804 | 0 ) ; $38 = HEAP32 [ $37 >> 2 ] | 0 ; $39 = ( $38 | 0 ) != ( 0 | 0 ) ; if ( $39 ) { $40 = ( ( ( $7 ) ) + 24 | 0 ) ; $41 = HEAP32 [ $40 >> 2 ] | 0 ; $42 = ( $41 | 0 ) != ( 0 ) ; if ( $42 ) { $43 = $3 ; $44 = $4 ; _pngx_set_interlace_type ( $43 , $44 , 1 ) ; } _GIFGetColorTable ( $11 , $12 , $7 ) ; $45 = $3 ; $46 = $4 ; $47 = HEAP32 [ $11 >> 2 ] | 0 ; $48 = HEAP32 [ $12 >> 2 ] | 0 ; _pngx_set_gif_palette ( $45 , $46 , $47 , $48 ) ; $49 = $13 ; $50 = ( $49 >>> 0 ) < ( 256 ) ; if ( $50 ) { $51 = $3 ; $52 = $4 ; $53 = $13 ; _pngx_set_gif_transparent ( $51 , $52 , $53 ) ; } $54 = ( ( ( $7 ) ) + 804 | 0 ) ; HEAP32 [ $54 >> 2 ] = 0 ; } $55 = $14 ; $56 = ( ( $55 ) + 1 ) | 0 ; $14 = $56 ; } $75 = ( ( ( $7 ) ) + 804 | 0 ) ; $76 = HEAP32 [ $75 >> 2 ] | 0 ; $77 = ( $76 | 0 ) != ( 0 | 0 ) ; if ( $77 ) { $78 = $3 ; _png_error ( $78 , 22794 ) ; // unreachable; } else { _GIFDestroyImage ( $7 ) ; _GIFDestroyExtension ( $8 ) ; $79 = $14 ; STACKTOP = sp ; return ( $79 | 0 ) ; } return ( 0 ) | 0 ; } function _pngx_gif_error ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $2 = HEAP32 [ 8524 ] | 0 ; $3 = ( $2 | 0 ) != ( 0 | 0 ) ; if ( $3 ) { $4 = HEAP32 [ 8524 ] | 0 ; _GIFDestroyImage ( $4 ) ; } $5 = HEAP32 [ 8525 ] | 0 ; $6 = ( $5 | 0 ) != ( 0 | 0 ) ; if ( $6 ) { $7 = HEAP32 [ 8525 ] | 0 ; _GIFDestroyExtension ( $7 ) ; } $8 = HEAP32 [ 8523 ] | 0 ; $9 = $1 ; _png_error ( $8 , $9 ) ; // unreachable; } function _pngx_gif_warning ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $2 = HEAP32 [ 8523 ] | 0 ; $3 = $1 ; _png_warning ( $2 , $3 ) ; STACKTOP = sp ; return ; } function _pngx_set_gif_palette ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 ; var sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 800 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 800 | 0 ) ; $8 = sp + 24 | 0 ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $7 = $3 ; $9 = 0 ; while ( 1 ) { $10 = $9 ; $11 = $7 ; $12 = ( $10 >>> 0 ) < ( $11 >>> 0 ) ; if ( ! ( $12 ) ) { break ; } $13 = $6 ; $14 = $9 ; $15 = ( $14 * 3 ) | 0 ; $16 = ( ( $13 ) + ( $15 ) | 0 ) ; $17 = HEAP8 [ $16 >> 0 ] | 0 ; $18 = $9 ; $19 = ( ( $8 ) + ( ( $18 * 3 ) | 0 ) | 0 ) ; HEAP8 [ $19 >> 0 ] = $17 ; $20 = $6 ; $21 = $9 ; $22 = ( $21 * 3 ) | 0 ; $23 = ( ( $22 ) + 1 ) | 0 ; $24 = ( ( $20 ) + ( $23 ) | 0 ) ; $25 = HEAP8 [ $24 >> 0 ] | 0 ; $26 = $9 ; $27 = ( ( $8 ) + ( ( $26 * 3 ) | 0 ) | 0 ) ; $28 = ( ( ( $27 ) ) + 1 | 0 ) ; HEAP8 [ $28 >> 0 ] = $25 ; $29 = $6 ; $30 = $9 ; $31 = ( $30 * 3 ) | 0 ; $32 = ( ( $31 ) + 2 ) | 0 ; $33 = ( ( $29 ) + ( $32 ) | 0 ) ; $34 = HEAP8 [ $33 >> 0 ] | 0 ; $35 = $9 ; $36 = ( ( $8 ) + ( ( $35 * 3 ) | 0 ) | 0 ) ; $37 = ( ( ( $36 ) ) + 2 | 0 ) ; HEAP8 [ $37 >> 0 ] = $34 ; $38 = $9 ; $39 = ( ( $38 ) + 1 ) | 0 ; $9 = $39 ; } $40 = $4 ; $41 = $5 ; $42 = $7 ; _png_set_PLTE ( $40 , $41 , $8 , $42 ) ; STACKTOP = sp ; return ; } function _pngx_set_gif_transparent ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 272 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 272 | 0 ) ; $6 = sp + 16 | 0 ; $3 = $0 ; $4 = $1 ; $5 = $2 ; $7 = 0 ; while ( 1 ) { $8 = $7 ; $9 = $5 ; $10 = ( $8 >>> 0 ) < ( $9 >>> 0 ) ; if ( ! ( $10 ) ) { break ; } $11 = $7 ; $12 = ( ( $6 ) + ( $11 ) | 0 ) ; HEAP8 [ $12 >> 0 ] = - 1 ; $13 = $7 ; $14 = ( ( $13 ) + 1 ) | 0 ; $7 = $14 ; } $15 = $5 ; $16 = ( ( $6 ) + ( $15 ) | 0 ) ; HEAP8 [ $16 >> 0 ] = 0 ; $17 = $3 ; $18 = $4 ; $19 = $5 ; $20 = ( ( $19 ) + 1 ) | 0 ; _png_set_tRNS ( $17 , $18 , $6 , $20 , 0 ) ; STACKTOP = sp ; return ; } function _pngx_sig_is_jpeg ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 ; var $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 ; var $or$cond3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $5 = $0 ; $6 = $1 ; $7 = $2 ; $8 = $3 ; $12 = $6 ; $13 = ( $12 >>> 0 ) < ( 12 ) ; if ( $13 ) { $4 = - 1 ; $62 = $4 ; STACKTOP = sp ; return ( $62 | 0 ) ; } $14 = $5 ; $15 = HEAP8 [ $14 >> 0 ] | 0 ; $16 = $15 & 255 ; $17 = ( $16 | 0 ) == ( 255 ) ; if ( $17 ) { $18 = $5 ; $19 = ( ( ( $18 ) ) + 1 | 0 ) ; $20 = HEAP8 [ $19 >> 0 ] | 0 ; $21 = $20 & 255 ; $22 = ( $21 | 0 ) == ( 216 ) ; if ( $22 ) { $23 = $5 ; $24 = ( ( ( $23 ) ) + 2 | 0 ) ; $25 = HEAP8 [ $24 >> 0 ] | 0 ; $26 = $25 & 255 ; $27 = ( $26 | 0 ) == ( 255 ) ; if ( $27 ) { $28 = $5 ; $29 = ( ( ( $28 ) ) + 3 | 0 ) ; $30 = HEAP8 [ $29 >> 0 ] | 0 ; $31 = $30 & 255 ; $32 = 65280 | $31 ; $10 = $32 ; $33 = $10 ; $34 = ( $33 >>> 0 ) >= ( 65472 ) ; $35 = $10 ; $36 = ( $35 >>> 0 ) <= ( 65487 ) ; $or$cond = $34 & $36 ; if ( ! ( $or$cond ) ) { $37 = $10 ; $38 = ( $37 >>> 0 ) >= ( 65498 ) ; $39 = $10 ; $40 = ( $39 >>> 0 ) <= ( 65534 ) ; $or$cond3 = $38 & $40 ; if ( ! ( $or$cond3 ) ) { $4 = 0 ; $62 = $4 ; STACKTOP = sp ; return ( $62 | 0 ) ; } } $9 = 22815 ; $11 = 1 ; } else { label = 10 ; } } else { label = 10 ; } } else { label = 10 ; } do { if ( ( label | 0 ) == 10 ) { $41 = $5 ; $42 = ( _memcmp ( $41 , 22820 , 12 ) | 0 ) ; $43 = ( $42 | 0 ) == ( 0 ) ; if ( ! ( $43 ) ) { $44 = $5 ; $45 = ( _memcmp ( $44 , 22832 , 4 ) | 0 ) ; $46 = ( $45 | 0 ) == ( 0 ) ; if ( ! ( $46 ) ) { $47 = $5 ; $48 = ( _memcmp ( $47 , 22846 , 8 ) | 0 ) ; $49 = ( $48 | 0 ) == ( 0 ) ; if ( ! ( $49 ) ) { $50 = $5 ; $51 = ( _memcmp ( $50 , 22854 , 8 ) | 0 ) ; $52 = ( $51 | 0 ) == ( 0 ) ; if ( ! ( $52 ) ) { $4 = 0 ; $62 = $4 ; STACKTOP = sp ; return ( $62 | 0 ) ; } } $9 = 22862 ; $11 = 3 ; break ; } } $9 = 22836 ; $11 = 2 ; } } while ( 0 ) ; $53 = $7 ; $54 = ( $53 | 0 ) != ( 0 | 0 ) ; if ( $54 ) { $55 = $9 ; $56 = $7 ; HEAP32 [ $56 >> 2 ] = $55 ; } $57 = $8 ; $58 = ( $57 | 0 ) != ( 0 | 0 ) ; if ( $58 ) { $59 = $9 ; $60 = $8 ; HEAP32 [ $60 >> 2 ] = $59 ; } $61 = $11 ; $4 = $61 ; $62 = $4 ; STACKTOP = sp ; return ( $62 | 0 ) ; } function _pngx_read_jpeg ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $7 = sp + 20 | 0 ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $9 = $6 ; $10 = ( _fread ( $7 , 12 , 1 , $9 ) | 0 ) ; $11 = ( $10 | 0 ) != ( 1 ) ; if ( $11 ) { $3 = 0 ; $17 = $3 ; STACKTOP = sp ; return ( $17 | 0 ) ; } $12 = ( _pngx_sig_is_jpeg ( $7 , 12 , 0 , 0 ) | 0 ) ; $8 = $12 ; $13 = $8 ; switch ( $13 | 0 ) { case 1 : { $14 = $4 ; _png_error ( $14 , 22866 ) ; // unreachable; break ; } case 2 : { $15 = $4 ; _png_error ( $15 , 22897 ) ; // unreachable; break ; } case 3 : { $16 = $4 ; _png_error ( $16 , 22933 ) ; // unreachable; break ; } default : { $3 = 0 ; $17 = $3 ; STACKTOP = sp ; return ( $17 | 0 ) ; } } return ( 0 ) | 0 ; } function _pngx_sig_is_pnm ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 ; var $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 ; var $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $5 = $0 ; $6 = $1 ; $7 = $2 ; $8 = $3 ; $9 = $6 ; $10 = ( $9 >>> 0 ) < ( 4 ) ; if ( $10 ) { $4 = - 1 ; $70 = $4 ; STACKTOP = sp ; return ( $70 | 0 ) ; } $11 = $5 ; $12 = HEAP8 [ $11 >> 0 ] | 0 ; $13 = $12 & 255 ; $14 = ( $13 | 0 ) != ( 80 ) ; if ( ! ( $14 ) ) { $15 = $5 ; $16 = ( ( ( $15 ) ) + 1 | 0 ) ; $17 = HEAP8 [ $16 >> 0 ] | 0 ; $18 = $17 & 255 ; $19 = ( $18 | 0 ) < ( 49 ) ; if ( ! ( $19 ) ) { $20 = $5 ; $21 = ( ( ( $20 ) ) + 1 | 0 ) ; $22 = HEAP8 [ $21 >> 0 ] | 0 ; $23 = $22 & 255 ; $24 = ( $23 | 0 ) > ( 55 ) ; if ( ! ( $24 ) ) { $25 = $5 ; $26 = ( ( ( $25 ) ) + 2 | 0 ) ; $27 = HEAP8 [ $26 >> 0 ] | 0 ; $28 = $27 & 255 ; $29 = ( $28 | 0 ) != ( 32 ) ; if ( $29 ) { $30 = $5 ; $31 = ( ( ( $30 ) ) + 2 | 0 ) ; $32 = HEAP8 [ $31 >> 0 ] | 0 ; $33 = $32 & 255 ; $34 = ( $33 | 0 ) != ( 9 ) ; if ( $34 ) { $35 = $5 ; $36 = ( ( ( $35 ) ) + 2 | 0 ) ; $37 = HEAP8 [ $36 >> 0 ] | 0 ; $38 = $37 & 255 ; $39 = ( $38 | 0 ) != ( 10 ) ; if ( $39 ) { $40 = $5 ; $41 = ( ( ( $40 ) ) + 2 | 0 ) ; $42 = HEAP8 [ $41 >> 0 ] | 0 ; $43 = $42 & 255 ; $44 = ( $43 | 0 ) != ( 13 ) ; if ( $44 ) { $45 = $5 ; $46 = ( ( ( $45 ) ) + 2 | 0 ) ; $47 = HEAP8 [ $46 >> 0 ] | 0 ; $48 = $47 & 255 ; $49 = ( $48 | 0 ) != ( 35 ) ; if ( $49 ) { $4 = 0 ; $70 = $4 ; STACKTOP = sp ; return ( $70 | 0 ) ; } } } } } $50 = $7 ; $51 = ( $50 | 0 ) != ( 0 | 0 ) ; if ( $51 ) { $52 = $5 ; $53 = ( ( ( $52 ) ) + 1 | 0 ) ; $54 = HEAP8 [ $53 >> 0 ] | 0 ; $55 = $54 & 255 ; $56 = ( ( $55 ) - 49 ) | 0 ; $57 = ( 192 + ( $56 << 2 ) | 0 ) ; $58 = HEAP32 [ $57 >> 2 ] | 0 ; $59 = $7 ; HEAP32 [ $59 >> 2 ] = $58 ; } $60 = $8 ; $61 = ( $60 | 0 ) != ( 0 | 0 ) ; if ( $61 ) { $62 = $5 ; $63 = ( ( ( $62 ) ) + 1 | 0 ) ; $64 = HEAP8 [ $63 >> 0 ] | 0 ; $65 = $64 & 255 ; $66 = ( ( $65 ) - 49 ) | 0 ; $67 = ( 220 + ( $66 << 2 ) | 0 ) ; $68 = HEAP32 [ $67 >> 2 ] | 0 ; $69 = $8 ; HEAP32 [ $69 >> 2 ] = $68 ; } $4 = 1 ; $70 = $4 ; STACKTOP = sp ; return ( $70 | 0 ) ; } } } $4 = 0 ; $70 = $4 ; STACKTOP = sp ; return ( $70 | 0 ) ; } function _pngx_read_pnm ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$ = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 ; var $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 ; var $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 ; var $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 ; var $171 = 0 , $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 ; var $19 = 0 , $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 ; var $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 ; var $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 ; var $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 ; var $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 ; var $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 ; var $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 112 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 112 | 0 ) ; $7 = sp + 68 | 0 ; $19 = sp + 104 | 0 ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $26 = $6 ; $27 = ( _pnm_fget_header ( $7 , $26 ) | 0 ) ; $28 = ( $27 | 0 ) != ( 1 ) ; if ( $28 ) { $3 = 0 ; $234 = $3 ; STACKTOP = sp ; return ( $234 | 0 ) ; } $29 = HEAP32 [ $7 >> 2 ] | 0 ; $8 = $29 ; $30 = ( ( ( $7 ) ) + 4 | 0 ) ; $31 = HEAP32 [ $30 >> 2 ] | 0 ; $9 = $31 ; $32 = ( ( ( $7 ) ) + 8 | 0 ) ; $33 = HEAP32 [ $32 >> 2 ] | 0 ; $10 = $33 ; $34 = ( ( ( $7 ) ) + 12 | 0 ) ; $35 = HEAP32 [ $34 >> 2 ] | 0 ; $11 = $35 ; $36 = ( ( ( $7 ) ) + 16 | 0 ) ; $37 = HEAP32 [ $36 >> 2 ] | 0 ; $12 = $37 ; $38 = $8 ; $39 = ( $38 >>> 0 ) > ( 6 ) ; if ( $39 ) { $40 = $4 ; _png_error ( $40 , 23051 ) ; // unreachable; } $41 = $9 ; $42 = ( 1073741823 / ( $41 >>> 0 ) ) & - 1 ; $13 = $42 ; $43 = $13 ; $44 = ( $43 >>> 0 ) > ( 2147483647 ) ; $$ = $44 ? 2147483647 : $42 ; $13 = $$ ; $45 = $10 ; $46 = $13 ; $47 = ( $45 >>> 0 ) > ( $46 >>> 0 ) ; if ( $47 ) { $48 = $4 ; _png_error ( $48 , 23098 ) ; // unreachable; } $15 = 1 ; $49 = $9 ; $50 = $10 ; $51 = Math_imul ( $49 , $50 ) | 0 ; $14 = $51 ; $17 = $51 ; $52 = $12 ; $53 = ( $52 >>> 0 ) > ( 65535 ) ; if ( $53 ) { $54 = $4 ; _png_error ( $54 , 23144 ) ; // unreachable; } $55 = $12 ; $56 = ( $55 >>> 0 ) > ( 255 ) ; if ( $56 ) { $15 = 2 ; $57 = $17 ; $58 = $57 << 1 ; $17 = $58 ; } $59 = $4 ; $60 = $5 ; $61 = $10 ; $62 = $11 ; $63 = $12 ; $64 = ( $63 >>> 0 ) <= ( 255 ) ; $65 = $64 ? 8 : 16 ; $66 = $9 ; $67 = ( $66 | 0 ) == ( 1 ) ; $68 = $67 ? 0 : 2 ; _png_set_IHDR ( $59 , $60 , $61 , $62 , $65 , $68 , 0 , 0 , 0 ) ; $20 = 1 ; $21 = 2 ; while ( 1 ) { $69 = $21 ; $70 = ( ( $69 ) - 1 ) | 0 ; $71 = $12 ; $72 = ( $70 >>> 0 ) < ( $71 >>> 0 ) ; if ( ! ( $72 ) ) { break ; } $73 = $20 ; $74 = ( ( $73 ) + 1 ) | 0 ; $20 = $74 ; $75 = $21 ; $76 = $75 << 1 ; $21 = $76 ; } $77 = $21 ; $78 = ( ( $77 ) - 1 ) | 0 ; $79 = $12 ; $80 = ( $78 | 0 ) != ( $79 | 0 ) ; do { if ( $80 ) { $81 = $4 ; _png_warning ( $81 , 23189 ) ; } else { $82 = $20 ; $83 = ( ( $82 >>> 0 ) % 8 ) & - 1 ; $84 = ( $83 | 0 ) != ( 0 ) ; if ( $84 ) { $85 = $9 ; $86 = ( $85 >>> 0 ) > ( 1 ) ; if ( ! ( $86 ) ) { $87 = $20 ; $88 = ( 8 % ( $87 >>> 0 ) ) & - 1 ; $89 = ( $88 | 0 ) != ( 0 ) ; if ( ! ( $89 ) ) { break ; } } $90 = $20 ; $91 = $90 & 255 ; $92 = ( ( ( $19 ) ) + 3 | 0 ) ; HEAP8 [ $92 >> 0 ] = $91 ; $93 = ( ( ( $19 ) ) + 2 | 0 ) ; HEAP8 [ $93 >> 0 ] = $91 ; $94 = ( ( ( $19 ) ) + 1 | 0 ) ; HEAP8 [ $94 >> 0 ] = $91 ; HEAP8 [ $19 >> 0 ] = $91 ; $95 = ( ( ( $19 ) ) + 4 | 0 ) ; HEAP8 [ $95 >> 0 ] = 0 ; $96 = $4 ; $97 = $5 ; _png_set_sBIT ( $96 , $97 , $19 ) ; } } } while ( 0 ) ; $98 = $4 ; $99 = $5 ; $100 = ( _pngx_malloc_rows ( $98 , $99 , - 1 ) | 0 ) ; $18 = $100 ; $101 = $8 ; $102 = ( $101 >>> 0 ) >= ( 4 ) ; if ( $102 ) { $103 = $12 ; $104 = ( $103 | 0 ) == ( 255 ) ; $105 = $12 ; $106 = ( $105 | 0 ) == ( 65535 ) ; $or$cond = $104 | $106 ; if ( $or$cond ) { $16 = 0 ; } else { label = 23 ; } } else { label = 23 ; } if ( ( label | 0 ) == 23 ) { $107 = $4 ; $108 = $14 ; $109 = $108 << 2 ; $110 = ( _png_malloc ( $107 , $109 ) | 0 ) ; $16 = $110 ; } $22 = 0 ; $23 = 0 ; $111 = $16 ; $112 = ( $111 | 0 ) != ( 0 | 0 ) ; $20 = 0 ; L35 : do { if ( $112 ) { while ( 1 ) { $113 = $20 ; $114 = $11 ; $115 = ( $113 >>> 0 ) < ( $114 >>> 0 ) ; if ( ! ( $115 ) ) { break L35 ; } $116 = $16 ; $117 = $6 ; $118 = ( _pnm_fget_values ( $7 , $116 , 1 , $117 ) | 0 ) ; $119 = ( $118 | 0 ) <= ( 0 ) ; if ( $119 ) { $22 = 1 ; } $120 = $12 ; $121 = ( $120 >>> 0 ) <= ( 255 ) ; $21 = 0 ; L42 : do { if ( $121 ) { while ( 1 ) { $122 = $21 ; $123 = $14 ; $124 = ( $122 >>> 0 ) < ( $123 >>> 0 ) ; if ( ! ( $124 ) ) { break L42 ; } $125 = $16 ; $126 = $21 ; $127 = ( ( $125 ) + ( $126 << 2 ) | 0 ) ; $128 = HEAP32 [ $127 >> 2 ] | 0 ; $24 = $128 ; $129 = $24 ; $130 = $12 ; $131 = ( $129 >>> 0 ) > ( $130 >>> 0 ) ; if ( $131 ) { $24 = 255 ; $23 = 1 ; } else { $132 = $12 ; $133 = ( $132 | 0 ) != ( 255 ) ; if ( $133 ) { $134 = $24 ; $135 = ( $134 * 255 ) | 0 ; $136 = $12 ; $137 = ( ( $136 >>> 0 ) / 2 ) & - 1 ; $138 = ( ( $135 ) + ( $137 ) ) | 0 ; $139 = $12 ; $140 = ( ( $138 >>> 0 ) / ( $139 >>> 0 ) ) & - 1 ; $24 = $140 ; } } $141 = $24 ; $142 = $141 & 255 ; $143 = $18 ; $144 = $20 ; $145 = ( ( $143 ) + ( $144 << 2 ) | 0 ) ; $146 = HEAP32 [ $145 >> 2 ] | 0 ; $147 = $21 ; $148 = ( ( $146 ) + ( $147 ) | 0 ) ; HEAP8 [ $148 >> 0 ] = $142 ; $149 = $21 ; $150 = ( ( $149 ) + 1 ) | 0 ; $21 = $150 ; } } else { while ( 1 ) { $151 = $21 ; $152 = $14 ; $153 = ( $151 >>> 0 ) < ( $152 >>> 0 ) ; if ( ! ( $153 ) ) { break L42 ; } $154 = $16 ; $155 = $21 ; $156 = ( ( $154 ) + ( $155 << 2 ) | 0 ) ; $157 = HEAP32 [ $156 >> 2 ] | 0 ; $25 = $157 ; $158 = $25 ; $159 = $12 ; $160 = ( $158 >>> 0 ) > ( $159 >>> 0 ) ; if ( $160 ) { $25 = 65535 ; $23 = 1 ; } else { $161 = $12 ; $162 = ( $161 | 0 ) != ( 65535 ) ; if ( $162 ) { $163 = $25 ; $164 = ( $163 * 65535 ) | 0 ; $165 = $12 ; $166 = ( ( $165 >>> 0 ) / 2 ) & - 1 ; $167 = ( ( $164 ) + ( $166 ) ) | 0 ; $168 = $12 ; $169 = ( ( $167 >>> 0 ) / ( $168 >>> 0 ) ) & - 1 ; $25 = $169 ; } } $170 = $25 ; $171 = $170 >>> 8 ; $172 = $171 & 255 ; $173 = $18 ; $174 = $20 ; $175 = ( ( $173 ) + ( $174 << 2 ) | 0 ) ; $176 = HEAP32 [ $175 >> 2 ] | 0 ; $177 = $21 ; $178 = $177 << 1 ; $179 = ( ( $176 ) + ( $178 ) | 0 ) ; HEAP8 [ $179 >> 0 ] = $172 ; $180 = $25 ; $181 = $180 & 255 ; $182 = $181 & 255 ; $183 = $18 ; $184 = $20 ; $185 = ( ( $183 ) + ( $184 << 2 ) | 0 ) ; $186 = HEAP32 [ $185 >> 2 ] | 0 ; $187 = $21 ; $188 = $187 << 1 ; $189 = ( ( $188 ) + 1 ) | 0 ; $190 = ( ( $186 ) + ( $189 ) | 0 ) ; HEAP8 [ $190 >> 0 ] = $182 ; $191 = $21 ; $192 = ( ( $191 ) + 1 ) | 0 ; $21 = $192 ; } } } while ( 0 ) ; $193 = $22 ; $194 = ( $193 | 0 ) != ( 0 ) ; if ( $194 ) { break L35 ; } $195 = $20 ; $196 = ( ( $195 ) + 1 ) | 0 ; $20 = $196 ; } } else { while ( 1 ) { $197 = $20 ; $198 = $11 ; $199 = ( $197 >>> 0 ) < ( $198 >>> 0 ) ; if ( ! ( $199 ) ) { break L35 ; } $200 = $18 ; $201 = $20 ; $202 = ( ( $200 ) + ( $201 << 2 ) | 0 ) ; $203 = HEAP32 [ $202 >> 2 ] | 0 ; $204 = $15 ; $205 = $6 ; $206 = ( _pnm_fget_bytes ( $7 , $203 , $204 , 1 , $205 ) | 0 ) ; $207 = ( $206 | 0 ) <= ( 0 ) ; if ( $207 ) { break ; } $208 = $20 ; $209 = ( ( $208 ) + 1 ) | 0 ; $20 = $209 ; } $22 = 1 ; } } while ( 0 ) ; while ( 1 ) { $210 = $20 ; $211 = $11 ; $212 = ( $210 >>> 0 ) < ( $211 >>> 0 ) ; if ( ! ( $212 ) ) { break ; } $213 = $18 ; $214 = $20 ; $215 = ( ( $213 ) + ( $214 << 2 ) | 0 ) ; $216 = HEAP32 [ $215 >> 2 ] | 0 ; $217 = $17 ; _memset ( ( $216 | 0 ) , 0 , ( $217 | 0 ) ) | 0 ; $218 = $20 ; $219 = ( ( $218 ) + 1 ) | 0 ; $20 = $219 ; } $220 = $16 ; $221 = ( $220 | 0 ) != ( 0 | 0 ) ; if ( $221 ) { $222 = $4 ; $223 = $16 ; _png_free ( $222 , $223 ) ; } $224 = $23 ; $225 = ( $224 | 0 ) != ( 0 ) ; if ( $225 ) { $226 = $4 ; _png_warning ( $226 , 23240 ) ; } $227 = $22 ; $228 = ( $227 | 0 ) != ( 0 ) ; if ( $228 ) { $229 = $4 ; _png_error ( $229 , 23264 ) ; // unreachable; } $230 = $6 ; $231 = ( _pnm_fpeek_eof ( $7 , $230 ) | 0 ) ; $232 = ( $231 | 0 ) != ( 0 ) ; if ( ! ( $232 ) ) { $233 = $4 ; _png_warning ( $233 , 23288 ) ; } $3 = 1 ; $234 = $3 ; STACKTOP = sp ; return ( $234 | 0 ) ; } function _pnm_fpeek_eof ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 ; var $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 ; var $or$cond10 = 0 , $or$cond3 = 0 , $or$cond5 = 0 , $or$cond8 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $3 = $0 ; $4 = $1 ; $6 = $3 ; $7 = HEAP32 [ $6 >> 2 ] | 0 ; $8 = ( $7 >>> 0 ) >= ( 1 ) ; L1 : do { if ( $8 ) { $9 = $3 ; $10 = HEAP32 [ $9 >> 2 ] | 0 ; $11 = ( $10 >>> 0 ) <= ( 3 ) ; if ( $11 ) { while ( 1 ) { $12 = $4 ; $13 = ( _getc ( $12 ) | 0 ) ; $5 = $13 ; $14 = $5 ; $15 = ( $14 | 0 ) == ( 35 ) ; if ( $15 ) { while ( 1 ) { $16 = $4 ; $17 = ( _getc ( $16 ) | 0 ) ; $5 = $17 ; $18 = $5 ; $19 = ( $18 | 0 ) != ( - 1 ) ; $20 = $5 ; $21 = ( $20 | 0 ) != ( 10 ) ; $or$cond = $19 & $21 ; $22 = $5 ; $23 = ( $22 | 0 ) != ( 13 ) ; $or$cond10 = $or$cond & $23 ; if ( ! ( $or$cond10 ) ) { break ; } } } $24 = $5 ; $25 = ( $24 | 0 ) == ( - 1 ) ; if ( $25 ) { break ; } $26 = $5 ; $27 = ( $26 | 0 ) == ( 32 ) ; $28 = $5 ; $29 = ( $28 | 0 ) == ( 9 ) ; $or$cond3 = $27 | $29 ; $30 = $5 ; $31 = ( $30 | 0 ) == ( 10 ) ; $or$cond5 = $or$cond3 | $31 ; $32 = $5 ; $33 = ( $32 | 0 ) == ( 13 ) ; $or$cond8 = $or$cond5 | $33 ; if ( ! ( $or$cond8 ) ) { break L1 ; } } $2 = 1 ; $40 = $2 ; STACKTOP = sp ; return ( $40 | 0 ) ; } else { label = 8 ; } } else { label = 8 ; } } while ( 0 ) ; if ( ( label | 0 ) == 8 ) { $34 = $4 ; $35 = ( _getc ( $34 ) | 0 ) ; $5 = $35 ; $36 = $5 ; $37 = ( $36 | 0 ) == ( - 1 ) ; if ( $37 ) { $2 = 1 ; $40 = $2 ; STACKTOP = sp ; return ( $40 | 0 ) ; } } $38 = $5 ; $39 = $4 ; ( _ungetc ( $38 , $39 ) | 0 ) ; $2 = 0 ; $40 = $2 ; STACKTOP = sp ; return ( $40 | 0 ) ; } function _pngx_sig_is_tiff ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 ; var label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $5 = $0 ; $6 = $1 ; $7 = $2 ; $8 = $3 ; $9 = $6 ; $10 = ( $9 >>> 0 ) < ( 8 ) ; do { if ( $10 ) { $4 = - 1 ; } else { $11 = $5 ; $12 = ( _memcmp ( $11 , 30563 , 4 ) | 0 ) ; $13 = ( $12 | 0 ) != ( 0 ) ; if ( $13 ) { $14 = $5 ; $15 = ( _memcmp ( $14 , 30567 , 4 ) | 0 ) ; $16 = ( $15 | 0 ) != ( 0 ) ; if ( $16 ) { $4 = 0 ; break ; } } $17 = $7 ; $18 = ( $17 | 0 ) != ( 0 | 0 ) ; if ( $18 ) { $19 = $7 ; HEAP32 [ $19 >> 2 ] = 23326 ; } $20 = $8 ; $21 = ( $20 | 0 ) != ( 0 | 0 ) ; if ( $21 ) { $22 = $8 ; HEAP32 [ $22 >> 2 ] = 23331 ; } $4 = 1 ; } } while ( 0 ) ; $23 = $4 ; STACKTOP = sp ; return ( $23 | 0 ) ; } function _pngx_read_tiff ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 ; var $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 ; var $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 ; var $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 ; var $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 , $208 = 0 ; var $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 ; var $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 ; var $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 ; var $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 ; var $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 128 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 128 | 0 ) ; $6 = sp + 56 | 0 ; $3 = $0 ; $4 = $1 ; $5 = $2 ; $22 = $3 ; HEAP32 [ 8526 ] = $22 ; HEAP32 [ 8527 ] = 0 ; _minitiff_init_info ( $6 ) ; HEAP32 [ $6 >> 2 ] = 90 ; $23 = ( ( ( $6 ) ) + 4 | 0 ) ; HEAP32 [ $23 >> 2 ] = 91 ; $24 = $5 ; _minitiff_read_info ( $6 , $24 ) ; _minitiff_validate_info ( $6 ) ; $25 = ( ( ( $6 ) ) + 12 | 0 ) ; $26 = HEAP32 [ $25 >> 2 ] | 0 ; $7 = $26 ; $27 = ( ( ( $6 ) ) + 16 | 0 ) ; $28 = HEAP32 [ $27 >> 2 ] | 0 ; $8 = $28 ; $29 = ( ( ( $6 ) ) + 44 | 0 ) ; $30 = HEAP32 [ $29 >> 2 ] | 0 ; $9 = $30 ; $31 = ( ( ( $6 ) ) + 20 | 0 ) ; $32 = HEAP32 [ $31 >> 2 ] | 0 ; $10 = $32 ; $33 = $9 ; switch ( $33 | 0 ) { case 1 : { $12 = 0 ; break ; } case 2 : { $12 = 4 ; break ; } case 3 : { $12 = 2 ; break ; } case 4 : { $12 = 6 ; break ; } default : { $34 = $3 ; _png_error ( $34 , 23356 ) ; // unreachable; } } $35 = $10 ; $36 = ( $35 >>> 0 ) > ( 16 ) ; if ( $36 ) { $37 = $3 ; _png_error ( $37 , 23385 ) ; // unreachable; } $38 = $10 ; $39 = 1 << $38 ; $40 = ( ( $39 ) - 1 ) | 0 ; $11 = $40 ; $13 = 0 ; $41 = $3 ; $42 = $4 ; $43 = $7 ; $44 = $8 ; $45 = $10 ; $46 = ( $45 >>> 0 ) <= ( 8 ) ; $47 = $46 ? 8 : 16 ; $48 = $12 ; _png_set_IHDR ( $41 , $42 , $43 , $44 , $47 , $48 , 0 , 0 , 0 ) ; $49 = $3 ; $50 = $4 ; $51 = ( _pngx_malloc_rows ( $49 , $50 , 0 ) | 0 ) ; $14 = $51 ; $52 = $10 ; $53 = ( $52 >>> 0 ) <= ( 8 ) ; $16 = 0 ; L11 : do { if ( $53 ) { while ( 1 ) { $54 = $16 ; $55 = $8 ; $56 = ( $54 >>> 0 ) < ( $55 >>> 0 ) ; if ( ! ( $56 ) ) { break L11 ; } $57 = $14 ; $58 = $16 ; $59 = ( ( $57 ) + ( $58 << 2 ) | 0 ) ; $60 = HEAP32 [ $59 >> 2 ] | 0 ; $15 = $60 ; $61 = $15 ; $62 = $16 ; $63 = $5 ; _minitiff_read_row ( $6 , $61 , $62 , $63 ) ; $64 = $10 ; $65 = ( $64 >>> 0 ) < ( 8 ) ; L15 : do { if ( $65 ) { $17 = 0 ; while ( 1 ) { $66 = $17 ; $67 = $9 ; $68 = $7 ; $69 = Math_imul ( $67 , $68 ) | 0 ; $70 = ( $66 >>> 0 ) < ( $69 >>> 0 ) ; if ( ! ( $70 ) ) { break L15 ; } $71 = $15 ; $72 = $17 ; $73 = ( ( $71 ) + ( $72 ) | 0 ) ; $74 = HEAP8 [ $73 >> 0 ] | 0 ; $75 = $74 & 255 ; $19 = $75 ; $76 = $19 ; $77 = $11 ; $78 = ( $76 >>> 0 ) > ( $77 >>> 0 ) ; if ( $78 ) { $79 = $11 ; $19 = $79 ; $13 = 1 ; } $80 = $19 ; $81 = ( $80 * 255 ) | 0 ; $82 = $11 ; $83 = ( ( $82 >>> 0 ) / 2 ) & - 1 ; $84 = ( ( $81 ) + ( $83 ) ) | 0 ; $85 = $11 ; $86 = ( ( $84 >>> 0 ) / ( $85 >>> 0 ) ) & - 1 ; $87 = $86 & 255 ; $88 = $15 ; $89 = $17 ; $90 = ( ( $88 ) + ( $89 ) | 0 ) ; HEAP8 [ $90 >> 0 ] = $87 ; $91 = $17 ; $92 = ( ( $91 ) + 1 ) | 0 ; $17 = $92 ; } } } while ( 0 ) ; $93 = ( ( ( $6 ) ) + 28 | 0 ) ; $94 = HEAP32 [ $93 >> 2 ] | 0 ; $95 = ( $94 | 0 ) == ( 0 ) ; L24 : do { if ( $95 ) { $17 = 0 ; while ( 1 ) { $96 = $17 ; $97 = $9 ; $98 = $7 ; $99 = Math_imul ( $97 , $98 ) | 0 ; $100 = ( $96 >>> 0 ) < ( $99 >>> 0 ) ; if ( ! ( $100 ) ) { break L24 ; } $101 = $15 ; $102 = $17 ; $103 = ( ( $101 ) + ( $102 ) | 0 ) ; $104 = HEAP8 [ $103 >> 0 ] | 0 ; $105 = $104 & 255 ; $106 = ( 255 - ( $105 ) ) | 0 ; $107 = $106 & 255 ; $108 = $15 ; $109 = $17 ; $110 = ( ( $108 ) + ( $109 ) | 0 ) ; HEAP8 [ $110 >> 0 ] = $107 ; $111 = $17 ; $112 = ( ( $111 ) + 1 ) | 0 ; $17 = $112 ; } } } while ( 0 ) ; $113 = $16 ; $114 = ( ( $113 ) + 1 ) | 0 ; $16 = $114 ; } } else { while ( 1 ) { $115 = $16 ; $116 = $8 ; $117 = ( $115 >>> 0 ) < ( $116 >>> 0 ) ; if ( ! ( $117 ) ) { break L11 ; } $118 = $14 ; $119 = $16 ; $120 = ( ( $118 ) + ( $119 << 2 ) | 0 ) ; $121 = HEAP32 [ $120 >> 2 ] | 0 ; $15 = $121 ; $122 = $15 ; $123 = $16 ; $124 = $5 ; _minitiff_read_row ( $6 , $122 , $123 , $124 ) ; $125 = ( ( ( $6 ) ) + 8 | 0 ) ; $126 = HEAP32 [ $125 >> 2 ] | 0 ; $127 = ( $126 | 0 ) == ( 73 ) ; L33 : do { if ( $127 ) { $18 = 0 ; $17 = 0 ; while ( 1 ) { $128 = $17 ; $129 = $9 ; $130 = $7 ; $131 = Math_imul ( $129 , $130 ) | 0 ; $132 = ( $128 >>> 0 ) < ( $131 >>> 0 ) ; if ( ! ( $132 ) ) { break L33 ; } $133 = $15 ; $134 = $18 ; $135 = ( ( $133 ) + ( $134 ) | 0 ) ; $136 = HEAP8 [ $135 >> 0 ] | 0 ; $20 = $136 ; $137 = $15 ; $138 = $18 ; $139 = ( ( $138 ) + 1 ) | 0 ; $140 = ( ( $137 ) + ( $139 ) | 0 ) ; $141 = HEAP8 [ $140 >> 0 ] | 0 ; $142 = $15 ; $143 = $18 ; $144 = ( ( $142 ) + ( $143 ) | 0 ) ; HEAP8 [ $144 >> 0 ] = $141 ; $145 = $20 ; $146 = $15 ; $147 = $18 ; $148 = ( ( $147 ) + 1 ) | 0 ; $149 = ( ( $146 ) + ( $148 ) | 0 ) ; HEAP8 [ $149 >> 0 ] = $145 ; $150 = $17 ; $151 = ( ( $150 ) + 1 ) | 0 ; $17 = $151 ; $152 = $18 ; $153 = ( ( $152 ) + 2 ) | 0 ; $18 = $153 ; } } } while ( 0 ) ; $154 = $10 ; $155 = ( $154 >>> 0 ) < ( 16 ) ; L39 : do { if ( $155 ) { $18 = 0 ; $17 = 0 ; while ( 1 ) { $156 = $18 ; $157 = $9 ; $158 = $7 ; $159 = Math_imul ( $157 , $158 ) | 0 ; $160 = ( $156 >>> 0 ) < ( $159 >>> 0 ) ; if ( ! ( $160 ) ) { break L39 ; } $161 = $15 ; $162 = $18 ; $163 = ( ( $161 ) + ( $162 ) | 0 ) ; $164 = HEAP8 [ $163 >> 0 ] | 0 ; $165 = $164 & 255 ; $166 = $165 << 8 ; $167 = $15 ; $168 = $18 ; $169 = ( ( $168 ) + 1 ) | 0 ; $170 = ( ( $167 ) + ( $169 ) | 0 ) ; $171 = HEAP8 [ $170 >> 0 ] | 0 ; $172 = $171 & 255 ; $173 = ( ( $166 ) + ( $172 ) ) | 0 ; $21 = $173 ; $174 = $21 ; $175 = $11 ; $176 = ( $174 >>> 0 ) > ( $175 >>> 0 ) ; if ( $176 ) { $177 = $11 ; $21 = $177 ; $13 = 1 ; } $178 = $21 ; $179 = ( $178 * 65535 ) | 0 ; $180 = $11 ; $181 = ( ( $180 >>> 0 ) / 2 ) & - 1 ; $182 = ( ( $179 ) + ( $181 ) ) | 0 ; $183 = $11 ; $184 = ( ( $182 >>> 0 ) / ( $183 >>> 0 ) ) & - 1 ; $21 = $184 ; $185 = $21 ; $186 = $185 >>> 8 ; $187 = $186 & 255 ; $188 = $15 ; $189 = $18 ; $190 = ( ( $188 ) + ( $189 ) | 0 ) ; HEAP8 [ $190 >> 0 ] = $187 ; $191 = $21 ; $192 = $191 & 255 ; $193 = $192 & 255 ; $194 = $15 ; $195 = $18 ; $196 = ( ( $195 ) + 1 ) | 0 ; $197 = ( ( $194 ) + ( $196 ) | 0 ) ; HEAP8 [ $197 >> 0 ] = $193 ; $198 = $17 ; $199 = ( ( $198 ) + 1 ) | 0 ; $17 = $199 ; $200 = $18 ; $201 = ( ( $200 ) + 2 ) | 0 ; $18 = $201 ; } } } while ( 0 ) ; $202 = $16 ; $203 = ( ( $202 ) + 1 ) | 0 ; $16 = $203 ; } } } while ( 0 ) ; $204 = $13 ; $205 = ( $204 | 0 ) != ( 0 ) ; if ( ! ( $205 ) ) { _minitiff_destroy_info ( $6 ) ; $207 = HEAP32 [ 8527 ] | 0 ; $208 = ( 1 + ( $207 ) ) | 0 ; STACKTOP = sp ; return ( $208 | 0 ) ; } $206 = $3 ; _png_warning ( $206 , 23415 ) ; _minitiff_destroy_info ( $6 ) ; $207 = HEAP32 [ 8527 ] | 0 ; $208 = ( 1 + ( $207 ) ) | 0 ; STACKTOP = sp ; return ( $208 | 0 ) ; } function _pngx_tiff_error ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $2 = HEAP32 [ 8526 ] | 0 ; $3 = $1 ; _png_error ( $2 , $3 ) ; // unreachable; } function _pngx_tiff_warning ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $2 = $1 ; $3 = ( _strstr ( $2 , 23440 ) | 0 ) ; $4 = ( $3 | 0 ) != ( 0 | 0 ) ; if ( ! ( $4 ) ) { STACKTOP = sp ; return ; } $5 = HEAP32 [ 8527 ] | 0 ; $6 = ( ( $5 ) + 1 ) | 0 ; HEAP32 [ 8527 ] = $6 ; STACKTOP = sp ; return ; } function _pngx_malloc_rows ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $3 = $0 ; $4 = $1 ; $5 = $2 ; $6 = $3 ; $7 = $4 ; $8 = $5 ; $9 = ( _pngx_malloc_rows_extended ( $6 , $7 , 0 , $8 ) | 0 ) ; STACKTOP = sp ; return ( $9 | 0 ) ; } function _pngx_malloc_rows_extended ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 ; var $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 ; var $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 48 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 48 | 0 ) ; $5 = $0 ; $6 = $1 ; $7 = $2 ; $8 = $3 ; $14 = $5 ; $15 = $6 ; $16 = ( _png_get_image_height ( $14 , $15 ) | 0 ) ; $12 = $16 ; $17 = $12 ; $18 = ( $17 | 0 ) == ( 0 ) ; $19 = $5 ; if ( $18 ) { _png_error ( $19 , 23452 ) ; // unreachable; } $20 = $6 ; $21 = ( _png_get_rowbytes ( $19 , $20 ) | 0 ) ; $9 = $21 ; $22 = $9 ; $23 = ( $22 | 0 ) == ( 0 ) ; $24 = $12 ; $25 = ( $24 >>> 0 ) > ( 1073741823 ) ; $or$cond = $23 | $25 ; if ( $or$cond ) { $26 = $5 ; _png_error ( $26 , 23465 ) ; // unreachable; } $27 = $9 ; $28 = $7 ; $29 = ( $27 >>> 0 ) < ( $28 >>> 0 ) ; if ( $29 ) { $30 = $7 ; $9 = $30 ; } $31 = $5 ; $32 = $6 ; _png_free_data ( $31 , $32 , 64 , 0 ) ; $33 = $5 ; $34 = $12 ; $35 = $34 << 2 ; $36 = ( _png_malloc ( $33 , $35 ) | 0 ) ; $11 = $36 ; $37 = $11 ; $38 = ( $37 | 0 ) == ( 0 | 0 ) ; if ( $38 ) { $4 = 0 ; $70 = $4 ; STACKTOP = sp ; return ( $70 | 0 ) ; } $13 = 0 ; while ( 1 ) { $39 = $13 ; $40 = $12 ; $41 = ( $39 >>> 0 ) < ( $40 >>> 0 ) ; $42 = $5 ; if ( ! ( $41 ) ) { label = 18 ; break ; } $43 = $9 ; $44 = ( _png_malloc ( $42 , $43 ) | 0 ) ; $10 = $44 ; $45 = $10 ; $46 = ( $45 | 0 ) == ( 0 | 0 ) ; if ( $46 ) { break ; } $55 = $8 ; $56 = ( $55 | 0 ) >= ( 0 ) ; if ( $56 ) { $57 = $10 ; $58 = $8 ; $59 = $58 & 255 ; $60 = $9 ; _memset ( ( $57 | 0 ) , ( $59 | 0 ) , ( $60 | 0 ) ) | 0 ; } $61 = $10 ; $62 = $11 ; $63 = $13 ; $64 = ( ( $62 ) + ( $63 << 2 ) | 0 ) ; HEAP32 [ $64 >> 2 ] = $61 ; $65 = $13 ; $66 = ( ( $65 ) + 1 ) | 0 ; $13 = $66 ; } if ( ( label | 0 ) == 18 ) { $67 = $6 ; $68 = $11 ; _png_set_rows ( $42 , $67 , $68 ) ; $69 = $11 ; $4 = $69 ; $70 = $4 ; STACKTOP = sp ; return ( $70 | 0 ) ; } while ( 1 ) { $47 = $13 ; $48 = ( $47 >>> 0 ) > ( 0 ) ; $49 = $5 ; $50 = $11 ; if ( ! ( $48 ) ) { break ; } $51 = $13 ; $52 = ( ( $51 ) + - 1 ) | 0 ; $13 = $52 ; $53 = ( ( $50 ) + ( $52 << 2 ) | 0 ) ; $54 = HEAP32 [ $53 >> 2 ] | 0 ; _png_free ( $49 , $54 ) ; } _png_free ( $49 , $50 ) ; $4 = 0 ; $70 = $4 ; STACKTOP = sp ; return ( $70 | 0 ) ; } function _pngx_set_interlace_type ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $3 = 0 ; var $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 48 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 48 | 0 ) ; $6 = sp + 24 | 0 ; $7 = sp + 20 | 0 ; $8 = sp + 16 | 0 ; $9 = sp + 12 | 0 ; $10 = sp + 8 | 0 ; $11 = sp + 4 | 0 ; $12 = sp ; $3 = $0 ; $4 = $1 ; $5 = $2 ; $13 = $3 ; $14 = $4 ; $15 = ( _png_get_IHDR ( $13 , $14 , $6 , $7 , $8 , $9 , $12 , $10 , $11 ) | 0 ) ; $16 = ( $15 | 0 ) != ( 0 ) ; if ( ! ( $16 ) ) { STACKTOP = sp ; return ; } $17 = $5 ; $18 = HEAP32 [ $12 >> 2 ] | 0 ; $19 = ( $17 | 0 ) == ( $18 | 0 ) ; if ( $19 ) { STACKTOP = sp ; return ; } $20 = $3 ; $21 = $4 ; $22 = HEAP32 [ $6 >> 2 ] | 0 ; $23 = HEAP32 [ $7 >> 2 ] | 0 ; $24 = HEAP32 [ $8 >> 2 ] | 0 ; $25 = HEAP32 [ $9 >> 2 ] | 0 ; $26 = $5 ; $27 = HEAP32 [ $10 >> 2 ] | 0 ; $28 = HEAP32 [ $11 >> 2 ] | 0 ; _png_set_IHDR ( $20 , $21 , $22 , $23 , $24 , $25 , $26 , $27 , $28 ) ; STACKTOP = sp ; return ; } function _png_set_sig_bytes ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$ = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $2 ) { return ; } $3 = ( $1 | 0 ) > ( 0 ) ; $$ = $3 ? $1 : 0 ; $4 = ( $$ >>> 0 ) > ( 8 ) ; if ( $4 ) { _png_error ( $0 , 23513 ) ; // unreachable; } $5 = $$ & 255 ; $6 = ( ( ( $0 ) ) + 229 | 0 ) ; HEAP8 [ $6 >> 0 ] = $5 ; return ; } function _png_sig_cmp ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$$0 = 0 , $$0 = 0 , $$010 = 0 , $10 = 0 , $11 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( $2 >>> 0 ) > ( 8 ) ; if ( $3 ) { $$0 = 8 ; } else { $4 = ( $2 | 0 ) == ( 0 ) ; if ( $4 ) { $$010 = - 1 ; return ( $$010 | 0 ) ; } else { $$0 = $2 ; } } $5 = ( $1 >>> 0 ) > ( 7 ) ; if ( $5 ) { $$010 = - 1 ; return ( $$010 | 0 ) ; } $6 = ( 23546 + ( $1 ) | 0 ) ; $7 = ( ( $0 ) + ( $1 ) | 0 ) ; $8 = ( ( $$0 ) + ( $1 ) ) | 0 ; $9 = ( $8 >>> 0 ) > ( 8 ) ; $10 = ( 8 - ( $1 ) ) | 0 ; $$$0 = $9 ? $10 : $$0 ; $11 = ( _memcmp ( $7 , $6 , $$$0 ) | 0 ) ; $$010 = $11 ; return ( $$010 | 0 ) ; } function _png_zalloc ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$0 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $3 ) { $$0 = 0 ; return ( $$0 | 0 ) ; } $4 = ( 4294967295 / ( $2 >>> 0 ) ) & - 1 ; $5 = ( $4 >>> 0 ) > ( $1 >>> 0 ) ; if ( $5 ) { $6 = Math_imul ( $2 , $1 ) | 0 ; $7 = ( _png_malloc_warn ( $0 , $6 ) | 0 ) ; $$0 = $7 ; return ( $$0 | 0 ) ; } else { _png_warning ( $0 , 23554 ) ; $$0 = 0 ; return ( $$0 | 0 ) ; } return ( 0 ) | 0 ; } function _png_zfree ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var label = 0 , sp = 0 ; sp = STACKTOP ; _png_free ( $0 , $1 ) ; return ; } function _png_reset_crc ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( _crc32 ( 0 , 0 , 0 ) | 0 ) ; $2 = ( ( ( $0 ) ) + 200 | 0 ) ; HEAP32 [ $2 >> 2 ] = $1 ; return ; } function _png_calculate_crc ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$ = 0 , $$0 = 0 , $$022 = 0 , $$023 = 0 , $$024 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 ; var $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( ( ( $0 ) ) + 172 | 0 ) ; $4 = HEAP32 [ $3 >> 2 ] | 0 ; $5 = $4 & 536870912 ; $6 = ( $5 | 0 ) == ( 0 ) ; $7 = ( ( ( $0 ) ) + 28 | 0 ) ; $8 = HEAP32 [ $7 >> 2 ] | 0 ; $9 = $8 & 768 ; $10 = ( $9 | 0 ) != ( 768 ) ; $11 = $8 & 2048 ; $12 = ( $11 | 0 ) == ( 0 ) ; $$023 = $6 ? $12 : $10 ; $13 = ( $2 | 0 ) != ( 0 ) ; $or$cond = $13 & $$023 ; if ( ! ( $or$cond ) ) { return ; } $14 = ( ( ( $0 ) ) + 200 | 0 ) ; $15 = HEAP32 [ $14 >> 2 ] | 0 ; $$0 = $1 ; $$022 = $15 ; $$024 = $2 ; while ( 1 ) { $16 = ( $$024 | 0 ) == ( 0 ) ; $$ = $16 ? - 1 : $$024 ; $17 = ( _crc32 ( $$022 , $$0 , $$ ) | 0 ) ; $18 = ( ( $$0 ) + ( $$ ) | 0 ) ; $19 = ( ( $$024 ) - ( $$ ) ) | 0 ; $20 = ( $19 | 0 ) == ( 0 ) ; if ( $20 ) { break ; } else { $$0 = $18 ; $$022 = $17 ; $$024 = $19 ; } } HEAP32 [ $14 >> 2 ] = $17 ; return ; } function _png_user_version_check ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$$028 = 0 , $$0 = 0 , $$028 = 0 , $$029 = 0 , $$pre = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 ; var $24 = 0 , $25 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 128 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 128 | 0 ) ; $2 = sp ; $3 = ( $1 | 0 ) == ( 0 | 0 ) ; $4 = ( ( ( $0 ) ) + 28 | 0 ) ; if ( $3 ) { $18 = HEAP32 [ $4 >> 2 ] | 0 ; $19 = $18 | 131072 ; HEAP32 [ $4 >> 2 ] = $19 ; $21 = $19 ; } else { $$028 = 0 ; $$029 = - 1 ; while ( 1 ) { $5 = ( ( $$029 ) + 1 ) | 0 ; $6 = ( ( $1 ) + ( $5 ) | 0 ) ; $7 = HEAP8 [ $6 >> 0 ] | 0 ; $8 = ( 23589 + ( $5 ) | 0 ) ; $9 = HEAP8 [ $8 >> 0 ] | 0 ; $10 = ( $7 << 24 >> 24 ) == ( $9 << 24 >> 24 ) ; if ( ! ( $10 ) ) { $11 = HEAP32 [ $4 >> 2 ] | 0 ; $12 = $11 | 131072 ; HEAP32 [ $4 >> 2 ] = $12 ; } $13 = ( $7 << 24 >> 24 ) == ( 46 ) ; $14 = $13 & 1 ; $$$028 = ( ( $$028 ) + ( $14 ) ) | 0 ; $15 = ( $$$028 | 0 ) < ( 2 ) ; if ( ! ( $15 ) ) { break ; } $16 = ( $7 << 24 >> 24 ) == ( 0 ) ; $17 = ( $5 | 0 ) == ( 6 ) ; $or$cond = $17 | $16 ; if ( $or$cond ) { break ; } else { $$028 = $$$028 ; $$029 = $5 ; } } $$pre = HEAP32 [ $4 >> 2 ] | 0 ; $21 = $$pre ; } $20 = $21 & 131072 ; $22 = ( $20 | 0 ) == ( 0 ) ; if ( $22 ) { $$0 = 1 ; STACKTOP = sp ; return ( $$0 | 0 ) ; } $23 = ( _png_safecat ( $2 , 128 , 0 , 23596 ) | 0 ) ; $24 = ( _png_safecat ( $2 , 128 , $23 , $1 ) | 0 ) ; $25 = ( _png_safecat ( $2 , 128 , $24 , 23627 ) | 0 ) ; ( _png_safecat ( $2 , 128 , $25 , 23589 ) | 0 ) ; _png_warning ( $0 , $2 ) ; $$0 = 0 ; STACKTOP = sp ; return ( $$0 | 0 ) ; } function _png_create_png_struct ( $0 , $1 , $2 , $3 , $4 , $5 , $6 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; $4 = $4 | 0 ; $5 = $5 | 0 ; $6 = $6 | 0 ; var $$1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 400 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 400 | 0 ) ; $7 = sp ; _memset ( ( $7 | 0 ) , 0 , 396 ) | 0 ; $8 = ( ( ( $7 ) ) + 320 | 0 ) ; HEAP32 [ $8 >> 2 ] = 1000000 ; $9 = ( ( ( $7 ) ) + 324 | 0 ) ; HEAP32 [ $9 >> 2 ] = 1000000 ; $10 = ( ( ( $7 ) ) + 328 | 0 ) ; HEAP32 [ $10 >> 2 ] = 1000 ; $11 = ( ( ( $7 ) ) + 332 | 0 ) ; HEAP32 [ $11 >> 2 ] = 8000000 ; _png_set_error_fn ( $7 , $1 , $2 , $3 ) ; $12 = ( _png_user_version_check ( $7 , $0 ) | 0 ) ; $13 = ( $12 | 0 ) == ( 0 ) ; if ( $13 ) { $$1 = 0 ; STACKTOP = sp ; return ( $$1 | 0 ) ; } $14 = ( _png_malloc_warn ( $7 , 396 ) | 0 ) ; $15 = ( $14 | 0 ) == ( 0 | 0 ) ; if ( $15 ) { $$1 = 0 ; STACKTOP = sp ; return ( $$1 | 0 ) ; } $16 = ( ( ( $7 ) ) + 72 | 0 ) ; HEAP32 [ $16 >> 2 ] = 92 ; $17 = ( ( ( $7 ) ) + 76 | 0 ) ; HEAP32 [ $17 >> 2 ] = 93 ; $18 = ( ( ( $7 ) ) + 80 | 0 ) ; HEAP32 [ $18 >> 2 ] = $14 ; _memcpy ( ( $14 | 0 ) , ( $7 | 0 ) , 396 ) | 0 ; $$1 = $14 ; STACKTOP = sp ; return ( $$1 | 0 ) ; } function _png_create_info_struct ( $0 ) { $0 = $0 | 0 ; var $$0 = 0 , $1 = 0 , $2 = 0 , $3 = 0 , dest = 0 , label = 0 , sp = 0 , stop = 0 ; sp = STACKTOP ; $1 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $1 ) { $$0 = 0 ; return ( $$0 | 0 ) ; } $2 = ( _png_malloc_base ( $0 , 92 ) | 0 ) ; $3 = ( $2 | 0 ) == ( 0 | 0 ) ; if ( $3 ) { $$0 = $2 ; return ( $$0 | 0 ) ; } dest = $2 ; stop = dest + 92 | 0 ; do { HEAP32 [ dest >> 2 ] = 0 | 0 ; dest = dest + 4 | 0 ; } while ( ( dest | 0 ) < ( stop | 0 ) ) ; $$0 = $2 ; return ( $$0 | 0 ) ; } function _png_destroy_info_struct ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $or$cond = 0 , dest = 0 , label = 0 , sp = 0 , stop = 0 ; sp = STACKTOP ; $2 = ( $0 | 0 ) == ( 0 | 0 ) ; $3 = ( $1 | 0 ) == ( 0 | 0 ) ; $or$cond = $2 | $3 ; if ( $or$cond ) { return ; } $4 = HEAP32 [ $1 >> 2 ] | 0 ; $5 = ( $4 | 0 ) == ( 0 | 0 ) ; if ( $5 ) { return ; } HEAP32 [ $1 >> 2 ] = 0 ; _png_free_data ( $0 , $4 , 65535 , - 1 ) ; dest = $4 ; stop = dest + 92 | 0 ; do { HEAP32 [ dest >> 2 ] = 0 | 0 ; dest = dest + 4 | 0 ; } while ( ( dest | 0 ) < ( stop | 0 ) ) ; _png_free ( $0 , $4 ) ; return ; } function _png_free_data ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $$ = 0 , $$05763 = 0 , $$062 = 0 , $$lcssa = 0 , $$lcssa60 = 0 , $$pre = 0 , $$pre70 = 0 , $$pre71 = 0 , $$pre71$pre = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 ; var $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 ; var $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 ; var $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 ; var $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $9 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $4 = ( $0 | 0 ) == ( 0 | 0 ) ; $5 = ( $1 | 0 ) == ( 0 | 0 ) ; $or$cond = $4 | $5 ; if ( $or$cond ) { return ; } $6 = $2 & 8192 ; $7 = ( ( ( $1 ) ) + 76 | 0 ) ; $8 = HEAP32 [ $7 >> 2 ] | 0 ; $9 = $6 & $8 ; $10 = ( $9 | 0 ) == ( 0 ) ; if ( ! ( $10 ) ) { $11 = ( ( ( $1 ) ) + 8 | 0 ) ; $12 = HEAP32 [ $11 >> 2 ] | 0 ; $13 = $12 & - 17 ; HEAP32 [ $11 >> 2 ] = $13 ; $14 = ( ( ( $1 ) ) + 48 | 0 ) ; $15 = HEAP32 [ $14 >> 2 ] | 0 ; _png_free ( $0 , $15 ) ; HEAP32 [ $14 >> 2 ] = 0 ; $16 = ( ( ( $1 ) ) + 22 | 0 ) ; HEAP16 [ $16 >> 1 ] = 0 ; } $17 = ( ( ( $1 ) ) + 80 | 0 ) ; $18 = HEAP32 [ $17 >> 2 ] | 0 ; $19 = ( $18 | 0 ) == ( 0 | 0 ) ; do { if ( ! ( $19 ) ) { $20 = $2 & 512 ; $21 = HEAP32 [ $7 >> 2 ] | 0 ; $22 = $20 & $21 ; $23 = ( $22 | 0 ) == ( 0 ) ; if ( ! ( $23 ) ) { $24 = ( $3 | 0 ) == ( - 1 ) ; if ( ! ( $24 ) ) { $28 = ( ( ( ( $18 ) + ( ( $3 * 20 ) | 0 ) | 0 ) ) + 8 | 0 ) ; $29 = HEAP32 [ $28 >> 2 ] | 0 ; _png_free ( $0 , $29 ) ; $30 = HEAP32 [ $17 >> 2 ] | 0 ; $31 = ( ( ( ( $30 ) + ( ( $3 * 20 ) | 0 ) | 0 ) ) + 8 | 0 ) ; HEAP32 [ $31 >> 2 ] = 0 ; break ; } $25 = ( ( ( $1 ) ) + 84 | 0 ) ; $26 = HEAP32 [ $25 >> 2 ] | 0 ; $27 = ( $26 | 0 ) > ( 0 ) ; if ( $27 ) { $$05763 = 0 ; $33 = $18 ; while ( 1 ) { $32 = ( ( ( ( $33 ) + ( ( $$05763 * 20 ) | 0 ) | 0 ) ) + 8 | 0 ) ; $34 = HEAP32 [ $32 >> 2 ] | 0 ; _png_free ( $0 , $34 ) ; $35 = ( ( $$05763 ) + 1 ) | 0 ; $36 = HEAP32 [ $25 >> 2 ] | 0 ; $37 = ( $35 | 0 ) < ( $36 | 0 ) ; $38 = HEAP32 [ $17 >> 2 ] | 0 ; if ( $37 ) { $$05763 = $35 ; $33 = $38 ; } else { $$lcssa60 = $38 ; break ; } } } else { $$lcssa60 = $18 ; } _png_free ( $0 , $$lcssa60 ) ; HEAP32 [ $17 >> 2 ] = 0 ; HEAP32 [ $25 >> 2 ] = 0 ; } } } while ( 0 ) ; $39 = $2 & 8 ; $40 = HEAP32 [ $7 >> 2 ] | 0 ; $41 = $39 & $40 ; $42 = ( $41 | 0 ) == ( 0 ) ; if ( $42 ) { $50 = $40 ; } else { $43 = ( ( ( $1 ) ) + 72 | 0 ) ; $44 = HEAP32 [ $43 >> 2 ] | 0 ; _png_free ( $0 , $44 ) ; HEAP32 [ $43 >> 2 ] = 0 ; $45 = ( ( ( $1 ) ) + 8 | 0 ) ; $46 = HEAP32 [ $45 >> 2 ] | 0 ; $47 = $46 & - 65 ; HEAP32 [ $45 >> 2 ] = $47 ; $$pre = HEAP32 [ $7 >> 2 ] | 0 ; $50 = $$pre ; } $48 = $2 & 4096 ; $49 = $48 & $50 ; $51 = ( $49 | 0 ) == ( 0 ) ; if ( $51 ) { $60 = $50 ; } else { $52 = ( ( ( $1 ) ) + 16 | 0 ) ; $53 = HEAP32 [ $52 >> 2 ] | 0 ; _png_free ( $0 , $53 ) ; HEAP32 [ $52 >> 2 ] = 0 ; $54 = ( ( ( $1 ) ) + 8 | 0 ) ; $55 = HEAP32 [ $54 >> 2 ] | 0 ; $56 = $55 & - 9 ; HEAP32 [ $54 >> 2 ] = $56 ; $57 = ( ( ( $1 ) ) + 20 | 0 ) ; HEAP16 [ $57 >> 1 ] = 0 ; $$pre70 = HEAP32 [ $7 >> 2 ] | 0 ; $60 = $$pre70 ; } $58 = $2 & 64 ; $59 = $58 & $60 ; $61 = ( $59 | 0 ) == ( 0 ) ; if ( $61 ) { $82 = $60 ; } else { $62 = ( ( ( $1 ) ) + 88 | 0 ) ; $63 = HEAP32 [ $62 >> 2 ] | 0 ; $64 = ( $63 | 0 ) == ( 0 | 0 ) ; if ( $64 ) { $$pre71 = $60 ; } else { $65 = ( ( ( $1 ) ) + 4 | 0 ) ; $66 = HEAP32 [ $65 >> 2 ] | 0 ; $67 = ( $66 | 0 ) == ( 0 ) ; if ( $67 ) { $$lcssa = $63 ; } else { $$062 = 0 ; $69 = $63 ; while ( 1 ) { $68 = ( ( $69 ) + ( $$062 << 2 ) | 0 ) ; $70 = HEAP32 [ $68 >> 2 ] | 0 ; _png_free ( $0 , $70 ) ; $71 = ( ( $$062 ) + 1 ) | 0 ; $72 = HEAP32 [ $65 >> 2 ] | 0 ; $73 = ( $71 >>> 0 ) < ( $72 >>> 0 ) ; $74 = HEAP32 [ $62 >> 2 ] | 0 ; if ( $73 ) { $$062 = $71 ; $69 = $74 ; } else { $$lcssa = $74 ; break ; } } } _png_free ( $0 , $$lcssa ) ; HEAP32 [ $62 >> 2 ] = 0 ; $$pre71$pre = HEAP32 [ $7 >> 2 ] | 0 ; $$pre71 = $$pre71$pre ; } $75 = ( ( ( $1 ) ) + 8 | 0 ) ; $76 = HEAP32 [ $75 >> 2 ] | 0 ; $77 = $76 & - 32769 ; HEAP32 [ $75 >> 2 ] = $77 ; $82 = $$pre71 ; } $78 = ( $3 | 0 ) == ( - 1 ) ; $79 = $2 & - 16929 ; $$ = $78 ? $2 : $79 ; $80 = $$ ^ - 1 ; $81 = $82 & $80 ; HEAP32 [ $7 >> 2 ] = $81 ; return ; } function _png_data_freer ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $4 = ( $0 | 0 ) == ( 0 | 0 ) ; $5 = ( $1 | 0 ) == ( 0 | 0 ) ; $or$cond = $4 | $5 ; if ( $or$cond ) { return ; } switch ( $2 | 0 ) { case 1 : { $6 = ( ( ( $1 ) ) + 76 | 0 ) ; $7 = HEAP32 [ $6 >> 2 ] | 0 ; $8 = $7 | $3 ; HEAP32 [ $6 >> 2 ] = $8 ; return ; break ; } case 2 : { $9 = $3 ^ - 1 ; $10 = ( ( ( $1 ) ) + 76 | 0 ) ; $11 = HEAP32 [ $10 >> 2 ] | 0 ; $12 = $11 & $9 ; HEAP32 [ $10 >> 2 ] = $12 ; return ; break ; } default : { _png_error ( $0 , 23646 ) ; // unreachable; } } } function _png_get_io_ptr ( $0 ) { $0 = $0 | 0 ; var $$0 = 0 , $1 = 0 , $2 = 0 , $3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $1 ) { $$0 = 0 ; return ( $$0 | 0 ) ; } $2 = ( ( ( $0 ) ) + 20 | 0 ) ; $3 = HEAP32 [ $2 >> 2 ] | 0 ; $$0 = $3 ; return ( $$0 | 0 ) ; } function _png_get_libpng_ver ( $0 ) { $0 = $0 | 0 ; var label = 0 , sp = 0 ; sp = STACKTOP ; return ( 23589 | 0 ) ; } function _png_handle_as_unknown ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$0 = 0 , $$015 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , label = 0 ; var sp = 0 ; sp = STACKTOP ; $2 = ( $0 | 0 ) == ( 0 | 0 ) ; $3 = ( $1 | 0 ) == ( 0 | 0 ) ; $or$cond = $2 | $3 ; if ( $or$cond ) { $$0 = 0 ; return ( $$0 | 0 ) ; } $4 = ( ( ( $0 ) ) + 304 | 0 ) ; $5 = HEAP32 [ $4 >> 2 ] | 0 ; $6 = ( $5 | 0 ) == ( 0 ) ; if ( $6 ) { $$0 = 0 ; return ( $$0 | 0 ) ; } $7 = ( ( ( $0 ) ) + 308 | 0 ) ; $8 = HEAP32 [ $7 >> 2 ] | 0 ; $9 = ( $5 * 5 ) | 0 ; $10 = ( ( $8 ) + ( $9 ) | 0 ) ; $$015 = $10 ; while ( 1 ) { $11 = ( ( ( $$015 ) ) + - 5 | 0 ) ; $12 = ( _memcmp ( $1 , $11 , 4 ) | 0 ) ; $13 = ( $12 | 0 ) == ( 0 ) ; if ( $13 ) { break ; } $17 = ( $11 >>> 0 ) > ( $8 >>> 0 ) ; if ( $17 ) { $$015 = $11 ; } else { $$0 = 0 ; label = 7 ; break ; } } if ( ( label | 0 ) == 7 ) { return ( $$0 | 0 ) ; } $14 = ( ( ( $$015 ) ) + - 1 | 0 ) ; $15 = HEAP8 [ $14 >> 0 ] | 0 ; $16 = $15 & 255 ; $$0 = $16 ; return ( $$0 | 0 ) ; } function _png_chunk_unknown_handling ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$0$i = 0 , $$015$i = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 ; var $27 = 0 , $28 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = sp ; $3 = $1 >>> 24 ; $4 = $3 & 255 ; HEAP8 [ $2 >> 0 ] = $4 ; $5 = $1 >>> 16 ; $6 = $5 & 255 ; $7 = ( ( ( $2 ) ) + 1 | 0 ) ; HEAP8 [ $7 >> 0 ] = $6 ; $8 = $1 >>> 8 ; $9 = $8 & 255 ; $10 = ( ( ( $2 ) ) + 2 | 0 ) ; HEAP8 [ $10 >> 0 ] = $9 ; $11 = $1 & 255 ; $12 = ( ( ( $2 ) ) + 3 | 0 ) ; HEAP8 [ $12 >> 0 ] = $11 ; $13 = ( ( ( $2 ) ) + 4 | 0 ) ; HEAP8 [ $13 >> 0 ] = 0 ; $14 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $14 ) { $$0$i = 0 ; STACKTOP = sp ; return ( $$0$i | 0 ) ; } $15 = ( ( ( $0 ) ) + 304 | 0 ) ; $16 = HEAP32 [ $15 >> 2 ] | 0 ; $17 = ( $16 | 0 ) == ( 0 ) ; if ( $17 ) { $$0$i = 0 ; STACKTOP = sp ; return ( $$0$i | 0 ) ; } $18 = ( ( ( $0 ) ) + 308 | 0 ) ; $19 = HEAP32 [ $18 >> 2 ] | 0 ; $20 = ( $16 * 5 ) | 0 ; $21 = ( ( $19 ) + ( $20 ) | 0 ) ; $$015$i = $21 ; while ( 1 ) { $22 = ( ( ( $$015$i ) ) + - 5 | 0 ) ; $23 = ( _memcmp ( $2 , $22 , 4 ) | 0 ) ; $24 = ( $23 | 0 ) == ( 0 ) ; if ( $24 ) { break ; } $28 = ( $22 >>> 0 ) > ( $19 >>> 0 ) ; if ( $28 ) { $$015$i = $22 ; } else { $$0$i = 0 ; label = 7 ; break ; } } if ( ( label | 0 ) == 7 ) { STACKTOP = sp ; return ( $$0$i | 0 ) ; } $25 = ( ( ( $$015$i ) ) + - 1 | 0 ) ; $26 = HEAP8 [ $25 >> 0 ] | 0 ; $27 = $26 & 255 ; $$0$i = $27 ; STACKTOP = sp ; return ( $$0$i | 0 ) ; } function _png_zstream_error ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$sink = 0 , $2 = 0 , $3 = 0 , $4 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( ( ( $0 ) ) + 64 | 0 ) ; $3 = HEAP32 [ $2 >> 2 ] | 0 ; $4 = ( $3 | 0 ) == ( 0 | 0 ) ; if ( ! ( $4 ) ) { return ; } switch ( $1 | 0 ) { case - 7 : { $$sink = 23688 ; break ; } case 1 : { $$sink = 23823 ; break ; } case 2 : { $$sink = 23801 ; break ; } case - 1 : { $$sink = 23787 ; break ; } case - 2 : { $$sink = 23764 ; break ; } case - 3 : { $$sink = 23746 ; break ; } case - 4 : { $$sink = 29609 ; break ; } case - 5 : { $$sink = 23736 ; break ; } case - 6 : { $$sink = 23711 ; break ; } default : { $$sink = 23851 ; } } HEAP32 [ $2 >> 2 ] = $$sink ; return ; } function _png_check_IHDR ( $0 , $1 , $2 , $3 , $4 , $5 , $6 , $7 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; $4 = $4 | 0 ; $5 = $5 | 0 ; $6 = $6 | 0 ; $7 = $7 | 0 ; var $$1 = 0 , $$10 = 0 , $$11 = 0 , $$2 = 0 , $$3 = 0 , $$5 = 0 , $$6 = 0 , $$7 = 0 , $$8 = 0 , $$9 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 ; var $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $8 = 0 , $9 = 0 , $or$cond15 = 0 , $or$cond21 = 0 , label = 0 ; var sp = 0 ; sp = STACKTOP ; $8 = ( $1 | 0 ) == ( 0 ) ; if ( $8 ) { _png_warning ( $0 , 23879 ) ; $$2 = 1 ; } else { $9 = ( $1 | 0 ) < ( 0 ) ; if ( $9 ) { _png_warning ( $0 , 23907 ) ; $$1 = 1 ; } else { $$1 = 0 ; } $10 = ( ( $1 ) + 7 ) | 0 ; $11 = $10 & - 8 ; $12 = ( $11 >>> 0 ) < ( 536870905 ) ; if ( $12 ) { $$2 = $$1 ; } else { _png_warning ( $0 , 23935 ) ; $$2 = 1 ; } } $13 = ( ( ( $0 ) ) + 320 | 0 ) ; $14 = HEAP32 [ $13 >> 2 ] | 0 ; $15 = ( $14 >>> 0 ) < ( $1 >>> 0 ) ; if ( $15 ) { _png_warning ( $0 , 23982 ) ; $$3 = 1 ; } else { $$3 = $$2 ; } $16 = ( $2 | 0 ) == ( 0 ) ; if ( $16 ) { _png_warning ( $0 , 24021 ) ; $$5 = 1 ; } else { $17 = ( $2 | 0 ) < ( 0 ) ; if ( $17 ) { _png_warning ( $0 , 24050 ) ; $$5 = 1 ; } else { $$5 = $$3 ; } } $18 = ( ( ( $0 ) ) + 324 | 0 ) ; $19 = HEAP32 [ $18 >> 2 ] | 0 ; $20 = ( $19 >>> 0 ) < ( $2 >>> 0 ) ; if ( $20 ) { _png_warning ( $0 , 24079 ) ; $$6 = 1 ; } else { $$6 = $$5 ; } switch ( $3 | 0 ) { case 1 : case 2 : case 4 : case 8 : case 16 : { $$7 = $$6 ; break ; } default : { _png_warning ( $0 , 24119 ) ; $$7 = 1 ; } } $21 = $4 | 4 ; $22 = ( $21 | 0 ) == ( 5 ) ; $23 = ( $4 >>> 0 ) > ( 6 ) ; $24 = $23 | $22 ; if ( $24 ) { _png_warning ( $0 , 24145 ) ; $$8 = 1 ; } else { $$8 = $$7 ; } $25 = ( $4 | 0 ) == ( 3 ) ; $26 = ( $3 | 0 ) > ( 8 ) ; $or$cond15 = $26 & $25 ; if ( $or$cond15 ) { label = 21 ; } else { $27 = ( $4 | 0 ) == ( 4 ) ; $28 = ( $21 | 0 ) == ( 6 ) ; $29 = $27 | $28 ; $30 = ( $3 | 0 ) < ( 8 ) ; $or$cond21 = $30 & $29 ; if ( $or$cond21 ) { label = 21 ; } else { $$9 = $$8 ; } } if ( ( label | 0 ) == 21 ) { _png_warning ( $0 , 24172 ) ; $$9 = 1 ; } $31 = ( $5 | 0 ) > ( 1 ) ; if ( $31 ) { _png_warning ( $0 , 24221 ) ; $$10 = 1 ; } else { $$10 = $$9 ; } $32 = ( $6 | 0 ) == ( 0 ) ; if ( $32 ) { $$11 = $$10 ; } else { _png_warning ( $0 , 24254 ) ; $$11 = 1 ; } $33 = ( $7 | 0 ) == ( 0 ) ; if ( ! ( $33 ) ) { _png_warning ( $0 , 24289 ) ; _png_error ( $0 , 24319 ) ; // unreachable; } $34 = ( $$11 | 0 ) == ( 1 ) ; if ( $34 ) { _png_error ( $0 , 24319 ) ; // unreachable; } else { return ; } } function _png_error ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $vararg_buffer = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $vararg_buffer = sp ; $2 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( ! ( $2 ) ) { $3 = HEAP32 [ $0 >> 2 ] | 0 ; $4 = ( $3 | 0 ) == ( 0 | 0 ) ; if ( ! ( $4 ) ) { FUNCTION_TABLE_vii [ $3 & 127 ] ( $0 , $1 ) ; } } $5 = HEAP32 [ 2398 ] | 0 ; $6 = ( $1 | 0 ) != ( 0 | 0 ) ; $7 = $6 ? $1 : 24337 ; HEAP32 [ $vararg_buffer >> 2 ] = $7 ; ( _fprintf ( $5 , 24347 , $vararg_buffer ) | 0 ) ; ( _fputc ( 10 , $5 ) | 0 ) ; _abort ( ) ; // unreachable; } function _png_safecat ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $$01216 = 0 , $$017 = 0 , $$1 = 0 , $$2 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 ; var $or$cond14 = 0 , $or$cond1415 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $4 = ( $0 | 0 ) != ( 0 | 0 ) ; $5 = ( $2 >>> 0 ) < ( $1 >>> 0 ) ; $or$cond = $4 & $5 ; if ( ! ( $or$cond ) ) { $$2 = $2 ; return ( $$2 | 0 ) ; } $6 = ( $3 | 0 ) == ( 0 | 0 ) ; if ( $6 ) { $$1 = $2 ; } else { $7 = HEAP8 [ $3 >> 0 ] | 0 ; $8 = ( $7 << 24 >> 24 ) != ( 0 ) ; $9 = ( ( $1 ) + - 1 ) | 0 ; $10 = ( $9 >>> 0 ) > ( $2 >>> 0 ) ; $or$cond1415 = $10 & $8 ; if ( $or$cond1415 ) { $$01216 = $2 ; $$017 = $3 ; $14 = $7 ; while ( 1 ) { $11 = ( ( ( $$017 ) ) + 1 | 0 ) ; $12 = ( ( $$01216 ) + 1 ) | 0 ; $13 = ( ( $0 ) + ( $$01216 ) | 0 ) ; HEAP8 [ $13 >> 0 ] = $14 ; $15 = HEAP8 [ $11 >> 0 ] | 0 ; $16 = ( $15 << 24 >> 24 ) != ( 0 ) ; $17 = ( $12 >>> 0 ) < ( $9 >>> 0 ) ; $or$cond14 = $17 & $16 ; if ( $or$cond14 ) { $$01216 = $12 ; $$017 = $11 ; $14 = $15 ; } else { $$1 = $12 ; break ; } } } else { $$1 = $2 ; } } $18 = ( ( $0 ) + ( $$1 ) | 0 ) ; HEAP8 [ $18 >> 0 ] = 0 ; $$2 = $$1 ; return ( $$2 | 0 ) ; } function _png_warning ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$ = 0 , $$115 = 0 , $$116 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 ; var $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 ; var $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $vararg_buffer = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $vararg_buffer = sp ; $2 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $2 ) { $$116 = 0 ; } else { $3 = HEAP8 [ $1 >> 0 ] | 0 ; $4 = ( $3 << 24 >> 24 ) == ( 35 ) ; if ( $4 ) { $5 = ( ( ( $1 ) ) + 1 | 0 ) ; $6 = HEAP8 [ $5 >> 0 ] | 0 ; $7 = ( $6 << 24 >> 24 ) == ( 32 ) ; if ( $7 ) { $$115 = 1 ; } else { $8 = ( ( ( $1 ) ) + 2 | 0 ) ; $9 = HEAP8 [ $8 >> 0 ] | 0 ; $10 = ( $9 << 24 >> 24 ) == ( 32 ) ; if ( $10 ) { $$115 = 2 ; } else { $17 = ( ( ( $1 ) ) + 3 | 0 ) ; $18 = HEAP8 [ $17 >> 0 ] | 0 ; $19 = ( $18 << 24 >> 24 ) == ( 32 ) ; if ( $19 ) { $$115 = 3 ; } else { $20 = ( ( ( $1 ) ) + 4 | 0 ) ; $21 = HEAP8 [ $20 >> 0 ] | 0 ; $22 = ( $21 << 24 >> 24 ) == ( 32 ) ; if ( $22 ) { $$115 = 4 ; } else { $23 = ( ( ( $1 ) ) + 5 | 0 ) ; $24 = HEAP8 [ $23 >> 0 ] | 0 ; $25 = ( $24 << 24 >> 24 ) == ( 32 ) ; if ( $25 ) { $$115 = 5 ; } else { $26 = ( ( ( $1 ) ) + 6 | 0 ) ; $27 = HEAP8 [ $26 >> 0 ] | 0 ; $28 = ( $27 << 24 >> 24 ) == ( 32 ) ; if ( $28 ) { $$115 = 6 ; } else { $29 = ( ( ( $1 ) ) + 7 | 0 ) ; $30 = HEAP8 [ $29 >> 0 ] | 0 ; $31 = ( $30 << 24 >> 24 ) == ( 32 ) ; if ( $31 ) { $$115 = 7 ; } else { $32 = ( ( ( $1 ) ) + 8 | 0 ) ; $33 = HEAP8 [ $32 >> 0 ] | 0 ; $34 = ( $33 << 24 >> 24 ) == ( 32 ) ; if ( $34 ) { $$115 = 8 ; } else { $35 = ( ( ( $1 ) ) + 9 | 0 ) ; $36 = HEAP8 [ $35 >> 0 ] | 0 ; $37 = ( $36 << 24 >> 24 ) == ( 32 ) ; if ( $37 ) { $$115 = 9 ; } else { $38 = ( ( ( $1 ) ) + 10 | 0 ) ; $39 = HEAP8 [ $38 >> 0 ] | 0 ; $40 = ( $39 << 24 >> 24 ) == ( 32 ) ; if ( $40 ) { $$115 = 10 ; } else { $41 = ( ( ( $1 ) ) + 11 | 0 ) ; $42 = HEAP8 [ $41 >> 0 ] | 0 ; $43 = ( $42 << 24 >> 24 ) == ( 32 ) ; if ( $43 ) { $$115 = 11 ; } else { $44 = ( ( ( $1 ) ) + 12 | 0 ) ; $45 = HEAP8 [ $44 >> 0 ] | 0 ; $46 = ( $45 << 24 >> 24 ) == ( 32 ) ; if ( $46 ) { $$115 = 12 ; } else { $47 = ( ( ( $1 ) ) + 13 | 0 ) ; $48 = HEAP8 [ $47 >> 0 ] | 0 ; $49 = ( $48 << 24 >> 24 ) == ( 32 ) ; if ( $49 ) { $$115 = 13 ; } else { $50 = ( ( ( $1 ) ) + 14 | 0 ) ; $51 = HEAP8 [ $50 >> 0 ] | 0 ; $52 = ( $51 << 24 >> 24 ) == ( 32 ) ; $$ = $52 ? 14 : 15 ; $$115 = $$ ; } } } } } } } } } } } } } } else { $$115 = 0 ; } $11 = ( ( ( $0 ) ) + 4 | 0 ) ; $12 = HEAP32 [ $11 >> 2 ] | 0 ; $13 = ( $12 | 0 ) == ( 0 | 0 ) ; if ( $13 ) { $$116 = $$115 ; } else { $14 = ( ( $1 ) + ( $$115 ) | 0 ) ; FUNCTION_TABLE_vii [ $12 & 127 ] ( $0 , $14 ) ; STACKTOP = sp ; return ; } } $15 = ( ( $1 ) + ( $$116 ) | 0 ) ; $16 = HEAP32 [ 2398 ] | 0 ; HEAP32 [ $vararg_buffer >> 2 ] = $15 ; ( _fprintf ( $16 , 24364 , $vararg_buffer ) | 0 ) ; ( _fputc ( 10 , $16 ) | 0 ) ; STACKTOP = sp ; return ; } function _png_benign_error ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 224 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 224 | 0 ) ; $2 = sp ; $3 = ( ( ( $0 ) ) + 28 | 0 ) ; $4 = HEAP32 [ $3 >> 2 ] | 0 ; $5 = $4 & 1048576 ; $6 = ( $5 | 0 ) == ( 0 ) ; $7 = ( ( ( $0 ) ) + 24 | 0 ) ; $8 = HEAP32 [ $7 >> 2 ] | 0 ; $9 = $8 & 32768 ; $10 = ( $9 | 0 ) != ( 0 ) ; if ( $6 ) { if ( ! ( $10 ) ) { _png_error ( $0 , $1 ) ; // unreachable; } $14 = ( ( ( $0 ) ) + 172 | 0 ) ; $15 = HEAP32 [ $14 >> 2 ] | 0 ; $16 = ( $15 | 0 ) == ( 0 ) ; if ( $16 ) { _png_error ( $0 , $1 ) ; // unreachable; } else { _png_chunk_error ( $0 , $1 ) ; // unreachable; } } if ( $10 ) { $11 = ( ( ( $0 ) ) + 172 | 0 ) ; $12 = HEAP32 [ $11 >> 2 ] | 0 ; $13 = ( $12 | 0 ) == ( 0 ) ; if ( ! ( $13 ) ) { _png_format_buffer ( $12 , $2 , $1 ) ; _png_warning ( $0 , $2 ) ; STACKTOP = sp ; return ; } } _png_warning ( $0 , $1 ) ; STACKTOP = sp ; return ; } function _png_format_buffer ( $$0$30$val , $0 , $1 ) { $$0$30$val = $$0$30$val | 0 ; $0 = $0 | 0 ; $1 = $1 | 0 ; var $$03 = 0 , $$1 = 0 , $$1$1 = 0 , $$1$2 = 0 , $$1$3 = 0 , $$1$in = 0 , $$1$in$1 = 0 , $$1$in$2 = 0 , $$1$in$3 = 0 , $$2$sink = 0 , $$22 = 0 , $$off = 0 , $$off$1 = 0 , $$off$2 = 0 , $$off$3 = 0 , $$off52 = 0 , $$off52$1 = 0 , $$off52$2 = 0 , $$off52$3 = 0 , $$sink = 0 ; var $$sink$1 = 0 , $$sink$2 = 0 , $$sink$3 = 0 , $$sink2 = 0 , $$sink2$1 = 0 , $$sink2$2 = 0 , $$sink2$3 = 0 , $$sink4 = 0 , $$sink41 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 ; var $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 ; var $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 ; var $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 ; var $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = $$0$30$val >>> 24 ; $$off = ( ( $2 ) + - 65 ) | 0 ; $3 = ( $$off >>> 0 ) > ( 57 ) ; $$off52 = ( ( $2 ) + - 91 ) | 0 ; $4 = ( $$off52 >>> 0 ) < ( 6 ) ; $5 = $3 | $4 ; if ( $5 ) { HEAP8 [ $0 >> 0 ] = 91 ; $6 = $$0$30$val >>> 28 ; $7 = ( 31337 + ( $6 ) | 0 ) ; $8 = HEAP8 [ $7 >> 0 ] | 0 ; $9 = ( ( ( $0 ) ) + 1 | 0 ) ; HEAP8 [ $9 >> 0 ] = $8 ; $10 = $2 & 15 ; $11 = ( 31337 + ( $10 ) | 0 ) ; $12 = HEAP8 [ $11 >> 0 ] | 0 ; $13 = ( ( ( $0 ) ) + 2 | 0 ) ; HEAP8 [ $13 >> 0 ] = $12 ; $$1$in = 3 ; $$sink = 93 ; } else { $14 = $2 & 255 ; $$1$in = 0 ; $$sink = $14 ; } $$sink2 = ( ( $0 ) + ( $$1$in ) | 0 ) ; $$1 = ( ( $$1$in ) + 1 ) | 0 ; HEAP8 [ $$sink2 >> 0 ] = $$sink ; $15 = $$0$30$val >>> 16 ; $16 = $15 & 255 ; $$off$1 = ( ( $16 ) + - 65 ) | 0 ; $17 = ( $$off$1 >>> 0 ) > ( 57 ) ; $$off52$1 = ( ( $16 ) + - 91 ) | 0 ; $18 = ( $$off52$1 >>> 0 ) < ( 6 ) ; $19 = $17 | $18 ; if ( $19 ) { $31 = ( ( $$1$in ) + 2 ) | 0 ; $32 = ( ( $0 ) + ( $$1 ) | 0 ) ; HEAP8 [ $32 >> 0 ] = 91 ; $33 = $$0$30$val >>> 20 ; $34 = $33 & 15 ; $35 = ( 31337 + ( $34 ) | 0 ) ; $36 = HEAP8 [ $35 >> 0 ] | 0 ; $37 = ( ( $$1$in ) + 3 ) | 0 ; $38 = ( ( $0 ) + ( $31 ) | 0 ) ; HEAP8 [ $38 >> 0 ] = $36 ; $39 = $15 & 15 ; $40 = ( 31337 + ( $39 ) | 0 ) ; $41 = HEAP8 [ $40 >> 0 ] | 0 ; $42 = $$1$in | 4 ; $43 = ( ( $0 ) + ( $37 ) | 0 ) ; HEAP8 [ $43 >> 0 ] = $41 ; $$1$in$1 = $42 ; $$sink$1 = 93 ; } else { $30 = $15 & 255 ; $$1$in$1 = $$1 ; $$sink$1 = $30 ; } $$sink2$1 = ( ( $0 ) + ( $$1$in$1 ) | 0 ) ; $$1$1 = ( ( $$1$in$1 ) + 1 ) | 0 ; HEAP8 [ $$sink2$1 >> 0 ] = $$sink$1 ; $44 = $$0$30$val >>> 8 ; $45 = $44 & 255 ; $$off$2 = ( ( $45 ) + - 65 ) | 0 ; $46 = ( $$off$2 >>> 0 ) > ( 57 ) ; $$off52$2 = ( ( $45 ) + - 91 ) | 0 ; $47 = ( $$off52$2 >>> 0 ) < ( 6 ) ; $48 = $46 | $47 ; if ( $48 ) { $50 = ( ( $$1$in$1 ) + 2 ) | 0 ; $51 = ( ( $0 ) + ( $$1$1 ) | 0 ) ; HEAP8 [ $51 >> 0 ] = 91 ; $52 = $$0$30$val >>> 12 ; $53 = $52 & 15 ; $54 = ( 31337 + ( $53 ) | 0 ) ; $55 = HEAP8 [ $54 >> 0 ] | 0 ; $56 = ( ( $$1$in$1 ) + 3 ) | 0 ; $57 = ( ( $0 ) + ( $50 ) | 0 ) ; HEAP8 [ $57 >> 0 ] = $55 ; $58 = $44 & 15 ; $59 = ( 31337 + ( $58 ) | 0 ) ; $60 = HEAP8 [ $59 >> 0 ] | 0 ; $61 = ( ( $$1$in$1 ) + 4 ) | 0 ; $62 = ( ( $0 ) + ( $56 ) | 0 ) ; HEAP8 [ $62 >> 0 ] = $60 ; $$1$in$2 = $61 ; $$sink$2 = 93 ; } else { $49 = $44 & 255 ; $$1$in$2 = $$1$1 ; $$sink$2 = $49 ; } $$sink2$2 = ( ( $0 ) + ( $$1$in$2 ) | 0 ) ; $$1$2 = ( ( $$1$in$2 ) + 1 ) | 0 ; HEAP8 [ $$sink2$2 >> 0 ] = $$sink$2 ; $63 = $$0$30$val & 255 ; $$off$3 = ( ( $63 ) + - 65 ) | 0 ; $64 = ( $$off$3 >>> 0 ) > ( 57 ) ; $$off52$3 = ( ( $63 ) + - 91 ) | 0 ; $65 = ( $$off52$3 >>> 0 ) < ( 6 ) ; $66 = $64 | $65 ; if ( $66 ) { $68 = ( ( $$1$in$2 ) + 2 ) | 0 ; $69 = ( ( $0 ) + ( $$1$2 ) | 0 ) ; HEAP8 [ $69 >> 0 ] = 91 ; $70 = $$0$30$val >>> 4 ; $71 = $70 & 15 ; $72 = ( 31337 + ( $71 ) | 0 ) ; $73 = HEAP8 [ $72 >> 0 ] | 0 ; $74 = ( ( $$1$in$2 ) + 3 ) | 0 ; $75 = ( ( $0 ) + ( $68 ) | 0 ) ; HEAP8 [ $75 >> 0 ] = $73 ; $76 = $$0$30$val & 15 ; $77 = ( 31337 + ( $76 ) | 0 ) ; $78 = HEAP8 [ $77 >> 0 ] | 0 ; $79 = ( ( $$1$in$2 ) + 4 ) | 0 ; $80 = ( ( $0 ) + ( $74 ) | 0 ) ; HEAP8 [ $80 >> 0 ] = $78 ; $$1$in$3 = $79 ; $$sink$3 = 93 ; } else { $67 = $$0$30$val & 255 ; $$1$in$3 = $$1$2 ; $$sink$3 = $67 ; } $$sink2$3 = ( ( $0 ) + ( $$1$in$3 ) | 0 ) ; $$1$3 = ( ( $$1$in$3 ) + 1 ) | 0 ; HEAP8 [ $$sink2$3 >> 0 ] = $$sink$3 ; $81 = ( $1 | 0 ) == ( 0 | 0 ) ; if ( $81 ) { $$2$sink = $$1$3 ; $29 = ( ( $0 ) + ( $$2$sink ) | 0 ) ; HEAP8 [ $29 >> 0 ] = 0 ; return ; } $20 = ( ( $$1$in$3 ) + 2 ) | 0 ; $21 = ( ( $0 ) + ( $$1$3 ) | 0 ) ; HEAP8 [ $21 >> 0 ] = 58 ; $22 = ( ( $$1$in$3 ) + 3 ) | 0 ; $$sink41 = ( ( $0 ) + ( $20 ) | 0 ) ; HEAP8 [ $$sink41 >> 0 ] = 32 ; $$03 = 0 ; $$22 = $22 ; while ( 1 ) { $23 = ( ( $1 ) + ( $$03 ) | 0 ) ; $24 = HEAP8 [ $23 >> 0 ] | 0 ; $25 = ( $24 << 24 >> 24 ) == ( 0 ) ; if ( $25 ) { $$2$sink = $$22 ; label = 8 ; break ; } $26 = ( ( $$03 ) + 1 ) | 0 ; $27 = ( ( $$22 ) + 1 ) | 0 ; $$sink4 = ( ( $0 ) + ( $$22 ) | 0 ) ; HEAP8 [ $$sink4 >> 0 ] = $24 ; $28 = ( $$03 | 0 ) < ( 194 ) ; if ( $28 ) { $$03 = $26 ; $$22 = $27 ; } else { $$2$sink = $27 ; label = 8 ; break ; } } if ( ( label | 0 ) == 8 ) { $29 = ( ( $0 ) + ( $$2$sink ) | 0 ) ; HEAP8 [ $29 >> 0 ] = 0 ; return ; } } function _png_chunk_error ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$idx = 0 , $$idx$val = 0 , $2 = 0 , $3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 224 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 224 | 0 ) ; $2 = sp ; $3 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $3 ) { _png_error ( 0 , $1 ) ; // unreachable; } else { $$idx = ( ( ( $0 ) ) + 172 | 0 ) ; $$idx$val = HEAP32 [ $$idx >> 2 ] | 0 ; _png_format_buffer ( $$idx$val , $2 , $1 ) ; _png_error ( $0 , $2 ) ; // unreachable; } } function _png_chunk_warning ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$idx = 0 , $$idx$val = 0 , $2 = 0 , $3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 224 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 224 | 0 ) ; $2 = sp ; $3 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $3 ) { _png_warning ( 0 , $1 ) ; STACKTOP = sp ; return ; } else { $$idx = ( ( ( $0 ) ) + 172 | 0 ) ; $$idx$val = HEAP32 [ $$idx >> 2 ] | 0 ; _png_format_buffer ( $$idx$val , $2 , $1 ) ; _png_warning ( $0 , $2 ) ; STACKTOP = sp ; return ; } } function _png_app_warning ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( ( ( $0 ) ) + 28 | 0 ) ; $3 = HEAP32 [ $2 >> 2 ] | 0 ; $4 = $3 & 2097152 ; $5 = ( $4 | 0 ) == ( 0 ) ; if ( $5 ) { _png_error ( $0 , $1 ) ; // unreachable; } else { _png_warning ( $0 , $1 ) ; return ; } } function _png_app_error ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( ( ( $0 ) ) + 28 | 0 ) ; $3 = HEAP32 [ $2 >> 2 ] | 0 ; $4 = $3 & 4194304 ; $5 = ( $4 | 0 ) == ( 0 ) ; if ( $5 ) { _png_error ( $0 , $1 ) ; // unreachable; } else { _png_warning ( $0 , $1 ) ; return ; } } function _png_chunk_benign_error ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$idx$i = 0 , $$idx$val$i = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 224 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 224 | 0 ) ; $2 = sp ; $3 = ( ( ( $0 ) ) + 28 | 0 ) ; $4 = HEAP32 [ $3 >> 2 ] | 0 ; $5 = $4 & 1048576 ; $6 = ( $5 | 0 ) == ( 0 ) ; if ( $6 ) { _png_chunk_error ( $0 , $1 ) ; // unreachable; } else { $$idx$i = ( ( ( $0 ) ) + 172 | 0 ) ; $$idx$val$i = HEAP32 [ $$idx$i >> 2 ] | 0 ; _png_format_buffer ( $$idx$val$i , $2 , $1 ) ; _png_warning ( $0 , $2 ) ; STACKTOP = sp ; return ; } } function _png_chunk_report ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$idx$i = 0 , $$idx$i$i = 0 , $$idx$val$i = 0 , $$idx$val$i$i = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 ; var $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 224 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 224 | 0 ) ; $3 = sp ; $4 = ( ( ( $0 ) ) + 24 | 0 ) ; $5 = HEAP32 [ $4 >> 2 ] | 0 ; $6 = $5 & 32768 ; $7 = ( $6 | 0 ) == ( 0 ) ; if ( ! ( $7 ) ) { $8 = ( $2 | 0 ) < ( 2 ) ; if ( $8 ) { $$idx$i = ( ( ( $0 ) ) + 172 | 0 ) ; $$idx$val$i = HEAP32 [ $$idx$i >> 2 ] | 0 ; _png_format_buffer ( $$idx$val$i , $3 , $1 ) ; _png_warning ( $0 , $3 ) ; STACKTOP = sp ; return ; } $9 = ( ( ( $0 ) ) + 28 | 0 ) ; $10 = HEAP32 [ $9 >> 2 ] | 0 ; $11 = $10 & 1048576 ; $12 = ( $11 | 0 ) == ( 0 ) ; if ( $12 ) { _png_chunk_error ( $0 , $1 ) ; // unreachable; } $$idx$i$i = ( ( ( $0 ) ) + 172 | 0 ) ; $$idx$val$i$i = HEAP32 [ $$idx$i$i >> 2 ] | 0 ; _png_format_buffer ( $$idx$val$i$i , $3 , $1 ) ; _png_warning ( $0 , $3 ) ; STACKTOP = sp ; return ; } $13 = ( $2 | 0 ) < ( 1 ) ; $14 = ( ( ( $0 ) ) + 28 | 0 ) ; $15 = HEAP32 [ $14 >> 2 ] | 0 ; if ( $13 ) { $16 = $15 & 2097152 ; $17 = ( $16 | 0 ) == ( 0 ) ; if ( $17 ) { _png_error ( $0 , $1 ) ; // unreachable; } _png_warning ( $0 , $1 ) ; STACKTOP = sp ; return ; } else { $18 = $15 & 4194304 ; $19 = ( $18 | 0 ) == ( 0 ) ; if ( $19 ) { _png_error ( $0 , $1 ) ; // unreachable; } _png_warning ( $0 , $1 ) ; STACKTOP = sp ; return ; } } function _png_set_error_fn ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $4 = 0 , $5 = 0 , $6 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $4 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $4 ) { return ; } $5 = ( ( ( $0 ) ) + 8 | 0 ) ; HEAP32 [ $5 >> 2 ] = $1 ; HEAP32 [ $0 >> 2 ] = $2 ; $6 = ( ( ( $0 ) ) + 4 | 0 ) ; HEAP32 [ $6 >> 2 ] = $3 ; return ; } function _png_get_valid ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$0 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( $0 | 0 ) != ( 0 | 0 ) ; $4 = ( $1 | 0 ) != ( 0 | 0 ) ; $or$cond = $3 & $4 ; if ( ! ( $or$cond ) ) { $$0 = 0 ; return ( $$0 | 0 ) ; } $5 = ( ( ( $1 ) ) + 8 | 0 ) ; $6 = HEAP32 [ $5 >> 2 ] | 0 ; $7 = $6 & $2 ; $$0 = $7 ; return ( $$0 | 0 ) ; } function _png_get_rowbytes ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$0 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( $0 | 0 ) != ( 0 | 0 ) ; $3 = ( $1 | 0 ) != ( 0 | 0 ) ; $or$cond = $2 & $3 ; if ( ! ( $or$cond ) ) { $$0 = 0 ; return ( $$0 | 0 ) ; } $4 = ( ( ( $1 ) ) + 12 | 0 ) ; $5 = HEAP32 [ $4 >> 2 ] | 0 ; $$0 = $5 ; return ( $$0 | 0 ) ; } function _png_get_rows ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$0 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( $0 | 0 ) != ( 0 | 0 ) ; $3 = ( $1 | 0 ) != ( 0 | 0 ) ; $or$cond = $2 & $3 ; if ( ! ( $or$cond ) ) { $$0 = 0 ; return ( $$0 | 0 ) ; } $4 = ( ( ( $1 ) ) + 88 | 0 ) ; $5 = HEAP32 [ $4 >> 2 ] | 0 ; $$0 = $5 ; return ( $$0 | 0 ) ; } function _png_get_image_width ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$0 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( $0 | 0 ) != ( 0 | 0 ) ; $3 = ( $1 | 0 ) != ( 0 | 0 ) ; $or$cond = $2 & $3 ; if ( ! ( $or$cond ) ) { $$0 = 0 ; return ( $$0 | 0 ) ; } $4 = HEAP32 [ $1 >> 2 ] | 0 ; $$0 = $4 ; return ( $$0 | 0 ) ; } function _png_get_image_height ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$0 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( $0 | 0 ) != ( 0 | 0 ) ; $3 = ( $1 | 0 ) != ( 0 | 0 ) ; $or$cond = $2 & $3 ; if ( ! ( $or$cond ) ) { $$0 = 0 ; return ( $$0 | 0 ) ; } $4 = ( ( ( $1 ) ) + 4 | 0 ) ; $5 = HEAP32 [ $4 >> 2 ] | 0 ; $$0 = $5 ; return ( $$0 | 0 ) ; } function _png_get_bit_depth ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$0 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( $0 | 0 ) != ( 0 | 0 ) ; $3 = ( $1 | 0 ) != ( 0 | 0 ) ; $or$cond = $2 & $3 ; if ( ! ( $or$cond ) ) { $$0 = 0 ; return ( $$0 | 0 ) ; } $4 = ( ( ( $1 ) ) + 24 | 0 ) ; $5 = HEAP8 [ $4 >> 0 ] | 0 ; $$0 = $5 ; return ( $$0 | 0 ) ; } function _png_get_color_type ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$0 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( $0 | 0 ) != ( 0 | 0 ) ; $3 = ( $1 | 0 ) != ( 0 | 0 ) ; $or$cond = $2 & $3 ; if ( ! ( $or$cond ) ) { $$0 = 0 ; return ( $$0 | 0 ) ; } $4 = ( ( ( $1 ) ) + 25 | 0 ) ; $5 = HEAP8 [ $4 >> 0 ] | 0 ; $$0 = $5 ; return ( $$0 | 0 ) ; } function _png_get_channels ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$0 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( $0 | 0 ) != ( 0 | 0 ) ; $3 = ( $1 | 0 ) != ( 0 | 0 ) ; $or$cond = $2 & $3 ; if ( ! ( $or$cond ) ) { $$0 = 0 ; return ( $$0 | 0 ) ; } $4 = ( ( ( $1 ) ) + 29 | 0 ) ; $5 = HEAP8 [ $4 >> 0 ] | 0 ; $$0 = $5 ; return ( $$0 | 0 ) ; } function _png_get_bKGD ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$0 = 0 , $10 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , $or$cond3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( $0 | 0 ) != ( 0 | 0 ) ; $4 = ( $1 | 0 ) != ( 0 | 0 ) ; $or$cond = $3 & $4 ; if ( ! ( $or$cond ) ) { $$0 = 0 ; return ( $$0 | 0 ) ; } $5 = ( ( ( $1 ) ) + 8 | 0 ) ; $6 = HEAP32 [ $5 >> 2 ] | 0 ; $7 = $6 & 32 ; $8 = ( $7 | 0 ) != ( 0 ) ; $9 = ( $2 | 0 ) != ( 0 | 0 ) ; $or$cond3 = $9 & $8 ; if ( ! ( $or$cond3 ) ) { $$0 = 0 ; return ( $$0 | 0 ) ; } $10 = ( ( ( $1 ) ) + 62 | 0 ) ; HEAP32 [ $2 >> 2 ] = $10 ; $$0 = 32 ; return ( $$0 | 0 ) ; } function _png_get_hIST ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$0 = 0 , $10 = 0 , $11 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , $or$cond3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( $0 | 0 ) != ( 0 | 0 ) ; $4 = ( $1 | 0 ) != ( 0 | 0 ) ; $or$cond = $3 & $4 ; if ( ! ( $or$cond ) ) { $$0 = 0 ; return ( $$0 | 0 ) ; } $5 = ( ( ( $1 ) ) + 8 | 0 ) ; $6 = HEAP32 [ $5 >> 2 ] | 0 ; $7 = $6 & 64 ; $8 = ( $7 | 0 ) != ( 0 ) ; $9 = ( $2 | 0 ) != ( 0 | 0 ) ; $or$cond3 = $9 & $8 ; if ( ! ( $or$cond3 ) ) { $$0 = 0 ; return ( $$0 | 0 ) ; } $10 = ( ( ( $1 ) ) + 72 | 0 ) ; $11 = HEAP32 [ $10 >> 2 ] | 0 ; HEAP32 [ $2 >> 2 ] = $11 ; $$0 = 64 ; return ( $$0 | 0 ) ; } function _png_get_IHDR ( $0 , $1 , $2 , $3 , $4 , $5 , $6 , $7 , $8 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; $4 = $4 | 0 ; $5 = $5 | 0 ; $6 = $6 | 0 ; $7 = $7 | 0 ; $8 = $8 | 0 ; var $$0 = 0 , $$phi$trans$insert = 0 , $$pre = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 ; var $27 = 0 , $28 = 0 , $29 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 ; var $47 = 0 , $48 = 0 , $49 = 0 , $9 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $9 = ( $0 | 0 ) == ( 0 | 0 ) ; $10 = ( $1 | 0 ) == ( 0 | 0 ) ; $or$cond = $9 | $10 ; if ( $or$cond ) { $$0 = 0 ; return ( $$0 | 0 ) ; } $11 = ( $2 | 0 ) == ( 0 | 0 ) ; if ( ! ( $11 ) ) { $12 = HEAP32 [ $1 >> 2 ] | 0 ; HEAP32 [ $2 >> 2 ] = $12 ; } $13 = ( $3 | 0 ) == ( 0 | 0 ) ; if ( ! ( $13 ) ) { $14 = ( ( ( $1 ) ) + 4 | 0 ) ; $15 = HEAP32 [ $14 >> 2 ] | 0 ; HEAP32 [ $3 >> 2 ] = $15 ; } $16 = ( $4 | 0 ) == ( 0 | 0 ) ; if ( ! ( $16 ) ) { $17 = ( ( ( $1 ) ) + 24 | 0 ) ; $18 = HEAP8 [ $17 >> 0 ] | 0 ; $19 = $18 & 255 ; HEAP32 [ $4 >> 2 ] = $19 ; } $20 = ( $5 | 0 ) == ( 0 | 0 ) ; if ( ! ( $20 ) ) { $21 = ( ( ( $1 ) ) + 25 | 0 ) ; $22 = HEAP8 [ $21 >> 0 ] | 0 ; $23 = $22 & 255 ; HEAP32 [ $5 >> 2 ] = $23 ; } $24 = ( $7 | 0 ) == ( 0 | 0 ) ; if ( ! ( $24 ) ) { $25 = ( ( ( $1 ) ) + 26 | 0 ) ; $26 = HEAP8 [ $25 >> 0 ] | 0 ; $27 = $26 & 255 ; HEAP32 [ $7 >> 2 ] = $27 ; } $28 = ( $8 | 0 ) == ( 0 | 0 ) ; if ( ! ( $28 ) ) { $29 = ( ( ( $1 ) ) + 27 | 0 ) ; $30 = HEAP8 [ $29 >> 0 ] | 0 ; $31 = $30 & 255 ; HEAP32 [ $8 >> 2 ] = $31 ; } $32 = ( $6 | 0 ) == ( 0 | 0 ) ; $$phi$trans$insert = ( ( ( $1 ) ) + 28 | 0 ) ; $$pre = HEAP8 [ $$phi$trans$insert >> 0 ] | 0 ; if ( ! ( $32 ) ) { $33 = $$pre & 255 ; HEAP32 [ $6 >> 2 ] = $33 ; } $34 = HEAP32 [ $1 >> 2 ] | 0 ; $35 = ( ( ( $1 ) ) + 4 | 0 ) ; $36 = HEAP32 [ $35 >> 2 ] | 0 ; $37 = ( ( ( $1 ) ) + 24 | 0 ) ; $38 = HEAP8 [ $37 >> 0 ] | 0 ; $39 = $38 & 255 ; $40 = ( ( ( $1 ) ) + 25 | 0 ) ; $41 = HEAP8 [ $40 >> 0 ] | 0 ; $42 = $41 & 255 ; $43 = $$pre & 255 ; $44 = ( ( ( $1 ) ) + 26 | 0 ) ; $45 = HEAP8 [ $44 >> 0 ] | 0 ; $46 = $45 & 255 ; $47 = ( ( ( $1 ) ) + 27 | 0 ) ; $48 = HEAP8 [ $47 >> 0 ] | 0 ; $49 = $48 & 255 ; _png_check_IHDR ( $0 , $34 , $36 , $39 , $42 , $43 , $46 , $49 ) ; $$0 = 1 ; return ( $$0 | 0 ) ; } function _png_get_PLTE ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $$0 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , $or$cond3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $4 = ( $0 | 0 ) != ( 0 | 0 ) ; $5 = ( $1 | 0 ) != ( 0 | 0 ) ; $or$cond = $4 & $5 ; if ( ! ( $or$cond ) ) { $$0 = 0 ; return ( $$0 | 0 ) ; } $6 = ( ( ( $1 ) ) + 8 | 0 ) ; $7 = HEAP32 [ $6 >> 2 ] | 0 ; $8 = $7 & 8 ; $9 = ( $8 | 0 ) != ( 0 ) ; $10 = ( $2 | 0 ) != ( 0 | 0 ) ; $or$cond3 = $10 & $9 ; if ( ! ( $or$cond3 ) ) { $$0 = 0 ; return ( $$0 | 0 ) ; } $11 = ( ( ( $1 ) ) + 16 | 0 ) ; $12 = HEAP32 [ $11 >> 2 ] | 0 ; HEAP32 [ $2 >> 2 ] = $12 ; $13 = ( ( ( $1 ) ) + 20 | 0 ) ; $14 = HEAP16 [ $13 >> 1 ] | 0 ; $15 = $14 & 65535 ; HEAP32 [ $3 >> 2 ] = $15 ; $$0 = 8 ; return ( $$0 | 0 ) ; } function _png_get_sBIT ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$0 = 0 , $10 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , $or$cond3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( $0 | 0 ) != ( 0 | 0 ) ; $4 = ( $1 | 0 ) != ( 0 | 0 ) ; $or$cond = $3 & $4 ; if ( ! ( $or$cond ) ) { $$0 = 0 ; return ( $$0 | 0 ) ; } $5 = ( ( ( $1 ) ) + 8 | 0 ) ; $6 = HEAP32 [ $5 >> 2 ] | 0 ; $7 = $6 & 2 ; $8 = ( $7 | 0 ) != ( 0 ) ; $9 = ( $2 | 0 ) != ( 0 | 0 ) ; $or$cond3 = $9 & $8 ; if ( ! ( $or$cond3 ) ) { $$0 = 0 ; return ( $$0 | 0 ) ; } $10 = ( ( ( $1 ) ) + 40 | 0 ) ; HEAP32 [ $2 >> 2 ] = $10 ; $$0 = 2 ; return ( $$0 | 0 ) ; } function _png_get_tRNS ( $0 , $1 , $2 , $3 , $4 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; $4 = $4 | 0 ; var $$0 = 0 , $$1 = 0 , $$2 = 0 , $$3 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 ; var $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $5 = ( $0 | 0 ) != ( 0 | 0 ) ; $6 = ( $1 | 0 ) != ( 0 | 0 ) ; $or$cond = $5 & $6 ; if ( ! ( $or$cond ) ) { $$3 = 0 ; return ( $$3 | 0 ) ; } $7 = ( ( ( $1 ) ) + 8 | 0 ) ; $8 = HEAP32 [ $7 >> 2 ] | 0 ; $9 = $8 & 16 ; $10 = ( $9 | 0 ) == ( 0 ) ; if ( $10 ) { $$3 = 0 ; return ( $$3 | 0 ) ; } $11 = ( ( ( $1 ) ) + 25 | 0 ) ; $12 = HEAP8 [ $11 >> 0 ] | 0 ; $13 = ( $12 << 24 >> 24 ) == ( 3 ) ; if ( $13 ) { $14 = ( $2 | 0 ) == ( 0 | 0 ) ; if ( $14 ) { $$0 = 0 ; } else { $15 = ( ( ( $1 ) ) + 48 | 0 ) ; $16 = HEAP32 [ $15 >> 2 ] | 0 ; HEAP32 [ $2 >> 2 ] = $16 ; $$0 = 16 ; } $17 = ( $4 | 0 ) == ( 0 | 0 ) ; if ( $17 ) { $$2 = $$0 ; } else { $18 = ( ( ( $1 ) ) + 52 | 0 ) ; HEAP32 [ $4 >> 2 ] = $18 ; $$2 = $$0 ; } } else { $19 = ( $4 | 0 ) == ( 0 | 0 ) ; if ( $19 ) { $$1 = 0 ; } else { $20 = ( ( ( $1 ) ) + 52 | 0 ) ; HEAP32 [ $4 >> 2 ] = $20 ; $$1 = 16 ; } $21 = ( $2 | 0 ) == ( 0 | 0 ) ; if ( $21 ) { $$2 = $$1 ; } else { HEAP32 [ $2 >> 2 ] = 0 ; $$2 = $$1 ; } } $22 = ( $3 | 0 ) == ( 0 | 0 ) ; if ( $22 ) { $$3 = $$2 ; return ( $$3 | 0 ) ; } $23 = ( ( ( $1 ) ) + 22 | 0 ) ; $24 = HEAP16 [ $23 >> 1 ] | 0 ; $25 = $24 & 65535 ; HEAP32 [ $3 >> 2 ] = $25 ; $$3 = 16 ; return ( $$3 | 0 ) ; } function _png_get_unknown_chunks ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$0 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , $or$cond3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( $0 | 0 ) != ( 0 | 0 ) ; $4 = ( $1 | 0 ) != ( 0 | 0 ) ; $or$cond = $3 & $4 ; $5 = ( $2 | 0 ) != ( 0 | 0 ) ; $or$cond3 = $or$cond & $5 ; if ( ! ( $or$cond3 ) ) { $$0 = 0 ; return ( $$0 | 0 ) ; } $6 = ( ( ( $1 ) ) + 80 | 0 ) ; $7 = HEAP32 [ $6 >> 2 ] | 0 ; HEAP32 [ $2 >> 2 ] = $7 ; $8 = ( ( ( $1 ) ) + 84 | 0 ) ; $9 = HEAP32 [ $8 >> 2 ] | 0 ; $$0 = $9 ; return ( $$0 | 0 ) ; } function _png_get_io_state ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( ( ( $0 ) ) + 372 | 0 ) ; $2 = HEAP32 [ $1 >> 2 ] | 0 ; return ( $2 | 0 ) ; } function _png_destroy_png_struct ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( ! ( $1 ) ) { _free ( $0 ) ; } return ; } function _png_free ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $2 = 0 , $3 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( $0 | 0 ) == ( 0 | 0 ) ; $3 = ( $1 | 0 ) == ( 0 | 0 ) ; $or$cond = $2 | $3 ; if ( $or$cond ) { return ; } _free ( $1 ) ; return ; } function _png_calloc ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$0$i6 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $2 ) { $$0$i6 = 0 ; return ( $$0$i6 | 0 ) ; } $3 = ( $1 | 0 ) == ( 0 ) ; if ( ! ( $3 ) ) { $4 = ( _malloc ( $1 ) | 0 ) ; $5 = ( $4 | 0 ) == ( 0 | 0 ) ; if ( ! ( $5 ) ) { _memset ( ( $4 | 0 ) , 0 , ( $1 | 0 ) ) | 0 ; $$0$i6 = $4 ; return ( $$0$i6 | 0 ) ; } } _png_error ( $0 , 24383 ) ; // unreachable; return ( 0 ) | 0 ; } function _png_malloc ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$0 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $2 ) { $$0 = 0 ; return ( $$0 | 0 ) ; } $3 = ( $1 | 0 ) == ( 0 ) ; if ( ! ( $3 ) ) { $4 = ( _malloc ( $1 ) | 0 ) ; $5 = ( $4 | 0 ) == ( 0 | 0 ) ; if ( ! ( $5 ) ) { $$0 = $4 ; return ( $$0 | 0 ) ; } } _png_error ( $0 , 24383 ) ; // unreachable; return ( 0 ) | 0 ; } function _png_malloc_base ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$0 = 0 , $2 = 0 , $3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( $1 | 0 ) == ( 0 ) ; if ( $2 ) { $$0 = 0 ; } else { $3 = ( _malloc ( $1 ) | 0 ) ; $$0 = $3 ; } return ( $$0 | 0 ) ; } function _png_realloc_array ( $0 , $1 , $2 , $3 , $4 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; $4 = $4 | 0 ; var $$1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , $or$cond3 = 0 ; var $or$cond5 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $5 = ( $3 | 0 ) < ( 1 ) ; $6 = ( $4 | 0 ) == ( 0 ) ; $or$cond = $5 | $6 ; $7 = ( $2 | 0 ) < ( 0 ) ; $or$cond3 = $7 | $or$cond ; if ( $or$cond3 ) { _png_error ( $0 , 24397 ) ; // unreachable; } $8 = ( $1 | 0 ) == ( 0 | 0 ) ; $9 = ( $2 | 0 ) > ( 0 ) ; $or$cond5 = $8 & $9 ; if ( $or$cond5 ) { _png_error ( $0 , 24397 ) ; // unreachable; } $10 = ( 2147483647 - ( $2 ) ) | 0 ; $11 = ( $10 | 0 ) < ( $3 | 0 ) ; if ( $11 ) { $$1 = 0 ; return ( $$1 | 0 ) ; } $12 = ( ( $3 ) + ( $2 ) ) | 0 ; $13 = ( 4294967295 / ( $4 >>> 0 ) ) & - 1 ; $14 = ( $13 >>> 0 ) < ( $12 >>> 0 ) ; if ( $14 ) { $$1 = 0 ; return ( $$1 | 0 ) ; } $15 = Math_imul ( $12 , $4 ) | 0 ; $16 = ( $15 | 0 ) == ( 0 ) ; if ( $16 ) { $$1 = 0 ; return ( $$1 | 0 ) ; } $17 = ( _malloc ( $15 ) | 0 ) ; $18 = ( $17 | 0 ) == ( 0 | 0 ) ; if ( $18 ) { $$1 = 0 ; return ( $$1 | 0 ) ; } $19 = Math_imul ( $4 , $2 ) | 0 ; if ( $9 ) { _memcpy ( ( $17 | 0 ) , ( $1 | 0 ) , ( $19 | 0 ) ) | 0 ; } $20 = ( ( $17 ) + ( $19 ) | 0 ) ; $21 = Math_imul ( $4 , $3 ) | 0 ; _memset ( ( $20 | 0 ) , 0 , ( $21 | 0 ) ) | 0 ; $$1 = $17 ; return ( $$1 | 0 ) ; } function _png_malloc_warn ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$1 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( $0 | 0 ) == ( 0 | 0 ) ; do { if ( $2 ) { $$1 = 0 ; } else { $3 = ( $1 | 0 ) == ( 0 ) ; if ( ! ( $3 ) ) { $4 = ( _malloc ( $1 ) | 0 ) ; $5 = ( $4 | 0 ) == ( 0 | 0 ) ; if ( ! ( $5 ) ) { $$1 = $4 ; break ; } } _png_warning ( $0 , 24383 ) ; $$1 = 0 ; } } while ( 0 ) ; return ( $$1 | 0 ) ; } function _png_create_read_struct ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $10 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $4 = ( _png_create_png_struct ( $0 , $1 , $2 , $3 , 0 , 0 , 0 ) | 0 ) ; $5 = ( $4 | 0 ) == ( 0 | 0 ) ; if ( $5 ) { return ( $4 | 0 ) ; } $6 = ( ( ( $4 ) ) + 24 | 0 ) ; HEAP32 [ $6 >> 2 ] = 32768 ; $7 = ( ( ( $4 ) ) + 368 | 0 ) ; HEAP32 [ $7 >> 2 ] = 8192 ; $8 = ( ( ( $4 ) ) + 28 | 0 ) ; $9 = HEAP32 [ $8 >> 2 ] | 0 ; $10 = $9 | 3145728 ; HEAP32 [ $8 >> 2 ] = $10 ; _png_set_read_fn ( $4 , 0 , 0 ) ; return ( $4 | 0 ) ; } function _png_read_info ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$pre = 0 , $$sink = 0 , $$sink4 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 ; var $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , $or$cond67 = 0 , $switch$split12D = 0 , $switch$split2D = 0 , $switch$split42D = 0 , $switch$split72D = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( $0 | 0 ) == ( 0 | 0 ) ; $3 = ( $1 | 0 ) == ( 0 | 0 ) ; $or$cond = $2 | $3 ; if ( $or$cond ) { return ; } _png_read_sig ( $0 , $1 ) ; $4 = ( ( ( $0 ) ) + 172 | 0 ) ; $5 = ( ( ( $0 ) ) + 24 | 0 ) ; $6 = ( ( ( $0 ) ) + 223 | 0 ) ; L4 : while ( 1 ) { $7 = ( _png_read_chunk_header ( $0 ) | 0 ) ; $8 = HEAP32 [ $4 >> 2 ] | 0 ; $9 = ( $8 | 0 ) == ( 1229209940 ) ; $10 = HEAP32 [ $5 >> 2 ] | 0 ; if ( $9 ) { $11 = $10 & 1 ; $12 = ( $11 | 0 ) == ( 0 ) ; if ( $12 ) { label = 5 ; break ; } $13 = HEAP8 [ $6 >> 0 ] | 0 ; $14 = ( $13 << 24 >> 24 ) == ( 3 ) ; $15 = $10 & 2 ; $16 = ( $15 | 0 ) == ( 0 ) ; $or$cond67 = $16 & $14 ; if ( $or$cond67 ) { label = 7 ; break ; } $17 = $10 & 8 ; $18 = ( $17 | 0 ) == ( 0 ) ; if ( $18 ) { $$sink4 = 4 ; $23 = $10 ; label = 12 ; } else { _png_chunk_benign_error ( $0 , 24477 ) ; $$pre = HEAP32 [ $5 >> 2 ] | 0 ; $$sink4 = 4 ; $23 = $$pre ; label = 12 ; } } else { $19 = $10 & 4 ; $20 = ( $19 | 0 ) == ( 0 ) ; if ( ! ( $20 ) ) { $21 = $10 | 8192 ; HEAP32 [ $5 >> 2 ] = $21 ; $$sink4 = 8 ; $23 = $21 ; label = 12 ; } } if ( ( label | 0 ) == 12 ) { label = 0 ; $22 = $23 | $$sink4 ; HEAP32 [ $5 >> 2 ] = $22 ; } $switch$split2D = ( $8 | 0 ) < ( 1229472850 ) ; L16 : do { if ( $switch$split2D ) { switch ( $8 | 0 ) { case 1229278788 : { break ; } default : { break L16 ; } } _png_handle_IEND ( $0 , $1 , $7 ) ; continue L4 ; } else { switch ( $8 | 0 ) { case 1229472850 : { break ; } default : { break L16 ; } } _png_handle_IHDR ( $0 , $1 , $7 ) ; continue L4 ; } } while ( 0 ) ; $24 = ( _png_chunk_unknown_handling ( $0 , $8 ) | 0 ) ; $25 = ( $24 | 0 ) == ( 0 ) ; if ( ! ( $25 ) ) { _png_handle_unknown ( $0 , $1 , $7 , $24 ) ; $26 = ( $8 | 0 ) == ( 1347179589 ) ; if ( $26 ) { $27 = HEAP32 [ $5 >> 2 ] | 0 ; $28 = $27 | 2 ; HEAP32 [ $5 >> 2 ] = $28 ; continue ; } else { if ( $9 ) { $$sink = 0 ; label = 29 ; break ; } else { continue ; } } } $29 = ( $8 | 0 ) == ( 1347179589 ) ; if ( $29 ) { _png_handle_PLTE ( $0 , $1 , $7 ) ; continue ; } if ( $9 ) { $$sink = $7 ; label = 29 ; break ; } $switch$split12D = ( $8 | 0 ) < ( 1933723988 ) ; L32 : do { if ( $switch$split12D ) { $switch$split42D = ( $8 | 0 ) < ( 1749635924 ) ; if ( $switch$split42D ) { switch ( $8 | 0 ) { case 1649100612 : { break ; } default : { break L32 ; } } _png_handle_bKGD ( $0 , $1 , $7 ) ; continue L4 ; } else { switch ( $8 | 0 ) { case 1749635924 : { break ; } default : { break L32 ; } } _png_handle_hIST ( $0 , $1 , $7 ) ; continue L4 ; } } else { $switch$split72D = ( $8 | 0 ) < ( 1951551059 ) ; if ( $switch$split72D ) { switch ( $8 | 0 ) { case 1933723988 : { break ; } default : { break L32 ; } } _png_handle_sBIT ( $0 , $1 , $7 ) ; continue L4 ; } else { switch ( $8 | 0 ) { case 1951551059 : { break ; } default : { break L32 ; } } _png_handle_tRNS ( $0 , $1 , $7 ) ; continue L4 ; } } } while ( 0 ) ; _png_handle_unknown ( $0 , $1 , $7 , 0 ) ; } if ( ( label | 0 ) == 5 ) { _png_chunk_error ( $0 , 24427 ) ; // unreachable; } else if ( ( label | 0 ) == 7 ) { _png_chunk_error ( $0 , 24452 ) ; // unreachable; } else if ( ( label | 0 ) == 29 ) { $30 = ( ( ( $0 ) ) + 196 | 0 ) ; HEAP32 [ $30 >> 2 ] = $$sink ; return ; } } function _png_read_row ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$pre = 0 , $$pre$phiZ2D = 0 , $$pre96 = 0 , $$pre97 = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 ; var $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $14 = 0 ; var $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 ; var $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 ; var $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 ; var $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 ; var $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $or$cond = 0 , $or$cond95 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $3 = sp ; $4 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $4 ) { STACKTOP = sp ; return ; } $5 = ( ( ( $0 ) ) + 28 | 0 ) ; $6 = HEAP32 [ $5 >> 2 ] | 0 ; $7 = $6 & 64 ; $8 = ( $7 | 0 ) == ( 0 ) ; if ( $8 ) { _png_read_start_row ( $0 ) ; } $9 = ( ( ( $0 ) ) + 164 | 0 ) ; $10 = HEAP32 [ $9 >> 2 ] | 0 ; HEAP32 [ $3 >> 2 ] = $10 ; $11 = ( ( ( $0 ) ) + 223 | 0 ) ; $12 = HEAP8 [ $11 >> 0 ] | 0 ; $13 = ( ( ( $3 ) ) + 8 | 0 ) ; HEAP8 [ $13 >> 0 ] = $12 ; $14 = ( ( ( $0 ) ) + 224 | 0 ) ; $15 = HEAP8 [ $14 >> 0 ] | 0 ; $16 = ( ( ( $3 ) ) + 9 | 0 ) ; HEAP8 [ $16 >> 0 ] = $15 ; $17 = ( ( ( $0 ) ) + 227 | 0 ) ; $18 = HEAP8 [ $17 >> 0 ] | 0 ; $19 = ( ( ( $3 ) ) + 10 | 0 ) ; HEAP8 [ $19 >> 0 ] = $18 ; $20 = ( ( ( $0 ) ) + 226 | 0 ) ; $21 = HEAP8 [ $20 >> 0 ] | 0 ; $22 = ( ( ( $3 ) ) + 11 | 0 ) ; HEAP8 [ $22 >> 0 ] = $21 ; $23 = $21 & 255 ; $24 = ( $21 & 255 ) > ( 7 ) ; if ( $24 ) { $25 = $23 >>> 3 ; $26 = Math_imul ( $10 , $25 ) | 0 ; $31 = $26 ; } else { $27 = Math_imul ( $10 , $23 ) | 0 ; $28 = ( ( $27 ) + 7 ) | 0 ; $29 = $28 >>> 3 ; $31 = $29 ; } $30 = ( ( ( $3 ) ) + 4 | 0 ) ; HEAP32 [ $30 >> 2 ] = $31 ; $32 = ( ( ( $0 ) ) + 168 | 0 ) ; $33 = HEAP32 [ $32 >> 2 ] | 0 ; $34 = ( ( ( $0 ) ) + 220 | 0 ) ; $35 = HEAP8 [ $34 >> 0 ] | 0 ; $36 = ( $35 << 24 >> 24 ) == ( 0 ) ; L11 : do { if ( ! ( $36 ) ) { $37 = ( ( ( $0 ) ) + 32 | 0 ) ; $38 = HEAP32 [ $37 >> 2 ] | 0 ; $39 = $38 & 2 ; $40 = ( $39 | 0 ) == ( 0 ) ; if ( ! ( $40 ) ) { $41 = ( ( ( $0 ) ) + 221 | 0 ) ; $42 = HEAP8 [ $41 >> 0 ] | 0 ; switch ( $42 << 24 >> 24 ) { case 0 : { $43 = $33 & 7 ; $44 = ( $43 | 0 ) == ( 0 ) ; if ( $44 ) { break L11 ; } $45 = ( $2 | 0 ) == ( 0 | 0 ) ; if ( ! ( $45 ) ) { _png_combine_row ( $0 , $2 , 1 ) ; } _png_read_finish_row ( $0 ) ; STACKTOP = sp ; return ; break ; } case 1 : { $46 = $33 & 7 ; $47 = ( $46 | 0 ) == ( 0 ) ; if ( $47 ) { $48 = ( ( ( $0 ) ) + 144 | 0 ) ; $49 = HEAP32 [ $48 >> 2 ] | 0 ; $50 = ( $49 >>> 0 ) < ( 5 ) ; if ( ! ( $50 ) ) { break L11 ; } } $51 = ( $2 | 0 ) == ( 0 | 0 ) ; if ( ! ( $51 ) ) { _png_combine_row ( $0 , $2 , 1 ) ; } _png_read_finish_row ( $0 ) ; STACKTOP = sp ; return ; break ; } case 2 : { $52 = $33 & 7 ; $53 = ( $52 | 0 ) == ( 4 ) ; if ( $53 ) { break L11 ; } $54 = ( $2 | 0 ) == ( 0 | 0 ) ; $55 = $33 & 4 ; $56 = ( $55 | 0 ) == ( 0 ) ; $or$cond = $54 | $56 ; if ( ! ( $or$cond ) ) { _png_combine_row ( $0 , $2 , 1 ) ; } _png_read_finish_row ( $0 ) ; STACKTOP = sp ; return ; break ; } case 3 : { $57 = $33 & 3 ; $58 = ( $57 | 0 ) == ( 0 ) ; if ( $58 ) { $59 = ( ( ( $0 ) ) + 144 | 0 ) ; $60 = HEAP32 [ $59 >> 2 ] | 0 ; $61 = ( $60 >>> 0 ) < ( 3 ) ; if ( ! ( $61 ) ) { break L11 ; } } $62 = ( $2 | 0 ) == ( 0 | 0 ) ; if ( ! ( $62 ) ) { _png_combine_row ( $0 , $2 , 1 ) ; } _png_read_finish_row ( $0 ) ; STACKTOP = sp ; return ; break ; } case 4 : { $63 = $33 & 3 ; $64 = ( $63 | 0 ) == ( 2 ) ; if ( $64 ) { break L11 ; } $65 = ( $2 | 0 ) == ( 0 | 0 ) ; $66 = $33 & 2 ; $67 = ( $66 | 0 ) == ( 0 ) ; $or$cond95 = $65 | $67 ; if ( ! ( $or$cond95 ) ) { _png_combine_row ( $0 , $2 , 1 ) ; } _png_read_finish_row ( $0 ) ; STACKTOP = sp ; return ; break ; } case 5 : { $68 = $33 & 1 ; $69 = ( $68 | 0 ) == ( 0 ) ; if ( $69 ) { $70 = ( ( ( $0 ) ) + 144 | 0 ) ; $71 = HEAP32 [ $70 >> 2 ] | 0 ; $72 = ( $71 >>> 0 ) < ( 2 ) ; if ( ! ( $72 ) ) { break L11 ; } } $73 = ( $2 | 0 ) == ( 0 | 0 ) ; if ( ! ( $73 ) ) { _png_combine_row ( $0 , $2 , 1 ) ; } _png_read_finish_row ( $0 ) ; STACKTOP = sp ; return ; break ; } default : { $74 = $33 & 1 ; $75 = ( $74 | 0 ) == ( 0 ) ; if ( ! ( $75 ) ) { break L11 ; } _png_read_finish_row ( $0 ) ; STACKTOP = sp ; return ; } } } } } while ( 0 ) ; $76 = ( ( ( $0 ) ) + 24 | 0 ) ; $77 = HEAP32 [ $76 >> 2 ] | 0 ; $78 = $77 & 4 ; $79 = ( $78 | 0 ) == ( 0 ) ; if ( $79 ) { _png_error ( $0 , 24614 ) ; // unreachable; } $80 = ( ( ( $0 ) ) + 180 | 0 ) ; $81 = HEAP32 [ $80 >> 2 ] | 0 ; HEAP8 [ $81 >> 0 ] = - 1 ; $82 = HEAP32 [ $80 >> 2 ] | 0 ; $83 = HEAP32 [ $30 >> 2 ] | 0 ; $84 = ( ( $83 ) + 1 ) | 0 ; _png_read_IDAT_data ( $0 , $82 , $84 ) ; $85 = HEAP32 [ $80 >> 2 ] | 0 ; $86 = HEAP8 [ $85 >> 0 ] | 0 ; $87 = $86 & 255 ; $88 = ( $86 << 24 >> 24 ) == ( 0 ) ; do { if ( $88 ) { $$pre97 = ( ( ( $0 ) ) + 176 | 0 ) ; $$pre$phiZ2D = $$pre97 ; $96 = $83 ; $97 = $85 ; } else { $89 = ( $86 & 255 ) < ( 5 ) ; if ( $89 ) { $90 = ( ( ( $85 ) ) + 1 | 0 ) ; $91 = ( ( ( $0 ) ) + 176 | 0 ) ; $92 = HEAP32 [ $91 >> 2 ] | 0 ; $93 = ( ( ( $92 ) ) + 1 | 0 ) ; _png_read_filter_row ( $0 , $3 , $90 , $93 , $87 ) ; $$pre = HEAP32 [ $80 >> 2 ] | 0 ; $$pre96 = HEAP32 [ $30 >> 2 ] | 0 ; $$pre$phiZ2D = $91 ; $96 = $$pre96 ; $97 = $$pre ; break ; } else { _png_error ( $0 , 24647 ) ; // unreachable; } } } while ( 0 ) ; $94 = HEAP32 [ $$pre$phiZ2D >> 2 ] | 0 ; $95 = ( ( $96 ) + 1 ) | 0 ; _memcpy ( ( $94 | 0 ) , ( $97 | 0 ) , ( $95 | 0 ) ) | 0 ; $98 = ( ( ( $0 ) ) + 32 | 0 ) ; $99 = HEAP32 [ $98 >> 2 ] | 0 ; $100 = ( $99 | 0 ) == ( 0 ) ; if ( ! ( $100 ) ) { _png_do_read_transformations ( $0 , $3 ) ; } $101 = ( ( ( $0 ) ) + 231 | 0 ) ; $102 = HEAP8 [ $101 >> 0 ] | 0 ; $103 = ( $102 << 24 >> 24 ) == ( 0 ) ; $104 = HEAP8 [ $22 >> 0 ] | 0 ; if ( $103 ) { HEAP8 [ $101 >> 0 ] = $104 ; $105 = ( ( ( $0 ) ) + 230 | 0 ) ; $106 = HEAP8 [ $105 >> 0 ] | 0 ; $107 = ( $104 & 255 ) > ( $106 & 255 ) ; if ( $107 ) { _png_error ( $0 , 24673 ) ; // unreachable; } } else { $108 = ( $102 << 24 >> 24 ) == ( $104 << 24 >> 24 ) ; if ( ! ( $108 ) ) { _png_error ( $0 , 24697 ) ; // unreachable; } } $109 = HEAP8 [ $34 >> 0 ] | 0 ; $110 = ( $109 << 24 >> 24 ) == ( 0 ) ; if ( $110 ) { label = 61 ; } else { $111 = HEAP32 [ $98 >> 2 ] | 0 ; $112 = $111 & 2 ; $113 = ( $112 | 0 ) == ( 0 ) ; if ( $113 ) { label = 61 ; } else { $114 = ( ( ( $0 ) ) + 221 | 0 ) ; $115 = HEAP8 [ $114 >> 0 ] | 0 ; $116 = ( $115 & 255 ) < ( 6 ) ; if ( $116 ) { $117 = $115 & 255 ; $118 = HEAP32 [ $80 >> 2 ] | 0 ; $119 = ( ( ( $118 ) ) + 1 | 0 ) ; _png_do_read_interlace ( $3 , $119 , $117 , $111 ) ; } $120 = ( $2 | 0 ) == ( 0 | 0 ) ; if ( ! ( $120 ) ) { _png_combine_row ( $0 , $2 , 1 ) ; } $121 = ( $1 | 0 ) == ( 0 | 0 ) ; if ( ! ( $121 ) ) { _png_combine_row ( $0 , $1 , 0 ) ; } } } if ( ( label | 0 ) == 61 ) { $122 = ( $1 | 0 ) == ( 0 | 0 ) ; if ( ! ( $122 ) ) { _png_combine_row ( $0 , $1 , - 1 ) ; } $123 = ( $2 | 0 ) == ( 0 | 0 ) ; if ( ! ( $123 ) ) { _png_combine_row ( $0 , $2 , - 1 ) ; } } _png_read_finish_row ( $0 ) ; $124 = ( ( ( $0 ) ) + 288 | 0 ) ; $125 = HEAP32 [ $124 >> 2 ] | 0 ; $126 = ( $125 | 0 ) == ( 0 | 0 ) ; if ( $126 ) { STACKTOP = sp ; return ; } $127 = HEAP32 [ $32 >> 2 ] | 0 ; $128 = ( ( ( $0 ) ) + 221 | 0 ) ; $129 = HEAP8 [ $128 >> 0 ] | 0 ; $130 = $129 & 255 ; FUNCTION_TABLE_viii [ $125 & 127 ] ( $0 , $127 , $130 ) ; STACKTOP = sp ; return ; } function _png_read_image ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$02833$us = 0 , $$029 = 0 , $$03031$us = 0 , $$032$us = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 ; var $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $exitcond = 0 , $exitcond35 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $2 ) { return ; } $3 = ( ( ( $0 ) ) + 28 | 0 ) ; $4 = HEAP32 [ $3 >> 2 ] | 0 ; $5 = $4 & 64 ; $6 = ( $5 | 0 ) == ( 0 ) ; do { if ( $6 ) { $7 = ( _png_set_interlace_handling ( $0 ) | 0 ) ; $8 = HEAP32 [ $3 >> 2 ] | 0 ; $9 = $8 & 64 ; $10 = ( $9 | 0 ) == ( 0 ) ; if ( $10 ) { _png_read_start_row ( $0 ) ; $$029 = $7 ; break ; } else { _png_app_error ( $0 , 24556 ) ; $$029 = $7 ; break ; } } else { $11 = ( ( ( $0 ) ) + 220 | 0 ) ; $12 = HEAP8 [ $11 >> 0 ] | 0 ; $13 = ( $12 << 24 >> 24 ) == ( 0 ) ; if ( ! ( $13 ) ) { $14 = ( ( ( $0 ) ) + 32 | 0 ) ; $15 = HEAP32 [ $14 >> 2 ] | 0 ; $16 = $15 & 2 ; $17 = ( $16 | 0 ) == ( 0 ) ; if ( $17 ) { _png_warning ( $0 , 24744 ) ; $18 = ( ( ( $0 ) ) + 148 | 0 ) ; $19 = HEAP32 [ $18 >> 2 ] | 0 ; $20 = ( ( ( $0 ) ) + 152 | 0 ) ; HEAP32 [ $20 >> 2 ] = $19 ; } } $21 = ( _png_set_interlace_handling ( $0 ) | 0 ) ; $$029 = $21 ; } } while ( 0 ) ; $22 = ( ( ( $0 ) ) + 148 | 0 ) ; $23 = HEAP32 [ $22 >> 2 ] | 0 ; $24 = ( $$029 | 0 ) < ( 1 ) ; $25 = ( $23 | 0 ) == ( 0 ) ; $or$cond = $24 | $25 ; if ( $or$cond ) { return ; } else { $$02833$us = 0 ; } while ( 1 ) { $$03031$us = 0 ; $$032$us = $1 ; while ( 1 ) { $26 = HEAP32 [ $$032$us >> 2 ] | 0 ; _png_read_row ( $0 , $26 , 0 ) ; $27 = ( ( ( $$032$us ) ) + 4 | 0 ) ; $28 = ( ( $$03031$us ) + 1 ) | 0 ; $exitcond = ( $28 | 0 ) == ( $23 | 0 ) ; if ( $exitcond ) { break ; } else { $$03031$us = $28 ; $$032$us = $27 ; } } $29 = ( ( $$02833$us ) + 1 ) | 0 ; $exitcond35 = ( $29 | 0 ) == ( $$029 | 0 ) ; if ( $exitcond35 ) { break ; } else { $$02833$us = $29 ; } } return ; } function _png_read_end ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 ; var $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $5 = 0 , $6 = 0 , $7 = 0 ; var $8 = 0 , $9 = 0 , $cond = 0 , $switch$split102D = 0 , $switch$split12D = 0 , $switch$split2D = 0 , $switch$split42D = 0 , $switch$split72D = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $2 ) { return ; } $3 = ( _png_chunk_unknown_handling ( $0 , 1229209940 ) | 0 ) ; $4 = ( $3 | 0 ) == ( 0 ) ; if ( $4 ) { _png_read_finish_IDAT ( $0 ) ; } $5 = ( ( ( $0 ) ) + 223 | 0 ) ; $6 = HEAP8 [ $5 >> 0 ] | 0 ; $7 = ( $6 << 24 >> 24 ) == ( 3 ) ; if ( $7 ) { $8 = ( ( ( $0 ) ) + 212 | 0 ) ; $9 = HEAP32 [ $8 >> 2 ] | 0 ; $10 = ( ( ( $0 ) ) + 208 | 0 ) ; $11 = HEAP16 [ $10 >> 1 ] | 0 ; $12 = $11 & 65535 ; $13 = ( $9 | 0 ) > ( $12 | 0 ) ; if ( $13 ) { _png_benign_error ( $0 , 24809 ) ; } } $14 = ( ( ( $0 ) ) + 172 | 0 ) ; $15 = ( $1 | 0 ) == ( 0 | 0 ) ; $16 = ( ( ( $0 ) ) + 24 | 0 ) ; $17 = ( ( ( $0 ) ) + 28 | 0 ) ; while ( 1 ) { $18 = ( _png_read_chunk_header ( $0 ) | 0 ) ; $19 = HEAP32 [ $14 >> 2 ] | 0 ; $cond = ( $19 | 0 ) == ( 1229209940 ) ; L13 : do { if ( $cond ) { label = 12 ; } else { $20 = HEAP32 [ $16 >> 2 ] | 0 ; $21 = $20 | 8192 ; HEAP32 [ $16 >> 2 ] = $21 ; $switch$split2D = ( $19 | 0 ) < ( 1229472850 ) ; if ( $switch$split2D ) { switch ( $19 | 0 ) { case 1229278788 : { break ; } default : { label = 12 ; break L13 ; } } _png_handle_IEND ( $0 , $1 , $18 ) ; break ; } else { switch ( $19 | 0 ) { case 1229472850 : { break ; } default : { label = 12 ; break L13 ; } } _png_handle_IHDR ( $0 , $1 , $18 ) ; break ; } } } while ( 0 ) ; L20 : do { if ( ( label | 0 ) == 12 ) { label = 0 ; if ( $15 ) { ( _png_crc_finish ( $0 , $18 ) | 0 ) ; break ; } $22 = ( _png_chunk_unknown_handling ( $0 , $19 ) | 0 ) ; $23 = ( $22 | 0 ) == ( 0 ) ; if ( ! ( $23 ) ) { if ( ! ( $cond ) ) { _png_handle_unknown ( $0 , $1 , $18 , $22 ) ; $31 = ( $19 | 0 ) == ( 1347179589 ) ; if ( ! ( $31 ) ) { break ; } $32 = HEAP32 [ $16 >> 2 ] | 0 ; $33 = $32 | 2 ; HEAP32 [ $16 >> 2 ] = $33 ; break ; } $24 = ( $18 | 0 ) == ( 0 ) ; if ( $24 ) { label = 18 ; } else { $25 = HEAP32 [ $17 >> 2 ] | 0 ; $26 = $25 & 8 ; $27 = ( $26 | 0 ) == ( 0 ) ; if ( $27 ) { label = 19 ; } else { label = 18 ; } } if ( ( label | 0 ) == 18 ) { label = 0 ; $28 = HEAP32 [ $16 >> 2 ] | 0 ; $29 = $28 & 8192 ; $30 = ( $29 | 0 ) == ( 0 ) ; if ( ! ( $30 ) ) { label = 19 ; } } if ( ( label | 0 ) == 19 ) { label = 0 ; _png_benign_error ( $0 , 24850 ) ; } _png_handle_unknown ( $0 , $1 , $18 , $22 ) ; break ; } if ( $cond ) { $34 = ( $18 | 0 ) == ( 0 ) ; if ( $34 ) { label = 26 ; } else { $35 = HEAP32 [ $17 >> 2 ] | 0 ; $36 = $35 & 8 ; $37 = ( $36 | 0 ) == ( 0 ) ; if ( $37 ) { label = 27 ; } else { label = 26 ; } } if ( ( label | 0 ) == 26 ) { label = 0 ; $38 = HEAP32 [ $16 >> 2 ] | 0 ; $39 = $38 & 8192 ; $40 = ( $39 | 0 ) == ( 0 ) ; if ( ! ( $40 ) ) { label = 27 ; } } if ( ( label | 0 ) == 27 ) { label = 0 ; _png_benign_error ( $0 , 24872 ) ; } ( _png_crc_finish ( $0 , $18 ) | 0 ) ; break ; } $switch$split12D = ( $19 | 0 ) < ( 1749635924 ) ; L49 : do { if ( $switch$split12D ) { $switch$split42D = ( $19 | 0 ) < ( 1649100612 ) ; if ( $switch$split42D ) { switch ( $19 | 0 ) { case 1347179589 : { break ; } default : { break L49 ; } } _png_handle_PLTE ( $0 , $1 , $18 ) ; break L20 ; } else { switch ( $19 | 0 ) { case 1649100612 : { break ; } default : { break L49 ; } } _png_handle_bKGD ( $0 , $1 , $18 ) ; break L20 ; } } else { $switch$split72D = ( $19 | 0 ) < ( 1933723988 ) ; if ( $switch$split72D ) { switch ( $19 | 0 ) { case 1749635924 : { break ; } default : { break L49 ; } } _png_handle_hIST ( $0 , $1 , $18 ) ; break L20 ; } $switch$split102D = ( $19 | 0 ) < ( 1951551059 ) ; if ( $switch$split102D ) { switch ( $19 | 0 ) { case 1933723988 : { break ; } default : { break L49 ; } } _png_handle_sBIT ( $0 , $1 , $18 ) ; break L20 ; } else { switch ( $19 | 0 ) { case 1951551059 : { break ; } default : { break L49 ; } } _png_handle_tRNS ( $0 , $1 , $18 ) ; break L20 ; } } } while ( 0 ) ; _png_handle_unknown ( $0 , $1 , $18 , 0 ) ; } } while ( 0 ) ; $41 = HEAP32 [ $16 >> 2 ] | 0 ; $42 = $41 & 16 ; $43 = ( $42 | 0 ) == ( 0 ) ; if ( ! ( $43 ) ) { break ; } } return ; } function _png_destroy_read_struct ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$pre$i = 0 , $$pre26$i = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 ; var $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $3 ) { return ; } $4 = HEAP32 [ $0 >> 2 ] | 0 ; $5 = ( $4 | 0 ) == ( 0 | 0 ) ; if ( $5 ) { return ; } _png_destroy_info_struct ( $4 , $2 ) ; _png_destroy_info_struct ( $4 , $1 ) ; HEAP32 [ $0 >> 2 ] = 0 ; $6 = ( ( ( $4 ) ) + 312 | 0 ) ; $7 = HEAP32 [ $6 >> 2 ] | 0 ; _png_free ( $4 , $7 ) ; HEAP32 [ $6 >> 2 ] = 0 ; $8 = ( ( ( $4 ) ) + 376 | 0 ) ; $9 = HEAP32 [ $8 >> 2 ] | 0 ; _png_free ( $4 , $9 ) ; HEAP32 [ $8 >> 2 ] = 0 ; $10 = ( ( ( $4 ) ) + 360 | 0 ) ; $11 = HEAP32 [ $10 >> 2 ] | 0 ; _png_free ( $4 , $11 ) ; HEAP32 [ $10 >> 2 ] = 0 ; $12 = ( ( ( $4 ) ) + 296 | 0 ) ; $13 = HEAP32 [ $12 >> 2 ] | 0 ; $14 = $13 & 4096 ; $15 = ( $14 | 0 ) == ( 0 ) ; if ( $15 ) { $19 = $13 ; } else { $16 = ( ( ( $4 ) ) + 204 | 0 ) ; $17 = HEAP32 [ $16 >> 2 ] | 0 ; _png_zfree ( $4 , $17 ) ; HEAP32 [ $16 >> 2 ] = 0 ; $$pre$i = HEAP32 [ $12 >> 2 ] | 0 ; $19 = $$pre$i ; } $18 = $19 & - 4097 ; HEAP32 [ $12 >> 2 ] = $18 ; $20 = $19 & 8192 ; $21 = ( $20 | 0 ) == ( 0 ) ; if ( $21 ) { $25 = $18 ; } else { $22 = ( ( ( $4 ) ) + 272 | 0 ) ; $23 = HEAP32 [ $22 >> 2 ] | 0 ; _png_free ( $4 , $23 ) ; HEAP32 [ $22 >> 2 ] = 0 ; $$pre26$i = HEAP32 [ $12 >> 2 ] | 0 ; $25 = $$pre26$i ; } $24 = $25 & - 8193 ; HEAP32 [ $12 >> 2 ] = $24 ; $26 = ( ( ( $4 ) ) + 40 | 0 ) ; ( _inflateEnd ( $26 ) | 0 ) ; $27 = ( ( ( $4 ) ) + 344 | 0 ) ; $28 = HEAP32 [ $27 >> 2 ] | 0 ; _png_free ( $4 , $28 ) ; HEAP32 [ $27 >> 2 ] = 0 ; $29 = ( ( ( $4 ) ) + 308 | 0 ) ; $30 = HEAP32 [ $29 >> 2 ] | 0 ; _png_free ( $4 , $30 ) ; HEAP32 [ $29 >> 2 ] = 0 ; _png_destroy_png_struct ( $4 ) ; return ; } function _png_read_png ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $$162 = 0 , $$pre = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 ; var $28 = 0 , $29 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 ; var $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 ; var $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $4 = ( $0 | 0 ) == ( 0 | 0 ) ; $5 = ( $1 | 0 ) == ( 0 | 0 ) ; $or$cond = $4 | $5 ; if ( $or$cond ) { return ; } _png_read_info ( $0 , $1 ) ; $6 = ( ( ( $1 ) ) + 4 | 0 ) ; $7 = HEAP32 [ $6 >> 2 ] | 0 ; $8 = ( $7 >>> 0 ) > ( 1073741823 ) ; if ( $8 ) { _png_error ( $0 , 24895 ) ; // unreachable; } $9 = $2 & 32768 ; $10 = ( $9 | 0 ) == ( 0 ) ; if ( ! ( $10 ) ) { _png_app_error ( $0 , 24944 ) ; } $11 = $2 & 1 ; $12 = ( $11 | 0 ) == ( 0 ) ; if ( ! ( $12 ) ) { _png_app_error ( $0 , 24981 ) ; } $13 = $2 & 2 ; $14 = ( $13 | 0 ) == ( 0 ) ; if ( ! ( $14 ) ) { _png_app_error ( $0 , 25018 ) ; } $15 = $2 & 4 ; $16 = ( $15 | 0 ) == ( 0 ) ; if ( ! ( $16 ) ) { _png_app_error ( $0 , 27174 ) ; } $17 = $2 & 8 ; $18 = ( $17 | 0 ) == ( 0 ) ; if ( ! ( $18 ) ) { _png_app_error ( $0 , 27362 ) ; } $19 = $2 & 16 ; $20 = ( $19 | 0 ) == ( 0 ) ; if ( ! ( $20 ) ) { _png_app_error ( $0 , 25058 ) ; } $21 = $2 & 32 ; $22 = ( $21 | 0 ) == ( 0 ) ; if ( ! ( $22 ) ) { _png_app_error ( $0 , 27100 ) ; } $23 = $2 & 64 ; $24 = ( $23 | 0 ) == ( 0 ) ; if ( ! ( $24 ) ) { _png_app_error ( $0 , 27140 ) ; } $25 = $2 & 128 ; $26 = ( $25 | 0 ) == ( 0 ) ; if ( ! ( $26 ) ) { _png_app_error ( $0 , 27290 ) ; } $27 = $2 & 256 ; $28 = ( $27 | 0 ) == ( 0 ) ; if ( ! ( $28 ) ) { _png_app_error ( $0 , 27210 ) ; } $29 = $2 & 512 ; $30 = ( $29 | 0 ) == ( 0 ) ; if ( ! ( $30 ) ) { _png_app_error ( $0 , 27322 ) ; } $31 = $2 & 1024 ; $32 = ( $31 | 0 ) == ( 0 ) ; if ( ! ( $32 ) ) { _png_app_error ( $0 , 27399 ) ; } $33 = $2 & 8192 ; $34 = ( $33 | 0 ) == ( 0 ) ; if ( ! ( $34 ) ) { _png_app_error ( $0 , 25093 ) ; } $35 = $2 & 16384 ; $36 = ( $35 | 0 ) == ( 0 ) ; if ( ! ( $36 ) ) { _png_app_error ( $0 , 25133 ) ; } ( _png_set_interlace_handling ( $0 ) | 0 ) ; $37 = ( ( ( $0 ) ) + 28 | 0 ) ; $38 = HEAP32 [ $37 >> 2 ] | 0 ; $39 = $38 & 64 ; $40 = ( $39 | 0 ) == ( 0 ) ; if ( $40 ) { _png_read_start_row ( $0 ) ; _png_read_transform_info ( $0 , $1 ) ; } else { _png_app_error ( $0 , 24498 ) ; } _png_free_data ( $0 , $1 , 64 , 0 ) ; $41 = ( ( ( $1 ) ) + 88 | 0 ) ; $42 = HEAP32 [ $41 >> 2 ] | 0 ; $43 = ( $42 | 0 ) == ( 0 | 0 ) ; do { if ( $43 ) { $44 = HEAP32 [ $6 >> 2 ] | 0 ; $45 = $44 << 2 ; $46 = ( _png_malloc ( $0 , $45 ) | 0 ) ; HEAP32 [ $41 >> 2 ] = $46 ; $47 = HEAP32 [ $6 >> 2 ] | 0 ; $48 = ( $47 | 0 ) == ( 0 ) ; if ( $48 ) { $49 = ( ( ( $1 ) ) + 76 | 0 ) ; $50 = HEAP32 [ $49 >> 2 ] | 0 ; $51 = $50 | 64 ; HEAP32 [ $49 >> 2 ] = $51 ; break ; } HEAP32 [ $46 >> 2 ] = 0 ; $52 = ( $47 | 0 ) == ( 1 ) ; if ( ! ( $52 ) ) { $54 = 1 ; while ( 1 ) { $$pre = HEAP32 [ $41 >> 2 ] | 0 ; $53 = ( ( $$pre ) + ( $54 << 2 ) | 0 ) ; HEAP32 [ $53 >> 2 ] = 0 ; $55 = ( ( $54 ) + 1 ) | 0 ; $56 = ( $55 >>> 0 ) < ( $47 >>> 0 ) ; if ( $56 ) { $54 = $55 ; } else { break ; } } } $57 = ( ( ( $1 ) ) + 76 | 0 ) ; $58 = HEAP32 [ $57 >> 2 ] | 0 ; $59 = $58 | 64 ; HEAP32 [ $57 >> 2 ] = $59 ; $60 = ( ( ( $1 ) ) + 12 | 0 ) ; $$162 = 0 ; while ( 1 ) { $61 = HEAP32 [ $60 >> 2 ] | 0 ; $62 = ( _png_malloc ( $0 , $61 ) | 0 ) ; $63 = HEAP32 [ $41 >> 2 ] | 0 ; $64 = ( ( $63 ) + ( $$162 << 2 ) | 0 ) ; HEAP32 [ $64 >> 2 ] = $62 ; $65 = ( ( $$162 ) + 1 ) | 0 ; $66 = HEAP32 [ $6 >> 2 ] | 0 ; $67 = ( $65 >>> 0 ) < ( $66 >>> 0 ) ; if ( $67 ) { $$162 = $65 ; } else { break ; } } } } while ( 0 ) ; $68 = HEAP32 [ $41 >> 2 ] | 0 ; _png_read_image ( $0 , $68 ) ; $69 = ( ( ( $1 ) ) + 8 | 0 ) ; $70 = HEAP32 [ $69 >> 2 ] | 0 ; $71 = $70 | 32768 ; HEAP32 [ $69 >> 2 ] = $71 ; _png_read_end ( $0 , $1 ) ; return ; } function _png_read_data ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $3 = 0 , $4 = 0 , $5 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( ( ( $0 ) ) + 16 | 0 ) ; $4 = HEAP32 [ $3 >> 2 ] | 0 ; $5 = ( $4 | 0 ) == ( 0 | 0 ) ; if ( $5 ) { _png_error ( $0 , 25171 ) ; // unreachable; } else { FUNCTION_TABLE_viii [ $4 & 127 ] ( $0 , $1 , $2 ) ; return ; } } function _png_default_read_data ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $3 ) { return ; } $4 = ( ( ( $0 ) ) + 20 | 0 ) ; $5 = HEAP32 [ $4 >> 2 ] | 0 ; $6 = ( _fread ( $1 , 1 , $2 , $5 ) | 0 ) ; $7 = ( $6 | 0 ) == ( $2 | 0 ) ; if ( $7 ) { return ; } else { _png_error ( $0 , 25198 ) ; // unreachable; } } function _png_set_read_fn ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $png_default_read_data$sink = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $3 ) { return ; } $4 = ( ( ( $0 ) ) + 20 | 0 ) ; HEAP32 [ $4 >> 2 ] = $1 ; $5 = ( $2 | 0 ) != ( 0 | 0 ) ; $png_default_read_data$sink = $5 ? $2 : 94 ; $6 = ( ( ( $0 ) ) + 16 | 0 ) ; HEAP32 [ $6 >> 2 ] = $png_default_read_data$sink ; $7 = ( ( ( $0 ) ) + 12 | 0 ) ; $8 = HEAP32 [ $7 >> 2 ] | 0 ; $9 = ( $8 | 0 ) == ( 0 | 0 ) ; if ( ! ( $9 ) ) { HEAP32 [ $7 >> 2 ] = 0 ; _png_warning ( $0 , 26543 ) ; } $10 = ( ( ( $0 ) ) + 252 | 0 ) ; HEAP32 [ $10 >> 2 ] = 0 ; return ; } function _png_init_read_transformations ( $0 ) { $0 = $0 | 0 ; var $$01723$i = 0 , $$024$i = 0 , $$1$i = 0 , $$3$ph$i = 0 , $$lobit$i = 0 , $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 ; var $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond$i = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( ( ( $0 ) ) + 223 | 0 ) ; $2 = HEAP8 [ $1 >> 0 ] | 0 ; $3 = ( $2 << 24 >> 24 ) == ( 3 ) ; if ( ! ( $3 ) ) { $$lobit$i = $2 & 4 ; $22 = ( ( ( $0 ) ) + 216 | 0 ) ; $23 = HEAP16 [ $22 >> 1 ] | 0 ; $24 = ( $23 << 16 >> 16 ) == ( 0 ) ; $25 = ( $$lobit$i << 24 >> 24 ) == ( 0 ) ; $or$cond$i = $25 & $24 ; if ( ! ( $or$cond$i ) ) { return ; } $26 = ( ( ( $0 ) ) + 32 | 0 ) ; $27 = HEAP32 [ $26 >> 2 ] | 0 ; $28 = $27 & - 385 ; HEAP32 [ $26 >> 2 ] = $28 ; return ; } $4 = ( ( ( $0 ) ) + 216 | 0 ) ; $5 = HEAP16 [ $4 >> 1 ] | 0 ; $6 = ( $5 << 16 >> 16 ) == ( 0 ) ; L8 : do { if ( $6 ) { $$3$ph$i = 0 ; } else { $7 = ( ( ( $0 ) ) + 272 | 0 ) ; $8 = HEAP32 [ $7 >> 2 ] | 0 ; $9 = $5 & 65535 ; $$01723$i = 0 ; $$024$i = 0 ; L10 : while ( 1 ) { $10 = ( ( $8 ) + ( $$024$i ) | 0 ) ; $11 = HEAP8 [ $10 >> 0 ] | 0 ; switch ( $11 << 24 >> 24 ) { case - 1 : { $$1$i = $$01723$i ; break ; } case 0 : { $$1$i = 1 ; break ; } default : { break L10 ; } } $12 = ( ( $$024$i ) + 1 ) | 0 ; $13 = ( $12 | 0 ) < ( $9 | 0 ) ; if ( $13 ) { $$01723$i = $$1$i ; $$024$i = $12 ; } else { $$3$ph$i = $$1$i ; break L8 ; } } return ; } } while ( 0 ) ; $14 = ( ( ( $0 ) ) + 32 | 0 ) ; $15 = HEAP32 [ $14 >> 2 ] | 0 ; $16 = $15 & - 8388609 ; HEAP32 [ $14 >> 2 ] = $16 ; $17 = ( ( ( $0 ) ) + 28 | 0 ) ; $18 = HEAP32 [ $17 >> 2 ] | 0 ; $19 = $18 & - 8193 ; HEAP32 [ $17 >> 2 ] = $19 ; $20 = ( $$3$ph$i | 0 ) == ( 0 ) ; if ( ! ( $20 ) ) { return ; } $21 = $15 & - 8388993 ; HEAP32 [ $14 >> 2 ] = $21 ; return ; } function _png_read_transform_info ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$ = 0 , $$16 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 ; var $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $storemerge = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( ( ( $1 ) ) + 24 | 0 ) ; $3 = ( ( ( $1 ) ) + 25 | 0 ) ; $4 = HEAP8 [ $3 >> 0 ] | 0 ; $5 = ( $4 << 24 >> 24 ) == ( 3 ) ; if ( $5 ) { $13 = 1 ; $storemerge = 1 ; } else { $6 = $4 & 2 ; $7 = $6 | 1 ; $8 = $4 & 4 ; $9 = ( $8 << 24 >> 24 ) == ( 0 ) ; $10 = ( ( $7 ) + 1 ) << 24 >> 24 ; $$ = $9 ? $7 : $10 ; $$16 = $9 ? $7 : $10 ; $13 = $$16 ; $storemerge = $$ ; } $11 = ( ( ( $1 ) ) + 29 | 0 ) ; HEAP8 [ $11 >> 0 ] = $storemerge ; $12 = $13 & 255 ; $14 = HEAP8 [ $2 >> 0 ] | 0 ; $15 = $14 & 255 ; $16 = Math_imul ( $15 , $12 ) | 0 ; $17 = $16 & 255 ; $18 = ( ( ( $1 ) ) + 30 | 0 ) ; HEAP8 [ $18 >> 0 ] = $17 ; $19 = $16 & 255 ; $20 = ( $19 >>> 0 ) > ( 7 ) ; $21 = HEAP32 [ $1 >> 2 ] | 0 ; if ( $20 ) { $22 = $19 >>> 3 ; $23 = Math_imul ( $22 , $21 ) | 0 ; $28 = $23 ; $27 = ( ( ( $1 ) ) + 12 | 0 ) ; HEAP32 [ $27 >> 2 ] = $28 ; $29 = ( ( ( $0 ) ) + 192 | 0 ) ; HEAP32 [ $29 >> 2 ] = $28 ; return ; } else { $24 = Math_imul ( $19 , $21 ) | 0 ; $25 = ( ( $24 ) + 7 ) | 0 ; $26 = $25 >>> 3 ; $28 = $26 ; $27 = ( ( ( $1 ) ) + 12 | 0 ) ; HEAP32 [ $27 >> 2 ] = $28 ; $29 = ( ( ( $0 ) ) + 192 | 0 ) ; HEAP32 [ $29 >> 2 ] = $28 ; return ; } } function _png_do_read_transformations ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( ( ( $0 ) ) + 180 | 0 ) ; $3 = HEAP32 [ $2 >> 2 ] | 0 ; $4 = ( $3 | 0 ) == ( 0 | 0 ) ; if ( $4 ) { _png_error ( $0 , 25209 ) ; // unreachable; } $5 = ( ( ( $0 ) ) + 28 | 0 ) ; $6 = HEAP32 [ $5 >> 2 ] | 0 ; $7 = $6 & 16448 ; $8 = ( $7 | 0 ) == ( 16384 ) ; if ( $8 ) { _png_error ( $0 , 25225 ) ; // unreachable; } $9 = ( ( ( $1 ) ) + 8 | 0 ) ; $10 = HEAP8 [ $9 >> 0 ] | 0 ; $11 = ( $10 << 24 >> 24 ) == ( 3 ) ; if ( ! ( $11 ) ) { return ; } $12 = ( ( ( $0 ) ) + 212 | 0 ) ; $13 = HEAP32 [ $12 >> 2 ] | 0 ; $14 = ( $13 | 0 ) > ( - 1 ) ; if ( ! ( $14 ) ) { return ; } _png_do_check_palette_indexes ( $0 , $1 ) ; return ; } function _png_read_sig ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( ( ( $0 ) ) + 229 | 0 ) ; $3 = HEAP8 [ $2 >> 0 ] | 0 ; $4 = $3 & 255 ; $5 = ( $3 & 255 ) > ( 7 ) ; if ( $5 ) { return ; } $6 = ( 8 - ( $4 ) ) | 0 ; $7 = ( ( ( $0 ) ) + 372 | 0 ) ; HEAP32 [ $7 >> 2 ] = 17 ; $8 = ( ( ( ( $1 ) ) + 32 | 0 ) + ( $4 ) | 0 ) ; _png_read_data ( $0 , $8 , $6 ) ; HEAP8 [ $2 >> 0 ] = 8 ; $9 = ( ( ( $1 ) ) + 32 | 0 ) ; $10 = ( _png_sig_cmp ( $9 , $4 , $6 ) | 0 ) ; $11 = ( $10 | 0 ) == ( 0 ) ; if ( $11 ) { $16 = ( $3 & 255 ) < ( 3 ) ; if ( ! ( $16 ) ) { return ; } $17 = ( ( ( $0 ) ) + 24 | 0 ) ; $18 = HEAP32 [ $17 >> 2 ] | 0 ; $19 = $18 | 4096 ; HEAP32 [ $17 >> 2 ] = $19 ; return ; } $12 = ( $3 & 255 ) < ( 4 ) ; if ( ! ( $12 ) ) { _png_error ( $0 , 25292 ) ; // unreachable; } $13 = ( ( $6 ) + - 4 ) | 0 ; $14 = ( _png_sig_cmp ( $9 , $4 , $13 ) | 0 ) ; $15 = ( $14 | 0 ) == ( 0 ) ; if ( $15 ) { _png_error ( $0 , 25292 ) ; // unreachable; } else { _png_error ( $0 , 25277 ) ; // unreachable; } } function _png_read_chunk_header ( $0 ) { $0 = $0 | 0 ; var $$0$i = 0 , $$031$i = 0 , $$1$i = 0 , $$off$1$i = 0 , $$off$2$i = 0 , $$off$3$i = 0 , $$off$i = 0 , $$off$i12 = 0 , $$off18$1$i = 0 , $$off18$2$i = 0 , $$off18$3$i = 0 , $$off18$i = 0 , $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 ; var $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 ; var $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 ; var $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 ; var $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 ; var $9 = 0 , $90 = 0 , $91 = 0 , $or$cond$1$i = 0 , $or$cond$2$i = 0 , $or$cond$3$i = 0 , $or$cond$i = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = sp ; $2 = ( ( ( $0 ) ) + 372 | 0 ) ; HEAP32 [ $2 >> 2 ] = 33 ; _png_read_data ( $0 , $1 , 8 ) ; $3 = HEAP8 [ $1 >> 0 ] | 0 ; $4 = $3 & 255 ; $5 = $4 << 24 ; $6 = ( ( ( $1 ) ) + 1 | 0 ) ; $7 = HEAP8 [ $6 >> 0 ] | 0 ; $8 = $7 & 255 ; $9 = $8 << 16 ; $10 = $9 | $5 ; $11 = ( ( ( $1 ) ) + 2 | 0 ) ; $12 = HEAP8 [ $11 >> 0 ] | 0 ; $13 = $12 & 255 ; $14 = $13 << 8 ; $15 = $10 | $14 ; $16 = ( ( ( $1 ) ) + 3 | 0 ) ; $17 = HEAP8 [ $16 >> 0 ] | 0 ; $18 = $17 & 255 ; $19 = $15 | $18 ; $20 = ( $19 | 0 ) < ( 0 ) ; if ( $20 ) { _png_error ( $0 , 25243 ) ; // unreachable; } $21 = ( ( ( $1 ) ) + 4 | 0 ) ; $22 = HEAP8 [ $21 >> 0 ] | 0 ; $23 = $22 & 255 ; $24 = $23 << 24 ; $25 = ( ( ( $1 ) ) + 5 | 0 ) ; $26 = HEAP8 [ $25 >> 0 ] | 0 ; $27 = $26 & 255 ; $28 = $27 << 16 ; $29 = $28 | $24 ; $30 = ( ( ( $1 ) ) + 6 | 0 ) ; $31 = HEAP8 [ $30 >> 0 ] | 0 ; $32 = $31 & 255 ; $33 = $32 << 8 ; $34 = $29 | $33 ; $35 = ( ( ( $1 ) ) + 7 | 0 ) ; $36 = HEAP8 [ $35 >> 0 ] | 0 ; $37 = $36 & 255 ; $38 = $34 | $37 ; $39 = ( ( ( $0 ) ) + 172 | 0 ) ; HEAP32 [ $39 >> 2 ] = $38 ; _png_reset_crc ( $0 ) ; _png_calculate_crc ( $0 , $21 , 4 ) ; $40 = HEAP32 [ $39 >> 2 ] | 0 ; $41 = $40 & 255 ; $$off$i = ( ( $41 ) + - 65 ) | 0 ; $42 = ( $$off$i >>> 0 ) > ( 57 ) ; $$off18$i = ( ( $41 ) + - 91 ) | 0 ; $43 = ( $$off18$i >>> 0 ) < ( 6 ) ; $or$cond$i = $42 | $43 ; if ( $or$cond$i ) { _png_chunk_error ( $0 , 25331 ) ; // unreachable; } $44 = $40 >>> 8 ; $45 = $44 & 255 ; $$off$1$i = ( ( $45 ) + - 65 ) | 0 ; $46 = ( $$off$1$i >>> 0 ) > ( 57 ) ; $$off18$1$i = ( ( $45 ) + - 91 ) | 0 ; $47 = ( $$off18$1$i >>> 0 ) < ( 6 ) ; $or$cond$1$i = $46 | $47 ; if ( $or$cond$1$i ) { _png_chunk_error ( $0 , 25331 ) ; // unreachable; } $48 = $40 >>> 16 ; $49 = $48 & 255 ; $$off$2$i = ( ( $49 ) + - 65 ) | 0 ; $50 = ( $$off$2$i >>> 0 ) > ( 57 ) ; $$off18$2$i = ( ( $49 ) + - 91 ) | 0 ; $51 = ( $$off18$2$i >>> 0 ) < ( 6 ) ; $or$cond$2$i = $50 | $51 ; if ( $or$cond$2$i ) { _png_chunk_error ( $0 , 25331 ) ; // unreachable; } $52 = $40 >>> 24 ; $$off$3$i = ( ( $52 ) + - 65 ) | 0 ; $53 = ( $$off$3$i >>> 0 ) > ( 57 ) ; $$off18$3$i = ( ( $52 ) + - 91 ) | 0 ; $54 = ( $$off18$3$i >>> 0 ) < ( 6 ) ; $or$cond$3$i = $53 | $54 ; if ( $or$cond$3$i ) { _png_chunk_error ( $0 , 25331 ) ; // unreachable; } $55 = ( ( ( $0 ) ) + 332 | 0 ) ; $56 = HEAP32 [ $55 >> 2 ] | 0 ; $$off$i12 = ( ( $56 ) + - 1 ) | 0 ; $57 = ( $$off$i12 >>> 0 ) < ( 2147483646 ) ; $$031$i = $57 ? $56 : 2147483647 ; $58 = ( $40 | 0 ) == ( 1229209940 ) ; if ( $58 ) { $59 = ( ( ( $0 ) ) + 144 | 0 ) ; $60 = HEAP32 [ $59 >> 2 ] | 0 ; $61 = ( ( ( $0 ) ) + 227 | 0 ) ; $62 = HEAP8 [ $61 >> 0 ] | 0 ; $63 = $62 & 255 ; $64 = Math_imul ( $60 , $63 ) | 0 ; $65 = ( ( ( $0 ) ) + 224 | 0 ) ; $66 = HEAP8 [ $65 >> 0 ] | 0 ; $67 = ( $66 & 255 ) > ( 8 ) ; $68 = $67 ? 2 : 1 ; $69 = Math_imul ( $64 , $68 ) | 0 ; $70 = ( ( $69 ) + 1 ) | 0 ; $71 = ( ( ( $0 ) ) + 220 | 0 ) ; $72 = HEAP8 [ $71 >> 0 ] | 0 ; $73 = ( $72 << 24 >> 24 ) != ( 0 ) ; $74 = $73 ? 6 : 0 ; $75 = ( ( $70 ) + ( $74 ) ) | 0 ; $76 = ( ( ( $0 ) ) + 148 | 0 ) ; $77 = HEAP32 [ $76 >> 2 ] | 0 ; $78 = ( 4294967295 / ( $75 >>> 0 ) ) & - 1 ; $79 = ( $77 >>> 0 ) > ( $78 >>> 0 ) ; $80 = Math_imul ( $75 , $77 ) | 0 ; $$0$i = $79 ? 2147483647 : $80 ; $81 = ( $75 >>> 0 ) < ( 32566 ) ; $82 = $81 ? $75 : 32566 ; $83 = ( ( $$0$i >>> 0 ) / ( $82 >>> 0 ) ) & - 1 ; $84 = ( $83 * 5 ) | 0 ; $85 = ( ( $84 ) + 11 ) | 0 ; $86 = ( ( $85 ) + ( $$0$i ) ) | 0 ; $87 = ( $86 >>> 0 ) < ( 2147483647 ) ; $88 = $87 ? $86 : 2147483647 ; $89 = ( $$031$i >>> 0 ) < ( $88 >>> 0 ) ; $90 = $89 ? $88 : $$031$i ; $$1$i = $90 ; } else { $$1$i = $$031$i ; } $91 = ( $$1$i >>> 0 ) < ( $19 >>> 0 ) ; if ( $91 ) { _png_chunk_error ( $0 , 25350 ) ; // unreachable; } else { HEAP32 [ $2 >> 2 ] = 65 ; STACKTOP = sp ; return ( $19 | 0 ) ; } return ( 0 ) | 0 ; } function _png_crc_finish ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$014$ = 0 , $$014$$us = 0 , $$01416 = 0 , $$01416$us = 0 , $$015 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 ; var $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 ; var $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 1040 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 1040 | 0 ) ; $2 = sp + 1024 | 0 ; $3 = sp ; $4 = ( $1 | 0 ) == ( 0 ) ; if ( ! ( $4 ) ) { $5 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $5 ) { $$01416$us = $1 ; while ( 1 ) { $6 = ( $$01416$us >>> 0 ) < ( 1024 ) ; $$014$$us = $6 ? $$01416$us : 1024 ; $7 = ( ( $$01416$us ) - ( $$014$$us ) ) | 0 ; $8 = ( $7 | 0 ) == ( 0 ) ; if ( $8 ) { break ; } else { $$01416$us = $7 ; } } } else { $$01416 = $1 ; while ( 1 ) { $9 = ( $$01416 >>> 0 ) < ( 1024 ) ; $$014$ = $9 ? $$01416 : 1024 ; $10 = ( ( $$01416 ) - ( $$014$ ) ) | 0 ; _png_read_data ( $0 , $3 , $$014$ ) ; _png_calculate_crc ( $0 , $3 , $$014$ ) ; $11 = ( $10 | 0 ) == ( 0 ) ; if ( $11 ) { break ; } else { $$01416 = $10 ; } } } } $12 = ( ( ( $0 ) ) + 172 | 0 ) ; $13 = HEAP32 [ $12 >> 2 ] | 0 ; $14 = $13 & 536870912 ; $15 = ( $14 | 0 ) == ( 0 ) ; $16 = ( ( ( $0 ) ) + 28 | 0 ) ; $17 = HEAP32 [ $16 >> 2 ] | 0 ; if ( $15 ) { $21 = $17 & 2048 ; $22 = ( $21 | 0 ) == ( 0 ) ; $23 = ( ( ( $0 ) ) + 372 | 0 ) ; HEAP32 [ $23 >> 2 ] = 129 ; _png_read_data ( $0 , $2 , 4 ) ; if ( ! ( $22 ) ) { label = 8 ; } } else { $18 = $17 & 768 ; $19 = ( $18 | 0 ) == ( 768 ) ; $20 = ( ( ( $0 ) ) + 372 | 0 ) ; HEAP32 [ $20 >> 2 ] = 129 ; _png_read_data ( $0 , $2 , 4 ) ; if ( $19 ) { label = 8 ; } } if ( ( label | 0 ) == 8 ) { $$015 = 0 ; STACKTOP = sp ; return ( $$015 | 0 ) ; } $24 = HEAP8 [ $2 >> 0 ] | 0 ; $25 = $24 & 255 ; $26 = $25 << 24 ; $27 = ( ( ( $2 ) ) + 1 | 0 ) ; $28 = HEAP8 [ $27 >> 0 ] | 0 ; $29 = $28 & 255 ; $30 = $29 << 16 ; $31 = $30 | $26 ; $32 = ( ( ( $2 ) ) + 2 | 0 ) ; $33 = HEAP8 [ $32 >> 0 ] | 0 ; $34 = $33 & 255 ; $35 = $34 << 8 ; $36 = $31 | $35 ; $37 = ( ( ( $2 ) ) + 3 | 0 ) ; $38 = HEAP8 [ $37 >> 0 ] | 0 ; $39 = $38 & 255 ; $40 = $36 | $39 ; $41 = ( ( ( $0 ) ) + 200 | 0 ) ; $42 = HEAP32 [ $41 >> 2 ] | 0 ; $43 = ( $40 | 0 ) == ( $42 | 0 ) ; if ( $43 ) { $$015 = 0 ; STACKTOP = sp ; return ( $$015 | 0 ) ; } $44 = HEAP32 [ $12 >> 2 ] | 0 ; $45 = $44 & 536870912 ; $46 = ( $45 | 0 ) == ( 0 ) ; $47 = HEAP32 [ $16 >> 2 ] | 0 ; if ( $46 ) { $50 = $47 & 1024 ; $51 = ( $50 | 0 ) == ( 0 ) ; if ( $51 ) { _png_chunk_error ( $0 , 25374 ) ; // unreachable; } } else { $48 = $47 & 512 ; $49 = ( $48 | 0 ) == ( 0 ) ; if ( ! ( $49 ) ) { _png_chunk_error ( $0 , 25374 ) ; // unreachable; } } _png_chunk_warning ( $0 , 25374 ) ; $$015 = 1 ; STACKTOP = sp ; return ( $$015 | 0 ) ; } function _png_handle_IHDR ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$sink = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 ; var $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 ; var $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 ; var $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $9 = 0 ; var label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $3 = sp ; $4 = ( ( ( $0 ) ) + 24 | 0 ) ; $5 = HEAP32 [ $4 >> 2 ] | 0 ; $6 = $5 & 1 ; $7 = ( $6 | 0 ) == ( 0 ) ; if ( ! ( $7 ) ) { _png_chunk_error ( $0 , 25413 ) ; // unreachable; } $8 = ( $2 | 0 ) == ( 13 ) ; if ( ! ( $8 ) ) { _png_chunk_error ( $0 , 25426 ) ; // unreachable; } $9 = $5 | 1 ; HEAP32 [ $4 >> 2 ] = $9 ; _png_read_data ( $0 , $3 , 13 ) ; _png_calculate_crc ( $0 , $3 , 13 ) ; ( _png_crc_finish ( $0 , 0 ) | 0 ) ; $10 = HEAP8 [ $3 >> 0 ] | 0 ; $11 = $10 & 255 ; $12 = $11 << 24 ; $13 = ( ( ( $3 ) ) + 1 | 0 ) ; $14 = HEAP8 [ $13 >> 0 ] | 0 ; $15 = $14 & 255 ; $16 = $15 << 16 ; $17 = $16 | $12 ; $18 = ( ( ( $3 ) ) + 2 | 0 ) ; $19 = HEAP8 [ $18 >> 0 ] | 0 ; $20 = $19 & 255 ; $21 = $20 << 8 ; $22 = $17 | $21 ; $23 = ( ( ( $3 ) ) + 3 | 0 ) ; $24 = HEAP8 [ $23 >> 0 ] | 0 ; $25 = $24 & 255 ; $26 = $22 | $25 ; $27 = ( $26 | 0 ) < ( 0 ) ; if ( $27 ) { _png_error ( $0 , 25243 ) ; // unreachable; } $28 = ( ( ( $3 ) ) + 4 | 0 ) ; $29 = HEAP8 [ $28 >> 0 ] | 0 ; $30 = $29 & 255 ; $31 = $30 << 24 ; $32 = ( ( ( $3 ) ) + 5 | 0 ) ; $33 = HEAP8 [ $32 >> 0 ] | 0 ; $34 = $33 & 255 ; $35 = $34 << 16 ; $36 = $35 | $31 ; $37 = ( ( ( $3 ) ) + 6 | 0 ) ; $38 = HEAP8 [ $37 >> 0 ] | 0 ; $39 = $38 & 255 ; $40 = $39 << 8 ; $41 = $36 | $40 ; $42 = ( ( ( $3 ) ) + 7 | 0 ) ; $43 = HEAP8 [ $42 >> 0 ] | 0 ; $44 = $43 & 255 ; $45 = $41 | $44 ; $46 = ( $45 | 0 ) < ( 0 ) ; if ( $46 ) { _png_error ( $0 , 25243 ) ; // unreachable; } $47 = ( ( ( $3 ) ) + 8 | 0 ) ; $48 = HEAP8 [ $47 >> 0 ] | 0 ; $49 = $48 & 255 ; $50 = ( ( ( $3 ) ) + 9 | 0 ) ; $51 = HEAP8 [ $50 >> 0 ] | 0 ; $52 = $51 & 255 ; $53 = ( ( ( $3 ) ) + 10 | 0 ) ; $54 = HEAP8 [ $53 >> 0 ] | 0 ; $55 = $54 & 255 ; $56 = ( ( ( $3 ) ) + 11 | 0 ) ; $57 = HEAP8 [ $56 >> 0 ] | 0 ; $58 = $57 & 255 ; $59 = ( ( ( $3 ) ) + 12 | 0 ) ; $60 = HEAP8 [ $59 >> 0 ] | 0 ; $61 = $60 & 255 ; $62 = ( ( ( $0 ) ) + 144 | 0 ) ; HEAP32 [ $62 >> 2 ] = $26 ; $63 = ( ( ( $0 ) ) + 148 | 0 ) ; HEAP32 [ $63 >> 2 ] = $45 ; $64 = ( ( ( $0 ) ) + 224 | 0 ) ; HEAP8 [ $64 >> 0 ] = $48 ; $65 = ( ( ( $0 ) ) + 220 | 0 ) ; HEAP8 [ $65 >> 0 ] = $60 ; $66 = ( ( ( $0 ) ) + 223 | 0 ) ; HEAP8 [ $66 >> 0 ] = $51 ; $67 = ( ( ( $0 ) ) + 316 | 0 ) ; HEAP8 [ $67 >> 0 ] = $54 ; switch ( $51 << 24 >> 24 ) { case 6 : { $$sink = 4 ; break ; } case 4 : { $$sink = 2 ; break ; } case 2 : { $$sink = 3 ; break ; } default : { $$sink = 1 ; } } $68 = ( ( ( $0 ) ) + 227 | 0 ) ; HEAP8 [ $68 >> 0 ] = $$sink ; $69 = $$sink & 255 ; $70 = Math_imul ( $49 , $69 ) | 0 ; $71 = $70 & 255 ; $72 = ( ( ( $0 ) ) + 226 | 0 ) ; HEAP8 [ $72 >> 0 ] = $71 ; $73 = $70 & 255 ; $74 = ( $73 >>> 0 ) > ( 7 ) ; if ( $74 ) { $75 = $73 >>> 3 ; $76 = Math_imul ( $75 , $26 ) | 0 ; $81 = $76 ; $80 = ( ( ( $0 ) ) + 160 | 0 ) ; HEAP32 [ $80 >> 2 ] = $81 ; _png_set_IHDR ( $0 , $1 , $26 , $45 , $49 , $52 , $61 , $55 , $58 ) ; STACKTOP = sp ; return ; } else { $77 = Math_imul ( $73 , $26 ) | 0 ; $78 = ( ( $77 ) + 7 ) | 0 ; $79 = $78 >>> 3 ; $81 = $79 ; $80 = ( ( ( $0 ) ) + 160 | 0 ) ; HEAP32 [ $80 >> 2 ] = $81 ; _png_set_IHDR ( $0 , $1 , $26 , $45 , $49 , $52 , $61 , $55 , $58 ) ; STACKTOP = sp ; return ; } } function _png_handle_PLTE ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$05562 = 0 , $$057 = 0 , $$057$ = 0 , $$063 = 0 , $$phi$trans$insert$pre$phiZZZZ2D = 0 , $$pre$phiZ2D = 0 , $$pre65 = 0 , $$pre66 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 ; var $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 ; var $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 ; var $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 784 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 784 | 0 ) ; $3 = sp + 8 | 0 ; $4 = sp ; $5 = ( ( ( $0 ) ) + 24 | 0 ) ; $6 = HEAP32 [ $5 >> 2 ] | 0 ; $7 = $6 & 1 ; $8 = ( $7 | 0 ) == ( 0 ) ; if ( $8 ) { _png_chunk_error ( $0 , 25434 ) ; // unreachable; } $9 = $6 & 2 ; $10 = ( $9 | 0 ) == ( 0 ) ; if ( ! ( $10 ) ) { _png_chunk_error ( $0 , 25447 ) ; // unreachable; } $11 = $6 & 4 ; $12 = ( $11 | 0 ) == ( 0 ) ; if ( ! ( $12 ) ) { ( _png_crc_finish ( $0 , $2 ) | 0 ) ; _png_chunk_benign_error ( $0 , 25413 ) ; STACKTOP = sp ; return ; } $13 = $6 | 2 ; HEAP32 [ $5 >> 2 ] = $13 ; $14 = ( ( ( $0 ) ) + 223 | 0 ) ; $15 = HEAP8 [ $14 >> 0 ] | 0 ; $16 = $15 & 2 ; $17 = ( $16 << 24 >> 24 ) == ( 0 ) ; if ( $17 ) { ( _png_crc_finish ( $0 , $2 ) | 0 ) ; _png_chunk_benign_error ( $0 , 25457 ) ; STACKTOP = sp ; return ; } $18 = ( $2 >>> 0 ) < ( 769 ) ; $19 = ( ( $2 >>> 0 ) % 3 ) & - 1 ; $20 = ( $19 | 0 ) == ( 0 ) ; $or$cond = $18 & $20 ; if ( ! ( $or$cond ) ) { ( _png_crc_finish ( $0 , $2 ) | 0 ) ; $21 = HEAP8 [ $14 >> 0 ] | 0 ; $22 = ( $21 << 24 >> 24 ) == ( 3 ) ; if ( $22 ) { _png_chunk_error ( $0 , 25426 ) ; // unreachable; } _png_chunk_benign_error ( $0 , 25426 ) ; STACKTOP = sp ; return ; } $23 = ( ( $2 >>> 0 ) / 3 ) & - 1 ; $24 = ( $15 << 24 >> 24 ) == ( 3 ) ; if ( $24 ) { $25 = ( ( ( $0 ) ) + 224 | 0 ) ; $26 = HEAP8 [ $25 >> 0 ] | 0 ; $27 = $26 & 255 ; $28 = 1 << $27 ; $$057 = $28 ; } else { $$057 = 256 ; } $29 = ( $23 | 0 ) > ( $$057 | 0 ) ; $$057$ = $29 ? $$057 : $23 ; $30 = ( $$057$ | 0 ) > ( 0 ) ; if ( $30 ) { $31 = ( ( ( $4 ) ) + 1 | 0 ) ; $32 = ( ( ( $4 ) ) + 2 | 0 ) ; $$05562 = 0 ; $$063 = $3 ; while ( 1 ) { _png_read_data ( $0 , $4 , 3 ) ; _png_calculate_crc ( $0 , $4 , 3 ) ; $33 = HEAP8 [ $4 >> 0 ] | 0 ; HEAP8 [ $$063 >> 0 ] = $33 ; $34 = HEAP8 [ $31 >> 0 ] | 0 ; $35 = ( ( ( $$063 ) ) + 1 | 0 ) ; HEAP8 [ $35 >> 0 ] = $34 ; $36 = HEAP8 [ $32 >> 0 ] | 0 ; $37 = ( ( ( $$063 ) ) + 2 | 0 ) ; HEAP8 [ $37 >> 0 ] = $36 ; $38 = ( ( $$05562 ) + 1 ) | 0 ; $39 = ( ( ( $$063 ) ) + 3 | 0 ) ; $40 = ( $38 | 0 ) < ( $$057$ | 0 ) ; if ( $40 ) { $$05562 = $38 ; $$063 = $39 ; } else { break ; } } } $41 = Math_imul ( $$057$ , - 3 ) | 0 ; $42 = ( ( $41 ) + ( $2 ) ) | 0 ; ( _png_crc_finish ( $0 , $42 ) | 0 ) ; _png_set_PLTE ( $0 , $1 , $3 , $$057$ ) ; $43 = ( ( ( $0 ) ) + 216 | 0 ) ; $44 = HEAP16 [ $43 >> 1 ] | 0 ; $45 = ( $44 << 16 >> 16 ) == ( 0 ) ; do { if ( $45 ) { $46 = ( $1 | 0 ) == ( 0 | 0 ) ; if ( $46 ) { STACKTOP = sp ; return ; } $47 = ( ( ( $1 ) ) + 8 | 0 ) ; $48 = HEAP32 [ $47 >> 2 ] | 0 ; $49 = $48 & 16 ; $50 = ( $49 | 0 ) == ( 0 ) ; if ( $50 ) { $$pre$phiZ2D = $47 ; $54 = $48 ; } else { HEAP16 [ $43 >> 1 ] = 0 ; $$phi$trans$insert$pre$phiZZZZ2D = $47 ; label = 24 ; } } else { HEAP16 [ $43 >> 1 ] = 0 ; $51 = ( $1 | 0 ) == ( 0 | 0 ) ; if ( ! ( $51 ) ) { $$pre66 = ( ( ( $1 ) ) + 8 | 0 ) ; $$phi$trans$insert$pre$phiZZZZ2D = $$pre66 ; label = 24 ; break ; } _png_chunk_benign_error ( $0 , 25482 ) ; STACKTOP = sp ; return ; } } while ( 0 ) ; if ( ( label | 0 ) == 24 ) { $52 = ( ( ( $1 ) ) + 22 | 0 ) ; HEAP16 [ $52 >> 1 ] = 0 ; _png_chunk_benign_error ( $0 , 25482 ) ; $$pre65 = HEAP32 [ $$phi$trans$insert$pre$phiZZZZ2D >> 2 ] | 0 ; $$pre$phiZ2D = $$phi$trans$insert$pre$phiZZZZ2D ; $54 = $$pre65 ; } $53 = $54 & 64 ; $55 = ( $53 | 0 ) == ( 0 ) ; if ( ! ( $55 ) ) { _png_chunk_benign_error ( $0 , 25501 ) ; } $56 = HEAP32 [ $$pre$phiZ2D >> 2 ] | 0 ; $57 = $56 & 32 ; $58 = ( $57 | 0 ) == ( 0 ) ; if ( $58 ) { STACKTOP = sp ; return ; } _png_chunk_benign_error ( $0 , 25520 ) ; STACKTOP = sp ; return ; } function _png_handle_IEND ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( ( ( $0 ) ) + 24 | 0 ) ; $4 = HEAP32 [ $3 >> 2 ] | 0 ; $5 = $4 & 5 ; $6 = ( $5 | 0 ) == ( 5 ) ; if ( ! ( $6 ) ) { _png_chunk_error ( $0 , 25413 ) ; // unreachable; } $7 = $4 | 24 ; HEAP32 [ $3 >> 2 ] = $7 ; ( _png_crc_finish ( $0 , $2 ) | 0 ) ; $8 = ( $2 | 0 ) == ( 0 ) ; if ( $8 ) { return ; } _png_chunk_benign_error ( $0 , 25426 ) ; return ; } function _png_handle_sBIT ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$0 = 0 , $$04853 = 0 , $$049 = 0 , $$sink = 0 , $$sink51 = 0 , $$sink54 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 ; var $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 ; var $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $3 = sp ; $4 = ( ( ( $0 ) ) + 24 | 0 ) ; $5 = HEAP32 [ $4 >> 2 ] | 0 ; $6 = $5 & 1 ; $7 = ( $6 | 0 ) == ( 0 ) ; if ( $7 ) { _png_chunk_error ( $0 , 25434 ) ; // unreachable; } $8 = $5 & 6 ; $9 = ( $8 | 0 ) == ( 0 ) ; if ( ! ( $9 ) ) { ( _png_crc_finish ( $0 , $2 ) | 0 ) ; _png_chunk_benign_error ( $0 , 25413 ) ; STACKTOP = sp ; return ; } $10 = ( $1 | 0 ) == ( 0 | 0 ) ; if ( ! ( $10 ) ) { $11 = ( ( ( $1 ) ) + 8 | 0 ) ; $12 = HEAP32 [ $11 >> 2 ] | 0 ; $13 = $12 & 2 ; $14 = ( $13 | 0 ) == ( 0 ) ; if ( ! ( $14 ) ) { ( _png_crc_finish ( $0 , $2 ) | 0 ) ; _png_chunk_benign_error ( $0 , 25447 ) ; STACKTOP = sp ; return ; } } $15 = ( ( ( $0 ) ) + 223 | 0 ) ; $16 = HEAP8 [ $15 >> 0 ] | 0 ; $17 = ( $16 << 24 >> 24 ) == ( 3 ) ; if ( $17 ) { $$0 = 8 ; $$049 = 3 ; } else { $18 = ( ( ( $0 ) ) + 227 | 0 ) ; $19 = HEAP8 [ $18 >> 0 ] | 0 ; $20 = $19 & 255 ; $21 = ( ( ( $0 ) ) + 224 | 0 ) ; $22 = HEAP8 [ $21 >> 0 ] | 0 ; $$0 = $22 ; $$049 = $20 ; } $23 = ( $$049 | 0 ) != ( $2 | 0 ) ; $24 = ( $2 >>> 0 ) > ( 4 ) ; $or$cond = $24 | $23 ; if ( $or$cond ) { _png_chunk_benign_error ( $0 , 25426 ) ; ( _png_crc_finish ( $0 , $2 ) | 0 ) ; STACKTOP = sp ; return ; } $25 = ( ( ( $3 ) ) + 3 | 0 ) ; $26 = ( ( ( $3 ) ) + 2 | 0 ) ; $27 = ( ( ( $3 ) ) + 1 | 0 ) ; _memset ( ( $3 | 0 ) , ( $$0 | 0 ) , 4 ) | 0 ; _png_read_data ( $0 , $3 , $2 ) ; _png_calculate_crc ( $0 , $3 , $2 ) ; $28 = ( _png_crc_finish ( $0 , 0 ) | 0 ) ; $29 = ( $28 | 0 ) == ( 0 ) ; if ( ! ( $29 ) ) { STACKTOP = sp ; return ; } $30 = ( $2 | 0 ) == ( 0 ) ; L23 : do { if ( ! ( $30 ) ) { $$04853 = 0 ; while ( 1 ) { $33 = ( ( $3 ) + ( $$04853 ) | 0 ) ; $34 = HEAP8 [ $33 >> 0 ] | 0 ; $35 = ( ( $34 ) + - 1 ) << 24 >> 24 ; $36 = ( $35 & 255 ) < ( $$0 & 255 ) ; $31 = ( ( $$04853 ) + 1 ) | 0 ; if ( ! ( $36 ) ) { break ; } $32 = ( $31 >>> 0 ) < ( $2 >>> 0 ) ; if ( $32 ) { $$04853 = $31 ; } else { break L23 ; } } _png_chunk_benign_error ( $0 , 25426 ) ; STACKTOP = sp ; return ; } } while ( 0 ) ; $37 = HEAP8 [ $15 >> 0 ] | 0 ; $38 = $37 & 2 ; $39 = ( $38 << 24 >> 24 ) == ( 0 ) ; $40 = HEAP8 [ $3 >> 0 ] | 0 ; $41 = ( ( ( $0 ) ) + 264 | 0 ) ; if ( $39 ) { $44 = ( ( ( $0 ) ) + 267 | 0 ) ; HEAP8 [ $44 >> 0 ] = $40 ; $$sink = $40 ; $$sink51 = $27 ; $$sink54 = $40 ; } else { $42 = HEAP8 [ $27 >> 0 ] | 0 ; $43 = HEAP8 [ $26 >> 0 ] | 0 ; $$sink = $43 ; $$sink51 = $25 ; $$sink54 = $42 ; } HEAP8 [ $41 >> 0 ] = $40 ; $45 = ( ( ( $0 ) ) + 265 | 0 ) ; HEAP8 [ $45 >> 0 ] = $$sink54 ; $46 = ( ( ( $0 ) ) + 266 | 0 ) ; HEAP8 [ $46 >> 0 ] = $$sink ; $47 = HEAP8 [ $$sink51 >> 0 ] | 0 ; $48 = ( ( ( $0 ) ) + 268 | 0 ) ; HEAP8 [ $48 >> 0 ] = $47 ; _png_set_sBIT ( $0 , $1 , $41 ) ; STACKTOP = sp ; return ; } function _png_handle_tRNS ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$pre$phiZ2D = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 ; var $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 ; var $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 ; var $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 272 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 272 | 0 ) ; $3 = sp + 8 | 0 ; $4 = sp + 6 | 0 ; $5 = sp ; $6 = ( ( ( $0 ) ) + 24 | 0 ) ; $7 = HEAP32 [ $6 >> 2 ] | 0 ; $8 = $7 & 1 ; $9 = ( $8 | 0 ) == ( 0 ) ; if ( $9 ) { _png_chunk_error ( $0 , 25434 ) ; // unreachable; } $10 = $7 & 4 ; $11 = ( $10 | 0 ) == ( 0 ) ; if ( ! ( $11 ) ) { ( _png_crc_finish ( $0 , $2 ) | 0 ) ; _png_chunk_benign_error ( $0 , 25413 ) ; STACKTOP = sp ; return ; } $12 = ( $1 | 0 ) == ( 0 | 0 ) ; if ( ! ( $12 ) ) { $13 = ( ( ( $1 ) ) + 8 | 0 ) ; $14 = HEAP32 [ $13 >> 2 ] | 0 ; $15 = $14 & 16 ; $16 = ( $15 | 0 ) == ( 0 ) ; if ( ! ( $16 ) ) { ( _png_crc_finish ( $0 , $2 ) | 0 ) ; _png_chunk_benign_error ( $0 , 25447 ) ; STACKTOP = sp ; return ; } } $17 = ( ( ( $0 ) ) + 223 | 0 ) ; $18 = HEAP8 [ $17 >> 0 ] | 0 ; L13 : do { switch ( $18 << 24 >> 24 ) { case 0 : { $19 = ( $2 | 0 ) == ( 2 ) ; if ( $19 ) { _png_read_data ( $0 , $4 , 2 ) ; _png_calculate_crc ( $0 , $4 , 2 ) ; $20 = ( ( ( $0 ) ) + 216 | 0 ) ; HEAP16 [ $20 >> 1 ] = 1 ; $21 = HEAP8 [ $4 >> 0 ] | 0 ; $22 = $21 & 255 ; $23 = $22 << 8 ; $24 = ( ( ( $4 ) ) + 1 | 0 ) ; $25 = HEAP8 [ $24 >> 0 ] | 0 ; $26 = $25 & 255 ; $27 = $23 | $26 ; $28 = $27 & 65535 ; $29 = ( ( ( $0 ) ) + 284 | 0 ) ; HEAP16 [ $29 >> 1 ] = $28 ; $$pre$phiZ2D = $20 ; break L13 ; } ( _png_crc_finish ( $0 , $2 ) | 0 ) ; _png_chunk_benign_error ( $0 , 25426 ) ; STACKTOP = sp ; return ; break ; } case 2 : { $30 = ( $2 | 0 ) == ( 6 ) ; if ( $30 ) { _png_read_data ( $0 , $5 , 6 ) ; _png_calculate_crc ( $0 , $5 , 6 ) ; $31 = ( ( ( $0 ) ) + 216 | 0 ) ; HEAP16 [ $31 >> 1 ] = 1 ; $32 = HEAP8 [ $5 >> 0 ] | 0 ; $33 = $32 & 255 ; $34 = $33 << 8 ; $35 = ( ( ( $5 ) ) + 1 | 0 ) ; $36 = HEAP8 [ $35 >> 0 ] | 0 ; $37 = $36 & 255 ; $38 = $34 | $37 ; $39 = $38 & 65535 ; $40 = ( ( ( $0 ) ) + 278 | 0 ) ; HEAP16 [ $40 >> 1 ] = $39 ; $41 = ( ( ( $5 ) ) + 2 | 0 ) ; $42 = HEAP8 [ $41 >> 0 ] | 0 ; $43 = $42 & 255 ; $44 = $43 << 8 ; $45 = ( ( ( $5 ) ) + 3 | 0 ) ; $46 = HEAP8 [ $45 >> 0 ] | 0 ; $47 = $46 & 255 ; $48 = $44 | $47 ; $49 = $48 & 65535 ; $50 = ( ( ( $0 ) ) + 280 | 0 ) ; HEAP16 [ $50 >> 1 ] = $49 ; $51 = ( ( ( $5 ) ) + 4 | 0 ) ; $52 = HEAP8 [ $51 >> 0 ] | 0 ; $53 = $52 & 255 ; $54 = $53 << 8 ; $55 = ( ( ( $5 ) ) + 5 | 0 ) ; $56 = HEAP8 [ $55 >> 0 ] | 0 ; $57 = $56 & 255 ; $58 = $54 | $57 ; $59 = $58 & 65535 ; $60 = ( ( ( $0 ) ) + 282 | 0 ) ; HEAP16 [ $60 >> 1 ] = $59 ; $$pre$phiZ2D = $31 ; break L13 ; } ( _png_crc_finish ( $0 , $2 ) | 0 ) ; _png_chunk_benign_error ( $0 , 25426 ) ; STACKTOP = sp ; return ; break ; } case 3 : { $61 = $7 & 2 ; $62 = ( $61 | 0 ) == ( 0 ) ; if ( $62 ) { ( _png_crc_finish ( $0 , $2 ) | 0 ) ; _png_chunk_benign_error ( $0 , 25413 ) ; STACKTOP = sp ; return ; } $63 = ( ( ( $0 ) ) + 208 | 0 ) ; $64 = HEAP16 [ $63 >> 1 ] | 0 ; $65 = $64 & 65535 ; $66 = ( $2 >>> 0 ) > ( 256 ) ; $67 = ( ( $2 ) + - 1 ) | 0 ; $68 = ( $67 >>> 0 ) >= ( $65 >>> 0 ) ; $69 = $66 | $68 ; if ( ! ( $69 ) ) { _png_read_data ( $0 , $3 , $2 ) ; _png_calculate_crc ( $0 , $3 , $2 ) ; $70 = $2 & 65535 ; $71 = ( ( ( $0 ) ) + 216 | 0 ) ; HEAP16 [ $71 >> 1 ] = $70 ; $$pre$phiZ2D = $71 ; break L13 ; } ( _png_crc_finish ( $0 , $2 ) | 0 ) ; _png_chunk_benign_error ( $0 , 25426 ) ; STACKTOP = sp ; return ; break ; } default : { ( _png_crc_finish ( $0 , $2 ) | 0 ) ; _png_chunk_benign_error ( $0 , 25539 ) ; STACKTOP = sp ; return ; } } } while ( 0 ) ; $72 = ( _png_crc_finish ( $0 , 0 ) | 0 ) ; $73 = ( $72 | 0 ) == ( 0 ) ; if ( $73 ) { $74 = HEAP16 [ $$pre$phiZ2D >> 1 ] | 0 ; $75 = $74 & 65535 ; $76 = ( ( ( $0 ) ) + 276 | 0 ) ; _png_set_tRNS ( $0 , $1 , $3 , $75 , $76 ) ; STACKTOP = sp ; return ; } else { HEAP16 [ $$pre$phiZ2D >> 1 ] = 0 ; STACKTOP = sp ; return ; } } function _png_handle_bKGD ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$$ = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 ; var $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 ; var $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 ; var $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 ; var $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $3 = sp + 10 | 0 ; $4 = sp ; $5 = ( ( ( $0 ) ) + 24 | 0 ) ; $6 = HEAP32 [ $5 >> 2 ] | 0 ; $7 = $6 & 1 ; $8 = ( $7 | 0 ) == ( 0 ) ; if ( $8 ) { _png_chunk_error ( $0 , 25434 ) ; // unreachable; } $9 = $6 & 4 ; $10 = ( $9 | 0 ) == ( 0 ) ; if ( $10 ) { $11 = ( ( ( $0 ) ) + 223 | 0 ) ; $12 = HEAP8 [ $11 >> 0 ] | 0 ; $13 = ( $12 << 24 >> 24 ) == ( 3 ) ; $14 = $6 & 2 ; $15 = ( $14 | 0 ) == ( 0 ) ; $or$cond = $15 & $13 ; if ( ! ( $or$cond ) ) { $16 = ( $1 | 0 ) != ( 0 | 0 ) ; if ( $16 ) { $17 = ( ( ( $1 ) ) + 8 | 0 ) ; $18 = HEAP32 [ $17 >> 2 ] | 0 ; $19 = $18 & 32 ; $20 = ( $19 | 0 ) == ( 0 ) ; if ( ! ( $20 ) ) { ( _png_crc_finish ( $0 , $2 ) | 0 ) ; _png_chunk_benign_error ( $0 , 25447 ) ; STACKTOP = sp ; return ; } } $21 = ( $12 << 1 ) & 255 ; $22 = $21 & 4 ; $23 = $22 | 2 ; $24 = $23 & 255 ; $$$ = $13 ? 1 : $24 ; $25 = ( $$$ | 0 ) == ( $2 | 0 ) ; if ( ! ( $25 ) ) { ( _png_crc_finish ( $0 , $2 ) | 0 ) ; _png_chunk_benign_error ( $0 , 25426 ) ; STACKTOP = sp ; return ; } _png_read_data ( $0 , $3 , $2 ) ; _png_calculate_crc ( $0 , $3 , $2 ) ; $26 = ( _png_crc_finish ( $0 , 0 ) | 0 ) ; $27 = ( $26 | 0 ) == ( 0 ) ; if ( ! ( $27 ) ) { STACKTOP = sp ; return ; } $28 = HEAP8 [ $11 >> 0 ] | 0 ; $29 = ( $28 << 24 >> 24 ) == ( 3 ) ; do { if ( $29 ) { $30 = HEAP8 [ $3 >> 0 ] | 0 ; HEAP8 [ $4 >> 0 ] = $30 ; do { if ( $16 ) { $31 = ( ( ( $1 ) ) + 20 | 0 ) ; $32 = HEAP16 [ $31 >> 1 ] | 0 ; $33 = ( $32 << 16 >> 16 ) == ( 0 ) ; if ( $33 ) { label = 18 ; } else { $34 = $32 & 65535 ; $35 = $30 & 255 ; $36 = ( $35 >>> 0 ) < ( $34 >>> 0 ) ; if ( $36 ) { $37 = ( ( ( $0 ) ) + 204 | 0 ) ; $38 = HEAP32 [ $37 >> 2 ] | 0 ; $39 = ( ( $38 ) + ( ( $35 * 3 ) | 0 ) | 0 ) ; $40 = HEAP8 [ $39 >> 0 ] | 0 ; $41 = $40 & 255 ; $42 = ( ( ( $4 ) ) + 2 | 0 ) ; HEAP16 [ $42 >> 1 ] = $41 ; $43 = ( ( ( ( $38 ) + ( ( $35 * 3 ) | 0 ) | 0 ) ) + 1 | 0 ) ; $44 = HEAP8 [ $43 >> 0 ] | 0 ; $45 = $44 & 255 ; $46 = ( ( ( $4 ) ) + 4 | 0 ) ; HEAP16 [ $46 >> 1 ] = $45 ; $47 = ( ( ( ( $38 ) + ( ( $35 * 3 ) | 0 ) | 0 ) ) + 2 | 0 ) ; $48 = HEAP8 [ $47 >> 0 ] | 0 ; $49 = $48 & 255 ; $50 = ( ( ( $4 ) ) + 6 | 0 ) ; HEAP16 [ $50 >> 1 ] = $49 ; break ; } _png_chunk_benign_error ( $0 , 25566 ) ; STACKTOP = sp ; return ; } } else { label = 18 ; } } while ( 0 ) ; if ( ( label | 0 ) == 18 ) { $51 = ( ( ( $4 ) ) + 6 | 0 ) ; HEAP16 [ $51 >> 1 ] = 0 ; $52 = ( ( ( $4 ) ) + 4 | 0 ) ; HEAP16 [ $52 >> 1 ] = 0 ; $53 = ( ( ( $4 ) ) + 2 | 0 ) ; HEAP16 [ $53 >> 1 ] = 0 ; } $54 = ( ( ( $4 ) ) + 8 | 0 ) ; HEAP16 [ $54 >> 1 ] = 0 ; } else { $55 = $28 & 2 ; $56 = ( $55 << 24 >> 24 ) == ( 0 ) ; HEAP8 [ $4 >> 0 ] = 0 ; $57 = HEAP8 [ $3 >> 0 ] | 0 ; $58 = $57 & 255 ; $59 = $58 << 8 ; $60 = ( ( ( $3 ) ) + 1 | 0 ) ; $61 = HEAP8 [ $60 >> 0 ] | 0 ; $62 = $61 & 255 ; $63 = $59 | $62 ; $64 = $63 & 65535 ; if ( $56 ) { $65 = ( ( ( $4 ) ) + 8 | 0 ) ; HEAP16 [ $65 >> 1 ] = $64 ; $66 = ( ( ( $4 ) ) + 6 | 0 ) ; HEAP16 [ $66 >> 1 ] = $64 ; $67 = ( ( ( $4 ) ) + 4 | 0 ) ; HEAP16 [ $67 >> 1 ] = $64 ; $68 = ( ( ( $4 ) ) + 2 | 0 ) ; HEAP16 [ $68 >> 1 ] = $64 ; break ; } else { $69 = ( ( ( $4 ) ) + 2 | 0 ) ; HEAP16 [ $69 >> 1 ] = $64 ; $70 = ( ( ( $3 ) ) + 2 | 0 ) ; $71 = HEAP8 [ $70 >> 0 ] | 0 ; $72 = $71 & 255 ; $73 = $72 << 8 ; $74 = ( ( ( $3 ) ) + 3 | 0 ) ; $75 = HEAP8 [ $74 >> 0 ] | 0 ; $76 = $75 & 255 ; $77 = $73 | $76 ; $78 = $77 & 65535 ; $79 = ( ( ( $4 ) ) + 4 | 0 ) ; HEAP16 [ $79 >> 1 ] = $78 ; $80 = ( ( ( $3 ) ) + 4 | 0 ) ; $81 = HEAP8 [ $80 >> 0 ] | 0 ; $82 = $81 & 255 ; $83 = $82 << 8 ; $84 = ( ( ( $3 ) ) + 5 | 0 ) ; $85 = HEAP8 [ $84 >> 0 ] | 0 ; $86 = $85 & 255 ; $87 = $83 | $86 ; $88 = $87 & 65535 ; $89 = ( ( ( $4 ) ) + 6 | 0 ) ; HEAP16 [ $89 >> 1 ] = $88 ; $90 = ( ( ( $4 ) ) + 8 | 0 ) ; HEAP16 [ $90 >> 1 ] = 0 ; break ; } } } while ( 0 ) ; _png_set_bKGD ( $0 , $1 , $4 ) ; STACKTOP = sp ; return ; } } ( _png_crc_finish ( $0 , $2 ) | 0 ) ; _png_chunk_benign_error ( $0 , 25413 ) ; STACKTOP = sp ; return ; } function _png_handle_hIST ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$031 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 ; var $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $exitcond33 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 528 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 528 | 0 ) ; $3 = sp ; $4 = sp + 512 | 0 ; $5 = ( ( ( $0 ) ) + 24 | 0 ) ; $6 = HEAP32 [ $5 >> 2 ] | 0 ; $7 = $6 & 1 ; $8 = ( $7 | 0 ) == ( 0 ) ; if ( $8 ) { _png_chunk_error ( $0 , 25434 ) ; // unreachable; } $9 = $6 & 6 ; $10 = ( $9 | 0 ) == ( 2 ) ; if ( ! ( $10 ) ) { ( _png_crc_finish ( $0 , $2 ) | 0 ) ; _png_chunk_benign_error ( $0 , 25413 ) ; STACKTOP = sp ; return ; } $11 = ( $1 | 0 ) == ( 0 | 0 ) ; if ( ! ( $11 ) ) { $12 = ( ( ( $1 ) ) + 8 | 0 ) ; $13 = HEAP32 [ $12 >> 2 ] | 0 ; $14 = $13 & 64 ; $15 = ( $14 | 0 ) == ( 0 ) ; if ( ! ( $15 ) ) { ( _png_crc_finish ( $0 , $2 ) | 0 ) ; _png_chunk_benign_error ( $0 , 25447 ) ; STACKTOP = sp ; return ; } } $16 = $2 >>> 1 ; $17 = ( ( ( $0 ) ) + 208 | 0 ) ; $18 = HEAP16 [ $17 >> 1 ] | 0 ; $19 = $18 & 65535 ; $20 = ( $16 | 0 ) != ( $19 | 0 ) ; $21 = ( $2 >>> 0 ) > ( 513 ) ; $or$cond = $21 | $20 ; if ( $or$cond ) { ( _png_crc_finish ( $0 , $2 ) | 0 ) ; _png_chunk_benign_error ( $0 , 25426 ) ; STACKTOP = sp ; return ; } $22 = ( $16 | 0 ) == ( 0 ) ; if ( ! ( $22 ) ) { $23 = ( ( ( $4 ) ) + 1 | 0 ) ; $$031 = 0 ; while ( 1 ) { _png_read_data ( $0 , $4 , 2 ) ; _png_calculate_crc ( $0 , $4 , 2 ) ; $24 = HEAP8 [ $4 >> 0 ] | 0 ; $25 = $24 & 255 ; $26 = $25 << 8 ; $27 = HEAP8 [ $23 >> 0 ] | 0 ; $28 = $27 & 255 ; $29 = $26 | $28 ; $30 = $29 & 65535 ; $31 = ( ( $3 ) + ( $$031 << 1 ) | 0 ) ; HEAP16 [ $31 >> 1 ] = $30 ; $32 = ( ( $$031 ) + 1 ) | 0 ; $exitcond33 = ( $32 | 0 ) == ( $16 | 0 ) ; if ( $exitcond33 ) { break ; } else { $$031 = $32 ; } } } $33 = ( _png_crc_finish ( $0 , 0 ) | 0 ) ; $34 = ( $33 | 0 ) == ( 0 ) ; if ( ! ( $34 ) ) { STACKTOP = sp ; return ; } _png_set_hIST ( $0 , $1 , $3 ) ; STACKTOP = sp ; return ; } function _png_handle_unknown ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $$0 = 0 , $$026 = 0 , $$sink$i = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 ; var $27 = 0 , $28 = 0 , $29 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 ; var $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond$i = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $4 = ( $3 | 0 ) == ( 0 ) ; if ( $4 ) { $5 = ( ( ( $0 ) ) + 300 | 0 ) ; $6 = HEAP32 [ $5 >> 2 ] | 0 ; $$026 = $6 ; } else { $$026 = $3 ; } switch ( $$026 | 0 ) { case 3 : { label = 5 ; break ; } case 2 : { $7 = ( ( ( $0 ) ) + 172 | 0 ) ; $8 = HEAP32 [ $7 >> 2 ] | 0 ; $9 = $8 & 536870912 ; $10 = ( $9 | 0 ) == ( 0 ) ; if ( $10 ) { label = 17 ; } else { label = 5 ; } break ; } default : { label = 17 ; } } do { if ( ( label | 0 ) == 5 ) { $11 = ( ( ( $0 ) ) + 344 | 0 ) ; $12 = HEAP32 [ $11 >> 2 ] | 0 ; $13 = ( $12 | 0 ) == ( 0 | 0 ) ; if ( ! ( $13 ) ) { _png_free ( $0 , $12 ) ; HEAP32 [ $11 >> 2 ] = 0 ; } $14 = ( ( ( $0 ) ) + 332 | 0 ) ; $15 = HEAP32 [ $14 >> 2 ] | 0 ; switch ( $15 | 0 ) { case - 1 : case 0 : { label = 9 ; break ; } default : { $16 = ( $15 >>> 0 ) < ( $2 >>> 0 ) ; if ( $16 ) { $38 = 0 ; } else { label = 9 ; } } } if ( ( label | 0 ) == 9 ) { $17 = ( ( ( $0 ) ) + 172 | 0 ) ; $18 = HEAP32 [ $17 >> 2 ] | 0 ; $19 = $18 >>> 24 ; $20 = $19 & 255 ; $21 = ( ( ( $0 ) ) + 336 | 0 ) ; HEAP8 [ $21 >> 0 ] = $20 ; $22 = $18 >>> 16 ; $23 = $22 & 255 ; $24 = ( ( ( $0 ) ) + 337 | 0 ) ; HEAP8 [ $24 >> 0 ] = $23 ; $25 = $18 >>> 8 ; $26 = $25 & 255 ; $27 = ( ( ( $0 ) ) + 338 | 0 ) ; HEAP8 [ $27 >> 0 ] = $26 ; $28 = $18 & 255 ; $29 = ( ( ( $0 ) ) + 339 | 0 ) ; HEAP8 [ $29 >> 0 ] = $28 ; $30 = ( ( ( $0 ) ) + 340 | 0 ) ; HEAP8 [ $30 >> 0 ] = 0 ; $31 = ( ( ( $0 ) ) + 348 | 0 ) ; HEAP32 [ $31 >> 2 ] = $2 ; $32 = ( ( ( $0 ) ) + 24 | 0 ) ; $33 = HEAP32 [ $32 >> 2 ] | 0 ; $34 = $33 & 255 ; $35 = ( ( ( $0 ) ) + 352 | 0 ) ; HEAP8 [ $35 >> 0 ] = $34 ; $36 = ( $2 | 0 ) == ( 0 ) ; if ( $36 ) { $$sink$i = 0 ; } else { $37 = ( _png_malloc_warn ( $0 , $2 ) | 0 ) ; $$sink$i = $37 ; } HEAP32 [ $11 >> 2 ] = $$sink$i ; $38 = $$sink$i ; } $39 = ( $38 | 0 ) == ( 0 | 0 ) ; $40 = ( $2 | 0 ) != ( 0 ) ; $or$cond$i = $40 & $39 ; if ( $or$cond$i ) { ( _png_crc_finish ( $0 , $2 ) | 0 ) ; _png_chunk_benign_error ( $0 , 25580 ) ; $$0 = 0 ; break ; } if ( $40 ) { _png_read_data ( $0 , $38 , $2 ) ; _png_calculate_crc ( $0 , $38 , $2 ) ; } ( _png_crc_finish ( $0 , 0 ) | 0 ) ; label = 18 ; } else if ( ( label | 0 ) == 17 ) { ( _png_crc_finish ( $0 , $2 ) | 0 ) ; label = 18 ; } } while ( 0 ) ; L26 : do { if ( ( label | 0 ) == 18 ) { switch ( $$026 | 0 ) { case 3 : { break ; } case 2 : { $41 = ( ( ( $0 ) ) + 172 | 0 ) ; $42 = HEAP32 [ $41 >> 2 ] | 0 ; $43 = $42 & 536870912 ; $44 = ( $43 | 0 ) == ( 0 ) ; if ( $44 ) { $$0 = 0 ; break L26 ; } break ; } default : { $$0 = 0 ; break L26 ; } } $45 = ( ( ( $0 ) ) + 328 | 0 ) ; $46 = HEAP32 [ $45 >> 2 ] | 0 ; switch ( $46 | 0 ) { case 1 : { $$0 = 0 ; break L26 ; break ; } case 2 : { HEAP32 [ $45 >> 2 ] = 1 ; _png_chunk_benign_error ( $0 , 25616 ) ; $$0 = 0 ; break L26 ; break ; } case 0 : { break ; } default : { $47 = ( ( $46 ) + - 1 ) | 0 ; HEAP32 [ $45 >> 2 ] = $47 ; } } $48 = ( ( ( $0 ) ) + 336 | 0 ) ; _png_set_unknown_chunks ( $0 , $1 , $48 , 1 ) ; $$0 = 1 ; } } while ( 0 ) ; $49 = ( ( ( $0 ) ) + 344 | 0 ) ; $50 = HEAP32 [ $49 >> 2 ] | 0 ; $51 = ( $50 | 0 ) == ( 0 | 0 ) ; if ( ! ( $51 ) ) { _png_free ( $0 , $50 ) ; } HEAP32 [ $49 >> 2 ] = 0 ; $52 = ( $$0 | 0 ) == ( 0 ) ; if ( ! ( $52 ) ) { return ; } $53 = ( ( ( $0 ) ) + 172 | 0 ) ; $54 = HEAP32 [ $53 >> 2 ] | 0 ; $55 = $54 & 536870912 ; $56 = ( $55 | 0 ) == ( 0 ) ; if ( $56 ) { _png_chunk_error ( $0 , 25640 ) ; // unreachable; } else { return ; } } function _png_combine_row ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$ = 0 , $$$ = 0 , $$$1277 = 0 , $$0 = 0 , $$0246 = 0 , $$0247 = 0 , $$0250 = 0 , $$0253 = 0 , $$0254 = 0 , $$0257 = 0 , $$0260 = 0 , $$0268 = 0 , $$0278 = 0 , $$0279 = 0 , $$0283 = 0 , $$0284 = 0 , $$10 = 0 , $$11333 = 0 , $$1248 = 0 , $$1251 = 0 ; var $$1255 = 0 , $$1258 = 0 , $$1277332 = 0 , $$2262337 = 0 , $$2270336 = 0 , $$2338 = 0 , $$3 = 0 , $$3263 = 0 , $$3271 = 0 , $$4264341 = 0 , $$4272340 = 0 , $$4342 = 0 , $$5 = 0 , $$5265 = 0 , $$5273 = 0 , $$6 = 0 , $$6266 = 0 , $$7267334 = 0 , $$7275 = 0 , $$7335 = 0 ; var $$8 = 0 , $$pre = 0 , $$pre$phiZ2D = 0 , $$sink = 0 , $$sink285 = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 ; var $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 ; var $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 ; var $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 ; var $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 , $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 ; var $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 , $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 ; var $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 ; var $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 ; var $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 ; var $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $or$cond = 0 , $trunc = 0 ; var label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( ( ( $0 ) ) + 231 | 0 ) ; $4 = HEAP8 [ $3 >> 0 ] | 0 ; $5 = $4 & 255 ; $6 = ( ( ( $0 ) ) + 180 | 0 ) ; $7 = HEAP32 [ $6 >> 2 ] | 0 ; $8 = ( ( ( $7 ) ) + 1 | 0 ) ; $9 = ( ( ( $0 ) ) + 144 | 0 ) ; $10 = HEAP32 [ $9 >> 2 ] | 0 ; $11 = ( ( ( $0 ) ) + 221 | 0 ) ; $12 = HEAP8 [ $11 >> 0 ] | 0 ; $13 = $12 & 255 ; $14 = ( $4 << 24 >> 24 ) == ( 0 ) ; if ( $14 ) { _png_error ( $0 , 25665 ) ; // unreachable; } $15 = ( ( ( $0 ) ) + 192 | 0 ) ; $16 = HEAP32 [ $15 >> 2 ] | 0 ; $17 = ( $16 | 0 ) == ( 0 ) ; if ( ! ( $17 ) ) { $18 = ( $4 & 255 ) > ( 7 ) ; if ( $18 ) { $19 = $5 >>> 3 ; $20 = Math_imul ( $10 , $19 ) | 0 ; $25 = $20 ; } else { $21 = Math_imul ( $10 , $5 ) | 0 ; $22 = ( ( $21 ) + 7 ) | 0 ; $23 = $22 >>> 3 ; $25 = $23 ; } $24 = ( $16 | 0 ) == ( $25 | 0 ) ; if ( ! ( $24 ) ) { _png_error ( $0 , 25690 ) ; // unreachable; } } $26 = ( $10 | 0 ) == ( 0 ) ; if ( $26 ) { _png_error ( $0 , 25726 ) ; // unreachable; } $27 = Math_imul ( $10 , $5 ) | 0 ; $28 = $27 & 7 ; $29 = ( $28 | 0 ) == ( 0 ) ; $30 = ( $4 & 255 ) > ( 7 ) ; $31 = $5 >>> 3 ; $32 = Math_imul ( $10 , $31 ) | 0 ; $33 = ( ( $27 ) + 7 ) | 0 ; $34 = $33 >>> 3 ; $35 = $30 ? $32 : $34 ; $36 = ( ( $1 ) + ( $35 ) | 0 ) ; $37 = ( ( ( $36 ) ) + - 1 | 0 ) ; if ( $29 ) { $$0279 = 0 ; $$0283 = 0 ; $$0284 = 0 ; } else { $38 = 255 >>> $28 ; $39 = HEAP8 [ $37 >> 0 ] | 0 ; $$0279 = $37 ; $$0283 = $38 ; $$0284 = $39 ; } $40 = ( ( ( $0 ) ) + 220 | 0 ) ; $41 = HEAP8 [ $40 >> 0 ] | 0 ; $42 = ( $41 << 24 >> 24 ) == ( 0 ) ; L18 : do { if ( $42 ) { label = 56 ; } else { $43 = ( ( ( $0 ) ) + 32 | 0 ) ; $44 = HEAP32 [ $43 >> 2 ] | 0 ; $45 = $44 & 2 ; $46 = ( $45 | 0 ) != ( 0 ) ; $47 = ( $12 & 255 ) < ( 6 ) ; $or$cond = $47 & $46 ; if ( $or$cond ) { switch ( $2 | 0 ) { case 0 : { $$pre = $13 & 1 ; $$pre$phiZ2D = $$pre ; break ; } case 1 : { $48 = $13 & 1 ; $49 = ( $48 | 0 ) == ( 0 ) ; if ( $49 ) { label = 56 ; break L18 ; } else { $$pre$phiZ2D = 1 ; } break ; } default : { label = 56 ; break L18 ; } } $50 = ( ( $13 ) + 1 ) | 0 ; $51 = $50 >>> 1 ; $52 = ( 3 - ( $51 ) ) | 0 ; $53 = $$pre$phiZ2D << $52 ; $54 = $53 & 7 ; $55 = ( $10 >>> 0 ) > ( $54 >>> 0 ) ; if ( ! ( $55 ) ) { return ; } $56 = ( $4 & 255 ) < ( 8 ) ; if ( $56 ) { $57 = ( 8 / ( $5 >>> 0 ) ) & - 1 ; $58 = ( $2 | 0 ) == ( 0 ) ; $59 = ( $4 << 24 >> 24 ) == ( 1 ) ; $60 = ( $4 << 24 >> 24 ) == ( 2 ) ; $61 = $60 ? 1 : 2 ; $62 = $59 ? 0 : $61 ; $63 = ( ( 320 + ( ( $62 * 24 ) | 0 ) | 0 ) + ( $13 << 2 ) | 0 ) ; $64 = $13 >>> 1 ; $65 = ( ( 428 + ( ( $62 * 12 ) | 0 ) | 0 ) + ( $64 << 2 ) | 0 ) ; $$sink = $58 ? $63 : $65 ; $66 = HEAP32 [ $$sink >> 2 ] | 0 ; $$0246 = $1 ; $$0260 = $8 ; $$0268 = $10 ; $$0278 = $66 ; while ( 1 ) { $67 = $$0278 >>> 8 ; $68 = $$0278 << 24 ; $69 = $67 | $68 ; $trunc = $$0278 & 255 ; switch ( $trunc << 24 >> 24 ) { case 0 : { break ; } case - 1 : { $79 = HEAP8 [ $$0260 >> 0 ] | 0 ; $$sink285 = $79 ; label = 24 ; break ; } default : { $70 = HEAP8 [ $$0246 >> 0 ] | 0 ; $71 = $70 & 255 ; $72 = $$0278 ^ 255 ; $73 = $72 & $71 ; $74 = HEAP8 [ $$0260 >> 0 ] | 0 ; $75 = $74 & 255 ; $76 = $$0278 & $75 ; $77 = $76 | $73 ; $78 = $77 & 255 ; $$sink285 = $78 ; label = 24 ; } } if ( ( label | 0 ) == 24 ) { label = 0 ; HEAP8 [ $$0246 >> 0 ] = $$sink285 ; } $80 = ( $$0268 >>> 0 ) > ( $57 >>> 0 ) ; $81 = ( ( $$0268 ) - ( $57 ) ) | 0 ; $82 = ( ( ( $$0246 ) ) + 1 | 0 ) ; $83 = ( ( ( $$0260 ) ) + 1 | 0 ) ; if ( $80 ) { $$0246 = $82 ; $$0260 = $83 ; $$0268 = $81 ; $$0278 = $69 ; } else { break L18 ; } } } $84 = $5 & 7 ; $85 = ( $84 | 0 ) == ( 0 ) ; if ( ! ( $85 ) ) { _png_error ( $0 , 25751 ) ; // unreachable; } $86 = Math_imul ( $54 , $31 ) | 0 ; $87 = ( ( $32 ) - ( $86 ) ) | 0 ; $88 = ( ( $1 ) + ( $86 ) | 0 ) ; $89 = ( ( $8 ) + ( $86 ) | 0 ) ; $90 = ( $2 | 0 ) == ( 0 ) ; $91 = ( 6 - ( $13 ) ) | 0 ; $92 = $91 >>> 1 ; $93 = $31 << $92 ; $94 = ( $93 >>> 0 ) > ( $87 >>> 0 ) ; $$ = $94 ? $87 : $93 ; $$$ = $90 ? $31 : $$ ; $95 = ( 7 - ( $13 ) ) | 0 ; $96 = $95 >>> 1 ; $97 = $31 << $96 ; switch ( $$$ | 0 ) { case 1 : { $106 = HEAP8 [ $89 >> 0 ] | 0 ; HEAP8 [ $88 >> 0 ] = $106 ; $107 = ( $87 >>> 0 ) > ( $97 >>> 0 ) ; if ( $107 ) { $$2262337 = $89 ; $$2270336 = $87 ; $$2338 = $88 ; } else { return ; } while ( 1 ) { $108 = ( ( $$2338 ) + ( $97 ) | 0 ) ; $109 = ( ( $$2262337 ) + ( $97 ) | 0 ) ; $110 = ( ( $$2270336 ) - ( $97 ) ) | 0 ; $111 = HEAP8 [ $109 >> 0 ] | 0 ; HEAP8 [ $108 >> 0 ] = $111 ; $112 = ( $110 >>> 0 ) > ( $97 >>> 0 ) ; if ( $112 ) { $$2262337 = $109 ; $$2270336 = $110 ; $$2338 = $108 ; } else { break ; } } return ; break ; } case 2 : { $$3 = $88 ; $$3263 = $89 ; $$3271 = $87 ; while ( 1 ) { $113 = HEAP8 [ $$3263 >> 0 ] | 0 ; HEAP8 [ $$3 >> 0 ] = $113 ; $114 = ( ( ( $$3263 ) ) + 1 | 0 ) ; $115 = HEAP8 [ $114 >> 0 ] | 0 ; $116 = ( ( ( $$3 ) ) + 1 | 0 ) ; HEAP8 [ $116 >> 0 ] = $115 ; $117 = ( $$3271 >>> 0 ) > ( $97 >>> 0 ) ; if ( ! ( $117 ) ) { label = 59 ; break ; } $118 = ( ( $$3263 ) + ( $97 ) | 0 ) ; $119 = ( ( $$3 ) + ( $97 ) | 0 ) ; $120 = ( ( $$3271 ) - ( $97 ) ) | 0 ; $121 = ( $120 >>> 0 ) > ( 1 ) ; if ( $121 ) { $$3 = $119 ; $$3263 = $118 ; $$3271 = $120 ; } else { break ; } } if ( ( label | 0 ) == 59 ) { return ; } $122 = HEAP8 [ $118 >> 0 ] | 0 ; HEAP8 [ $119 >> 0 ] = $122 ; return ; break ; } case 3 : { $98 = HEAP8 [ $89 >> 0 ] | 0 ; HEAP8 [ $88 >> 0 ] = $98 ; $99 = ( ( ( $89 ) ) + 1 | 0 ) ; $100 = HEAP8 [ $99 >> 0 ] | 0 ; $101 = ( ( ( $88 ) ) + 1 | 0 ) ; HEAP8 [ $101 >> 0 ] = $100 ; $102 = ( ( ( $89 ) ) + 2 | 0 ) ; $103 = HEAP8 [ $102 >> 0 ] | 0 ; $104 = ( ( ( $88 ) ) + 2 | 0 ) ; HEAP8 [ $104 >> 0 ] = $103 ; $105 = ( $87 >>> 0 ) > ( $97 >>> 0 ) ; if ( $105 ) { $$4264341 = $89 ; $$4272340 = $87 ; $$4342 = $88 ; } else { return ; } while ( 1 ) { $123 = ( ( $$4264341 ) + ( $97 ) | 0 ) ; $124 = ( ( $$4342 ) + ( $97 ) | 0 ) ; $125 = ( ( $$4272340 ) - ( $97 ) ) | 0 ; $126 = HEAP8 [ $123 >> 0 ] | 0 ; HEAP8 [ $124 >> 0 ] = $126 ; $127 = ( ( ( $123 ) ) + 1 | 0 ) ; $128 = HEAP8 [ $127 >> 0 ] | 0 ; $129 = ( ( ( $124 ) ) + 1 | 0 ) ; HEAP8 [ $129 >> 0 ] = $128 ; $130 = ( ( ( $123 ) ) + 2 | 0 ) ; $131 = HEAP8 [ $130 >> 0 ] | 0 ; $132 = ( ( ( $124 ) ) + 2 | 0 ) ; HEAP8 [ $132 >> 0 ] = $131 ; $133 = ( $125 >>> 0 ) > ( $97 >>> 0 ) ; if ( $133 ) { $$4264341 = $123 ; $$4272340 = $125 ; $$4342 = $124 ; } else { break ; } } return ; break ; } default : { $134 = ( $$$ >>> 0 ) < ( 16 ) ; if ( $134 ) { $136 = $88 ; $137 = $136 & 1 ; $138 = ( $137 | 0 ) == ( 0 ) ; if ( $138 ) { $139 = $89 ; $140 = $97 | $139 ; $141 = $140 | $$$ ; $142 = $141 & 1 ; $143 = ( $142 | 0 ) == ( 0 ) ; if ( $143 ) { $144 = $140 | $136 ; $145 = $144 | $$$ ; $146 = $145 & 3 ; $147 = ( $146 | 0 ) == ( 0 ) ; if ( $147 ) { $148 = ( ( $97 ) - ( $$$ ) ) | 0 ; $149 = $148 >>> 2 ; $$0254 = $89 ; $$0257 = $88 ; $$5273 = $87 ; while ( 1 ) { $$0253 = $$$ ; $$1255 = $$0254 ; $$1258 = $$0257 ; while ( 1 ) { $150 = ( ( ( $$1255 ) ) + 4 | 0 ) ; $151 = HEAP32 [ $$1255 >> 2 ] | 0 ; $152 = ( ( ( $$1258 ) ) + 4 | 0 ) ; HEAP32 [ $$1258 >> 2 ] = $151 ; $153 = ( ( $$0253 ) + - 4 ) | 0 ; $154 = ( $153 | 0 ) == ( 0 ) ; if ( $154 ) { break ; } else { $$0253 = $153 ; $$1255 = $150 ; $$1258 = $152 ; } } $155 = ( $$5273 >>> 0 ) > ( $97 >>> 0 ) ; $156 = ( ( $152 ) + ( $149 << 2 ) | 0 ) ; $157 = ( ( $150 ) + ( $149 << 2 ) | 0 ) ; $158 = ( ( $$5273 ) - ( $97 ) ) | 0 ; if ( ! ( $155 ) ) { label = 59 ; break ; } $159 = ( $$$ >>> 0 ) > ( $158 >>> 0 ) ; if ( $159 ) { break ; } else { $$0254 = $157 ; $$0257 = $156 ; $$5273 = $158 ; } } if ( ( label | 0 ) == 59 ) { return ; } $$5 = $156 ; $$5265 = $157 ; $$7275 = $158 ; while ( 1 ) { $160 = ( ( ( $$5265 ) ) + 1 | 0 ) ; $161 = HEAP8 [ $$5265 >> 0 ] | 0 ; $162 = ( ( ( $$5 ) ) + 1 | 0 ) ; HEAP8 [ $$5 >> 0 ] = $161 ; $163 = ( ( $$7275 ) + - 1 ) | 0 ; $164 = ( $163 | 0 ) == ( 0 ) ; if ( $164 ) { break ; } else { $$5 = $162 ; $$5265 = $160 ; $$7275 = $163 ; } } return ; } else { $165 = ( ( $97 ) - ( $$$ ) ) | 0 ; $166 = $165 >>> 1 ; $$0247 = $89 ; $$0250 = $88 ; $$8 = $87 ; while ( 1 ) { $$0 = $$$ ; $$1248 = $$0247 ; $$1251 = $$0250 ; while ( 1 ) { $167 = ( ( ( $$1248 ) ) + 2 | 0 ) ; $168 = HEAP16 [ $$1248 >> 1 ] | 0 ; $169 = ( ( ( $$1251 ) ) + 2 | 0 ) ; HEAP16 [ $$1251 >> 1 ] = $168 ; $170 = ( ( $$0 ) + - 2 ) | 0 ; $171 = ( $170 | 0 ) == ( 0 ) ; if ( $171 ) { break ; } else { $$0 = $170 ; $$1248 = $167 ; $$1251 = $169 ; } } $172 = ( $$8 >>> 0 ) > ( $97 >>> 0 ) ; $173 = ( ( $169 ) + ( $166 << 1 ) | 0 ) ; $174 = ( ( $167 ) + ( $166 << 1 ) | 0 ) ; $175 = ( ( $$8 ) - ( $97 ) ) | 0 ; if ( ! ( $172 ) ) { label = 59 ; break ; } $176 = ( $$$ >>> 0 ) > ( $175 >>> 0 ) ; if ( $176 ) { break ; } else { $$0247 = $174 ; $$0250 = $173 ; $$8 = $175 ; } } if ( ( label | 0 ) == 59 ) { return ; } $$10 = $175 ; $$6 = $173 ; $$6266 = $174 ; while ( 1 ) { $177 = ( ( ( $$6266 ) ) + 1 | 0 ) ; $178 = HEAP8 [ $$6266 >> 0 ] | 0 ; $179 = ( ( ( $$6 ) ) + 1 | 0 ) ; HEAP8 [ $$6 >> 0 ] = $178 ; $180 = ( ( $$10 ) + - 1 ) | 0 ; $181 = ( $180 | 0 ) == ( 0 ) ; if ( $181 ) { break ; } else { $$10 = $180 ; $$6 = $179 ; $$6266 = $177 ; } } return ; } } } } _memcpy ( ( $88 | 0 ) , ( $89 | 0 ) , ( $$$ | 0 ) ) | 0 ; $135 = ( $87 >>> 0 ) > ( $97 >>> 0 ) ; if ( $135 ) { $$11333 = $87 ; $$1277332 = $$$ ; $$7267334 = $89 ; $$7335 = $88 ; } else { return ; } while ( 1 ) { $182 = ( ( $$7267334 ) + ( $97 ) | 0 ) ; $183 = ( ( $$7335 ) + ( $97 ) | 0 ) ; $184 = ( ( $$11333 ) - ( $97 ) ) | 0 ; $185 = ( $$1277332 >>> 0 ) > ( $184 >>> 0 ) ; $$$1277 = $185 ? $184 : $$1277332 ; _memcpy ( ( $183 | 0 ) , ( $182 | 0 ) , ( $$$1277 | 0 ) ) | 0 ; $186 = ( $184 >>> 0 ) > ( $97 >>> 0 ) ; if ( $186 ) { $$11333 = $184 ; $$1277332 = $$$1277 ; $$7267334 = $182 ; $$7335 = $183 ; } else { break ; } } return ; } } } else { label = 56 ; } } } while ( 0 ) ; if ( ( label | 0 ) == 56 ) { _memcpy ( ( $1 | 0 ) , ( $8 | 0 ) , ( $35 | 0 ) ) | 0 ; } $187 = ( $$0279 | 0 ) == ( 0 | 0 ) ; if ( $187 ) { return ; } $188 = $$0284 & 255 ; $189 = $$0283 & $188 ; $190 = HEAP8 [ $$0279 >> 0 ] | 0 ; $191 = $190 & 255 ; $192 = $$0283 ^ 255 ; $193 = $192 & $191 ; $194 = $193 | $189 ; $195 = $194 & 255 ; HEAP8 [ $$0279 >> 0 ] = $195 ; return ; } function _png_do_read_interlace ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $$0218268$us = 0 , $$0219283$us = 0 , $$0220267$us = 0 , $$0222266$us = 0 , $$0223282$us = 0 , $$0225281$us = 0 , $$0227303$us = 0 , $$0228280$us = 0 , $$0231279$us = 0 , $$0232313$us = 0 , $$0233271$us = 0 , $$0234298$us = 0 , $$0236297$us = 0 , $$0239312$us = 0 , $$0242311$us = 0 , $$0244310$us = 0 , $$0247309$us = 0 , $$0249296$us = 0 , $$0251287$us = 0 , $$0252295$us = 0 ; var $$0255294$us = 0 , $$0265$us = 0 , $$1$us = 0 , $$1221264$us = 0 , $$1224273$us = 0 , $$1226$us = 0 , $$1229272$us = 0 , $$1235$us = 0 , $$1237288$us = 0 , $$1240302$us = 0 , $$1243$us = 0 , $$1245301$us = 0 , $$1248$us = 0 , $$1250$us = 0 , $$1253286$us = 0 , $$2$us = 0 , $$2230$us = 0 , $$2238$us = 0 , $$2241$us = 0 , $$2246$us = 0 ; var $$2254$us = 0 , $$pr = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 ; var $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 ; var $134 = 0 , $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $16 = 0 , $17 = 0 ; var $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 ; var $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 ; var $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 ; var $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 ; var $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $4 = sp ; $5 = ( $1 | 0 ) != ( 0 | 0 ) ; $6 = ( $0 | 0 ) != ( 0 | 0 ) ; $or$cond = $6 & $5 ; if ( ! ( $or$cond ) ) { STACKTOP = sp ; return ; } $7 = HEAP32 [ $0 >> 2 ] | 0 ; $8 = ( 464 + ( $2 << 2 ) | 0 ) ; $9 = HEAP32 [ $8 >> 2 ] | 0 ; $10 = Math_imul ( $9 , $7 ) | 0 ; $11 = ( ( ( $0 ) ) + 11 | 0 ) ; $12 = HEAP8 [ $11 >> 0 ] | 0 ; switch ( $12 << 24 >> 24 ) { case 1 : { $13 = ( $7 | 0 ) == ( 0 ) ; if ( $13 ) { label = 24 ; } else { $14 = ( ( $10 ) + - 1 ) | 0 ; $15 = $14 >>> 3 ; $16 = ( ( $1 ) + ( $15 ) | 0 ) ; $17 = ( ( $10 ) + 7 ) | 0 ; $18 = $17 & 7 ; $19 = $18 ^ 7 ; $20 = ( ( $7 ) + - 1 ) | 0 ; $21 = $20 >>> 3 ; $22 = ( ( $1 ) + ( $21 ) | 0 ) ; $23 = ( ( $7 ) + 7 ) | 0 ; $24 = $23 & 7 ; $25 = $24 ^ 7 ; $$0219283$us = $22 ; $$0223282$us = $16 ; $$0225281$us = $25 ; $$0228280$us = $19 ; $$0231279$us = 0 ; while ( 1 ) { $26 = HEAP8 [ $$0219283$us >> 0 ] | 0 ; $27 = $26 & 255 ; $28 = $27 >>> $$0225281$us ; $29 = $28 & 1 ; $$0233271$us = 0 ; $$1224273$us = $$0223282$us ; $$1229272$us = $$0228280$us ; while ( 1 ) { $30 = HEAP8 [ $$1224273$us >> 0 ] | 0 ; $31 = $30 & 255 ; $32 = ( 7 - ( $$1229272$us ) ) | 0 ; $33 = 32639 >>> $32 ; $34 = $33 & $31 ; $35 = $29 << $$1229272$us ; $36 = $34 | $35 ; $37 = $36 & 255 ; HEAP8 [ $$1224273$us >> 0 ] = $37 ; $38 = ( $$1229272$us | 0 ) == ( 7 ) ; $39 = ( ( ( $$1224273$us ) ) + - 1 | 0 ) ; $40 = ( ( $$1229272$us ) + 1 ) | 0 ; $$2230$us = $38 ? 0 : $40 ; $$2$us = $38 ? $39 : $$1224273$us ; $41 = ( ( $$0233271$us ) + 1 ) | 0 ; $42 = ( $41 | 0 ) < ( $9 | 0 ) ; if ( $42 ) { $$0233271$us = $41 ; $$1224273$us = $$2$us ; $$1229272$us = $$2230$us ; } else { break ; } } $43 = ( $$0225281$us | 0 ) == ( 7 ) ; $44 = ( ( ( $$0219283$us ) ) + - 1 | 0 ) ; $45 = ( ( $$0225281$us ) + 1 ) | 0 ; $$1226$us = $43 ? 0 : $45 ; $$1$us = $43 ? $44 : $$0219283$us ; $46 = ( ( $$0231279$us ) + 1 ) | 0 ; $47 = HEAP32 [ $0 >> 2 ] | 0 ; $48 = ( $46 >>> 0 ) < ( $47 >>> 0 ) ; if ( $48 ) { $$0219283$us = $$1$us ; $$0223282$us = $$2$us ; $$0225281$us = $$1226$us ; $$0228280$us = $$2230$us ; $$0231279$us = $46 ; } else { label = 23 ; break ; } } } break ; } case 2 : { $49 = ( $7 | 0 ) == ( 0 ) ; if ( $49 ) { label = 24 ; } else { $50 = ( ( $10 ) + - 1 ) | 0 ; $51 = $50 >>> 2 ; $52 = ( ( $1 ) + ( $51 ) | 0 ) ; $53 = $10 << 1 ; $54 = ( ( $53 ) + 6 ) | 0 ; $55 = $54 & 6 ; $56 = $55 ^ 6 ; $57 = ( ( $7 ) + - 1 ) | 0 ; $58 = $57 >>> 2 ; $59 = ( ( $1 ) + ( $58 ) | 0 ) ; $60 = $7 << 1 ; $61 = ( ( $60 ) + 6 ) | 0 ; $62 = $61 & 6 ; $63 = $62 ^ 6 ; $$0234298$us = $59 ; $$0236297$us = $52 ; $$0249296$us = $63 ; $$0252295$us = $56 ; $$0255294$us = 0 ; while ( 1 ) { $64 = HEAP8 [ $$0234298$us >> 0 ] | 0 ; $65 = $64 & 255 ; $66 = $65 >>> $$0249296$us ; $67 = $66 & 3 ; $$0251287$us = 0 ; $$1237288$us = $$0236297$us ; $$1253286$us = $$0252295$us ; while ( 1 ) { $68 = HEAP8 [ $$1237288$us >> 0 ] | 0 ; $69 = $68 & 255 ; $70 = ( 6 - ( $$1253286$us ) ) | 0 ; $71 = 16191 >>> $70 ; $72 = $71 & $69 ; $73 = $67 << $$1253286$us ; $74 = $72 | $73 ; $75 = $74 & 255 ; HEAP8 [ $$1237288$us >> 0 ] = $75 ; $76 = ( $$1253286$us | 0 ) == ( 6 ) ; $77 = ( ( ( $$1237288$us ) ) + - 1 | 0 ) ; $78 = ( ( $$1253286$us ) + 2 ) | 0 ; $$2254$us = $76 ? 0 : $78 ; $$2238$us = $76 ? $77 : $$1237288$us ; $79 = ( ( $$0251287$us ) + 1 ) | 0 ; $80 = ( $79 | 0 ) < ( $9 | 0 ) ; if ( $80 ) { $$0251287$us = $79 ; $$1237288$us = $$2238$us ; $$1253286$us = $$2254$us ; } else { break ; } } $81 = ( $$0249296$us | 0 ) == ( 6 ) ; $82 = ( ( ( $$0234298$us ) ) + - 1 | 0 ) ; $83 = ( ( $$0249296$us ) + 2 ) | 0 ; $$1250$us = $81 ? 0 : $83 ; $$1235$us = $81 ? $82 : $$0234298$us ; $84 = ( ( $$0255294$us ) + 1 ) | 0 ; $85 = HEAP32 [ $0 >> 2 ] | 0 ; $86 = ( $84 >>> 0 ) < ( $85 >>> 0 ) ; if ( $86 ) { $$0234298$us = $$1235$us ; $$0236297$us = $$2238$us ; $$0249296$us = $$1250$us ; $$0252295$us = $$2254$us ; $$0255294$us = $84 ; } else { label = 23 ; break ; } } } break ; } case 4 : { $87 = ( $7 | 0 ) == ( 0 ) ; if ( $87 ) { label = 24 ; } else { $88 = $10 << 2 ; $89 = $88 & 4 ; $90 = ( ( $10 ) + - 1 ) | 0 ; $91 = $90 >>> 1 ; $92 = ( ( $1 ) + ( $91 ) | 0 ) ; $93 = ( ( $7 ) + - 1 ) | 0 ; $94 = $93 >>> 1 ; $95 = ( ( $1 ) + ( $94 ) | 0 ) ; $96 = $7 << 2 ; $97 = $96 & 4 ; $$0232313$us = 0 ; $$0239312$us = $89 ; $$0242311$us = $97 ; $$0244310$us = $92 ; $$0247309$us = $95 ; while ( 1 ) { $98 = HEAP8 [ $$0247309$us >> 0 ] | 0 ; $99 = $98 & 255 ; $100 = $99 >>> $$0242311$us ; $101 = $100 & 15 ; $$0227303$us = 0 ; $$1240302$us = $$0239312$us ; $$1245301$us = $$0244310$us ; while ( 1 ) { $102 = HEAP8 [ $$1245301$us >> 0 ] | 0 ; $103 = $102 & 255 ; $104 = ( 4 - ( $$1240302$us ) ) | 0 ; $105 = 3855 >>> $104 ; $106 = $105 & $103 ; $107 = $101 << $$1240302$us ; $108 = $106 | $107 ; $109 = $108 & 255 ; HEAP8 [ $$1245301$us >> 0 ] = $109 ; $110 = ( $$1240302$us | 0 ) == ( 4 ) ; $111 = ( ( ( $$1245301$us ) ) + - 1 | 0 ) ; $112 = ( ( $$1240302$us ) + 4 ) | 0 ; $$2246$us = $110 ? $111 : $$1245301$us ; $$2241$us = $110 ? 0 : $112 ; $113 = ( ( $$0227303$us ) + 1 ) | 0 ; $114 = ( $113 | 0 ) < ( $9 | 0 ) ; if ( $114 ) { $$0227303$us = $113 ; $$1240302$us = $$2241$us ; $$1245301$us = $$2246$us ; } else { break ; } } $115 = ( $$0242311$us | 0 ) == ( 4 ) ; $116 = ( ( ( $$0247309$us ) ) + - 1 | 0 ) ; $117 = ( ( $$0242311$us ) + 4 ) | 0 ; $$1248$us = $115 ? $116 : $$0247309$us ; $$1243$us = $115 ? 0 : $117 ; $118 = ( ( $$0232313$us ) + 1 ) | 0 ; $119 = HEAP32 [ $0 >> 2 ] | 0 ; $120 = ( $118 >>> 0 ) < ( $119 >>> 0 ) ; if ( $120 ) { $$0232313$us = $118 ; $$0239312$us = $$2241$us ; $$0242311$us = $$1243$us ; $$0244310$us = $$2246$us ; $$0247309$us = $$1248$us ; } else { label = 23 ; break ; } } } break ; } default : { $121 = $12 & 255 ; $122 = $121 >>> 3 ; $123 = ( $7 | 0 ) == ( 0 ) ; if ( $123 ) { $140 = $12 ; label = 25 ; } else { $124 = ( 0 - ( $122 ) ) | 0 ; $125 = ( ( $10 ) + - 1 ) | 0 ; $126 = Math_imul ( $122 , $125 ) | 0 ; $127 = ( ( $1 ) + ( $126 ) | 0 ) ; $128 = ( ( $7 ) + - 1 ) | 0 ; $129 = Math_imul ( $122 , $128 ) | 0 ; $130 = ( ( $1 ) + ( $129 ) | 0 ) ; $$0218268$us = 0 ; $$0220267$us = $127 ; $$0222266$us = $130 ; while ( 1 ) { _memcpy ( ( $4 | 0 ) , ( $$0222266$us | 0 ) , ( $122 | 0 ) ) | 0 ; $$0265$us = 0 ; $$1221264$us = $$0220267$us ; while ( 1 ) { _memcpy ( ( $$1221264$us | 0 ) , ( $4 | 0 ) , ( $122 | 0 ) ) | 0 ; $131 = ( ( $$1221264$us ) + ( $124 ) | 0 ) ; $132 = ( ( $$0265$us ) + 1 ) | 0 ; $133 = ( $132 | 0 ) < ( $9 | 0 ) ; if ( $133 ) { $$0265$us = $132 ; $$1221264$us = $131 ; } else { break ; } } $134 = ( ( $$0222266$us ) + ( $124 ) | 0 ) ; $135 = ( ( $$0218268$us ) + 1 ) | 0 ; $136 = HEAP32 [ $0 >> 2 ] | 0 ; $137 = ( $135 >>> 0 ) < ( $136 >>> 0 ) ; if ( $137 ) { $$0218268$us = $135 ; $$0220267$us = $131 ; $$0222266$us = $134 ; } else { label = 23 ; break ; } } } } } if ( ( label | 0 ) == 23 ) { $$pr = HEAP8 [ $11 >> 0 ] | 0 ; $140 = $$pr ; label = 25 ; } else if ( ( label | 0 ) == 24 ) { HEAP32 [ $0 >> 2 ] = $10 ; $138 = $12 & 255 ; $145 = $138 ; label = 27 ; } if ( ( label | 0 ) == 25 ) { HEAP32 [ $0 >> 2 ] = $10 ; $139 = $140 & 255 ; $141 = ( $140 & 255 ) > ( 7 ) ; if ( $141 ) { $142 = $139 >>> 3 ; $143 = Math_imul ( $142 , $10 ) | 0 ; $149 = $143 ; } else { $145 = $139 ; label = 27 ; } } if ( ( label | 0 ) == 27 ) { $144 = Math_imul ( $10 , $145 ) | 0 ; $146 = ( ( $144 ) + 7 ) | 0 ; $147 = $146 >>> 3 ; $149 = $147 ; } $148 = ( ( ( $0 ) ) + 4 | 0 ) ; HEAP32 [ $148 >> 2 ] = $149 ; STACKTOP = sp ; return ; } function _png_read_filter_row ( $0 , $1 , $2 , $3 , $4 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; $4 = $4 | 0 ; var $$mask$i = 0 , $$off = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $png_read_filter_row_paeth_multibyte_pixel$sink$i = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $$off = ( ( $4 ) + - 1 ) | 0 ; $5 = ( $$off >>> 0 ) < ( 4 ) ; if ( ! ( $5 ) ) { return ; } $6 = ( ( ( $0 ) ) + 380 | 0 ) ; $7 = HEAP32 [ $6 >> 2 ] | 0 ; $8 = ( $7 | 0 ) == ( 0 | 0 ) ; if ( $8 ) { $9 = ( ( ( $0 ) ) + 226 | 0 ) ; $10 = HEAP8 [ $9 >> 0 ] | 0 ; $11 = $10 & 255 ; $12 = ( ( $11 ) + 7 ) | 0 ; HEAP32 [ $6 >> 2 ] = 95 ; $13 = ( ( ( $0 ) ) + 384 | 0 ) ; HEAP32 [ $13 >> 2 ] = 96 ; $14 = ( ( ( $0 ) ) + 388 | 0 ) ; HEAP32 [ $14 >> 2 ] = 97 ; $$mask$i = $12 & 504 ; $15 = ( $$mask$i | 0 ) == ( 8 ) ; $16 = ( ( ( $0 ) ) + 392 | 0 ) ; $png_read_filter_row_paeth_multibyte_pixel$sink$i = $15 ? 99 : 98 ; HEAP32 [ $16 >> 2 ] = $png_read_filter_row_paeth_multibyte_pixel$sink$i ; } $17 = ( ( ( ( $0 ) ) + 380 | 0 ) + ( $$off << 2 ) | 0 ) ; $18 = HEAP32 [ $17 >> 2 ] | 0 ; FUNCTION_TABLE_viii [ $18 & 127 ] ( $1 , $2 , $3 ) ; return ; } function _png_read_filter_row_sub ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$02021 = 0 , $$022 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 ; var $9 = 0 , $exitcond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( ( ( $0 ) ) + 4 | 0 ) ; $4 = HEAP32 [ $3 >> 2 ] | 0 ; $5 = ( ( ( $0 ) ) + 11 | 0 ) ; $6 = HEAP8 [ $5 >> 0 ] | 0 ; $7 = $6 & 255 ; $8 = ( ( $7 ) + 7 ) | 0 ; $9 = $8 >>> 3 ; $10 = ( $9 >>> 0 ) < ( $4 >>> 0 ) ; if ( ! ( $10 ) ) { return ; } $11 = ( ( $1 ) + ( $9 ) | 0 ) ; $12 = ( 0 - ( $9 ) ) | 0 ; $$02021 = $9 ; $$022 = $11 ; while ( 1 ) { $13 = HEAP8 [ $$022 >> 0 ] | 0 ; $14 = $13 & 255 ; $15 = ( ( $$022 ) + ( $12 ) | 0 ) ; $16 = HEAP8 [ $15 >> 0 ] | 0 ; $17 = $16 & 255 ; $18 = ( ( $17 ) + ( $14 ) ) | 0 ; $19 = $18 & 255 ; HEAP8 [ $$022 >> 0 ] = $19 ; $20 = ( ( ( $$022 ) ) + 1 | 0 ) ; $21 = ( ( $$02021 ) + 1 ) | 0 ; $exitcond = ( $21 | 0 ) == ( $4 | 0 ) ; if ( $exitcond ) { break ; } else { $$02021 = $21 ; $$022 = $20 ; } } return ; } function _png_read_filter_row_up ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$01619 = 0 , $$01718 = 0 , $$020 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $exitcond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( ( ( $0 ) ) + 4 | 0 ) ; $4 = HEAP32 [ $3 >> 2 ] | 0 ; $5 = ( $4 | 0 ) == ( 0 ) ; if ( $5 ) { return ; } else { $$01619 = $1 ; $$01718 = 0 ; $$020 = $2 ; } while ( 1 ) { $6 = HEAP8 [ $$01619 >> 0 ] | 0 ; $7 = $6 & 255 ; $8 = ( ( ( $$020 ) ) + 1 | 0 ) ; $9 = HEAP8 [ $$020 >> 0 ] | 0 ; $10 = $9 & 255 ; $11 = ( ( $10 ) + ( $7 ) ) | 0 ; $12 = $11 & 255 ; HEAP8 [ $$01619 >> 0 ] = $12 ; $13 = ( ( ( $$01619 ) ) + 1 | 0 ) ; $14 = ( ( $$01718 ) + 1 ) | 0 ; $exitcond = ( $14 | 0 ) == ( $4 | 0 ) ; if ( $exitcond ) { break ; } else { $$01619 = $13 ; $$01718 = $14 ; $$020 = $8 ; } } return ; } function _png_read_filter_row_avg ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$029$lcssa = 0 , $$02937 = 0 , $$031$lcssa = 0 , $$03136 = 0 , $$038 = 0 , $$13034 = 0 , $$13233 = 0 , $$135 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 ; var $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 ; var $8 = 0 , $9 = 0 , $div = 0 , $exitcond = 0 , $exitcond44 = 0 , $scevgep = 0 , $scevgep43 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( ( ( $0 ) ) + 11 | 0 ) ; $4 = HEAP8 [ $3 >> 0 ] | 0 ; $5 = $4 & 255 ; $6 = ( ( $5 ) + 7 ) | 0 ; $7 = $6 >>> 3 ; $8 = ( ( ( $0 ) ) + 4 | 0 ) ; $9 = HEAP32 [ $8 >> 2 ] | 0 ; $10 = ( ( $9 ) - ( $7 ) ) | 0 ; $11 = ( $7 | 0 ) == ( 0 ) ; if ( $11 ) { $$029$lcssa = $1 ; $$031$lcssa = $2 ; } else { $scevgep = ( ( $2 ) + ( $7 ) | 0 ) ; $$02937 = $1 ; $$03136 = $2 ; $$038 = 0 ; while ( 1 ) { $14 = HEAP8 [ $$02937 >> 0 ] | 0 ; $15 = $14 & 255 ; $16 = ( ( ( $$03136 ) ) + 1 | 0 ) ; $17 = HEAP8 [ $$03136 >> 0 ] | 0 ; $div = ( $17 & 255 ) >>> 1 ; $18 = $div & 255 ; $19 = ( ( $18 ) + ( $15 ) ) | 0 ; $20 = $19 & 255 ; HEAP8 [ $$02937 >> 0 ] = $20 ; $21 = ( ( ( $$02937 ) ) + 1 | 0 ) ; $22 = ( ( $$038 ) + 1 ) | 0 ; $exitcond44 = ( $22 | 0 ) == ( $7 | 0 ) ; if ( $exitcond44 ) { break ; } else { $$02937 = $21 ; $$03136 = $16 ; $$038 = $22 ; } } $scevgep43 = ( ( $1 ) + ( $7 ) | 0 ) ; $$029$lcssa = $scevgep43 ; $$031$lcssa = $scevgep ; } $12 = ( $10 | 0 ) == ( 0 ) ; if ( $12 ) { return ; } $13 = ( 0 - ( $7 ) ) | 0 ; $$13034 = $$029$lcssa ; $$13233 = $$031$lcssa ; $$135 = 0 ; while ( 1 ) { $23 = HEAP8 [ $$13034 >> 0 ] | 0 ; $24 = $23 & 255 ; $25 = ( ( ( $$13233 ) ) + 1 | 0 ) ; $26 = HEAP8 [ $$13233 >> 0 ] | 0 ; $27 = $26 & 255 ; $28 = ( ( $$13034 ) + ( $13 ) | 0 ) ; $29 = HEAP8 [ $28 >> 0 ] | 0 ; $30 = $29 & 255 ; $31 = ( ( $30 ) + ( $27 ) ) | 0 ; $32 = $31 >>> 1 ; $33 = ( ( $32 ) + ( $24 ) ) | 0 ; $34 = $33 & 255 ; HEAP8 [ $$13034 >> 0 ] = $34 ; $35 = ( ( ( $$13034 ) ) + 1 | 0 ) ; $36 = ( ( $$135 ) + 1 ) | 0 ; $exitcond = ( $36 | 0 ) == ( $10 | 0 ) ; if ( $exitcond ) { break ; } else { $$13034 = $35 ; $$13233 = $25 ; $$135 = $36 ; } } return ; } function _png_read_filter_row_paeth_1byte_pixel ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$ = 0 , $$0 = 0 , $$04960 = 0 , $$04960$pn = 0 , $$05258 = 0 , $$056 = 0 , $$059 = 0 , $$2 = 0 , $$55 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 ; var $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 ; var $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( ( ( $0 ) ) + 4 | 0 ) ; $4 = HEAP32 [ $3 >> 2 ] | 0 ; $5 = ( ( $1 ) + ( $4 ) | 0 ) ; $6 = HEAP8 [ $2 >> 0 ] | 0 ; $7 = $6 & 255 ; $8 = HEAP8 [ $1 >> 0 ] | 0 ; $9 = $8 & 255 ; $10 = ( ( $9 ) + ( $7 ) ) | 0 ; $11 = $10 & 255 ; HEAP8 [ $1 >> 0 ] = $11 ; $12 = ( $4 | 0 ) > ( 1 ) ; if ( ! ( $12 ) ) { return ; } $$056 = ( ( ( $1 ) ) + 1 | 0 ) ; $$04960$pn = $2 ; $$05258 = $7 ; $$059 = $$056 ; $14 = $10 ; while ( 1 ) { $$04960 = ( ( ( $$04960$pn ) ) + 1 | 0 ) ; $13 = $14 & 255 ; $15 = HEAP8 [ $$04960 >> 0 ] | 0 ; $16 = $15 & 255 ; $17 = ( ( $16 ) - ( $$05258 ) ) | 0 ; $18 = ( ( $13 ) - ( $$05258 ) ) | 0 ; $19 = ( $17 | 0 ) < ( 0 ) ; $20 = ( 0 - ( $17 ) ) | 0 ; $21 = $19 ? $20 : $17 ; $22 = ( $18 | 0 ) < ( 0 ) ; $23 = ( 0 - ( $18 ) ) | 0 ; $24 = $22 ? $23 : $18 ; $25 = ( ( $17 ) + ( $18 ) ) | 0 ; $26 = ( $25 | 0 ) < ( 0 ) ; $27 = ( 0 - ( $25 ) ) | 0 ; $28 = $26 ? $27 : $25 ; $29 = ( $24 | 0 ) < ( $21 | 0 ) ; $$ = $29 ? $16 : $13 ; $$55 = $29 ? $24 : $21 ; $30 = ( $28 | 0 ) < ( $$55 | 0 ) ; $$2 = $30 ? $$05258 : $$ ; $31 = HEAP8 [ $$059 >> 0 ] | 0 ; $32 = $31 & 255 ; $33 = ( ( $$2 ) + ( $32 ) ) | 0 ; $34 = $33 & 255 ; HEAP8 [ $$059 >> 0 ] = $34 ; $$0 = ( ( ( $$059 ) ) + 1 | 0 ) ; $35 = ( $$0 >>> 0 ) < ( $5 >>> 0 ) ; if ( $35 ) { $$04960$pn = $$04960 ; $$05258 = $16 ; $$059 = $$0 ; $14 = $33 ; } else { break ; } } return ; } function _png_read_filter_row_paeth_multibyte_pixel ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$ = 0 , $$0$lcssa = 0 , $$060$lcssa = 0 , $$06068 = 0 , $$069 = 0 , $$16166 = 0 , $$164 = 0 , $$167 = 0 , $$65 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 ; var $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 ; var $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $exitcond = 0 , label = 0 ; var sp = 0 ; sp = STACKTOP ; $3 = ( ( ( $0 ) ) + 11 | 0 ) ; $4 = HEAP8 [ $3 >> 0 ] | 0 ; $5 = $4 & 255 ; $6 = ( ( $5 ) + 7 ) | 0 ; $7 = $6 >>> 3 ; $8 = ( ( $1 ) + ( $7 ) | 0 ) ; $9 = ( $7 | 0 ) == ( 0 ) ; if ( $9 ) { $$0$lcssa = $1 ; $$060$lcssa = $2 ; } else { $$06068 = $2 ; $$069 = $1 ; while ( 1 ) { $10 = HEAP8 [ $$069 >> 0 ] | 0 ; $11 = $10 & 255 ; $12 = ( ( ( $$06068 ) ) + 1 | 0 ) ; $13 = HEAP8 [ $$06068 >> 0 ] | 0 ; $14 = $13 & 255 ; $15 = ( ( $14 ) + ( $11 ) ) | 0 ; $16 = $15 & 255 ; $17 = ( ( ( $$069 ) ) + 1 | 0 ) ; HEAP8 [ $$069 >> 0 ] = $16 ; $18 = ( $17 >>> 0 ) < ( $8 >>> 0 ) ; if ( $18 ) { $$06068 = $12 ; $$069 = $17 ; } else { $$0$lcssa = $17 ; $$060$lcssa = $12 ; break ; } } } $19 = ( ( ( $0 ) ) + 4 | 0 ) ; $20 = HEAP32 [ $19 >> 2 ] | 0 ; $21 = ( ( $1 ) + ( $20 ) | 0 ) ; $22 = ( $$0$lcssa >>> 0 ) < ( $21 >>> 0 ) ; if ( ! ( $22 ) ) { return ; } $23 = ( 0 - ( $7 ) ) | 0 ; $$16166 = $$060$lcssa ; $$167 = $$0$lcssa ; while ( 1 ) { $24 = ( ( $$16166 ) + ( $23 ) | 0 ) ; $25 = HEAP8 [ $24 >> 0 ] | 0 ; $26 = $25 & 255 ; $27 = ( ( $$167 ) + ( $23 ) | 0 ) ; $28 = HEAP8 [ $27 >> 0 ] | 0 ; $29 = $28 & 255 ; $30 = ( ( ( $$16166 ) ) + 1 | 0 ) ; $31 = HEAP8 [ $$16166 >> 0 ] | 0 ; $32 = $31 & 255 ; $33 = ( ( $32 ) - ( $26 ) ) | 0 ; $34 = ( ( $29 ) - ( $26 ) ) | 0 ; $35 = ( $33 | 0 ) < ( 0 ) ; $36 = ( 0 - ( $33 ) ) | 0 ; $37 = $35 ? $36 : $33 ; $38 = ( $34 | 0 ) < ( 0 ) ; $39 = ( 0 - ( $34 ) ) | 0 ; $40 = $38 ? $39 : $34 ; $41 = ( ( $33 ) + ( $34 ) ) | 0 ; $42 = ( $41 | 0 ) < ( 0 ) ; $43 = ( 0 - ( $41 ) ) | 0 ; $44 = $42 ? $43 : $41 ; $45 = ( $40 | 0 ) < ( $37 | 0 ) ; $$ = $45 ? $32 : $29 ; $$65 = $45 ? $40 : $37 ; $46 = ( $44 | 0 ) < ( $$65 | 0 ) ; $$164 = $46 ? $26 : $$ ; $47 = HEAP8 [ $$167 >> 0 ] | 0 ; $48 = $47 & 255 ; $49 = ( ( $$164 ) + ( $48 ) ) | 0 ; $50 = $49 & 255 ; $51 = ( ( ( $$167 ) ) + 1 | 0 ) ; HEAP8 [ $$167 >> 0 ] = $50 ; $exitcond = ( $51 | 0 ) == ( $21 | 0 ) ; if ( $exitcond ) { break ; } else { $$16166 = $30 ; $$167 = $51 ; } } return ; } function _png_read_IDAT_data ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$ = 0 , $$0$i71 = 0 , $$066 = 0 , $$066$us = 0 , $$1$i = 0 , $$1$i$us = 0 , $$2 = 0 , $$2$lcssa85 = 0 , $$68 = 0 , $$68$us = 0 , $$pre = 0 , $$pre124 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 ; var $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 ; var $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 ; var $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 ; var $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $9 = 0 , $cond = 0 , $cond$us = 0 , $or$cond = 0 , $or$cond145 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 1024 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 1024 | 0 ) ; $3 = sp ; $4 = ( ( ( $0 ) ) + 52 | 0 ) ; HEAP32 [ $4 >> 2 ] = $1 ; $5 = ( ( ( $0 ) ) + 56 | 0 ) ; HEAP32 [ $5 >> 2 ] = 0 ; $6 = ( $1 | 0 ) == ( 0 | 0 ) ; $$ = $6 ? 0 : $2 ; $7 = ( ( ( $0 ) ) + 44 | 0 ) ; $8 = ( $1 | 0 ) != ( 0 | 0 ) ; $9 = ( ( ( $0 ) ) + 232 | 0 ) ; $10 = ( ( ( $0 ) ) + 40 | 0 ) ; $11 = ( ( ( $0 ) ) + 40 | 0 ) ; $12 = ( ( ( $0 ) ) + 196 | 0 ) ; $13 = ( ( ( $0 ) ) + 172 | 0 ) ; $14 = ( ( ( $0 ) ) + 368 | 0 ) ; $15 = ( ( ( $0 ) ) + 360 | 0 ) ; $16 = ( ( ( $0 ) ) + 364 | 0 ) ; L1 : do { if ( $8 ) { $$066$us = $$ ; L2 : while ( 1 ) { $17 = HEAP32 [ $7 >> 2 ] | 0 ; $18 = ( $17 | 0 ) == ( 0 ) ; if ( $18 ) { $$pre124 = HEAP32 [ $12 >> 2 ] | 0 ; $19 = $$pre124 ; while ( 1 ) { $20 = ( $19 | 0 ) == ( 0 ) ; if ( ! ( $20 ) ) { break ; } ( _png_crc_finish ( $0 , 0 ) | 0 ) ; $40 = ( _png_read_chunk_header ( $0 ) | 0 ) ; HEAP32 [ $12 >> 2 ] = $40 ; $41 = HEAP32 [ $13 >> 2 ] | 0 ; $42 = ( $41 | 0 ) == ( 1229209940 ) ; if ( $42 ) { $19 = $40 ; } else { label = 21 ; break L2 ; } } $21 = HEAP32 [ $14 >> 2 ] | 0 ; $22 = ( $21 >>> 0 ) > ( $19 >>> 0 ) ; $$68$us = $22 ? $19 : $21 ; $23 = HEAP32 [ $15 >> 2 ] | 0 ; $24 = ( $23 | 0 ) == ( 0 | 0 ) ; if ( $24 ) { label = 8 ; } else { $25 = HEAP32 [ $16 >> 2 ] | 0 ; $26 = ( $25 >>> 0 ) < ( $$68$us >>> 0 ) ; if ( $26 ) { HEAP32 [ $15 >> 2 ] = 0 ; HEAP32 [ $16 >> 2 ] = 0 ; _png_free ( $0 , $23 ) ; label = 8 ; } else { $$1$i$us = $23 ; } } if ( ( label | 0 ) == 8 ) { label = 0 ; $27 = ( _png_malloc_base ( $0 , $$68$us ) | 0 ) ; $28 = ( $27 | 0 ) == ( 0 | 0 ) ; if ( $28 ) { label = 27 ; break ; } _memset ( ( $27 | 0 ) , 0 , ( $$68$us | 0 ) ) | 0 ; HEAP32 [ $15 >> 2 ] = $27 ; HEAP32 [ $16 >> 2 ] = $$68$us ; $$1$i$us = $27 ; } _png_read_data ( $0 , $$1$i$us , $$68$us ) ; _png_calculate_crc ( $0 , $$1$i$us , $$68$us ) ; $29 = HEAP32 [ $12 >> 2 ] | 0 ; $30 = ( ( $29 ) - ( $$68$us ) ) | 0 ; HEAP32 [ $12 >> 2 ] = $30 ; HEAP32 [ $11 >> 2 ] = $$1$i$us ; HEAP32 [ $7 >> 2 ] = $$68$us ; $33 = $$68$us ; } else { $33 = $17 ; } HEAP32 [ $5 >> 2 ] = $$066$us ; $31 = HEAP8 [ $9 >> 0 ] | 0 ; $32 = ( $31 << 24 >> 24 ) == ( 0 ) ; $34 = ( $33 | 0 ) == ( 0 ) ; $or$cond = $32 | $34 ; if ( ! ( $or$cond ) ) { $35 = HEAP32 [ $11 >> 2 ] | 0 ; $36 = HEAP8 [ $35 >> 0 ] | 0 ; $37 = ( $36 << 24 >> 24 ) < ( 0 ) ; if ( $37 ) { label = 31 ; break L1 ; } HEAP8 [ $9 >> 0 ] = 0 ; } $38 = ( _inflate ( $10 , 0 ) | 0 ) ; $39 = HEAP32 [ $5 >> 2 ] | 0 ; HEAP32 [ $5 >> 2 ] = 0 ; switch ( $38 | 0 ) { case 1 : { $$2$lcssa85 = $39 ; label = 34 ; break L1 ; break ; } case 0 : { break ; } default : { $$0$i71 = $38 ; break L1 ; } } $cond$us = ( $39 | 0 ) == ( 0 ) ; if ( $cond$us ) { label = 45 ; break ; } else { $$066$us = $39 ; } } if ( ( label | 0 ) == 21 ) { _png_error ( $0 , 25786 ) ; // unreachable; } else if ( ( label | 0 ) == 27 ) { _png_chunk_error ( $0 , 25808 ) ; // unreachable; } else if ( ( label | 0 ) == 45 ) { STACKTOP = sp ; return ; } } else { $$066 = $$ ; L27 : while ( 1 ) { $43 = HEAP32 [ $7 >> 2 ] | 0 ; $44 = ( $43 | 0 ) == ( 0 ) ; if ( $44 ) { $$pre = HEAP32 [ $12 >> 2 ] | 0 ; $45 = $$pre ; while ( 1 ) { $46 = ( $45 | 0 ) == ( 0 ) ; if ( ! ( $46 ) ) { break ; } ( _png_crc_finish ( $0 , 0 ) | 0 ) ; $47 = ( _png_read_chunk_header ( $0 ) | 0 ) ; HEAP32 [ $12 >> 2 ] = $47 ; $48 = HEAP32 [ $13 >> 2 ] | 0 ; $49 = ( $48 | 0 ) == ( 1229209940 ) ; if ( $49 ) { $45 = $47 ; } else { label = 21 ; break L27 ; } } $50 = HEAP32 [ $14 >> 2 ] | 0 ; $51 = ( $50 >>> 0 ) > ( $45 >>> 0 ) ; $$68 = $51 ? $45 : $50 ; $52 = HEAP32 [ $15 >> 2 ] | 0 ; $53 = ( $52 | 0 ) == ( 0 | 0 ) ; if ( $53 ) { label = 25 ; } else { $54 = HEAP32 [ $16 >> 2 ] | 0 ; $55 = ( $54 >>> 0 ) < ( $$68 >>> 0 ) ; if ( $55 ) { HEAP32 [ $15 >> 2 ] = 0 ; HEAP32 [ $16 >> 2 ] = 0 ; _png_free ( $0 , $52 ) ; label = 25 ; } else { $$1$i = $52 ; } } if ( ( label | 0 ) == 25 ) { label = 0 ; $56 = ( _png_malloc_base ( $0 , $$68 ) | 0 ) ; $57 = ( $56 | 0 ) == ( 0 | 0 ) ; if ( $57 ) { label = 27 ; break ; } _memset ( ( $56 | 0 ) , 0 , ( $$68 | 0 ) ) | 0 ; HEAP32 [ $15 >> 2 ] = $56 ; HEAP32 [ $16 >> 2 ] = $$68 ; $$1$i = $56 ; } _png_read_data ( $0 , $$1$i , $$68 ) ; _png_calculate_crc ( $0 , $$1$i , $$68 ) ; $58 = HEAP32 [ $12 >> 2 ] | 0 ; $59 = ( ( $58 ) - ( $$68 ) ) | 0 ; HEAP32 [ $12 >> 2 ] = $59 ; HEAP32 [ $11 >> 2 ] = $$1$i ; HEAP32 [ $7 >> 2 ] = $$68 ; $62 = $$68 ; } else { $62 = $43 ; } HEAP32 [ $4 >> 2 ] = $3 ; HEAP32 [ $5 >> 2 ] = 1024 ; $60 = HEAP8 [ $9 >> 0 ] | 0 ; $61 = ( $60 << 24 >> 24 ) == ( 0 ) ; $63 = ( $62 | 0 ) == ( 0 ) ; $or$cond145 = $61 | $63 ; if ( ! ( $or$cond145 ) ) { $64 = HEAP32 [ $11 >> 2 ] | 0 ; $65 = HEAP8 [ $64 >> 0 ] | 0 ; $66 = ( $65 << 24 >> 24 ) < ( 0 ) ; if ( $66 ) { label = 31 ; break L1 ; } HEAP8 [ $9 >> 0 ] = 0 ; } $68 = ( _inflate ( $10 , 0 ) | 0 ) ; $69 = HEAP32 [ $5 >> 2 ] | 0 ; $70 = ( 1024 - ( $69 ) ) | 0 ; $$2 = ( ( $70 ) + ( $$066 ) ) | 0 ; HEAP32 [ $5 >> 2 ] = 0 ; switch ( $68 | 0 ) { case 1 : { $$2$lcssa85 = $$2 ; label = 34 ; break L1 ; break ; } case 0 : { break ; } default : { $$0$i71 = $68 ; break L1 ; } } $cond = ( $$2 | 0 ) == ( 0 ) ; if ( $cond ) { label = 45 ; break ; } else { $$066 = $$2 ; } } if ( ( label | 0 ) == 21 ) { _png_error ( $0 , 25786 ) ; // unreachable; } else if ( ( label | 0 ) == 27 ) { _png_chunk_error ( $0 , 25808 ) ; // unreachable; } else if ( ( label | 0 ) == 45 ) { STACKTOP = sp ; return ; } } } while ( 0 ) ; if ( ( label | 0 ) == 31 ) { $67 = ( ( ( $0 ) ) + 64 | 0 ) ; HEAP32 [ $67 >> 2 ] = 25384 ; HEAP32 [ $5 >> 2 ] = 0 ; $$0$i71 = - 3 ; } else if ( ( label | 0 ) == 34 ) { HEAP32 [ $4 >> 2 ] = 0 ; $71 = ( ( ( $0 ) ) + 24 | 0 ) ; $72 = HEAP32 [ $71 >> 2 ] | 0 ; $73 = $72 | 8 ; HEAP32 [ $71 >> 2 ] = $73 ; $74 = ( ( ( $0 ) ) + 28 | 0 ) ; $75 = HEAP32 [ $74 >> 2 ] | 0 ; $76 = $75 | 8 ; HEAP32 [ $74 >> 2 ] = $76 ; $77 = HEAP32 [ $7 >> 2 ] | 0 ; $78 = ( $77 | 0 ) == ( 0 ) ; if ( $78 ) { $79 = HEAP32 [ $12 >> 2 ] | 0 ; $80 = ( $79 | 0 ) == ( 0 ) ; if ( ! ( $80 ) ) { label = 36 ; } } else { label = 36 ; } if ( ( label | 0 ) == 36 ) { _png_chunk_benign_error ( $0 , 25842 ) ; } $83 = ( $$2$lcssa85 | 0 ) == ( 0 ) ; if ( $83 ) { STACKTOP = sp ; return ; } if ( $8 ) { _png_error ( $0 , 25786 ) ; // unreachable; } _png_chunk_benign_error ( $0 , 25864 ) ; STACKTOP = sp ; return ; } _png_zstream_error ( $0 , $$0$i71 ) ; $81 = ( ( ( $0 ) ) + 64 | 0 ) ; $82 = HEAP32 [ $81 >> 2 ] | 0 ; if ( $8 ) { _png_chunk_error ( $0 , $82 ) ; // unreachable; } _png_chunk_benign_error ( $0 , $82 ) ; STACKTOP = sp ; return ; } function _png_read_finish_IDAT ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 ; var sp = 0 ; sp = STACKTOP ; $1 = ( ( ( $0 ) ) + 28 | 0 ) ; $2 = HEAP32 [ $1 >> 2 ] | 0 ; $3 = $2 & 8 ; $4 = ( $3 | 0 ) == ( 0 ) ; if ( $4 ) { _png_read_IDAT_data ( $0 , 0 , 0 ) ; $5 = ( ( ( $0 ) ) + 52 | 0 ) ; HEAP32 [ $5 >> 2 ] = 0 ; $6 = HEAP32 [ $1 >> 2 ] | 0 ; $7 = $6 & 8 ; $8 = ( $7 | 0 ) == ( 0 ) ; if ( $8 ) { $9 = ( ( ( $0 ) ) + 24 | 0 ) ; $10 = HEAP32 [ $9 >> 2 ] | 0 ; $11 = $10 | 8 ; HEAP32 [ $9 >> 2 ] = $11 ; $12 = $6 | 8 ; HEAP32 [ $1 >> 2 ] = $12 ; } } $13 = ( ( ( $0 ) ) + 36 | 0 ) ; $14 = HEAP32 [ $13 >> 2 ] | 0 ; $15 = ( $14 | 0 ) == ( 1229209940 ) ; if ( ! ( $15 ) ) { return ; } $16 = ( ( ( $0 ) ) + 40 | 0 ) ; HEAP32 [ $16 >> 2 ] = 0 ; $17 = ( ( ( $0 ) ) + 44 | 0 ) ; HEAP32 [ $17 >> 2 ] = 0 ; HEAP32 [ $13 >> 2 ] = 0 ; $18 = ( ( ( $0 ) ) + 196 | 0 ) ; $19 = HEAP32 [ $18 >> 2 ] | 0 ; ( _png_crc_finish ( $0 , $19 ) | 0 ) ; return ; } function _png_read_finish_row ( $0 ) { $0 = $0 | 0 ; var $$lcssa = 0 , $$pre = 0 , $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 ; var $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 ; var $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 ; var $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 ; var $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $9 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( ( ( $0 ) ) + 168 | 0 ) ; $2 = HEAP32 [ $1 >> 2 ] | 0 ; $3 = ( ( $2 ) + 1 ) | 0 ; HEAP32 [ $1 >> 2 ] = $3 ; $4 = ( ( ( $0 ) ) + 152 | 0 ) ; $5 = HEAP32 [ $4 >> 2 ] | 0 ; $6 = ( $3 >>> 0 ) < ( $5 >>> 0 ) ; if ( $6 ) { return ; } $7 = ( ( ( $0 ) ) + 220 | 0 ) ; $8 = HEAP8 [ $7 >> 0 ] | 0 ; $9 = ( $8 << 24 >> 24 ) == ( 0 ) ; L4 : do { if ( ! ( $9 ) ) { HEAP32 [ $1 >> 2 ] = 0 ; $10 = ( ( ( $0 ) ) + 176 | 0 ) ; $11 = HEAP32 [ $10 >> 2 ] | 0 ; $12 = ( ( ( $0 ) ) + 160 | 0 ) ; $13 = HEAP32 [ $12 >> 2 ] | 0 ; $14 = ( ( $13 ) + 1 ) | 0 ; _memset ( ( $11 | 0 ) , 0 , ( $14 | 0 ) ) | 0 ; $15 = ( ( ( $0 ) ) + 221 | 0 ) ; $16 = HEAP8 [ $15 >> 0 ] | 0 ; $17 = ( ( $16 ) + 1 ) << 24 >> 24 ; HEAP8 [ $15 >> 0 ] = $17 ; $18 = $17 & 255 ; $19 = ( $17 & 255 ) > ( 6 ) ; if ( ! ( $19 ) ) { $20 = ( ( ( $0 ) ) + 144 | 0 ) ; $21 = HEAP32 [ $20 >> 2 ] | 0 ; $22 = ( ( $21 ) + - 1 ) | 0 ; $23 = ( ( ( $0 ) ) + 164 | 0 ) ; $24 = ( ( ( $0 ) ) + 32 | 0 ) ; $25 = HEAP32 [ $24 >> 2 ] | 0 ; $26 = $25 & 2 ; $27 = ( $26 | 0 ) == ( 0 ) ; do { if ( $27 ) { $28 = ( ( ( $0 ) ) + 148 | 0 ) ; $$pre = HEAP32 [ $28 >> 2 ] | 0 ; $29 = ( ( $$pre ) + - 1 ) | 0 ; $31 = $18 ; $40 = $17 ; while ( 1 ) { $30 = ( 28419 + ( $31 ) | 0 ) ; $32 = HEAP8 [ $30 >> 0 ] | 0 ; $33 = $32 & 255 ; $34 = ( 28426 + ( $31 ) | 0 ) ; $35 = HEAP8 [ $34 >> 0 ] | 0 ; $36 = $35 & 255 ; $37 = ( ( $22 ) + ( $33 ) ) | 0 ; $38 = ( ( $37 ) - ( $36 ) ) | 0 ; $39 = $40 & 255 ; $41 = ( 28433 + ( $39 ) | 0 ) ; $42 = HEAP8 [ $41 >> 0 ] | 0 ; $43 = $42 & 255 ; $44 = ( 28440 + ( $39 ) | 0 ) ; $45 = HEAP8 [ $44 >> 0 ] | 0 ; $46 = $45 & 255 ; $47 = ( ( $29 ) + ( $43 ) ) | 0 ; $48 = ( ( $47 ) - ( $46 ) ) | 0 ; $49 = ( $48 >>> 0 ) < ( $43 >>> 0 ) ; $50 = ( $38 >>> 0 ) < ( $33 >>> 0 ) ; $or$cond = $49 | $50 ; if ( ! ( $or$cond ) ) { label = 9 ; break ; } $51 = ( ( $40 ) + 1 ) << 24 >> 24 ; HEAP8 [ $15 >> 0 ] = $51 ; $52 = $51 & 255 ; $53 = ( $51 & 255 ) > ( 6 ) ; if ( $53 ) { label = 11 ; break ; } else { $31 = $52 ; $40 = $51 ; } } if ( ( label | 0 ) == 9 ) { $63 = ( ( $48 >>> 0 ) / ( $43 >>> 0 ) ) & - 1 ; HEAP32 [ $4 >> 2 ] = $63 ; $64 = ( ( $38 >>> 0 ) / ( $33 >>> 0 ) ) & - 1 ; $$lcssa = $64 ; break ; } else if ( ( label | 0 ) == 11 ) { $65 = ( ( $48 >>> 0 ) / ( $43 >>> 0 ) ) & - 1 ; HEAP32 [ $4 >> 2 ] = $65 ; $66 = ( ( $38 >>> 0 ) / ( $33 >>> 0 ) ) & - 1 ; HEAP32 [ $23 >> 2 ] = $66 ; break L4 ; } } else { $54 = ( 28419 + ( $18 ) | 0 ) ; $55 = HEAP8 [ $54 >> 0 ] | 0 ; $56 = $55 & 255 ; $57 = ( 28426 + ( $18 ) | 0 ) ; $58 = HEAP8 [ $57 >> 0 ] | 0 ; $59 = $58 & 255 ; $60 = ( ( $22 ) + ( $56 ) ) | 0 ; $61 = ( ( $60 ) - ( $59 ) ) | 0 ; $62 = ( ( $61 >>> 0 ) / ( $56 >>> 0 ) ) & - 1 ; $$lcssa = $62 ; } } while ( 0 ) ; HEAP32 [ $23 >> 2 ] = $$lcssa ; return ; } } } while ( 0 ) ; $67 = ( ( ( $0 ) ) + 28 | 0 ) ; $68 = HEAP32 [ $67 >> 2 ] | 0 ; $69 = $68 & 8 ; $70 = ( $69 | 0 ) == ( 0 ) ; if ( $70 ) { _png_read_IDAT_data ( $0 , 0 , 0 ) ; $71 = ( ( ( $0 ) ) + 52 | 0 ) ; HEAP32 [ $71 >> 2 ] = 0 ; $72 = HEAP32 [ $67 >> 2 ] | 0 ; $73 = $72 & 8 ; $74 = ( $73 | 0 ) == ( 0 ) ; $75 = ( ( ( $0 ) ) + 24 | 0 ) ; if ( $74 ) { $76 = $72 | 8 ; $77 = HEAP32 [ $75 >> 2 ] | 0 ; $78 = $77 | 8 ; HEAP32 [ $75 >> 2 ] = $78 ; HEAP32 [ $67 >> 2 ] = $76 ; } } $79 = ( ( ( $0 ) ) + 36 | 0 ) ; $80 = HEAP32 [ $79 >> 2 ] | 0 ; $81 = ( $80 | 0 ) == ( 1229209940 ) ; if ( ! ( $81 ) ) { return ; } $82 = ( ( ( $0 ) ) + 40 | 0 ) ; HEAP32 [ $82 >> 2 ] = 0 ; $83 = ( ( ( $0 ) ) + 44 | 0 ) ; HEAP32 [ $83 >> 2 ] = 0 ; HEAP32 [ $79 >> 2 ] = 0 ; $84 = ( ( ( $0 ) ) + 196 | 0 ) ; $85 = HEAP32 [ $84 >> 2 ] | 0 ; ( _png_crc_finish ( $0 , $85 ) | 0 ) ; return ; } function _png_read_start_row ( $0 ) { $0 = $0 | 0 ; var $$04$i = 0 , $$pre = 0 , $$sink = 0 , $$sink$sink = 0 , $$sink3 = 0 , $$sink6 = 0 , $1 = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 ; var $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 ; var $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 ; var $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 ; var $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 ; var $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 ; var $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 64 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 64 | 0 ) ; $1 = sp ; _png_init_read_transformations ( $0 ) ; $2 = ( ( ( $0 ) ) + 220 | 0 ) ; $3 = HEAP8 [ $2 >> 0 ] | 0 ; $4 = ( $3 << 24 >> 24 ) == ( 0 ) ; if ( $4 ) { $28 = ( ( ( $0 ) ) + 148 | 0 ) ; $29 = HEAP32 [ $28 >> 2 ] | 0 ; $30 = ( ( ( $0 ) ) + 144 | 0 ) ; $31 = HEAP32 [ $30 >> 2 ] | 0 ; $$sink$sink = $29 ; $$sink3 = $31 ; $40 = $31 ; } else { $5 = ( ( ( $0 ) ) + 32 | 0 ) ; $6 = HEAP32 [ $5 >> 2 ] | 0 ; $7 = $6 & 2 ; $8 = ( $7 | 0 ) == ( 0 ) ; $9 = ( ( ( $0 ) ) + 148 | 0 ) ; $10 = HEAP32 [ $9 >> 2 ] | 0 ; $11 = ( ( $10 ) + 7 ) | 0 ; $12 = $11 >>> 3 ; $$sink = $8 ? $12 : $10 ; $13 = ( ( ( $0 ) ) + 144 | 0 ) ; $14 = HEAP32 [ $13 >> 2 ] | 0 ; $15 = ( ( ( $0 ) ) + 221 | 0 ) ; $16 = HEAP8 [ $15 >> 0 ] | 0 ; $17 = $16 & 255 ; $18 = ( 28419 + ( $17 ) | 0 ) ; $19 = HEAP8 [ $18 >> 0 ] | 0 ; $20 = $19 & 255 ; $21 = ( 28426 + ( $17 ) | 0 ) ; $22 = HEAP8 [ $21 >> 0 ] | 0 ; $23 = $22 & 255 ; $24 = ( ( $14 ) + - 1 ) | 0 ; $25 = ( ( $24 ) + ( $20 ) ) | 0 ; $26 = ( ( $25 ) - ( $23 ) ) | 0 ; $27 = ( ( $26 >>> 0 ) / ( $20 >>> 0 ) ) & - 1 ; $$sink$sink = $$sink ; $$sink3 = $27 ; $40 = $14 ; } $32 = ( ( ( $0 ) ) + 152 | 0 ) ; HEAP32 [ $32 >> 2 ] = $$sink$sink ; $33 = ( ( ( $0 ) ) + 164 | 0 ) ; HEAP32 [ $33 >> 2 ] = $$sink3 ; $34 = ( ( ( $0 ) ) + 226 | 0 ) ; $35 = HEAP8 [ $34 >> 0 ] | 0 ; $36 = $35 & 255 ; $37 = ( ( ( $0 ) ) + 230 | 0 ) ; HEAP8 [ $37 >> 0 ] = $35 ; $38 = ( ( ( $0 ) ) + 231 | 0 ) ; HEAP8 [ $38 >> 0 ] = 0 ; $39 = ( ( $40 ) + 7 ) | 0 ; $41 = $39 & - 8 ; $42 = ( $35 & 255 ) > ( 7 ) ; $43 = $36 >>> 3 ; $44 = Math_imul ( $41 , $43 ) | 0 ; $45 = Math_imul ( $41 , $36 ) | 0 ; $46 = $45 >>> 3 ; $47 = $42 ? $44 : $46 ; $48 = ( ( $36 ) + 7 ) | 0 ; $49 = $48 >>> 3 ; $50 = ( ( $49 ) + 49 ) | 0 ; $51 = ( ( $50 ) + ( $47 ) ) | 0 ; $52 = ( ( ( $0 ) ) + 356 | 0 ) ; $53 = HEAP32 [ $52 >> 2 ] | 0 ; $54 = ( $51 >>> 0 ) > ( $53 >>> 0 ) ; if ( $54 ) { $55 = ( ( ( $0 ) ) + 312 | 0 ) ; $56 = HEAP32 [ $55 >> 2 ] | 0 ; _png_free ( $0 , $56 ) ; $57 = ( ( ( $0 ) ) + 376 | 0 ) ; $58 = HEAP32 [ $57 >> 2 ] | 0 ; _png_free ( $0 , $58 ) ; $59 = HEAP8 [ $2 >> 0 ] | 0 ; $60 = ( $59 << 24 >> 24 ) == ( 0 ) ; if ( $60 ) { $62 = ( _png_malloc ( $0 , $51 ) | 0 ) ; $$sink6 = $62 ; } else { $61 = ( _png_calloc ( $0 , $51 ) | 0 ) ; $$sink6 = $61 ; } HEAP32 [ $55 >> 2 ] = $$sink6 ; $63 = ( _png_malloc ( $0 , $51 ) | 0 ) ; HEAP32 [ $57 >> 2 ] = $63 ; $64 = HEAP32 [ $55 >> 2 ] | 0 ; $65 = ( ( ( $64 ) ) + 32 | 0 ) ; $66 = $65 ; $67 = $66 & 15 ; $68 = ( 0 - ( $67 ) ) | 0 ; $69 = ( ( $65 ) + ( $68 ) | 0 ) ; $70 = ( ( ( $69 ) ) + - 1 | 0 ) ; $71 = ( ( ( $0 ) ) + 180 | 0 ) ; HEAP32 [ $71 >> 2 ] = $70 ; $72 = ( ( ( $63 ) ) + 32 | 0 ) ; $73 = $72 ; $74 = $73 & 15 ; $75 = ( 0 - ( $74 ) ) | 0 ; $76 = ( ( $72 ) + ( $75 ) | 0 ) ; $77 = ( ( ( $76 ) ) + - 1 | 0 ) ; $78 = ( ( ( $0 ) ) + 176 | 0 ) ; HEAP32 [ $78 >> 2 ] = $77 ; HEAP32 [ $52 >> 2 ] = $51 ; } $79 = ( ( ( $0 ) ) + 160 | 0 ) ; $80 = HEAP32 [ $79 >> 2 ] | 0 ; $81 = ( $80 | 0 ) == ( - 1 ) ; if ( $81 ) { _png_error ( $0 , 25884 ) ; // unreachable; } $82 = ( ( ( $0 ) ) + 176 | 0 ) ; $83 = HEAP32 [ $82 >> 2 ] | 0 ; $84 = ( ( $80 ) + 1 ) | 0 ; _memset ( ( $83 | 0 ) , 0 , ( $84 | 0 ) ) | 0 ; $85 = ( ( ( $0 ) ) + 360 | 0 ) ; $86 = HEAP32 [ $85 >> 2 ] | 0 ; $87 = ( $86 | 0 ) == ( 0 | 0 ) ; if ( ! ( $87 ) ) { $88 = ( ( ( $0 ) ) + 364 | 0 ) ; HEAP32 [ $88 >> 2 ] = 0 ; HEAP32 [ $85 >> 2 ] = 0 ; _png_free ( $0 , $86 ) ; } $89 = ( ( ( $0 ) ) + 36 | 0 ) ; $90 = HEAP32 [ $89 >> 2 ] | 0 ; $91 = ( $90 | 0 ) == ( 0 ) ; if ( ! ( $91 ) ) { $92 = $90 >>> 24 ; $93 = $92 & 255 ; HEAP8 [ $1 >> 0 ] = $93 ; $94 = $90 >>> 16 ; $95 = $94 & 255 ; $96 = ( ( ( $1 ) ) + 1 | 0 ) ; HEAP8 [ $96 >> 0 ] = $95 ; $97 = $90 >>> 8 ; $98 = $97 & 255 ; $99 = ( ( ( $1 ) ) + 2 | 0 ) ; HEAP8 [ $99 >> 0 ] = $98 ; $100 = $90 & 255 ; $101 = ( ( ( $1 ) ) + 3 | 0 ) ; HEAP8 [ $101 >> 0 ] = $100 ; ( _png_safecat ( $1 , 64 , 4 , 27876 ) | 0 ) ; _png_chunk_warning ( $0 , $1 ) ; HEAP32 [ $89 >> 2 ] = 0 ; } $102 = ( ( ( $0 ) ) + 40 | 0 ) ; HEAP32 [ $102 >> 2 ] = 0 ; $103 = ( ( ( $0 ) ) + 44 | 0 ) ; HEAP32 [ $103 >> 2 ] = 0 ; $104 = ( ( ( $0 ) ) + 52 | 0 ) ; HEAP32 [ $104 >> 2 ] = 0 ; $105 = ( ( ( $0 ) ) + 56 | 0 ) ; HEAP32 [ $105 >> 2 ] = 0 ; $106 = ( ( ( $0 ) ) + 28 | 0 ) ; $107 = HEAP32 [ $106 >> 2 ] | 0 ; $108 = $107 & 2 ; $109 = ( $108 | 0 ) == ( 0 ) ; if ( $109 ) { $110 = ( _inflateInit2_ ( $102 , 0 , 29663 , 56 ) | 0 ) ; $111 = ( $110 | 0 ) == ( 0 ) ; if ( ! ( $111 ) ) { $$04$i = $110 ; _png_zstream_error ( $0 , $$04$i ) ; $116 = ( ( ( $0 ) ) + 64 | 0 ) ; $117 = HEAP32 [ $116 >> 2 ] | 0 ; _png_error ( $0 , $117 ) ; // unreachable; } $112 = HEAP32 [ $106 >> 2 ] | 0 ; $113 = $112 | 2 ; HEAP32 [ $106 >> 2 ] = $113 ; $119 = $113 ; HEAP32 [ $89 >> 2 ] = 1229209940 ; $118 = $119 | 64 ; HEAP32 [ $106 >> 2 ] = $118 ; STACKTOP = sp ; return ; } else { $114 = ( _inflateReset2 ( $102 , 0 ) | 0 ) ; $115 = ( $114 | 0 ) == ( 0 ) ; if ( ! ( $115 ) ) { $$04$i = $114 ; _png_zstream_error ( $0 , $$04$i ) ; $116 = ( ( ( $0 ) ) + 64 | 0 ) ; $117 = HEAP32 [ $116 >> 2 ] | 0 ; _png_error ( $0 , $117 ) ; // unreachable; } $$pre = HEAP32 [ $106 >> 2 ] | 0 ; $119 = $$pre ; HEAP32 [ $89 >> 2 ] = 1229209940 ; $118 = $119 | 64 ; HEAP32 [ $106 >> 2 ] = $118 ; STACKTOP = sp ; return ; } } function _png_set_bKGD ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , $or$cond3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( $0 | 0 ) == ( 0 | 0 ) ; $4 = ( $1 | 0 ) == ( 0 | 0 ) ; $or$cond = $3 | $4 ; $5 = ( $2 | 0 ) == ( 0 | 0 ) ; $or$cond3 = $or$cond | $5 ; if ( $or$cond3 ) { return ; } $6 = ( ( ( $1 ) ) + 62 | 0 ) ; ; HEAP16 [ $6 >> 1 ] = HEAP16 [ $2 >> 1 ] | 0 ; HEAP16 [ $6 + 2 >> 1 ] = HEAP16 [ $2 + 2 >> 1 ] | 0 ; HEAP16 [ $6 + 4 >> 1 ] = HEAP16 [ $2 + 4 >> 1 ] | 0 ; HEAP16 [ $6 + 6 >> 1 ] = HEAP16 [ $2 + 6 >> 1 ] | 0 ; HEAP16 [ $6 + 8 >> 1 ] = HEAP16 [ $2 + 8 >> 1 ] | 0 ; $7 = ( ( ( $1 ) ) + 8 | 0 ) ; $8 = HEAP32 [ $7 >> 2 ] | 0 ; $9 = $8 | 32 ; HEAP32 [ $7 >> 2 ] = $9 ; return ; } function _png_set_hIST ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$022 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $3 = 0 , $4 = 0 , $5 = 0 ; var $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( $0 | 0 ) == ( 0 | 0 ) ; $4 = ( $1 | 0 ) == ( 0 | 0 ) ; $or$cond = $3 | $4 ; if ( $or$cond ) { return ; } $5 = ( ( ( $1 ) ) + 20 | 0 ) ; $6 = HEAP16 [ $5 >> 1 ] | 0 ; $7 = ( ( $6 ) + - 1 ) << 16 >> 16 ; $8 = ( $7 & 65535 ) > ( 255 ) ; if ( $8 ) { _png_warning ( $0 , 25929 ) ; return ; } _png_free_data ( $0 , $1 , 8 , 0 ) ; $9 = ( _png_malloc_warn ( $0 , 512 ) | 0 ) ; $10 = ( ( ( $1 ) ) + 72 | 0 ) ; HEAP32 [ $10 >> 2 ] = $9 ; $11 = ( $9 | 0 ) == ( 0 | 0 ) ; if ( $11 ) { _png_warning ( $0 , 25975 ) ; return ; } $12 = ( ( ( $1 ) ) + 76 | 0 ) ; $13 = HEAP32 [ $12 >> 2 ] | 0 ; $14 = $13 | 8 ; HEAP32 [ $12 >> 2 ] = $14 ; $15 = HEAP16 [ $5 >> 1 ] | 0 ; $16 = ( $15 << 16 >> 16 ) == ( 0 ) ; if ( ! ( $16 ) ) { $17 = $15 & 65535 ; $$022 = 0 ; while ( 1 ) { $18 = ( ( $2 ) + ( $$022 << 1 ) | 0 ) ; $19 = HEAP16 [ $18 >> 1 ] | 0 ; $20 = ( ( $9 ) + ( $$022 << 1 ) | 0 ) ; HEAP16 [ $20 >> 1 ] = $19 ; $21 = ( ( $$022 ) + 1 ) | 0 ; $22 = ( $21 | 0 ) < ( $17 | 0 ) ; if ( $22 ) { $$022 = $21 ; } else { break ; } } } $23 = ( ( ( $1 ) ) + 8 | 0 ) ; $24 = HEAP32 [ $23 >> 2 ] | 0 ; $25 = $24 | 64 ; HEAP32 [ $23 >> 2 ] = $25 ; return ; } function _png_set_IHDR ( $0 , $1 , $2 , $3 , $4 , $5 , $6 , $7 , $8 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; $4 = $4 | 0 ; $5 = $5 | 0 ; $6 = $6 | 0 ; $7 = $7 | 0 ; $8 = $8 | 0 ; var $$ = 0 , $$36 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 ; var $28 = 0 , $29 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 ; var $48 = 0 , $49 = 0 , $50 = 0 , $9 = 0 , $or$cond = 0 , $storemerge = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $9 = ( $0 | 0 ) == ( 0 | 0 ) ; $10 = ( $1 | 0 ) == ( 0 | 0 ) ; $or$cond = $9 | $10 ; if ( $or$cond ) { return ; } HEAP32 [ $1 >> 2 ] = $2 ; $11 = ( ( ( $1 ) ) + 4 | 0 ) ; HEAP32 [ $11 >> 2 ] = $3 ; $12 = $4 & 255 ; $13 = ( ( ( $1 ) ) + 24 | 0 ) ; HEAP8 [ $13 >> 0 ] = $12 ; $14 = $5 & 255 ; $15 = ( ( ( $1 ) ) + 25 | 0 ) ; HEAP8 [ $15 >> 0 ] = $14 ; $16 = $7 & 255 ; $17 = ( ( ( $1 ) ) + 26 | 0 ) ; HEAP8 [ $17 >> 0 ] = $16 ; $18 = $8 & 255 ; $19 = ( ( ( $1 ) ) + 27 | 0 ) ; HEAP8 [ $19 >> 0 ] = $18 ; $20 = $6 & 255 ; $21 = ( ( ( $1 ) ) + 28 | 0 ) ; HEAP8 [ $21 >> 0 ] = $20 ; $22 = $4 & 255 ; $23 = $5 & 255 ; $24 = $6 & 255 ; $25 = $7 & 255 ; $26 = $8 & 255 ; _png_check_IHDR ( $0 , $2 , $3 , $22 , $23 , $24 , $25 , $26 ) ; $27 = HEAP8 [ $15 >> 0 ] | 0 ; $28 = ( $27 << 24 >> 24 ) == ( 3 ) ; if ( $28 ) { $36 = 1 ; $storemerge = 1 ; } else { $29 = $27 & 2 ; $30 = $29 | 1 ; $31 = $27 & 4 ; $32 = ( $31 << 24 >> 24 ) == ( 0 ) ; $33 = ( ( $30 ) + 1 ) << 24 >> 24 ; $$ = $32 ? $30 : $33 ; $$36 = $32 ? $30 : $33 ; $36 = $$36 ; $storemerge = $$ ; } $34 = ( ( ( $1 ) ) + 29 | 0 ) ; HEAP8 [ $34 >> 0 ] = $storemerge ; $35 = $36 & 255 ; $37 = HEAP8 [ $13 >> 0 ] | 0 ; $38 = $37 & 255 ; $39 = Math_imul ( $38 , $35 ) | 0 ; $40 = $39 & 255 ; $41 = ( ( ( $1 ) ) + 30 | 0 ) ; HEAP8 [ $41 >> 0 ] = $40 ; $42 = $39 & 255 ; $43 = ( $42 >>> 0 ) > ( 7 ) ; if ( $43 ) { $44 = $42 >>> 3 ; $45 = Math_imul ( $44 , $2 ) | 0 ; $50 = $45 ; } else { $46 = Math_imul ( $42 , $2 ) | 0 ; $47 = ( ( $46 ) + 7 ) | 0 ; $48 = $47 >>> 3 ; $50 = $48 ; } $49 = ( ( ( $1 ) ) + 12 | 0 ) ; HEAP32 [ $49 >> 2 ] = $50 ; return ; } function _png_set_PLTE ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $30 = 0 , $31 = 0 , $32 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , $or$cond3 = 0 , $or$cond32 = 0 , $or$cond5 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $4 = ( $0 | 0 ) == ( 0 | 0 ) ; $5 = ( $1 | 0 ) == ( 0 | 0 ) ; $or$cond = $4 | $5 ; if ( $or$cond ) { return ; } $6 = ( ( ( $1 ) ) + 25 | 0 ) ; $7 = HEAP8 [ $6 >> 0 ] | 0 ; $8 = ( $7 << 24 >> 24 ) == ( 3 ) ; if ( $8 ) { $9 = ( ( ( $1 ) ) + 24 | 0 ) ; $10 = HEAP8 [ $9 >> 0 ] | 0 ; $11 = $10 & 255 ; $12 = 1 << $11 ; $14 = $12 ; } else { $14 = 256 ; } $13 = ( $3 | 0 ) < ( 0 ) ; $15 = ( $14 | 0 ) < ( $3 | 0 ) ; $or$cond32 = $13 | $15 ; if ( $or$cond32 ) { if ( $8 ) { _png_error ( $0 , 26015 ) ; // unreachable; } _png_warning ( $0 , 26015 ) ; return ; } $16 = ( $3 | 0 ) > ( 0 ) ; $17 = ( $2 | 0 ) == ( 0 | 0 ) ; $or$cond3 = $17 & $16 ; $18 = ( $3 | 0 ) == ( 0 ) ; $or$cond5 = $18 | $or$cond3 ; if ( $or$cond5 ) { _png_error ( $0 , 26038 ) ; // unreachable; } _png_free_data ( $0 , $1 , 4096 , 0 ) ; $19 = ( _png_calloc ( $0 , 768 ) | 0 ) ; $20 = ( ( ( $0 ) ) + 204 | 0 ) ; HEAP32 [ $20 >> 2 ] = $19 ; $21 = $19 ; if ( $16 ) { $22 = ( $3 * 3 ) | 0 ; _memcpy ( ( $19 | 0 ) , ( $2 | 0 ) , ( $22 | 0 ) ) | 0 ; } $23 = ( ( ( $1 ) ) + 16 | 0 ) ; HEAP32 [ $23 >> 2 ] = $21 ; $24 = $3 & 65535 ; $25 = ( ( ( $0 ) ) + 208 | 0 ) ; HEAP16 [ $25 >> 1 ] = $24 ; $26 = ( ( ( $1 ) ) + 20 | 0 ) ; HEAP16 [ $26 >> 1 ] = $24 ; $27 = ( ( ( $1 ) ) + 76 | 0 ) ; $28 = HEAP32 [ $27 >> 2 ] | 0 ; $29 = $28 | 4096 ; HEAP32 [ $27 >> 2 ] = $29 ; $30 = ( ( ( $1 ) ) + 8 | 0 ) ; $31 = HEAP32 [ $30 >> 2 ] | 0 ; $32 = $31 | 8 ; HEAP32 [ $30 >> 2 ] = $32 ; return ; } function _png_set_sBIT ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , $or$cond3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( $0 | 0 ) == ( 0 | 0 ) ; $4 = ( $1 | 0 ) == ( 0 | 0 ) ; $or$cond = $3 | $4 ; $5 = ( $2 | 0 ) == ( 0 | 0 ) ; $or$cond3 = $or$cond | $5 ; if ( $or$cond3 ) { return ; } $6 = ( ( ( $1 ) ) + 40 | 0 ) ; ; HEAP8 [ $6 >> 0 ] = HEAP8 [ $2 >> 0 ] | 0 ; HEAP8 [ $6 + 1 >> 0 ] = HEAP8 [ $2 + 1 >> 0 ] | 0 ; HEAP8 [ $6 + 2 >> 0 ] = HEAP8 [ $2 + 2 >> 0 ] | 0 ; HEAP8 [ $6 + 3 >> 0 ] = HEAP8 [ $2 + 3 >> 0 ] | 0 ; HEAP8 [ $6 + 4 >> 0 ] = HEAP8 [ $2 + 4 >> 0 ] | 0 ; $7 = ( ( ( $1 ) ) + 8 | 0 ) ; $8 = HEAP32 [ $7 >> 2 ] | 0 ; $9 = $8 | 2 ; HEAP32 [ $7 >> 2 ] = $9 ; return ; } function _png_set_tRNS ( $0 , $1 , $2 , $3 , $4 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; $4 = $4 | 0 ; var $$off = 0 , $$phi$trans$insert = 0 , $$pre = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 ; var $27 = 0 , $28 = 0 , $29 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 ; var $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $5 = ( $0 | 0 ) == ( 0 | 0 ) ; $6 = ( $1 | 0 ) == ( 0 | 0 ) ; $or$cond = $5 | $6 ; if ( $or$cond ) { return ; } $7 = ( $2 | 0 ) == ( 0 | 0 ) ; if ( ! ( $7 ) ) { _png_free_data ( $0 , $1 , 8192 , 0 ) ; $$off = ( ( $3 ) + - 1 ) | 0 ; $8 = ( $$off >>> 0 ) < ( 256 ) ; if ( $8 ) { $9 = ( _png_malloc ( $0 , 256 ) | 0 ) ; $10 = ( ( ( $1 ) ) + 48 | 0 ) ; HEAP32 [ $10 >> 2 ] = $9 ; _memcpy ( ( $9 | 0 ) , ( $2 | 0 ) , ( $3 | 0 ) ) | 0 ; $11 = $9 ; $13 = $11 ; } else { $$phi$trans$insert = ( ( ( $1 ) ) + 48 | 0 ) ; $$pre = HEAP32 [ $$phi$trans$insert >> 2 ] | 0 ; $13 = $$pre ; } $12 = ( ( ( $0 ) ) + 272 | 0 ) ; HEAP32 [ $12 >> 2 ] = $13 ; } $14 = ( $4 | 0 ) == ( 0 | 0 ) ; if ( $14 ) { $43 = $3 & 65535 ; $44 = ( ( ( $1 ) ) + 22 | 0 ) ; HEAP16 [ $44 >> 1 ] = $43 ; $45 = ( $3 | 0 ) == ( 0 ) ; if ( $45 ) { return ; } } else { $15 = ( ( ( $1 ) ) + 24 | 0 ) ; $16 = HEAP8 [ $15 >> 0 ] | 0 ; $17 = ( $16 & 255 ) < ( 16 ) ; L15 : do { if ( $17 ) { $18 = $16 & 255 ; $19 = 1 << $18 ; $20 = ( ( ( $1 ) ) + 25 | 0 ) ; $21 = HEAP8 [ $20 >> 0 ] | 0 ; switch ( $21 << 24 >> 24 ) { case 0 : { $22 = ( ( ( $4 ) ) + 8 | 0 ) ; $23 = HEAP16 [ $22 >> 1 ] | 0 ; $24 = $23 & 65535 ; $25 = ( $19 | 0 ) > ( $24 | 0 ) ; if ( $25 ) { break L15 ; } break ; } case 2 : { $26 = ( ( ( $4 ) ) + 2 | 0 ) ; $27 = HEAP16 [ $26 >> 1 ] | 0 ; $28 = $27 & 65535 ; $29 = ( $19 | 0 ) > ( $28 | 0 ) ; if ( $29 ) { $30 = ( ( ( $4 ) ) + 4 | 0 ) ; $31 = HEAP16 [ $30 >> 1 ] | 0 ; $32 = $31 & 65535 ; $33 = ( $19 | 0 ) > ( $32 | 0 ) ; if ( $33 ) { $34 = ( ( ( $4 ) ) + 6 | 0 ) ; $35 = HEAP16 [ $34 >> 1 ] | 0 ; $36 = $35 & 65535 ; $37 = ( $19 | 0 ) > ( $36 | 0 ) ; if ( $37 ) { break L15 ; } } } break ; } default : { break L15 ; } } _png_warning ( $0 , 26054 ) ; } } while ( 0 ) ; $38 = ( ( ( $1 ) ) + 52 | 0 ) ; ; HEAP16 [ $38 >> 1 ] = HEAP16 [ $4 >> 1 ] | 0 ; HEAP16 [ $38 + 2 >> 1 ] = HEAP16 [ $4 + 2 >> 1 ] | 0 ; HEAP16 [ $38 + 4 >> 1 ] = HEAP16 [ $4 + 4 >> 1 ] | 0 ; HEAP16 [ $38 + 6 >> 1 ] = HEAP16 [ $4 + 6 >> 1 ] | 0 ; HEAP16 [ $38 + 8 >> 1 ] = HEAP16 [ $4 + 8 >> 1 ] | 0 ; $39 = ( $3 | 0 ) == ( 0 ) ; $40 = $3 & 65535 ; $41 = $39 ? 1 : $40 ; $42 = ( ( ( $1 ) ) + 22 | 0 ) ; HEAP16 [ $42 >> 1 ] = $41 ; } $46 = ( ( ( $1 ) ) + 8 | 0 ) ; $47 = HEAP32 [ $46 >> 2 ] | 0 ; $48 = $47 | 16 ; HEAP32 [ $46 >> 2 ] = $48 ; $49 = ( ( ( $1 ) ) + 76 | 0 ) ; $50 = HEAP32 [ $49 >> 2 ] | 0 ; $51 = $50 | 8192 ; HEAP32 [ $49 >> 2 ] = $51 ; return ; } function _png_set_unknown_chunks ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $$04750 = 0 , $$04849 = 0 , $$051 = 0 , $$1 = 0 , $$1$i = 0 , $$sink = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 ; var $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 ; var $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $6 = 0 , $7 = 0 , $8 = 0 ; var $9 = 0 , $or$cond = 0 , $or$cond3 = 0 , $or$cond5 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $4 = ( $0 | 0 ) == ( 0 | 0 ) ; $5 = ( $1 | 0 ) == ( 0 | 0 ) ; $or$cond = $4 | $5 ; $6 = ( $3 | 0 ) < ( 1 ) ; $or$cond3 = $or$cond | $6 ; $7 = ( $2 | 0 ) == ( 0 | 0 ) ; $or$cond5 = $7 | $or$cond3 ; if ( $or$cond5 ) { return ; } $8 = ( ( ( $1 ) ) + 80 | 0 ) ; $9 = HEAP32 [ $8 >> 2 ] | 0 ; $10 = ( ( ( $1 ) ) + 84 | 0 ) ; $11 = HEAP32 [ $10 >> 2 ] | 0 ; $12 = ( _png_realloc_array ( $0 , $9 , $11 , $3 , 20 ) | 0 ) ; $13 = ( $12 | 0 ) == ( 0 | 0 ) ; if ( $13 ) { _png_chunk_report ( $0 , 26104 , 1 ) ; return ; } $14 = HEAP32 [ $8 >> 2 ] | 0 ; _png_free ( $0 , $14 ) ; HEAP32 [ $8 >> 2 ] = $12 ; $15 = ( ( ( $1 ) ) + 76 | 0 ) ; $16 = HEAP32 [ $15 >> 2 ] | 0 ; $17 = $16 | 512 ; HEAP32 [ $15 >> 2 ] = $17 ; $18 = ( $3 | 0 ) > ( 0 ) ; if ( ! ( $18 ) ) { return ; } $19 = HEAP32 [ $10 >> 2 ] | 0 ; $20 = ( ( $12 ) + ( ( $19 * 20 ) | 0 ) | 0 ) ; $21 = ( ( ( $0 ) ) + 24 | 0 ) ; $$04750 = $3 ; $$04849 = $2 ; $$051 = $20 ; while ( 1 ) { $22 = HEAP32 [ $$04849 >> 2 ] | 0 ; HEAP32 [ $$051 >> 2 ] = $22 ; $23 = ( ( ( $$051 ) ) + 4 | 0 ) ; HEAP8 [ $23 >> 0 ] = 0 ; $24 = ( ( ( $$04849 ) ) + 16 | 0 ) ; $25 = HEAP8 [ $24 >> 0 ] | 0 ; $26 = $25 & 11 ; $27 = $26 & 255 ; $28 = ( $26 << 24 >> 24 ) == ( 0 ) ; if ( $28 ) { $29 = HEAP32 [ $21 >> 2 ] | 0 ; $30 = $29 & 32768 ; $31 = ( $30 | 0 ) == ( 0 ) ; if ( ! ( $31 ) ) { label = 9 ; break ; } _png_app_warning ( $0 , 26128 ) ; $32 = HEAP32 [ $21 >> 2 ] | 0 ; $33 = $32 & 11 ; $34 = ( $33 | 0 ) == ( 0 ) ; if ( $34 ) { label = 9 ; break ; } else { $$1$i = $33 ; } } else { $$1$i = $27 ; } while ( 1 ) { $35 = ( 0 - ( $$1$i ) ) | 0 ; $36 = $$1$i & $35 ; $37 = ( $$1$i | 0 ) == ( $36 | 0 ) ; $38 = $36 ^ $$1$i ; if ( $37 ) { break ; } else { $$1$i = $38 ; } } $39 = $$1$i & 255 ; $40 = ( ( ( $$051 ) ) + 16 | 0 ) ; HEAP8 [ $40 >> 0 ] = $39 ; $41 = ( ( ( $$04849 ) ) + 12 | 0 ) ; $42 = HEAP32 [ $41 >> 2 ] | 0 ; $43 = ( $42 | 0 ) == ( 0 ) ; do { if ( $43 ) { $44 = ( ( ( $$051 ) ) + 8 | 0 ) ; HEAP32 [ $44 >> 2 ] = 0 ; $$sink = 0 ; label = 16 ; } else { $45 = ( _png_malloc_base ( $0 , $42 ) | 0 ) ; $46 = ( ( ( $$051 ) ) + 8 | 0 ) ; HEAP32 [ $46 >> 2 ] = $45 ; $47 = ( $45 | 0 ) == ( 0 | 0 ) ; if ( $47 ) { _png_chunk_report ( $0 , 26223 , 1 ) ; $$1 = $$051 ; break ; } else { $48 = ( ( ( $$04849 ) ) + 8 | 0 ) ; $49 = HEAP32 [ $48 >> 2 ] | 0 ; $50 = HEAP32 [ $41 >> 2 ] | 0 ; _memcpy ( ( $45 | 0 ) , ( $49 | 0 ) , ( $50 | 0 ) ) | 0 ; $51 = HEAP32 [ $41 >> 2 ] | 0 ; $$sink = $51 ; label = 16 ; break ; } } } while ( 0 ) ; if ( ( label | 0 ) == 16 ) { label = 0 ; $52 = ( ( ( $$051 ) ) + 12 | 0 ) ; HEAP32 [ $52 >> 2 ] = $$sink ; $53 = ( ( ( $$051 ) ) + 20 | 0 ) ; $54 = HEAP32 [ $10 >> 2 ] | 0 ; $55 = ( ( $54 ) + 1 ) | 0 ; HEAP32 [ $10 >> 2 ] = $55 ; $$1 = $53 ; } $56 = ( ( $$04750 ) + - 1 ) | 0 ; $57 = ( ( ( $$04849 ) ) + 20 | 0 ) ; $58 = ( $$04750 | 0 ) > ( 1 ) ; if ( $58 ) { $$04750 = $56 ; $$04849 = $57 ; $$051 = $$1 ; } else { label = 18 ; break ; } } if ( ( label | 0 ) == 9 ) { _png_error ( $0 , 26180 ) ; // unreachable; } else if ( ( label | 0 ) == 18 ) { return ; } } function _png_set_unknown_chunk_location ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $$ = 0 , $$0 = 0 , $$1$i = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 ; var $27 = 0 , $28 = 0 , $29 = 0 , $30 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , $or$cond3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $4 = ( $0 | 0 ) != ( 0 | 0 ) ; $5 = ( $1 | 0 ) != ( 0 | 0 ) ; $or$cond = $4 & $5 ; $6 = ( $2 | 0 ) > ( - 1 ) ; $or$cond3 = $or$cond & $6 ; if ( ! ( $or$cond3 ) ) { return ; } $7 = ( ( ( $1 ) ) + 84 | 0 ) ; $8 = HEAP32 [ $7 >> 2 ] | 0 ; $9 = ( $8 | 0 ) > ( $2 | 0 ) ; if ( ! ( $9 ) ) { return ; } $10 = $3 & 11 ; $11 = ( $10 | 0 ) == ( 0 ) ; if ( $11 ) { $12 = $3 & 4 ; $13 = ( $12 | 0 ) == ( 0 ) ; $$ = $13 ? 1 : 8 ; _png_app_error ( $0 , 26252 ) ; $$0 = $$ ; } else { $$0 = $3 ; } $14 = $$0 & 11 ; $15 = ( $14 | 0 ) == ( 0 ) ; if ( $15 ) { $16 = ( ( ( $0 ) ) + 24 | 0 ) ; $17 = HEAP32 [ $16 >> 2 ] | 0 ; $18 = $17 & 32768 ; $19 = ( $18 | 0 ) == ( 0 ) ; if ( ! ( $19 ) ) { _png_error ( $0 , 26180 ) ; // unreachable; } _png_app_warning ( $0 , 26128 ) ; $20 = HEAP32 [ $16 >> 2 ] | 0 ; $21 = $20 & 11 ; $22 = ( $21 | 0 ) == ( 0 ) ; if ( $22 ) { _png_error ( $0 , 26180 ) ; // unreachable; } else { $$1$i = $21 ; } } else { $$1$i = $14 ; } while ( 1 ) { $23 = ( 0 - ( $$1$i ) ) | 0 ; $24 = $$1$i & $23 ; $25 = ( $$1$i | 0 ) == ( $24 | 0 ) ; $26 = $24 ^ $$1$i ; if ( $25 ) { break ; } else { $$1$i = $26 ; } } $27 = $$1$i & 255 ; $28 = ( ( ( $1 ) ) + 80 | 0 ) ; $29 = HEAP32 [ $28 >> 2 ] | 0 ; $30 = ( ( ( ( $29 ) + ( ( $2 * 20 ) | 0 ) | 0 ) ) + 16 | 0 ) ; HEAP8 [ $30 >> 0 ] = $27 ; return ; } function _png_set_keep_unknown_chunks ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $$ = 0 , $$017$ph$i = 0 , $$018$lcssa$i = 0 , $$01822$i = 0 , $$01823$i = 0 , $$01823$i$us = 0 , $$024$i = 0 , $$024$i$us = 0 , $$07389 = 0 , $$07588 = 0 , $$076$lcssa = 0 , $$07691 = 0 , $$077 = 0 , $$079 = 0 , $$082 = 0 , $$093 = 0 , $$093$us = 0 , $$174 = 0 , $$17887 = 0 , $$190 = 0 ; var $$2 = 0 , $$281 = 0 , $$281$ph = 0 , $$3 = 0 , $$3$ph = 0 , $$pr = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 ; var $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 ; var $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 ; var $61 = 0 , $62 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $exitcond = 0 , $exitcond100 = 0 , $exitcond99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $4 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $4 ) { return ; } $5 = ( $1 >>> 0 ) > ( 3 ) ; if ( $5 ) { _png_app_error ( $0 , 26283 ) ; return ; } $6 = ( $3 | 0 ) < ( 1 ) ; if ( $6 ) { $7 = ( ( ( $0 ) ) + 300 | 0 ) ; HEAP32 [ $7 >> 2 ] = $1 ; $8 = ( $3 | 0 ) == ( 0 ) ; if ( $8 ) { return ; } else { $$077 = 18 ; $$082 = 26368 ; } } else { $9 = ( $2 | 0 ) == ( 0 | 0 ) ; if ( $9 ) { _png_app_error ( $0 , 26325 ) ; return ; } else { $$077 = $3 ; $$082 = $2 ; } } $10 = ( ( ( $0 ) ) + 304 | 0 ) ; $11 = HEAP32 [ $10 >> 2 ] | 0 ; $12 = ( ( ( $0 ) ) + 308 | 0 ) ; $13 = HEAP32 [ $12 >> 2 ] | 0 ; $14 = ( $13 | 0 ) == ( 0 | 0 ) ; $$ = $14 ? 0 : $11 ; $15 = ( ( $$ ) + ( $$077 ) ) | 0 ; $16 = ( $15 >>> 0 ) > ( 858993459 ) ; if ( $16 ) { _png_app_error ( $0 , 26458 ) ; return ; } $17 = ( $1 | 0 ) == ( 0 ) ; if ( $17 ) { $23 = ( $$ | 0 ) == ( 0 ) ; if ( $23 ) { $$281$ph = 0 ; $$3$ph = 0 ; label = 36 ; } else { $$079 = $13 ; label = 14 ; } } else { $18 = ( $15 * 5 ) | 0 ; $19 = ( _png_malloc ( $0 , $18 ) | 0 ) ; $20 = ( $$ | 0 ) == ( 0 ) ; if ( $20 ) { $$079 = $19 ; label = 14 ; } else { $21 = ( $$ * 5 ) | 0 ; $22 = HEAP32 [ $12 >> 2 ] | 0 ; _memcpy ( ( $19 | 0 ) , ( $22 | 0 ) , ( $21 | 0 ) ) | 0 ; $$079 = $19 ; label = 14 ; } } do { if ( ( label | 0 ) == 14 ) { $24 = ( $$079 | 0 ) == ( 0 | 0 ) ; if ( $24 ) { $$281$ph = 0 ; $$3$ph = 0 ; label = 36 ; } else { $25 = $1 & 255 ; if ( $17 ) { $26 = ( $$ | 0 ) == ( 0 ) ; $$093$us = 0 ; while ( 1 ) { $27 = ( $$093$us * 5 ) | 0 ; $28 = ( ( $$082 ) + ( $27 ) | 0 ) ; L30 : do { if ( ! ( $26 ) ) { $$01823$i$us = $$079 ; $$024$i$us = 0 ; while ( 1 ) { $29 = ( _memcmp ( $$01823$i$us , $28 , 4 ) | 0 ) ; $30 = ( $29 | 0 ) == ( 0 ) ; if ( $30 ) { break ; } $31 = ( ( $$024$i$us ) + 1 ) | 0 ; $32 = ( ( ( $$01823$i$us ) ) + 5 | 0 ) ; $33 = ( $31 >>> 0 ) < ( $$ >>> 0 ) ; if ( $33 ) { $$01823$i$us = $32 ; $$024$i$us = $31 ; } else { break L30 ; } } $35 = ( ( ( $$01823$i$us ) ) + 4 | 0 ) ; HEAP8 [ $35 >> 0 ] = $25 ; } } while ( 0 ) ; $34 = ( ( $$093$us ) + 1 ) | 0 ; $exitcond99 = ( $34 | 0 ) == ( $$077 | 0 ) ; if ( $exitcond99 ) { $$076$lcssa = $$ ; break ; } else { $$093$us = $34 ; } } } else { $$07691 = $$ ; $$093 = 0 ; while ( 1 ) { $37 = ( $$093 * 5 ) | 0 ; $38 = ( ( $$082 ) + ( $37 ) | 0 ) ; $39 = ( $$07691 | 0 ) == ( 0 ) ; L38 : do { if ( $39 ) { $$018$lcssa$i = $$079 ; label = 26 ; } else { $$01823$i = $$079 ; $$024$i = 0 ; while ( 1 ) { $40 = ( _memcmp ( $$01823$i , $38 , 4 ) | 0 ) ; $41 = ( $40 | 0 ) == ( 0 ) ; if ( $41 ) { $$017$ph$i = $$07691 ; $$01822$i = $$01823$i ; break L38 ; } $42 = ( ( $$024$i ) + 1 ) | 0 ; $43 = ( ( ( $$01823$i ) ) + 5 | 0 ) ; $44 = ( $42 >>> 0 ) < ( $$07691 >>> 0 ) ; if ( $44 ) { $$01823$i = $43 ; $$024$i = $42 ; } else { $$018$lcssa$i = $43 ; label = 26 ; break ; } } } } while ( 0 ) ; if ( ( label | 0 ) == 26 ) { label = 0 ; $45 = ( ( $$07691 ) + 1 ) | 0 ; $46 = HEAPU8 [ $38 >> 0 ] | ( HEAPU8 [ $38 + 1 >> 0 ] << 8 ) | ( HEAPU8 [ $38 + 2 >> 0 ] << 16 ) | ( HEAPU8 [ $38 + 3 >> 0 ] << 24 ) ; HEAP8 [ $$018$lcssa$i >> 0 ] = $46 & 255 ; HEAP8 [ $$018$lcssa$i + 1 >> 0 ] = ( $46 >> 8 ) & 255 ; HEAP8 [ $$018$lcssa$i + 2 >> 0 ] = ( $46 >> 16 ) & 255 ; HEAP8 [ $$018$lcssa$i + 3 >> 0 ] = $46 >> 24 ; $$017$ph$i = $45 ; $$01822$i = $$018$lcssa$i ; } $47 = ( ( ( $$01822$i ) ) + 4 | 0 ) ; HEAP8 [ $47 >> 0 ] = $25 ; $48 = ( ( $$093 ) + 1 ) | 0 ; $exitcond100 = ( $48 | 0 ) == ( $$077 | 0 ) ; if ( $exitcond100 ) { $$076$lcssa = $$017$ph$i ; break ; } else { $$07691 = $$017$ph$i ; $$093 = $48 ; } } } $36 = ( $$076$lcssa | 0 ) == ( 0 ) ; if ( ! ( $36 ) ) { $$07389 = $$079 ; $$07588 = $$079 ; $$17887 = 0 ; $$190 = 0 ; while ( 1 ) { $49 = ( ( ( $$07588 ) ) + 4 | 0 ) ; $50 = HEAP8 [ $49 >> 0 ] | 0 ; $51 = ( $50 << 24 >> 24 ) == ( 0 ) ; if ( $51 ) { $$174 = $$07389 ; $$2 = $$17887 ; } else { $52 = ( $$07389 | 0 ) == ( $$07588 | 0 ) ; if ( ! ( $52 ) ) { ; HEAP8 [ $$07389 >> 0 ] = HEAP8 [ $$07588 >> 0 ] | 0 ; HEAP8 [ $$07389 + 1 >> 0 ] = HEAP8 [ $$07588 + 1 >> 0 ] | 0 ; HEAP8 [ $$07389 + 2 >> 0 ] = HEAP8 [ $$07588 + 2 >> 0 ] | 0 ; HEAP8 [ $$07389 + 3 >> 0 ] = HEAP8 [ $$07588 + 3 >> 0 ] | 0 ; HEAP8 [ $$07389 + 4 >> 0 ] = HEAP8 [ $$07588 + 4 >> 0 ] | 0 ; } $53 = ( ( ( $$07389 ) ) + 5 | 0 ) ; $54 = ( ( $$17887 ) + 1 ) | 0 ; $$174 = $53 ; $$2 = $54 ; } $55 = ( ( $$190 ) + 1 ) | 0 ; $56 = ( ( ( $$07588 ) ) + 5 | 0 ) ; $exitcond = ( $55 | 0 ) == ( $$076$lcssa | 0 ) ; if ( $exitcond ) { break ; } else { $$07389 = $$174 ; $$07588 = $56 ; $$17887 = $$2 ; $$190 = $55 ; } } $57 = ( $$2 | 0 ) == ( 0 ) ; if ( ! ( $57 ) ) { $$281$ph = $$079 ; $$3$ph = $$2 ; label = 36 ; break ; } } $58 = HEAP32 [ $12 >> 2 ] | 0 ; $59 = ( $58 | 0 ) == ( $$079 | 0 ) ; if ( $59 ) { $$281 = 0 ; $$3 = 0 ; $60 = $$079 ; } else { _png_free ( $0 , $$079 ) ; $$281$ph = 0 ; $$3$ph = 0 ; label = 36 ; } } } } while ( 0 ) ; if ( ( label | 0 ) == 36 ) { $$pr = HEAP32 [ $12 >> 2 ] | 0 ; $$281 = $$281$ph ; $$3 = $$3$ph ; $60 = $$pr ; } HEAP32 [ $10 >> 2 ] = $$3 ; $61 = ( $60 | 0 ) == ( $$281 | 0 ) ; if ( $61 ) { return ; } $62 = ( $60 | 0 ) == ( 0 | 0 ) ; if ( ! ( $62 ) ) { _png_free ( $0 , $60 ) ; } HEAP32 [ $12 >> 2 ] = $$281 ; return ; } function _png_set_rows ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , $or$cond12 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( $0 | 0 ) == ( 0 | 0 ) ; $4 = ( $1 | 0 ) == ( 0 | 0 ) ; $or$cond = $3 | $4 ; if ( $or$cond ) { return ; } $5 = ( ( ( $1 ) ) + 88 | 0 ) ; $6 = HEAP32 [ $5 >> 2 ] | 0 ; $7 = ( $6 | 0 ) == ( 0 | 0 ) ; $8 = ( $6 | 0 ) == ( $2 | 0 ) ; $or$cond12 = $7 | $8 ; if ( ! ( $or$cond12 ) ) { _png_free_data ( $0 , $1 , 64 , 0 ) ; } HEAP32 [ $5 >> 2 ] = $2 ; $9 = ( $2 | 0 ) == ( 0 | 0 ) ; if ( $9 ) { return ; } $10 = ( ( ( $1 ) ) + 8 | 0 ) ; $11 = HEAP32 [ $10 >> 2 ] | 0 ; $12 = $11 | 32768 ; HEAP32 [ $10 >> 2 ] = $12 ; return ; } function _png_set_invalid ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( $0 | 0 ) != ( 0 | 0 ) ; $4 = ( $1 | 0 ) != ( 0 | 0 ) ; $or$cond = $3 & $4 ; $5 = ( ( ( $1 ) ) + 8 | 0 ) ; if ( ! ( $or$cond ) ) { return ; } $6 = $2 ^ - 1 ; $7 = HEAP32 [ $5 >> 2 ] | 0 ; $8 = $7 & $6 ; HEAP32 [ $5 >> 2 ] = $8 ; return ; } function _png_set_user_limits ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $3 = 0 , $4 = 0 , $5 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $3 ) { return ; } $4 = ( ( ( $0 ) ) + 320 | 0 ) ; HEAP32 [ $4 >> 2 ] = $1 ; $5 = ( ( ( $0 ) ) + 324 | 0 ) ; HEAP32 [ $5 >> 2 ] = $2 ; return ; } function _png_set_interlace_handling ( $0 ) { $0 = $0 | 0 ; var $$0 = 0 , $1 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $1 ) { $$0 = 1 ; return ( $$0 | 0 ) ; } $2 = ( ( ( $0 ) ) + 220 | 0 ) ; $3 = HEAP8 [ $2 >> 0 ] | 0 ; $4 = ( $3 << 24 >> 24 ) == ( 0 ) ; if ( $4 ) { $$0 = 1 ; return ( $$0 | 0 ) ; } $5 = ( ( ( $0 ) ) + 32 | 0 ) ; $6 = HEAP32 [ $5 >> 2 ] | 0 ; $7 = $6 | 2 ; HEAP32 [ $5 >> 2 ] = $7 ; $$0 = 7 ; return ( $$0 | 0 ) ; } function _png_do_check_palette_indexes ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$ = 0 , $$$$105 = 0 , $$$105 = 0 , $$079 = 0 , $$105 = 0 , $$181 = 0 , $$284 = 0 , $$386 = 0 , $$pre = 0 , $$pre100 = 0 , $$pre101 = 0 , $$pre98 = 0 , $$pre99 = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 ; var $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 ; var $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 ; var $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 ; var $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 ; var $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 ; var $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( ( ( $0 ) ) + 208 | 0 ) ; $3 = HEAP16 [ $2 >> 1 ] | 0 ; $4 = $3 & 65535 ; $5 = ( ( ( $1 ) ) + 9 | 0 ) ; $6 = HEAP8 [ $5 >> 0 ] | 0 ; $7 = $6 & 255 ; $8 = 1 << $7 ; $9 = ( $8 | 0 ) <= ( $4 | 0 ) ; $10 = ( $3 << 16 >> 16 ) == ( 0 ) ; $or$cond = $10 | $9 ; if ( $or$cond ) { return ; } $11 = ( ( ( $1 ) ) + 11 | 0 ) ; $12 = HEAP8 [ $11 >> 0 ] | 0 ; $13 = $12 & 255 ; $14 = HEAP32 [ $1 >> 2 ] | 0 ; $15 = $14 & 7 ; $16 = ( 0 - ( $13 ) ) | 0 ; $17 = Math_imul ( $15 , $16 ) | 0 ; $18 = $17 & 7 ; $19 = ( ( ( $0 ) ) + 180 | 0 ) ; $20 = HEAP32 [ $19 >> 2 ] | 0 ; $21 = ( ( ( $1 ) ) + 4 | 0 ) ; $22 = HEAP32 [ $21 >> 2 ] | 0 ; $23 = ( ( $20 ) + ( $22 ) | 0 ) ; $24 = ( ( ( $23 ) ) + - 1 | 0 ) ; switch ( $6 << 24 >> 24 ) { case 1 : { $63 = ( $24 >>> 0 ) > ( $20 >>> 0 ) ; if ( ! ( $63 ) ) { return ; } $64 = ( ( ( $0 ) ) + 212 | 0 ) ; $65 = HEAP8 [ $24 >> 0 ] | 0 ; $66 = $65 & 255 ; $67 = $66 >>> $18 ; $68 = ( $67 | 0 ) == ( 0 ) ; if ( ! ( $68 ) ) { HEAP32 [ $64 >> 2 ] = 1 ; } $69 = ( ( ( $24 ) ) + - 1 | 0 ) ; $70 = ( $69 >>> 0 ) > ( $20 >>> 0 ) ; if ( $70 ) { $$079 = $69 ; } else { return ; } while ( 1 ) { $71 = HEAP8 [ $$079 >> 0 ] | 0 ; $72 = ( $71 << 24 >> 24 ) == ( 0 ) ; if ( ! ( $72 ) ) { HEAP32 [ $64 >> 2 ] = 1 ; } $73 = ( ( ( $$079 ) ) + - 1 | 0 ) ; $74 = ( $73 >>> 0 ) > ( $20 >>> 0 ) ; if ( $74 ) { $$079 = $73 ; } else { break ; } } return ; break ; } case 2 : { $41 = ( $24 >>> 0 ) > ( $20 >>> 0 ) ; if ( ! ( $41 ) ) { return ; } $42 = ( ( ( $0 ) ) + 212 | 0 ) ; $43 = HEAP8 [ $24 >> 0 ] | 0 ; $44 = $43 & 255 ; $45 = $44 >>> $18 ; $46 = $45 & 3 ; $47 = HEAP32 [ $42 >> 2 ] | 0 ; $48 = ( $46 | 0 ) > ( $47 | 0 ) ; $49 = $48 ? $46 : $47 ; $50 = $45 >>> 2 ; $51 = $50 & 3 ; $52 = ( $51 | 0 ) > ( $49 | 0 ) ; $$105 = $52 ? $51 : $49 ; $53 = $48 | $52 ; $54 = $45 >>> 4 ; $55 = $54 & 3 ; $56 = ( $55 | 0 ) > ( $$105 | 0 ) ; $$$105 = $56 ? $55 : $$105 ; $57 = $53 | $56 ; $58 = $45 >>> 6 ; $59 = ( $58 | 0 ) > ( $$$105 | 0 ) ; $$$$105 = $59 ? $58 : $$$105 ; $60 = $57 | $59 ; if ( $60 ) { HEAP32 [ $42 >> 2 ] = $$$$105 ; } $61 = ( ( ( $24 ) ) + - 1 | 0 ) ; $62 = ( $61 >>> 0 ) > ( $20 >>> 0 ) ; if ( $62 ) { $$181 = $61 ; $78 = $$$$105 ; } else { return ; } while ( 1 ) { $75 = HEAP8 [ $$181 >> 0 ] | 0 ; $76 = $75 & 3 ; $77 = $76 & 255 ; $79 = ( $78 | 0 ) < ( $77 | 0 ) ; if ( $79 ) { HEAP32 [ $42 >> 2 ] = $77 ; $$pre99 = HEAP8 [ $$181 >> 0 ] | 0 ; $81 = $$pre99 ; $85 = $77 ; } else { $81 = $75 ; $85 = $78 ; } $80 = $81 & 255 ; $82 = $80 >>> 2 ; $83 = $82 & 3 ; $84 = ( $83 | 0 ) > ( $85 | 0 ) ; if ( $84 ) { HEAP32 [ $42 >> 2 ] = $83 ; $$pre100 = HEAP8 [ $$181 >> 0 ] | 0 ; $87 = $$pre100 ; $91 = $83 ; } else { $87 = $81 ; $91 = $85 ; } $86 = $87 & 255 ; $88 = $86 >>> 4 ; $89 = $88 & 3 ; $90 = ( $89 | 0 ) > ( $91 | 0 ) ; if ( $90 ) { HEAP32 [ $42 >> 2 ] = $89 ; $$pre101 = HEAP8 [ $$181 >> 0 ] | 0 ; $93 = $$pre101 ; $96 = $89 ; } else { $93 = $87 ; $96 = $91 ; } $92 = $93 & 255 ; $94 = $92 >>> 6 ; $95 = ( $94 | 0 ) > ( $96 | 0 ) ; if ( $95 ) { HEAP32 [ $42 >> 2 ] = $94 ; $117 = $94 ; } else { $117 = $96 ; } $97 = ( ( ( $$181 ) ) + - 1 | 0 ) ; $98 = ( $97 >>> 0 ) > ( $20 >>> 0 ) ; if ( $98 ) { $$181 = $97 ; $78 = $117 ; } else { break ; } } return ; break ; } case 4 : { $27 = ( $24 >>> 0 ) > ( $20 >>> 0 ) ; if ( ! ( $27 ) ) { return ; } $28 = ( ( ( $0 ) ) + 212 | 0 ) ; $29 = HEAP8 [ $24 >> 0 ] | 0 ; $30 = $29 & 255 ; $31 = $30 >>> $18 ; $32 = $31 & 15 ; $33 = HEAP32 [ $28 >> 2 ] | 0 ; $34 = ( $32 | 0 ) > ( $33 | 0 ) ; $35 = $34 ? $32 : $33 ; $36 = $31 >>> 4 ; $37 = ( $36 | 0 ) > ( $35 | 0 ) ; $$ = $37 ? $36 : $35 ; $38 = $34 | $37 ; if ( $38 ) { HEAP32 [ $28 >> 2 ] = $$ ; } $39 = ( ( ( $24 ) ) + - 1 | 0 ) ; $40 = ( $39 >>> 0 ) > ( $20 >>> 0 ) ; if ( $40 ) { $$284 = $39 ; $102 = $$ ; } else { return ; } while ( 1 ) { $99 = HEAP8 [ $$284 >> 0 ] | 0 ; $100 = $99 & 15 ; $101 = $100 & 255 ; $103 = ( $102 | 0 ) < ( $101 | 0 ) ; if ( $103 ) { HEAP32 [ $28 >> 2 ] = $101 ; $$pre98 = HEAP8 [ $$284 >> 0 ] | 0 ; $105 = $$pre98 ; $108 = $101 ; } else { $105 = $99 ; $108 = $102 ; } $104 = $105 & 255 ; $106 = $104 >>> 4 ; $107 = ( $106 | 0 ) > ( $108 | 0 ) ; if ( $107 ) { HEAP32 [ $28 >> 2 ] = $106 ; $118 = $106 ; } else { $118 = $108 ; } $109 = ( ( ( $$284 ) ) + - 1 | 0 ) ; $110 = ( $109 >>> 0 ) > ( $20 >>> 0 ) ; if ( $110 ) { $$284 = $109 ; $102 = $118 ; } else { break ; } } return ; break ; } case 8 : { $25 = ( $24 >>> 0 ) > ( $20 >>> 0 ) ; if ( ! ( $25 ) ) { return ; } $26 = ( ( ( $0 ) ) + 212 | 0 ) ; $$pre = HEAP32 [ $26 >> 2 ] | 0 ; $$386 = $24 ; $113 = $$pre ; while ( 1 ) { $111 = HEAP8 [ $$386 >> 0 ] | 0 ; $112 = $111 & 255 ; $114 = ( $113 | 0 ) < ( $112 | 0 ) ; if ( $114 ) { HEAP32 [ $26 >> 2 ] = $112 ; $119 = $112 ; } else { $119 = $113 ; } $115 = ( ( ( $$386 ) ) + - 1 | 0 ) ; $116 = ( $115 >>> 0 ) > ( $20 >>> 0 ) ; if ( $116 ) { $$386 = $115 ; $113 = $119 ; } else { break ; } } return ; break ; } default : { return ; } } } function _png_write_data ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $3 = 0 , $4 = 0 , $5 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( ( ( $0 ) ) + 12 | 0 ) ; $4 = HEAP32 [ $3 >> 2 ] | 0 ; $5 = ( $4 | 0 ) == ( 0 | 0 ) ; if ( $5 ) { _png_error ( $0 , 26503 ) ; // unreachable; } else { FUNCTION_TABLE_viii [ $4 & 127 ] ( $0 , $1 , $2 ) ; return ; } } function _png_default_write_data ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $3 ) { return ; } $4 = ( ( ( $0 ) ) + 20 | 0 ) ; $5 = HEAP32 [ $4 >> 2 ] | 0 ; $6 = ( _fwrite ( $1 , 1 , $2 , $5 ) | 0 ) ; $7 = ( $6 | 0 ) == ( $2 | 0 ) ; if ( $7 ) { return ; } else { _png_error ( $0 , 26531 ) ; // unreachable; } } function _png_flush ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( ( ( $0 ) ) + 252 | 0 ) ; $2 = HEAP32 [ $1 >> 2 ] | 0 ; $3 = ( $2 | 0 ) == ( 0 | 0 ) ; if ( $3 ) { return ; } FUNCTION_TABLE_vi [ $2 & 127 ] ( $0 ) ; return ; } function _png_default_flush ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $1 ) { return ; } $2 = ( ( ( $0 ) ) + 20 | 0 ) ; $3 = HEAP32 [ $2 >> 2 ] | 0 ; ( _fflush ( $3 ) | 0 ) ; return ; } function _png_set_write_fn ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $png_default_flush$sink = 0 , $png_default_write_data$sink = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $4 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $4 ) { return ; } $5 = ( ( ( $0 ) ) + 20 | 0 ) ; HEAP32 [ $5 >> 2 ] = $1 ; $6 = ( $2 | 0 ) != ( 0 | 0 ) ; $png_default_write_data$sink = $6 ? $2 : 100 ; $7 = ( ( ( $0 ) ) + 12 | 0 ) ; HEAP32 [ $7 >> 2 ] = $png_default_write_data$sink ; $8 = ( $3 | 0 ) != ( 0 | 0 ) ; $png_default_flush$sink = $8 ? $3 : 101 ; $9 = ( ( ( $0 ) ) + 252 | 0 ) ; HEAP32 [ $9 >> 2 ] = $png_default_flush$sink ; $10 = ( ( ( $0 ) ) + 16 | 0 ) ; $11 = HEAP32 [ $10 >> 2 ] | 0 ; $12 = ( $11 | 0 ) == ( 0 | 0 ) ; if ( $12 ) { return ; } HEAP32 [ $10 >> 2 ] = 0 ; _png_warning ( $0 , 26543 ) ; return ; } function _png_write_info_before_PLTE ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$024$i = 0 , $$pre$i = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 ; var $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 ; var $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 ; var $63 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , $or$cond$i = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( $0 | 0 ) == ( 0 | 0 ) ; $3 = ( $1 | 0 ) == ( 0 | 0 ) ; $or$cond = $2 | $3 ; if ( $or$cond ) { return ; } $4 = ( ( ( $0 ) ) + 24 | 0 ) ; $5 = HEAP32 [ $4 >> 2 ] | 0 ; $6 = $5 & 1024 ; $7 = ( $6 | 0 ) == ( 0 ) ; if ( ! ( $7 ) ) { return ; } _png_write_sig ( $0 ) ; $8 = HEAP32 [ $1 >> 2 ] | 0 ; $9 = ( ( ( $1 ) ) + 4 | 0 ) ; $10 = HEAP32 [ $9 >> 2 ] | 0 ; $11 = ( ( ( $1 ) ) + 24 | 0 ) ; $12 = HEAP8 [ $11 >> 0 ] | 0 ; $13 = $12 & 255 ; $14 = ( ( ( $1 ) ) + 25 | 0 ) ; $15 = HEAP8 [ $14 >> 0 ] | 0 ; $16 = $15 & 255 ; $17 = ( ( ( $1 ) ) + 26 | 0 ) ; $18 = HEAP8 [ $17 >> 0 ] | 0 ; $19 = $18 & 255 ; $20 = ( ( ( $1 ) ) + 27 | 0 ) ; $21 = HEAP8 [ $20 >> 0 ] | 0 ; $22 = $21 & 255 ; $23 = ( ( ( $1 ) ) + 28 | 0 ) ; $24 = HEAP8 [ $23 >> 0 ] | 0 ; $25 = $24 & 255 ; _png_write_IHDR ( $0 , $8 , $10 , $13 , $16 , $19 , $22 , $25 ) ; $26 = ( ( ( $1 ) ) + 8 | 0 ) ; $27 = HEAP32 [ $26 >> 2 ] | 0 ; $28 = $27 & 2 ; $29 = ( $28 | 0 ) == ( 0 ) ; if ( ! ( $29 ) ) { $30 = ( ( ( $1 ) ) + 40 | 0 ) ; $31 = HEAP8 [ $14 >> 0 ] | 0 ; $32 = $31 & 255 ; _png_write_sBIT ( $0 , $30 , $32 ) ; } $33 = ( ( ( $1 ) ) + 84 | 0 ) ; $34 = HEAP32 [ $33 >> 2 ] | 0 ; $35 = ( $34 | 0 ) > ( 0 ) ; if ( $35 ) { $36 = ( ( ( $1 ) ) + 80 | 0 ) ; $37 = HEAP32 [ $36 >> 2 ] | 0 ; $38 = ( ( ( $0 ) ) + 300 | 0 ) ; $39 = ( ( $37 ) + ( ( $34 * 20 ) | 0 ) | 0 ) ; $$024$i = $37 ; while ( 1 ) { $40 = ( ( ( $$024$i ) ) + 16 | 0 ) ; $41 = HEAP8 [ $40 >> 0 ] | 0 ; $42 = $41 & 1 ; $43 = ( $42 << 24 >> 24 ) == ( 0 ) ; do { if ( ! ( $43 ) ) { $44 = ( _png_handle_as_unknown ( $0 , $$024$i ) | 0 ) ; $45 = ( $44 | 0 ) == ( 1 ) ; if ( ! ( $45 ) ) { $46 = ( ( ( $$024$i ) ) + 3 | 0 ) ; $47 = HEAP8 [ $46 >> 0 ] | 0 ; $48 = $47 & 32 ; $49 = ( $48 << 24 >> 24 ) != ( 0 ) ; $50 = ( $44 | 0 ) == ( 3 ) ; $or$cond$i = $50 | $49 ; if ( ! ( $or$cond$i ) ) { $51 = ( $44 | 0 ) == ( 0 ) ; if ( ! ( $51 ) ) { break ; } $52 = HEAP32 [ $38 >> 2 ] | 0 ; $53 = ( $52 | 0 ) == ( 3 ) ; if ( ! ( $53 ) ) { break ; } } $54 = ( ( ( $$024$i ) ) + 12 | 0 ) ; $55 = HEAP32 [ $54 >> 2 ] | 0 ; $56 = ( $55 | 0 ) == ( 0 ) ; if ( $56 ) { _png_warning ( $0 , 26611 ) ; $$pre$i = HEAP32 [ $54 >> 2 ] | 0 ; $59 = $$pre$i ; } else { $59 = $55 ; } $57 = ( ( ( $$024$i ) ) + 8 | 0 ) ; $58 = HEAP32 [ $57 >> 2 ] | 0 ; _png_write_chunk ( $0 , $$024$i , $58 , $59 ) ; } } } while ( 0 ) ; $60 = ( ( ( $$024$i ) ) + 20 | 0 ) ; $61 = ( $60 >>> 0 ) < ( $39 >>> 0 ) ; if ( $61 ) { $$024$i = $60 ; } else { break ; } } } $62 = HEAP32 [ $4 >> 2 ] | 0 ; $63 = $62 | 1024 ; HEAP32 [ $4 >> 2 ] = $63 ; return ; } function _png_write_info ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$024$i = 0 , $$pre = 0 , $$pre$i = 0 , $$pre27 = 0 , $$pre28 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 ; var $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 ; var $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 ; var $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , $or$cond$i = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( $0 | 0 ) == ( 0 | 0 ) ; $3 = ( $1 | 0 ) == ( 0 | 0 ) ; $or$cond = $2 | $3 ; if ( $or$cond ) { return ; } _png_write_info_before_PLTE ( $0 , $1 ) ; $4 = ( ( ( $1 ) ) + 8 | 0 ) ; $5 = HEAP32 [ $4 >> 2 ] | 0 ; $6 = $5 & 8 ; $7 = ( $6 | 0 ) == ( 0 ) ; if ( $7 ) { $13 = ( ( ( $1 ) ) + 25 | 0 ) ; $14 = HEAP8 [ $13 >> 0 ] | 0 ; $15 = ( $14 << 24 >> 24 ) == ( 3 ) ; if ( $15 ) { _png_error ( $0 , 26645 ) ; // unreachable; } else { $17 = $5 ; } } else { $8 = ( ( ( $1 ) ) + 16 | 0 ) ; $9 = HEAP32 [ $8 >> 2 ] | 0 ; $10 = ( ( ( $1 ) ) + 20 | 0 ) ; $11 = HEAP16 [ $10 >> 1 ] | 0 ; $12 = $11 & 65535 ; _png_write_PLTE ( $0 , $9 , $12 ) ; $$pre = HEAP32 [ $4 >> 2 ] | 0 ; $17 = $$pre ; } $16 = $17 & 16 ; $18 = ( $16 | 0 ) == ( 0 ) ; if ( $18 ) { $29 = $17 ; } else { $19 = ( ( ( $1 ) ) + 48 | 0 ) ; $20 = HEAP32 [ $19 >> 2 ] | 0 ; $21 = ( ( ( $1 ) ) + 52 | 0 ) ; $22 = ( ( ( $1 ) ) + 22 | 0 ) ; $23 = HEAP16 [ $22 >> 1 ] | 0 ; $24 = $23 & 65535 ; $25 = ( ( ( $1 ) ) + 25 | 0 ) ; $26 = HEAP8 [ $25 >> 0 ] | 0 ; $27 = $26 & 255 ; _png_write_tRNS ( $0 , $20 , $21 , $24 , $27 ) ; $$pre27 = HEAP32 [ $4 >> 2 ] | 0 ; $29 = $$pre27 ; } $28 = $29 & 32 ; $30 = ( $28 | 0 ) == ( 0 ) ; if ( $30 ) { $36 = $29 ; } else { $31 = ( ( ( $1 ) ) + 62 | 0 ) ; $32 = ( ( ( $1 ) ) + 25 | 0 ) ; $33 = HEAP8 [ $32 >> 0 ] | 0 ; $34 = $33 & 255 ; _png_write_bKGD ( $0 , $31 , $34 ) ; $$pre28 = HEAP32 [ $4 >> 2 ] | 0 ; $36 = $$pre28 ; } $35 = $36 & 64 ; $37 = ( $35 | 0 ) == ( 0 ) ; if ( ! ( $37 ) ) { $38 = ( ( ( $1 ) ) + 72 | 0 ) ; $39 = HEAP32 [ $38 >> 2 ] | 0 ; $40 = ( ( ( $1 ) ) + 20 | 0 ) ; $41 = HEAP16 [ $40 >> 1 ] | 0 ; $42 = $41 & 65535 ; _png_write_hIST ( $0 , $39 , $42 ) ; } $43 = ( ( ( $1 ) ) + 84 | 0 ) ; $44 = HEAP32 [ $43 >> 2 ] | 0 ; $45 = ( $44 | 0 ) > ( 0 ) ; if ( ! ( $45 ) ) { return ; } $46 = ( ( ( $1 ) ) + 80 | 0 ) ; $47 = HEAP32 [ $46 >> 2 ] | 0 ; $48 = ( ( ( $0 ) ) + 300 | 0 ) ; $49 = ( ( $47 ) + ( ( $44 * 20 ) | 0 ) | 0 ) ; $$024$i = $47 ; while ( 1 ) { $50 = ( ( ( $$024$i ) ) + 16 | 0 ) ; $51 = HEAP8 [ $50 >> 0 ] | 0 ; $52 = $51 & 2 ; $53 = ( $52 << 24 >> 24 ) == ( 0 ) ; do { if ( ! ( $53 ) ) { $54 = ( _png_handle_as_unknown ( $0 , $$024$i ) | 0 ) ; $55 = ( $54 | 0 ) == ( 1 ) ; if ( ! ( $55 ) ) { $56 = ( ( ( $$024$i ) ) + 3 | 0 ) ; $57 = HEAP8 [ $56 >> 0 ] | 0 ; $58 = $57 & 32 ; $59 = ( $58 << 24 >> 24 ) != ( 0 ) ; $60 = ( $54 | 0 ) == ( 3 ) ; $or$cond$i = $60 | $59 ; if ( ! ( $or$cond$i ) ) { $61 = ( $54 | 0 ) == ( 0 ) ; if ( ! ( $61 ) ) { break ; } $62 = HEAP32 [ $48 >> 2 ] | 0 ; $63 = ( $62 | 0 ) == ( 3 ) ; if ( ! ( $63 ) ) { break ; } } $64 = ( ( ( $$024$i ) ) + 12 | 0 ) ; $65 = HEAP32 [ $64 >> 2 ] | 0 ; $66 = ( $65 | 0 ) == ( 0 ) ; if ( $66 ) { _png_warning ( $0 , 26611 ) ; $$pre$i = HEAP32 [ $64 >> 2 ] | 0 ; $69 = $$pre$i ; } else { $69 = $65 ; } $67 = ( ( ( $$024$i ) ) + 8 | 0 ) ; $68 = HEAP32 [ $67 >> 2 ] | 0 ; _png_write_chunk ( $0 , $$024$i , $68 , $69 ) ; } } } while ( 0 ) ; $70 = ( ( ( $$024$i ) ) + 20 | 0 ) ; $71 = ( $70 >>> 0 ) < ( $49 >>> 0 ) ; if ( $71 ) { $$024$i = $70 ; } else { break ; } } return ; } function _png_write_end ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$024$i = 0 , $$pre$i = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 ; var $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 ; var $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond$i = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $2 ) { return ; } $3 = ( ( ( $0 ) ) + 24 | 0 ) ; $4 = HEAP32 [ $3 >> 2 ] | 0 ; $5 = $4 & 4 ; $6 = ( $5 | 0 ) == ( 0 ) ; if ( $6 ) { _png_error ( $0 , 26688 ) ; // unreachable; } $7 = ( ( ( $0 ) ) + 212 | 0 ) ; $8 = HEAP32 [ $7 >> 2 ] | 0 ; $9 = ( ( ( $0 ) ) + 208 | 0 ) ; $10 = HEAP16 [ $9 >> 1 ] | 0 ; $11 = $10 & 65535 ; $12 = ( $8 | 0 ) > ( $11 | 0 ) ; if ( $12 ) { _png_benign_error ( $0 , 26715 ) ; } $13 = ( $1 | 0 ) == ( 0 | 0 ) ; if ( ! ( $13 ) ) { $14 = ( ( ( $1 ) ) + 84 | 0 ) ; $15 = HEAP32 [ $14 >> 2 ] | 0 ; $16 = ( $15 | 0 ) > ( 0 ) ; if ( $16 ) { $17 = ( ( ( $1 ) ) + 80 | 0 ) ; $18 = HEAP32 [ $17 >> 2 ] | 0 ; $19 = ( ( ( $0 ) ) + 300 | 0 ) ; $20 = ( ( $18 ) + ( ( $15 * 20 ) | 0 ) | 0 ) ; $$024$i = $18 ; while ( 1 ) { $21 = ( ( ( $$024$i ) ) + 16 | 0 ) ; $22 = HEAP8 [ $21 >> 0 ] | 0 ; $23 = $22 & 8 ; $24 = ( $23 << 24 >> 24 ) == ( 0 ) ; do { if ( ! ( $24 ) ) { $25 = ( _png_handle_as_unknown ( $0 , $$024$i ) | 0 ) ; $26 = ( $25 | 0 ) == ( 1 ) ; if ( ! ( $26 ) ) { $27 = ( ( ( $$024$i ) ) + 3 | 0 ) ; $28 = HEAP8 [ $27 >> 0 ] | 0 ; $29 = $28 & 32 ; $30 = ( $29 << 24 >> 24 ) != ( 0 ) ; $31 = ( $25 | 0 ) == ( 3 ) ; $or$cond$i = $31 | $30 ; if ( ! ( $or$cond$i ) ) { $32 = ( $25 | 0 ) == ( 0 ) ; if ( ! ( $32 ) ) { break ; } $33 = HEAP32 [ $19 >> 2 ] | 0 ; $34 = ( $33 | 0 ) == ( 3 ) ; if ( ! ( $34 ) ) { break ; } } $35 = ( ( ( $$024$i ) ) + 12 | 0 ) ; $36 = HEAP32 [ $35 >> 2 ] | 0 ; $37 = ( $36 | 0 ) == ( 0 ) ; if ( $37 ) { _png_warning ( $0 , 26611 ) ; $$pre$i = HEAP32 [ $35 >> 2 ] | 0 ; $40 = $$pre$i ; } else { $40 = $36 ; } $38 = ( ( ( $$024$i ) ) + 8 | 0 ) ; $39 = HEAP32 [ $38 >> 2 ] | 0 ; _png_write_chunk ( $0 , $$024$i , $39 , $40 ) ; } } } while ( 0 ) ; $41 = ( ( ( $$024$i ) ) + 20 | 0 ) ; $42 = ( $41 >>> 0 ) < ( $20 >>> 0 ) ; if ( $42 ) { $$024$i = $41 ; } else { break ; } } } } $43 = HEAP32 [ $3 >> 2 ] | 0 ; $44 = $43 | 8 ; HEAP32 [ $3 >> 2 ] = $44 ; _png_write_IEND ( $0 ) ; return ; } function _png_create_write_struct ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $4 = ( _png_create_png_struct ( $0 , $1 , $2 , $3 , 0 , 0 , 0 ) | 0 ) ; $5 = ( $4 | 0 ) == ( 0 | 0 ) ; if ( $5 ) { return ( $4 | 0 ) ; } $6 = ( ( ( $4 ) ) + 100 | 0 ) ; HEAP32 [ $6 >> 2 ] = 8192 ; $7 = ( ( ( $4 ) ) + 120 | 0 ) ; HEAP32 [ $7 >> 2 ] = 1 ; $8 = ( ( ( $4 ) ) + 104 | 0 ) ; HEAP32 [ $8 >> 2 ] = - 1 ; $9 = ( ( ( $4 ) ) + 116 | 0 ) ; HEAP32 [ $9 >> 2 ] = 8 ; $10 = ( ( ( $4 ) ) + 112 | 0 ) ; HEAP32 [ $10 >> 2 ] = 15 ; $11 = ( ( ( $4 ) ) + 108 | 0 ) ; HEAP32 [ $11 >> 2 ] = 8 ; $12 = ( ( ( $4 ) ) + 28 | 0 ) ; $13 = HEAP32 [ $12 >> 2 ] | 0 ; $14 = $13 | 2097152 ; HEAP32 [ $12 >> 2 ] = $14 ; _png_set_write_fn ( $4 , 0 , 0 , 0 ) ; return ( $4 | 0 ) ; } function _png_write_row ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$pre = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $12 = 0 , $13 = 0 , $14 = 0 ; var $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 ; var $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 ; var $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 ; var $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 ; var $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = sp ; $3 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $3 ) { STACKTOP = sp ; return ; } $4 = ( ( ( $0 ) ) + 168 | 0 ) ; $5 = HEAP32 [ $4 >> 2 ] | 0 ; $6 = ( $5 | 0 ) == ( 0 ) ; do { if ( $6 ) { $7 = ( ( ( $0 ) ) + 221 | 0 ) ; $8 = HEAP8 [ $7 >> 0 ] | 0 ; $9 = ( $8 << 24 >> 24 ) == ( 0 ) ; if ( $9 ) { $10 = ( ( ( $0 ) ) + 24 | 0 ) ; $11 = HEAP32 [ $10 >> 2 ] | 0 ; $12 = $11 & 1024 ; $13 = ( $12 | 0 ) == ( 0 ) ; if ( $13 ) { _png_error ( $0 , 26757 ) ; // unreachable; } else { _png_write_start_row ( $0 ) ; break ; } } } } while ( 0 ) ; $14 = ( ( ( $0 ) ) + 220 | 0 ) ; $15 = HEAP8 [ $14 >> 0 ] | 0 ; $16 = ( $15 << 24 >> 24 ) == ( 0 ) ; L11 : do { if ( ! ( $16 ) ) { $17 = ( ( ( $0 ) ) + 32 | 0 ) ; $18 = HEAP32 [ $17 >> 2 ] | 0 ; $19 = $18 & 2 ; $20 = ( $19 | 0 ) == ( 0 ) ; if ( ! ( $20 ) ) { $21 = ( ( ( $0 ) ) + 221 | 0 ) ; $22 = HEAP8 [ $21 >> 0 ] | 0 ; switch ( $22 << 24 >> 24 ) { case 0 : { $23 = HEAP32 [ $4 >> 2 ] | 0 ; $24 = $23 & 7 ; $25 = ( $24 | 0 ) == ( 0 ) ; if ( $25 ) { break L11 ; } _png_write_finish_row ( $0 ) ; STACKTOP = sp ; return ; break ; } case 1 : { $26 = HEAP32 [ $4 >> 2 ] | 0 ; $27 = $26 & 7 ; $28 = ( $27 | 0 ) == ( 0 ) ; if ( $28 ) { $29 = ( ( ( $0 ) ) + 144 | 0 ) ; $30 = HEAP32 [ $29 >> 2 ] | 0 ; $31 = ( $30 >>> 0 ) < ( 5 ) ; if ( ! ( $31 ) ) { break L11 ; } } _png_write_finish_row ( $0 ) ; STACKTOP = sp ; return ; break ; } case 2 : { $32 = HEAP32 [ $4 >> 2 ] | 0 ; $33 = $32 & 7 ; $34 = ( $33 | 0 ) == ( 4 ) ; if ( $34 ) { break L11 ; } _png_write_finish_row ( $0 ) ; STACKTOP = sp ; return ; break ; } case 3 : { $35 = HEAP32 [ $4 >> 2 ] | 0 ; $36 = $35 & 3 ; $37 = ( $36 | 0 ) == ( 0 ) ; if ( $37 ) { $38 = ( ( ( $0 ) ) + 144 | 0 ) ; $39 = HEAP32 [ $38 >> 2 ] | 0 ; $40 = ( $39 >>> 0 ) < ( 3 ) ; if ( ! ( $40 ) ) { break L11 ; } } _png_write_finish_row ( $0 ) ; STACKTOP = sp ; return ; break ; } case 4 : { $41 = HEAP32 [ $4 >> 2 ] | 0 ; $42 = $41 & 3 ; $43 = ( $42 | 0 ) == ( 2 ) ; if ( $43 ) { break L11 ; } _png_write_finish_row ( $0 ) ; STACKTOP = sp ; return ; break ; } case 5 : { $44 = HEAP32 [ $4 >> 2 ] | 0 ; $45 = $44 & 1 ; $46 = ( $45 | 0 ) == ( 0 ) ; if ( $46 ) { $47 = ( ( ( $0 ) ) + 144 | 0 ) ; $48 = HEAP32 [ $47 >> 2 ] | 0 ; $49 = ( $48 >>> 0 ) < ( 2 ) ; if ( ! ( $49 ) ) { break L11 ; } } _png_write_finish_row ( $0 ) ; STACKTOP = sp ; return ; break ; } case 6 : { $50 = HEAP32 [ $4 >> 2 ] | 0 ; $51 = $50 & 1 ; $52 = ( $51 | 0 ) == ( 0 ) ; if ( ! ( $52 ) ) { break L11 ; } _png_write_finish_row ( $0 ) ; STACKTOP = sp ; return ; break ; } default : { break L11 ; } } } } } while ( 0 ) ; $53 = ( ( ( $0 ) ) + 223 | 0 ) ; $54 = HEAP8 [ $53 >> 0 ] | 0 ; $55 = ( ( ( $2 ) ) + 8 | 0 ) ; HEAP8 [ $55 >> 0 ] = $54 ; $56 = ( ( ( $0 ) ) + 156 | 0 ) ; $57 = HEAP32 [ $56 >> 2 ] | 0 ; HEAP32 [ $2 >> 2 ] = $57 ; $58 = ( ( ( $0 ) ) + 228 | 0 ) ; $59 = HEAP8 [ $58 >> 0 ] | 0 ; $60 = ( ( ( $2 ) ) + 10 | 0 ) ; HEAP8 [ $60 >> 0 ] = $59 ; $61 = ( ( ( $0 ) ) + 225 | 0 ) ; $62 = HEAP8 [ $61 >> 0 ] | 0 ; $63 = ( ( ( $2 ) ) + 9 | 0 ) ; HEAP8 [ $63 >> 0 ] = $62 ; $64 = $62 & 255 ; $65 = $59 & 255 ; $66 = Math_imul ( $64 , $65 ) | 0 ; $67 = $66 & 255 ; $68 = ( ( ( $2 ) ) + 11 | 0 ) ; HEAP8 [ $68 >> 0 ] = $67 ; $69 = $66 & 255 ; $70 = ( $69 >>> 0 ) > ( 7 ) ; if ( $70 ) { $71 = $69 >>> 3 ; $72 = Math_imul ( $71 , $57 ) | 0 ; $77 = $72 ; } else { $73 = Math_imul ( $57 , $69 ) | 0 ; $74 = ( ( $73 ) + 7 ) | 0 ; $75 = $74 >>> 3 ; $77 = $75 ; } $76 = ( ( ( $2 ) ) + 4 | 0 ) ; HEAP32 [ $76 >> 2 ] = $77 ; $78 = ( ( ( $0 ) ) + 180 | 0 ) ; $79 = HEAP32 [ $78 >> 2 ] | 0 ; $80 = ( ( ( $79 ) ) + 1 | 0 ) ; _memcpy ( ( $80 | 0 ) , ( $1 | 0 ) , ( $77 | 0 ) ) | 0 ; $81 = HEAP8 [ $14 >> 0 ] | 0 ; $82 = ( $81 << 24 >> 24 ) == ( 0 ) ; do { if ( $82 ) { $97 = $67 ; } else { $83 = ( ( ( $0 ) ) + 221 | 0 ) ; $84 = HEAP8 [ $83 >> 0 ] | 0 ; $85 = $84 & 255 ; $86 = ( $84 & 255 ) < ( 6 ) ; if ( $86 ) { $87 = ( ( ( $0 ) ) + 32 | 0 ) ; $88 = HEAP32 [ $87 >> 2 ] | 0 ; $89 = $88 & 2 ; $90 = ( $89 | 0 ) == ( 0 ) ; if ( $90 ) { $97 = $67 ; } else { $91 = HEAP32 [ $78 >> 2 ] | 0 ; $92 = ( ( ( $91 ) ) + 1 | 0 ) ; _png_do_write_interlace ( $2 , $92 , $85 ) ; $93 = HEAP32 [ $2 >> 2 ] | 0 ; $94 = ( $93 | 0 ) == ( 0 ) ; if ( ! ( $94 ) ) { $$pre = HEAP8 [ $68 >> 0 ] | 0 ; $97 = $$pre ; break ; } _png_write_finish_row ( $0 ) ; STACKTOP = sp ; return ; } } else { $97 = $67 ; } } } while ( 0 ) ; $95 = ( ( ( $0 ) ) + 226 | 0 ) ; $96 = HEAP8 [ $95 >> 0 ] | 0 ; $98 = ( $97 << 24 >> 24 ) == ( $96 << 24 >> 24 ) ; if ( ! ( $98 ) ) { _png_error ( $0 , 26810 ) ; // unreachable; } $99 = ( ( ( $0 ) ) + 231 | 0 ) ; $100 = HEAP8 [ $99 >> 0 ] | 0 ; $101 = ( $97 << 24 >> 24 ) == ( $100 << 24 >> 24 ) ; if ( ! ( $101 ) ) { _png_error ( $0 , 26810 ) ; // unreachable; } $102 = HEAP8 [ $55 >> 0 ] | 0 ; $103 = ( $102 << 24 >> 24 ) == ( 3 ) ; if ( $103 ) { $104 = ( ( ( $0 ) ) + 212 | 0 ) ; $105 = HEAP32 [ $104 >> 2 ] | 0 ; $106 = ( $105 | 0 ) > ( - 1 ) ; if ( $106 ) { _png_do_check_palette_indexes ( $0 , $2 ) ; } } _png_write_find_filter ( $0 , $2 ) ; $107 = ( ( ( $0 ) ) + 292 | 0 ) ; $108 = HEAP32 [ $107 >> 2 ] | 0 ; $109 = ( $108 | 0 ) == ( 0 | 0 ) ; if ( $109 ) { STACKTOP = sp ; return ; } $110 = HEAP32 [ $4 >> 2 ] | 0 ; $111 = ( ( ( $0 ) ) + 221 | 0 ) ; $112 = HEAP8 [ $111 >> 0 ] | 0 ; $113 = $112 & 255 ; FUNCTION_TABLE_viii [ $108 & 127 ] ( $0 , $110 , $113 ) ; STACKTOP = sp ; return ; } function _png_write_flush ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $1 ) { return ; } $2 = ( ( ( $0 ) ) + 168 | 0 ) ; $3 = HEAP32 [ $2 >> 2 ] | 0 ; $4 = ( ( ( $0 ) ) + 152 | 0 ) ; $5 = HEAP32 [ $4 >> 2 ] | 0 ; $6 = ( $3 >>> 0 ) < ( $5 >>> 0 ) ; if ( ! ( $6 ) ) { return ; } _png_compress_IDAT ( $0 , 0 , 0 , 2 ) ; $7 = ( ( ( $0 ) ) + 260 | 0 ) ; HEAP32 [ $7 >> 2 ] = 0 ; _png_flush ( $0 ) ; return ; } function _png_destroy_write_struct ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 ; var sp = 0 ; sp = STACKTOP ; $2 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $2 ) { return ; } $3 = HEAP32 [ $0 >> 2 ] | 0 ; $4 = ( $3 | 0 ) == ( 0 | 0 ) ; if ( $4 ) { return ; } _png_destroy_info_struct ( $3 , $1 ) ; HEAP32 [ $0 >> 2 ] = 0 ; $5 = ( ( ( $3 ) ) + 28 | 0 ) ; $6 = HEAP32 [ $5 >> 2 ] | 0 ; $7 = $6 & 2 ; $8 = ( $7 | 0 ) == ( 0 ) ; if ( ! ( $8 ) ) { $9 = ( ( ( $3 ) ) + 40 | 0 ) ; ( _deflateEnd ( $9 ) | 0 ) ; } $10 = ( ( ( $3 ) ) + 96 | 0 ) ; _png_free_buffer_list ( $3 , $10 ) ; $11 = ( ( ( $3 ) ) + 180 | 0 ) ; $12 = HEAP32 [ $11 >> 2 ] | 0 ; _png_free ( $3 , $12 ) ; HEAP32 [ $11 >> 2 ] = 0 ; $13 = ( ( ( $3 ) ) + 176 | 0 ) ; $14 = HEAP32 [ $13 >> 2 ] | 0 ; _png_free ( $3 , $14 ) ; $15 = ( ( ( $3 ) ) + 184 | 0 ) ; $16 = HEAP32 [ $15 >> 2 ] | 0 ; _png_free ( $3 , $16 ) ; $17 = ( ( ( $3 ) ) + 188 | 0 ) ; $18 = HEAP32 [ $17 >> 2 ] | 0 ; _png_free ( $3 , $18 ) ; HEAP32 [ $13 >> 2 ] = 0 ; HEAP32 [ $15 >> 2 ] = 0 ; HEAP32 [ $17 >> 2 ] = 0 ; $19 = ( ( ( $3 ) ) + 308 | 0 ) ; $20 = HEAP32 [ $19 >> 2 ] | 0 ; _png_free ( $3 , $20 ) ; HEAP32 [ $19 >> 2 ] = 0 ; _png_destroy_png_struct ( $3 ) ; return ; } function _png_set_filter ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$ = 0 , $$1 = 0 , $$150 = 0 , $$150$ = 0 , $$2 = 0 , $$3 = 0 , $$352 = 0 , $$lobit = 0 , $$lobit54 = 0 , $$lobit55 = 0 , $$lobit56 = 0 , $$pre = 0 , $$sink = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 ; var $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 ; var $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $6 = 0 ; var $7 = 0 , $8 = 0 , $9 = 0 , $trunc = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $3 ) { return ; } $4 = ( $1 | 0 ) == ( 0 ) ; if ( ! ( $4 ) ) { _png_error ( $0 , 26936 ) ; // unreachable; } $trunc = $2 & 255 ; switch ( $trunc << 24 >> 24 ) { case 7 : case 6 : case 5 : { _png_app_error ( $0 , 26847 ) ; $$sink = 8 ; break ; } case 0 : { $$sink = 8 ; break ; } case 1 : { $$sink = 16 ; break ; } case 2 : { $$sink = 32 ; break ; } case 3 : { $$sink = 64 ; break ; } case 4 : { $$sink = - 128 ; break ; } default : { $$sink = $trunc ; } } $5 = ( ( ( $0 ) ) + 222 | 0 ) ; HEAP8 [ $5 >> 0 ] = $$sink ; $6 = ( ( ( $0 ) ) + 180 | 0 ) ; $7 = HEAP32 [ $6 >> 2 ] | 0 ; $8 = ( $7 | 0 ) == ( 0 | 0 ) ; if ( $8 ) { $$3 = $2 ; } else { $9 = ( ( ( $0 ) ) + 148 | 0 ) ; $10 = HEAP32 [ $9 >> 2 ] | 0 ; $11 = ( $10 | 0 ) == ( 1 ) ; $12 = $2 & - 225 ; $$ = $11 ? $12 : $2 ; $13 = ( ( ( $0 ) ) + 144 | 0 ) ; $14 = HEAP32 [ $13 >> 2 ] | 0 ; $15 = ( $14 | 0 ) == ( 1 ) ; $16 = $$ & - 209 ; $$1 = $15 ? $16 : $$ ; $17 = $$1 & 224 ; $18 = ( $17 | 0 ) == ( 0 ) ; if ( $18 ) { $$2 = $$1 ; $37 = $14 ; } else { $19 = ( ( ( $0 ) ) + 176 | 0 ) ; $20 = HEAP32 [ $19 >> 2 ] | 0 ; $21 = ( $20 | 0 ) == ( 0 | 0 ) ; if ( $21 ) { $22 = $$1 & - 225 ; _png_app_warning ( $0 , 26879 ) ; $$pre = HEAP32 [ $13 >> 2 ] | 0 ; $$2 = $22 ; $37 = $$pre ; } else { $$2 = $$1 ; $37 = $14 ; } } $23 = $$2 >>> 4 ; $$lobit = $23 & 1 ; $24 = $$2 >>> 5 ; $$lobit54 = $24 & 1 ; $$150 = ( ( $$lobit ) + ( $$lobit54 ) ) | 0 ; $25 = $$2 >>> 6 ; $$lobit55 = $25 & 1 ; $$150$ = ( ( $$150 ) + ( $$lobit55 ) ) | 0 ; $26 = $$2 >>> 7 ; $$lobit56 = $26 & 1 ; $$352 = ( ( $$150$ ) + ( $$lobit56 ) ) | 0 ; $27 = ( ( ( $0 ) ) + 228 | 0 ) ; $28 = HEAP8 [ $27 >> 0 ] | 0 ; $29 = $28 & 255 ; $30 = ( ( ( $0 ) ) + 225 | 0 ) ; $31 = HEAP8 [ $30 >> 0 ] | 0 ; $32 = $31 & 255 ; $33 = Math_imul ( $32 , $29 ) | 0 ; $34 = ( $33 >>> 0 ) > ( 7 ) ; if ( $34 ) { $35 = $33 >>> 3 ; $36 = Math_imul ( $35 , $37 ) | 0 ; $42 = $36 ; } else { $38 = Math_imul ( $33 , $37 ) | 0 ; $39 = ( ( $38 ) + 7 ) | 0 ; $40 = $39 >>> 3 ; $42 = $40 ; } $41 = ( ( $42 ) + 1 ) | 0 ; $43 = ( ( ( $0 ) ) + 184 | 0 ) ; $44 = HEAP32 [ $43 >> 2 ] | 0 ; $45 = ( $44 | 0 ) == ( 0 | 0 ) ; if ( $45 ) { $46 = ( _png_malloc ( $0 , $41 ) | 0 ) ; HEAP32 [ $43 >> 2 ] = $46 ; } $47 = ( $$352 >>> 0 ) > ( 1 ) ; if ( $47 ) { $48 = ( ( ( $0 ) ) + 188 | 0 ) ; $49 = HEAP32 [ $48 >> 2 ] | 0 ; $50 = ( $49 | 0 ) == ( 0 | 0 ) ; if ( $50 ) { $51 = ( _png_malloc ( $0 , $41 ) | 0 ) ; HEAP32 [ $48 >> 2 ] = $51 ; $$3 = $$2 ; } else { $$3 = $$2 ; } } else { $$3 = $$2 ; } } $52 = $$3 & 255 ; HEAP8 [ $5 >> 0 ] = $52 ; return ; } function _png_set_compression_level ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $2 = 0 , $3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $2 ) { return ; } $3 = ( ( ( $0 ) ) + 104 | 0 ) ; HEAP32 [ $3 >> 2 ] = $1 ; return ; } function _png_set_compression_mem_level ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $2 = 0 , $3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $2 ) { return ; } $3 = ( ( ( $0 ) ) + 116 | 0 ) ; HEAP32 [ $3 >> 2 ] = $1 ; return ; } function _png_set_compression_strategy ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $2 ) { return ; } $3 = ( ( ( $0 ) ) + 28 | 0 ) ; $4 = HEAP32 [ $3 >> 2 ] | 0 ; $5 = $4 | 1 ; HEAP32 [ $3 >> 2 ] = $5 ; $6 = ( ( ( $0 ) ) + 120 | 0 ) ; HEAP32 [ $6 >> 2 ] = $1 ; return ; } function _png_set_compression_window_bits ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$0 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $2 ) { return ; } $3 = ( $1 | 0 ) > ( 15 ) ; if ( $3 ) { _png_warning ( $0 , 26965 ) ; $$0 = 15 ; } else { $4 = ( $1 | 0 ) < ( 8 ) ; if ( $4 ) { _png_warning ( $0 , 27014 ) ; $$0 = 8 ; } else { $$0 = $1 ; } } $5 = ( ( ( $0 ) ) + 112 | 0 ) ; HEAP32 [ $5 >> 2 ] = $$0 ; return ; } function _png_write_png ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $$01820$i = 0 , $$01922$i = 0 , $$021$i = 0 , $$pre$i = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 ; var $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $5 = 0 , $6 = 0 , $7 = 0 ; var $8 = 0 , $9 = 0 , $exitcond$i = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $4 = ( $0 | 0 ) == ( 0 | 0 ) ; $5 = ( $1 | 0 ) == ( 0 | 0 ) ; $or$cond = $4 | $5 ; if ( $or$cond ) { return ; } $6 = ( ( ( $1 ) ) + 8 | 0 ) ; $7 = HEAP32 [ $6 >> 2 ] | 0 ; $8 = $7 & 32768 ; $9 = ( $8 | 0 ) == ( 0 ) ; if ( $9 ) { _png_app_error ( $0 , 27063 ) ; return ; } _png_write_info ( $0 , $1 ) ; $10 = $2 & 32 ; $11 = ( $10 | 0 ) == ( 0 ) ; if ( ! ( $11 ) ) { _png_app_error ( $0 , 27100 ) ; } $12 = $2 & 64 ; $13 = ( $12 | 0 ) == ( 0 ) ; if ( ! ( $13 ) ) { _png_app_error ( $0 , 27140 ) ; } $14 = $2 & 4 ; $15 = ( $14 | 0 ) == ( 0 ) ; if ( ! ( $15 ) ) { _png_app_error ( $0 , 27174 ) ; } $16 = $2 & 256 ; $17 = ( $16 | 0 ) == ( 0 ) ; if ( ! ( $17 ) ) { _png_app_error ( $0 , 27210 ) ; } $18 = $2 & 6144 ; $19 = ( $18 | 0 ) == ( 0 ) ; if ( ! ( $19 ) ) { _png_app_error ( $0 , 27249 ) ; } $20 = $2 & 128 ; $21 = ( $20 | 0 ) == ( 0 ) ; if ( ! ( $21 ) ) { _png_app_error ( $0 , 27290 ) ; } $22 = $2 & 512 ; $23 = ( $22 | 0 ) == ( 0 ) ; if ( ! ( $23 ) ) { _png_app_error ( $0 , 27322 ) ; } $24 = $2 & 8 ; $25 = ( $24 | 0 ) == ( 0 ) ; if ( ! ( $25 ) ) { _png_app_error ( $0 , 27362 ) ; } $26 = $2 & 1024 ; $27 = ( $26 | 0 ) == ( 0 ) ; if ( ! ( $27 ) ) { _png_app_error ( $0 , 27399 ) ; } $28 = ( ( ( $1 ) ) + 88 | 0 ) ; $29 = HEAP32 [ $28 >> 2 ] | 0 ; $30 = ( _png_set_interlace_handling ( $0 ) | 0 ) ; $31 = ( $30 | 0 ) > ( 0 ) ; if ( $31 ) { $32 = ( ( ( $0 ) ) + 148 | 0 ) ; $$pre$i = HEAP32 [ $32 >> 2 ] | 0 ; $$01922$i = 0 ; $33 = $$pre$i ; while ( 1 ) { $34 = ( $33 | 0 ) == ( 0 ) ; if ( $34 ) { $41 = 0 ; } else { $$01820$i = 0 ; $$021$i = $29 ; while ( 1 ) { $35 = HEAP32 [ $$021$i >> 2 ] | 0 ; _png_write_row ( $0 , $35 ) ; $36 = ( ( $$01820$i ) + 1 ) | 0 ; $37 = ( ( ( $$021$i ) ) + 4 | 0 ) ; $38 = HEAP32 [ $32 >> 2 ] | 0 ; $39 = ( $36 >>> 0 ) < ( $38 >>> 0 ) ; if ( $39 ) { $$01820$i = $36 ; $$021$i = $37 ; } else { $41 = $38 ; break ; } } } $40 = ( ( $$01922$i ) + 1 ) | 0 ; $exitcond$i = ( $40 | 0 ) == ( $30 | 0 ) ; if ( $exitcond$i ) { break ; } else { $$01922$i = $40 ; $33 = $41 ; } } } _png_write_end ( $0 , $1 ) ; return ; } function _png_save_uint_32 ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = $1 >>> 24 ; $3 = $2 & 255 ; HEAP8 [ $0 >> 0 ] = $3 ; $4 = $1 >>> 16 ; $5 = $4 & 255 ; $6 = ( ( ( $0 ) ) + 1 | 0 ) ; HEAP8 [ $6 >> 0 ] = $5 ; $7 = $1 >>> 8 ; $8 = $7 & 255 ; $9 = ( ( ( $0 ) ) + 2 | 0 ) ; HEAP8 [ $9 >> 0 ] = $8 ; $10 = $1 & 255 ; $11 = ( ( ( $0 ) ) + 3 | 0 ) ; HEAP8 [ $11 >> 0 ] = $10 ; return ; } function _png_write_sig ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = sp ; $2 = $1 ; $3 = $2 ; HEAP32 [ $3 >> 2 ] = 1196314761 ; $4 = ( ( $2 ) + 4 ) | 0 ; $5 = $4 ; HEAP32 [ $5 >> 2 ] = 169478669 ; $6 = ( ( ( $0 ) ) + 372 | 0 ) ; HEAP32 [ $6 >> 2 ] = 18 ; $7 = ( ( ( $0 ) ) + 229 | 0 ) ; $8 = HEAP8 [ $7 >> 0 ] | 0 ; $9 = $8 & 255 ; $10 = ( ( $1 ) + ( $9 ) | 0 ) ; $11 = ( 8 - ( $9 ) ) | 0 ; _png_write_data ( $0 , $10 , $11 ) ; $12 = HEAP8 [ $7 >> 0 ] | 0 ; $13 = ( $12 & 255 ) < ( 3 ) ; if ( ! ( $13 ) ) { STACKTOP = sp ; return ; } $14 = ( ( ( $0 ) ) + 24 | 0 ) ; $15 = HEAP32 [ $14 >> 2 ] | 0 ; $16 = $15 | 4096 ; HEAP32 [ $14 >> 2 ] = $16 ; STACKTOP = sp ; return ; } function _png_write_chunk ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 ; var $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond3$i$i = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $4 = sp + 8 | 0 ; $5 = sp ; $6 = HEAP8 [ $1 >> 0 ] | 0 ; $7 = $6 & 255 ; $8 = $7 << 24 ; $9 = ( ( ( $1 ) ) + 1 | 0 ) ; $10 = HEAP8 [ $9 >> 0 ] | 0 ; $11 = $10 & 255 ; $12 = $11 << 16 ; $13 = $12 | $8 ; $14 = ( ( ( $1 ) ) + 2 | 0 ) ; $15 = HEAP8 [ $14 >> 0 ] | 0 ; $16 = $15 & 255 ; $17 = $16 << 8 ; $18 = $13 | $17 ; $19 = ( ( ( $1 ) ) + 3 | 0 ) ; $20 = HEAP8 [ $19 >> 0 ] | 0 ; $21 = $20 & 255 ; $22 = $18 | $21 ; $23 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $23 ) { STACKTOP = sp ; return ; } $24 = ( $3 | 0 ) < ( 0 ) ; if ( $24 ) { _png_error ( $0 , 27440 ) ; // unreachable; } $25 = ( ( ( $0 ) ) + 372 | 0 ) ; HEAP32 [ $25 >> 2 ] = 34 ; $26 = $3 >>> 24 ; $27 = $26 & 255 ; HEAP8 [ $5 >> 0 ] = $27 ; $28 = $3 >>> 16 ; $29 = $28 & 255 ; $30 = ( ( ( $5 ) ) + 1 | 0 ) ; HEAP8 [ $30 >> 0 ] = $29 ; $31 = $3 >>> 8 ; $32 = $31 & 255 ; $33 = ( ( ( $5 ) ) + 2 | 0 ) ; HEAP8 [ $33 >> 0 ] = $32 ; $34 = $3 & 255 ; $35 = ( ( ( $5 ) ) + 3 | 0 ) ; HEAP8 [ $35 >> 0 ] = $34 ; $36 = ( ( ( $5 ) ) + 4 | 0 ) ; HEAP8 [ $36 >> 0 ] = $6 ; $37 = ( ( ( $5 ) ) + 5 | 0 ) ; HEAP8 [ $37 >> 0 ] = $10 ; $38 = ( ( ( $5 ) ) + 6 | 0 ) ; HEAP8 [ $38 >> 0 ] = $15 ; $39 = ( ( ( $5 ) ) + 7 | 0 ) ; HEAP8 [ $39 >> 0 ] = $20 ; _png_write_data ( $0 , $5 , 8 ) ; $40 = ( ( ( $0 ) ) + 172 | 0 ) ; HEAP32 [ $40 >> 2 ] = $22 ; _png_reset_crc ( $0 ) ; _png_calculate_crc ( $0 , $36 , 4 ) ; HEAP32 [ $25 >> 2 ] = 66 ; $41 = ( $2 | 0 ) != ( 0 | 0 ) ; $42 = ( $3 | 0 ) != ( 0 ) ; $or$cond3$i$i = $41 & $42 ; if ( $or$cond3$i$i ) { _png_write_data ( $0 , $2 , $3 ) ; _png_calculate_crc ( $0 , $2 , $3 ) ; } HEAP32 [ $25 >> 2 ] = 130 ; $43 = ( ( ( $0 ) ) + 200 | 0 ) ; $44 = HEAP32 [ $43 >> 2 ] | 0 ; $45 = $44 >>> 24 ; $46 = $45 & 255 ; HEAP8 [ $4 >> 0 ] = $46 ; $47 = $44 >>> 16 ; $48 = $47 & 255 ; $49 = ( ( ( $4 ) ) + 1 | 0 ) ; HEAP8 [ $49 >> 0 ] = $48 ; $50 = $44 >>> 8 ; $51 = $50 & 255 ; $52 = ( ( ( $4 ) ) + 2 | 0 ) ; HEAP8 [ $52 >> 0 ] = $51 ; $53 = $44 & 255 ; $54 = ( ( ( $4 ) ) + 3 | 0 ) ; HEAP8 [ $54 >> 0 ] = $53 ; _png_write_data ( $0 , $4 , 4 ) ; STACKTOP = sp ; return ; } function _png_free_buffer_list ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$0 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = HEAP32 [ $1 >> 2 ] | 0 ; $3 = ( $2 | 0 ) == ( 0 | 0 ) ; if ( $3 ) { return ; } HEAP32 [ $1 >> 2 ] = 0 ; $$0 = $2 ; while ( 1 ) { $4 = HEAP32 [ $$0 >> 2 ] | 0 ; _png_free ( $0 , $$0 ) ; $5 = ( $4 | 0 ) == ( 0 | 0 ) ; if ( $5 ) { break ; } else { $$0 = $4 ; } } return ; } function _png_write_IHDR ( $0 , $1 , $2 , $3 , $4 , $5 , $6 , $7 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; $4 = $4 | 0 ; $5 = $5 | 0 ; $6 = $6 | 0 ; $7 = $7 | 0 ; var $$ = 0 , $$0 = 0 , $$sink = 0 , $$sink4 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 ; var $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 ; var $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 ; var $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 ; var $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $8 = sp + 24 | 0 ; $9 = sp + 16 | 0 ; $10 = sp ; L1 : do { switch ( $4 | 0 ) { case 0 : { switch ( $3 | 0 ) { case 16 : case 8 : case 4 : case 2 : case 1 : { $$sink = 1 ; break L1 ; break ; } default : { } } _png_error ( $0 , 27467 ) ; // unreachable; break ; } case 2 : { switch ( $3 | 0 ) { case 8 : case 16 : { $$sink = 3 ; break L1 ; break ; } default : { } } _png_error ( $0 , 27505 ) ; // unreachable; break ; } case 3 : { switch ( $3 | 0 ) { case 8 : case 4 : case 2 : case 1 : { $$sink = 1 ; break L1 ; break ; } default : { } } _png_error ( $0 , 27537 ) ; // unreachable; break ; } case 4 : { switch ( $3 | 0 ) { case 8 : case 16 : { $$sink = 2 ; break L1 ; break ; } default : { } } _png_error ( $0 , 27574 ) ; // unreachable; break ; } case 6 : { switch ( $3 | 0 ) { case 8 : case 16 : { $$sink = 4 ; break L1 ; break ; } default : { } } _png_error ( $0 , 27618 ) ; // unreachable; break ; } default : { _png_error ( $0 , 27651 ) ; // unreachable; } } } while ( 0 ) ; $11 = ( ( ( $0 ) ) + 227 | 0 ) ; HEAP8 [ $11 >> 0 ] = $$sink ; $12 = ( $5 | 0 ) == ( 0 ) ; if ( ! ( $12 ) ) { _png_warning ( $0 , 27686 ) ; } $13 = ( $6 | 0 ) == ( 0 ) ; if ( ! ( $13 ) ) { _png_warning ( $0 , 27721 ) ; } $14 = ( $7 >>> 0 ) > ( 1 ) ; if ( $14 ) { _png_warning ( $0 , 27751 ) ; $$0 = 1 ; } else { $$0 = $7 ; } $15 = $3 & 255 ; $16 = ( ( ( $0 ) ) + 224 | 0 ) ; HEAP8 [ $16 >> 0 ] = $15 ; $17 = $4 & 255 ; $18 = ( ( ( $0 ) ) + 223 | 0 ) ; HEAP8 [ $18 >> 0 ] = $17 ; $19 = $$0 & 255 ; $20 = ( ( ( $0 ) ) + 220 | 0 ) ; HEAP8 [ $20 >> 0 ] = $19 ; $21 = ( ( ( $0 ) ) + 316 | 0 ) ; HEAP8 [ $21 >> 0 ] = 0 ; $22 = ( ( ( $0 ) ) + 144 | 0 ) ; HEAP32 [ $22 >> 2 ] = $1 ; $23 = ( ( ( $0 ) ) + 148 | 0 ) ; HEAP32 [ $23 >> 2 ] = $2 ; $24 = HEAP8 [ $11 >> 0 ] | 0 ; $25 = $24 & 255 ; $26 = Math_imul ( $25 , $3 ) | 0 ; $27 = $26 & 255 ; $28 = ( ( ( $0 ) ) + 226 | 0 ) ; HEAP8 [ $28 >> 0 ] = $27 ; $29 = $26 & 255 ; $30 = ( $29 >>> 0 ) > ( 7 ) ; if ( $30 ) { $31 = $29 >>> 3 ; $32 = Math_imul ( $31 , $1 ) | 0 ; $37 = $32 ; } else { $33 = Math_imul ( $29 , $1 ) | 0 ; $34 = ( ( $33 ) + 7 ) | 0 ; $35 = $34 >>> 3 ; $37 = $35 ; } $36 = ( ( ( $0 ) ) + 160 | 0 ) ; HEAP32 [ $36 >> 2 ] = $37 ; $38 = ( ( ( $0 ) ) + 156 | 0 ) ; HEAP32 [ $38 >> 2 ] = $1 ; $39 = ( ( ( $0 ) ) + 225 | 0 ) ; HEAP8 [ $39 >> 0 ] = $15 ; $40 = ( ( ( $0 ) ) + 228 | 0 ) ; HEAP8 [ $40 >> 0 ] = $24 ; $41 = $1 >>> 24 ; $42 = $41 & 255 ; HEAP8 [ $10 >> 0 ] = $42 ; $43 = $1 >>> 16 ; $44 = $43 & 255 ; $45 = ( ( ( $10 ) ) + 1 | 0 ) ; HEAP8 [ $45 >> 0 ] = $44 ; $46 = $1 >>> 8 ; $47 = $46 & 255 ; $48 = ( ( ( $10 ) ) + 2 | 0 ) ; HEAP8 [ $48 >> 0 ] = $47 ; $49 = $1 & 255 ; $50 = ( ( ( $10 ) ) + 3 | 0 ) ; HEAP8 [ $50 >> 0 ] = $49 ; $51 = ( ( ( $10 ) ) + 4 | 0 ) ; $52 = $2 >>> 24 ; $53 = $52 & 255 ; HEAP8 [ $51 >> 0 ] = $53 ; $54 = $2 >>> 16 ; $55 = $54 & 255 ; $56 = ( ( ( $10 ) ) + 5 | 0 ) ; HEAP8 [ $56 >> 0 ] = $55 ; $57 = $2 >>> 8 ; $58 = $57 & 255 ; $59 = ( ( ( $10 ) ) + 6 | 0 ) ; HEAP8 [ $59 >> 0 ] = $58 ; $60 = $2 & 255 ; $61 = ( ( ( $10 ) ) + 7 | 0 ) ; HEAP8 [ $61 >> 0 ] = $60 ; $62 = ( ( ( $10 ) ) + 8 | 0 ) ; HEAP8 [ $62 >> 0 ] = $15 ; $63 = ( ( ( $10 ) ) + 9 | 0 ) ; HEAP8 [ $63 >> 0 ] = $17 ; $64 = ( ( ( $10 ) ) + 10 | 0 ) ; HEAP8 [ $64 >> 0 ] = 0 ; $65 = ( ( ( $10 ) ) + 11 | 0 ) ; HEAP8 [ $65 >> 0 ] = 0 ; $66 = ( ( ( $10 ) ) + 12 | 0 ) ; HEAP8 [ $66 >> 0 ] = $19 ; $67 = ( ( ( $0 ) ) + 372 | 0 ) ; HEAP32 [ $67 >> 2 ] = 34 ; HEAP8 [ $8 >> 0 ] = 0 ; $68 = ( ( ( $8 ) ) + 1 | 0 ) ; HEAP8 [ $68 >> 0 ] = 0 ; $69 = ( ( ( $8 ) ) + 2 | 0 ) ; HEAP8 [ $69 >> 0 ] = 0 ; $70 = ( ( ( $8 ) ) + 3 | 0 ) ; HEAP8 [ $70 >> 0 ] = 13 ; $71 = ( ( ( $8 ) ) + 4 | 0 ) ; HEAP8 [ $71 >> 0 ] = 73 ; $72 = ( ( ( $8 ) ) + 5 | 0 ) ; HEAP8 [ $72 >> 0 ] = 72 ; $73 = ( ( ( $8 ) ) + 6 | 0 ) ; HEAP8 [ $73 >> 0 ] = 68 ; $74 = ( ( ( $8 ) ) + 7 | 0 ) ; HEAP8 [ $74 >> 0 ] = 82 ; _png_write_data ( $0 , $8 , 8 ) ; $75 = ( ( ( $0 ) ) + 172 | 0 ) ; HEAP32 [ $75 >> 2 ] = 1229472850 ; _png_reset_crc ( $0 ) ; _png_calculate_crc ( $0 , $71 , 4 ) ; HEAP32 [ $67 >> 2 ] = 66 ; _png_write_data ( $0 , $10 , 13 ) ; _png_calculate_crc ( $0 , $10 , 13 ) ; HEAP32 [ $67 >> 2 ] = 130 ; $76 = ( ( ( $0 ) ) + 200 | 0 ) ; $77 = HEAP32 [ $76 >> 2 ] | 0 ; $78 = $77 >>> 24 ; $79 = $78 & 255 ; HEAP8 [ $9 >> 0 ] = $79 ; $80 = $77 >>> 16 ; $81 = $80 & 255 ; $82 = ( ( ( $9 ) ) + 1 | 0 ) ; HEAP8 [ $82 >> 0 ] = $81 ; $83 = $77 >>> 8 ; $84 = $83 & 255 ; $85 = ( ( ( $9 ) ) + 2 | 0 ) ; HEAP8 [ $85 >> 0 ] = $84 ; $86 = $77 & 255 ; $87 = ( ( ( $9 ) ) + 3 | 0 ) ; HEAP8 [ $87 >> 0 ] = $86 ; _png_write_data ( $0 , $9 , 4 ) ; $88 = ( ( ( $0 ) ) + 222 | 0 ) ; $89 = HEAP8 [ $88 >> 0 ] | 0 ; $90 = ( $89 << 24 >> 24 ) == ( 0 ) ; if ( ! ( $90 ) ) { $95 = ( ( ( $0 ) ) + 24 | 0 ) ; HEAP32 [ $95 >> 2 ] = 1 ; STACKTOP = sp ; return ; } $91 = HEAP8 [ $18 >> 0 ] | 0 ; $92 = ( $91 << 24 >> 24 ) == ( 3 ) ; if ( $92 ) { $$sink4 = 8 ; } else { $93 = HEAP8 [ $16 >> 0 ] | 0 ; $94 = ( $93 & 255 ) < ( 8 ) ; $$ = $94 ? 8 : - 8 ; $$sink4 = $$ ; } HEAP8 [ $88 >> 0 ] = $$sink4 ; $95 = ( ( ( $0 ) ) + 24 | 0 ) ; HEAP32 [ $95 >> 2 ] = 1 ; STACKTOP = sp ; return ; } function _png_write_PLTE ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$02829 = 0 , $$030 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 ; var $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 ; var $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $7 = 0 , $8 = 0 , $9 = 0 ; var $exitcond32 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $3 = sp + 16 | 0 ; $4 = sp + 8 | 0 ; $5 = sp ; $6 = ( ( ( $0 ) ) + 223 | 0 ) ; $7 = HEAP8 [ $6 >> 0 ] | 0 ; $8 = ( $7 << 24 >> 24 ) == ( 3 ) ; if ( $8 ) { $9 = ( ( ( $0 ) ) + 224 | 0 ) ; $10 = HEAP8 [ $9 >> 0 ] | 0 ; $11 = $10 & 255 ; $12 = 1 << $11 ; $15 = $12 ; } else { $15 = 256 ; } $13 = ( ( $2 ) + - 1 ) | 0 ; $14 = ( $13 >>> 0 ) < ( $15 >>> 0 ) ; if ( ! ( $14 ) ) { if ( $8 ) { _png_error ( $0 , 27784 ) ; // unreachable; } _png_warning ( $0 , 27784 ) ; STACKTOP = sp ; return ; } $16 = $7 & 2 ; $17 = ( $16 << 24 >> 24 ) == ( 0 ) ; if ( $17 ) { _png_warning ( $0 , 27820 ) ; STACKTOP = sp ; return ; } $18 = $2 & 65535 ; $19 = ( ( ( $0 ) ) + 208 | 0 ) ; HEAP16 [ $19 >> 1 ] = $18 ; $20 = ( $2 * 3 ) | 0 ; $21 = ( ( ( $0 ) ) + 372 | 0 ) ; HEAP32 [ $21 >> 2 ] = 34 ; $22 = $20 >>> 24 ; $23 = $22 & 255 ; HEAP8 [ $4 >> 0 ] = $23 ; $24 = $20 >>> 16 ; $25 = $24 & 255 ; $26 = ( ( ( $4 ) ) + 1 | 0 ) ; HEAP8 [ $26 >> 0 ] = $25 ; $27 = $20 >>> 8 ; $28 = $27 & 255 ; $29 = ( ( ( $4 ) ) + 2 | 0 ) ; HEAP8 [ $29 >> 0 ] = $28 ; $30 = $20 & 255 ; $31 = ( ( ( $4 ) ) + 3 | 0 ) ; HEAP8 [ $31 >> 0 ] = $30 ; $32 = ( ( ( $4 ) ) + 4 | 0 ) ; HEAP8 [ $32 >> 0 ] = 80 ; $33 = ( ( ( $4 ) ) + 5 | 0 ) ; HEAP8 [ $33 >> 0 ] = 76 ; $34 = ( ( ( $4 ) ) + 6 | 0 ) ; HEAP8 [ $34 >> 0 ] = 84 ; $35 = ( ( ( $4 ) ) + 7 | 0 ) ; HEAP8 [ $35 >> 0 ] = 69 ; _png_write_data ( $0 , $4 , 8 ) ; $36 = ( ( ( $0 ) ) + 172 | 0 ) ; HEAP32 [ $36 >> 2 ] = 1347179589 ; _png_reset_crc ( $0 ) ; _png_calculate_crc ( $0 , $32 , 4 ) ; HEAP32 [ $21 >> 2 ] = 66 ; $37 = ( ( ( $5 ) ) + 1 | 0 ) ; $38 = ( ( ( $5 ) ) + 2 | 0 ) ; $$02829 = 0 ; $$030 = $1 ; while ( 1 ) { $39 = HEAP8 [ $$030 >> 0 ] | 0 ; HEAP8 [ $5 >> 0 ] = $39 ; $40 = ( ( ( $$030 ) ) + 1 | 0 ) ; $41 = HEAP8 [ $40 >> 0 ] | 0 ; HEAP8 [ $37 >> 0 ] = $41 ; $42 = ( ( ( $$030 ) ) + 2 | 0 ) ; $43 = HEAP8 [ $42 >> 0 ] | 0 ; HEAP8 [ $38 >> 0 ] = $43 ; _png_write_data ( $0 , $5 , 3 ) ; _png_calculate_crc ( $0 , $5 , 3 ) ; $44 = ( ( $$02829 ) + 1 ) | 0 ; $45 = ( ( ( $$030 ) ) + 3 | 0 ) ; $exitcond32 = ( $44 | 0 ) == ( $2 | 0 ) ; if ( $exitcond32 ) { break ; } else { $$02829 = $44 ; $$030 = $45 ; } } HEAP32 [ $21 >> 2 ] = 130 ; $46 = ( ( ( $0 ) ) + 200 | 0 ) ; $47 = HEAP32 [ $46 >> 2 ] | 0 ; $48 = $47 >>> 24 ; $49 = $48 & 255 ; HEAP8 [ $3 >> 0 ] = $49 ; $50 = $47 >>> 16 ; $51 = $50 & 255 ; $52 = ( ( ( $3 ) ) + 1 | 0 ) ; HEAP8 [ $52 >> 0 ] = $51 ; $53 = $47 >>> 8 ; $54 = $53 & 255 ; $55 = ( ( ( $3 ) ) + 2 | 0 ) ; HEAP8 [ $55 >> 0 ] = $54 ; $56 = $47 & 255 ; $57 = ( ( ( $3 ) ) + 3 | 0 ) ; HEAP8 [ $57 >> 0 ] = $56 ; _png_write_data ( $0 , $3 , 4 ) ; $58 = ( ( ( $0 ) ) + 24 | 0 ) ; $59 = HEAP32 [ $58 >> 2 ] | 0 ; $60 = $59 | 2 ; HEAP32 [ $58 >> 2 ] = $60 ; STACKTOP = sp ; return ; } function _png_compress_IDAT ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $$$i = 0 , $$0 = 0 , $$0$i = 0 , $$0$i89 = 0 , $$0$i93 = 0 , $$029$i = 0 , $$029$i92 = 0 , $$05$i = 0 , $$0723$i = 0 , $$073$i = 0 , $$0754$i = 0 , $$176$i = 0 , $$phi$trans$insert = 0 , $$pre = 0 , $$pre$phi119Z2D = 0 , $$pre$phi121Z2D = 0 , $$pre$phi123Z2D = 0 , $$pre$phi125Z2D = 0 , $$pre$phi127Z2D = 0 , $$pre$phi129Z2D = 0 ; var $$pre$phi131Z2D = 0 , $$pre118 = 0 , $$pre122 = 0 , $$pre124 = 0 , $$pre126 = 0 , $$pre128 = 0 , $$pre130 = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 ; var $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 ; var $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 ; var $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 ; var $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 , $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 ; var $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 , $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $20 = 0 , $200 = 0 , $201 = 0 ; var $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 , $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 ; var $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 , $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 ; var $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 , $244 = 0 , $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 ; var $257 = 0 , $258 = 0 , $259 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 ; var $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 ; var $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 ; var $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 ; var $97 = 0 , $98 = 0 , $99 = 0 , $not$or$cond = 0 , $or$cond$i = 0 , $or$cond$i91 = 0 , $or$cond3 = 0 , $or$cond31$i = 0 , $or$cond31$i94 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 96 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 96 | 0 ) ; $4 = sp + 88 | 0 ; $5 = sp + 80 | 0 ; $6 = sp + 72 | 0 ; $7 = sp + 64 | 0 ; $8 = sp ; $9 = ( ( ( $0 ) ) + 36 | 0 ) ; $10 = HEAP32 [ $9 >> 2 ] | 0 ; $11 = ( $10 | 0 ) == ( 1229209940 ) ; do { if ( $11 ) { $$pre118 = ( ( ( $0 ) ) + 40 | 0 ) ; $$pre122 = ( ( ( $0 ) ) + 44 | 0 ) ; $$pre124 = ( ( ( $0 ) ) + 56 | 0 ) ; $$pre126 = ( ( ( $0 ) ) + 96 | 0 ) ; $$pre128 = ( ( ( $0 ) ) + 100 | 0 ) ; $$pre130 = ( ( ( $0 ) ) + 52 | 0 ) ; $$pre$phi119Z2D = $$pre118 ; $$pre$phi121Z2D = $$pre118 ; $$pre$phi123Z2D = $$pre122 ; $$pre$phi125Z2D = $$pre124 ; $$pre$phi127Z2D = $$pre126 ; $$pre$phi129Z2D = $$pre128 ; $$pre$phi131Z2D = $$pre130 ; } else { $12 = ( ( ( $0 ) ) + 96 | 0 ) ; $13 = HEAP32 [ $12 >> 2 ] | 0 ; $14 = ( $13 | 0 ) == ( 0 | 0 ) ; if ( $14 ) { $15 = ( ( ( $0 ) ) + 100 | 0 ) ; $16 = HEAP32 [ $15 >> 2 ] | 0 ; $17 = ( ( $16 ) + 4 ) | 0 ; $18 = ( _png_malloc ( $0 , $17 ) | 0 ) ; HEAP32 [ $12 >> 2 ] = $18 ; HEAP32 [ $18 >> 2 ] = 0 ; } else { $19 = HEAP32 [ $13 >> 2 ] | 0 ; $20 = ( $19 | 0 ) == ( 0 | 0 ) ; if ( ! ( $20 ) ) { HEAP32 [ $13 >> 2 ] = 0 ; $$0$i = $19 ; while ( 1 ) { $21 = HEAP32 [ $$0$i >> 2 ] | 0 ; _png_free ( $0 , $$0$i ) ; $22 = ( $21 | 0 ) == ( 0 | 0 ) ; if ( $22 ) { break ; } else { $$0$i = $21 ; } } } } $23 = ( _png_image_size ( $0 ) | 0 ) ; $24 = HEAP32 [ $9 >> 2 ] | 0 ; $25 = ( $24 | 0 ) == ( 0 ) ; do { if ( ! ( $25 ) ) { HEAP8 [ $8 >> 0 ] = 73 ; $26 = ( ( ( $8 ) ) + 1 | 0 ) ; HEAP8 [ $26 >> 0 ] = 68 ; $27 = ( ( ( $8 ) ) + 2 | 0 ) ; HEAP8 [ $27 >> 0 ] = 65 ; $28 = ( ( ( $8 ) ) + 3 | 0 ) ; HEAP8 [ $28 >> 0 ] = 84 ; $29 = ( ( ( $8 ) ) + 4 | 0 ) ; HEAP8 [ $29 >> 0 ] = 58 ; $30 = ( ( ( $8 ) ) + 5 | 0 ) ; HEAP8 [ $30 >> 0 ] = 32 ; $31 = $24 >>> 24 ; $32 = $31 & 255 ; $33 = ( ( ( $8 ) ) + 6 | 0 ) ; HEAP8 [ $33 >> 0 ] = $32 ; $34 = $24 >>> 16 ; $35 = $34 & 255 ; $36 = ( ( ( $8 ) ) + 7 | 0 ) ; HEAP8 [ $36 >> 0 ] = $35 ; $37 = $24 >>> 8 ; $38 = $37 & 255 ; $39 = ( ( ( $8 ) ) + 8 | 0 ) ; HEAP8 [ $39 >> 0 ] = $38 ; $40 = $24 & 255 ; $41 = ( ( ( $8 ) ) + 9 | 0 ) ; HEAP8 [ $41 >> 0 ] = $40 ; ( _png_safecat ( $8 , 64 , 10 , 27876 ) | 0 ) ; _png_warning ( $0 , $8 ) ; $42 = HEAP32 [ $9 >> 2 ] | 0 ; $43 = ( $42 | 0 ) == ( 1229209940 ) ; if ( ! ( $43 ) ) { HEAP32 [ $9 >> 2 ] = 0 ; break ; } $44 = ( ( ( $0 ) ) + 64 | 0 ) ; HEAP32 [ $44 >> 2 ] = 27891 ; $105 = 27891 ; _png_error ( $0 , $105 ) ; // unreachable; } } while ( 0 ) ; $45 = ( ( ( $0 ) ) + 104 | 0 ) ; $46 = HEAP32 [ $45 >> 2 ] | 0 ; $47 = ( ( ( $0 ) ) + 108 | 0 ) ; $48 = HEAP32 [ $47 >> 2 ] | 0 ; $49 = ( ( ( $0 ) ) + 112 | 0 ) ; $50 = HEAP32 [ $49 >> 2 ] | 0 ; $51 = ( ( ( $0 ) ) + 116 | 0 ) ; $52 = HEAP32 [ $51 >> 2 ] | 0 ; $53 = ( ( ( $0 ) ) + 28 | 0 ) ; $54 = HEAP32 [ $53 >> 2 ] | 0 ; $55 = $54 & 1 ; $56 = ( $55 | 0 ) == ( 0 ) ; if ( $56 ) { $59 = ( ( ( $0 ) ) + 222 | 0 ) ; $60 = HEAP8 [ $59 >> 0 ] | 0 ; $61 = ( $60 << 24 >> 24 ) != ( 8 ) ; $$$i = $61 & 1 ; $$073$i = $$$i ; } else { $57 = ( ( ( $0 ) ) + 120 | 0 ) ; $58 = HEAP32 [ $57 >> 2 ] | 0 ; $$073$i = $58 ; } $62 = ( $23 >>> 0 ) < ( 16385 ) ; if ( $62 ) { $63 = ( ( $50 ) + - 1 ) | 0 ; $64 = 1 << $63 ; $65 = ( ( $23 ) + 262 ) | 0 ; $66 = ( $65 >>> 0 ) > ( $64 >>> 0 ) ; if ( $66 ) { $$176$i = $50 ; } else { $$05$i = $64 ; $$0754$i = $50 ; while ( 1 ) { $67 = $$05$i >>> 1 ; $68 = ( ( $$0754$i ) + - 1 ) | 0 ; $69 = ( $65 >>> 0 ) > ( $67 >>> 0 ) ; if ( $69 ) { $$176$i = $68 ; break ; } else { $$05$i = $67 ; $$0754$i = $68 ; } } } } else { $$176$i = $50 ; } $70 = $54 & 2 ; $71 = ( $70 | 0 ) == ( 0 ) ; do { if ( $71 ) { $97 = $54 ; } else { $72 = ( ( ( $0 ) ) + 124 | 0 ) ; $73 = HEAP32 [ $72 >> 2 ] | 0 ; $74 = ( $73 | 0 ) == ( $46 | 0 ) ; if ( $74 ) { $75 = ( ( ( $0 ) ) + 128 | 0 ) ; $76 = HEAP32 [ $75 >> 2 ] | 0 ; $77 = ( $76 | 0 ) == ( $48 | 0 ) ; if ( $77 ) { $78 = ( ( ( $0 ) ) + 132 | 0 ) ; $79 = HEAP32 [ $78 >> 2 ] | 0 ; $80 = ( $79 | 0 ) == ( $$176$i | 0 ) ; if ( $80 ) { $81 = ( ( ( $0 ) ) + 136 | 0 ) ; $82 = HEAP32 [ $81 >> 2 ] | 0 ; $83 = ( $82 | 0 ) == ( $52 | 0 ) ; if ( $83 ) { $84 = ( ( ( $0 ) ) + 140 | 0 ) ; $85 = HEAP32 [ $84 >> 2 ] | 0 ; $86 = ( $85 | 0 ) == ( $$073$i | 0 ) ; if ( $86 ) { $97 = $54 ; break ; } } } } } $87 = ( ( ( $0 ) ) + 40 | 0 ) ; $88 = ( _deflateEnd ( $87 ) | 0 ) ; $89 = ( $88 | 0 ) == ( 0 ) ; if ( ! ( $89 ) ) { _png_warning ( $0 , 27906 ) ; } $90 = HEAP32 [ $53 >> 2 ] | 0 ; $91 = $90 & - 3 ; HEAP32 [ $53 >> 2 ] = $91 ; $97 = $91 ; } } while ( 0 ) ; $92 = ( ( ( $0 ) ) + 40 | 0 ) ; HEAP32 [ $92 >> 2 ] = 0 ; $93 = ( ( ( $0 ) ) + 44 | 0 ) ; HEAP32 [ $93 >> 2 ] = 0 ; $94 = ( ( ( $0 ) ) + 52 | 0 ) ; HEAP32 [ $94 >> 2 ] = 0 ; $95 = ( ( ( $0 ) ) + 56 | 0 ) ; HEAP32 [ $95 >> 2 ] = 0 ; $96 = $97 & 2 ; $98 = ( $96 | 0 ) == ( 0 ) ; if ( $98 ) { $99 = ( _deflateInit2_ ( $92 , $46 , $48 , $$176$i , $52 , $$073$i , 29663 , 56 ) | 0 ) ; $100 = ( $99 | 0 ) == ( 0 ) ; if ( $100 ) { $101 = HEAP32 [ $53 >> 2 ] | 0 ; $102 = $101 | 2 ; HEAP32 [ $53 >> 2 ] = $102 ; label = 33 ; } else { $$0723$i = $99 ; } } else { $103 = ( _deflateReset ( $92 ) | 0 ) ; $104 = ( $103 | 0 ) == ( 0 ) ; if ( $104 ) { label = 33 ; } else { $$0723$i = $103 ; } } if ( ( label | 0 ) == 33 ) { HEAP32 [ $9 >> 2 ] = 1229209940 ; $106 = HEAP32 [ $12 >> 2 ] | 0 ; $107 = ( ( ( $106 ) ) + 4 | 0 ) ; HEAP32 [ $94 >> 2 ] = $107 ; $108 = ( ( ( $0 ) ) + 100 | 0 ) ; $109 = HEAP32 [ $108 >> 2 ] | 0 ; HEAP32 [ $95 >> 2 ] = $109 ; $$pre$phi119Z2D = $92 ; $$pre$phi121Z2D = $92 ; $$pre$phi123Z2D = $93 ; $$pre$phi125Z2D = $95 ; $$pre$phi127Z2D = $12 ; $$pre$phi129Z2D = $108 ; $$pre$phi131Z2D = $94 ; break ; } _png_zstream_error ( $0 , $$0723$i ) ; $$phi$trans$insert = ( ( ( $0 ) ) + 64 | 0 ) ; $$pre = HEAP32 [ $$phi$trans$insert >> 2 ] | 0 ; $105 = $$pre ; _png_error ( $0 , $105 ) ; // unreachable; } } while ( 0 ) ; HEAP32 [ $$pre$phi121Z2D >> 2 ] = $1 ; HEAP32 [ $$pre$phi123Z2D >> 2 ] = 0 ; $110 = ( ( ( $0 ) ) + 24 | 0 ) ; $111 = ( ( ( $0 ) ) + 316 | 0 ) ; $112 = ( $3 | 0 ) == ( 0 ) ; $113 = ( ( ( $0 ) ) + 372 | 0 ) ; $114 = ( ( ( $6 ) ) + 1 | 0 ) ; $115 = ( ( ( $6 ) ) + 2 | 0 ) ; $116 = ( ( ( $6 ) ) + 3 | 0 ) ; $117 = ( ( ( $6 ) ) + 4 | 0 ) ; $118 = ( ( ( $6 ) ) + 5 | 0 ) ; $119 = ( ( ( $6 ) ) + 6 | 0 ) ; $120 = ( ( ( $6 ) ) + 7 | 0 ) ; $121 = ( ( ( $0 ) ) + 172 | 0 ) ; $122 = ( ( ( $0 ) ) + 200 | 0 ) ; $123 = ( ( ( $7 ) ) + 1 | 0 ) ; $124 = ( ( ( $7 ) ) + 2 | 0 ) ; $125 = ( ( ( $7 ) ) + 3 | 0 ) ; $$0 = $2 ; while ( 1 ) { HEAP32 [ $$pre$phi123Z2D >> 2 ] = $$0 ; $126 = ( _deflate ( $$pre$phi119Z2D , $3 ) | 0 ) ; $127 = HEAP32 [ $$pre$phi123Z2D >> 2 ] | 0 ; HEAP32 [ $$pre$phi123Z2D >> 2 ] = 0 ; $128 = HEAP32 [ $$pre$phi125Z2D >> 2 ] | 0 ; $129 = ( $128 | 0 ) == ( 0 ) ; if ( $129 ) { $130 = HEAP32 [ $$pre$phi127Z2D >> 2 ] | 0 ; $131 = ( ( ( $130 ) ) + 4 | 0 ) ; $132 = HEAP32 [ $$pre$phi129Z2D >> 2 ] | 0 ; $133 = HEAP32 [ $110 >> 2 ] | 0 ; $134 = $133 & 4 ; $135 = ( $134 | 0 ) == ( 0 ) ; if ( $135 ) { $136 = HEAP8 [ $111 >> 0 ] | 0 ; $137 = ( $136 << 24 >> 24 ) == ( 0 ) ; if ( $137 ) { $138 = ( _png_image_size ( $0 ) | 0 ) ; $139 = ( $138 >>> 0 ) < ( 16385 ) ; if ( $139 ) { $140 = HEAP8 [ $131 >> 0 ] | 0 ; $141 = $140 & 255 ; $142 = $141 & 15 ; $143 = ( $142 | 0 ) == ( 8 ) ; $144 = $141 & 240 ; $145 = ( $144 >>> 0 ) < ( 113 ) ; $or$cond$i = $143 & $145 ; if ( $or$cond$i ) { $146 = $141 >>> 4 ; $147 = 128 << $146 ; $148 = ( $147 >>> 0 ) < ( $138 >>> 0 ) ; if ( ! ( $148 ) ) { $$0$i89 = $147 ; $$029$i = $146 ; while ( 1 ) { $149 = $$0$i89 >>> 1 ; $150 = ( ( $$029$i ) + - 1 ) | 0 ; $151 = ( $150 | 0 ) == ( 0 ) ; $152 = ( $149 >>> 0 ) < ( $138 >>> 0 ) ; $or$cond31$i = $151 | $152 ; if ( $or$cond31$i ) { break ; } else { $$0$i89 = $149 ; $$029$i = $150 ; } } $153 = $150 << 4 ; $154 = $153 | 8 ; $155 = $154 & 255 ; HEAP8 [ $131 >> 0 ] = $155 ; $156 = ( ( ( $130 ) ) + 5 | 0 ) ; $157 = HEAP8 [ $156 >> 0 ] | 0 ; $158 = $157 & - 32 ; $159 = $158 & 255 ; $160 = $154 << 8 ; $161 = $160 | $159 ; $162 = ( ( $161 >>> 0 ) % 31 ) & - 1 ; $163 = $162 | $159 ; $164 = $163 ^ 31 ; $165 = $164 & 255 ; HEAP8 [ $156 >> 0 ] = $165 ; } } } } } $166 = ( $132 | 0 ) == ( 0 ) ; if ( ! ( $166 ) ) { $167 = ( $132 | 0 ) < ( 0 ) ; if ( $167 ) { label = 45 ; break ; } HEAP32 [ $113 >> 2 ] = 34 ; $168 = $132 >>> 24 ; $169 = $168 & 255 ; HEAP8 [ $6 >> 0 ] = $169 ; $170 = $132 >>> 16 ; $171 = $170 & 255 ; HEAP8 [ $114 >> 0 ] = $171 ; $172 = $132 >>> 8 ; $173 = $172 & 255 ; HEAP8 [ $115 >> 0 ] = $173 ; $174 = $132 & 255 ; HEAP8 [ $116 >> 0 ] = $174 ; HEAP8 [ $117 >> 0 ] = 73 ; HEAP8 [ $118 >> 0 ] = 68 ; HEAP8 [ $119 >> 0 ] = 65 ; HEAP8 [ $120 >> 0 ] = 84 ; _png_write_data ( $0 , $6 , 8 ) ; HEAP32 [ $121 >> 2 ] = 1229209940 ; _png_reset_crc ( $0 ) ; _png_calculate_crc ( $0 , $117 , 4 ) ; HEAP32 [ $113 >> 2 ] = 66 ; _png_write_data ( $0 , $131 , $132 ) ; _png_calculate_crc ( $0 , $131 , $132 ) ; HEAP32 [ $113 >> 2 ] = 130 ; $175 = HEAP32 [ $122 >> 2 ] | 0 ; $176 = $175 >>> 24 ; $177 = $176 & 255 ; HEAP8 [ $7 >> 0 ] = $177 ; $178 = $175 >>> 16 ; $179 = $178 & 255 ; HEAP8 [ $123 >> 0 ] = $179 ; $180 = $175 >>> 8 ; $181 = $180 & 255 ; HEAP8 [ $124 >> 0 ] = $181 ; $182 = $175 & 255 ; HEAP8 [ $125 >> 0 ] = $182 ; _png_write_data ( $0 , $7 , 4 ) ; } $183 = HEAP32 [ $110 >> 2 ] | 0 ; $184 = $183 | 4 ; HEAP32 [ $110 >> 2 ] = $184 ; HEAP32 [ $$pre$phi131Z2D >> 2 ] = $131 ; HEAP32 [ $$pre$phi125Z2D >> 2 ] = $132 ; $185 = ( $126 | 0 ) != ( 0 ) ; $not$or$cond = $112 | $185 ; if ( $not$or$cond ) { $195 = $132 ; } else { $$0 = $127 ; continue ; } } else { $195 = $128 ; } $186 = ( $126 | 0 ) == ( 0 ) ; if ( ! ( $186 ) ) { label = 52 ; break ; } $187 = ( $127 | 0 ) == ( 0 ) ; if ( $187 ) { label = 50 ; break ; } else { $$0 = $127 ; } } if ( ( label | 0 ) == 45 ) { _png_error ( $0 , 27440 ) ; // unreachable; } else if ( ( label | 0 ) == 50 ) { $188 = ( $3 | 0 ) == ( 4 ) ; if ( $188 ) { _png_error ( $0 , 27934 ) ; // unreachable; } else { STACKTOP = sp ; return ; } } else if ( ( label | 0 ) == 52 ) { $189 = ( $126 | 0 ) == ( 1 ) ; $190 = ( $3 | 0 ) == ( 4 ) ; $or$cond3 = $190 & $189 ; if ( ! ( $or$cond3 ) ) { _png_zstream_error ( $0 , $126 ) ; $258 = ( ( ( $0 ) ) + 64 | 0 ) ; $259 = HEAP32 [ $258 >> 2 ] | 0 ; _png_error ( $0 , $259 ) ; // unreachable; } $191 = HEAP32 [ $$pre$phi127Z2D >> 2 ] | 0 ; $192 = ( ( ( $191 ) ) + 4 | 0 ) ; $193 = HEAP32 [ $$pre$phi129Z2D >> 2 ] | 0 ; $194 = ( ( $193 ) - ( $195 ) ) | 0 ; $196 = HEAP32 [ $110 >> 2 ] | 0 ; $197 = $196 & 4 ; $198 = ( $197 | 0 ) == ( 0 ) ; if ( $198 ) { $199 = HEAP8 [ $111 >> 0 ] | 0 ; $200 = ( $199 << 24 >> 24 ) == ( 0 ) ; if ( $200 ) { $201 = ( _png_image_size ( $0 ) | 0 ) ; $202 = ( $201 >>> 0 ) < ( 16385 ) ; if ( $202 ) { $203 = HEAP8 [ $192 >> 0 ] | 0 ; $204 = $203 & 255 ; $205 = $204 & 15 ; $206 = ( $205 | 0 ) == ( 8 ) ; $207 = $204 & 240 ; $208 = ( $207 >>> 0 ) < ( 113 ) ; $or$cond$i91 = $206 & $208 ; if ( $or$cond$i91 ) { $209 = $204 >>> 4 ; $210 = 128 << $209 ; $211 = ( $210 >>> 0 ) < ( $201 >>> 0 ) ; if ( ! ( $211 ) ) { $$0$i93 = $210 ; $$029$i92 = $209 ; while ( 1 ) { $212 = $$0$i93 >>> 1 ; $213 = ( ( $$029$i92 ) + - 1 ) | 0 ; $214 = ( $213 | 0 ) == ( 0 ) ; $215 = ( $212 >>> 0 ) < ( $201 >>> 0 ) ; $or$cond31$i94 = $214 | $215 ; if ( $or$cond31$i94 ) { break ; } else { $$0$i93 = $212 ; $$029$i92 = $213 ; } } $216 = $213 << 4 ; $217 = $216 | 8 ; $218 = $217 & 255 ; HEAP8 [ $192 >> 0 ] = $218 ; $219 = ( ( ( $191 ) ) + 5 | 0 ) ; $220 = HEAP8 [ $219 >> 0 ] | 0 ; $221 = $220 & - 32 ; $222 = $221 & 255 ; $223 = $217 << 8 ; $224 = $223 | $222 ; $225 = ( ( $224 >>> 0 ) % 31 ) & - 1 ; $226 = $225 | $222 ; $227 = $226 ^ 31 ; $228 = $227 & 255 ; HEAP8 [ $219 >> 0 ] = $228 ; } } } } } $229 = ( $194 | 0 ) == ( 0 ) ; do { if ( ! ( $229 ) ) { $230 = ( $194 | 0 ) < ( 0 ) ; if ( $230 ) { _png_error ( $0 , 27440 ) ; // unreachable; } else { HEAP32 [ $113 >> 2 ] = 34 ; $231 = $194 >>> 24 ; $232 = $231 & 255 ; HEAP8 [ $5 >> 0 ] = $232 ; $233 = $194 >>> 16 ; $234 = $233 & 255 ; $235 = ( ( ( $5 ) ) + 1 | 0 ) ; HEAP8 [ $235 >> 0 ] = $234 ; $236 = $194 >>> 8 ; $237 = $236 & 255 ; $238 = ( ( ( $5 ) ) + 2 | 0 ) ; HEAP8 [ $238 >> 0 ] = $237 ; $239 = $194 & 255 ; $240 = ( ( ( $5 ) ) + 3 | 0 ) ; HEAP8 [ $240 >> 0 ] = $239 ; $241 = ( ( ( $5 ) ) + 4 | 0 ) ; HEAP8 [ $241 >> 0 ] = 73 ; $242 = ( ( ( $5 ) ) + 5 | 0 ) ; HEAP8 [ $242 >> 0 ] = 68 ; $243 = ( ( ( $5 ) ) + 6 | 0 ) ; HEAP8 [ $243 >> 0 ] = 65 ; $244 = ( ( ( $5 ) ) + 7 | 0 ) ; HEAP8 [ $244 >> 0 ] = 84 ; _png_write_data ( $0 , $5 , 8 ) ; HEAP32 [ $121 >> 2 ] = 1229209940 ; _png_reset_crc ( $0 ) ; _png_calculate_crc ( $0 , $241 , 4 ) ; HEAP32 [ $113 >> 2 ] = 66 ; _png_write_data ( $0 , $192 , $194 ) ; _png_calculate_crc ( $0 , $192 , $194 ) ; HEAP32 [ $113 >> 2 ] = 130 ; $245 = HEAP32 [ $122 >> 2 ] | 0 ; $246 = $245 >>> 24 ; $247 = $246 & 255 ; HEAP8 [ $4 >> 0 ] = $247 ; $248 = $245 >>> 16 ; $249 = $248 & 255 ; $250 = ( ( ( $4 ) ) + 1 | 0 ) ; HEAP8 [ $250 >> 0 ] = $249 ; $251 = $245 >>> 8 ; $252 = $251 & 255 ; $253 = ( ( ( $4 ) ) + 2 | 0 ) ; HEAP8 [ $253 >> 0 ] = $252 ; $254 = $245 & 255 ; $255 = ( ( ( $4 ) ) + 3 | 0 ) ; HEAP8 [ $255 >> 0 ] = $254 ; _png_write_data ( $0 , $4 , 4 ) ; break ; } } } while ( 0 ) ; HEAP32 [ $$pre$phi125Z2D >> 2 ] = 0 ; HEAP32 [ $$pre$phi131Z2D >> 2 ] = 0 ; $256 = HEAP32 [ $110 >> 2 ] | 0 ; $257 = $256 | 12 ; HEAP32 [ $110 >> 2 ] = $257 ; HEAP32 [ $9 >> 2 ] = 0 ; STACKTOP = sp ; return ; } } function _png_image_size ( $0 ) { $0 = $0 | 0 ; var $$0 = 0 , $$042 = 0 , $$042$ph = 0 , $$042$ph$us = 0 , $$042$us = 0 , $$043$ph = 0 , $$043$ph$us = 0 , $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 ; var $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 ; var $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 ; var $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 ; var $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( ( ( $0 ) ) + 148 | 0 ) ; $2 = HEAP32 [ $1 >> 2 ] | 0 ; $3 = ( ( ( $0 ) ) + 160 | 0 ) ; $4 = HEAP32 [ $3 >> 2 ] | 0 ; $5 = $4 | $2 ; $6 = ( $5 >>> 0 ) < ( 32768 ) ; if ( ! ( $6 ) ) { $$0 = - 1 ; return ( $$0 | 0 ) ; } $7 = ( ( ( $0 ) ) + 220 | 0 ) ; $8 = HEAP8 [ $7 >> 0 ] | 0 ; $9 = ( $8 << 24 >> 24 ) == ( 0 ) ; if ( $9 ) { $87 = ( ( $4 ) + 1 ) | 0 ; $88 = Math_imul ( $87 , $2 ) | 0 ; $$0 = $88 ; return ( $$0 | 0 ) ; } $10 = ( ( ( $0 ) ) + 144 | 0 ) ; $11 = HEAP32 [ $10 >> 2 ] | 0 ; $12 = ( ( ( $0 ) ) + 226 | 0 ) ; $13 = HEAP8 [ $12 >> 0 ] | 0 ; $14 = $13 & 255 ; $15 = ( ( $11 ) + - 1 ) | 0 ; $16 = ( $13 & 255 ) > ( 7 ) ; $17 = $14 >>> 3 ; $18 = ( ( $2 ) + - 1 ) | 0 ; if ( $16 ) { $$042$ph$us = 0 ; $$043$ph$us = 0 ; L9 : while ( 1 ) { $$042$us = $$042$ph$us ; while ( 1 ) { $51 = ( $$042$us | 0 ) < ( 7 ) ; if ( ! ( $51 ) ) { $$0 = $$043$ph$us ; break L9 ; } $19 = ( $$042$us | 0 ) > ( 1 ) ; $20 = ( 7 - ( $$042$us ) ) | 0 ; $21 = $20 >> 1 ; $22 = $19 ? $21 : 3 ; $23 = 1 << $22 ; $24 = $$042$us & 1 ; $25 = ( ( $$042$us ) + 1 ) | 0 ; $26 = $25 >> 1 ; $27 = ( 3 - ( $26 ) ) | 0 ; $28 = $24 << $27 ; $29 = $28 & 7 ; $30 = ( ( $15 ) + ( $23 ) ) | 0 ; $31 = ( ( $30 ) - ( $29 ) ) | 0 ; $32 = $31 >>> $22 ; $33 = ( $32 | 0 ) == ( 0 ) ; if ( $33 ) { $$042$us = $25 ; } else { break ; } } $34 = Math_imul ( $32 , $17 ) | 0 ; $35 = ( ( $34 ) + 1 ) | 0 ; $36 = ( $$042$us | 0 ) > ( 2 ) ; $37 = ( 8 - ( $$042$us ) ) | 0 ; $38 = $37 >> 1 ; $39 = $36 ? $38 : 3 ; $40 = 1 << $39 ; $41 = $24 ^ 1 ; $42 = $$042$us >> 1 ; $43 = ( 3 - ( $42 ) ) | 0 ; $44 = $41 << $43 ; $45 = $44 & 7 ; $46 = ( ( $18 ) + ( $40 ) ) | 0 ; $47 = ( ( $46 ) - ( $45 ) ) | 0 ; $48 = $47 >>> $39 ; $49 = Math_imul ( $35 , $48 ) | 0 ; $50 = ( ( $49 ) + ( $$043$ph$us ) ) | 0 ; $$042$ph$us = $25 ; $$043$ph$us = $50 ; } return ( $$0 | 0 ) ; } else { $$042$ph = 0 ; $$043$ph = 0 ; L16 : while ( 1 ) { $$042 = $$042$ph ; while ( 1 ) { $52 = ( $$042 | 0 ) < ( 7 ) ; if ( ! ( $52 ) ) { $$0 = $$043$ph ; break L16 ; } $53 = ( $$042 | 0 ) > ( 1 ) ; $54 = ( 7 - ( $$042 ) ) | 0 ; $55 = $54 >> 1 ; $56 = $53 ? $55 : 3 ; $57 = 1 << $56 ; $58 = $$042 & 1 ; $59 = ( ( $$042 ) + 1 ) | 0 ; $60 = $59 >> 1 ; $61 = ( 3 - ( $60 ) ) | 0 ; $62 = $58 << $61 ; $63 = $62 & 7 ; $64 = ( ( $15 ) + ( $57 ) ) | 0 ; $65 = ( ( $64 ) - ( $63 ) ) | 0 ; $66 = $65 >>> $56 ; $67 = ( $66 | 0 ) == ( 0 ) ; if ( $67 ) { $$042 = $59 ; } else { break ; } } $68 = Math_imul ( $66 , $14 ) | 0 ; $69 = ( ( $68 ) + 7 ) | 0 ; $70 = $69 >>> 3 ; $71 = ( ( $70 ) + 1 ) | 0 ; $72 = ( $$042 | 0 ) > ( 2 ) ; $73 = ( 8 - ( $$042 ) ) | 0 ; $74 = $73 >> 1 ; $75 = $72 ? $74 : 3 ; $76 = 1 << $75 ; $77 = $58 ^ 1 ; $78 = $$042 >> 1 ; $79 = ( 3 - ( $78 ) ) | 0 ; $80 = $77 << $79 ; $81 = $80 & 7 ; $82 = ( ( $18 ) + ( $76 ) ) | 0 ; $83 = ( ( $82 ) - ( $81 ) ) | 0 ; $84 = $83 >>> $75 ; $85 = Math_imul ( $71 , $84 ) | 0 ; $86 = ( ( $85 ) + ( $$043$ph ) ) | 0 ; $$042$ph = $59 ; $$043$ph = $86 ; } return ( $$0 | 0 ) ; } return ( 0 ) | 0 ; } function _png_write_IEND ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $3 = 0 , $4 = 0 , $5 = 0 ; var $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = sp ; $2 = sp + 8 | 0 ; $3 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $3 ) { $22 = ( ( ( $0 ) ) + 24 | 0 ) ; $23 = HEAP32 [ $22 >> 2 ] | 0 ; $24 = $23 | 16 ; HEAP32 [ $22 >> 2 ] = $24 ; STACKTOP = sp ; return ; } $4 = ( ( ( $0 ) ) + 372 | 0 ) ; HEAP32 [ $4 >> 2 ] = 34 ; $5 = ( ( ( $1 ) ) + 4 | 0 ) ; HEAP32 [ $1 >> 2 ] = 0 ; HEAP8 [ $5 >> 0 ] = 73 ; $6 = ( ( ( $1 ) ) + 5 | 0 ) ; HEAP8 [ $6 >> 0 ] = 69 ; $7 = ( ( ( $1 ) ) + 6 | 0 ) ; HEAP8 [ $7 >> 0 ] = 78 ; $8 = ( ( ( $1 ) ) + 7 | 0 ) ; HEAP8 [ $8 >> 0 ] = 68 ; _png_write_data ( $0 , $1 , 8 ) ; $9 = ( ( ( $0 ) ) + 172 | 0 ) ; HEAP32 [ $9 >> 2 ] = 1229278788 ; _png_reset_crc ( $0 ) ; _png_calculate_crc ( $0 , $5 , 4 ) ; HEAP32 [ $4 >> 2 ] = 130 ; $10 = ( ( ( $0 ) ) + 200 | 0 ) ; $11 = HEAP32 [ $10 >> 2 ] | 0 ; $12 = $11 >>> 24 ; $13 = $12 & 255 ; HEAP8 [ $2 >> 0 ] = $13 ; $14 = $11 >>> 16 ; $15 = $14 & 255 ; $16 = ( ( ( $2 ) ) + 1 | 0 ) ; HEAP8 [ $16 >> 0 ] = $15 ; $17 = $11 >>> 8 ; $18 = $17 & 255 ; $19 = ( ( ( $2 ) ) + 2 | 0 ) ; HEAP8 [ $19 >> 0 ] = $18 ; $20 = $11 & 255 ; $21 = ( ( ( $2 ) ) + 3 | 0 ) ; HEAP8 [ $21 >> 0 ] = $20 ; _png_write_data ( $0 , $2 , 4 ) ; $22 = ( ( ( $0 ) ) + 24 | 0 ) ; $23 = HEAP32 [ $22 >> 2 ] | 0 ; $24 = $23 | 16 ; HEAP32 [ $22 >> 2 ] = $24 ; STACKTOP = sp ; return ; } function _png_write_sBIT ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$1 = 0 , $$236 = 0 , $$sink = 0 , $$sink35 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 ; var $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 ; var $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 ; var $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $3 = sp + 16 | 0 ; $4 = sp + 8 | 0 ; $5 = sp ; $6 = $2 & 2 ; $7 = ( $6 | 0 ) == ( 0 ) ; do { if ( $7 ) { $24 = ( ( ( $1 ) ) + 3 | 0 ) ; $25 = HEAP8 [ $24 >> 0 ] | 0 ; $26 = ( $25 << 24 >> 24 ) == ( 0 ) ; if ( ! ( $26 ) ) { $27 = ( ( ( $0 ) ) + 225 | 0 ) ; $28 = HEAP8 [ $27 >> 0 ] | 0 ; $29 = ( $25 & 255 ) > ( $28 & 255 ) ; if ( ! ( $29 ) ) { $$1 = 1 ; $$sink = $25 ; $$sink35 = 0 ; break ; } } _png_warning ( $0 , 27969 ) ; STACKTOP = sp ; return ; } else { $8 = ( $2 | 0 ) == ( 3 ) ; if ( $8 ) { $14 = 8 ; } else { $9 = ( ( ( $0 ) ) + 225 | 0 ) ; $10 = HEAP8 [ $9 >> 0 ] | 0 ; $14 = $10 ; } $11 = HEAP8 [ $1 >> 0 ] | 0 ; $12 = ( ( $11 ) + - 1 ) << 24 >> 24 ; $13 = ( $12 & 255 ) < ( $14 & 255 ) ; if ( $13 ) { $15 = ( ( ( $1 ) ) + 1 | 0 ) ; $16 = HEAP8 [ $15 >> 0 ] | 0 ; $17 = ( ( $16 ) + - 1 ) << 24 >> 24 ; $18 = ( $17 & 255 ) < ( $14 & 255 ) ; if ( $18 ) { $19 = ( ( ( $1 ) ) + 2 | 0 ) ; $20 = HEAP8 [ $19 >> 0 ] | 0 ; $21 = ( ( $20 ) + - 1 ) << 24 >> 24 ; $22 = ( $21 & 255 ) < ( $14 & 255 ) ; if ( $22 ) { HEAP8 [ $5 >> 0 ] = $11 ; $23 = ( ( ( $5 ) ) + 1 | 0 ) ; HEAP8 [ $23 >> 0 ] = $16 ; $$1 = 3 ; $$sink = $20 ; $$sink35 = 2 ; break ; } } } _png_warning ( $0 , 27969 ) ; STACKTOP = sp ; return ; } } while ( 0 ) ; $30 = ( ( $5 ) + ( $$sink35 ) | 0 ) ; HEAP8 [ $30 >> 0 ] = $$sink ; $31 = $2 & 4 ; $32 = ( $31 | 0 ) == ( 0 ) ; do { if ( $32 ) { $41 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $41 ) { STACKTOP = sp ; return ; } else { $$236 = $$1 ; } } else { $33 = ( ( ( $1 ) ) + 4 | 0 ) ; $34 = HEAP8 [ $33 >> 0 ] | 0 ; $35 = ( $34 << 24 >> 24 ) == ( 0 ) ; if ( ! ( $35 ) ) { $36 = ( ( ( $0 ) ) + 225 | 0 ) ; $37 = HEAP8 [ $36 >> 0 ] | 0 ; $38 = ( $34 & 255 ) > ( $37 & 255 ) ; if ( ! ( $38 ) ) { $39 = ( ( $$1 ) + 1 ) | 0 ; $40 = ( ( $5 ) + ( $$1 ) | 0 ) ; HEAP8 [ $40 >> 0 ] = $34 ; $$236 = $39 ; break ; } } _png_warning ( $0 , 27969 ) ; STACKTOP = sp ; return ; } } while ( 0 ) ; $42 = ( ( ( $0 ) ) + 372 | 0 ) ; HEAP32 [ $42 >> 2 ] = 34 ; $43 = $$236 >>> 24 ; $44 = $43 & 255 ; HEAP8 [ $4 >> 0 ] = $44 ; $45 = $$236 >>> 16 ; $46 = $45 & 255 ; $47 = ( ( ( $4 ) ) + 1 | 0 ) ; HEAP8 [ $47 >> 0 ] = $46 ; $48 = $$236 >>> 8 ; $49 = $48 & 255 ; $50 = ( ( ( $4 ) ) + 2 | 0 ) ; HEAP8 [ $50 >> 0 ] = $49 ; $51 = $$236 & 255 ; $52 = ( ( ( $4 ) ) + 3 | 0 ) ; HEAP8 [ $52 >> 0 ] = $51 ; $53 = ( ( ( $4 ) ) + 4 | 0 ) ; HEAP8 [ $53 >> 0 ] = 115 ; $54 = ( ( ( $4 ) ) + 5 | 0 ) ; HEAP8 [ $54 >> 0 ] = 66 ; $55 = ( ( ( $4 ) ) + 6 | 0 ) ; HEAP8 [ $55 >> 0 ] = 73 ; $56 = ( ( ( $4 ) ) + 7 | 0 ) ; HEAP8 [ $56 >> 0 ] = 84 ; _png_write_data ( $0 , $4 , 8 ) ; $57 = ( ( ( $0 ) ) + 172 | 0 ) ; HEAP32 [ $57 >> 2 ] = 1933723988 ; _png_reset_crc ( $0 ) ; _png_calculate_crc ( $0 , $53 , 4 ) ; HEAP32 [ $42 >> 2 ] = 66 ; _png_write_data ( $0 , $5 , $$236 ) ; _png_calculate_crc ( $0 , $5 , $$236 ) ; HEAP32 [ $42 >> 2 ] = 130 ; $58 = ( ( ( $0 ) ) + 200 | 0 ) ; $59 = HEAP32 [ $58 >> 2 ] | 0 ; $60 = $59 >>> 24 ; $61 = $60 & 255 ; HEAP8 [ $3 >> 0 ] = $61 ; $62 = $59 >>> 16 ; $63 = $62 & 255 ; $64 = ( ( ( $3 ) ) + 1 | 0 ) ; HEAP8 [ $64 >> 0 ] = $63 ; $65 = $59 >>> 8 ; $66 = $65 & 255 ; $67 = ( ( ( $3 ) ) + 2 | 0 ) ; HEAP8 [ $67 >> 0 ] = $66 ; $68 = $59 & 255 ; $69 = ( ( ( $3 ) ) + 3 | 0 ) ; HEAP8 [ $69 >> 0 ] = $68 ; _png_write_data ( $0 , $3 , 4 ) ; STACKTOP = sp ; return ; } function _png_write_tRNS ( $0 , $1 , $2 , $3 , $4 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; $4 = $4 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 ; var $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 ; var $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 ; var $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 ; var $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 ; var $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 48 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 48 | 0 ) ; $5 = sp + 40 | 0 ; $6 = sp + 32 | 0 ; $7 = sp + 24 | 0 ; $8 = sp + 16 | 0 ; $9 = sp + 12 | 0 ; $10 = sp + 8 | 0 ; $11 = sp ; switch ( $4 | 0 ) { case 3 : { $12 = ( $3 | 0 ) < ( 1 ) ; if ( ! ( $12 ) ) { $13 = ( ( ( $0 ) ) + 208 | 0 ) ; $14 = HEAP16 [ $13 >> 1 ] | 0 ; $15 = $14 & 65535 ; $16 = ( $15 | 0 ) < ( $3 | 0 ) ; if ( ! ( $16 ) ) { $17 = ( ( ( $0 ) ) + 372 | 0 ) ; HEAP32 [ $17 >> 2 ] = 34 ; $18 = $3 >>> 24 ; $19 = $18 & 255 ; HEAP8 [ $7 >> 0 ] = $19 ; $20 = $3 >>> 16 ; $21 = $20 & 255 ; $22 = ( ( ( $7 ) ) + 1 | 0 ) ; HEAP8 [ $22 >> 0 ] = $21 ; $23 = $3 >>> 8 ; $24 = $23 & 255 ; $25 = ( ( ( $7 ) ) + 2 | 0 ) ; HEAP8 [ $25 >> 0 ] = $24 ; $26 = $3 & 255 ; $27 = ( ( ( $7 ) ) + 3 | 0 ) ; HEAP8 [ $27 >> 0 ] = $26 ; $28 = ( ( ( $7 ) ) + 4 | 0 ) ; HEAP8 [ $28 >> 0 ] = 116 ; $29 = ( ( ( $7 ) ) + 5 | 0 ) ; HEAP8 [ $29 >> 0 ] = 82 ; $30 = ( ( ( $7 ) ) + 6 | 0 ) ; HEAP8 [ $30 >> 0 ] = 78 ; $31 = ( ( ( $7 ) ) + 7 | 0 ) ; HEAP8 [ $31 >> 0 ] = 83 ; _png_write_data ( $0 , $7 , 8 ) ; $32 = ( ( ( $0 ) ) + 172 | 0 ) ; HEAP32 [ $32 >> 2 ] = 1951551059 ; _png_reset_crc ( $0 ) ; _png_calculate_crc ( $0 , $28 , 4 ) ; HEAP32 [ $17 >> 2 ] = 66 ; $33 = ( $1 | 0 ) == ( 0 | 0 ) ; if ( ! ( $33 ) ) { _png_write_data ( $0 , $1 , $3 ) ; _png_calculate_crc ( $0 , $1 , $3 ) ; } HEAP32 [ $17 >> 2 ] = 130 ; $34 = ( ( ( $0 ) ) + 200 | 0 ) ; $35 = HEAP32 [ $34 >> 2 ] | 0 ; $36 = $35 >>> 24 ; $37 = $36 & 255 ; HEAP8 [ $10 >> 0 ] = $37 ; $38 = $35 >>> 16 ; $39 = $38 & 255 ; $40 = ( ( ( $10 ) ) + 1 | 0 ) ; HEAP8 [ $40 >> 0 ] = $39 ; $41 = $35 >>> 8 ; $42 = $41 & 255 ; $43 = ( ( ( $10 ) ) + 2 | 0 ) ; HEAP8 [ $43 >> 0 ] = $42 ; $44 = $35 & 255 ; $45 = ( ( ( $10 ) ) + 3 | 0 ) ; HEAP8 [ $45 >> 0 ] = $44 ; _png_write_data ( $0 , $10 , 4 ) ; STACKTOP = sp ; return ; } } _png_app_warning ( $0 , 27998 ) ; STACKTOP = sp ; return ; break ; } case 0 : { $46 = ( ( ( $2 ) ) + 8 | 0 ) ; $47 = HEAP16 [ $46 >> 1 ] | 0 ; $48 = $47 & 65535 ; $49 = ( ( ( $0 ) ) + 224 | 0 ) ; $50 = HEAP8 [ $49 >> 0 ] | 0 ; $51 = $50 & 255 ; $52 = 1 << $51 ; $53 = ( $52 | 0 ) > ( $48 | 0 ) ; if ( $53 ) { $54 = ( $47 & 65535 ) >>> 8 ; $55 = $54 & 255 ; HEAP8 [ $11 >> 0 ] = $55 ; $56 = $47 & 255 ; $57 = ( ( ( $11 ) ) + 1 | 0 ) ; HEAP8 [ $57 >> 0 ] = $56 ; $58 = ( ( ( $0 ) ) + 372 | 0 ) ; HEAP32 [ $58 >> 2 ] = 34 ; HEAP8 [ $8 >> 0 ] = 0 ; $59 = ( ( ( $8 ) ) + 1 | 0 ) ; HEAP8 [ $59 >> 0 ] = 0 ; $60 = ( ( ( $8 ) ) + 2 | 0 ) ; HEAP8 [ $60 >> 0 ] = 0 ; $61 = ( ( ( $8 ) ) + 3 | 0 ) ; HEAP8 [ $61 >> 0 ] = 2 ; $62 = ( ( ( $8 ) ) + 4 | 0 ) ; HEAP8 [ $62 >> 0 ] = 116 ; $63 = ( ( ( $8 ) ) + 5 | 0 ) ; HEAP8 [ $63 >> 0 ] = 82 ; $64 = ( ( ( $8 ) ) + 6 | 0 ) ; HEAP8 [ $64 >> 0 ] = 78 ; $65 = ( ( ( $8 ) ) + 7 | 0 ) ; HEAP8 [ $65 >> 0 ] = 83 ; _png_write_data ( $0 , $8 , 8 ) ; $66 = ( ( ( $0 ) ) + 172 | 0 ) ; HEAP32 [ $66 >> 2 ] = 1951551059 ; _png_reset_crc ( $0 ) ; _png_calculate_crc ( $0 , $62 , 4 ) ; HEAP32 [ $58 >> 2 ] = 66 ; _png_write_data ( $0 , $11 , 2 ) ; _png_calculate_crc ( $0 , $11 , 2 ) ; HEAP32 [ $58 >> 2 ] = 130 ; $67 = ( ( ( $0 ) ) + 200 | 0 ) ; $68 = HEAP32 [ $67 >> 2 ] | 0 ; $69 = $68 >>> 24 ; $70 = $69 & 255 ; HEAP8 [ $9 >> 0 ] = $70 ; $71 = $68 >>> 16 ; $72 = $71 & 255 ; $73 = ( ( ( $9 ) ) + 1 | 0 ) ; HEAP8 [ $73 >> 0 ] = $72 ; $74 = $68 >>> 8 ; $75 = $74 & 255 ; $76 = ( ( ( $9 ) ) + 2 | 0 ) ; HEAP8 [ $76 >> 0 ] = $75 ; $77 = $68 & 255 ; $78 = ( ( ( $9 ) ) + 3 | 0 ) ; HEAP8 [ $78 >> 0 ] = $77 ; _png_write_data ( $0 , $9 , 4 ) ; STACKTOP = sp ; return ; } else { _png_app_warning ( $0 , 28045 ) ; STACKTOP = sp ; return ; } break ; } case 2 : { $79 = ( ( ( $2 ) ) + 2 | 0 ) ; $80 = HEAP16 [ $79 >> 1 ] | 0 ; $81 = ( $80 & 65535 ) >>> 8 ; $82 = $81 & 255 ; HEAP8 [ $11 >> 0 ] = $82 ; $83 = $80 & 255 ; $84 = ( ( ( $11 ) ) + 1 | 0 ) ; HEAP8 [ $84 >> 0 ] = $83 ; $85 = ( ( ( $11 ) ) + 2 | 0 ) ; $86 = ( ( ( $2 ) ) + 4 | 0 ) ; $87 = HEAP16 [ $86 >> 1 ] | 0 ; $88 = ( $87 & 65535 ) >>> 8 ; $89 = $88 & 255 ; HEAP8 [ $85 >> 0 ] = $89 ; $90 = $87 & 255 ; $91 = ( ( ( $11 ) ) + 3 | 0 ) ; HEAP8 [ $91 >> 0 ] = $90 ; $92 = ( ( ( $11 ) ) + 4 | 0 ) ; $93 = ( ( ( $2 ) ) + 6 | 0 ) ; $94 = HEAP16 [ $93 >> 1 ] | 0 ; $95 = ( $94 & 65535 ) >>> 8 ; $96 = $95 & 255 ; HEAP8 [ $92 >> 0 ] = $96 ; $97 = $94 & 255 ; $98 = ( ( ( $11 ) ) + 5 | 0 ) ; HEAP8 [ $98 >> 0 ] = $97 ; $99 = ( ( ( $0 ) ) + 224 | 0 ) ; $100 = HEAP8 [ $99 >> 0 ] | 0 ; $101 = ( $100 << 24 >> 24 ) == ( 8 ) ; if ( $101 ) { $102 = $88 | $81 ; $103 = $102 | $95 ; $104 = ( $103 << 16 >> 16 ) == ( 0 ) ; if ( ! ( $104 ) ) { _png_app_warning ( $0 , 28109 ) ; STACKTOP = sp ; return ; } } $105 = ( ( ( $0 ) ) + 372 | 0 ) ; HEAP32 [ $105 >> 2 ] = 34 ; HEAP8 [ $6 >> 0 ] = 0 ; $106 = ( ( ( $6 ) ) + 1 | 0 ) ; HEAP8 [ $106 >> 0 ] = 0 ; $107 = ( ( ( $6 ) ) + 2 | 0 ) ; HEAP8 [ $107 >> 0 ] = 0 ; $108 = ( ( ( $6 ) ) + 3 | 0 ) ; HEAP8 [ $108 >> 0 ] = 6 ; $109 = ( ( ( $6 ) ) + 4 | 0 ) ; HEAP8 [ $109 >> 0 ] = 116 ; $110 = ( ( ( $6 ) ) + 5 | 0 ) ; HEAP8 [ $110 >> 0 ] = 82 ; $111 = ( ( ( $6 ) ) + 6 | 0 ) ; HEAP8 [ $111 >> 0 ] = 78 ; $112 = ( ( ( $6 ) ) + 7 | 0 ) ; HEAP8 [ $112 >> 0 ] = 83 ; _png_write_data ( $0 , $6 , 8 ) ; $113 = ( ( ( $0 ) ) + 172 | 0 ) ; HEAP32 [ $113 >> 2 ] = 1951551059 ; _png_reset_crc ( $0 ) ; _png_calculate_crc ( $0 , $109 , 4 ) ; HEAP32 [ $105 >> 2 ] = 66 ; _png_write_data ( $0 , $11 , 6 ) ; _png_calculate_crc ( $0 , $11 , 6 ) ; HEAP32 [ $105 >> 2 ] = 130 ; $114 = ( ( ( $0 ) ) + 200 | 0 ) ; $115 = HEAP32 [ $114 >> 2 ] | 0 ; $116 = $115 >>> 24 ; $117 = $116 & 255 ; HEAP8 [ $5 >> 0 ] = $117 ; $118 = $115 >>> 16 ; $119 = $118 & 255 ; $120 = ( ( ( $5 ) ) + 1 | 0 ) ; HEAP8 [ $120 >> 0 ] = $119 ; $121 = $115 >>> 8 ; $122 = $121 & 255 ; $123 = ( ( ( $5 ) ) + 2 | 0 ) ; HEAP8 [ $123 >> 0 ] = $122 ; $124 = $115 & 255 ; $125 = ( ( ( $5 ) ) + 3 | 0 ) ; HEAP8 [ $125 >> 0 ] = $124 ; _png_write_data ( $0 , $5 , 4 ) ; STACKTOP = sp ; return ; break ; } default : { _png_app_warning ( $0 , 28173 ) ; STACKTOP = sp ; return ; } } } function _png_write_bKGD ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 ; var $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 ; var $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 ; var $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 64 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 64 | 0 ) ; $3 = sp + 48 | 0 ; $4 = sp + 40 | 0 ; $5 = sp + 32 | 0 ; $6 = sp + 24 | 0 ; $7 = sp + 16 | 0 ; $8 = sp + 8 | 0 ; $9 = sp ; $10 = ( $2 | 0 ) == ( 3 ) ; if ( $10 ) { $11 = HEAP8 [ $1 >> 0 ] | 0 ; $12 = $11 & 255 ; $13 = ( ( ( $0 ) ) + 208 | 0 ) ; $14 = HEAP16 [ $13 >> 1 ] | 0 ; $15 = $14 & 65535 ; $16 = ( $12 >>> 0 ) < ( $15 >>> 0 ) ; if ( $16 ) { HEAP8 [ $9 >> 0 ] = $11 ; $17 = ( ( ( $0 ) ) + 372 | 0 ) ; HEAP32 [ $17 >> 2 ] = 34 ; HEAP8 [ $7 >> 0 ] = 0 ; $18 = ( ( ( $7 ) ) + 1 | 0 ) ; HEAP8 [ $18 >> 0 ] = 0 ; $19 = ( ( ( $7 ) ) + 2 | 0 ) ; HEAP8 [ $19 >> 0 ] = 0 ; $20 = ( ( ( $7 ) ) + 3 | 0 ) ; HEAP8 [ $20 >> 0 ] = 1 ; $21 = ( ( ( $7 ) ) + 4 | 0 ) ; HEAP8 [ $21 >> 0 ] = 98 ; $22 = ( ( ( $7 ) ) + 5 | 0 ) ; HEAP8 [ $22 >> 0 ] = 75 ; $23 = ( ( ( $7 ) ) + 6 | 0 ) ; HEAP8 [ $23 >> 0 ] = 71 ; $24 = ( ( ( $7 ) ) + 7 | 0 ) ; HEAP8 [ $24 >> 0 ] = 68 ; _png_write_data ( $0 , $7 , 8 ) ; $25 = ( ( ( $0 ) ) + 172 | 0 ) ; HEAP32 [ $25 >> 2 ] = 1649100612 ; _png_reset_crc ( $0 ) ; _png_calculate_crc ( $0 , $21 , 4 ) ; HEAP32 [ $17 >> 2 ] = 66 ; _png_write_data ( $0 , $9 , 1 ) ; _png_calculate_crc ( $0 , $9 , 1 ) ; HEAP32 [ $17 >> 2 ] = 130 ; $26 = ( ( ( $0 ) ) + 200 | 0 ) ; $27 = HEAP32 [ $26 >> 2 ] | 0 ; $28 = $27 >>> 24 ; $29 = $28 & 255 ; HEAP8 [ $8 >> 0 ] = $29 ; $30 = $27 >>> 16 ; $31 = $30 & 255 ; $32 = ( ( ( $8 ) ) + 1 | 0 ) ; HEAP8 [ $32 >> 0 ] = $31 ; $33 = $27 >>> 8 ; $34 = $33 & 255 ; $35 = ( ( ( $8 ) ) + 2 | 0 ) ; HEAP8 [ $35 >> 0 ] = $34 ; $36 = $27 & 255 ; $37 = ( ( ( $8 ) ) + 3 | 0 ) ; HEAP8 [ $37 >> 0 ] = $36 ; _png_write_data ( $0 , $8 , 4 ) ; STACKTOP = sp ; return ; } else { _png_warning ( $0 , 28212 ) ; STACKTOP = sp ; return ; } } $38 = $2 & 2 ; $39 = ( $38 | 0 ) == ( 0 ) ; if ( $39 ) { $87 = ( ( ( $1 ) ) + 8 | 0 ) ; $88 = HEAP16 [ $87 >> 1 ] | 0 ; $89 = $88 & 65535 ; $90 = ( ( ( $0 ) ) + 224 | 0 ) ; $91 = HEAP8 [ $90 >> 0 ] | 0 ; $92 = $91 & 255 ; $93 = 1 << $92 ; $94 = ( $93 | 0 ) > ( $89 | 0 ) ; if ( $94 ) { $95 = ( $88 & 65535 ) >>> 8 ; $96 = $95 & 255 ; HEAP8 [ $9 >> 0 ] = $96 ; $97 = $88 & 255 ; $98 = ( ( ( $9 ) ) + 1 | 0 ) ; HEAP8 [ $98 >> 0 ] = $97 ; $99 = ( ( ( $0 ) ) + 372 | 0 ) ; HEAP32 [ $99 >> 2 ] = 34 ; HEAP8 [ $4 >> 0 ] = 0 ; $100 = ( ( ( $4 ) ) + 1 | 0 ) ; HEAP8 [ $100 >> 0 ] = 0 ; $101 = ( ( ( $4 ) ) + 2 | 0 ) ; HEAP8 [ $101 >> 0 ] = 0 ; $102 = ( ( ( $4 ) ) + 3 | 0 ) ; HEAP8 [ $102 >> 0 ] = 2 ; $103 = ( ( ( $4 ) ) + 4 | 0 ) ; HEAP8 [ $103 >> 0 ] = 98 ; $104 = ( ( ( $4 ) ) + 5 | 0 ) ; HEAP8 [ $104 >> 0 ] = 75 ; $105 = ( ( ( $4 ) ) + 6 | 0 ) ; HEAP8 [ $105 >> 0 ] = 71 ; $106 = ( ( ( $4 ) ) + 7 | 0 ) ; HEAP8 [ $106 >> 0 ] = 68 ; _png_write_data ( $0 , $4 , 8 ) ; $107 = ( ( ( $0 ) ) + 172 | 0 ) ; HEAP32 [ $107 >> 2 ] = 1649100612 ; _png_reset_crc ( $0 ) ; _png_calculate_crc ( $0 , $103 , 4 ) ; HEAP32 [ $99 >> 2 ] = 66 ; _png_write_data ( $0 , $9 , 2 ) ; _png_calculate_crc ( $0 , $9 , 2 ) ; HEAP32 [ $99 >> 2 ] = 130 ; $108 = ( ( ( $0 ) ) + 200 | 0 ) ; $109 = HEAP32 [ $108 >> 2 ] | 0 ; $110 = $109 >>> 24 ; $111 = $110 & 255 ; HEAP8 [ $3 >> 0 ] = $111 ; $112 = $109 >>> 16 ; $113 = $112 & 255 ; $114 = ( ( ( $3 ) ) + 1 | 0 ) ; HEAP8 [ $114 >> 0 ] = $113 ; $115 = $109 >>> 8 ; $116 = $115 & 255 ; $117 = ( ( ( $3 ) ) + 2 | 0 ) ; HEAP8 [ $117 >> 0 ] = $116 ; $118 = $109 & 255 ; $119 = ( ( ( $3 ) ) + 3 | 0 ) ; HEAP8 [ $119 >> 0 ] = $118 ; _png_write_data ( $0 , $3 , 4 ) ; STACKTOP = sp ; return ; } else { _png_warning ( $0 , 28309 ) ; STACKTOP = sp ; return ; } } $40 = ( ( ( $1 ) ) + 2 | 0 ) ; $41 = HEAP16 [ $40 >> 1 ] | 0 ; $42 = ( $41 & 65535 ) >>> 8 ; $43 = $42 & 255 ; HEAP8 [ $9 >> 0 ] = $43 ; $44 = $41 & 255 ; $45 = ( ( ( $9 ) ) + 1 | 0 ) ; HEAP8 [ $45 >> 0 ] = $44 ; $46 = ( ( ( $9 ) ) + 2 | 0 ) ; $47 = ( ( ( $1 ) ) + 4 | 0 ) ; $48 = HEAP16 [ $47 >> 1 ] | 0 ; $49 = ( $48 & 65535 ) >>> 8 ; $50 = $49 & 255 ; HEAP8 [ $46 >> 0 ] = $50 ; $51 = $48 & 255 ; $52 = ( ( ( $9 ) ) + 3 | 0 ) ; HEAP8 [ $52 >> 0 ] = $51 ; $53 = ( ( ( $9 ) ) + 4 | 0 ) ; $54 = ( ( ( $1 ) ) + 6 | 0 ) ; $55 = HEAP16 [ $54 >> 1 ] | 0 ; $56 = ( $55 & 65535 ) >>> 8 ; $57 = $56 & 255 ; HEAP8 [ $53 >> 0 ] = $57 ; $58 = $55 & 255 ; $59 = ( ( ( $9 ) ) + 5 | 0 ) ; HEAP8 [ $59 >> 0 ] = $58 ; $60 = ( ( ( $0 ) ) + 224 | 0 ) ; $61 = HEAP8 [ $60 >> 0 ] | 0 ; $62 = ( $61 << 24 >> 24 ) == ( 8 ) ; if ( $62 ) { $63 = $49 | $42 ; $64 = $63 | $56 ; $65 = ( $64 << 16 >> 16 ) == ( 0 ) ; if ( ! ( $65 ) ) { _png_warning ( $0 , 28245 ) ; STACKTOP = sp ; return ; } } $66 = ( ( ( $0 ) ) + 372 | 0 ) ; HEAP32 [ $66 >> 2 ] = 34 ; HEAP8 [ $5 >> 0 ] = 0 ; $67 = ( ( ( $5 ) ) + 1 | 0 ) ; HEAP8 [ $67 >> 0 ] = 0 ; $68 = ( ( ( $5 ) ) + 2 | 0 ) ; HEAP8 [ $68 >> 0 ] = 0 ; $69 = ( ( ( $5 ) ) + 3 | 0 ) ; HEAP8 [ $69 >> 0 ] = 6 ; $70 = ( ( ( $5 ) ) + 4 | 0 ) ; HEAP8 [ $70 >> 0 ] = 98 ; $71 = ( ( ( $5 ) ) + 5 | 0 ) ; HEAP8 [ $71 >> 0 ] = 75 ; $72 = ( ( ( $5 ) ) + 6 | 0 ) ; HEAP8 [ $72 >> 0 ] = 71 ; $73 = ( ( ( $5 ) ) + 7 | 0 ) ; HEAP8 [ $73 >> 0 ] = 68 ; _png_write_data ( $0 , $5 , 8 ) ; $74 = ( ( ( $0 ) ) + 172 | 0 ) ; HEAP32 [ $74 >> 2 ] = 1649100612 ; _png_reset_crc ( $0 ) ; _png_calculate_crc ( $0 , $70 , 4 ) ; HEAP32 [ $66 >> 2 ] = 66 ; _png_write_data ( $0 , $9 , 6 ) ; _png_calculate_crc ( $0 , $9 , 6 ) ; HEAP32 [ $66 >> 2 ] = 130 ; $75 = ( ( ( $0 ) ) + 200 | 0 ) ; $76 = HEAP32 [ $75 >> 2 ] | 0 ; $77 = $76 >>> 24 ; $78 = $77 & 255 ; HEAP8 [ $6 >> 0 ] = $78 ; $79 = $76 >>> 16 ; $80 = $79 & 255 ; $81 = ( ( ( $6 ) ) + 1 | 0 ) ; HEAP8 [ $81 >> 0 ] = $80 ; $82 = $76 >>> 8 ; $83 = $82 & 255 ; $84 = ( ( ( $6 ) ) + 2 | 0 ) ; HEAP8 [ $84 >> 0 ] = $83 ; $85 = $76 & 255 ; $86 = ( ( ( $6 ) ) + 3 | 0 ) ; HEAP8 [ $86 >> 0 ] = $85 ; _png_write_data ( $0 , $6 , 4 ) ; STACKTOP = sp ; return ; } function _png_write_hIST ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$011 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 ; var $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 ; var $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $exitcond13 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $3 = sp + 16 | 0 ; $4 = sp + 8 | 0 ; $5 = sp ; $6 = ( ( ( $0 ) ) + 208 | 0 ) ; $7 = HEAP16 [ $6 >> 1 ] | 0 ; $8 = $7 & 65535 ; $9 = ( $8 | 0 ) < ( $2 | 0 ) ; if ( $9 ) { _png_warning ( $0 , 28373 ) ; STACKTOP = sp ; return ; } $10 = $2 << 1 ; $11 = ( ( ( $0 ) ) + 372 | 0 ) ; HEAP32 [ $11 >> 2 ] = 34 ; $12 = $2 >>> 23 ; $13 = $12 & 255 ; HEAP8 [ $4 >> 0 ] = $13 ; $14 = $2 >>> 15 ; $15 = $14 & 255 ; $16 = ( ( ( $4 ) ) + 1 | 0 ) ; HEAP8 [ $16 >> 0 ] = $15 ; $17 = $2 >>> 7 ; $18 = $17 & 255 ; $19 = ( ( ( $4 ) ) + 2 | 0 ) ; HEAP8 [ $19 >> 0 ] = $18 ; $20 = $10 & 255 ; $21 = ( ( ( $4 ) ) + 3 | 0 ) ; HEAP8 [ $21 >> 0 ] = $20 ; $22 = ( ( ( $4 ) ) + 4 | 0 ) ; HEAP8 [ $22 >> 0 ] = 104 ; $23 = ( ( ( $4 ) ) + 5 | 0 ) ; HEAP8 [ $23 >> 0 ] = 73 ; $24 = ( ( ( $4 ) ) + 6 | 0 ) ; HEAP8 [ $24 >> 0 ] = 83 ; $25 = ( ( ( $4 ) ) + 7 | 0 ) ; HEAP8 [ $25 >> 0 ] = 84 ; _png_write_data ( $0 , $4 , 8 ) ; $26 = ( ( ( $0 ) ) + 172 | 0 ) ; HEAP32 [ $26 >> 2 ] = 1749635924 ; _png_reset_crc ( $0 ) ; _png_calculate_crc ( $0 , $22 , 4 ) ; HEAP32 [ $11 >> 2 ] = 66 ; $27 = ( $2 | 0 ) > ( 0 ) ; if ( $27 ) { $28 = ( ( ( $5 ) ) + 1 | 0 ) ; $$011 = 0 ; while ( 1 ) { $29 = ( ( $1 ) + ( $$011 << 1 ) | 0 ) ; $30 = HEAP16 [ $29 >> 1 ] | 0 ; $31 = ( $30 & 65535 ) >>> 8 ; $32 = $31 & 255 ; HEAP8 [ $5 >> 0 ] = $32 ; $33 = $30 & 255 ; HEAP8 [ $28 >> 0 ] = $33 ; _png_write_data ( $0 , $5 , 2 ) ; _png_calculate_crc ( $0 , $5 , 2 ) ; $34 = ( ( $$011 ) + 1 ) | 0 ; $exitcond13 = ( $34 | 0 ) == ( $2 | 0 ) ; if ( $exitcond13 ) { break ; } else { $$011 = $34 ; } } } HEAP32 [ $11 >> 2 ] = 130 ; $35 = ( ( ( $0 ) ) + 200 | 0 ) ; $36 = HEAP32 [ $35 >> 2 ] | 0 ; $37 = $36 >>> 24 ; $38 = $37 & 255 ; HEAP8 [ $3 >> 0 ] = $38 ; $39 = $36 >>> 16 ; $40 = $39 & 255 ; $41 = ( ( ( $3 ) ) + 1 | 0 ) ; HEAP8 [ $41 >> 0 ] = $40 ; $42 = $36 >>> 8 ; $43 = $42 & 255 ; $44 = ( ( ( $3 ) ) + 2 | 0 ) ; HEAP8 [ $44 >> 0 ] = $43 ; $45 = $36 & 255 ; $46 = ( ( ( $3 ) ) + 3 | 0 ) ; HEAP8 [ $46 >> 0 ] = $45 ; _png_write_data ( $0 , $3 , 4 ) ; STACKTOP = sp ; return ; } function _png_write_start_row ( $0 ) { $0 = $0 | 0 ; var $$ = 0 , $$$164 = 0 , $$1 = 0 , $$1$ = 0 , $$164 = 0 , $$3 = 0 , $$lobit = 0 , $$lobit67 = 0 , $$lobit68 = 0 , $$lobit69 = 0 , $$sink3 = 0 , $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 ; var $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 ; var $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 ; var $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 ; var $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( ( ( $0 ) ) + 228 | 0 ) ; $2 = HEAP8 [ $1 >> 0 ] | 0 ; $3 = $2 & 255 ; $4 = ( ( ( $0 ) ) + 225 | 0 ) ; $5 = HEAP8 [ $4 >> 0 ] | 0 ; $6 = $5 & 255 ; $7 = Math_imul ( $6 , $3 ) | 0 ; $8 = ( $7 >>> 0 ) > ( 7 ) ; $9 = ( ( ( $0 ) ) + 144 | 0 ) ; $10 = HEAP32 [ $9 >> 2 ] | 0 ; if ( $8 ) { $11 = $7 >>> 3 ; $12 = Math_imul ( $11 , $10 ) | 0 ; $17 = $12 ; } else { $13 = Math_imul ( $7 , $10 ) | 0 ; $14 = ( ( $13 ) + 7 ) | 0 ; $15 = $14 >>> 3 ; $17 = $15 ; } $16 = ( ( $17 ) + 1 ) | 0 ; $18 = ( ( ( $0 ) ) + 226 | 0 ) ; $19 = HEAP8 [ $18 >> 0 ] | 0 ; $20 = ( ( ( $0 ) ) + 231 | 0 ) ; HEAP8 [ $20 >> 0 ] = $19 ; $21 = $7 & 255 ; $22 = ( ( ( $0 ) ) + 230 | 0 ) ; HEAP8 [ $22 >> 0 ] = $21 ; $23 = ( _png_malloc ( $0 , $16 ) | 0 ) ; $24 = ( ( ( $0 ) ) + 180 | 0 ) ; HEAP32 [ $24 >> 2 ] = $23 ; HEAP8 [ $23 >> 0 ] = 0 ; $25 = ( ( ( $0 ) ) + 222 | 0 ) ; $26 = HEAP8 [ $25 >> 0 ] | 0 ; $27 = ( ( ( $0 ) ) + 148 | 0 ) ; $28 = HEAP32 [ $27 >> 2 ] | 0 ; $29 = ( $28 | 0 ) == ( 1 ) ; $30 = $26 & 31 ; $$ = $29 ? $30 : $26 ; $31 = HEAP32 [ $9 >> 2 ] | 0 ; $32 = ( $31 | 0 ) == ( 1 ) ; $33 = $$ & 47 ; $$164 = $32 ? $33 : $$ ; $34 = ( $$164 << 24 >> 24 ) == ( 0 ) ; $$$164 = $34 ? 8 : $$164 ; HEAP8 [ $25 >> 0 ] = $$$164 ; $35 = $$$164 & 255 ; $36 = $35 & 240 ; $37 = ( $36 | 0 ) == ( 0 ) ; if ( ! ( $37 ) ) { $38 = ( ( ( $0 ) ) + 184 | 0 ) ; $39 = HEAP32 [ $38 >> 2 ] | 0 ; $40 = ( $39 | 0 ) == ( 0 | 0 ) ; if ( $40 ) { $41 = ( _png_malloc ( $0 , $16 ) | 0 ) ; HEAP32 [ $38 >> 2 ] = $41 ; $42 = $35 >>> 4 ; $$lobit = $42 & 1 ; $43 = $35 >>> 5 ; $$lobit67 = $43 & 1 ; $44 = $35 >>> 6 ; $$lobit68 = $44 & 1 ; $$lobit69 = $35 >>> 7 ; $$1 = ( ( $$lobit67 ) + ( $$lobit69 ) ) | 0 ; $$1$ = ( ( $$1 ) + ( $$lobit ) ) | 0 ; $$3 = ( ( $$1$ ) + ( $$lobit68 ) ) | 0 ; $45 = ( $$3 >>> 0 ) > ( 1 ) ; if ( $45 ) { $46 = ( _png_malloc ( $0 , $16 ) | 0 ) ; $47 = ( ( ( $0 ) ) + 188 | 0 ) ; HEAP32 [ $47 >> 2 ] = $46 ; } } } $48 = $35 & 224 ; $49 = ( $48 | 0 ) == ( 0 ) ; if ( ! ( $49 ) ) { $50 = ( _png_calloc ( $0 , $16 ) | 0 ) ; $51 = ( ( ( $0 ) ) + 176 | 0 ) ; HEAP32 [ $51 >> 2 ] = $50 ; } $52 = ( ( ( $0 ) ) + 220 | 0 ) ; $53 = HEAP8 [ $52 >> 0 ] | 0 ; $54 = ( $53 << 24 >> 24 ) == ( 0 ) ; if ( $54 ) { $68 = HEAP32 [ $27 >> 2 ] | 0 ; $69 = ( ( ( $0 ) ) + 152 | 0 ) ; HEAP32 [ $69 >> 2 ] = $68 ; $70 = HEAP32 [ $9 >> 2 ] | 0 ; $$sink3 = $70 ; $71 = ( ( ( $0 ) ) + 156 | 0 ) ; HEAP32 [ $71 >> 2 ] = $$sink3 ; return ; } $55 = ( ( ( $0 ) ) + 32 | 0 ) ; $56 = HEAP32 [ $55 >> 2 ] | 0 ; $57 = $56 & 2 ; $58 = ( $57 | 0 ) == ( 0 ) ; $59 = HEAP32 [ $27 >> 2 ] | 0 ; if ( $58 ) { $60 = ( ( $59 ) + 7 ) | 0 ; $61 = $60 >>> 3 ; $62 = ( ( ( $0 ) ) + 152 | 0 ) ; HEAP32 [ $62 >> 2 ] = $61 ; $63 = HEAP32 [ $9 >> 2 ] | 0 ; $64 = ( ( $63 ) + 7 ) | 0 ; $65 = $64 >>> 3 ; $$sink3 = $65 ; $71 = ( ( ( $0 ) ) + 156 | 0 ) ; HEAP32 [ $71 >> 2 ] = $$sink3 ; return ; } else { $66 = ( ( ( $0 ) ) + 152 | 0 ) ; HEAP32 [ $66 >> 2 ] = $59 ; $67 = HEAP32 [ $9 >> 2 ] | 0 ; $$sink3 = $67 ; $71 = ( ( ( $0 ) ) + 156 | 0 ) ; HEAP32 [ $71 >> 2 ] = $$sink3 ; return ; } } function _png_write_finish_row ( $0 ) { $0 = $0 | 0 ; var $$promoted = 0 , $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 ; var $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 ; var $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 ; var $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( ( ( $0 ) ) + 168 | 0 ) ; $2 = HEAP32 [ $1 >> 2 ] | 0 ; $3 = ( ( $2 ) + 1 ) | 0 ; HEAP32 [ $1 >> 2 ] = $3 ; $4 = ( ( ( $0 ) ) + 152 | 0 ) ; $5 = HEAP32 [ $4 >> 2 ] | 0 ; $6 = ( $3 >>> 0 ) < ( $5 >>> 0 ) ; if ( $6 ) { return ; } $7 = ( ( ( $0 ) ) + 220 | 0 ) ; $8 = HEAP8 [ $7 >> 0 ] | 0 ; $9 = ( $8 << 24 >> 24 ) == ( 0 ) ; if ( ! ( $9 ) ) { HEAP32 [ $1 >> 2 ] = 0 ; $10 = ( ( ( $0 ) ) + 32 | 0 ) ; $11 = HEAP32 [ $10 >> 2 ] | 0 ; $12 = $11 & 2 ; $13 = ( $12 | 0 ) == ( 0 ) ; if ( $13 ) { $14 = ( ( ( $0 ) ) + 144 | 0 ) ; $15 = ( ( ( $0 ) ) + 221 | 0 ) ; $16 = ( ( ( $0 ) ) + 156 | 0 ) ; $17 = ( ( ( $0 ) ) + 148 | 0 ) ; $$promoted = HEAP8 [ $15 >> 0 ] | 0 ; $22 = $$promoted ; while ( 1 ) { $21 = ( ( $22 ) + 1 ) << 24 >> 24 ; $23 = $21 & 255 ; $24 = ( $21 & 255 ) > ( 6 ) ; if ( $24 ) { break ; } $25 = HEAP32 [ $14 >> 2 ] | 0 ; $26 = ( 28419 + ( $23 ) | 0 ) ; $27 = HEAP8 [ $26 >> 0 ] | 0 ; $28 = $27 & 255 ; $29 = ( 28426 + ( $23 ) | 0 ) ; $30 = HEAP8 [ $29 >> 0 ] | 0 ; $31 = $30 & 255 ; $32 = ( ( $25 ) + - 1 ) | 0 ; $33 = ( ( $32 ) + ( $28 ) ) | 0 ; $34 = ( ( $33 ) - ( $31 ) ) | 0 ; $35 = ( ( $34 >>> 0 ) / ( $28 >>> 0 ) ) & - 1 ; HEAP32 [ $16 >> 2 ] = $35 ; $36 = HEAP32 [ $17 >> 2 ] | 0 ; $37 = ( 28433 + ( $23 ) | 0 ) ; $38 = HEAP8 [ $37 >> 0 ] | 0 ; $39 = $38 & 255 ; $40 = ( 28440 + ( $23 ) | 0 ) ; $41 = HEAP8 [ $40 >> 0 ] | 0 ; $42 = $41 & 255 ; $43 = ( ( $36 ) + - 1 ) | 0 ; $44 = ( ( $43 ) + ( $39 ) ) | 0 ; $45 = ( ( $44 ) - ( $42 ) ) | 0 ; $46 = ( ( $45 >>> 0 ) / ( $39 >>> 0 ) ) & - 1 ; HEAP32 [ $4 >> 2 ] = $46 ; $47 = ( $34 >>> 0 ) < ( $28 >>> 0 ) ; $48 = ( $45 >>> 0 ) < ( $39 >>> 0 ) ; $or$cond = $48 | $47 ; if ( $or$cond ) { $22 = $21 ; } else { break ; } } HEAP8 [ $15 >> 0 ] = $21 ; $49 = $21 ; } else { $18 = ( ( ( $0 ) ) + 221 | 0 ) ; $19 = HEAP8 [ $18 >> 0 ] | 0 ; $20 = ( ( $19 ) + 1 ) << 24 >> 24 ; HEAP8 [ $18 >> 0 ] = $20 ; $49 = $20 ; } $50 = ( $49 & 255 ) < ( 7 ) ; if ( $50 ) { $51 = ( ( ( $0 ) ) + 176 | 0 ) ; $52 = HEAP32 [ $51 >> 2 ] | 0 ; $53 = ( $52 | 0 ) == ( 0 | 0 ) ; if ( $53 ) { return ; } $54 = ( ( ( $0 ) ) + 228 | 0 ) ; $55 = HEAP8 [ $54 >> 0 ] | 0 ; $56 = $55 & 255 ; $57 = ( ( ( $0 ) ) + 225 | 0 ) ; $58 = HEAP8 [ $57 >> 0 ] | 0 ; $59 = $58 & 255 ; $60 = Math_imul ( $59 , $56 ) | 0 ; $61 = ( $60 >>> 0 ) > ( 7 ) ; $62 = ( ( ( $0 ) ) + 144 | 0 ) ; $63 = HEAP32 [ $62 >> 2 ] | 0 ; if ( $61 ) { $64 = $60 >>> 3 ; $65 = Math_imul ( $64 , $63 ) | 0 ; $70 = $65 ; } else { $66 = Math_imul ( $60 , $63 ) | 0 ; $67 = ( ( $66 ) + 7 ) | 0 ; $68 = $67 >>> 3 ; $70 = $68 ; } $69 = ( ( $70 ) + 1 ) | 0 ; _memset ( ( $52 | 0 ) , 0 , ( $69 | 0 ) ) | 0 ; return ; } } _png_compress_IDAT ( $0 , 0 , 0 , 4 ) ; return ; } function _png_do_write_interlace ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$0142167 = 0 , $$0144164 = 0 , $$0145163 = 0 , $$0146166 = 0 , $$0148165 = 0 , $$0149185 = 0 , $$0150175 = 0 , $$0152184 = 0 , $$0154183 = 0 , $$0156182 = 0 , $$0158174 = 0 , $$0160173 = 0 , $$0162172 = 0 , $$0168 = 0 , $$1 = 0 , $$1143 = 0 , $$1147 = 0 , $$1151 = 0 , $$1153 = 0 , $$1155 = 0 ; var $$1157 = 0 , $$1159 = 0 , $$1161 = 0 , $$pre$phiZ2D = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 ; var $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 ; var $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 ; var $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 ; var $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 ; var $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 ; var $97 = 0 , $98 = 0 , $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( $2 | 0 ) < ( 6 ) ; if ( ! ( $3 ) ) { return ; } $4 = ( ( ( $0 ) ) + 11 | 0 ) ; $5 = HEAP8 [ $4 >> 0 ] | 0 ; switch ( $5 << 24 >> 24 ) { case 1 : { $6 = HEAP32 [ $0 >> 2 ] | 0 ; $7 = ( 28426 + ( $2 ) | 0 ) ; $8 = HEAP8 [ $7 >> 0 ] | 0 ; $9 = $8 & 255 ; $10 = ( $6 >>> 0 ) > ( $9 >>> 0 ) ; if ( $10 ) { $11 = ( 28419 + ( $2 ) | 0 ) ; $12 = HEAP8 [ $11 >> 0 ] | 0 ; $13 = $12 & 255 ; $$0142167 = 7 ; $$0146166 = 0 ; $$0148165 = $9 ; $$0168 = $1 ; while ( 1 ) { $14 = $$0148165 >>> 3 ; $15 = ( ( $1 ) + ( $14 ) | 0 ) ; $16 = HEAP8 [ $15 >> 0 ] | 0 ; $17 = $16 & 255 ; $18 = $$0148165 & 7 ; $19 = $18 ^ 7 ; $20 = $17 >>> $19 ; $21 = $20 & 1 ; $22 = $21 << $$0142167 ; $23 = $22 | $$0146166 ; $24 = ( $$0142167 | 0 ) == ( 0 ) ; if ( $24 ) { $25 = $23 & 255 ; $26 = ( ( ( $$0168 ) ) + 1 | 0 ) ; HEAP8 [ $$0168 >> 0 ] = $25 ; $$1 = $26 ; $$1143 = 7 ; $$1147 = 0 ; } else { $27 = ( ( $$0142167 ) + - 1 ) | 0 ; $$1 = $$0168 ; $$1143 = $27 ; $$1147 = $23 ; } $28 = ( ( $$0148165 ) + ( $13 ) ) | 0 ; $29 = ( $28 >>> 0 ) < ( $6 >>> 0 ) ; if ( $29 ) { $$0142167 = $$1143 ; $$0146166 = $$1147 ; $$0148165 = $28 ; $$0168 = $$1 ; } else { break ; } } $30 = ( $$1143 | 0 ) == ( 7 ) ; if ( $30 ) { $$pre$phiZ2D = $0 ; $107 = $8 ; } else { $31 = $$1147 & 255 ; HEAP8 [ $$1 >> 0 ] = $31 ; $$pre$phiZ2D = $0 ; $107 = $8 ; } } else { $$pre$phiZ2D = $0 ; $107 = $8 ; } break ; } case 2 : { $32 = HEAP32 [ $0 >> 2 ] | 0 ; $33 = ( 28426 + ( $2 ) | 0 ) ; $34 = HEAP8 [ $33 >> 0 ] | 0 ; $35 = $34 & 255 ; $36 = ( $32 >>> 0 ) > ( $35 >>> 0 ) ; if ( $36 ) { $37 = ( 28419 + ( $2 ) | 0 ) ; $38 = HEAP8 [ $37 >> 0 ] | 0 ; $39 = $38 & 255 ; $$0150175 = $1 ; $$0158174 = 6 ; $$0160173 = 0 ; $$0162172 = $35 ; while ( 1 ) { $40 = $$0162172 >>> 2 ; $41 = ( ( $1 ) + ( $40 ) | 0 ) ; $42 = HEAP8 [ $41 >> 0 ] | 0 ; $43 = $42 & 255 ; $44 = $$0162172 << 1 ; $45 = $44 & 6 ; $46 = $45 ^ 6 ; $47 = $43 >>> $46 ; $48 = $47 & 3 ; $49 = $48 << $$0158174 ; $50 = $49 | $$0160173 ; $51 = ( $$0158174 | 0 ) == ( 0 ) ; if ( $51 ) { $52 = $50 & 255 ; $53 = ( ( ( $$0150175 ) ) + 1 | 0 ) ; HEAP8 [ $$0150175 >> 0 ] = $52 ; $$1151 = $53 ; $$1159 = 6 ; $$1161 = 0 ; } else { $54 = ( ( $$0158174 ) + - 2 ) | 0 ; $$1151 = $$0150175 ; $$1159 = $54 ; $$1161 = $50 ; } $55 = ( ( $$0162172 ) + ( $39 ) ) | 0 ; $56 = ( $55 >>> 0 ) < ( $32 >>> 0 ) ; if ( $56 ) { $$0150175 = $$1151 ; $$0158174 = $$1159 ; $$0160173 = $$1161 ; $$0162172 = $55 ; } else { break ; } } $57 = ( $$1159 | 0 ) == ( 6 ) ; if ( $57 ) { $$pre$phiZ2D = $0 ; $107 = $34 ; } else { $58 = $$1161 & 255 ; HEAP8 [ $$1151 >> 0 ] = $58 ; $$pre$phiZ2D = $0 ; $107 = $34 ; } } else { $$pre$phiZ2D = $0 ; $107 = $34 ; } break ; } case 4 : { $59 = HEAP32 [ $0 >> 2 ] | 0 ; $60 = ( 28426 + ( $2 ) | 0 ) ; $61 = HEAP8 [ $60 >> 0 ] | 0 ; $62 = $61 & 255 ; $63 = ( $59 >>> 0 ) > ( $62 >>> 0 ) ; if ( $63 ) { $64 = ( 28419 + ( $2 ) | 0 ) ; $65 = HEAP8 [ $64 >> 0 ] | 0 ; $66 = $65 & 255 ; $$0149185 = $62 ; $$0152184 = 0 ; $$0154183 = 4 ; $$0156182 = $1 ; while ( 1 ) { $67 = $$0149185 >>> 1 ; $68 = ( ( $1 ) + ( $67 ) | 0 ) ; $69 = HEAP8 [ $68 >> 0 ] | 0 ; $70 = $69 & 255 ; $71 = $$0149185 << 2 ; $72 = $71 & 4 ; $73 = $72 ^ 4 ; $74 = $70 >>> $73 ; $75 = $74 & 15 ; $76 = $75 << $$0154183 ; $77 = $76 | $$0152184 ; $78 = ( $$0154183 | 0 ) == ( 0 ) ; if ( $78 ) { $79 = $77 & 255 ; $80 = ( ( ( $$0156182 ) ) + 1 | 0 ) ; HEAP8 [ $$0156182 >> 0 ] = $79 ; $$1153 = 0 ; $$1155 = 4 ; $$1157 = $80 ; } else { $81 = ( ( $$0154183 ) + - 4 ) | 0 ; $$1153 = $77 ; $$1155 = $81 ; $$1157 = $$0156182 ; } $82 = ( ( $$0149185 ) + ( $66 ) ) | 0 ; $83 = ( $82 >>> 0 ) < ( $59 >>> 0 ) ; if ( $83 ) { $$0149185 = $82 ; $$0152184 = $$1153 ; $$0154183 = $$1155 ; $$0156182 = $$1157 ; } else { break ; } } $84 = ( $$1155 | 0 ) == ( 4 ) ; if ( $84 ) { $$pre$phiZ2D = $0 ; $107 = $61 ; } else { $85 = $$1153 & 255 ; HEAP8 [ $$1157 >> 0 ] = $85 ; $$pre$phiZ2D = $0 ; $107 = $61 ; } } else { $$pre$phiZ2D = $0 ; $107 = $61 ; } break ; } default : { $86 = $5 & 255 ; $87 = HEAP32 [ $0 >> 2 ] | 0 ; $88 = $86 >>> 3 ; $89 = ( 28426 + ( $2 ) | 0 ) ; $90 = HEAP8 [ $89 >> 0 ] | 0 ; $91 = $90 & 255 ; $92 = ( $87 >>> 0 ) > ( $91 >>> 0 ) ; if ( $92 ) { $93 = ( 28419 + ( $2 ) | 0 ) ; $94 = HEAP8 [ $93 >> 0 ] | 0 ; $95 = $94 & 255 ; $$0144164 = $91 ; $$0145163 = $1 ; while ( 1 ) { $96 = Math_imul ( $$0144164 , $88 ) | 0 ; $97 = ( ( $1 ) + ( $96 ) | 0 ) ; $98 = ( $$0145163 | 0 ) == ( $97 | 0 ) ; if ( ! ( $98 ) ) { _memcpy ( ( $$0145163 | 0 ) , ( $97 | 0 ) , ( $88 | 0 ) ) | 0 ; } $99 = ( ( $$0145163 ) + ( $88 ) | 0 ) ; $100 = ( ( $$0144164 ) + ( $95 ) ) | 0 ; $101 = ( $100 >>> 0 ) < ( $87 >>> 0 ) ; if ( $101 ) { $$0144164 = $100 ; $$0145163 = $99 ; } else { $$pre$phiZ2D = $0 ; $107 = $90 ; break ; } } } else { $$pre$phiZ2D = $0 ; $107 = $90 ; } } } $102 = HEAP32 [ $$pre$phiZ2D >> 2 ] | 0 ; $103 = ( 28419 + ( $2 ) | 0 ) ; $104 = HEAP8 [ $103 >> 0 ] | 0 ; $105 = $104 & 255 ; $106 = $107 & 255 ; $108 = ( ( $102 ) + - 1 ) | 0 ; $109 = ( ( $108 ) + ( $105 ) ) | 0 ; $110 = ( ( $109 ) - ( $106 ) ) | 0 ; $111 = ( ( $110 >>> 0 ) / ( $105 >>> 0 ) ) & - 1 ; HEAP32 [ $$pre$phiZ2D >> 2 ] = $111 ; $112 = HEAP8 [ $4 >> 0 ] | 0 ; $113 = $112 & 255 ; $114 = ( $112 & 255 ) > ( 7 ) ; if ( $114 ) { $115 = $113 >>> 3 ; $116 = Math_imul ( $115 , $111 ) | 0 ; $121 = $116 ; } else { $117 = Math_imul ( $111 , $113 ) | 0 ; $118 = ( ( $117 ) + 7 ) | 0 ; $119 = $118 >>> 3 ; $121 = $119 ; } $120 = ( ( ( $0 ) ) + 4 | 0 ) ; HEAP32 [ $120 >> 2 ] = $121 ; return ; } function _png_write_find_filter ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$0 = 0 , $$0$i = 0 , $$0$lcssa$i = 0 , $$0$lcssa$i153 = 0 , $$0$lcssa$i166 = 0 , $$0$lcssa$i178 = 0 , $$0$lcssa$i188 = 0 , $$0135 = 0 , $$0142202 = 0 , $$0142202$pn = 0 , $$0143201 = 0 , $$0144200 = 0 , $$0195$i = 0 , $$0195$pn$i = 0 , $$0206$i = 0 , $$0206$pn$i = 0 , $$0217$i = 0 , $$0217$pn$i = 0 , $$02637$i = 0 , $$02637$pn$i = 0 ; var $$02641$i = 0 , $$02641$pn$i = 0 , $$027$i = 0 , $$027$i184 = 0 , $$027$lcssa$i = 0 , $$027$lcssa$i189 = 0 , $$02738$i = 0 , $$02741$i = 0 , $$02742$i = 0 , $$02746$i = 0 , $$029$i = 0 , $$029$i185 = 0 , $$029$lcssa$i = 0 , $$029$lcssa$i190 = 0 , $$02939$i = 0 , $$02942$i = 0 , $$02943$i = 0 , $$02947$i = 0 , $$0295$i = 0 , $$0304$i = 0 ; var $$031$i = 0 , $$031$lcssa$i = 0 , $$03144$i = 0 , $$03148$i = 0 , $$0317$i = 0 , $$0328$i = 0 , $$039$lcssa$i = 0 , $$039$lcssa$i177 = 0 , $$03958$i = 0 , $$03963$i = 0 , $$04$i = 0 , $$040$i = 0 , $$04153$i = 0 , $$04153$pn$i = 0 , $$04157$i = 0 , $$04157$pn$i = 0 , $$042$i = 0 , $$042$i172 = 0 , $$042$lcssa$i = 0 , $$042$lcssa$i179 = 0 ; var $$04256$i = 0 , $$04260$i = 0 , $$04260$i170 = 0 , $$04265$i = 0 , $$044$i = 0 , $$044$i173 = 0 , $$044$lcssa$i = 0 , $$044$lcssa$i180 = 0 , $$04457$i = 0 , $$04461$i = 0 , $$04461$i171 = 0 , $$04466$i = 0 , $$045$i = 0 , $$046$i = 0 , $$046$lcssa$i = 0 , $$04662$i = 0 , $$04667$i = 0 , $$059$i = 0 , $$06$i = 0 , $$064$i = 0 ; var $$066$i = 0 , $$066$lcssa$i = 0 , $$06687$i = 0 , $$06691$i = 0 , $$068$i = 0 , $$068$lcssa$i = 0 , $$06888$i = 0 , $$06892$i = 0 , $$07084$i = 0 , $$07084$pn$i = 0 , $$07185$i = 0 , $$07185$pn$i = 0 , $$072$lcssa$i = 0 , $$07289$i = 0 , $$080$i = 0 , $$080$lcssa$i = 0 , $$080106$i = 0 , $$080111$i = 0 , $$081$i = 0 , $$081$lcssa$i = 0 ; var $$081107$i = 0 , $$081112$i = 0 , $$083$i = 0 , $$083$lcssa$i = 0 , $$083108$i = 0 , $$083113$i = 0 , $$085102$i = 0 , $$085102$pn$i = 0 , $$086$i = 0 , $$086103$i = 0 , $$086103$pn$i = 0 , $$087$lcssa$i = 0 , $$087110$i = 0 , $$089$lcssa$i = 0 , $$089109$i = 0 , $$090$i = 0 , $$1 = 0 , $$1$i = 0 , $$1101$i = 0 , $$12835$i = 0 ; var $$12839$i = 0 , $$13034$i = 0 , $$13038$i = 0 , $$13237$i = 0 , $$136$i = 0 , $$140$i = 0 , $$14051$i = 0 , $$14055$i = 0 , $$14350$i = 0 , $$14354$i = 0 , $$14549$i = 0 , $$14553$i = 0 , $$14752$i = 0 , $$152$i = 0 , $$156$i = 0 , $$16782$i = 0 , $$16981$i = 0 , $$17380$i = 0 , $$182100$i = 0 , $$183$i = 0 ; var $$18499$i = 0 , $$18898$i = 0 , $$19097$i = 0 , $$2$i = 0 , $$2$i163 = 0 , $$2$i182 = 0 , $$2137 = 0 , $$3 = 0 , $$4139 = 0 , $$5 = 0 , $$6141 = 0 , $$7 = 0 , $$idx = 0 , $$idx$val = 0 , $$idx145$val = 0 , $$idx146 = 0 , $$idx146$val = 0 , $$idx147 = 0 , $$idx147$val = 0 , $$idx148$val = 0 ; var $$idx149 = 0 , $$idx149$val = 0 , $$pn$pn$i = 0 , $$pn33$pn$i = 0 , $$pn34$pn$i = 0 , $$pre = 0 , $$pre$i = 0 , $$pre$i160 = 0 , $$pre$i165 = 0 , $$pre$i176 = 0 , $$pre$i187 = 0 , $$pre$phiZ2D = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 ; var $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 ; var $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 ; var $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 ; var $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 , $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 ; var $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 , $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 ; var $198 = 0 , $199 = 0 , $2 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 , $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 ; var $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 , $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 ; var $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 , $244 = 0 , $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 ; var $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 , $258 = 0 , $259 = 0 , $26 = 0 , $260 = 0 , $261 = 0 , $262 = 0 , $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 , $267 = 0 , $268 = 0 , $269 = 0 ; var $27 = 0 , $270 = 0 , $271 = 0 , $272 = 0 , $273 = 0 , $274 = 0 , $275 = 0 , $276 = 0 , $277 = 0 , $278 = 0 , $279 = 0 , $28 = 0 , $280 = 0 , $281 = 0 , $282 = 0 , $283 = 0 , $284 = 0 , $285 = 0 , $286 = 0 , $287 = 0 ; var $288 = 0 , $289 = 0 , $29 = 0 , $290 = 0 , $291 = 0 , $292 = 0 , $293 = 0 , $294 = 0 , $295 = 0 , $296 = 0 , $297 = 0 , $298 = 0 , $299 = 0 , $3 = 0 , $30 = 0 , $300 = 0 , $301 = 0 , $302 = 0 , $303 = 0 , $304 = 0 ; var $305 = 0 , $306 = 0 , $307 = 0 , $308 = 0 , $309 = 0 , $31 = 0 , $310 = 0 , $311 = 0 , $312 = 0 , $313 = 0 , $314 = 0 , $315 = 0 , $316 = 0 , $317 = 0 , $318 = 0 , $319 = 0 , $32 = 0 , $320 = 0 , $321 = 0 , $33 = 0 ; var $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 ; var $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 ; var $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 ; var $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $div$i = 0 , $div$i183 = 0 , $exitcond = 0 , $exitcond$i = 0 , $exitcond$i151 = 0 , $exitcond$i155 = 0 , $exitcond$i158 = 0 , $exitcond$i168 = 0 ; var $exitcond$i174 = 0 , $exitcond$i191 = 0 , $exitcond104$i = 0 , $exitcond51$i = 0 , $exitcond60$i = 0 , $or$cond = 0 , $or$cond$i = 0 , $or$cond$i161 = 0 , $or$cond$i167 = 0 , $scevgep$i = 0 , $scevgep$i150 = 0 , $scevgep$i159 = 0 , $scevgep$i164 = 0 , $scevgep$i175 = 0 , $scevgep$i186 = 0 , $scevgep102$i = 0 , $scevgep103$i = 0 , $scevgep127$i = 0 , $scevgep128$i = 0 , $scevgep50$i = 0 ; var $scevgep58$i = 0 , $scevgep59$i = 0 , $scevgep73$i = 0 , $scevgep81$i = 0 , $scevgep82$i = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( ( ( $0 ) ) + 222 | 0 ) ; $3 = HEAP8 [ $2 >> 0 ] | 0 ; $4 = $3 & 255 ; $5 = ( ( ( $1 ) ) + 4 | 0 ) ; $6 = HEAP32 [ $5 >> 2 ] | 0 ; $7 = ( ( ( $1 ) ) + 11 | 0 ) ; $8 = HEAP8 [ $7 >> 0 ] | 0 ; $9 = $8 & 255 ; $10 = ( ( $9 ) + 7 ) | 0 ; $11 = $10 >>> 3 ; $12 = ( ( ( $0 ) ) + 180 | 0 ) ; $13 = HEAP32 [ $12 >> 2 ] | 0 ; $14 = ( $6 >>> 0 ) > ( 33554430 ) ; if ( $14 ) { $15 = ( 0 - ( $4 ) ) | 0 ; $16 = $4 & $15 ; $$0 = $16 ; $$0135 = - 257 ; } else { $17 = $4 & 8 ; $18 = ( $17 | 0 ) != ( 0 ) ; $19 = ( $3 << 24 >> 24 ) != ( 8 ) ; $or$cond = $19 & $18 ; if ( $or$cond ) { $20 = ( $6 | 0 ) == ( 0 ) ; if ( $20 ) { $$0 = $4 ; $$0135 = 0 ; } else { $$0142202$pn = $13 ; $$0143201 = 0 ; $$0144200 = 0 ; while ( 1 ) { $$0142202 = ( ( ( $$0142202$pn ) ) + 1 | 0 ) ; $21 = HEAP8 [ $$0142202 >> 0 ] | 0 ; $22 = $21 & 255 ; $23 = ( $21 << 24 >> 24 ) > ( - 1 ) ; $24 = ( 256 - ( $22 ) ) | 0 ; $25 = $23 ? $22 : $24 ; $26 = ( ( $25 ) + ( $$0143201 ) ) | 0 ; $27 = ( ( $$0144200 ) + 1 ) | 0 ; $exitcond = ( $27 | 0 ) == ( $6 | 0 ) ; if ( $exitcond ) { $$0 = $4 ; $$0135 = $26 ; break ; } else { $$0142202$pn = $$0142202 ; $$0143201 = $26 ; $$0144200 = $27 ; } } } } else { $$0 = $4 ; $$0135 = - 257 ; } } $28 = ( $$0 | 0 ) == ( 16 ) ; if ( $28 ) { $29 = ( ( ( $0 ) ) + 184 | 0 ) ; $30 = HEAP32 [ $29 >> 2 ] | 0 ; HEAP8 [ $30 >> 0 ] = 1 ; $$02738$i = ( ( ( $30 ) ) + 1 | 0 ) ; $$02939$i = ( ( ( $13 ) ) + 1 | 0 ) ; $31 = ( $11 | 0 ) == ( 0 ) ; if ( $31 ) { $$0$lcssa$i = 0 ; $$027$lcssa$i = $$02738$i ; $$029$lcssa$i = $$02939$i ; $317 = $13 ; } else { $32 = ( ( $11 ) + 1 ) | 0 ; $$02741$i = $$02738$i ; $$02942$i = $$02939$i ; $$040$i = 0 ; while ( 1 ) { $33 = HEAP8 [ $$02942$i >> 0 ] | 0 ; HEAP8 [ $$02741$i >> 0 ] = $33 ; $34 = ( ( $$040$i ) + 1 ) | 0 ; $$027$i = ( ( ( $$02741$i ) ) + 1 | 0 ) ; $$029$i = ( ( ( $$02942$i ) ) + 1 | 0 ) ; $exitcond51$i = ( $34 | 0 ) == ( $11 | 0 ) ; if ( $exitcond51$i ) { break ; } else { $$02741$i = $$027$i ; $$02942$i = $$029$i ; $$040$i = $34 ; } } $scevgep$i = ( ( $30 ) + ( $32 ) | 0 ) ; $scevgep50$i = ( ( $13 ) + ( $32 ) | 0 ) ; $$pre$i = HEAP32 [ $12 >> 2 ] | 0 ; $$0$lcssa$i = $11 ; $$027$lcssa$i = $scevgep$i ; $$029$lcssa$i = $scevgep50$i ; $317 = $$pre$i ; } $35 = ( $$0$lcssa$i >>> 0 ) < ( $6 >>> 0 ) ; if ( $35 ) { $$02637$pn$i = $317 ; $$12835$i = $$027$lcssa$i ; $$13034$i = $$029$lcssa$i ; $$136$i = $$0$lcssa$i ; while ( 1 ) { $$02637$i = ( ( ( $$02637$pn$i ) ) + 1 | 0 ) ; $36 = HEAP8 [ $$13034$i >> 0 ] | 0 ; $37 = $36 & 255 ; $38 = HEAP8 [ $$02637$i >> 0 ] | 0 ; $39 = $38 & 255 ; $40 = ( ( $37 ) - ( $39 ) ) | 0 ; $41 = $40 & 255 ; HEAP8 [ $$12835$i >> 0 ] = $41 ; $42 = ( ( $$136$i ) + 1 ) | 0 ; $43 = ( ( ( $$13034$i ) ) + 1 | 0 ) ; $44 = ( ( ( $$12835$i ) ) + 1 | 0 ) ; $exitcond$i = ( $42 | 0 ) == ( $6 | 0 ) ; if ( $exitcond$i ) { break ; } else { $$02637$pn$i = $$02637$i ; $$12835$i = $44 ; $$13034$i = $43 ; $$136$i = $42 ; } } } $45 = HEAP32 [ $29 >> 2 ] | 0 ; $$1 = $45 ; $$2137 = $$0135 ; } else { $46 = $$0 & 16 ; $47 = ( $46 | 0 ) == ( 0 ) ; if ( $47 ) { $$1 = $13 ; $$2137 = $$0135 ; } else { $48 = ( ( ( $0 ) ) + 184 | 0 ) ; $49 = HEAP32 [ $48 >> 2 ] | 0 ; HEAP8 [ $49 >> 0 ] = 1 ; $$04256$i = ( ( ( $49 ) ) + 1 | 0 ) ; $$04457$i = ( ( ( $13 ) ) + 1 | 0 ) ; $50 = ( $11 | 0 ) == ( 0 ) ; if ( $50 ) { $$0$lcssa$i153 = 0 ; $$039$lcssa$i = 0 ; $$042$lcssa$i = $$04256$i ; $$044$lcssa$i = $$04457$i ; } else { $51 = ( ( $11 ) + 1 ) | 0 ; $$03958$i = 0 ; $$04260$i = $$04256$i ; $$04461$i = $$04457$i ; $$059$i = 0 ; while ( 1 ) { $52 = HEAP8 [ $$04461$i >> 0 ] | 0 ; HEAP8 [ $$04260$i >> 0 ] = $52 ; $53 = $52 & 255 ; $54 = ( $52 << 24 >> 24 ) > ( - 1 ) ; $55 = ( 256 - ( $53 ) ) | 0 ; $56 = $54 ? $53 : $55 ; $57 = ( ( $56 ) + ( $$059$i ) ) | 0 ; $58 = ( ( $$03958$i ) + 1 ) | 0 ; $$042$i = ( ( ( $$04260$i ) ) + 1 | 0 ) ; $$044$i = ( ( ( $$04461$i ) ) + 1 | 0 ) ; $exitcond$i151 = ( $58 | 0 ) == ( $11 | 0 ) ; if ( $exitcond$i151 ) { break ; } else { $$03958$i = $58 ; $$04260$i = $$042$i ; $$04461$i = $$044$i ; $$059$i = $57 ; } } $scevgep$i150 = ( ( $49 ) + ( $51 ) | 0 ) ; $scevgep73$i = ( ( $13 ) + ( $51 ) | 0 ) ; $$0$lcssa$i153 = $57 ; $$039$lcssa$i = $11 ; $$042$lcssa$i = $scevgep$i150 ; $$044$lcssa$i = $scevgep73$i ; } $59 = ( $$039$lcssa$i >>> 0 ) < ( $6 >>> 0 ) ; L28 : do { if ( $59 ) { $$04153$pn$i = $13 ; $$14051$i = $$039$lcssa$i ; $$14350$i = $$042$lcssa$i ; $$14549$i = $$044$lcssa$i ; $$152$i = $$0$lcssa$i153 ; while ( 1 ) { $$04153$i = ( ( ( $$04153$pn$i ) ) + 1 | 0 ) ; $60 = HEAP8 [ $$14549$i >> 0 ] | 0 ; $61 = $60 & 255 ; $62 = HEAP8 [ $$04153$i >> 0 ] | 0 ; $63 = $62 & 255 ; $64 = ( ( $61 ) - ( $63 ) ) | 0 ; $65 = $64 & 255 ; HEAP8 [ $$14350$i >> 0 ] = $65 ; $66 = $64 & 255 ; $67 = ( $66 >>> 0 ) < ( 128 ) ; $68 = ( 256 - ( $66 ) ) | 0 ; $69 = $67 ? $66 : $68 ; $70 = ( ( $69 ) + ( $$152$i ) ) | 0 ; $71 = ( $70 >>> 0 ) > ( $$0135 >>> 0 ) ; if ( $71 ) { $$2$i = $70 ; break L28 ; } $72 = ( ( $$14051$i ) + 1 ) | 0 ; $73 = ( ( ( $$14549$i ) ) + 1 | 0 ) ; $74 = ( ( ( $$14350$i ) ) + 1 | 0 ) ; $75 = ( $72 >>> 0 ) < ( $6 >>> 0 ) ; if ( $75 ) { $$04153$pn$i = $$04153$i ; $$14051$i = $72 ; $$14350$i = $74 ; $$14549$i = $73 ; $$152$i = $70 ; } else { $$2$i = $70 ; break ; } } } else { $$2$i = $$0$lcssa$i153 ; } } while ( 0 ) ; $76 = ( $$2$i >>> 0 ) < ( $$0135 >>> 0 ) ; if ( $76 ) { $77 = HEAP32 [ $48 >> 2 ] | 0 ; $78 = ( ( ( $0 ) ) + 188 | 0 ) ; $79 = HEAP32 [ $78 >> 2 ] | 0 ; $80 = ( $79 | 0 ) == ( 0 | 0 ) ; if ( $80 ) { $$1 = $77 ; $$2137 = $$2$i ; } else { HEAP32 [ $48 >> 2 ] = $79 ; HEAP32 [ $78 >> 2 ] = $77 ; $$1 = $77 ; $$2137 = $$2$i ; } } else { $$1 = $13 ; $$2137 = $$0135 ; } } } $81 = ( $$0 | 0 ) == ( 32 ) ; if ( $81 ) { $$idx = ( ( ( $0 ) ) + 176 | 0 ) ; $$idx$val = HEAP32 [ $$idx >> 2 ] | 0 ; $$idx145$val = HEAP32 [ $12 >> 2 ] | 0 ; $$idx146 = ( ( ( $0 ) ) + 184 | 0 ) ; $$idx146$val = HEAP32 [ $$idx146 >> 2 ] | 0 ; HEAP8 [ $$idx146$val >> 0 ] = 2 ; $82 = ( $6 | 0 ) == ( 0 ) ; if ( ! ( $82 ) ) { $$0195$pn$i = $$idx$val ; $$0206$pn$i = $$idx146$val ; $$0217$pn$i = $$idx145$val ; $$04$i = 0 ; while ( 1 ) { $$0195$i = ( ( ( $$0195$pn$i ) ) + 1 | 0 ) ; $$0206$i = ( ( ( $$0206$pn$i ) ) + 1 | 0 ) ; $$0217$i = ( ( ( $$0217$pn$i ) ) + 1 | 0 ) ; $83 = HEAP8 [ $$0217$i >> 0 ] | 0 ; $84 = $83 & 255 ; $85 = HEAP8 [ $$0195$i >> 0 ] | 0 ; $86 = $85 & 255 ; $87 = ( ( $84 ) - ( $86 ) ) | 0 ; $88 = $87 & 255 ; HEAP8 [ $$0206$i >> 0 ] = $88 ; $89 = ( ( $$04$i ) + 1 ) | 0 ; $exitcond$i155 = ( $89 | 0 ) == ( $6 | 0 ) ; if ( $exitcond$i155 ) { break ; } else { $$0195$pn$i = $$0195$i ; $$0206$pn$i = $$0206$i ; $$0217$pn$i = $$0217$i ; $$04$i = $89 ; } } } $90 = HEAP32 [ $$idx146 >> 2 ] | 0 ; $$3 = $90 ; $$4139 = $$2137 ; } else { $91 = $$0 & 32 ; $92 = ( $91 | 0 ) == ( 0 ) ; if ( $92 ) { $$3 = $$1 ; $$4139 = $$2137 ; } else { $$idx147 = ( ( ( $0 ) ) + 176 | 0 ) ; $$idx147$val = HEAP32 [ $$idx147 >> 2 ] | 0 ; $$idx148$val = HEAP32 [ $12 >> 2 ] | 0 ; $$idx149 = ( ( ( $0 ) ) + 184 | 0 ) ; $$idx149$val = HEAP32 [ $$idx149 >> 2 ] | 0 ; HEAP8 [ $$idx149$val >> 0 ] = 2 ; $93 = ( $6 | 0 ) == ( 0 ) ; if ( $93 ) { $$1$i = 0 ; } else { $$0295$i = 0 ; $$0304$i = 0 ; $$pn$pn$i = $$idx149$val ; $$pn33$pn$i = $$idx147$val ; $$pn34$pn$i = $$idx148$val ; while ( 1 ) { $$06$i = ( ( ( $$pn34$pn$i ) ) + 1 | 0 ) ; $$0317$i = ( ( ( $$pn33$pn$i ) ) + 1 | 0 ) ; $$0328$i = ( ( ( $$pn$pn$i ) ) + 1 | 0 ) ; $94 = HEAP8 [ $$06$i >> 0 ] | 0 ; $95 = $94 & 255 ; $96 = HEAP8 [ $$0317$i >> 0 ] | 0 ; $97 = $96 & 255 ; $98 = ( ( $95 ) - ( $97 ) ) | 0 ; $99 = $98 & 255 ; HEAP8 [ $$0328$i >> 0 ] = $99 ; $100 = $98 & 255 ; $101 = ( $100 >>> 0 ) < ( 128 ) ; $102 = ( 256 - ( $100 ) ) | 0 ; $103 = $101 ? $100 : $102 ; $104 = ( ( $103 ) + ( $$0295$i ) ) | 0 ; $105 = ( $104 >>> 0 ) <= ( $$2137 >>> 0 ) ; $106 = ( ( $$0304$i ) + 1 ) | 0 ; $107 = ( $106 >>> 0 ) < ( $6 >>> 0 ) ; $or$cond$i = $107 & $105 ; if ( $or$cond$i ) { $$0295$i = $104 ; $$0304$i = $106 ; $$pn$pn$i = $$0328$i ; $$pn33$pn$i = $$0317$i ; $$pn34$pn$i = $$06$i ; } else { $$1$i = $104 ; break ; } } } $108 = ( $$1$i >>> 0 ) < ( $$2137 >>> 0 ) ; if ( $108 ) { $109 = HEAP32 [ $$idx149 >> 2 ] | 0 ; $110 = ( ( ( $0 ) ) + 188 | 0 ) ; $111 = HEAP32 [ $110 >> 2 ] | 0 ; $112 = ( $111 | 0 ) == ( 0 | 0 ) ; if ( $112 ) { $$3 = $109 ; $$4139 = $$1$i ; } else { HEAP32 [ $$idx149 >> 2 ] = $111 ; HEAP32 [ $110 >> 2 ] = $109 ; $$3 = $109 ; $$4139 = $$1$i ; } } else { $$3 = $$1 ; $$4139 = $$2137 ; } } } $113 = ( $$0 | 0 ) == ( 64 ) ; if ( $113 ) { $114 = ( ( ( $0 ) ) + 184 | 0 ) ; $115 = HEAP32 [ $114 >> 2 ] | 0 ; HEAP8 [ $115 >> 0 ] = 3 ; $116 = HEAP32 [ $12 >> 2 ] | 0 ; $117 = ( ( ( $0 ) ) + 176 | 0 ) ; $118 = HEAP32 [ $117 >> 2 ] | 0 ; $$02742$i = ( ( ( $118 ) ) + 1 | 0 ) ; $$02943$i = ( ( ( $115 ) ) + 1 | 0 ) ; $$03144$i = ( ( ( $116 ) ) + 1 | 0 ) ; $119 = ( $11 | 0 ) == ( 0 ) ; if ( $119 ) { $$0$lcssa$i188 = 0 ; $$027$lcssa$i189 = $$02742$i ; $$029$lcssa$i190 = $$02943$i ; $$031$lcssa$i = $$03144$i ; $318 = $116 ; } else { $120 = ( ( $11 ) + 1 ) | 0 ; $$02746$i = $$02742$i ; $$02947$i = $$02943$i ; $$03148$i = $$03144$i ; $$045$i = 0 ; while ( 1 ) { $121 = HEAP8 [ $$03148$i >> 0 ] | 0 ; $122 = $121 & 255 ; $123 = HEAP8 [ $$02746$i >> 0 ] | 0 ; $div$i183 = ( $123 & 255 ) >>> 1 ; $124 = $div$i183 & 255 ; $125 = ( ( $122 ) - ( $124 ) ) | 0 ; $126 = $125 & 255 ; HEAP8 [ $$02947$i >> 0 ] = $126 ; $127 = ( ( $$045$i ) + 1 ) | 0 ; $$027$i184 = ( ( ( $$02746$i ) ) + 1 | 0 ) ; $$029$i185 = ( ( ( $$02947$i ) ) + 1 | 0 ) ; $$031$i = ( ( ( $$03148$i ) ) + 1 | 0 ) ; $exitcond60$i = ( $127 | 0 ) == ( $11 | 0 ) ; if ( $exitcond60$i ) { break ; } else { $$02746$i = $$027$i184 ; $$02947$i = $$029$i185 ; $$03148$i = $$031$i ; $$045$i = $127 ; } } $scevgep58$i = ( ( $115 ) + ( $120 ) | 0 ) ; $scevgep$i186 = ( ( $118 ) + ( $120 ) | 0 ) ; $scevgep59$i = ( ( $116 ) + ( $120 ) | 0 ) ; $$pre$i187 = HEAP32 [ $12 >> 2 ] | 0 ; $$0$lcssa$i188 = $11 ; $$027$lcssa$i189 = $scevgep$i186 ; $$029$lcssa$i190 = $scevgep58$i ; $$031$lcssa$i = $scevgep59$i ; $318 = $$pre$i187 ; } $128 = ( $$0$lcssa$i188 >>> 0 ) < ( $6 >>> 0 ) ; if ( $128 ) { $$02641$pn$i = $318 ; $$12839$i = $$027$lcssa$i189 ; $$13038$i = $$029$lcssa$i190 ; $$13237$i = $$031$lcssa$i ; $$140$i = $$0$lcssa$i188 ; while ( 1 ) { $$02641$i = ( ( ( $$02641$pn$i ) ) + 1 | 0 ) ; $129 = ( ( ( $$13237$i ) ) + 1 | 0 ) ; $130 = HEAP8 [ $$13237$i >> 0 ] | 0 ; $131 = $130 & 255 ; $132 = ( ( ( $$12839$i ) ) + 1 | 0 ) ; $133 = HEAP8 [ $$12839$i >> 0 ] | 0 ; $134 = $133 & 255 ; $135 = HEAP8 [ $$02641$i >> 0 ] | 0 ; $136 = $135 & 255 ; $137 = ( ( $136 ) + ( $134 ) ) | 0 ; $138 = $137 >>> 1 ; $139 = ( ( $131 ) - ( $138 ) ) | 0 ; $140 = $139 & 255 ; $141 = ( ( ( $$13038$i ) ) + 1 | 0 ) ; HEAP8 [ $$13038$i >> 0 ] = $140 ; $142 = ( ( $$140$i ) + 1 ) | 0 ; $exitcond$i191 = ( $142 | 0 ) == ( $6 | 0 ) ; if ( $exitcond$i191 ) { break ; } else { $$02641$pn$i = $$02641$i ; $$12839$i = $132 ; $$13038$i = $141 ; $$13237$i = $129 ; $$140$i = $142 ; } } } $143 = HEAP32 [ $114 >> 2 ] | 0 ; $$5 = $143 ; $$6141 = $$4139 ; } else { $144 = $$0 & 64 ; $145 = ( $144 | 0 ) == ( 0 ) ; if ( $145 ) { $$5 = $$3 ; $$6141 = $$4139 ; } else { $146 = ( ( ( $0 ) ) + 184 | 0 ) ; $147 = HEAP32 [ $146 >> 2 ] | 0 ; HEAP8 [ $147 >> 0 ] = 3 ; $148 = HEAP32 [ $12 >> 2 ] | 0 ; $149 = ( ( ( $0 ) ) + 176 | 0 ) ; $150 = HEAP32 [ $149 >> 2 ] | 0 ; $$04260$i170 = ( ( ( $150 ) ) + 1 | 0 ) ; $$04461$i171 = ( ( ( $147 ) ) + 1 | 0 ) ; $$04662$i = ( ( ( $148 ) ) + 1 | 0 ) ; $151 = ( $11 | 0 ) == ( 0 ) ; if ( $151 ) { $$0$lcssa$i178 = 0 ; $$039$lcssa$i177 = 0 ; $$042$lcssa$i179 = $$04260$i170 ; $$044$lcssa$i180 = $$04461$i171 ; $$046$lcssa$i = $$04662$i ; $319 = $148 ; } else { $152 = ( ( $11 ) + 1 ) | 0 ; $$03963$i = 0 ; $$04265$i = $$04260$i170 ; $$04466$i = $$04461$i171 ; $$04667$i = $$04662$i ; $$064$i = 0 ; while ( 1 ) { $153 = HEAP8 [ $$04667$i >> 0 ] | 0 ; $154 = $153 & 255 ; $155 = HEAP8 [ $$04265$i >> 0 ] | 0 ; $div$i = ( $155 & 255 ) >>> 1 ; $156 = $div$i & 255 ; $157 = ( ( $154 ) - ( $156 ) ) | 0 ; $158 = $157 & 255 ; HEAP8 [ $$04466$i >> 0 ] = $158 ; $159 = $157 & 255 ; $160 = ( $159 >>> 0 ) < ( 128 ) ; $161 = ( 256 - ( $159 ) ) | 0 ; $162 = $160 ? $159 : $161 ; $163 = ( ( $162 ) + ( $$064$i ) ) | 0 ; $164 = ( ( $$03963$i ) + 1 ) | 0 ; $$042$i172 = ( ( ( $$04265$i ) ) + 1 | 0 ) ; $$044$i173 = ( ( ( $$04466$i ) ) + 1 | 0 ) ; $$046$i = ( ( ( $$04667$i ) ) + 1 | 0 ) ; $exitcond$i174 = ( $164 | 0 ) == ( $11 | 0 ) ; if ( $exitcond$i174 ) { break ; } else { $$03963$i = $164 ; $$04265$i = $$042$i172 ; $$04466$i = $$044$i173 ; $$04667$i = $$046$i ; $$064$i = $163 ; } } $scevgep81$i = ( ( $147 ) + ( $152 ) | 0 ) ; $scevgep$i175 = ( ( $150 ) + ( $152 ) | 0 ) ; $scevgep82$i = ( ( $148 ) + ( $152 ) | 0 ) ; $$pre$i176 = HEAP32 [ $12 >> 2 ] | 0 ; $$0$lcssa$i178 = $163 ; $$039$lcssa$i177 = $11 ; $$042$lcssa$i179 = $scevgep$i175 ; $$044$lcssa$i180 = $scevgep81$i ; $$046$lcssa$i = $scevgep82$i ; $319 = $$pre$i176 ; } $165 = ( $$039$lcssa$i177 >>> 0 ) < ( $6 >>> 0 ) ; L71 : do { if ( $165 ) { $$04157$pn$i = $319 ; $$14055$i = $$039$lcssa$i177 ; $$14354$i = $$042$lcssa$i179 ; $$14553$i = $$044$lcssa$i180 ; $$14752$i = $$046$lcssa$i ; $$156$i = $$0$lcssa$i178 ; while ( 1 ) { $$04157$i = ( ( ( $$04157$pn$i ) ) + 1 | 0 ) ; $166 = HEAP8 [ $$14752$i >> 0 ] | 0 ; $167 = $166 & 255 ; $168 = HEAP8 [ $$14354$i >> 0 ] | 0 ; $169 = $168 & 255 ; $170 = HEAP8 [ $$04157$i >> 0 ] | 0 ; $171 = $170 & 255 ; $172 = ( ( $171 ) + ( $169 ) ) | 0 ; $173 = $172 >>> 1 ; $174 = ( ( $167 ) - ( $173 ) ) | 0 ; $175 = $174 & 255 ; HEAP8 [ $$14553$i >> 0 ] = $175 ; $176 = $174 & 255 ; $177 = ( $176 >>> 0 ) < ( 128 ) ; $178 = ( 256 - ( $176 ) ) | 0 ; $179 = $177 ? $176 : $178 ; $180 = ( ( $179 ) + ( $$156$i ) ) | 0 ; $181 = ( $180 >>> 0 ) > ( $$4139 >>> 0 ) ; if ( $181 ) { $$2$i182 = $180 ; break L71 ; } $182 = ( ( ( $$14553$i ) ) + 1 | 0 ) ; $183 = ( ( ( $$14354$i ) ) + 1 | 0 ) ; $184 = ( ( ( $$14752$i ) ) + 1 | 0 ) ; $185 = ( ( $$14055$i ) + 1 ) | 0 ; $186 = ( $185 >>> 0 ) < ( $6 >>> 0 ) ; if ( $186 ) { $$04157$pn$i = $$04157$i ; $$14055$i = $185 ; $$14354$i = $183 ; $$14553$i = $182 ; $$14752$i = $184 ; $$156$i = $180 ; } else { $$2$i182 = $180 ; break ; } } } else { $$2$i182 = $$0$lcssa$i178 ; } } while ( 0 ) ; $187 = ( $$2$i182 >>> 0 ) < ( $$4139 >>> 0 ) ; if ( $187 ) { $188 = HEAP32 [ $146 >> 2 ] | 0 ; $189 = ( ( ( $0 ) ) + 188 | 0 ) ; $190 = HEAP32 [ $189 >> 2 ] | 0 ; $191 = ( $190 | 0 ) == ( 0 | 0 ) ; if ( $191 ) { $$5 = $188 ; $$6141 = $$2$i182 ; } else { HEAP32 [ $146 >> 2 ] = $190 ; HEAP32 [ $189 >> 2 ] = $188 ; $$5 = $188 ; $$6141 = $$2$i182 ; } } else { $$5 = $$3 ; $$6141 = $$4139 ; } } } $192 = ( $$0 | 0 ) == ( 128 ) ; do { if ( $192 ) { $193 = ( ( ( $0 ) ) + 184 | 0 ) ; $194 = HEAP32 [ $193 >> 2 ] | 0 ; HEAP8 [ $194 >> 0 ] = 4 ; $195 = HEAP32 [ $12 >> 2 ] | 0 ; $196 = ( ( ( $0 ) ) + 176 | 0 ) ; $197 = HEAP32 [ $196 >> 2 ] | 0 ; $$086$i = ( ( ( $195 ) ) + 1 | 0 ) ; $$06687$i = ( ( ( $194 ) ) + 1 | 0 ) ; $$06888$i = ( ( ( $197 ) ) + 1 | 0 ) ; $198 = ( $11 | 0 ) == ( 0 ) ; if ( $198 ) { $$0$lcssa$i166 = $$086$i ; $$066$lcssa$i = $$06687$i ; $$068$lcssa$i = $$06888$i ; $$072$lcssa$i = 0 ; $320 = $195 ; } else { $199 = ( ( $11 ) + 1 ) | 0 ; $$06691$i = $$06687$i ; $$06892$i = $$06888$i ; $$07289$i = 0 ; $$090$i = $$086$i ; while ( 1 ) { $200 = HEAP8 [ $$090$i >> 0 ] | 0 ; $201 = $200 & 255 ; $202 = HEAP8 [ $$06892$i >> 0 ] | 0 ; $203 = $202 & 255 ; $204 = ( ( $201 ) - ( $203 ) ) | 0 ; $205 = $204 & 255 ; HEAP8 [ $$06691$i >> 0 ] = $205 ; $206 = ( ( $$07289$i ) + 1 ) | 0 ; $$0$i = ( ( ( $$090$i ) ) + 1 | 0 ) ; $$066$i = ( ( ( $$06691$i ) ) + 1 | 0 ) ; $$068$i = ( ( ( $$06892$i ) ) + 1 | 0 ) ; $exitcond104$i = ( $206 | 0 ) == ( $11 | 0 ) ; if ( $exitcond104$i ) { break ; } else { $$06691$i = $$066$i ; $$06892$i = $$068$i ; $$07289$i = $206 ; $$090$i = $$0$i ; } } $scevgep102$i = ( ( $194 ) + ( $199 ) | 0 ) ; $scevgep$i164 = ( ( $195 ) + ( $199 ) | 0 ) ; $scevgep103$i = ( ( $197 ) + ( $199 ) | 0 ) ; $$pre$i165 = HEAP32 [ $12 >> 2 ] | 0 ; $$0$lcssa$i166 = $scevgep$i164 ; $$066$lcssa$i = $scevgep102$i ; $$068$lcssa$i = $scevgep103$i ; $$072$lcssa$i = $11 ; $320 = $$pre$i165 ; } $207 = ( $$072$lcssa$i >>> 0 ) < ( $6 >>> 0 ) ; if ( $207 ) { $$07084$pn$i = $197 ; $$07185$pn$i = $320 ; $$16782$i = $$066$lcssa$i ; $$16981$i = $$068$lcssa$i ; $$17380$i = $$072$lcssa$i ; $$183$i = $$0$lcssa$i166 ; while ( 1 ) { $$07084$i = ( ( ( $$07084$pn$i ) ) + 1 | 0 ) ; $$07185$i = ( ( ( $$07185$pn$i ) ) + 1 | 0 ) ; $208 = ( ( ( $$16981$i ) ) + 1 | 0 ) ; $209 = HEAP8 [ $$16981$i >> 0 ] | 0 ; $210 = $209 & 255 ; $211 = HEAP8 [ $$07084$i >> 0 ] | 0 ; $212 = $211 & 255 ; $213 = HEAP8 [ $$07185$i >> 0 ] | 0 ; $214 = $213 & 255 ; $215 = ( ( $210 ) - ( $212 ) ) | 0 ; $216 = ( ( $214 ) - ( $212 ) ) | 0 ; $217 = ( $215 | 0 ) < ( 0 ) ; $218 = ( 0 - ( $215 ) ) | 0 ; $219 = $217 ? $218 : $215 ; $220 = ( $216 | 0 ) < ( 0 ) ; $221 = ( 0 - ( $216 ) ) | 0 ; $222 = $220 ? $221 : $216 ; $223 = ( ( $216 ) + ( $215 ) ) | 0 ; $224 = ( $223 | 0 ) < ( 0 ) ; $225 = ( 0 - ( $223 ) ) | 0 ; $226 = $224 ? $225 : $223 ; $227 = ( $219 | 0 ) > ( $222 | 0 ) ; $228 = ( $219 | 0 ) > ( $226 | 0 ) ; $or$cond$i167 = $227 | $228 ; $229 = ( $222 | 0 ) <= ( $226 | 0 ) ; $230 = $229 ? $210 : $212 ; $231 = $or$cond$i167 ? $230 : $214 ; $232 = ( ( ( $$183$i ) ) + 1 | 0 ) ; $233 = HEAP8 [ $$183$i >> 0 ] | 0 ; $234 = $233 & 255 ; $235 = ( ( $234 ) - ( $231 ) ) | 0 ; $236 = $235 & 255 ; $237 = ( ( ( $$16782$i ) ) + 1 | 0 ) ; HEAP8 [ $$16782$i >> 0 ] = $236 ; $238 = ( ( $$17380$i ) + 1 ) | 0 ; $exitcond$i168 = ( $238 | 0 ) == ( $6 | 0 ) ; if ( $exitcond$i168 ) { break ; } else { $$07084$pn$i = $$07084$i ; $$07185$pn$i = $$07185$i ; $$16782$i = $237 ; $$16981$i = $208 ; $$17380$i = $238 ; $$183$i = $232 ; } } } $239 = HEAP32 [ $193 >> 2 ] | 0 ; $$7 = $239 ; $$pre$phiZ2D = $196 ; } else { $240 = $$0 & 128 ; $241 = ( $240 | 0 ) == ( 0 ) ; if ( $241 ) { $$pre = ( ( ( $0 ) ) + 176 | 0 ) ; $$7 = $$5 ; $$pre$phiZ2D = $$pre ; break ; } $242 = ( ( ( $0 ) ) + 184 | 0 ) ; $243 = HEAP32 [ $242 >> 2 ] | 0 ; HEAP8 [ $243 >> 0 ] = 4 ; $244 = HEAP32 [ $12 >> 2 ] | 0 ; $245 = ( ( ( $0 ) ) + 176 | 0 ) ; $246 = HEAP32 [ $245 >> 2 ] | 0 ; $$080106$i = ( ( ( $244 ) ) + 1 | 0 ) ; $$081107$i = ( ( ( $243 ) ) + 1 | 0 ) ; $$083108$i = ( ( ( $246 ) ) + 1 | 0 ) ; $247 = ( $11 | 0 ) == ( 0 ) ; if ( $247 ) { $$080$lcssa$i = $$080106$i ; $$081$lcssa$i = $$081107$i ; $$083$lcssa$i = $$083108$i ; $$087$lcssa$i = 0 ; $$089$lcssa$i = 0 ; $321 = $244 ; } else { $248 = ( ( $11 ) + 1 ) | 0 ; $$080111$i = $$080106$i ; $$081112$i = $$081107$i ; $$083113$i = $$083108$i ; $$087110$i = 0 ; $$089109$i = 0 ; while ( 1 ) { $249 = HEAP8 [ $$080111$i >> 0 ] | 0 ; $250 = $249 & 255 ; $251 = HEAP8 [ $$083113$i >> 0 ] | 0 ; $252 = $251 & 255 ; $253 = ( ( $250 ) - ( $252 ) ) | 0 ; $254 = $253 & 255 ; HEAP8 [ $$081112$i >> 0 ] = $254 ; $255 = $253 & 255 ; $256 = ( $255 >>> 0 ) < ( 128 ) ; $257 = ( 256 - ( $255 ) ) | 0 ; $258 = $256 ? $255 : $257 ; $259 = ( ( $258 ) + ( $$087110$i ) ) | 0 ; $260 = ( ( $$089109$i ) + 1 ) | 0 ; $$080$i = ( ( ( $$080111$i ) ) + 1 | 0 ) ; $$081$i = ( ( ( $$081112$i ) ) + 1 | 0 ) ; $$083$i = ( ( ( $$083113$i ) ) + 1 | 0 ) ; $exitcond$i158 = ( $260 | 0 ) == ( $11 | 0 ) ; if ( $exitcond$i158 ) { break ; } else { $$080111$i = $$080$i ; $$081112$i = $$081$i ; $$083113$i = $$083$i ; $$087110$i = $259 ; $$089109$i = $260 ; } } $scevgep127$i = ( ( $243 ) + ( $248 ) | 0 ) ; $scevgep$i159 = ( ( $244 ) + ( $248 ) | 0 ) ; $scevgep128$i = ( ( $246 ) + ( $248 ) | 0 ) ; $$pre$i160 = HEAP32 [ $12 >> 2 ] | 0 ; $$080$lcssa$i = $scevgep$i159 ; $$081$lcssa$i = $scevgep127$i ; $$083$lcssa$i = $scevgep128$i ; $$087$lcssa$i = $259 ; $$089$lcssa$i = $11 ; $321 = $$pre$i160 ; } $261 = ( $$089$lcssa$i >>> 0 ) < ( $6 >>> 0 ) ; L101 : do { if ( $261 ) { $$085102$pn$i = $246 ; $$086103$pn$i = $321 ; $$1101$i = $$080$lcssa$i ; $$182100$i = $$081$lcssa$i ; $$18499$i = $$083$lcssa$i ; $$18898$i = $$087$lcssa$i ; $$19097$i = $$089$lcssa$i ; while ( 1 ) { $$085102$i = ( ( ( $$085102$pn$i ) ) + 1 | 0 ) ; $$086103$i = ( ( ( $$086103$pn$i ) ) + 1 | 0 ) ; $262 = HEAP8 [ $$18499$i >> 0 ] | 0 ; $263 = $262 & 255 ; $264 = HEAP8 [ $$085102$i >> 0 ] | 0 ; $265 = $264 & 255 ; $266 = HEAP8 [ $$086103$i >> 0 ] | 0 ; $267 = $266 & 255 ; $268 = ( ( $263 ) - ( $265 ) ) | 0 ; $269 = ( ( $267 ) - ( $265 ) ) | 0 ; $270 = ( $268 | 0 ) < ( 0 ) ; $271 = ( 0 - ( $268 ) ) | 0 ; $272 = $270 ? $271 : $268 ; $273 = ( $269 | 0 ) < ( 0 ) ; $274 = ( 0 - ( $269 ) ) | 0 ; $275 = $273 ? $274 : $269 ; $276 = ( ( $269 ) + ( $268 ) ) | 0 ; $277 = ( $276 | 0 ) < ( 0 ) ; $278 = ( 0 - ( $276 ) ) | 0 ; $279 = $277 ? $278 : $276 ; $280 = ( $272 | 0 ) > ( $275 | 0 ) ; $281 = ( $272 | 0 ) > ( $279 | 0 ) ; $or$cond$i161 = $280 | $281 ; $282 = ( $275 | 0 ) <= ( $279 | 0 ) ; $283 = $282 ? $263 : $265 ; $284 = $or$cond$i161 ? $283 : $267 ; $285 = HEAP8 [ $$1101$i >> 0 ] | 0 ; $286 = $285 & 255 ; $287 = ( ( $286 ) - ( $284 ) ) | 0 ; $288 = $287 & 255 ; HEAP8 [ $$182100$i >> 0 ] = $288 ; $289 = $287 & 255 ; $290 = ( $289 >>> 0 ) < ( 128 ) ; $291 = ( 256 - ( $289 ) ) | 0 ; $292 = $290 ? $289 : $291 ; $293 = ( ( $292 ) + ( $$18898$i ) ) | 0 ; $294 = ( $293 >>> 0 ) > ( $$6141 >>> 0 ) ; if ( $294 ) { $$2$i163 = $293 ; break L101 ; } $295 = ( ( ( $$182100$i ) ) + 1 | 0 ) ; $296 = ( ( ( $$1101$i ) ) + 1 | 0 ) ; $297 = ( ( ( $$18499$i ) ) + 1 | 0 ) ; $298 = ( ( $$19097$i ) + 1 ) | 0 ; $299 = ( $298 >>> 0 ) < ( $6 >>> 0 ) ; if ( $299 ) { $$085102$pn$i = $$085102$i ; $$086103$pn$i = $$086103$i ; $$1101$i = $296 ; $$182100$i = $295 ; $$18499$i = $297 ; $$18898$i = $293 ; $$19097$i = $298 ; } else { $$2$i163 = $293 ; break ; } } } else { $$2$i163 = $$087$lcssa$i ; } } while ( 0 ) ; $300 = ( $$2$i163 >>> 0 ) < ( $$6141 >>> 0 ) ; if ( $300 ) { $301 = HEAP32 [ $242 >> 2 ] | 0 ; $302 = ( ( ( $0 ) ) + 188 | 0 ) ; $303 = HEAP32 [ $302 >> 2 ] | 0 ; $304 = ( $303 | 0 ) == ( 0 | 0 ) ; if ( $304 ) { $$7 = $301 ; $$pre$phiZ2D = $245 ; } else { HEAP32 [ $242 >> 2 ] = $303 ; HEAP32 [ $302 >> 2 ] = $301 ; $$7 = $301 ; $$pre$phiZ2D = $245 ; } } else { $$7 = $$5 ; $$pre$phiZ2D = $245 ; } } } while ( 0 ) ; $305 = HEAP32 [ $5 >> 2 ] | 0 ; $306 = ( ( $305 ) + 1 ) | 0 ; _png_compress_IDAT ( $0 , $$7 , $306 , 0 ) ; $307 = HEAP32 [ $$pre$phiZ2D >> 2 ] | 0 ; $308 = ( $307 | 0 ) == ( 0 | 0 ) ; if ( ! ( $308 ) ) { $309 = HEAP32 [ $12 >> 2 ] | 0 ; HEAP32 [ $$pre$phiZ2D >> 2 ] = $309 ; HEAP32 [ $12 >> 2 ] = $307 ; } _png_write_finish_row ( $0 ) ; $310 = ( ( ( $0 ) ) + 260 | 0 ) ; $311 = HEAP32 [ $310 >> 2 ] | 0 ; $312 = ( ( $311 ) + 1 ) | 0 ; HEAP32 [ $310 >> 2 ] = $312 ; $313 = ( ( ( $0 ) ) + 256 | 0 ) ; $314 = HEAP32 [ $313 >> 2 ] | 0 ; $315 = ( ( $314 ) + - 1 ) | 0 ; $316 = ( $315 >>> 0 ) < ( $312 >>> 0 ) ; if ( ! ( $316 ) ) { return ; } _png_write_flush ( $0 ) ; return ; } function _crc32_z ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $7 = sp ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $8 = $5 ; $9 = ( $8 | 0 ) == ( 0 | 0 ) ; do { if ( $9 ) { $3 = 0 ; } else { HEAP32 [ $7 >> 2 ] = 1 ; $10 = HEAP8 [ $7 >> 0 ] | 0 ; $11 = ( $10 << 24 >> 24 ) != ( 0 ) ; $12 = $4 ; $13 = $5 ; $14 = $6 ; if ( $11 ) { $15 = ( _crc32_little ( $12 , $13 , $14 ) | 0 ) ; $3 = $15 ; break ; } else { $16 = ( _crc32_big ( $12 , $13 , $14 ) | 0 ) ; $3 = $16 ; break ; } } } while ( 0 ) ; $17 = $3 ; STACKTOP = sp ; return ( $17 | 0 ) ; } function _crc32_little ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 ; var $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 ; var $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 ; var $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 ; var $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 , $208 = 0 ; var $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 , $226 = 0 ; var $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 , $244 = 0 ; var $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 , $258 = 0 , $259 = 0 , $26 = 0 , $260 = 0 , $261 = 0 , $262 = 0 ; var $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 , $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 , $270 = 0 , $271 = 0 , $272 = 0 , $273 = 0 , $274 = 0 , $275 = 0 , $276 = 0 , $277 = 0 , $278 = 0 , $279 = 0 , $28 = 0 , $280 = 0 ; var $281 = 0 , $282 = 0 , $283 = 0 , $284 = 0 , $285 = 0 , $286 = 0 , $287 = 0 , $288 = 0 , $289 = 0 , $29 = 0 , $290 = 0 , $291 = 0 , $292 = 0 , $293 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 ; var $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 ; var $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 ; var $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 ; var $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $3 = $0 ; $4 = $1 ; $5 = $2 ; $8 = $3 ; $6 = $8 ; $9 = $6 ; $10 = $9 ^ - 1 ; $6 = $10 ; while ( 1 ) { $11 = $5 ; $12 = ( $11 | 0 ) != ( 0 ) ; if ( ! ( $12 ) ) { break ; } $13 = $4 ; $14 = $13 ; $15 = $14 & 3 ; $16 = ( $15 | 0 ) != ( 0 ) ; if ( ! ( $16 ) ) { break ; } $17 = $6 ; $18 = $4 ; $19 = ( ( ( $18 ) ) + 1 | 0 ) ; $4 = $19 ; $20 = HEAP8 [ $18 >> 0 ] | 0 ; $21 = $20 & 255 ; $22 = $17 ^ $21 ; $23 = $22 & 255 ; $24 = ( 492 + ( $23 << 2 ) | 0 ) ; $25 = HEAP32 [ $24 >> 2 ] | 0 ; $26 = $6 ; $27 = $26 >>> 8 ; $28 = $25 ^ $27 ; $6 = $28 ; $29 = $5 ; $30 = ( ( $29 ) + - 1 ) | 0 ; $5 = $30 ; } $31 = $4 ; $7 = $31 ; while ( 1 ) { $32 = $5 ; $33 = ( $32 >>> 0 ) >= ( 32 ) ; if ( ! ( $33 ) ) { break ; } $34 = $7 ; $35 = ( ( ( $34 ) ) + 4 | 0 ) ; $7 = $35 ; $36 = HEAP32 [ $34 >> 2 ] | 0 ; $37 = $6 ; $38 = $37 ^ $36 ; $6 = $38 ; $39 = $6 ; $40 = $39 & 255 ; $41 = ( ( 3564 ) + ( $40 << 2 ) | 0 ) ; $42 = HEAP32 [ $41 >> 2 ] | 0 ; $43 = $6 ; $44 = $43 >>> 8 ; $45 = $44 & 255 ; $46 = ( ( 2540 ) + ( $45 << 2 ) | 0 ) ; $47 = HEAP32 [ $46 >> 2 ] | 0 ; $48 = $42 ^ $47 ; $49 = $6 ; $50 = $49 >>> 16 ; $51 = $50 & 255 ; $52 = ( ( 1516 ) + ( $51 << 2 ) | 0 ) ; $53 = HEAP32 [ $52 >> 2 ] | 0 ; $54 = $48 ^ $53 ; $55 = $6 ; $56 = $55 >>> 24 ; $57 = ( 492 + ( $56 << 2 ) | 0 ) ; $58 = HEAP32 [ $57 >> 2 ] | 0 ; $59 = $54 ^ $58 ; $6 = $59 ; $60 = $7 ; $61 = ( ( ( $60 ) ) + 4 | 0 ) ; $7 = $61 ; $62 = HEAP32 [ $60 >> 2 ] | 0 ; $63 = $6 ; $64 = $63 ^ $62 ; $6 = $64 ; $65 = $6 ; $66 = $65 & 255 ; $67 = ( ( 3564 ) + ( $66 << 2 ) | 0 ) ; $68 = HEAP32 [ $67 >> 2 ] | 0 ; $69 = $6 ; $70 = $69 >>> 8 ; $71 = $70 & 255 ; $72 = ( ( 2540 ) + ( $71 << 2 ) | 0 ) ; $73 = HEAP32 [ $72 >> 2 ] | 0 ; $74 = $68 ^ $73 ; $75 = $6 ; $76 = $75 >>> 16 ; $77 = $76 & 255 ; $78 = ( ( 1516 ) + ( $77 << 2 ) | 0 ) ; $79 = HEAP32 [ $78 >> 2 ] | 0 ; $80 = $74 ^ $79 ; $81 = $6 ; $82 = $81 >>> 24 ; $83 = ( 492 + ( $82 << 2 ) | 0 ) ; $84 = HEAP32 [ $83 >> 2 ] | 0 ; $85 = $80 ^ $84 ; $6 = $85 ; $86 = $7 ; $87 = ( ( ( $86 ) ) + 4 | 0 ) ; $7 = $87 ; $88 = HEAP32 [ $86 >> 2 ] | 0 ; $89 = $6 ; $90 = $89 ^ $88 ; $6 = $90 ; $91 = $6 ; $92 = $91 & 255 ; $93 = ( ( 3564 ) + ( $92 << 2 ) | 0 ) ; $94 = HEAP32 [ $93 >> 2 ] | 0 ; $95 = $6 ; $96 = $95 >>> 8 ; $97 = $96 & 255 ; $98 = ( ( 2540 ) + ( $97 << 2 ) | 0 ) ; $99 = HEAP32 [ $98 >> 2 ] | 0 ; $100 = $94 ^ $99 ; $101 = $6 ; $102 = $101 >>> 16 ; $103 = $102 & 255 ; $104 = ( ( 1516 ) + ( $103 << 2 ) | 0 ) ; $105 = HEAP32 [ $104 >> 2 ] | 0 ; $106 = $100 ^ $105 ; $107 = $6 ; $108 = $107 >>> 24 ; $109 = ( 492 + ( $108 << 2 ) | 0 ) ; $110 = HEAP32 [ $109 >> 2 ] | 0 ; $111 = $106 ^ $110 ; $6 = $111 ; $112 = $7 ; $113 = ( ( ( $112 ) ) + 4 | 0 ) ; $7 = $113 ; $114 = HEAP32 [ $112 >> 2 ] | 0 ; $115 = $6 ; $116 = $115 ^ $114 ; $6 = $116 ; $117 = $6 ; $118 = $117 & 255 ; $119 = ( ( 3564 ) + ( $118 << 2 ) | 0 ) ; $120 = HEAP32 [ $119 >> 2 ] | 0 ; $121 = $6 ; $122 = $121 >>> 8 ; $123 = $122 & 255 ; $124 = ( ( 2540 ) + ( $123 << 2 ) | 0 ) ; $125 = HEAP32 [ $124 >> 2 ] | 0 ; $126 = $120 ^ $125 ; $127 = $6 ; $128 = $127 >>> 16 ; $129 = $128 & 255 ; $130 = ( ( 1516 ) + ( $129 << 2 ) | 0 ) ; $131 = HEAP32 [ $130 >> 2 ] | 0 ; $132 = $126 ^ $131 ; $133 = $6 ; $134 = $133 >>> 24 ; $135 = ( 492 + ( $134 << 2 ) | 0 ) ; $136 = HEAP32 [ $135 >> 2 ] | 0 ; $137 = $132 ^ $136 ; $6 = $137 ; $138 = $7 ; $139 = ( ( ( $138 ) ) + 4 | 0 ) ; $7 = $139 ; $140 = HEAP32 [ $138 >> 2 ] | 0 ; $141 = $6 ; $142 = $141 ^ $140 ; $6 = $142 ; $143 = $6 ; $144 = $143 & 255 ; $145 = ( ( 3564 ) + ( $144 << 2 ) | 0 ) ; $146 = HEAP32 [ $145 >> 2 ] | 0 ; $147 = $6 ; $148 = $147 >>> 8 ; $149 = $148 & 255 ; $150 = ( ( 2540 ) + ( $149 << 2 ) | 0 ) ; $151 = HEAP32 [ $150 >> 2 ] | 0 ; $152 = $146 ^ $151 ; $153 = $6 ; $154 = $153 >>> 16 ; $155 = $154 & 255 ; $156 = ( ( 1516 ) + ( $155 << 2 ) | 0 ) ; $157 = HEAP32 [ $156 >> 2 ] | 0 ; $158 = $152 ^ $157 ; $159 = $6 ; $160 = $159 >>> 24 ; $161 = ( 492 + ( $160 << 2 ) | 0 ) ; $162 = HEAP32 [ $161 >> 2 ] | 0 ; $163 = $158 ^ $162 ; $6 = $163 ; $164 = $7 ; $165 = ( ( ( $164 ) ) + 4 | 0 ) ; $7 = $165 ; $166 = HEAP32 [ $164 >> 2 ] | 0 ; $167 = $6 ; $168 = $167 ^ $166 ; $6 = $168 ; $169 = $6 ; $170 = $169 & 255 ; $171 = ( ( 3564 ) + ( $170 << 2 ) | 0 ) ; $172 = HEAP32 [ $171 >> 2 ] | 0 ; $173 = $6 ; $174 = $173 >>> 8 ; $175 = $174 & 255 ; $176 = ( ( 2540 ) + ( $175 << 2 ) | 0 ) ; $177 = HEAP32 [ $176 >> 2 ] | 0 ; $178 = $172 ^ $177 ; $179 = $6 ; $180 = $179 >>> 16 ; $181 = $180 & 255 ; $182 = ( ( 1516 ) + ( $181 << 2 ) | 0 ) ; $183 = HEAP32 [ $182 >> 2 ] | 0 ; $184 = $178 ^ $183 ; $185 = $6 ; $186 = $185 >>> 24 ; $187 = ( 492 + ( $186 << 2 ) | 0 ) ; $188 = HEAP32 [ $187 >> 2 ] | 0 ; $189 = $184 ^ $188 ; $6 = $189 ; $190 = $7 ; $191 = ( ( ( $190 ) ) + 4 | 0 ) ; $7 = $191 ; $192 = HEAP32 [ $190 >> 2 ] | 0 ; $193 = $6 ; $194 = $193 ^ $192 ; $6 = $194 ; $195 = $6 ; $196 = $195 & 255 ; $197 = ( ( 3564 ) + ( $196 << 2 ) | 0 ) ; $198 = HEAP32 [ $197 >> 2 ] | 0 ; $199 = $6 ; $200 = $199 >>> 8 ; $201 = $200 & 255 ; $202 = ( ( 2540 ) + ( $201 << 2 ) | 0 ) ; $203 = HEAP32 [ $202 >> 2 ] | 0 ; $204 = $198 ^ $203 ; $205 = $6 ; $206 = $205 >>> 16 ; $207 = $206 & 255 ; $208 = ( ( 1516 ) + ( $207 << 2 ) | 0 ) ; $209 = HEAP32 [ $208 >> 2 ] | 0 ; $210 = $204 ^ $209 ; $211 = $6 ; $212 = $211 >>> 24 ; $213 = ( 492 + ( $212 << 2 ) | 0 ) ; $214 = HEAP32 [ $213 >> 2 ] | 0 ; $215 = $210 ^ $214 ; $6 = $215 ; $216 = $7 ; $217 = ( ( ( $216 ) ) + 4 | 0 ) ; $7 = $217 ; $218 = HEAP32 [ $216 >> 2 ] | 0 ; $219 = $6 ; $220 = $219 ^ $218 ; $6 = $220 ; $221 = $6 ; $222 = $221 & 255 ; $223 = ( ( 3564 ) + ( $222 << 2 ) | 0 ) ; $224 = HEAP32 [ $223 >> 2 ] | 0 ; $225 = $6 ; $226 = $225 >>> 8 ; $227 = $226 & 255 ; $228 = ( ( 2540 ) + ( $227 << 2 ) | 0 ) ; $229 = HEAP32 [ $228 >> 2 ] | 0 ; $230 = $224 ^ $229 ; $231 = $6 ; $232 = $231 >>> 16 ; $233 = $232 & 255 ; $234 = ( ( 1516 ) + ( $233 << 2 ) | 0 ) ; $235 = HEAP32 [ $234 >> 2 ] | 0 ; $236 = $230 ^ $235 ; $237 = $6 ; $238 = $237 >>> 24 ; $239 = ( 492 + ( $238 << 2 ) | 0 ) ; $240 = HEAP32 [ $239 >> 2 ] | 0 ; $241 = $236 ^ $240 ; $6 = $241 ; $242 = $5 ; $243 = ( ( $242 ) - 32 ) | 0 ; $5 = $243 ; } while ( 1 ) { $244 = $5 ; $245 = ( $244 >>> 0 ) >= ( 4 ) ; $246 = $7 ; if ( ! ( $245 ) ) { break ; } $247 = ( ( ( $246 ) ) + 4 | 0 ) ; $7 = $247 ; $248 = HEAP32 [ $246 >> 2 ] | 0 ; $249 = $6 ; $250 = $249 ^ $248 ; $6 = $250 ; $251 = $6 ; $252 = $251 & 255 ; $253 = ( ( 3564 ) + ( $252 << 2 ) | 0 ) ; $254 = HEAP32 [ $253 >> 2 ] | 0 ; $255 = $6 ; $256 = $255 >>> 8 ; $257 = $256 & 255 ; $258 = ( ( 2540 ) + ( $257 << 2 ) | 0 ) ; $259 = HEAP32 [ $258 >> 2 ] | 0 ; $260 = $254 ^ $259 ; $261 = $6 ; $262 = $261 >>> 16 ; $263 = $262 & 255 ; $264 = ( ( 1516 ) + ( $263 << 2 ) | 0 ) ; $265 = HEAP32 [ $264 >> 2 ] | 0 ; $266 = $260 ^ $265 ; $267 = $6 ; $268 = $267 >>> 24 ; $269 = ( 492 + ( $268 << 2 ) | 0 ) ; $270 = HEAP32 [ $269 >> 2 ] | 0 ; $271 = $266 ^ $270 ; $6 = $271 ; $272 = $5 ; $273 = ( ( $272 ) - 4 ) | 0 ; $5 = $273 ; } $4 = $246 ; $274 = $5 ; $275 = ( $274 | 0 ) != ( 0 ) ; if ( ! ( $275 ) ) { $291 = $6 ; $292 = $291 ^ - 1 ; $6 = $292 ; $293 = $6 ; STACKTOP = sp ; return ( $293 | 0 ) ; } while ( 1 ) { $276 = $6 ; $277 = $4 ; $278 = ( ( ( $277 ) ) + 1 | 0 ) ; $4 = $278 ; $279 = HEAP8 [ $277 >> 0 ] | 0 ; $280 = $279 & 255 ; $281 = $276 ^ $280 ; $282 = $281 & 255 ; $283 = ( 492 + ( $282 << 2 ) | 0 ) ; $284 = HEAP32 [ $283 >> 2 ] | 0 ; $285 = $6 ; $286 = $285 >>> 8 ; $287 = $284 ^ $286 ; $6 = $287 ; $288 = $5 ; $289 = ( ( $288 ) + - 1 ) | 0 ; $5 = $289 ; $290 = ( $289 | 0 ) != ( 0 ) ; if ( ! ( $290 ) ) { break ; } } $291 = $6 ; $292 = $291 ^ - 1 ; $6 = $292 ; $293 = $6 ; STACKTOP = sp ; return ( $293 | 0 ) ; } function _crc32_big ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 ; var $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 ; var $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 ; var $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 ; var $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 , $208 = 0 ; var $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 , $226 = 0 ; var $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 , $244 = 0 ; var $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 , $258 = 0 , $259 = 0 , $26 = 0 , $260 = 0 , $261 = 0 , $262 = 0 ; var $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 , $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 , $270 = 0 , $271 = 0 , $272 = 0 , $273 = 0 , $274 = 0 , $275 = 0 , $276 = 0 , $277 = 0 , $278 = 0 , $279 = 0 , $28 = 0 , $280 = 0 ; var $281 = 0 , $282 = 0 , $283 = 0 , $284 = 0 , $285 = 0 , $286 = 0 , $287 = 0 , $288 = 0 , $289 = 0 , $29 = 0 , $290 = 0 , $291 = 0 , $292 = 0 , $293 = 0 , $294 = 0 , $295 = 0 , $296 = 0 , $297 = 0 , $298 = 0 , $299 = 0 ; var $3 = 0 , $30 = 0 , $300 = 0 , $301 = 0 , $302 = 0 , $303 = 0 , $304 = 0 , $305 = 0 , $306 = 0 , $307 = 0 , $308 = 0 , $309 = 0 , $31 = 0 , $310 = 0 , $311 = 0 , $312 = 0 , $313 = 0 , $314 = 0 , $315 = 0 , $316 = 0 ; var $317 = 0 , $318 = 0 , $319 = 0 , $32 = 0 , $320 = 0 , $321 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 ; var $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 ; var $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 ; var $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , label = 0 ; var sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $3 = $0 ; $4 = $1 ; $5 = $2 ; $8 = $3 ; $9 = $8 >>> 24 ; $10 = $9 & 255 ; $11 = $3 ; $12 = $11 >>> 8 ; $13 = $12 & 65280 ; $14 = ( ( $10 ) + ( $13 ) ) | 0 ; $15 = $3 ; $16 = $15 & 65280 ; $17 = $16 << 8 ; $18 = ( ( $14 ) + ( $17 ) ) | 0 ; $19 = $3 ; $20 = $19 & 255 ; $21 = $20 << 24 ; $22 = ( ( $18 ) + ( $21 ) ) | 0 ; $6 = $22 ; $23 = $6 ; $24 = $23 ^ - 1 ; $6 = $24 ; while ( 1 ) { $25 = $5 ; $26 = ( $25 | 0 ) != ( 0 ) ; if ( ! ( $26 ) ) { break ; } $27 = $4 ; $28 = $27 ; $29 = $28 & 3 ; $30 = ( $29 | 0 ) != ( 0 ) ; if ( ! ( $30 ) ) { break ; } $31 = $6 ; $32 = $31 >>> 24 ; $33 = $4 ; $34 = ( ( ( $33 ) ) + 1 | 0 ) ; $4 = $34 ; $35 = HEAP8 [ $33 >> 0 ] | 0 ; $36 = $35 & 255 ; $37 = $32 ^ $36 ; $38 = ( ( 4588 ) + ( $37 << 2 ) | 0 ) ; $39 = HEAP32 [ $38 >> 2 ] | 0 ; $40 = $6 ; $41 = $40 << 8 ; $42 = $39 ^ $41 ; $6 = $42 ; $43 = $5 ; $44 = ( ( $43 ) + - 1 ) | 0 ; $5 = $44 ; } $45 = $4 ; $7 = $45 ; while ( 1 ) { $46 = $5 ; $47 = ( $46 >>> 0 ) >= ( 32 ) ; if ( ! ( $47 ) ) { break ; } $48 = $7 ; $49 = ( ( ( $48 ) ) + 4 | 0 ) ; $7 = $49 ; $50 = HEAP32 [ $48 >> 2 ] | 0 ; $51 = $6 ; $52 = $51 ^ $50 ; $6 = $52 ; $53 = $6 ; $54 = $53 & 255 ; $55 = ( ( 4588 ) + ( $54 << 2 ) | 0 ) ; $56 = HEAP32 [ $55 >> 2 ] | 0 ; $57 = $6 ; $58 = $57 >>> 8 ; $59 = $58 & 255 ; $60 = ( ( 5612 ) + ( $59 << 2 ) | 0 ) ; $61 = HEAP32 [ $60 >> 2 ] | 0 ; $62 = $56 ^ $61 ; $63 = $6 ; $64 = $63 >>> 16 ; $65 = $64 & 255 ; $66 = ( ( 6636 ) + ( $65 << 2 ) | 0 ) ; $67 = HEAP32 [ $66 >> 2 ] | 0 ; $68 = $62 ^ $67 ; $69 = $6 ; $70 = $69 >>> 24 ; $71 = ( ( 7660 ) + ( $70 << 2 ) | 0 ) ; $72 = HEAP32 [ $71 >> 2 ] | 0 ; $73 = $68 ^ $72 ; $6 = $73 ; $74 = $7 ; $75 = ( ( ( $74 ) ) + 4 | 0 ) ; $7 = $75 ; $76 = HEAP32 [ $74 >> 2 ] | 0 ; $77 = $6 ; $78 = $77 ^ $76 ; $6 = $78 ; $79 = $6 ; $80 = $79 & 255 ; $81 = ( ( 4588 ) + ( $80 << 2 ) | 0 ) ; $82 = HEAP32 [ $81 >> 2 ] | 0 ; $83 = $6 ; $84 = $83 >>> 8 ; $85 = $84 & 255 ; $86 = ( ( 5612 ) + ( $85 << 2 ) | 0 ) ; $87 = HEAP32 [ $86 >> 2 ] | 0 ; $88 = $82 ^ $87 ; $89 = $6 ; $90 = $89 >>> 16 ; $91 = $90 & 255 ; $92 = ( ( 6636 ) + ( $91 << 2 ) | 0 ) ; $93 = HEAP32 [ $92 >> 2 ] | 0 ; $94 = $88 ^ $93 ; $95 = $6 ; $96 = $95 >>> 24 ; $97 = ( ( 7660 ) + ( $96 << 2 ) | 0 ) ; $98 = HEAP32 [ $97 >> 2 ] | 0 ; $99 = $94 ^ $98 ; $6 = $99 ; $100 = $7 ; $101 = ( ( ( $100 ) ) + 4 | 0 ) ; $7 = $101 ; $102 = HEAP32 [ $100 >> 2 ] | 0 ; $103 = $6 ; $104 = $103 ^ $102 ; $6 = $104 ; $105 = $6 ; $106 = $105 & 255 ; $107 = ( ( 4588 ) + ( $106 << 2 ) | 0 ) ; $108 = HEAP32 [ $107 >> 2 ] | 0 ; $109 = $6 ; $110 = $109 >>> 8 ; $111 = $110 & 255 ; $112 = ( ( 5612 ) + ( $111 << 2 ) | 0 ) ; $113 = HEAP32 [ $112 >> 2 ] | 0 ; $114 = $108 ^ $113 ; $115 = $6 ; $116 = $115 >>> 16 ; $117 = $116 & 255 ; $118 = ( ( 6636 ) + ( $117 << 2 ) | 0 ) ; $119 = HEAP32 [ $118 >> 2 ] | 0 ; $120 = $114 ^ $119 ; $121 = $6 ; $122 = $121 >>> 24 ; $123 = ( ( 7660 ) + ( $122 << 2 ) | 0 ) ; $124 = HEAP32 [ $123 >> 2 ] | 0 ; $125 = $120 ^ $124 ; $6 = $125 ; $126 = $7 ; $127 = ( ( ( $126 ) ) + 4 | 0 ) ; $7 = $127 ; $128 = HEAP32 [ $126 >> 2 ] | 0 ; $129 = $6 ; $130 = $129 ^ $128 ; $6 = $130 ; $131 = $6 ; $132 = $131 & 255 ; $133 = ( ( 4588 ) + ( $132 << 2 ) | 0 ) ; $134 = HEAP32 [ $133 >> 2 ] | 0 ; $135 = $6 ; $136 = $135 >>> 8 ; $137 = $136 & 255 ; $138 = ( ( 5612 ) + ( $137 << 2 ) | 0 ) ; $139 = HEAP32 [ $138 >> 2 ] | 0 ; $140 = $134 ^ $139 ; $141 = $6 ; $142 = $141 >>> 16 ; $143 = $142 & 255 ; $144 = ( ( 6636 ) + ( $143 << 2 ) | 0 ) ; $145 = HEAP32 [ $144 >> 2 ] | 0 ; $146 = $140 ^ $145 ; $147 = $6 ; $148 = $147 >>> 24 ; $149 = ( ( 7660 ) + ( $148 << 2 ) | 0 ) ; $150 = HEAP32 [ $149 >> 2 ] | 0 ; $151 = $146 ^ $150 ; $6 = $151 ; $152 = $7 ; $153 = ( ( ( $152 ) ) + 4 | 0 ) ; $7 = $153 ; $154 = HEAP32 [ $152 >> 2 ] | 0 ; $155 = $6 ; $156 = $155 ^ $154 ; $6 = $156 ; $157 = $6 ; $158 = $157 & 255 ; $159 = ( ( 4588 ) + ( $158 << 2 ) | 0 ) ; $160 = HEAP32 [ $159 >> 2 ] | 0 ; $161 = $6 ; $162 = $161 >>> 8 ; $163 = $162 & 255 ; $164 = ( ( 5612 ) + ( $163 << 2 ) | 0 ) ; $165 = HEAP32 [ $164 >> 2 ] | 0 ; $166 = $160 ^ $165 ; $167 = $6 ; $168 = $167 >>> 16 ; $169 = $168 & 255 ; $170 = ( ( 6636 ) + ( $169 << 2 ) | 0 ) ; $171 = HEAP32 [ $170 >> 2 ] | 0 ; $172 = $166 ^ $171 ; $173 = $6 ; $174 = $173 >>> 24 ; $175 = ( ( 7660 ) + ( $174 << 2 ) | 0 ) ; $176 = HEAP32 [ $175 >> 2 ] | 0 ; $177 = $172 ^ $176 ; $6 = $177 ; $178 = $7 ; $179 = ( ( ( $178 ) ) + 4 | 0 ) ; $7 = $179 ; $180 = HEAP32 [ $178 >> 2 ] | 0 ; $181 = $6 ; $182 = $181 ^ $180 ; $6 = $182 ; $183 = $6 ; $184 = $183 & 255 ; $185 = ( ( 4588 ) + ( $184 << 2 ) | 0 ) ; $186 = HEAP32 [ $185 >> 2 ] | 0 ; $187 = $6 ; $188 = $187 >>> 8 ; $189 = $188 & 255 ; $190 = ( ( 5612 ) + ( $189 << 2 ) | 0 ) ; $191 = HEAP32 [ $190 >> 2 ] | 0 ; $192 = $186 ^ $191 ; $193 = $6 ; $194 = $193 >>> 16 ; $195 = $194 & 255 ; $196 = ( ( 6636 ) + ( $195 << 2 ) | 0 ) ; $197 = HEAP32 [ $196 >> 2 ] | 0 ; $198 = $192 ^ $197 ; $199 = $6 ; $200 = $199 >>> 24 ; $201 = ( ( 7660 ) + ( $200 << 2 ) | 0 ) ; $202 = HEAP32 [ $201 >> 2 ] | 0 ; $203 = $198 ^ $202 ; $6 = $203 ; $204 = $7 ; $205 = ( ( ( $204 ) ) + 4 | 0 ) ; $7 = $205 ; $206 = HEAP32 [ $204 >> 2 ] | 0 ; $207 = $6 ; $208 = $207 ^ $206 ; $6 = $208 ; $209 = $6 ; $210 = $209 & 255 ; $211 = ( ( 4588 ) + ( $210 << 2 ) | 0 ) ; $212 = HEAP32 [ $211 >> 2 ] | 0 ; $213 = $6 ; $214 = $213 >>> 8 ; $215 = $214 & 255 ; $216 = ( ( 5612 ) + ( $215 << 2 ) | 0 ) ; $217 = HEAP32 [ $216 >> 2 ] | 0 ; $218 = $212 ^ $217 ; $219 = $6 ; $220 = $219 >>> 16 ; $221 = $220 & 255 ; $222 = ( ( 6636 ) + ( $221 << 2 ) | 0 ) ; $223 = HEAP32 [ $222 >> 2 ] | 0 ; $224 = $218 ^ $223 ; $225 = $6 ; $226 = $225 >>> 24 ; $227 = ( ( 7660 ) + ( $226 << 2 ) | 0 ) ; $228 = HEAP32 [ $227 >> 2 ] | 0 ; $229 = $224 ^ $228 ; $6 = $229 ; $230 = $7 ; $231 = ( ( ( $230 ) ) + 4 | 0 ) ; $7 = $231 ; $232 = HEAP32 [ $230 >> 2 ] | 0 ; $233 = $6 ; $234 = $233 ^ $232 ; $6 = $234 ; $235 = $6 ; $236 = $235 & 255 ; $237 = ( ( 4588 ) + ( $236 << 2 ) | 0 ) ; $238 = HEAP32 [ $237 >> 2 ] | 0 ; $239 = $6 ; $240 = $239 >>> 8 ; $241 = $240 & 255 ; $242 = ( ( 5612 ) + ( $241 << 2 ) | 0 ) ; $243 = HEAP32 [ $242 >> 2 ] | 0 ; $244 = $238 ^ $243 ; $245 = $6 ; $246 = $245 >>> 16 ; $247 = $246 & 255 ; $248 = ( ( 6636 ) + ( $247 << 2 ) | 0 ) ; $249 = HEAP32 [ $248 >> 2 ] | 0 ; $250 = $244 ^ $249 ; $251 = $6 ; $252 = $251 >>> 24 ; $253 = ( ( 7660 ) + ( $252 << 2 ) | 0 ) ; $254 = HEAP32 [ $253 >> 2 ] | 0 ; $255 = $250 ^ $254 ; $6 = $255 ; $256 = $5 ; $257 = ( ( $256 ) - 32 ) | 0 ; $5 = $257 ; } while ( 1 ) { $258 = $5 ; $259 = ( $258 >>> 0 ) >= ( 4 ) ; $260 = $7 ; if ( ! ( $259 ) ) { break ; } $261 = ( ( ( $260 ) ) + 4 | 0 ) ; $7 = $261 ; $262 = HEAP32 [ $260 >> 2 ] | 0 ; $263 = $6 ; $264 = $263 ^ $262 ; $6 = $264 ; $265 = $6 ; $266 = $265 & 255 ; $267 = ( ( 4588 ) + ( $266 << 2 ) | 0 ) ; $268 = HEAP32 [ $267 >> 2 ] | 0 ; $269 = $6 ; $270 = $269 >>> 8 ; $271 = $270 & 255 ; $272 = ( ( 5612 ) + ( $271 << 2 ) | 0 ) ; $273 = HEAP32 [ $272 >> 2 ] | 0 ; $274 = $268 ^ $273 ; $275 = $6 ; $276 = $275 >>> 16 ; $277 = $276 & 255 ; $278 = ( ( 6636 ) + ( $277 << 2 ) | 0 ) ; $279 = HEAP32 [ $278 >> 2 ] | 0 ; $280 = $274 ^ $279 ; $281 = $6 ; $282 = $281 >>> 24 ; $283 = ( ( 7660 ) + ( $282 << 2 ) | 0 ) ; $284 = HEAP32 [ $283 >> 2 ] | 0 ; $285 = $280 ^ $284 ; $6 = $285 ; $286 = $5 ; $287 = ( ( $286 ) - 4 ) | 0 ; $5 = $287 ; } $4 = $260 ; $288 = $5 ; $289 = ( $288 | 0 ) != ( 0 ) ; if ( ! ( $289 ) ) { $305 = $6 ; $306 = $305 ^ - 1 ; $6 = $306 ; $307 = $6 ; $308 = $307 >>> 24 ; $309 = $308 & 255 ; $310 = $6 ; $311 = $310 >>> 8 ; $312 = $311 & 65280 ; $313 = ( ( $309 ) + ( $312 ) ) | 0 ; $314 = $6 ; $315 = $314 & 65280 ; $316 = $315 << 8 ; $317 = ( ( $313 ) + ( $316 ) ) | 0 ; $318 = $6 ; $319 = $318 & 255 ; $320 = $319 << 24 ; $321 = ( ( $317 ) + ( $320 ) ) | 0 ; STACKTOP = sp ; return ( $321 | 0 ) ; } while ( 1 ) { $290 = $6 ; $291 = $290 >>> 24 ; $292 = $4 ; $293 = ( ( ( $292 ) ) + 1 | 0 ) ; $4 = $293 ; $294 = HEAP8 [ $292 >> 0 ] | 0 ; $295 = $294 & 255 ; $296 = $291 ^ $295 ; $297 = ( ( 4588 ) + ( $296 << 2 ) | 0 ) ; $298 = HEAP32 [ $297 >> 2 ] | 0 ; $299 = $6 ; $300 = $299 << 8 ; $301 = $298 ^ $300 ; $6 = $301 ; $302 = $5 ; $303 = ( ( $302 ) + - 1 ) | 0 ; $5 = $303 ; $304 = ( $303 | 0 ) != ( 0 ) ; if ( ! ( $304 ) ) { break ; } } $305 = $6 ; $306 = $305 ^ - 1 ; $6 = $306 ; $307 = $6 ; $308 = $307 >>> 24 ; $309 = $308 & 255 ; $310 = $6 ; $311 = $310 >>> 8 ; $312 = $311 & 65280 ; $313 = ( ( $309 ) + ( $312 ) ) | 0 ; $314 = $6 ; $315 = $314 & 65280 ; $316 = $315 << 8 ; $317 = ( ( $313 ) + ( $316 ) ) | 0 ; $318 = $6 ; $319 = $318 & 255 ; $320 = $319 << 24 ; $321 = ( ( $317 ) + ( $320 ) ) | 0 ; STACKTOP = sp ; return ( $321 | 0 ) ; } function _crc32 ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $3 = $0 ; $4 = $1 ; $5 = $2 ; $6 = $3 ; $7 = $4 ; $8 = $5 ; $9 = ( _crc32_z ( $6 , $7 , $8 ) | 0 ) ; STACKTOP = sp ; return ( $9 | 0 ) ; } function _deflateInit2_ ( $0 , $1 , $2 , $3 , $4 , $5 , $6 , $7 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; $4 = $4 | 0 ; $5 = $5 | 0 ; $6 = $6 | 0 ; $7 = $7 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 ; var $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 ; var $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 ; var $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 ; var $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 , $208 = 0 ; var $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 , $226 = 0 ; var $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 , $244 = 0 ; var $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 ; var $37 = 0 , $38 = 0 , $39 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 ; var $57 = 0 , $58 = 0 , $59 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 ; var $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 ; var $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $or$cond = 0 , $or$cond11 = 0 , $or$cond13 = 0 , $or$cond15 = 0 , $or$cond17 = 0 , $or$cond19 = 0 , $or$cond3 = 0 , $or$cond5 = 0 , $or$cond7 = 0 , $or$cond9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 48 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 48 | 0 ) ; $9 = $0 ; $10 = $1 ; $11 = $2 ; $12 = $3 ; $13 = $4 ; $14 = $5 ; $15 = $6 ; $16 = $7 ; $18 = 1 ; $20 = $15 ; $21 = ( $20 | 0 ) == ( 0 | 0 ) ; if ( ! ( $21 ) ) { $22 = $15 ; $23 = HEAP8 [ $22 >> 0 ] | 0 ; $24 = $23 << 24 >> 24 ; $25 = HEAP8 [ 29663 ] | 0 ; $26 = $25 << 24 >> 24 ; $27 = ( $24 | 0 ) != ( $26 | 0 ) ; $28 = $16 ; $29 = ( $28 | 0 ) != ( 56 ) ; $or$cond = $27 | $29 ; if ( ! ( $or$cond ) ) { $30 = $9 ; $31 = ( $30 | 0 ) == ( 0 | 0 ) ; if ( $31 ) { $8 = - 2 ; $252 = $8 ; STACKTOP = sp ; return ( $252 | 0 ) ; } $32 = $9 ; $33 = ( ( ( $32 ) ) + 24 | 0 ) ; HEAP32 [ $33 >> 2 ] = 0 ; $34 = $9 ; $35 = ( ( ( $34 ) ) + 32 | 0 ) ; $36 = HEAP32 [ $35 >> 2 ] | 0 ; $37 = ( $36 | 0 ) == ( 0 | 0 ) ; if ( $37 ) { $38 = $9 ; $39 = ( ( ( $38 ) ) + 32 | 0 ) ; HEAP32 [ $39 >> 2 ] = 102 ; $40 = $9 ; $41 = ( ( ( $40 ) ) + 40 | 0 ) ; HEAP32 [ $41 >> 2 ] = 0 ; } $42 = $9 ; $43 = ( ( ( $42 ) ) + 36 | 0 ) ; $44 = HEAP32 [ $43 >> 2 ] | 0 ; $45 = ( $44 | 0 ) == ( 0 | 0 ) ; if ( $45 ) { $46 = $9 ; $47 = ( ( ( $46 ) ) + 36 | 0 ) ; HEAP32 [ $47 >> 2 ] = 103 ; } $48 = $10 ; $49 = ( $48 | 0 ) == ( - 1 ) ; if ( $49 ) { $10 = 6 ; } $50 = $12 ; $51 = ( $50 | 0 ) < ( 0 ) ; if ( $51 ) { $18 = 0 ; $52 = $12 ; $53 = ( 0 - ( $52 ) ) | 0 ; $12 = $53 ; } $54 = $13 ; $55 = ( $54 | 0 ) < ( 1 ) ; $56 = $13 ; $57 = ( $56 | 0 ) > ( 9 ) ; $or$cond3 = $55 | $57 ; $58 = $11 ; $59 = ( $58 | 0 ) != ( 8 ) ; $or$cond5 = $or$cond3 | $59 ; $60 = $12 ; $61 = ( $60 | 0 ) < ( 8 ) ; $or$cond7 = $or$cond5 | $61 ; $62 = $12 ; $63 = ( $62 | 0 ) > ( 15 ) ; $or$cond9 = $or$cond7 | $63 ; $64 = $10 ; $65 = ( $64 | 0 ) < ( 0 ) ; $or$cond11 = $or$cond9 | $65 ; $66 = $10 ; $67 = ( $66 | 0 ) > ( 9 ) ; $or$cond13 = $or$cond11 | $67 ; $68 = $14 ; $69 = ( $68 | 0 ) < ( 0 ) ; $or$cond15 = $or$cond13 | $69 ; $70 = $14 ; $71 = ( $70 | 0 ) > ( 4 ) ; $or$cond17 = $or$cond15 | $71 ; if ( ! ( $or$cond17 ) ) { $72 = $12 ; $73 = ( $72 | 0 ) == ( 8 ) ; $74 = $18 ; $75 = ( $74 | 0 ) != ( 1 ) ; $or$cond19 = $73 & $75 ; if ( ! ( $or$cond19 ) ) { $76 = $12 ; $77 = ( $76 | 0 ) == ( 8 ) ; if ( $77 ) { $12 = 9 ; } $78 = $9 ; $79 = ( ( ( $78 ) ) + 32 | 0 ) ; $80 = HEAP32 [ $79 >> 2 ] | 0 ; $81 = $9 ; $82 = ( ( ( $81 ) ) + 40 | 0 ) ; $83 = HEAP32 [ $82 >> 2 ] | 0 ; $84 = ( FUNCTION_TABLE_iiii [ $80 & 127 ] ( $83 , 1 , 5828 ) | 0 ) ; $17 = $84 ; $85 = $17 ; $86 = ( $85 | 0 ) == ( 0 | 0 ) ; if ( $86 ) { $8 = - 4 ; $252 = $8 ; STACKTOP = sp ; return ( $252 | 0 ) ; } $87 = $17 ; $88 = $9 ; $89 = ( ( ( $88 ) ) + 28 | 0 ) ; HEAP32 [ $89 >> 2 ] = $87 ; $90 = $9 ; $91 = $17 ; HEAP32 [ $91 >> 2 ] = $90 ; $92 = $17 ; $93 = ( ( ( $92 ) ) + 4 | 0 ) ; HEAP32 [ $93 >> 2 ] = 42 ; $94 = $18 ; $95 = $17 ; $96 = ( ( ( $95 ) ) + 24 | 0 ) ; HEAP32 [ $96 >> 2 ] = $94 ; $97 = $17 ; $98 = ( ( ( $97 ) ) + 28 | 0 ) ; HEAP32 [ $98 >> 2 ] = 0 ; $99 = $12 ; $100 = $17 ; $101 = ( ( ( $100 ) ) + 48 | 0 ) ; HEAP32 [ $101 >> 2 ] = $99 ; $102 = $17 ; $103 = ( ( ( $102 ) ) + 48 | 0 ) ; $104 = HEAP32 [ $103 >> 2 ] | 0 ; $105 = 1 << $104 ; $106 = $17 ; $107 = ( ( ( $106 ) ) + 44 | 0 ) ; HEAP32 [ $107 >> 2 ] = $105 ; $108 = $17 ; $109 = ( ( ( $108 ) ) + 44 | 0 ) ; $110 = HEAP32 [ $109 >> 2 ] | 0 ; $111 = ( ( $110 ) - 1 ) | 0 ; $112 = $17 ; $113 = ( ( ( $112 ) ) + 52 | 0 ) ; HEAP32 [ $113 >> 2 ] = $111 ; $114 = $13 ; $115 = ( ( $114 ) + 7 ) | 0 ; $116 = $17 ; $117 = ( ( ( $116 ) ) + 80 | 0 ) ; HEAP32 [ $117 >> 2 ] = $115 ; $118 = $17 ; $119 = ( ( ( $118 ) ) + 80 | 0 ) ; $120 = HEAP32 [ $119 >> 2 ] | 0 ; $121 = 1 << $120 ; $122 = $17 ; $123 = ( ( ( $122 ) ) + 76 | 0 ) ; HEAP32 [ $123 >> 2 ] = $121 ; $124 = $17 ; $125 = ( ( ( $124 ) ) + 76 | 0 ) ; $126 = HEAP32 [ $125 >> 2 ] | 0 ; $127 = ( ( $126 ) - 1 ) | 0 ; $128 = $17 ; $129 = ( ( ( $128 ) ) + 84 | 0 ) ; HEAP32 [ $129 >> 2 ] = $127 ; $130 = $17 ; $131 = ( ( ( $130 ) ) + 80 | 0 ) ; $132 = HEAP32 [ $131 >> 2 ] | 0 ; $133 = ( ( $132 ) + 3 ) | 0 ; $134 = ( ( $133 ) - 1 ) | 0 ; $135 = ( ( $134 >>> 0 ) / 3 ) & - 1 ; $136 = $17 ; $137 = ( ( ( $136 ) ) + 88 | 0 ) ; HEAP32 [ $137 >> 2 ] = $135 ; $138 = $9 ; $139 = ( ( ( $138 ) ) + 32 | 0 ) ; $140 = HEAP32 [ $139 >> 2 ] | 0 ; $141 = $9 ; $142 = ( ( ( $141 ) ) + 40 | 0 ) ; $143 = HEAP32 [ $142 >> 2 ] | 0 ; $144 = $17 ; $145 = ( ( ( $144 ) ) + 44 | 0 ) ; $146 = HEAP32 [ $145 >> 2 ] | 0 ; $147 = ( FUNCTION_TABLE_iiii [ $140 & 127 ] ( $143 , $146 , 2 ) | 0 ) ; $148 = $17 ; $149 = ( ( ( $148 ) ) + 56 | 0 ) ; HEAP32 [ $149 >> 2 ] = $147 ; $150 = $9 ; $151 = ( ( ( $150 ) ) + 32 | 0 ) ; $152 = HEAP32 [ $151 >> 2 ] | 0 ; $153 = $9 ; $154 = ( ( ( $153 ) ) + 40 | 0 ) ; $155 = HEAP32 [ $154 >> 2 ] | 0 ; $156 = $17 ; $157 = ( ( ( $156 ) ) + 44 | 0 ) ; $158 = HEAP32 [ $157 >> 2 ] | 0 ; $159 = ( FUNCTION_TABLE_iiii [ $152 & 127 ] ( $155 , $158 , 2 ) | 0 ) ; $160 = $17 ; $161 = ( ( ( $160 ) ) + 64 | 0 ) ; HEAP32 [ $161 >> 2 ] = $159 ; $162 = $9 ; $163 = ( ( ( $162 ) ) + 32 | 0 ) ; $164 = HEAP32 [ $163 >> 2 ] | 0 ; $165 = $9 ; $166 = ( ( ( $165 ) ) + 40 | 0 ) ; $167 = HEAP32 [ $166 >> 2 ] | 0 ; $168 = $17 ; $169 = ( ( ( $168 ) ) + 76 | 0 ) ; $170 = HEAP32 [ $169 >> 2 ] | 0 ; $171 = ( FUNCTION_TABLE_iiii [ $164 & 127 ] ( $167 , $170 , 2 ) | 0 ) ; $172 = $17 ; $173 = ( ( ( $172 ) ) + 68 | 0 ) ; HEAP32 [ $173 >> 2 ] = $171 ; $174 = $17 ; $175 = ( ( ( $174 ) ) + 5824 | 0 ) ; HEAP32 [ $175 >> 2 ] = 0 ; $176 = $13 ; $177 = ( ( $176 ) + 6 ) | 0 ; $178 = 1 << $177 ; $179 = $17 ; $180 = ( ( ( $179 ) ) + 5788 | 0 ) ; HEAP32 [ $180 >> 2 ] = $178 ; $181 = $9 ; $182 = ( ( ( $181 ) ) + 32 | 0 ) ; $183 = HEAP32 [ $182 >> 2 ] | 0 ; $184 = $9 ; $185 = ( ( ( $184 ) ) + 40 | 0 ) ; $186 = HEAP32 [ $185 >> 2 ] | 0 ; $187 = $17 ; $188 = ( ( ( $187 ) ) + 5788 | 0 ) ; $189 = HEAP32 [ $188 >> 2 ] | 0 ; $190 = ( FUNCTION_TABLE_iiii [ $183 & 127 ] ( $186 , $189 , 4 ) | 0 ) ; $19 = $190 ; $191 = $19 ; $192 = $17 ; $193 = ( ( ( $192 ) ) + 8 | 0 ) ; HEAP32 [ $193 >> 2 ] = $191 ; $194 = $17 ; $195 = ( ( ( $194 ) ) + 5788 | 0 ) ; $196 = HEAP32 [ $195 >> 2 ] | 0 ; $197 = $196 << 2 ; $198 = $17 ; $199 = ( ( ( $198 ) ) + 12 | 0 ) ; HEAP32 [ $199 >> 2 ] = $197 ; $200 = $17 ; $201 = ( ( ( $200 ) ) + 56 | 0 ) ; $202 = HEAP32 [ $201 >> 2 ] | 0 ; $203 = ( $202 | 0 ) == ( 0 | 0 ) ; if ( ! ( $203 ) ) { $204 = $17 ; $205 = ( ( ( $204 ) ) + 64 | 0 ) ; $206 = HEAP32 [ $205 >> 2 ] | 0 ; $207 = ( $206 | 0 ) == ( 0 | 0 ) ; if ( ! ( $207 ) ) { $208 = $17 ; $209 = ( ( ( $208 ) ) + 68 | 0 ) ; $210 = HEAP32 [ $209 >> 2 ] | 0 ; $211 = ( $210 | 0 ) == ( 0 | 0 ) ; if ( ! ( $211 ) ) { $212 = $17 ; $213 = ( ( ( $212 ) ) + 8 | 0 ) ; $214 = HEAP32 [ $213 >> 2 ] | 0 ; $215 = ( $214 | 0 ) == ( 0 | 0 ) ; if ( ! ( $215 ) ) { $222 = $19 ; $223 = $17 ; $224 = ( ( ( $223 ) ) + 5788 | 0 ) ; $225 = HEAP32 [ $224 >> 2 ] | 0 ; $226 = ( ( $225 >>> 0 ) / 2 ) & - 1 ; $227 = ( ( $222 ) + ( $226 << 1 ) | 0 ) ; $228 = $17 ; $229 = ( ( ( $228 ) ) + 5796 | 0 ) ; HEAP32 [ $229 >> 2 ] = $227 ; $230 = $17 ; $231 = ( ( ( $230 ) ) + 8 | 0 ) ; $232 = HEAP32 [ $231 >> 2 ] | 0 ; $233 = $17 ; $234 = ( ( ( $233 ) ) + 5788 | 0 ) ; $235 = HEAP32 [ $234 >> 2 ] | 0 ; $236 = ( $235 * 3 ) | 0 ; $237 = ( ( $232 ) + ( $236 ) | 0 ) ; $238 = $17 ; $239 = ( ( ( $238 ) ) + 5784 | 0 ) ; HEAP32 [ $239 >> 2 ] = $237 ; $240 = $10 ; $241 = $17 ; $242 = ( ( ( $241 ) ) + 132 | 0 ) ; HEAP32 [ $242 >> 2 ] = $240 ; $243 = $14 ; $244 = $17 ; $245 = ( ( ( $244 ) ) + 136 | 0 ) ; HEAP32 [ $245 >> 2 ] = $243 ; $246 = $11 ; $247 = $246 & 255 ; $248 = $17 ; $249 = ( ( ( $248 ) ) + 36 | 0 ) ; HEAP8 [ $249 >> 0 ] = $247 ; $250 = $9 ; $251 = ( _deflateReset ( $250 ) | 0 ) ; $8 = $251 ; $252 = $8 ; STACKTOP = sp ; return ( $252 | 0 ) ; } } } } $216 = $17 ; $217 = ( ( ( $216 ) ) + 4 | 0 ) ; HEAP32 [ $217 >> 2 ] = 666 ; $218 = HEAP32 [ ( 9436 ) >> 2 ] | 0 ; $219 = $9 ; $220 = ( ( ( $219 ) ) + 24 | 0 ) ; HEAP32 [ $220 >> 2 ] = $218 ; $221 = $9 ; ( _deflateEnd ( $221 ) | 0 ) ; $8 = - 4 ; $252 = $8 ; STACKTOP = sp ; return ( $252 | 0 ) ; } } $8 = - 2 ; $252 = $8 ; STACKTOP = sp ; return ( $252 | 0 ) ; } } $8 = - 6 ; $252 = $8 ; STACKTOP = sp ; return ( $252 | 0 ) ; } function _deflateEnd ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 ; var $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 ; var $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 ; var $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 ; var $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = $0 ; $4 = $2 ; $5 = ( _deflateStateCheck ( $4 ) | 0 ) ; $6 = ( $5 | 0 ) != ( 0 ) ; if ( $6 ) { $1 = - 2 ; $94 = $1 ; STACKTOP = sp ; return ( $94 | 0 ) ; } $7 = $2 ; $8 = ( ( ( $7 ) ) + 28 | 0 ) ; $9 = HEAP32 [ $8 >> 2 ] | 0 ; $10 = ( ( ( $9 ) ) + 4 | 0 ) ; $11 = HEAP32 [ $10 >> 2 ] | 0 ; $3 = $11 ; $12 = $2 ; $13 = ( ( ( $12 ) ) + 28 | 0 ) ; $14 = HEAP32 [ $13 >> 2 ] | 0 ; $15 = ( ( ( $14 ) ) + 8 | 0 ) ; $16 = HEAP32 [ $15 >> 2 ] | 0 ; $17 = ( $16 | 0 ) != ( 0 | 0 ) ; if ( $17 ) { $18 = $2 ; $19 = ( ( ( $18 ) ) + 36 | 0 ) ; $20 = HEAP32 [ $19 >> 2 ] | 0 ; $21 = $2 ; $22 = ( ( ( $21 ) ) + 40 | 0 ) ; $23 = HEAP32 [ $22 >> 2 ] | 0 ; $24 = $2 ; $25 = ( ( ( $24 ) ) + 28 | 0 ) ; $26 = HEAP32 [ $25 >> 2 ] | 0 ; $27 = ( ( ( $26 ) ) + 8 | 0 ) ; $28 = HEAP32 [ $27 >> 2 ] | 0 ; FUNCTION_TABLE_vii [ $20 & 127 ] ( $23 , $28 ) ; } $29 = $2 ; $30 = ( ( ( $29 ) ) + 28 | 0 ) ; $31 = HEAP32 [ $30 >> 2 ] | 0 ; $32 = ( ( ( $31 ) ) + 68 | 0 ) ; $33 = HEAP32 [ $32 >> 2 ] | 0 ; $34 = ( $33 | 0 ) != ( 0 | 0 ) ; if ( $34 ) { $35 = $2 ; $36 = ( ( ( $35 ) ) + 36 | 0 ) ; $37 = HEAP32 [ $36 >> 2 ] | 0 ; $38 = $2 ; $39 = ( ( ( $38 ) ) + 40 | 0 ) ; $40 = HEAP32 [ $39 >> 2 ] | 0 ; $41 = $2 ; $42 = ( ( ( $41 ) ) + 28 | 0 ) ; $43 = HEAP32 [ $42 >> 2 ] | 0 ; $44 = ( ( ( $43 ) ) + 68 | 0 ) ; $45 = HEAP32 [ $44 >> 2 ] | 0 ; FUNCTION_TABLE_vii [ $37 & 127 ] ( $40 , $45 ) ; } $46 = $2 ; $47 = ( ( ( $46 ) ) + 28 | 0 ) ; $48 = HEAP32 [ $47 >> 2 ] | 0 ; $49 = ( ( ( $48 ) ) + 64 | 0 ) ; $50 = HEAP32 [ $49 >> 2 ] | 0 ; $51 = ( $50 | 0 ) != ( 0 | 0 ) ; if ( $51 ) { $52 = $2 ; $53 = ( ( ( $52 ) ) + 36 | 0 ) ; $54 = HEAP32 [ $53 >> 2 ] | 0 ; $55 = $2 ; $56 = ( ( ( $55 ) ) + 40 | 0 ) ; $57 = HEAP32 [ $56 >> 2 ] | 0 ; $58 = $2 ; $59 = ( ( ( $58 ) ) + 28 | 0 ) ; $60 = HEAP32 [ $59 >> 2 ] | 0 ; $61 = ( ( ( $60 ) ) + 64 | 0 ) ; $62 = HEAP32 [ $61 >> 2 ] | 0 ; FUNCTION_TABLE_vii [ $54 & 127 ] ( $57 , $62 ) ; } $63 = $2 ; $64 = ( ( ( $63 ) ) + 28 | 0 ) ; $65 = HEAP32 [ $64 >> 2 ] | 0 ; $66 = ( ( ( $65 ) ) + 56 | 0 ) ; $67 = HEAP32 [ $66 >> 2 ] | 0 ; $68 = ( $67 | 0 ) != ( 0 | 0 ) ; if ( $68 ) { $69 = $2 ; $70 = ( ( ( $69 ) ) + 36 | 0 ) ; $71 = HEAP32 [ $70 >> 2 ] | 0 ; $72 = $2 ; $73 = ( ( ( $72 ) ) + 40 | 0 ) ; $74 = HEAP32 [ $73 >> 2 ] | 0 ; $75 = $2 ; $76 = ( ( ( $75 ) ) + 28 | 0 ) ; $77 = HEAP32 [ $76 >> 2 ] | 0 ; $78 = ( ( ( $77 ) ) + 56 | 0 ) ; $79 = HEAP32 [ $78 >> 2 ] | 0 ; FUNCTION_TABLE_vii [ $71 & 127 ] ( $74 , $79 ) ; } $80 = $2 ; $81 = ( ( ( $80 ) ) + 36 | 0 ) ; $82 = HEAP32 [ $81 >> 2 ] | 0 ; $83 = $2 ; $84 = ( ( ( $83 ) ) + 40 | 0 ) ; $85 = HEAP32 [ $84 >> 2 ] | 0 ; $86 = $2 ; $87 = ( ( ( $86 ) ) + 28 | 0 ) ; $88 = HEAP32 [ $87 >> 2 ] | 0 ; FUNCTION_TABLE_vii [ $82 & 127 ] ( $85 , $88 ) ; $89 = $2 ; $90 = ( ( ( $89 ) ) + 28 | 0 ) ; HEAP32 [ $90 >> 2 ] = 0 ; $91 = $3 ; $92 = ( $91 | 0 ) == ( 113 ) ; $93 = $92 ? - 3 : 0 ; $1 = $93 ; $94 = $1 ; STACKTOP = sp ; return ( $94 | 0 ) ; } function _deflateReset ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $3 = $1 ; $4 = ( _deflateResetKeep ( $3 ) | 0 ) ; $2 = $4 ; $5 = $2 ; $6 = ( $5 | 0 ) == ( 0 ) ; if ( $6 ) { $7 = $1 ; $8 = ( ( ( $7 ) ) + 28 | 0 ) ; $9 = HEAP32 [ $8 >> 2 ] | 0 ; _lm_init ( $9 ) ; } $10 = $2 ; STACKTOP = sp ; return ( $10 | 0 ) ; } function _deflateResetKeep ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 ; var $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 ; var $46 = 0 , $47 = 0 , $48 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = $0 ; $4 = $2 ; $5 = ( _deflateStateCheck ( $4 ) | 0 ) ; $6 = ( $5 | 0 ) != ( 0 ) ; if ( $6 ) { $1 = - 2 ; $48 = $1 ; STACKTOP = sp ; return ( $48 | 0 ) ; } $7 = $2 ; $8 = ( ( ( $7 ) ) + 20 | 0 ) ; HEAP32 [ $8 >> 2 ] = 0 ; $9 = $2 ; $10 = ( ( ( $9 ) ) + 8 | 0 ) ; HEAP32 [ $10 >> 2 ] = 0 ; $11 = $2 ; $12 = ( ( ( $11 ) ) + 24 | 0 ) ; HEAP32 [ $12 >> 2 ] = 0 ; $13 = $2 ; $14 = ( ( ( $13 ) ) + 44 | 0 ) ; HEAP32 [ $14 >> 2 ] = 2 ; $15 = $2 ; $16 = ( ( ( $15 ) ) + 28 | 0 ) ; $17 = HEAP32 [ $16 >> 2 ] | 0 ; $3 = $17 ; $18 = $3 ; $19 = ( ( ( $18 ) ) + 20 | 0 ) ; HEAP32 [ $19 >> 2 ] = 0 ; $20 = $3 ; $21 = ( ( ( $20 ) ) + 8 | 0 ) ; $22 = HEAP32 [ $21 >> 2 ] | 0 ; $23 = $3 ; $24 = ( ( ( $23 ) ) + 16 | 0 ) ; HEAP32 [ $24 >> 2 ] = $22 ; $25 = $3 ; $26 = ( ( ( $25 ) ) + 24 | 0 ) ; $27 = HEAP32 [ $26 >> 2 ] | 0 ; $28 = ( $27 | 0 ) < ( 0 ) ; if ( $28 ) { $29 = $3 ; $30 = ( ( ( $29 ) ) + 24 | 0 ) ; $31 = HEAP32 [ $30 >> 2 ] | 0 ; $32 = ( 0 - ( $31 ) ) | 0 ; $33 = $3 ; $34 = ( ( ( $33 ) ) + 24 | 0 ) ; HEAP32 [ $34 >> 2 ] = $32 ; } $35 = $3 ; $36 = ( ( ( $35 ) ) + 24 | 0 ) ; $37 = HEAP32 [ $36 >> 2 ] | 0 ; $38 = ( $37 | 0 ) != ( 0 ) ; $39 = $38 ? 42 : 113 ; $40 = $3 ; $41 = ( ( ( $40 ) ) + 4 | 0 ) ; HEAP32 [ $41 >> 2 ] = $39 ; $42 = ( _adler32 ( 0 , 0 , 0 ) | 0 ) ; $43 = $2 ; $44 = ( ( ( $43 ) ) + 48 | 0 ) ; HEAP32 [ $44 >> 2 ] = $42 ; $45 = $3 ; $46 = ( ( ( $45 ) ) + 40 | 0 ) ; HEAP32 [ $46 >> 2 ] = 0 ; $47 = $3 ; __tr_init ( $47 ) ; $1 = 0 ; $48 = $1 ; STACKTOP = sp ; return ( $48 | 0 ) ; } function _lm_init ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 ; var $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 ; var $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 ; var $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $2 = $1 ; $3 = ( ( ( $2 ) ) + 44 | 0 ) ; $4 = HEAP32 [ $3 >> 2 ] | 0 ; $5 = $4 << 1 ; $6 = $1 ; $7 = ( ( ( $6 ) ) + 60 | 0 ) ; HEAP32 [ $7 >> 2 ] = $5 ; $8 = $1 ; $9 = ( ( ( $8 ) ) + 68 | 0 ) ; $10 = HEAP32 [ $9 >> 2 ] | 0 ; $11 = $1 ; $12 = ( ( ( $11 ) ) + 76 | 0 ) ; $13 = HEAP32 [ $12 >> 2 ] | 0 ; $14 = ( ( $13 ) - 1 ) | 0 ; $15 = ( ( $10 ) + ( $14 << 1 ) | 0 ) ; HEAP16 [ $15 >> 1 ] = 0 ; $16 = $1 ; $17 = ( ( ( $16 ) ) + 68 | 0 ) ; $18 = HEAP32 [ $17 >> 2 ] | 0 ; $19 = $1 ; $20 = ( ( ( $19 ) ) + 76 | 0 ) ; $21 = HEAP32 [ $20 >> 2 ] | 0 ; $22 = ( ( $21 ) - 1 ) | 0 ; $23 = $22 << 1 ; _memset ( ( $18 | 0 ) , 0 , ( $23 | 0 ) ) | 0 ; $24 = $1 ; $25 = ( ( ( $24 ) ) + 132 | 0 ) ; $26 = HEAP32 [ $25 >> 2 ] | 0 ; $27 = ( 8684 + ( ( $26 * 12 ) | 0 ) | 0 ) ; $28 = ( ( ( $27 ) ) + 2 | 0 ) ; $29 = HEAP16 [ $28 >> 1 ] | 0 ; $30 = $29 & 65535 ; $31 = $1 ; $32 = ( ( ( $31 ) ) + 128 | 0 ) ; HEAP32 [ $32 >> 2 ] = $30 ; $33 = $1 ; $34 = ( ( ( $33 ) ) + 132 | 0 ) ; $35 = HEAP32 [ $34 >> 2 ] | 0 ; $36 = ( 8684 + ( ( $35 * 12 ) | 0 ) | 0 ) ; $37 = HEAP16 [ $36 >> 1 ] | 0 ; $38 = $37 & 65535 ; $39 = $1 ; $40 = ( ( ( $39 ) ) + 140 | 0 ) ; HEAP32 [ $40 >> 2 ] = $38 ; $41 = $1 ; $42 = ( ( ( $41 ) ) + 132 | 0 ) ; $43 = HEAP32 [ $42 >> 2 ] | 0 ; $44 = ( 8684 + ( ( $43 * 12 ) | 0 ) | 0 ) ; $45 = ( ( ( $44 ) ) + 4 | 0 ) ; $46 = HEAP16 [ $45 >> 1 ] | 0 ; $47 = $46 & 65535 ; $48 = $1 ; $49 = ( ( ( $48 ) ) + 144 | 0 ) ; HEAP32 [ $49 >> 2 ] = $47 ; $50 = $1 ; $51 = ( ( ( $50 ) ) + 132 | 0 ) ; $52 = HEAP32 [ $51 >> 2 ] | 0 ; $53 = ( 8684 + ( ( $52 * 12 ) | 0 ) | 0 ) ; $54 = ( ( ( $53 ) ) + 6 | 0 ) ; $55 = HEAP16 [ $54 >> 1 ] | 0 ; $56 = $55 & 65535 ; $57 = $1 ; $58 = ( ( ( $57 ) ) + 124 | 0 ) ; HEAP32 [ $58 >> 2 ] = $56 ; $59 = $1 ; $60 = ( ( ( $59 ) ) + 108 | 0 ) ; HEAP32 [ $60 >> 2 ] = 0 ; $61 = $1 ; $62 = ( ( ( $61 ) ) + 92 | 0 ) ; HEAP32 [ $62 >> 2 ] = 0 ; $63 = $1 ; $64 = ( ( ( $63 ) ) + 116 | 0 ) ; HEAP32 [ $64 >> 2 ] = 0 ; $65 = $1 ; $66 = ( ( ( $65 ) ) + 5812 | 0 ) ; HEAP32 [ $66 >> 2 ] = 0 ; $67 = $1 ; $68 = ( ( ( $67 ) ) + 120 | 0 ) ; HEAP32 [ $68 >> 2 ] = 2 ; $69 = $1 ; $70 = ( ( ( $69 ) ) + 96 | 0 ) ; HEAP32 [ $70 >> 2 ] = 2 ; $71 = $1 ; $72 = ( ( ( $71 ) ) + 104 | 0 ) ; HEAP32 [ $72 >> 2 ] = 0 ; $73 = $1 ; $74 = ( ( ( $73 ) ) + 72 | 0 ) ; HEAP32 [ $74 >> 2 ] = 0 ; STACKTOP = sp ; return ; } function _deflate_stored ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 ; var $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 ; var $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 ; var $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 ; var $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $2 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 ; var $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 ; var $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 ; var $244 = 0 , $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 , $258 = 0 , $259 = 0 , $26 = 0 , $260 = 0 , $261 = 0 ; var $262 = 0 , $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 , $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 , $270 = 0 , $271 = 0 , $272 = 0 , $273 = 0 , $274 = 0 , $275 = 0 , $276 = 0 , $277 = 0 , $278 = 0 , $279 = 0 , $28 = 0 ; var $280 = 0 , $281 = 0 , $282 = 0 , $283 = 0 , $284 = 0 , $285 = 0 , $286 = 0 , $287 = 0 , $288 = 0 , $289 = 0 , $29 = 0 , $290 = 0 , $291 = 0 , $292 = 0 , $293 = 0 , $294 = 0 , $295 = 0 , $296 = 0 , $297 = 0 , $298 = 0 ; var $299 = 0 , $3 = 0 , $30 = 0 , $300 = 0 , $301 = 0 , $302 = 0 , $303 = 0 , $304 = 0 , $305 = 0 , $306 = 0 , $307 = 0 , $308 = 0 , $309 = 0 , $31 = 0 , $310 = 0 , $311 = 0 , $312 = 0 , $313 = 0 , $314 = 0 , $315 = 0 ; var $316 = 0 , $317 = 0 , $318 = 0 , $319 = 0 , $32 = 0 , $320 = 0 , $321 = 0 , $322 = 0 , $323 = 0 , $324 = 0 , $325 = 0 , $326 = 0 , $327 = 0 , $328 = 0 , $329 = 0 , $33 = 0 , $330 = 0 , $331 = 0 , $332 = 0 , $333 = 0 ; var $334 = 0 , $335 = 0 , $336 = 0 , $337 = 0 , $338 = 0 , $339 = 0 , $34 = 0 , $340 = 0 , $341 = 0 , $342 = 0 , $343 = 0 , $344 = 0 , $345 = 0 , $346 = 0 , $347 = 0 , $348 = 0 , $349 = 0 , $35 = 0 , $350 = 0 , $351 = 0 ; var $352 = 0 , $353 = 0 , $354 = 0 , $355 = 0 , $356 = 0 , $357 = 0 , $358 = 0 , $359 = 0 , $36 = 0 , $360 = 0 , $361 = 0 , $362 = 0 , $363 = 0 , $364 = 0 , $365 = 0 , $366 = 0 , $367 = 0 , $368 = 0 , $369 = 0 , $37 = 0 ; var $370 = 0 , $371 = 0 , $372 = 0 , $373 = 0 , $374 = 0 , $375 = 0 , $376 = 0 , $377 = 0 , $378 = 0 , $379 = 0 , $38 = 0 , $380 = 0 , $381 = 0 , $382 = 0 , $383 = 0 , $384 = 0 , $385 = 0 , $386 = 0 , $387 = 0 , $388 = 0 ; var $389 = 0 , $39 = 0 , $390 = 0 , $391 = 0 , $392 = 0 , $393 = 0 , $394 = 0 , $395 = 0 , $396 = 0 , $397 = 0 , $398 = 0 , $399 = 0 , $4 = 0 , $40 = 0 , $400 = 0 , $401 = 0 , $402 = 0 , $403 = 0 , $404 = 0 , $405 = 0 ; var $406 = 0 , $407 = 0 , $408 = 0 , $409 = 0 , $41 = 0 , $410 = 0 , $411 = 0 , $412 = 0 , $413 = 0 , $414 = 0 , $415 = 0 , $416 = 0 , $417 = 0 , $418 = 0 , $419 = 0 , $42 = 0 , $420 = 0 , $421 = 0 , $422 = 0 , $423 = 0 ; var $424 = 0 , $425 = 0 , $426 = 0 , $427 = 0 , $428 = 0 , $429 = 0 , $43 = 0 , $430 = 0 , $431 = 0 , $432 = 0 , $433 = 0 , $434 = 0 , $435 = 0 , $436 = 0 , $437 = 0 , $438 = 0 , $439 = 0 , $44 = 0 , $440 = 0 , $441 = 0 ; var $442 = 0 , $443 = 0 , $444 = 0 , $445 = 0 , $446 = 0 , $447 = 0 , $448 = 0 , $449 = 0 , $45 = 0 , $450 = 0 , $451 = 0 , $452 = 0 , $453 = 0 , $454 = 0 , $455 = 0 , $456 = 0 , $457 = 0 , $458 = 0 , $459 = 0 , $46 = 0 ; var $460 = 0 , $461 = 0 , $462 = 0 , $463 = 0 , $464 = 0 , $465 = 0 , $466 = 0 , $467 = 0 , $468 = 0 , $469 = 0 , $47 = 0 , $470 = 0 , $471 = 0 , $472 = 0 , $473 = 0 , $474 = 0 , $475 = 0 , $476 = 0 , $477 = 0 , $478 = 0 ; var $479 = 0 , $48 = 0 , $480 = 0 , $481 = 0 , $482 = 0 , $483 = 0 , $484 = 0 , $485 = 0 , $486 = 0 , $487 = 0 , $488 = 0 , $489 = 0 , $49 = 0 , $490 = 0 , $491 = 0 , $492 = 0 , $493 = 0 , $494 = 0 , $495 = 0 , $496 = 0 ; var $497 = 0 , $498 = 0 , $499 = 0 , $5 = 0 , $50 = 0 , $500 = 0 , $501 = 0 , $502 = 0 , $503 = 0 , $504 = 0 , $505 = 0 , $506 = 0 , $507 = 0 , $508 = 0 , $509 = 0 , $51 = 0 , $510 = 0 , $511 = 0 , $512 = 0 , $513 = 0 ; var $514 = 0 , $515 = 0 , $516 = 0 , $517 = 0 , $518 = 0 , $519 = 0 , $52 = 0 , $520 = 0 , $521 = 0 , $522 = 0 , $523 = 0 , $524 = 0 , $525 = 0 , $526 = 0 , $527 = 0 , $528 = 0 , $529 = 0 , $53 = 0 , $530 = 0 , $531 = 0 ; var $532 = 0 , $533 = 0 , $534 = 0 , $535 = 0 , $536 = 0 , $537 = 0 , $538 = 0 , $539 = 0 , $54 = 0 , $540 = 0 , $541 = 0 , $542 = 0 , $543 = 0 , $544 = 0 , $545 = 0 , $546 = 0 , $547 = 0 , $548 = 0 , $549 = 0 , $55 = 0 ; var $550 = 0 , $551 = 0 , $552 = 0 , $553 = 0 , $554 = 0 , $555 = 0 , $556 = 0 , $557 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 ; var $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 ; var $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $or$cond = 0 , $or$cond3 = 0 , $or$cond5 = 0 , $or$cond7 = 0 ; var $or$cond9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 48 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 48 | 0 ) ; $3 = $0 ; $4 = $1 ; $11 = $3 ; $12 = ( ( ( $11 ) ) + 12 | 0 ) ; $13 = HEAP32 [ $12 >> 2 ] | 0 ; $14 = ( ( $13 ) - 5 ) | 0 ; $15 = $3 ; $16 = ( ( ( $15 ) ) + 44 | 0 ) ; $17 = HEAP32 [ $16 >> 2 ] | 0 ; $18 = ( $14 >>> 0 ) > ( $17 >>> 0 ) ; $19 = $3 ; if ( $18 ) { $20 = ( ( ( $19 ) ) + 44 | 0 ) ; $21 = HEAP32 [ $20 >> 2 ] | 0 ; $25 = $21 ; } else { $22 = ( ( ( $19 ) ) + 12 | 0 ) ; $23 = HEAP32 [ $22 >> 2 ] | 0 ; $24 = ( ( $23 ) - 5 ) | 0 ; $25 = $24 ; } $5 = $25 ; $9 = 0 ; $26 = $3 ; $27 = HEAP32 [ $26 >> 2 ] | 0 ; $28 = ( ( ( $27 ) ) + 4 | 0 ) ; $29 = HEAP32 [ $28 >> 2 ] | 0 ; $10 = $29 ; while ( 1 ) { $6 = 65535 ; $30 = $3 ; $31 = ( ( ( $30 ) ) + 5820 | 0 ) ; $32 = HEAP32 [ $31 >> 2 ] | 0 ; $33 = ( ( $32 ) + 42 ) | 0 ; $34 = $33 >> 3 ; $8 = $34 ; $35 = $3 ; $36 = HEAP32 [ $35 >> 2 ] | 0 ; $37 = ( ( ( $36 ) ) + 16 | 0 ) ; $38 = HEAP32 [ $37 >> 2 ] | 0 ; $39 = $8 ; $40 = ( $38 >>> 0 ) < ( $39 >>> 0 ) ; if ( $40 ) { break ; } $41 = $3 ; $42 = HEAP32 [ $41 >> 2 ] | 0 ; $43 = ( ( ( $42 ) ) + 16 | 0 ) ; $44 = HEAP32 [ $43 >> 2 ] | 0 ; $45 = $8 ; $46 = ( ( $44 ) - ( $45 ) ) | 0 ; $8 = $46 ; $47 = $3 ; $48 = ( ( ( $47 ) ) + 108 | 0 ) ; $49 = HEAP32 [ $48 >> 2 ] | 0 ; $50 = $3 ; $51 = ( ( ( $50 ) ) + 92 | 0 ) ; $52 = HEAP32 [ $51 >> 2 ] | 0 ; $53 = ( ( $49 ) - ( $52 ) ) | 0 ; $7 = $53 ; $54 = $6 ; $55 = $7 ; $56 = $3 ; $57 = HEAP32 [ $56 >> 2 ] | 0 ; $58 = ( ( ( $57 ) ) + 4 | 0 ) ; $59 = HEAP32 [ $58 >> 2 ] | 0 ; $60 = ( ( $55 ) + ( $59 ) ) | 0 ; $61 = ( $54 >>> 0 ) > ( $60 >>> 0 ) ; if ( $61 ) { $62 = $7 ; $63 = $3 ; $64 = HEAP32 [ $63 >> 2 ] | 0 ; $65 = ( ( ( $64 ) ) + 4 | 0 ) ; $66 = HEAP32 [ $65 >> 2 ] | 0 ; $67 = ( ( $62 ) + ( $66 ) ) | 0 ; $6 = $67 ; } $68 = $6 ; $69 = $8 ; $70 = ( $68 >>> 0 ) > ( $69 >>> 0 ) ; if ( $70 ) { $71 = $8 ; $6 = $71 ; } $72 = $6 ; $73 = $5 ; $74 = ( $72 >>> 0 ) < ( $73 >>> 0 ) ; if ( $74 ) { $75 = $6 ; $76 = ( $75 | 0 ) == ( 0 ) ; $77 = $4 ; $78 = ( $77 | 0 ) != ( 4 ) ; $or$cond = $76 & $78 ; $79 = $4 ; $80 = ( $79 | 0 ) == ( 0 ) ; $or$cond3 = $or$cond | $80 ; if ( $or$cond3 ) { break ; } $81 = $6 ; $82 = $7 ; $83 = $3 ; $84 = HEAP32 [ $83 >> 2 ] | 0 ; $85 = ( ( ( $84 ) ) + 4 | 0 ) ; $86 = HEAP32 [ $85 >> 2 ] | 0 ; $87 = ( ( $82 ) + ( $86 ) ) | 0 ; $88 = ( $81 | 0 ) != ( $87 | 0 ) ; if ( $88 ) { break ; } } $89 = $4 ; $90 = ( $89 | 0 ) == ( 4 ) ; if ( $90 ) { $91 = $6 ; $92 = $7 ; $93 = $3 ; $94 = HEAP32 [ $93 >> 2 ] | 0 ; $95 = ( ( ( $94 ) ) + 4 | 0 ) ; $96 = HEAP32 [ $95 >> 2 ] | 0 ; $97 = ( ( $92 ) + ( $96 ) ) | 0 ; $98 = ( $91 | 0 ) == ( $97 | 0 ) ; $99 = $98 ; } else { $99 = 0 ; } $100 = $99 ? 1 : 0 ; $9 = $100 ; $101 = $3 ; $102 = $9 ; __tr_stored_block ( $101 , 0 , 0 , $102 ) ; $103 = $6 ; $104 = $103 & 255 ; $105 = $3 ; $106 = ( ( ( $105 ) ) + 8 | 0 ) ; $107 = HEAP32 [ $106 >> 2 ] | 0 ; $108 = $3 ; $109 = ( ( ( $108 ) ) + 20 | 0 ) ; $110 = HEAP32 [ $109 >> 2 ] | 0 ; $111 = ( ( $110 ) - 4 ) | 0 ; $112 = ( ( $107 ) + ( $111 ) | 0 ) ; HEAP8 [ $112 >> 0 ] = $104 ; $113 = $6 ; $114 = $113 >>> 8 ; $115 = $114 & 255 ; $116 = $3 ; $117 = ( ( ( $116 ) ) + 8 | 0 ) ; $118 = HEAP32 [ $117 >> 2 ] | 0 ; $119 = $3 ; $120 = ( ( ( $119 ) ) + 20 | 0 ) ; $121 = HEAP32 [ $120 >> 2 ] | 0 ; $122 = ( ( $121 ) - 3 ) | 0 ; $123 = ( ( $118 ) + ( $122 ) | 0 ) ; HEAP8 [ $123 >> 0 ] = $115 ; $124 = $6 ; $125 = $124 ^ - 1 ; $126 = $125 & 255 ; $127 = $3 ; $128 = ( ( ( $127 ) ) + 8 | 0 ) ; $129 = HEAP32 [ $128 >> 2 ] | 0 ; $130 = $3 ; $131 = ( ( ( $130 ) ) + 20 | 0 ) ; $132 = HEAP32 [ $131 >> 2 ] | 0 ; $133 = ( ( $132 ) - 2 ) | 0 ; $134 = ( ( $129 ) + ( $133 ) | 0 ) ; HEAP8 [ $134 >> 0 ] = $126 ; $135 = $6 ; $136 = $135 ^ - 1 ; $137 = $136 >>> 8 ; $138 = $137 & 255 ; $139 = $3 ; $140 = ( ( ( $139 ) ) + 8 | 0 ) ; $141 = HEAP32 [ $140 >> 2 ] | 0 ; $142 = $3 ; $143 = ( ( ( $142 ) ) + 20 | 0 ) ; $144 = HEAP32 [ $143 >> 2 ] | 0 ; $145 = ( ( $144 ) - 1 ) | 0 ; $146 = ( ( $141 ) + ( $145 ) | 0 ) ; HEAP8 [ $146 >> 0 ] = $138 ; $147 = $3 ; $148 = HEAP32 [ $147 >> 2 ] | 0 ; _flush_pending ( $148 ) ; $149 = $7 ; $150 = ( $149 | 0 ) != ( 0 ) ; if ( $150 ) { $151 = $7 ; $152 = $6 ; $153 = ( $151 >>> 0 ) > ( $152 >>> 0 ) ; if ( $153 ) { $154 = $6 ; $7 = $154 ; } $155 = $3 ; $156 = HEAP32 [ $155 >> 2 ] | 0 ; $157 = ( ( ( $156 ) ) + 12 | 0 ) ; $158 = HEAP32 [ $157 >> 2 ] | 0 ; $159 = $3 ; $160 = ( ( ( $159 ) ) + 56 | 0 ) ; $161 = HEAP32 [ $160 >> 2 ] | 0 ; $162 = $3 ; $163 = ( ( ( $162 ) ) + 92 | 0 ) ; $164 = HEAP32 [ $163 >> 2 ] | 0 ; $165 = ( ( $161 ) + ( $164 ) | 0 ) ; $166 = $7 ; _memcpy ( ( $158 | 0 ) , ( $165 | 0 ) , ( $166 | 0 ) ) | 0 ; $167 = $7 ; $168 = $3 ; $169 = HEAP32 [ $168 >> 2 ] | 0 ; $170 = ( ( ( $169 ) ) + 12 | 0 ) ; $171 = HEAP32 [ $170 >> 2 ] | 0 ; $172 = ( ( $171 ) + ( $167 ) | 0 ) ; HEAP32 [ $170 >> 2 ] = $172 ; $173 = $7 ; $174 = $3 ; $175 = HEAP32 [ $174 >> 2 ] | 0 ; $176 = ( ( ( $175 ) ) + 16 | 0 ) ; $177 = HEAP32 [ $176 >> 2 ] | 0 ; $178 = ( ( $177 ) - ( $173 ) ) | 0 ; HEAP32 [ $176 >> 2 ] = $178 ; $179 = $7 ; $180 = $3 ; $181 = HEAP32 [ $180 >> 2 ] | 0 ; $182 = ( ( ( $181 ) ) + 20 | 0 ) ; $183 = HEAP32 [ $182 >> 2 ] | 0 ; $184 = ( ( $183 ) + ( $179 ) ) | 0 ; HEAP32 [ $182 >> 2 ] = $184 ; $185 = $7 ; $186 = $3 ; $187 = ( ( ( $186 ) ) + 92 | 0 ) ; $188 = HEAP32 [ $187 >> 2 ] | 0 ; $189 = ( ( $188 ) + ( $185 ) ) | 0 ; HEAP32 [ $187 >> 2 ] = $189 ; $190 = $7 ; $191 = $6 ; $192 = ( ( $191 ) - ( $190 ) ) | 0 ; $6 = $192 ; } $193 = $6 ; $194 = ( $193 | 0 ) != ( 0 ) ; if ( $194 ) { $195 = $3 ; $196 = HEAP32 [ $195 >> 2 ] | 0 ; $197 = $3 ; $198 = HEAP32 [ $197 >> 2 ] | 0 ; $199 = ( ( ( $198 ) ) + 12 | 0 ) ; $200 = HEAP32 [ $199 >> 2 ] | 0 ; $201 = $6 ; ( _read_buf ( $196 , $200 , $201 ) | 0 ) ; $202 = $6 ; $203 = $3 ; $204 = HEAP32 [ $203 >> 2 ] | 0 ; $205 = ( ( ( $204 ) ) + 12 | 0 ) ; $206 = HEAP32 [ $205 >> 2 ] | 0 ; $207 = ( ( $206 ) + ( $202 ) | 0 ) ; HEAP32 [ $205 >> 2 ] = $207 ; $208 = $6 ; $209 = $3 ; $210 = HEAP32 [ $209 >> 2 ] | 0 ; $211 = ( ( ( $210 ) ) + 16 | 0 ) ; $212 = HEAP32 [ $211 >> 2 ] | 0 ; $213 = ( ( $212 ) - ( $208 ) ) | 0 ; HEAP32 [ $211 >> 2 ] = $213 ; $214 = $6 ; $215 = $3 ; $216 = HEAP32 [ $215 >> 2 ] | 0 ; $217 = ( ( ( $216 ) ) + 20 | 0 ) ; $218 = HEAP32 [ $217 >> 2 ] | 0 ; $219 = ( ( $218 ) + ( $214 ) ) | 0 ; HEAP32 [ $217 >> 2 ] = $219 ; } $220 = $9 ; $221 = ( $220 | 0 ) == ( 0 ) ; if ( ! ( $221 ) ) { break ; } } $222 = $3 ; $223 = HEAP32 [ $222 >> 2 ] | 0 ; $224 = ( ( ( $223 ) ) + 4 | 0 ) ; $225 = HEAP32 [ $224 >> 2 ] | 0 ; $226 = $10 ; $227 = ( ( $226 ) - ( $225 ) ) | 0 ; $10 = $227 ; $228 = $10 ; $229 = ( $228 | 0 ) != ( 0 ) ; if ( $229 ) { $230 = $10 ; $231 = $3 ; $232 = ( ( ( $231 ) ) + 44 | 0 ) ; $233 = HEAP32 [ $232 >> 2 ] | 0 ; $234 = ( $230 >>> 0 ) >= ( $233 >>> 0 ) ; $235 = $3 ; if ( $234 ) { $236 = ( ( ( $235 ) ) + 5808 | 0 ) ; HEAP32 [ $236 >> 2 ] = 2 ; $237 = $3 ; $238 = ( ( ( $237 ) ) + 56 | 0 ) ; $239 = HEAP32 [ $238 >> 2 ] | 0 ; $240 = $3 ; $241 = HEAP32 [ $240 >> 2 ] | 0 ; $242 = HEAP32 [ $241 >> 2 ] | 0 ; $243 = $3 ; $244 = ( ( ( $243 ) ) + 44 | 0 ) ; $245 = HEAP32 [ $244 >> 2 ] | 0 ; $246 = ( 0 - ( $245 ) ) | 0 ; $247 = ( ( $242 ) + ( $246 ) | 0 ) ; $248 = $3 ; $249 = ( ( ( $248 ) ) + 44 | 0 ) ; $250 = HEAP32 [ $249 >> 2 ] | 0 ; _memcpy ( ( $239 | 0 ) , ( $247 | 0 ) , ( $250 | 0 ) ) | 0 ; $251 = $3 ; $252 = ( ( ( $251 ) ) + 44 | 0 ) ; $253 = HEAP32 [ $252 >> 2 ] | 0 ; $254 = $3 ; $255 = ( ( ( $254 ) ) + 108 | 0 ) ; HEAP32 [ $255 >> 2 ] = $253 ; } else { $256 = ( ( ( $235 ) ) + 60 | 0 ) ; $257 = HEAP32 [ $256 >> 2 ] | 0 ; $258 = $3 ; $259 = ( ( ( $258 ) ) + 108 | 0 ) ; $260 = HEAP32 [ $259 >> 2 ] | 0 ; $261 = ( ( $257 ) - ( $260 ) ) | 0 ; $262 = $10 ; $263 = ( $261 >>> 0 ) <= ( $262 >>> 0 ) ; if ( $263 ) { $264 = $3 ; $265 = ( ( ( $264 ) ) + 44 | 0 ) ; $266 = HEAP32 [ $265 >> 2 ] | 0 ; $267 = $3 ; $268 = ( ( ( $267 ) ) + 108 | 0 ) ; $269 = HEAP32 [ $268 >> 2 ] | 0 ; $270 = ( ( $269 ) - ( $266 ) ) | 0 ; HEAP32 [ $268 >> 2 ] = $270 ; $271 = $3 ; $272 = ( ( ( $271 ) ) + 56 | 0 ) ; $273 = HEAP32 [ $272 >> 2 ] | 0 ; $274 = $3 ; $275 = ( ( ( $274 ) ) + 56 | 0 ) ; $276 = HEAP32 [ $275 >> 2 ] | 0 ; $277 = $3 ; $278 = ( ( ( $277 ) ) + 44 | 0 ) ; $279 = HEAP32 [ $278 >> 2 ] | 0 ; $280 = ( ( $276 ) + ( $279 ) | 0 ) ; $281 = $3 ; $282 = ( ( ( $281 ) ) + 108 | 0 ) ; $283 = HEAP32 [ $282 >> 2 ] | 0 ; _memcpy ( ( $273 | 0 ) , ( $280 | 0 ) , ( $283 | 0 ) ) | 0 ; $284 = $3 ; $285 = ( ( ( $284 ) ) + 5808 | 0 ) ; $286 = HEAP32 [ $285 >> 2 ] | 0 ; $287 = ( $286 >>> 0 ) < ( 2 ) ; if ( $287 ) { $288 = $3 ; $289 = ( ( ( $288 ) ) + 5808 | 0 ) ; $290 = HEAP32 [ $289 >> 2 ] | 0 ; $291 = ( ( $290 ) + 1 ) | 0 ; HEAP32 [ $289 >> 2 ] = $291 ; } } $292 = $3 ; $293 = ( ( ( $292 ) ) + 56 | 0 ) ; $294 = HEAP32 [ $293 >> 2 ] | 0 ; $295 = $3 ; $296 = ( ( ( $295 ) ) + 108 | 0 ) ; $297 = HEAP32 [ $296 >> 2 ] | 0 ; $298 = ( ( $294 ) + ( $297 ) | 0 ) ; $299 = $3 ; $300 = HEAP32 [ $299 >> 2 ] | 0 ; $301 = HEAP32 [ $300 >> 2 ] | 0 ; $302 = $10 ; $303 = ( 0 - ( $302 ) ) | 0 ; $304 = ( ( $301 ) + ( $303 ) | 0 ) ; $305 = $10 ; _memcpy ( ( $298 | 0 ) , ( $304 | 0 ) , ( $305 | 0 ) ) | 0 ; $306 = $10 ; $307 = $3 ; $308 = ( ( ( $307 ) ) + 108 | 0 ) ; $309 = HEAP32 [ $308 >> 2 ] | 0 ; $310 = ( ( $309 ) + ( $306 ) ) | 0 ; HEAP32 [ $308 >> 2 ] = $310 ; } $311 = $3 ; $312 = ( ( ( $311 ) ) + 108 | 0 ) ; $313 = HEAP32 [ $312 >> 2 ] | 0 ; $314 = $3 ; $315 = ( ( ( $314 ) ) + 92 | 0 ) ; HEAP32 [ $315 >> 2 ] = $313 ; $316 = $10 ; $317 = $3 ; $318 = ( ( ( $317 ) ) + 44 | 0 ) ; $319 = HEAP32 [ $318 >> 2 ] | 0 ; $320 = $3 ; $321 = ( ( ( $320 ) ) + 5812 | 0 ) ; $322 = HEAP32 [ $321 >> 2 ] | 0 ; $323 = ( ( $319 ) - ( $322 ) ) | 0 ; $324 = ( $316 >>> 0 ) > ( $323 >>> 0 ) ; if ( $324 ) { $325 = $3 ; $326 = ( ( ( $325 ) ) + 44 | 0 ) ; $327 = HEAP32 [ $326 >> 2 ] | 0 ; $328 = $3 ; $329 = ( ( ( $328 ) ) + 5812 | 0 ) ; $330 = HEAP32 [ $329 >> 2 ] | 0 ; $331 = ( ( $327 ) - ( $330 ) ) | 0 ; $337 = $331 ; } else { $332 = $10 ; $337 = $332 ; } $333 = $3 ; $334 = ( ( ( $333 ) ) + 5812 | 0 ) ; $335 = HEAP32 [ $334 >> 2 ] | 0 ; $336 = ( ( $335 ) + ( $337 ) ) | 0 ; HEAP32 [ $334 >> 2 ] = $336 ; } $338 = $3 ; $339 = ( ( ( $338 ) ) + 5824 | 0 ) ; $340 = HEAP32 [ $339 >> 2 ] | 0 ; $341 = $3 ; $342 = ( ( ( $341 ) ) + 108 | 0 ) ; $343 = HEAP32 [ $342 >> 2 ] | 0 ; $344 = ( $340 >>> 0 ) < ( $343 >>> 0 ) ; if ( $344 ) { $345 = $3 ; $346 = ( ( ( $345 ) ) + 108 | 0 ) ; $347 = HEAP32 [ $346 >> 2 ] | 0 ; $348 = $3 ; $349 = ( ( ( $348 ) ) + 5824 | 0 ) ; HEAP32 [ $349 >> 2 ] = $347 ; } $350 = $9 ; $351 = ( $350 | 0 ) != ( 0 ) ; if ( $351 ) { $2 = 3 ; $557 = $2 ; STACKTOP = sp ; return ( $557 | 0 ) ; } $352 = $4 ; $353 = ( $352 | 0 ) != ( 0 ) ; $354 = $4 ; $355 = ( $354 | 0 ) != ( 4 ) ; $or$cond5 = $353 & $355 ; if ( $or$cond5 ) { $356 = $3 ; $357 = HEAP32 [ $356 >> 2 ] | 0 ; $358 = ( ( ( $357 ) ) + 4 | 0 ) ; $359 = HEAP32 [ $358 >> 2 ] | 0 ; $360 = ( $359 | 0 ) == ( 0 ) ; if ( $360 ) { $361 = $3 ; $362 = ( ( ( $361 ) ) + 108 | 0 ) ; $363 = HEAP32 [ $362 >> 2 ] | 0 ; $364 = $3 ; $365 = ( ( ( $364 ) ) + 92 | 0 ) ; $366 = HEAP32 [ $365 >> 2 ] | 0 ; $367 = ( $363 | 0 ) == ( $366 | 0 ) ; if ( $367 ) { $2 = 1 ; $557 = $2 ; STACKTOP = sp ; return ( $557 | 0 ) ; } } } $368 = $3 ; $369 = ( ( ( $368 ) ) + 60 | 0 ) ; $370 = HEAP32 [ $369 >> 2 ] | 0 ; $371 = $3 ; $372 = ( ( ( $371 ) ) + 108 | 0 ) ; $373 = HEAP32 [ $372 >> 2 ] | 0 ; $374 = ( ( $370 ) - ( $373 ) ) | 0 ; $375 = ( ( $374 ) - 1 ) | 0 ; $8 = $375 ; $376 = $3 ; $377 = HEAP32 [ $376 >> 2 ] | 0 ; $378 = ( ( ( $377 ) ) + 4 | 0 ) ; $379 = HEAP32 [ $378 >> 2 ] | 0 ; $380 = $8 ; $381 = ( $379 >>> 0 ) > ( $380 >>> 0 ) ; if ( $381 ) { $382 = $3 ; $383 = ( ( ( $382 ) ) + 92 | 0 ) ; $384 = HEAP32 [ $383 >> 2 ] | 0 ; $385 = $3 ; $386 = ( ( ( $385 ) ) + 44 | 0 ) ; $387 = HEAP32 [ $386 >> 2 ] | 0 ; $388 = ( $384 | 0 ) >= ( $387 | 0 ) ; if ( $388 ) { $389 = $3 ; $390 = ( ( ( $389 ) ) + 44 | 0 ) ; $391 = HEAP32 [ $390 >> 2 ] | 0 ; $392 = $3 ; $393 = ( ( ( $392 ) ) + 92 | 0 ) ; $394 = HEAP32 [ $393 >> 2 ] | 0 ; $395 = ( ( $394 ) - ( $391 ) ) | 0 ; HEAP32 [ $393 >> 2 ] = $395 ; $396 = $3 ; $397 = ( ( ( $396 ) ) + 44 | 0 ) ; $398 = HEAP32 [ $397 >> 2 ] | 0 ; $399 = $3 ; $400 = ( ( ( $399 ) ) + 108 | 0 ) ; $401 = HEAP32 [ $400 >> 2 ] | 0 ; $402 = ( ( $401 ) - ( $398 ) ) | 0 ; HEAP32 [ $400 >> 2 ] = $402 ; $403 = $3 ; $404 = ( ( ( $403 ) ) + 56 | 0 ) ; $405 = HEAP32 [ $404 >> 2 ] | 0 ; $406 = $3 ; $407 = ( ( ( $406 ) ) + 56 | 0 ) ; $408 = HEAP32 [ $407 >> 2 ] | 0 ; $409 = $3 ; $410 = ( ( ( $409 ) ) + 44 | 0 ) ; $411 = HEAP32 [ $410 >> 2 ] | 0 ; $412 = ( ( $408 ) + ( $411 ) | 0 ) ; $413 = $3 ; $414 = ( ( ( $413 ) ) + 108 | 0 ) ; $415 = HEAP32 [ $414 >> 2 ] | 0 ; _memcpy ( ( $405 | 0 ) , ( $412 | 0 ) , ( $415 | 0 ) ) | 0 ; $416 = $3 ; $417 = ( ( ( $416 ) ) + 5808 | 0 ) ; $418 = HEAP32 [ $417 >> 2 ] | 0 ; $419 = ( $418 >>> 0 ) < ( 2 ) ; if ( $419 ) { $420 = $3 ; $421 = ( ( ( $420 ) ) + 5808 | 0 ) ; $422 = HEAP32 [ $421 >> 2 ] | 0 ; $423 = ( ( $422 ) + 1 ) | 0 ; HEAP32 [ $421 >> 2 ] = $423 ; } $424 = $3 ; $425 = ( ( ( $424 ) ) + 44 | 0 ) ; $426 = HEAP32 [ $425 >> 2 ] | 0 ; $427 = $8 ; $428 = ( ( $427 ) + ( $426 ) ) | 0 ; $8 = $428 ; } } $429 = $8 ; $430 = $3 ; $431 = HEAP32 [ $430 >> 2 ] | 0 ; $432 = ( ( ( $431 ) ) + 4 | 0 ) ; $433 = HEAP32 [ $432 >> 2 ] | 0 ; $434 = ( $429 >>> 0 ) > ( $433 >>> 0 ) ; if ( $434 ) { $435 = $3 ; $436 = HEAP32 [ $435 >> 2 ] | 0 ; $437 = ( ( ( $436 ) ) + 4 | 0 ) ; $438 = HEAP32 [ $437 >> 2 ] | 0 ; $8 = $438 ; } $439 = $8 ; $440 = ( $439 | 0 ) != ( 0 ) ; if ( $440 ) { $441 = $3 ; $442 = HEAP32 [ $441 >> 2 ] | 0 ; $443 = $3 ; $444 = ( ( ( $443 ) ) + 56 | 0 ) ; $445 = HEAP32 [ $444 >> 2 ] | 0 ; $446 = $3 ; $447 = ( ( ( $446 ) ) + 108 | 0 ) ; $448 = HEAP32 [ $447 >> 2 ] | 0 ; $449 = ( ( $445 ) + ( $448 ) | 0 ) ; $450 = $8 ; ( _read_buf ( $442 , $449 , $450 ) | 0 ) ; $451 = $8 ; $452 = $3 ; $453 = ( ( ( $452 ) ) + 108 | 0 ) ; $454 = HEAP32 [ $453 >> 2 ] | 0 ; $455 = ( ( $454 ) + ( $451 ) ) | 0 ; HEAP32 [ $453 >> 2 ] = $455 ; } $456 = $3 ; $457 = ( ( ( $456 ) ) + 5824 | 0 ) ; $458 = HEAP32 [ $457 >> 2 ] | 0 ; $459 = $3 ; $460 = ( ( ( $459 ) ) + 108 | 0 ) ; $461 = HEAP32 [ $460 >> 2 ] | 0 ; $462 = ( $458 >>> 0 ) < ( $461 >>> 0 ) ; if ( $462 ) { $463 = $3 ; $464 = ( ( ( $463 ) ) + 108 | 0 ) ; $465 = HEAP32 [ $464 >> 2 ] | 0 ; $466 = $3 ; $467 = ( ( ( $466 ) ) + 5824 | 0 ) ; HEAP32 [ $467 >> 2 ] = $465 ; } $468 = $3 ; $469 = ( ( ( $468 ) ) + 5820 | 0 ) ; $470 = HEAP32 [ $469 >> 2 ] | 0 ; $471 = ( ( $470 ) + 42 ) | 0 ; $472 = $471 >> 3 ; $8 = $472 ; $473 = $3 ; $474 = ( ( ( $473 ) ) + 12 | 0 ) ; $475 = HEAP32 [ $474 >> 2 ] | 0 ; $476 = $8 ; $477 = ( ( $475 ) - ( $476 ) ) | 0 ; $478 = ( $477 >>> 0 ) > ( 65535 ) ; if ( $478 ) { $484 = 65535 ; } else { $479 = $3 ; $480 = ( ( ( $479 ) ) + 12 | 0 ) ; $481 = HEAP32 [ $480 >> 2 ] | 0 ; $482 = $8 ; $483 = ( ( $481 ) - ( $482 ) ) | 0 ; $484 = $483 ; } $8 = $484 ; $485 = $8 ; $486 = $3 ; $487 = ( ( ( $486 ) ) + 44 | 0 ) ; $488 = HEAP32 [ $487 >> 2 ] | 0 ; $489 = ( $485 >>> 0 ) > ( $488 >>> 0 ) ; if ( $489 ) { $490 = $3 ; $491 = ( ( ( $490 ) ) + 44 | 0 ) ; $492 = HEAP32 [ $491 >> 2 ] | 0 ; $494 = $492 ; } else { $493 = $8 ; $494 = $493 ; } $5 = $494 ; $495 = $3 ; $496 = ( ( ( $495 ) ) + 108 | 0 ) ; $497 = HEAP32 [ $496 >> 2 ] | 0 ; $498 = $3 ; $499 = ( ( ( $498 ) ) + 92 | 0 ) ; $500 = HEAP32 [ $499 >> 2 ] | 0 ; $501 = ( ( $497 ) - ( $500 ) ) | 0 ; $7 = $501 ; $502 = $7 ; $503 = $5 ; $504 = ( $502 >>> 0 ) >= ( $503 >>> 0 ) ; if ( $504 ) { label = 61 ; } else { $505 = $7 ; $506 = ( $505 | 0 ) != ( 0 ) ; $507 = $4 ; $508 = ( $507 | 0 ) == ( 4 ) ; $or$cond7 = $506 | $508 ; $509 = $4 ; $510 = ( $509 | 0 ) != ( 0 ) ; $or$cond9 = $or$cond7 & $510 ; if ( $or$cond9 ) { $511 = $3 ; $512 = HEAP32 [ $511 >> 2 ] | 0 ; $513 = ( ( ( $512 ) ) + 4 | 0 ) ; $514 = HEAP32 [ $513 >> 2 ] | 0 ; $515 = ( $514 | 0 ) == ( 0 ) ; if ( $515 ) { $516 = $7 ; $517 = $8 ; $518 = ( $516 >>> 0 ) <= ( $517 >>> 0 ) ; if ( $518 ) { label = 61 ; } } } } if ( ( label | 0 ) == 61 ) { $519 = $7 ; $520 = $8 ; $521 = ( $519 >>> 0 ) > ( $520 >>> 0 ) ; $522 = $8 ; $523 = $7 ; $524 = $521 ? $522 : $523 ; $6 = $524 ; $525 = $4 ; $526 = ( $525 | 0 ) == ( 4 ) ; if ( $526 ) { $527 = $3 ; $528 = HEAP32 [ $527 >> 2 ] | 0 ; $529 = ( ( ( $528 ) ) + 4 | 0 ) ; $530 = HEAP32 [ $529 >> 2 ] | 0 ; $531 = ( $530 | 0 ) == ( 0 ) ; if ( $531 ) { $532 = $6 ; $533 = $7 ; $534 = ( $532 | 0 ) == ( $533 | 0 ) ; $535 = $534 ; } else { $535 = 0 ; } } else { $535 = 0 ; } $536 = $535 ? 1 : 0 ; $9 = $536 ; $537 = $3 ; $538 = $3 ; $539 = ( ( ( $538 ) ) + 56 | 0 ) ; $540 = HEAP32 [ $539 >> 2 ] | 0 ; $541 = $3 ; $542 = ( ( ( $541 ) ) + 92 | 0 ) ; $543 = HEAP32 [ $542 >> 2 ] | 0 ; $544 = ( ( $540 ) + ( $543 ) | 0 ) ; $545 = $6 ; $546 = $9 ; __tr_stored_block ( $537 , $544 , $545 , $546 ) ; $547 = $6 ; $548 = $3 ; $549 = ( ( ( $548 ) ) + 92 | 0 ) ; $550 = HEAP32 [ $549 >> 2 ] | 0 ; $551 = ( ( $550 ) + ( $547 ) ) | 0 ; HEAP32 [ $549 >> 2 ] = $551 ; $552 = $3 ; $553 = HEAP32 [ $552 >> 2 ] | 0 ; _flush_pending ( $553 ) ; } $554 = $9 ; $555 = ( $554 | 0 ) != ( 0 ) ; $556 = $555 ? 2 : 0 ; $2 = $556 ; $557 = $2 ; STACKTOP = sp ; return ( $557 | 0 ) ; } function _deflate_fast ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$sink = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 ; var $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 ; var $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 ; var $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 ; var $171 = 0 , $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 ; var $19 = 0 , $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $2 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 ; var $207 = 0 , $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 ; var $225 = 0 , $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 ; var $243 = 0 , $244 = 0 , $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 , $258 = 0 , $259 = 0 , $26 = 0 , $260 = 0 ; var $261 = 0 , $262 = 0 , $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 , $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 , $270 = 0 , $271 = 0 , $272 = 0 , $273 = 0 , $274 = 0 , $275 = 0 , $276 = 0 , $277 = 0 , $278 = 0 , $279 = 0 ; var $28 = 0 , $280 = 0 , $281 = 0 , $282 = 0 , $283 = 0 , $284 = 0 , $285 = 0 , $286 = 0 , $287 = 0 , $288 = 0 , $289 = 0 , $29 = 0 , $290 = 0 , $291 = 0 , $292 = 0 , $293 = 0 , $294 = 0 , $295 = 0 , $296 = 0 , $297 = 0 ; var $298 = 0 , $299 = 0 , $3 = 0 , $30 = 0 , $300 = 0 , $301 = 0 , $302 = 0 , $303 = 0 , $304 = 0 , $305 = 0 , $306 = 0 , $307 = 0 , $308 = 0 , $309 = 0 , $31 = 0 , $310 = 0 , $311 = 0 , $312 = 0 , $313 = 0 , $314 = 0 ; var $315 = 0 , $316 = 0 , $317 = 0 , $318 = 0 , $319 = 0 , $32 = 0 , $320 = 0 , $321 = 0 , $322 = 0 , $323 = 0 , $324 = 0 , $325 = 0 , $326 = 0 , $327 = 0 , $328 = 0 , $329 = 0 , $33 = 0 , $330 = 0 , $331 = 0 , $332 = 0 ; var $333 = 0 , $334 = 0 , $335 = 0 , $336 = 0 , $337 = 0 , $338 = 0 , $339 = 0 , $34 = 0 , $340 = 0 , $341 = 0 , $342 = 0 , $343 = 0 , $344 = 0 , $345 = 0 , $346 = 0 , $347 = 0 , $348 = 0 , $349 = 0 , $35 = 0 , $350 = 0 ; var $351 = 0 , $352 = 0 , $353 = 0 , $354 = 0 , $355 = 0 , $356 = 0 , $357 = 0 , $358 = 0 , $359 = 0 , $36 = 0 , $360 = 0 , $361 = 0 , $362 = 0 , $363 = 0 , $364 = 0 , $365 = 0 , $366 = 0 , $367 = 0 , $368 = 0 , $369 = 0 ; var $37 = 0 , $370 = 0 , $371 = 0 , $372 = 0 , $373 = 0 , $374 = 0 , $375 = 0 , $376 = 0 , $377 = 0 , $378 = 0 , $379 = 0 , $38 = 0 , $380 = 0 , $381 = 0 , $382 = 0 , $383 = 0 , $384 = 0 , $385 = 0 , $386 = 0 , $387 = 0 ; var $388 = 0 , $389 = 0 , $39 = 0 , $390 = 0 , $391 = 0 , $392 = 0 , $393 = 0 , $394 = 0 , $395 = 0 , $396 = 0 , $397 = 0 , $398 = 0 , $399 = 0 , $4 = 0 , $40 = 0 , $400 = 0 , $401 = 0 , $402 = 0 , $403 = 0 , $404 = 0 ; var $405 = 0 , $406 = 0 , $407 = 0 , $408 = 0 , $409 = 0 , $41 = 0 , $410 = 0 , $411 = 0 , $412 = 0 , $413 = 0 , $414 = 0 , $415 = 0 , $416 = 0 , $417 = 0 , $418 = 0 , $419 = 0 , $42 = 0 , $420 = 0 , $421 = 0 , $422 = 0 ; var $423 = 0 , $424 = 0 , $425 = 0 , $426 = 0 , $427 = 0 , $428 = 0 , $429 = 0 , $43 = 0 , $430 = 0 , $431 = 0 , $432 = 0 , $433 = 0 , $434 = 0 , $435 = 0 , $436 = 0 , $437 = 0 , $438 = 0 , $439 = 0 , $44 = 0 , $440 = 0 ; var $441 = 0 , $442 = 0 , $443 = 0 , $444 = 0 , $445 = 0 , $446 = 0 , $447 = 0 , $448 = 0 , $449 = 0 , $45 = 0 , $450 = 0 , $451 = 0 , $452 = 0 , $453 = 0 , $454 = 0 , $455 = 0 , $456 = 0 , $457 = 0 , $458 = 0 , $459 = 0 ; var $46 = 0 , $460 = 0 , $461 = 0 , $462 = 0 , $463 = 0 , $464 = 0 , $465 = 0 , $466 = 0 , $467 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 ; var $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 ; var $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 ; var $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $3 = $0 ; $4 = $1 ; while ( 1 ) { $10 = $3 ; $11 = ( ( ( $10 ) ) + 116 | 0 ) ; $12 = HEAP32 [ $11 >> 2 ] | 0 ; $13 = ( $12 >>> 0 ) < ( 262 ) ; if ( $13 ) { $14 = $3 ; _fill_window ( $14 ) ; $15 = $3 ; $16 = ( ( ( $15 ) ) + 116 | 0 ) ; $17 = HEAP32 [ $16 >> 2 ] | 0 ; $18 = ( $17 >>> 0 ) < ( 262 ) ; $19 = $4 ; $20 = ( $19 | 0 ) == ( 0 ) ; $or$cond = $18 & $20 ; if ( $or$cond ) { label = 4 ; break ; } $21 = $3 ; $22 = ( ( ( $21 ) ) + 116 | 0 ) ; $23 = HEAP32 [ $22 >> 2 ] | 0 ; $24 = ( $23 | 0 ) == ( 0 ) ; if ( $24 ) { label = 24 ; break ; } } $5 = 0 ; $25 = $3 ; $26 = ( ( ( $25 ) ) + 116 | 0 ) ; $27 = HEAP32 [ $26 >> 2 ] | 0 ; $28 = ( $27 >>> 0 ) >= ( 3 ) ; if ( $28 ) { $29 = $3 ; $30 = ( ( ( $29 ) ) + 72 | 0 ) ; $31 = HEAP32 [ $30 >> 2 ] | 0 ; $32 = $3 ; $33 = ( ( ( $32 ) ) + 88 | 0 ) ; $34 = HEAP32 [ $33 >> 2 ] | 0 ; $35 = $31 << $34 ; $36 = $3 ; $37 = ( ( ( $36 ) ) + 56 | 0 ) ; $38 = HEAP32 [ $37 >> 2 ] | 0 ; $39 = $3 ; $40 = ( ( ( $39 ) ) + 108 | 0 ) ; $41 = HEAP32 [ $40 >> 2 ] | 0 ; $42 = ( ( $41 ) + 2 ) | 0 ; $43 = ( ( $38 ) + ( $42 ) | 0 ) ; $44 = HEAP8 [ $43 >> 0 ] | 0 ; $45 = $44 & 255 ; $46 = $35 ^ $45 ; $47 = $3 ; $48 = ( ( ( $47 ) ) + 84 | 0 ) ; $49 = HEAP32 [ $48 >> 2 ] | 0 ; $50 = $46 & $49 ; $51 = $3 ; $52 = ( ( ( $51 ) ) + 72 | 0 ) ; HEAP32 [ $52 >> 2 ] = $50 ; $53 = $3 ; $54 = ( ( ( $53 ) ) + 68 | 0 ) ; $55 = HEAP32 [ $54 >> 2 ] | 0 ; $56 = $3 ; $57 = ( ( ( $56 ) ) + 72 | 0 ) ; $58 = HEAP32 [ $57 >> 2 ] | 0 ; $59 = ( ( $55 ) + ( $58 << 1 ) | 0 ) ; $60 = HEAP16 [ $59 >> 1 ] | 0 ; $61 = $3 ; $62 = ( ( ( $61 ) ) + 64 | 0 ) ; $63 = HEAP32 [ $62 >> 2 ] | 0 ; $64 = $3 ; $65 = ( ( ( $64 ) ) + 108 | 0 ) ; $66 = HEAP32 [ $65 >> 2 ] | 0 ; $67 = $3 ; $68 = ( ( ( $67 ) ) + 52 | 0 ) ; $69 = HEAP32 [ $68 >> 2 ] | 0 ; $70 = $66 & $69 ; $71 = ( ( $63 ) + ( $70 << 1 ) | 0 ) ; HEAP16 [ $71 >> 1 ] = $60 ; $72 = $60 & 65535 ; $5 = $72 ; $73 = $3 ; $74 = ( ( ( $73 ) ) + 108 | 0 ) ; $75 = HEAP32 [ $74 >> 2 ] | 0 ; $76 = $75 & 65535 ; $77 = $3 ; $78 = ( ( ( $77 ) ) + 68 | 0 ) ; $79 = HEAP32 [ $78 >> 2 ] | 0 ; $80 = $3 ; $81 = ( ( ( $80 ) ) + 72 | 0 ) ; $82 = HEAP32 [ $81 >> 2 ] | 0 ; $83 = ( ( $79 ) + ( $82 << 1 ) | 0 ) ; HEAP16 [ $83 >> 1 ] = $76 ; } $84 = $5 ; $85 = ( $84 | 0 ) != ( 0 ) ; if ( $85 ) { $86 = $3 ; $87 = ( ( ( $86 ) ) + 108 | 0 ) ; $88 = HEAP32 [ $87 >> 2 ] | 0 ; $89 = $5 ; $90 = ( ( $88 ) - ( $89 ) ) | 0 ; $91 = $3 ; $92 = ( ( ( $91 ) ) + 44 | 0 ) ; $93 = HEAP32 [ $92 >> 2 ] | 0 ; $94 = ( ( $93 ) - 262 ) | 0 ; $95 = ( $90 >>> 0 ) <= ( $94 >>> 0 ) ; if ( $95 ) { $96 = $3 ; $97 = $5 ; $98 = ( _longest_match ( $96 , $97 ) | 0 ) ; $99 = $3 ; $100 = ( ( ( $99 ) ) + 96 | 0 ) ; HEAP32 [ $100 >> 2 ] = $98 ; } } $101 = $3 ; $102 = ( ( ( $101 ) ) + 96 | 0 ) ; $103 = HEAP32 [ $102 >> 2 ] | 0 ; $104 = ( $103 >>> 0 ) >= ( 3 ) ; $105 = $3 ; do { if ( $104 ) { $106 = ( ( ( $105 ) ) + 96 | 0 ) ; $107 = HEAP32 [ $106 >> 2 ] | 0 ; $108 = ( ( $107 ) - 3 ) | 0 ; $109 = $108 & 255 ; $7 = $109 ; $110 = $3 ; $111 = ( ( ( $110 ) ) + 108 | 0 ) ; $112 = HEAP32 [ $111 >> 2 ] | 0 ; $113 = $3 ; $114 = ( ( ( $113 ) ) + 112 | 0 ) ; $115 = HEAP32 [ $114 >> 2 ] | 0 ; $116 = ( ( $112 ) - ( $115 ) ) | 0 ; $117 = $116 & 65535 ; $8 = $117 ; $118 = $8 ; $119 = $3 ; $120 = ( ( ( $119 ) ) + 5796 | 0 ) ; $121 = HEAP32 [ $120 >> 2 ] | 0 ; $122 = $3 ; $123 = ( ( ( $122 ) ) + 5792 | 0 ) ; $124 = HEAP32 [ $123 >> 2 ] | 0 ; $125 = ( ( $121 ) + ( $124 << 1 ) | 0 ) ; HEAP16 [ $125 >> 1 ] = $118 ; $126 = $7 ; $127 = $3 ; $128 = ( ( ( $127 ) ) + 5784 | 0 ) ; $129 = HEAP32 [ $128 >> 2 ] | 0 ; $130 = $3 ; $131 = ( ( ( $130 ) ) + 5792 | 0 ) ; $132 = HEAP32 [ $131 >> 2 ] | 0 ; $133 = ( ( $132 ) + 1 ) | 0 ; HEAP32 [ $131 >> 2 ] = $133 ; $134 = ( ( $129 ) + ( $132 ) | 0 ) ; HEAP8 [ $134 >> 0 ] = $126 ; $135 = $8 ; $136 = ( ( $135 ) + - 1 ) << 16 >> 16 ; $8 = $136 ; $137 = $3 ; $138 = ( ( ( $137 ) ) + 148 | 0 ) ; $139 = $7 ; $140 = $139 & 255 ; $141 = ( 29272 + ( $140 ) | 0 ) ; $142 = HEAP8 [ $141 >> 0 ] | 0 ; $143 = $142 & 255 ; $144 = ( ( $143 ) + 256 ) | 0 ; $145 = ( ( $144 ) + 1 ) | 0 ; $146 = ( ( $138 ) + ( $145 << 2 ) | 0 ) ; $147 = HEAP16 [ $146 >> 1 ] | 0 ; $148 = ( ( $147 ) + 1 ) << 16 >> 16 ; HEAP16 [ $146 >> 1 ] = $148 ; $149 = $3 ; $150 = ( ( ( $149 ) ) + 2440 | 0 ) ; $151 = $8 ; $152 = $151 & 65535 ; $153 = ( $152 | 0 ) < ( 256 ) ; $154 = $8 ; $155 = $154 & 65535 ; $156 = $155 >> 7 ; $157 = ( 256 + ( $156 ) ) | 0 ; $$sink = $153 ? $155 : $157 ; $158 = ( 28760 + ( $$sink ) | 0 ) ; $159 = HEAP8 [ $158 >> 0 ] | 0 ; $160 = $159 & 255 ; $161 = ( ( $150 ) + ( $160 << 2 ) | 0 ) ; $162 = HEAP16 [ $161 >> 1 ] | 0 ; $163 = ( ( $162 ) + 1 ) << 16 >> 16 ; HEAP16 [ $161 >> 1 ] = $163 ; $164 = $3 ; $165 = ( ( ( $164 ) ) + 5792 | 0 ) ; $166 = HEAP32 [ $165 >> 2 ] | 0 ; $167 = $3 ; $168 = ( ( ( $167 ) ) + 5788 | 0 ) ; $169 = HEAP32 [ $168 >> 2 ] | 0 ; $170 = ( ( $169 ) - 1 ) | 0 ; $171 = ( $166 | 0 ) == ( $170 | 0 ) ; $172 = $171 & 1 ; $6 = $172 ; $173 = $3 ; $174 = ( ( ( $173 ) ) + 96 | 0 ) ; $175 = HEAP32 [ $174 >> 2 ] | 0 ; $176 = $3 ; $177 = ( ( ( $176 ) ) + 116 | 0 ) ; $178 = HEAP32 [ $177 >> 2 ] | 0 ; $179 = ( ( $178 ) - ( $175 ) ) | 0 ; HEAP32 [ $177 >> 2 ] = $179 ; $180 = $3 ; $181 = ( ( ( $180 ) ) + 96 | 0 ) ; $182 = HEAP32 [ $181 >> 2 ] | 0 ; $183 = $3 ; $184 = ( ( ( $183 ) ) + 128 | 0 ) ; $185 = HEAP32 [ $184 >> 2 ] | 0 ; $186 = ( $182 >>> 0 ) <= ( $185 >>> 0 ) ; if ( $186 ) { $187 = $3 ; $188 = ( ( ( $187 ) ) + 116 | 0 ) ; $189 = HEAP32 [ $188 >> 2 ] | 0 ; $190 = ( $189 >>> 0 ) >= ( 3 ) ; if ( $190 ) { $191 = $3 ; $192 = ( ( ( $191 ) ) + 96 | 0 ) ; $193 = HEAP32 [ $192 >> 2 ] | 0 ; $194 = ( ( $193 ) + - 1 ) | 0 ; HEAP32 [ $192 >> 2 ] = $194 ; while ( 1 ) { $195 = $3 ; $196 = ( ( ( $195 ) ) + 108 | 0 ) ; $197 = HEAP32 [ $196 >> 2 ] | 0 ; $198 = ( ( $197 ) + 1 ) | 0 ; HEAP32 [ $196 >> 2 ] = $198 ; $199 = $3 ; $200 = ( ( ( $199 ) ) + 72 | 0 ) ; $201 = HEAP32 [ $200 >> 2 ] | 0 ; $202 = $3 ; $203 = ( ( ( $202 ) ) + 88 | 0 ) ; $204 = HEAP32 [ $203 >> 2 ] | 0 ; $205 = $201 << $204 ; $206 = $3 ; $207 = ( ( ( $206 ) ) + 56 | 0 ) ; $208 = HEAP32 [ $207 >> 2 ] | 0 ; $209 = $3 ; $210 = ( ( ( $209 ) ) + 108 | 0 ) ; $211 = HEAP32 [ $210 >> 2 ] | 0 ; $212 = ( ( $211 ) + 2 ) | 0 ; $213 = ( ( $208 ) + ( $212 ) | 0 ) ; $214 = HEAP8 [ $213 >> 0 ] | 0 ; $215 = $214 & 255 ; $216 = $205 ^ $215 ; $217 = $3 ; $218 = ( ( ( $217 ) ) + 84 | 0 ) ; $219 = HEAP32 [ $218 >> 2 ] | 0 ; $220 = $216 & $219 ; $221 = $3 ; $222 = ( ( ( $221 ) ) + 72 | 0 ) ; HEAP32 [ $222 >> 2 ] = $220 ; $223 = $3 ; $224 = ( ( ( $223 ) ) + 68 | 0 ) ; $225 = HEAP32 [ $224 >> 2 ] | 0 ; $226 = $3 ; $227 = ( ( ( $226 ) ) + 72 | 0 ) ; $228 = HEAP32 [ $227 >> 2 ] | 0 ; $229 = ( ( $225 ) + ( $228 << 1 ) | 0 ) ; $230 = HEAP16 [ $229 >> 1 ] | 0 ; $231 = $3 ; $232 = ( ( ( $231 ) ) + 64 | 0 ) ; $233 = HEAP32 [ $232 >> 2 ] | 0 ; $234 = $3 ; $235 = ( ( ( $234 ) ) + 108 | 0 ) ; $236 = HEAP32 [ $235 >> 2 ] | 0 ; $237 = $3 ; $238 = ( ( ( $237 ) ) + 52 | 0 ) ; $239 = HEAP32 [ $238 >> 2 ] | 0 ; $240 = $236 & $239 ; $241 = ( ( $233 ) + ( $240 << 1 ) | 0 ) ; HEAP16 [ $241 >> 1 ] = $230 ; $242 = $230 & 65535 ; $5 = $242 ; $243 = $3 ; $244 = ( ( ( $243 ) ) + 108 | 0 ) ; $245 = HEAP32 [ $244 >> 2 ] | 0 ; $246 = $245 & 65535 ; $247 = $3 ; $248 = ( ( ( $247 ) ) + 68 | 0 ) ; $249 = HEAP32 [ $248 >> 2 ] | 0 ; $250 = $3 ; $251 = ( ( ( $250 ) ) + 72 | 0 ) ; $252 = HEAP32 [ $251 >> 2 ] | 0 ; $253 = ( ( $249 ) + ( $252 << 1 ) | 0 ) ; HEAP16 [ $253 >> 1 ] = $246 ; $254 = $3 ; $255 = ( ( ( $254 ) ) + 96 | 0 ) ; $256 = HEAP32 [ $255 >> 2 ] | 0 ; $257 = ( ( $256 ) + - 1 ) | 0 ; HEAP32 [ $255 >> 2 ] = $257 ; $258 = ( $257 | 0 ) != ( 0 ) ; if ( ! ( $258 ) ) { break ; } } $259 = $3 ; $260 = ( ( ( $259 ) ) + 108 | 0 ) ; $261 = HEAP32 [ $260 >> 2 ] | 0 ; $262 = ( ( $261 ) + 1 ) | 0 ; HEAP32 [ $260 >> 2 ] = $262 ; break ; } } $263 = $3 ; $264 = ( ( ( $263 ) ) + 96 | 0 ) ; $265 = HEAP32 [ $264 >> 2 ] | 0 ; $266 = $3 ; $267 = ( ( ( $266 ) ) + 108 | 0 ) ; $268 = HEAP32 [ $267 >> 2 ] | 0 ; $269 = ( ( $268 ) + ( $265 ) ) | 0 ; HEAP32 [ $267 >> 2 ] = $269 ; $270 = $3 ; $271 = ( ( ( $270 ) ) + 96 | 0 ) ; HEAP32 [ $271 >> 2 ] = 0 ; $272 = $3 ; $273 = ( ( ( $272 ) ) + 56 | 0 ) ; $274 = HEAP32 [ $273 >> 2 ] | 0 ; $275 = $3 ; $276 = ( ( ( $275 ) ) + 108 | 0 ) ; $277 = HEAP32 [ $276 >> 2 ] | 0 ; $278 = ( ( $274 ) + ( $277 ) | 0 ) ; $279 = HEAP8 [ $278 >> 0 ] | 0 ; $280 = $279 & 255 ; $281 = $3 ; $282 = ( ( ( $281 ) ) + 72 | 0 ) ; HEAP32 [ $282 >> 2 ] = $280 ; $283 = $3 ; $284 = ( ( ( $283 ) ) + 72 | 0 ) ; $285 = HEAP32 [ $284 >> 2 ] | 0 ; $286 = $3 ; $287 = ( ( ( $286 ) ) + 88 | 0 ) ; $288 = HEAP32 [ $287 >> 2 ] | 0 ; $289 = $285 << $288 ; $290 = $3 ; $291 = ( ( ( $290 ) ) + 56 | 0 ) ; $292 = HEAP32 [ $291 >> 2 ] | 0 ; $293 = $3 ; $294 = ( ( ( $293 ) ) + 108 | 0 ) ; $295 = HEAP32 [ $294 >> 2 ] | 0 ; $296 = ( ( $295 ) + 1 ) | 0 ; $297 = ( ( $292 ) + ( $296 ) | 0 ) ; $298 = HEAP8 [ $297 >> 0 ] | 0 ; $299 = $298 & 255 ; $300 = $289 ^ $299 ; $301 = $3 ; $302 = ( ( ( $301 ) ) + 84 | 0 ) ; $303 = HEAP32 [ $302 >> 2 ] | 0 ; $304 = $300 & $303 ; $305 = $3 ; $306 = ( ( ( $305 ) ) + 72 | 0 ) ; HEAP32 [ $306 >> 2 ] = $304 ; } else { $307 = ( ( ( $105 ) ) + 56 | 0 ) ; $308 = HEAP32 [ $307 >> 2 ] | 0 ; $309 = $3 ; $310 = ( ( ( $309 ) ) + 108 | 0 ) ; $311 = HEAP32 [ $310 >> 2 ] | 0 ; $312 = ( ( $308 ) + ( $311 ) | 0 ) ; $313 = HEAP8 [ $312 >> 0 ] | 0 ; $9 = $313 ; $314 = $3 ; $315 = ( ( ( $314 ) ) + 5796 | 0 ) ; $316 = HEAP32 [ $315 >> 2 ] | 0 ; $317 = $3 ; $318 = ( ( ( $317 ) ) + 5792 | 0 ) ; $319 = HEAP32 [ $318 >> 2 ] | 0 ; $320 = ( ( $316 ) + ( $319 << 1 ) | 0 ) ; HEAP16 [ $320 >> 1 ] = 0 ; $321 = $9 ; $322 = $3 ; $323 = ( ( ( $322 ) ) + 5784 | 0 ) ; $324 = HEAP32 [ $323 >> 2 ] | 0 ; $325 = $3 ; $326 = ( ( ( $325 ) ) + 5792 | 0 ) ; $327 = HEAP32 [ $326 >> 2 ] | 0 ; $328 = ( ( $327 ) + 1 ) | 0 ; HEAP32 [ $326 >> 2 ] = $328 ; $329 = ( ( $324 ) + ( $327 ) | 0 ) ; HEAP8 [ $329 >> 0 ] = $321 ; $330 = $3 ; $331 = ( ( ( $330 ) ) + 148 | 0 ) ; $332 = $9 ; $333 = $332 & 255 ; $334 = ( ( $331 ) + ( $333 << 2 ) | 0 ) ; $335 = HEAP16 [ $334 >> 1 ] | 0 ; $336 = ( ( $335 ) + 1 ) << 16 >> 16 ; HEAP16 [ $334 >> 1 ] = $336 ; $337 = $3 ; $338 = ( ( ( $337 ) ) + 5792 | 0 ) ; $339 = HEAP32 [ $338 >> 2 ] | 0 ; $340 = $3 ; $341 = ( ( ( $340 ) ) + 5788 | 0 ) ; $342 = HEAP32 [ $341 >> 2 ] | 0 ; $343 = ( ( $342 ) - 1 ) | 0 ; $344 = ( $339 | 0 ) == ( $343 | 0 ) ; $345 = $344 & 1 ; $6 = $345 ; $346 = $3 ; $347 = ( ( ( $346 ) ) + 116 | 0 ) ; $348 = HEAP32 [ $347 >> 2 ] | 0 ; $349 = ( ( $348 ) + - 1 ) | 0 ; HEAP32 [ $347 >> 2 ] = $349 ; $350 = $3 ; $351 = ( ( ( $350 ) ) + 108 | 0 ) ; $352 = HEAP32 [ $351 >> 2 ] | 0 ; $353 = ( ( $352 ) + 1 ) | 0 ; HEAP32 [ $351 >> 2 ] = $353 ; } } while ( 0 ) ; $354 = $6 ; $355 = ( $354 | 0 ) != ( 0 ) ; if ( ! ( $355 ) ) { continue ; } $356 = $3 ; $357 = $3 ; $358 = ( ( ( $357 ) ) + 92 | 0 ) ; $359 = HEAP32 [ $358 >> 2 ] | 0 ; $360 = ( $359 | 0 ) >= ( 0 ) ; if ( $360 ) { $361 = $3 ; $362 = ( ( ( $361 ) ) + 56 | 0 ) ; $363 = HEAP32 [ $362 >> 2 ] | 0 ; $364 = $3 ; $365 = ( ( ( $364 ) ) + 92 | 0 ) ; $366 = HEAP32 [ $365 >> 2 ] | 0 ; $367 = ( ( $363 ) + ( $366 ) | 0 ) ; $375 = $367 ; } else { $375 = 0 ; } $368 = $3 ; $369 = ( ( ( $368 ) ) + 108 | 0 ) ; $370 = HEAP32 [ $369 >> 2 ] | 0 ; $371 = $3 ; $372 = ( ( ( $371 ) ) + 92 | 0 ) ; $373 = HEAP32 [ $372 >> 2 ] | 0 ; $374 = ( ( $370 ) - ( $373 ) ) | 0 ; __tr_flush_block ( $356 , $375 , $374 , 0 ) ; $376 = $3 ; $377 = ( ( ( $376 ) ) + 108 | 0 ) ; $378 = HEAP32 [ $377 >> 2 ] | 0 ; $379 = $3 ; $380 = ( ( ( $379 ) ) + 92 | 0 ) ; HEAP32 [ $380 >> 2 ] = $378 ; $381 = $3 ; $382 = HEAP32 [ $381 >> 2 ] | 0 ; _flush_pending ( $382 ) ; $383 = $3 ; $384 = HEAP32 [ $383 >> 2 ] | 0 ; $385 = ( ( ( $384 ) ) + 16 | 0 ) ; $386 = HEAP32 [ $385 >> 2 ] | 0 ; $387 = ( $386 | 0 ) == ( 0 ) ; if ( $387 ) { label = 23 ; break ; } } if ( ( label | 0 ) == 4 ) { $2 = 0 ; $467 = $2 ; STACKTOP = sp ; return ( $467 | 0 ) ; } else if ( ( label | 0 ) == 23 ) { $2 = 0 ; $467 = $2 ; STACKTOP = sp ; return ( $467 | 0 ) ; } else if ( ( label | 0 ) == 24 ) { $388 = $3 ; $389 = ( ( ( $388 ) ) + 108 | 0 ) ; $390 = HEAP32 [ $389 >> 2 ] | 0 ; $391 = ( $390 >>> 0 ) < ( 2 ) ; if ( $391 ) { $392 = $3 ; $393 = ( ( ( $392 ) ) + 108 | 0 ) ; $394 = HEAP32 [ $393 >> 2 ] | 0 ; $397 = $394 ; } else { $397 = 2 ; } $395 = $3 ; $396 = ( ( ( $395 ) ) + 5812 | 0 ) ; HEAP32 [ $396 >> 2 ] = $397 ; $398 = $4 ; $399 = ( $398 | 0 ) == ( 4 ) ; $400 = $3 ; if ( $399 ) { $401 = $3 ; $402 = ( ( ( $401 ) ) + 92 | 0 ) ; $403 = HEAP32 [ $402 >> 2 ] | 0 ; $404 = ( $403 | 0 ) >= ( 0 ) ; if ( $404 ) { $405 = $3 ; $406 = ( ( ( $405 ) ) + 56 | 0 ) ; $407 = HEAP32 [ $406 >> 2 ] | 0 ; $408 = $3 ; $409 = ( ( ( $408 ) ) + 92 | 0 ) ; $410 = HEAP32 [ $409 >> 2 ] | 0 ; $411 = ( ( $407 ) + ( $410 ) | 0 ) ; $419 = $411 ; } else { $419 = 0 ; } $412 = $3 ; $413 = ( ( ( $412 ) ) + 108 | 0 ) ; $414 = HEAP32 [ $413 >> 2 ] | 0 ; $415 = $3 ; $416 = ( ( ( $415 ) ) + 92 | 0 ) ; $417 = HEAP32 [ $416 >> 2 ] | 0 ; $418 = ( ( $414 ) - ( $417 ) ) | 0 ; __tr_flush_block ( $400 , $419 , $418 , 1 ) ; $420 = $3 ; $421 = ( ( ( $420 ) ) + 108 | 0 ) ; $422 = HEAP32 [ $421 >> 2 ] | 0 ; $423 = $3 ; $424 = ( ( ( $423 ) ) + 92 | 0 ) ; HEAP32 [ $424 >> 2 ] = $422 ; $425 = $3 ; $426 = HEAP32 [ $425 >> 2 ] | 0 ; _flush_pending ( $426 ) ; $427 = $3 ; $428 = HEAP32 [ $427 >> 2 ] | 0 ; $429 = ( ( ( $428 ) ) + 16 | 0 ) ; $430 = HEAP32 [ $429 >> 2 ] | 0 ; $431 = ( $430 | 0 ) == ( 0 ) ; if ( $431 ) { $2 = 2 ; $467 = $2 ; STACKTOP = sp ; return ( $467 | 0 ) ; } else { $2 = 3 ; $467 = $2 ; STACKTOP = sp ; return ( $467 | 0 ) ; } } $432 = ( ( ( $400 ) ) + 5792 | 0 ) ; $433 = HEAP32 [ $432 >> 2 ] | 0 ; $434 = ( $433 | 0 ) != ( 0 ) ; if ( $434 ) { $435 = $3 ; $436 = $3 ; $437 = ( ( ( $436 ) ) + 92 | 0 ) ; $438 = HEAP32 [ $437 >> 2 ] | 0 ; $439 = ( $438 | 0 ) >= ( 0 ) ; if ( $439 ) { $440 = $3 ; $441 = ( ( ( $440 ) ) + 56 | 0 ) ; $442 = HEAP32 [ $441 >> 2 ] | 0 ; $443 = $3 ; $444 = ( ( ( $443 ) ) + 92 | 0 ) ; $445 = HEAP32 [ $444 >> 2 ] | 0 ; $446 = ( ( $442 ) + ( $445 ) | 0 ) ; $454 = $446 ; } else { $454 = 0 ; } $447 = $3 ; $448 = ( ( ( $447 ) ) + 108 | 0 ) ; $449 = HEAP32 [ $448 >> 2 ] | 0 ; $450 = $3 ; $451 = ( ( ( $450 ) ) + 92 | 0 ) ; $452 = HEAP32 [ $451 >> 2 ] | 0 ; $453 = ( ( $449 ) - ( $452 ) ) | 0 ; __tr_flush_block ( $435 , $454 , $453 , 0 ) ; $455 = $3 ; $456 = ( ( ( $455 ) ) + 108 | 0 ) ; $457 = HEAP32 [ $456 >> 2 ] | 0 ; $458 = $3 ; $459 = ( ( ( $458 ) ) + 92 | 0 ) ; HEAP32 [ $459 >> 2 ] = $457 ; $460 = $3 ; $461 = HEAP32 [ $460 >> 2 ] | 0 ; _flush_pending ( $461 ) ; $462 = $3 ; $463 = HEAP32 [ $462 >> 2 ] | 0 ; $464 = ( ( ( $463 ) ) + 16 | 0 ) ; $465 = HEAP32 [ $464 >> 2 ] | 0 ; $466 = ( $465 | 0 ) == ( 0 ) ; if ( $466 ) { $2 = 0 ; $467 = $2 ; STACKTOP = sp ; return ( $467 | 0 ) ; } } $2 = 1 ; $467 = $2 ; STACKTOP = sp ; return ( $467 | 0 ) ; } return ( 0 ) | 0 ; } function _deflate_slow ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$sink = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 ; var $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 ; var $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 ; var $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 ; var $171 = 0 , $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 ; var $19 = 0 , $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $2 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 ; var $207 = 0 , $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 ; var $225 = 0 , $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 ; var $243 = 0 , $244 = 0 , $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 , $258 = 0 , $259 = 0 , $26 = 0 , $260 = 0 ; var $261 = 0 , $262 = 0 , $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 , $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 , $270 = 0 , $271 = 0 , $272 = 0 , $273 = 0 , $274 = 0 , $275 = 0 , $276 = 0 , $277 = 0 , $278 = 0 , $279 = 0 ; var $28 = 0 , $280 = 0 , $281 = 0 , $282 = 0 , $283 = 0 , $284 = 0 , $285 = 0 , $286 = 0 , $287 = 0 , $288 = 0 , $289 = 0 , $29 = 0 , $290 = 0 , $291 = 0 , $292 = 0 , $293 = 0 , $294 = 0 , $295 = 0 , $296 = 0 , $297 = 0 ; var $298 = 0 , $299 = 0 , $3 = 0 , $30 = 0 , $300 = 0 , $301 = 0 , $302 = 0 , $303 = 0 , $304 = 0 , $305 = 0 , $306 = 0 , $307 = 0 , $308 = 0 , $309 = 0 , $31 = 0 , $310 = 0 , $311 = 0 , $312 = 0 , $313 = 0 , $314 = 0 ; var $315 = 0 , $316 = 0 , $317 = 0 , $318 = 0 , $319 = 0 , $32 = 0 , $320 = 0 , $321 = 0 , $322 = 0 , $323 = 0 , $324 = 0 , $325 = 0 , $326 = 0 , $327 = 0 , $328 = 0 , $329 = 0 , $33 = 0 , $330 = 0 , $331 = 0 , $332 = 0 ; var $333 = 0 , $334 = 0 , $335 = 0 , $336 = 0 , $337 = 0 , $338 = 0 , $339 = 0 , $34 = 0 , $340 = 0 , $341 = 0 , $342 = 0 , $343 = 0 , $344 = 0 , $345 = 0 , $346 = 0 , $347 = 0 , $348 = 0 , $349 = 0 , $35 = 0 , $350 = 0 ; var $351 = 0 , $352 = 0 , $353 = 0 , $354 = 0 , $355 = 0 , $356 = 0 , $357 = 0 , $358 = 0 , $359 = 0 , $36 = 0 , $360 = 0 , $361 = 0 , $362 = 0 , $363 = 0 , $364 = 0 , $365 = 0 , $366 = 0 , $367 = 0 , $368 = 0 , $369 = 0 ; var $37 = 0 , $370 = 0 , $371 = 0 , $372 = 0 , $373 = 0 , $374 = 0 , $375 = 0 , $376 = 0 , $377 = 0 , $378 = 0 , $379 = 0 , $38 = 0 , $380 = 0 , $381 = 0 , $382 = 0 , $383 = 0 , $384 = 0 , $385 = 0 , $386 = 0 , $387 = 0 ; var $388 = 0 , $389 = 0 , $39 = 0 , $390 = 0 , $391 = 0 , $392 = 0 , $393 = 0 , $394 = 0 , $395 = 0 , $396 = 0 , $397 = 0 , $398 = 0 , $399 = 0 , $4 = 0 , $40 = 0 , $400 = 0 , $401 = 0 , $402 = 0 , $403 = 0 , $404 = 0 ; var $405 = 0 , $406 = 0 , $407 = 0 , $408 = 0 , $409 = 0 , $41 = 0 , $410 = 0 , $411 = 0 , $412 = 0 , $413 = 0 , $414 = 0 , $415 = 0 , $416 = 0 , $417 = 0 , $418 = 0 , $419 = 0 , $42 = 0 , $420 = 0 , $421 = 0 , $422 = 0 ; var $423 = 0 , $424 = 0 , $425 = 0 , $426 = 0 , $427 = 0 , $428 = 0 , $429 = 0 , $43 = 0 , $430 = 0 , $431 = 0 , $432 = 0 , $433 = 0 , $434 = 0 , $435 = 0 , $436 = 0 , $437 = 0 , $438 = 0 , $439 = 0 , $44 = 0 , $440 = 0 ; var $441 = 0 , $442 = 0 , $443 = 0 , $444 = 0 , $445 = 0 , $446 = 0 , $447 = 0 , $448 = 0 , $449 = 0 , $45 = 0 , $450 = 0 , $451 = 0 , $452 = 0 , $453 = 0 , $454 = 0 , $455 = 0 , $456 = 0 , $457 = 0 , $458 = 0 , $459 = 0 ; var $46 = 0 , $460 = 0 , $461 = 0 , $462 = 0 , $463 = 0 , $464 = 0 , $465 = 0 , $466 = 0 , $467 = 0 , $468 = 0 , $469 = 0 , $47 = 0 , $470 = 0 , $471 = 0 , $472 = 0 , $473 = 0 , $474 = 0 , $475 = 0 , $476 = 0 , $477 = 0 ; var $478 = 0 , $479 = 0 , $48 = 0 , $480 = 0 , $481 = 0 , $482 = 0 , $483 = 0 , $484 = 0 , $485 = 0 , $486 = 0 , $487 = 0 , $488 = 0 , $489 = 0 , $49 = 0 , $490 = 0 , $491 = 0 , $492 = 0 , $493 = 0 , $494 = 0 , $495 = 0 ; var $496 = 0 , $497 = 0 , $498 = 0 , $499 = 0 , $5 = 0 , $50 = 0 , $500 = 0 , $501 = 0 , $502 = 0 , $503 = 0 , $504 = 0 , $505 = 0 , $506 = 0 , $507 = 0 , $508 = 0 , $509 = 0 , $51 = 0 , $510 = 0 , $511 = 0 , $512 = 0 ; var $513 = 0 , $514 = 0 , $515 = 0 , $516 = 0 , $517 = 0 , $518 = 0 , $519 = 0 , $52 = 0 , $520 = 0 , $521 = 0 , $522 = 0 , $523 = 0 , $524 = 0 , $525 = 0 , $526 = 0 , $527 = 0 , $528 = 0 , $529 = 0 , $53 = 0 , $530 = 0 ; var $531 = 0 , $532 = 0 , $533 = 0 , $534 = 0 , $535 = 0 , $536 = 0 , $537 = 0 , $538 = 0 , $539 = 0 , $54 = 0 , $540 = 0 , $541 = 0 , $542 = 0 , $543 = 0 , $544 = 0 , $545 = 0 , $546 = 0 , $547 = 0 , $548 = 0 , $549 = 0 ; var $55 = 0 , $550 = 0 , $551 = 0 , $552 = 0 , $553 = 0 , $554 = 0 , $555 = 0 , $556 = 0 , $557 = 0 , $558 = 0 , $559 = 0 , $56 = 0 , $560 = 0 , $561 = 0 , $562 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 ; var $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 ; var $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 ; var $98 = 0 , $99 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $3 = $0 ; $4 = $1 ; while ( 1 ) { $12 = $3 ; $13 = ( ( ( $12 ) ) + 116 | 0 ) ; $14 = HEAP32 [ $13 >> 2 ] | 0 ; $15 = ( $14 >>> 0 ) < ( 262 ) ; if ( $15 ) { $16 = $3 ; _fill_window ( $16 ) ; $17 = $3 ; $18 = ( ( ( $17 ) ) + 116 | 0 ) ; $19 = HEAP32 [ $18 >> 2 ] | 0 ; $20 = ( $19 >>> 0 ) < ( 262 ) ; $21 = $4 ; $22 = ( $21 | 0 ) == ( 0 ) ; $or$cond = $20 & $22 ; if ( $or$cond ) { label = 4 ; break ; } $23 = $3 ; $24 = ( ( ( $23 ) ) + 116 | 0 ) ; $25 = HEAP32 [ $24 >> 2 ] | 0 ; $26 = ( $25 | 0 ) == ( 0 ) ; if ( $26 ) { label = 33 ; break ; } } $5 = 0 ; $27 = $3 ; $28 = ( ( ( $27 ) ) + 116 | 0 ) ; $29 = HEAP32 [ $28 >> 2 ] | 0 ; $30 = ( $29 >>> 0 ) >= ( 3 ) ; if ( $30 ) { $31 = $3 ; $32 = ( ( ( $31 ) ) + 72 | 0 ) ; $33 = HEAP32 [ $32 >> 2 ] | 0 ; $34 = $3 ; $35 = ( ( ( $34 ) ) + 88 | 0 ) ; $36 = HEAP32 [ $35 >> 2 ] | 0 ; $37 = $33 << $36 ; $38 = $3 ; $39 = ( ( ( $38 ) ) + 56 | 0 ) ; $40 = HEAP32 [ $39 >> 2 ] | 0 ; $41 = $3 ; $42 = ( ( ( $41 ) ) + 108 | 0 ) ; $43 = HEAP32 [ $42 >> 2 ] | 0 ; $44 = ( ( $43 ) + 2 ) | 0 ; $45 = ( ( $40 ) + ( $44 ) | 0 ) ; $46 = HEAP8 [ $45 >> 0 ] | 0 ; $47 = $46 & 255 ; $48 = $37 ^ $47 ; $49 = $3 ; $50 = ( ( ( $49 ) ) + 84 | 0 ) ; $51 = HEAP32 [ $50 >> 2 ] | 0 ; $52 = $48 & $51 ; $53 = $3 ; $54 = ( ( ( $53 ) ) + 72 | 0 ) ; HEAP32 [ $54 >> 2 ] = $52 ; $55 = $3 ; $56 = ( ( ( $55 ) ) + 68 | 0 ) ; $57 = HEAP32 [ $56 >> 2 ] | 0 ; $58 = $3 ; $59 = ( ( ( $58 ) ) + 72 | 0 ) ; $60 = HEAP32 [ $59 >> 2 ] | 0 ; $61 = ( ( $57 ) + ( $60 << 1 ) | 0 ) ; $62 = HEAP16 [ $61 >> 1 ] | 0 ; $63 = $3 ; $64 = ( ( ( $63 ) ) + 64 | 0 ) ; $65 = HEAP32 [ $64 >> 2 ] | 0 ; $66 = $3 ; $67 = ( ( ( $66 ) ) + 108 | 0 ) ; $68 = HEAP32 [ $67 >> 2 ] | 0 ; $69 = $3 ; $70 = ( ( ( $69 ) ) + 52 | 0 ) ; $71 = HEAP32 [ $70 >> 2 ] | 0 ; $72 = $68 & $71 ; $73 = ( ( $65 ) + ( $72 << 1 ) | 0 ) ; HEAP16 [ $73 >> 1 ] = $62 ; $74 = $62 & 65535 ; $5 = $74 ; $75 = $3 ; $76 = ( ( ( $75 ) ) + 108 | 0 ) ; $77 = HEAP32 [ $76 >> 2 ] | 0 ; $78 = $77 & 65535 ; $79 = $3 ; $80 = ( ( ( $79 ) ) + 68 | 0 ) ; $81 = HEAP32 [ $80 >> 2 ] | 0 ; $82 = $3 ; $83 = ( ( ( $82 ) ) + 72 | 0 ) ; $84 = HEAP32 [ $83 >> 2 ] | 0 ; $85 = ( ( $81 ) + ( $84 << 1 ) | 0 ) ; HEAP16 [ $85 >> 1 ] = $78 ; } $86 = $3 ; $87 = ( ( ( $86 ) ) + 96 | 0 ) ; $88 = HEAP32 [ $87 >> 2 ] | 0 ; $89 = $3 ; $90 = ( ( ( $89 ) ) + 120 | 0 ) ; HEAP32 [ $90 >> 2 ] = $88 ; $91 = $3 ; $92 = ( ( ( $91 ) ) + 112 | 0 ) ; $93 = HEAP32 [ $92 >> 2 ] | 0 ; $94 = $3 ; $95 = ( ( ( $94 ) ) + 100 | 0 ) ; HEAP32 [ $95 >> 2 ] = $93 ; $96 = $3 ; $97 = ( ( ( $96 ) ) + 96 | 0 ) ; HEAP32 [ $97 >> 2 ] = 2 ; $98 = $5 ; $99 = ( $98 | 0 ) != ( 0 ) ; if ( $99 ) { $100 = $3 ; $101 = ( ( ( $100 ) ) + 120 | 0 ) ; $102 = HEAP32 [ $101 >> 2 ] | 0 ; $103 = $3 ; $104 = ( ( ( $103 ) ) + 128 | 0 ) ; $105 = HEAP32 [ $104 >> 2 ] | 0 ; $106 = ( $102 >>> 0 ) < ( $105 >>> 0 ) ; if ( $106 ) { $107 = $3 ; $108 = ( ( ( $107 ) ) + 108 | 0 ) ; $109 = HEAP32 [ $108 >> 2 ] | 0 ; $110 = $5 ; $111 = ( ( $109 ) - ( $110 ) ) | 0 ; $112 = $3 ; $113 = ( ( ( $112 ) ) + 44 | 0 ) ; $114 = HEAP32 [ $113 >> 2 ] | 0 ; $115 = ( ( $114 ) - 262 ) | 0 ; $116 = ( $111 >>> 0 ) <= ( $115 >>> 0 ) ; if ( $116 ) { $117 = $3 ; $118 = $5 ; $119 = ( _longest_match ( $117 , $118 ) | 0 ) ; $120 = $3 ; $121 = ( ( ( $120 ) ) + 96 | 0 ) ; HEAP32 [ $121 >> 2 ] = $119 ; $122 = $3 ; $123 = ( ( ( $122 ) ) + 96 | 0 ) ; $124 = HEAP32 [ $123 >> 2 ] | 0 ; $125 = ( $124 >>> 0 ) <= ( 5 ) ; if ( $125 ) { $126 = $3 ; $127 = ( ( ( $126 ) ) + 136 | 0 ) ; $128 = HEAP32 [ $127 >> 2 ] | 0 ; $129 = ( $128 | 0 ) == ( 1 ) ; if ( $129 ) { $130 = $3 ; $131 = ( ( ( $130 ) ) + 96 | 0 ) ; HEAP32 [ $131 >> 2 ] = 2 ; } } } } } $132 = $3 ; $133 = ( ( ( $132 ) ) + 120 | 0 ) ; $134 = HEAP32 [ $133 >> 2 ] | 0 ; $135 = ( $134 >>> 0 ) >= ( 3 ) ; if ( $135 ) { $136 = $3 ; $137 = ( ( ( $136 ) ) + 96 | 0 ) ; $138 = HEAP32 [ $137 >> 2 ] | 0 ; $139 = $3 ; $140 = ( ( ( $139 ) ) + 120 | 0 ) ; $141 = HEAP32 [ $140 >> 2 ] | 0 ; $142 = ( $138 >>> 0 ) <= ( $141 >>> 0 ) ; if ( $142 ) { $143 = $3 ; $144 = ( ( ( $143 ) ) + 108 | 0 ) ; $145 = HEAP32 [ $144 >> 2 ] | 0 ; $146 = $3 ; $147 = ( ( ( $146 ) ) + 116 | 0 ) ; $148 = HEAP32 [ $147 >> 2 ] | 0 ; $149 = ( ( $145 ) + ( $148 ) ) | 0 ; $150 = ( ( $149 ) - 3 ) | 0 ; $7 = $150 ; $151 = $3 ; $152 = ( ( ( $151 ) ) + 120 | 0 ) ; $153 = HEAP32 [ $152 >> 2 ] | 0 ; $154 = ( ( $153 ) - 3 ) | 0 ; $155 = $154 & 255 ; $8 = $155 ; $156 = $3 ; $157 = ( ( ( $156 ) ) + 108 | 0 ) ; $158 = HEAP32 [ $157 >> 2 ] | 0 ; $159 = ( ( $158 ) - 1 ) | 0 ; $160 = $3 ; $161 = ( ( ( $160 ) ) + 100 | 0 ) ; $162 = HEAP32 [ $161 >> 2 ] | 0 ; $163 = ( ( $159 ) - ( $162 ) ) | 0 ; $164 = $163 & 65535 ; $9 = $164 ; $165 = $9 ; $166 = $3 ; $167 = ( ( ( $166 ) ) + 5796 | 0 ) ; $168 = HEAP32 [ $167 >> 2 ] | 0 ; $169 = $3 ; $170 = ( ( ( $169 ) ) + 5792 | 0 ) ; $171 = HEAP32 [ $170 >> 2 ] | 0 ; $172 = ( ( $168 ) + ( $171 << 1 ) | 0 ) ; HEAP16 [ $172 >> 1 ] = $165 ; $173 = $8 ; $174 = $3 ; $175 = ( ( ( $174 ) ) + 5784 | 0 ) ; $176 = HEAP32 [ $175 >> 2 ] | 0 ; $177 = $3 ; $178 = ( ( ( $177 ) ) + 5792 | 0 ) ; $179 = HEAP32 [ $178 >> 2 ] | 0 ; $180 = ( ( $179 ) + 1 ) | 0 ; HEAP32 [ $178 >> 2 ] = $180 ; $181 = ( ( $176 ) + ( $179 ) | 0 ) ; HEAP8 [ $181 >> 0 ] = $173 ; $182 = $9 ; $183 = ( ( $182 ) + - 1 ) << 16 >> 16 ; $9 = $183 ; $184 = $3 ; $185 = ( ( ( $184 ) ) + 148 | 0 ) ; $186 = $8 ; $187 = $186 & 255 ; $188 = ( 29272 + ( $187 ) | 0 ) ; $189 = HEAP8 [ $188 >> 0 ] | 0 ; $190 = $189 & 255 ; $191 = ( ( $190 ) + 256 ) | 0 ; $192 = ( ( $191 ) + 1 ) | 0 ; $193 = ( ( $185 ) + ( $192 << 2 ) | 0 ) ; $194 = HEAP16 [ $193 >> 1 ] | 0 ; $195 = ( ( $194 ) + 1 ) << 16 >> 16 ; HEAP16 [ $193 >> 1 ] = $195 ; $196 = $3 ; $197 = ( ( ( $196 ) ) + 2440 | 0 ) ; $198 = $9 ; $199 = $198 & 65535 ; $200 = ( $199 | 0 ) < ( 256 ) ; $201 = $9 ; $202 = $201 & 65535 ; $203 = $202 >> 7 ; $204 = ( 256 + ( $203 ) ) | 0 ; $$sink = $200 ? $202 : $204 ; $205 = ( 28760 + ( $$sink ) | 0 ) ; $206 = HEAP8 [ $205 >> 0 ] | 0 ; $207 = $206 & 255 ; $208 = ( ( $197 ) + ( $207 << 2 ) | 0 ) ; $209 = HEAP16 [ $208 >> 1 ] | 0 ; $210 = ( ( $209 ) + 1 ) << 16 >> 16 ; HEAP16 [ $208 >> 1 ] = $210 ; $211 = $3 ; $212 = ( ( ( $211 ) ) + 5792 | 0 ) ; $213 = HEAP32 [ $212 >> 2 ] | 0 ; $214 = $3 ; $215 = ( ( ( $214 ) ) + 5788 | 0 ) ; $216 = HEAP32 [ $215 >> 2 ] | 0 ; $217 = ( ( $216 ) - 1 ) | 0 ; $218 = ( $213 | 0 ) == ( $217 | 0 ) ; $219 = $218 & 1 ; $6 = $219 ; $220 = $3 ; $221 = ( ( ( $220 ) ) + 120 | 0 ) ; $222 = HEAP32 [ $221 >> 2 ] | 0 ; $223 = ( ( $222 ) - 1 ) | 0 ; $224 = $3 ; $225 = ( ( ( $224 ) ) + 116 | 0 ) ; $226 = HEAP32 [ $225 >> 2 ] | 0 ; $227 = ( ( $226 ) - ( $223 ) ) | 0 ; HEAP32 [ $225 >> 2 ] = $227 ; $228 = $3 ; $229 = ( ( ( $228 ) ) + 120 | 0 ) ; $230 = HEAP32 [ $229 >> 2 ] | 0 ; $231 = ( ( $230 ) - 2 ) | 0 ; HEAP32 [ $229 >> 2 ] = $231 ; while ( 1 ) { $232 = $3 ; $233 = ( ( ( $232 ) ) + 108 | 0 ) ; $234 = HEAP32 [ $233 >> 2 ] | 0 ; $235 = ( ( $234 ) + 1 ) | 0 ; HEAP32 [ $233 >> 2 ] = $235 ; $236 = $7 ; $237 = ( $235 >>> 0 ) <= ( $236 >>> 0 ) ; if ( $237 ) { $238 = $3 ; $239 = ( ( ( $238 ) ) + 72 | 0 ) ; $240 = HEAP32 [ $239 >> 2 ] | 0 ; $241 = $3 ; $242 = ( ( ( $241 ) ) + 88 | 0 ) ; $243 = HEAP32 [ $242 >> 2 ] | 0 ; $244 = $240 << $243 ; $245 = $3 ; $246 = ( ( ( $245 ) ) + 56 | 0 ) ; $247 = HEAP32 [ $246 >> 2 ] | 0 ; $248 = $3 ; $249 = ( ( ( $248 ) ) + 108 | 0 ) ; $250 = HEAP32 [ $249 >> 2 ] | 0 ; $251 = ( ( $250 ) + 2 ) | 0 ; $252 = ( ( $247 ) + ( $251 ) | 0 ) ; $253 = HEAP8 [ $252 >> 0 ] | 0 ; $254 = $253 & 255 ; $255 = $244 ^ $254 ; $256 = $3 ; $257 = ( ( ( $256 ) ) + 84 | 0 ) ; $258 = HEAP32 [ $257 >> 2 ] | 0 ; $259 = $255 & $258 ; $260 = $3 ; $261 = ( ( ( $260 ) ) + 72 | 0 ) ; HEAP32 [ $261 >> 2 ] = $259 ; $262 = $3 ; $263 = ( ( ( $262 ) ) + 68 | 0 ) ; $264 = HEAP32 [ $263 >> 2 ] | 0 ; $265 = $3 ; $266 = ( ( ( $265 ) ) + 72 | 0 ) ; $267 = HEAP32 [ $266 >> 2 ] | 0 ; $268 = ( ( $264 ) + ( $267 << 1 ) | 0 ) ; $269 = HEAP16 [ $268 >> 1 ] | 0 ; $270 = $3 ; $271 = ( ( ( $270 ) ) + 64 | 0 ) ; $272 = HEAP32 [ $271 >> 2 ] | 0 ; $273 = $3 ; $274 = ( ( ( $273 ) ) + 108 | 0 ) ; $275 = HEAP32 [ $274 >> 2 ] | 0 ; $276 = $3 ; $277 = ( ( ( $276 ) ) + 52 | 0 ) ; $278 = HEAP32 [ $277 >> 2 ] | 0 ; $279 = $275 & $278 ; $280 = ( ( $272 ) + ( $279 << 1 ) | 0 ) ; HEAP16 [ $280 >> 1 ] = $269 ; $281 = $269 & 65535 ; $5 = $281 ; $282 = $3 ; $283 = ( ( ( $282 ) ) + 108 | 0 ) ; $284 = HEAP32 [ $283 >> 2 ] | 0 ; $285 = $284 & 65535 ; $286 = $3 ; $287 = ( ( ( $286 ) ) + 68 | 0 ) ; $288 = HEAP32 [ $287 >> 2 ] | 0 ; $289 = $3 ; $290 = ( ( ( $289 ) ) + 72 | 0 ) ; $291 = HEAP32 [ $290 >> 2 ] | 0 ; $292 = ( ( $288 ) + ( $291 << 1 ) | 0 ) ; HEAP16 [ $292 >> 1 ] = $285 ; } $293 = $3 ; $294 = ( ( ( $293 ) ) + 120 | 0 ) ; $295 = HEAP32 [ $294 >> 2 ] | 0 ; $296 = ( ( $295 ) + - 1 ) | 0 ; HEAP32 [ $294 >> 2 ] = $296 ; $297 = ( $296 | 0 ) != ( 0 ) ; if ( ! ( $297 ) ) { break ; } } $298 = $3 ; $299 = ( ( ( $298 ) ) + 104 | 0 ) ; HEAP32 [ $299 >> 2 ] = 0 ; $300 = $3 ; $301 = ( ( ( $300 ) ) + 96 | 0 ) ; HEAP32 [ $301 >> 2 ] = 2 ; $302 = $3 ; $303 = ( ( ( $302 ) ) + 108 | 0 ) ; $304 = HEAP32 [ $303 >> 2 ] | 0 ; $305 = ( ( $304 ) + 1 ) | 0 ; HEAP32 [ $303 >> 2 ] = $305 ; $306 = $6 ; $307 = ( $306 | 0 ) != ( 0 ) ; if ( ! ( $307 ) ) { continue ; } $308 = $3 ; $309 = $3 ; $310 = ( ( ( $309 ) ) + 92 | 0 ) ; $311 = HEAP32 [ $310 >> 2 ] | 0 ; $312 = ( $311 | 0 ) >= ( 0 ) ; if ( $312 ) { $313 = $3 ; $314 = ( ( ( $313 ) ) + 56 | 0 ) ; $315 = HEAP32 [ $314 >> 2 ] | 0 ; $316 = $3 ; $317 = ( ( ( $316 ) ) + 92 | 0 ) ; $318 = HEAP32 [ $317 >> 2 ] | 0 ; $319 = ( ( $315 ) + ( $318 ) | 0 ) ; $327 = $319 ; } else { $327 = 0 ; } $320 = $3 ; $321 = ( ( ( $320 ) ) + 108 | 0 ) ; $322 = HEAP32 [ $321 >> 2 ] | 0 ; $323 = $3 ; $324 = ( ( ( $323 ) ) + 92 | 0 ) ; $325 = HEAP32 [ $324 >> 2 ] | 0 ; $326 = ( ( $322 ) - ( $325 ) ) | 0 ; __tr_flush_block ( $308 , $327 , $326 , 0 ) ; $328 = $3 ; $329 = ( ( ( $328 ) ) + 108 | 0 ) ; $330 = HEAP32 [ $329 >> 2 ] | 0 ; $331 = $3 ; $332 = ( ( ( $331 ) ) + 92 | 0 ) ; HEAP32 [ $332 >> 2 ] = $330 ; $333 = $3 ; $334 = HEAP32 [ $333 >> 2 ] | 0 ; _flush_pending ( $334 ) ; $335 = $3 ; $336 = HEAP32 [ $335 >> 2 ] | 0 ; $337 = ( ( ( $336 ) ) + 16 | 0 ) ; $338 = HEAP32 [ $337 >> 2 ] | 0 ; $339 = ( $338 | 0 ) == ( 0 ) ; if ( $339 ) { label = 24 ; break ; } else { continue ; } } } $340 = $3 ; $341 = ( ( ( $340 ) ) + 104 | 0 ) ; $342 = HEAP32 [ $341 >> 2 ] | 0 ; $343 = ( $342 | 0 ) != ( 0 ) ; $344 = $3 ; if ( ! ( $343 ) ) { $427 = ( ( ( $344 ) ) + 104 | 0 ) ; HEAP32 [ $427 >> 2 ] = 1 ; $428 = $3 ; $429 = ( ( ( $428 ) ) + 108 | 0 ) ; $430 = HEAP32 [ $429 >> 2 ] | 0 ; $431 = ( ( $430 ) + 1 ) | 0 ; HEAP32 [ $429 >> 2 ] = $431 ; $432 = $3 ; $433 = ( ( ( $432 ) ) + 116 | 0 ) ; $434 = HEAP32 [ $433 >> 2 ] | 0 ; $435 = ( ( $434 ) + - 1 ) | 0 ; HEAP32 [ $433 >> 2 ] = $435 ; continue ; } $345 = ( ( ( $344 ) ) + 56 | 0 ) ; $346 = HEAP32 [ $345 >> 2 ] | 0 ; $347 = $3 ; $348 = ( ( ( $347 ) ) + 108 | 0 ) ; $349 = HEAP32 [ $348 >> 2 ] | 0 ; $350 = ( ( $349 ) - 1 ) | 0 ; $351 = ( ( $346 ) + ( $350 ) | 0 ) ; $352 = HEAP8 [ $351 >> 0 ] | 0 ; $10 = $352 ; $353 = $3 ; $354 = ( ( ( $353 ) ) + 5796 | 0 ) ; $355 = HEAP32 [ $354 >> 2 ] | 0 ; $356 = $3 ; $357 = ( ( ( $356 ) ) + 5792 | 0 ) ; $358 = HEAP32 [ $357 >> 2 ] | 0 ; $359 = ( ( $355 ) + ( $358 << 1 ) | 0 ) ; HEAP16 [ $359 >> 1 ] = 0 ; $360 = $10 ; $361 = $3 ; $362 = ( ( ( $361 ) ) + 5784 | 0 ) ; $363 = HEAP32 [ $362 >> 2 ] | 0 ; $364 = $3 ; $365 = ( ( ( $364 ) ) + 5792 | 0 ) ; $366 = HEAP32 [ $365 >> 2 ] | 0 ; $367 = ( ( $366 ) + 1 ) | 0 ; HEAP32 [ $365 >> 2 ] = $367 ; $368 = ( ( $363 ) + ( $366 ) | 0 ) ; HEAP8 [ $368 >> 0 ] = $360 ; $369 = $3 ; $370 = ( ( ( $369 ) ) + 148 | 0 ) ; $371 = $10 ; $372 = $371 & 255 ; $373 = ( ( $370 ) + ( $372 << 2 ) | 0 ) ; $374 = HEAP16 [ $373 >> 1 ] | 0 ; $375 = ( ( $374 ) + 1 ) << 16 >> 16 ; HEAP16 [ $373 >> 1 ] = $375 ; $376 = $3 ; $377 = ( ( ( $376 ) ) + 5792 | 0 ) ; $378 = HEAP32 [ $377 >> 2 ] | 0 ; $379 = $3 ; $380 = ( ( ( $379 ) ) + 5788 | 0 ) ; $381 = HEAP32 [ $380 >> 2 ] | 0 ; $382 = ( ( $381 ) - 1 ) | 0 ; $383 = ( $378 | 0 ) == ( $382 | 0 ) ; $384 = $383 & 1 ; $6 = $384 ; $385 = $6 ; $386 = ( $385 | 0 ) != ( 0 ) ; if ( $386 ) { $387 = $3 ; $388 = $3 ; $389 = ( ( ( $388 ) ) + 92 | 0 ) ; $390 = HEAP32 [ $389 >> 2 ] | 0 ; $391 = ( $390 | 0 ) >= ( 0 ) ; if ( $391 ) { $392 = $3 ; $393 = ( ( ( $392 ) ) + 56 | 0 ) ; $394 = HEAP32 [ $393 >> 2 ] | 0 ; $395 = $3 ; $396 = ( ( ( $395 ) ) + 92 | 0 ) ; $397 = HEAP32 [ $396 >> 2 ] | 0 ; $398 = ( ( $394 ) + ( $397 ) | 0 ) ; $406 = $398 ; } else { $406 = 0 ; } $399 = $3 ; $400 = ( ( ( $399 ) ) + 108 | 0 ) ; $401 = HEAP32 [ $400 >> 2 ] | 0 ; $402 = $3 ; $403 = ( ( ( $402 ) ) + 92 | 0 ) ; $404 = HEAP32 [ $403 >> 2 ] | 0 ; $405 = ( ( $401 ) - ( $404 ) ) | 0 ; __tr_flush_block ( $387 , $406 , $405 , 0 ) ; $407 = $3 ; $408 = ( ( ( $407 ) ) + 108 | 0 ) ; $409 = HEAP32 [ $408 >> 2 ] | 0 ; $410 = $3 ; $411 = ( ( ( $410 ) ) + 92 | 0 ) ; HEAP32 [ $411 >> 2 ] = $409 ; $412 = $3 ; $413 = HEAP32 [ $412 >> 2 ] | 0 ; _flush_pending ( $413 ) ; } $414 = $3 ; $415 = ( ( ( $414 ) ) + 108 | 0 ) ; $416 = HEAP32 [ $415 >> 2 ] | 0 ; $417 = ( ( $416 ) + 1 ) | 0 ; HEAP32 [ $415 >> 2 ] = $417 ; $418 = $3 ; $419 = ( ( ( $418 ) ) + 116 | 0 ) ; $420 = HEAP32 [ $419 >> 2 ] | 0 ; $421 = ( ( $420 ) + - 1 ) | 0 ; HEAP32 [ $419 >> 2 ] = $421 ; $422 = $3 ; $423 = HEAP32 [ $422 >> 2 ] | 0 ; $424 = ( ( ( $423 ) ) + 16 | 0 ) ; $425 = HEAP32 [ $424 >> 2 ] | 0 ; $426 = ( $425 | 0 ) == ( 0 ) ; if ( $426 ) { label = 31 ; break ; } } if ( ( label | 0 ) == 4 ) { $2 = 0 ; $562 = $2 ; STACKTOP = sp ; return ( $562 | 0 ) ; } else if ( ( label | 0 ) == 24 ) { $2 = 0 ; $562 = $2 ; STACKTOP = sp ; return ( $562 | 0 ) ; } else if ( ( label | 0 ) == 31 ) { $2 = 0 ; $562 = $2 ; STACKTOP = sp ; return ( $562 | 0 ) ; } else if ( ( label | 0 ) == 33 ) { $436 = $3 ; $437 = ( ( ( $436 ) ) + 104 | 0 ) ; $438 = HEAP32 [ $437 >> 2 ] | 0 ; $439 = ( $438 | 0 ) != ( 0 ) ; if ( $439 ) { $440 = $3 ; $441 = ( ( ( $440 ) ) + 56 | 0 ) ; $442 = HEAP32 [ $441 >> 2 ] | 0 ; $443 = $3 ; $444 = ( ( ( $443 ) ) + 108 | 0 ) ; $445 = HEAP32 [ $444 >> 2 ] | 0 ; $446 = ( ( $445 ) - 1 ) | 0 ; $447 = ( ( $442 ) + ( $446 ) | 0 ) ; $448 = HEAP8 [ $447 >> 0 ] | 0 ; $11 = $448 ; $449 = $3 ; $450 = ( ( ( $449 ) ) + 5796 | 0 ) ; $451 = HEAP32 [ $450 >> 2 ] | 0 ; $452 = $3 ; $453 = ( ( ( $452 ) ) + 5792 | 0 ) ; $454 = HEAP32 [ $453 >> 2 ] | 0 ; $455 = ( ( $451 ) + ( $454 << 1 ) | 0 ) ; HEAP16 [ $455 >> 1 ] = 0 ; $456 = $11 ; $457 = $3 ; $458 = ( ( ( $457 ) ) + 5784 | 0 ) ; $459 = HEAP32 [ $458 >> 2 ] | 0 ; $460 = $3 ; $461 = ( ( ( $460 ) ) + 5792 | 0 ) ; $462 = HEAP32 [ $461 >> 2 ] | 0 ; $463 = ( ( $462 ) + 1 ) | 0 ; HEAP32 [ $461 >> 2 ] = $463 ; $464 = ( ( $459 ) + ( $462 ) | 0 ) ; HEAP8 [ $464 >> 0 ] = $456 ; $465 = $3 ; $466 = ( ( ( $465 ) ) + 148 | 0 ) ; $467 = $11 ; $468 = $467 & 255 ; $469 = ( ( $466 ) + ( $468 << 2 ) | 0 ) ; $470 = HEAP16 [ $469 >> 1 ] | 0 ; $471 = ( ( $470 ) + 1 ) << 16 >> 16 ; HEAP16 [ $469 >> 1 ] = $471 ; $472 = $3 ; $473 = ( ( ( $472 ) ) + 5792 | 0 ) ; $474 = HEAP32 [ $473 >> 2 ] | 0 ; $475 = $3 ; $476 = ( ( ( $475 ) ) + 5788 | 0 ) ; $477 = HEAP32 [ $476 >> 2 ] | 0 ; $478 = ( ( $477 ) - 1 ) | 0 ; $479 = ( $474 | 0 ) == ( $478 | 0 ) ; $480 = $479 & 1 ; $6 = $480 ; $481 = $3 ; $482 = ( ( ( $481 ) ) + 104 | 0 ) ; HEAP32 [ $482 >> 2 ] = 0 ; } $483 = $3 ; $484 = ( ( ( $483 ) ) + 108 | 0 ) ; $485 = HEAP32 [ $484 >> 2 ] | 0 ; $486 = ( $485 >>> 0 ) < ( 2 ) ; if ( $486 ) { $487 = $3 ; $488 = ( ( ( $487 ) ) + 108 | 0 ) ; $489 = HEAP32 [ $488 >> 2 ] | 0 ; $492 = $489 ; } else { $492 = 2 ; } $490 = $3 ; $491 = ( ( ( $490 ) ) + 5812 | 0 ) ; HEAP32 [ $491 >> 2 ] = $492 ; $493 = $4 ; $494 = ( $493 | 0 ) == ( 4 ) ; $495 = $3 ; if ( $494 ) { $496 = $3 ; $497 = ( ( ( $496 ) ) + 92 | 0 ) ; $498 = HEAP32 [ $497 >> 2 ] | 0 ; $499 = ( $498 | 0 ) >= ( 0 ) ; if ( $499 ) { $500 = $3 ; $501 = ( ( ( $500 ) ) + 56 | 0 ) ; $502 = HEAP32 [ $501 >> 2 ] | 0 ; $503 = $3 ; $504 = ( ( ( $503 ) ) + 92 | 0 ) ; $505 = HEAP32 [ $504 >> 2 ] | 0 ; $506 = ( ( $502 ) + ( $505 ) | 0 ) ; $514 = $506 ; } else { $514 = 0 ; } $507 = $3 ; $508 = ( ( ( $507 ) ) + 108 | 0 ) ; $509 = HEAP32 [ $508 >> 2 ] | 0 ; $510 = $3 ; $511 = ( ( ( $510 ) ) + 92 | 0 ) ; $512 = HEAP32 [ $511 >> 2 ] | 0 ; $513 = ( ( $509 ) - ( $512 ) ) | 0 ; __tr_flush_block ( $495 , $514 , $513 , 1 ) ; $515 = $3 ; $516 = ( ( ( $515 ) ) + 108 | 0 ) ; $517 = HEAP32 [ $516 >> 2 ] | 0 ; $518 = $3 ; $519 = ( ( ( $518 ) ) + 92 | 0 ) ; HEAP32 [ $519 >> 2 ] = $517 ; $520 = $3 ; $521 = HEAP32 [ $520 >> 2 ] | 0 ; _flush_pending ( $521 ) ; $522 = $3 ; $523 = HEAP32 [ $522 >> 2 ] | 0 ; $524 = ( ( ( $523 ) ) + 16 | 0 ) ; $525 = HEAP32 [ $524 >> 2 ] | 0 ; $526 = ( $525 | 0 ) == ( 0 ) ; if ( $526 ) { $2 = 2 ; $562 = $2 ; STACKTOP = sp ; return ( $562 | 0 ) ; } else { $2 = 3 ; $562 = $2 ; STACKTOP = sp ; return ( $562 | 0 ) ; } } $527 = ( ( ( $495 ) ) + 5792 | 0 ) ; $528 = HEAP32 [ $527 >> 2 ] | 0 ; $529 = ( $528 | 0 ) != ( 0 ) ; if ( $529 ) { $530 = $3 ; $531 = $3 ; $532 = ( ( ( $531 ) ) + 92 | 0 ) ; $533 = HEAP32 [ $532 >> 2 ] | 0 ; $534 = ( $533 | 0 ) >= ( 0 ) ; if ( $534 ) { $535 = $3 ; $536 = ( ( ( $535 ) ) + 56 | 0 ) ; $537 = HEAP32 [ $536 >> 2 ] | 0 ; $538 = $3 ; $539 = ( ( ( $538 ) ) + 92 | 0 ) ; $540 = HEAP32 [ $539 >> 2 ] | 0 ; $541 = ( ( $537 ) + ( $540 ) | 0 ) ; $549 = $541 ; } else { $549 = 0 ; } $542 = $3 ; $543 = ( ( ( $542 ) ) + 108 | 0 ) ; $544 = HEAP32 [ $543 >> 2 ] | 0 ; $545 = $3 ; $546 = ( ( ( $545 ) ) + 92 | 0 ) ; $547 = HEAP32 [ $546 >> 2 ] | 0 ; $548 = ( ( $544 ) - ( $547 ) ) | 0 ; __tr_flush_block ( $530 , $549 , $548 , 0 ) ; $550 = $3 ; $551 = ( ( ( $550 ) ) + 108 | 0 ) ; $552 = HEAP32 [ $551 >> 2 ] | 0 ; $553 = $3 ; $554 = ( ( ( $553 ) ) + 92 | 0 ) ; HEAP32 [ $554 >> 2 ] = $552 ; $555 = $3 ; $556 = HEAP32 [ $555 >> 2 ] | 0 ; _flush_pending ( $556 ) ; $557 = $3 ; $558 = HEAP32 [ $557 >> 2 ] | 0 ; $559 = ( ( ( $558 ) ) + 16 | 0 ) ; $560 = HEAP32 [ $559 >> 2 ] | 0 ; $561 = ( $560 | 0 ) == ( 0 ) ; if ( $561 ) { $2 = 0 ; $562 = $2 ; STACKTOP = sp ; return ( $562 | 0 ) ; } } $2 = 1 ; $562 = $2 ; STACKTOP = sp ; return ( $562 | 0 ) ; } return ( 0 ) | 0 ; } function _fill_window ( $0 ) { $0 = $0 | 0 ; var $$ = 0 , $1 = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 ; var $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 ; var $134 = 0 , $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 ; var $152 = 0 , $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 ; var $170 = 0 , $171 = 0 , $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 ; var $189 = 0 , $19 = 0 , $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $2 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 ; var $206 = 0 , $207 = 0 , $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 ; var $224 = 0 , $225 = 0 , $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 ; var $242 = 0 , $243 = 0 , $244 = 0 , $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 , $258 = 0 , $259 = 0 , $26 = 0 ; var $260 = 0 , $261 = 0 , $262 = 0 , $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 , $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 , $270 = 0 , $271 = 0 , $272 = 0 , $273 = 0 , $274 = 0 , $275 = 0 , $276 = 0 , $277 = 0 , $278 = 0 ; var $279 = 0 , $28 = 0 , $280 = 0 , $281 = 0 , $282 = 0 , $283 = 0 , $284 = 0 , $285 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 ; var $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 ; var $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 ; var $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 ; var $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $1 = $0 ; $8 = $1 ; $9 = ( ( ( $8 ) ) + 44 | 0 ) ; $10 = HEAP32 [ $9 >> 2 ] | 0 ; $4 = $10 ; while ( 1 ) { $11 = $1 ; $12 = ( ( ( $11 ) ) + 60 | 0 ) ; $13 = HEAP32 [ $12 >> 2 ] | 0 ; $14 = $1 ; $15 = ( ( ( $14 ) ) + 116 | 0 ) ; $16 = HEAP32 [ $15 >> 2 ] | 0 ; $17 = ( ( $13 ) - ( $16 ) ) | 0 ; $18 = $1 ; $19 = ( ( ( $18 ) ) + 108 | 0 ) ; $20 = HEAP32 [ $19 >> 2 ] | 0 ; $21 = ( ( $17 ) - ( $20 ) ) | 0 ; $3 = $21 ; $22 = $1 ; $23 = ( ( ( $22 ) ) + 108 | 0 ) ; $24 = HEAP32 [ $23 >> 2 ] | 0 ; $25 = $4 ; $26 = $1 ; $27 = ( ( ( $26 ) ) + 44 | 0 ) ; $28 = HEAP32 [ $27 >> 2 ] | 0 ; $29 = ( ( $28 ) - 262 ) | 0 ; $30 = ( ( $25 ) + ( $29 ) ) | 0 ; $31 = ( $24 >>> 0 ) >= ( $30 >>> 0 ) ; if ( $31 ) { $32 = $1 ; $33 = ( ( ( $32 ) ) + 56 | 0 ) ; $34 = HEAP32 [ $33 >> 2 ] | 0 ; $35 = $1 ; $36 = ( ( ( $35 ) ) + 56 | 0 ) ; $37 = HEAP32 [ $36 >> 2 ] | 0 ; $38 = $4 ; $39 = ( ( $37 ) + ( $38 ) | 0 ) ; $40 = $4 ; $41 = $3 ; $42 = ( ( $40 ) - ( $41 ) ) | 0 ; _memcpy ( ( $34 | 0 ) , ( $39 | 0 ) , ( $42 | 0 ) ) | 0 ; $43 = $4 ; $44 = $1 ; $45 = ( ( ( $44 ) ) + 112 | 0 ) ; $46 = HEAP32 [ $45 >> 2 ] | 0 ; $47 = ( ( $46 ) - ( $43 ) ) | 0 ; HEAP32 [ $45 >> 2 ] = $47 ; $48 = $4 ; $49 = $1 ; $50 = ( ( ( $49 ) ) + 108 | 0 ) ; $51 = HEAP32 [ $50 >> 2 ] | 0 ; $52 = ( ( $51 ) - ( $48 ) ) | 0 ; HEAP32 [ $50 >> 2 ] = $52 ; $53 = $4 ; $54 = $1 ; $55 = ( ( ( $54 ) ) + 92 | 0 ) ; $56 = HEAP32 [ $55 >> 2 ] | 0 ; $57 = ( ( $56 ) - ( $53 ) ) | 0 ; HEAP32 [ $55 >> 2 ] = $57 ; $58 = $1 ; _slide_hash ( $58 ) ; $59 = $4 ; $60 = $3 ; $61 = ( ( $60 ) + ( $59 ) ) | 0 ; $3 = $61 ; } $62 = $1 ; $63 = HEAP32 [ $62 >> 2 ] | 0 ; $64 = ( ( ( $63 ) ) + 4 | 0 ) ; $65 = HEAP32 [ $64 >> 2 ] | 0 ; $66 = ( $65 | 0 ) == ( 0 ) ; if ( $66 ) { break ; } $67 = $1 ; $68 = HEAP32 [ $67 >> 2 ] | 0 ; $69 = $1 ; $70 = ( ( ( $69 ) ) + 56 | 0 ) ; $71 = HEAP32 [ $70 >> 2 ] | 0 ; $72 = $1 ; $73 = ( ( ( $72 ) ) + 108 | 0 ) ; $74 = HEAP32 [ $73 >> 2 ] | 0 ; $75 = ( ( $71 ) + ( $74 ) | 0 ) ; $76 = $1 ; $77 = ( ( ( $76 ) ) + 116 | 0 ) ; $78 = HEAP32 [ $77 >> 2 ] | 0 ; $79 = ( ( $75 ) + ( $78 ) | 0 ) ; $80 = $3 ; $81 = ( _read_buf ( $68 , $79 , $80 ) | 0 ) ; $2 = $81 ; $82 = $2 ; $83 = $1 ; $84 = ( ( ( $83 ) ) + 116 | 0 ) ; $85 = HEAP32 [ $84 >> 2 ] | 0 ; $86 = ( ( $85 ) + ( $82 ) ) | 0 ; HEAP32 [ $84 >> 2 ] = $86 ; $87 = $1 ; $88 = ( ( ( $87 ) ) + 116 | 0 ) ; $89 = HEAP32 [ $88 >> 2 ] | 0 ; $90 = $1 ; $91 = ( ( ( $90 ) ) + 5812 | 0 ) ; $92 = HEAP32 [ $91 >> 2 ] | 0 ; $93 = ( ( $89 ) + ( $92 ) ) | 0 ; $94 = ( $93 >>> 0 ) >= ( 3 ) ; L7 : do { if ( $94 ) { $95 = $1 ; $96 = ( ( ( $95 ) ) + 108 | 0 ) ; $97 = HEAP32 [ $96 >> 2 ] | 0 ; $98 = $1 ; $99 = ( ( ( $98 ) ) + 5812 | 0 ) ; $100 = HEAP32 [ $99 >> 2 ] | 0 ; $101 = ( ( $97 ) - ( $100 ) ) | 0 ; $5 = $101 ; $102 = $1 ; $103 = ( ( ( $102 ) ) + 56 | 0 ) ; $104 = HEAP32 [ $103 >> 2 ] | 0 ; $105 = $5 ; $106 = ( ( $104 ) + ( $105 ) | 0 ) ; $107 = HEAP8 [ $106 >> 0 ] | 0 ; $108 = $107 & 255 ; $109 = $1 ; $110 = ( ( ( $109 ) ) + 72 | 0 ) ; HEAP32 [ $110 >> 2 ] = $108 ; $111 = $1 ; $112 = ( ( ( $111 ) ) + 72 | 0 ) ; $113 = HEAP32 [ $112 >> 2 ] | 0 ; $114 = $1 ; $115 = ( ( ( $114 ) ) + 88 | 0 ) ; $116 = HEAP32 [ $115 >> 2 ] | 0 ; $117 = $113 << $116 ; $118 = $1 ; $119 = ( ( ( $118 ) ) + 56 | 0 ) ; $120 = HEAP32 [ $119 >> 2 ] | 0 ; $121 = $5 ; $122 = ( ( $121 ) + 1 ) | 0 ; $123 = ( ( $120 ) + ( $122 ) | 0 ) ; $124 = HEAP8 [ $123 >> 0 ] | 0 ; $125 = $124 & 255 ; $126 = $117 ^ $125 ; $127 = $1 ; $128 = ( ( ( $127 ) ) + 84 | 0 ) ; $129 = HEAP32 [ $128 >> 2 ] | 0 ; $130 = $126 & $129 ; $131 = $1 ; $132 = ( ( ( $131 ) ) + 72 | 0 ) ; HEAP32 [ $132 >> 2 ] = $130 ; while ( 1 ) { $133 = $1 ; $134 = ( ( ( $133 ) ) + 5812 | 0 ) ; $135 = HEAP32 [ $134 >> 2 ] | 0 ; $136 = ( $135 | 0 ) != ( 0 ) ; if ( ! ( $136 ) ) { break L7 ; } $137 = $1 ; $138 = ( ( ( $137 ) ) + 72 | 0 ) ; $139 = HEAP32 [ $138 >> 2 ] | 0 ; $140 = $1 ; $141 = ( ( ( $140 ) ) + 88 | 0 ) ; $142 = HEAP32 [ $141 >> 2 ] | 0 ; $143 = $139 << $142 ; $144 = $1 ; $145 = ( ( ( $144 ) ) + 56 | 0 ) ; $146 = HEAP32 [ $145 >> 2 ] | 0 ; $147 = $5 ; $148 = ( ( $147 ) + 3 ) | 0 ; $149 = ( ( $148 ) - 1 ) | 0 ; $150 = ( ( $146 ) + ( $149 ) | 0 ) ; $151 = HEAP8 [ $150 >> 0 ] | 0 ; $152 = $151 & 255 ; $153 = $143 ^ $152 ; $154 = $1 ; $155 = ( ( ( $154 ) ) + 84 | 0 ) ; $156 = HEAP32 [ $155 >> 2 ] | 0 ; $157 = $153 & $156 ; $158 = $1 ; $159 = ( ( ( $158 ) ) + 72 | 0 ) ; HEAP32 [ $159 >> 2 ] = $157 ; $160 = $1 ; $161 = ( ( ( $160 ) ) + 68 | 0 ) ; $162 = HEAP32 [ $161 >> 2 ] | 0 ; $163 = $1 ; $164 = ( ( ( $163 ) ) + 72 | 0 ) ; $165 = HEAP32 [ $164 >> 2 ] | 0 ; $166 = ( ( $162 ) + ( $165 << 1 ) | 0 ) ; $167 = HEAP16 [ $166 >> 1 ] | 0 ; $168 = $1 ; $169 = ( ( ( $168 ) ) + 64 | 0 ) ; $170 = HEAP32 [ $169 >> 2 ] | 0 ; $171 = $5 ; $172 = $1 ; $173 = ( ( ( $172 ) ) + 52 | 0 ) ; $174 = HEAP32 [ $173 >> 2 ] | 0 ; $175 = $171 & $174 ; $176 = ( ( $170 ) + ( $175 << 1 ) | 0 ) ; HEAP16 [ $176 >> 1 ] = $167 ; $177 = $5 ; $178 = $177 & 65535 ; $179 = $1 ; $180 = ( ( ( $179 ) ) + 68 | 0 ) ; $181 = HEAP32 [ $180 >> 2 ] | 0 ; $182 = $1 ; $183 = ( ( ( $182 ) ) + 72 | 0 ) ; $184 = HEAP32 [ $183 >> 2 ] | 0 ; $185 = ( ( $181 ) + ( $184 << 1 ) | 0 ) ; HEAP16 [ $185 >> 1 ] = $178 ; $186 = $5 ; $187 = ( ( $186 ) + 1 ) | 0 ; $5 = $187 ; $188 = $1 ; $189 = ( ( ( $188 ) ) + 5812 | 0 ) ; $190 = HEAP32 [ $189 >> 2 ] | 0 ; $191 = ( ( $190 ) + - 1 ) | 0 ; HEAP32 [ $189 >> 2 ] = $191 ; $192 = $1 ; $193 = ( ( ( $192 ) ) + 116 | 0 ) ; $194 = HEAP32 [ $193 >> 2 ] | 0 ; $195 = $1 ; $196 = ( ( ( $195 ) ) + 5812 | 0 ) ; $197 = HEAP32 [ $196 >> 2 ] | 0 ; $198 = ( ( $194 ) + ( $197 ) ) | 0 ; $199 = ( $198 >>> 0 ) < ( 3 ) ; if ( $199 ) { break ; } } } } while ( 0 ) ; $200 = $1 ; $201 = ( ( ( $200 ) ) + 116 | 0 ) ; $202 = HEAP32 [ $201 >> 2 ] | 0 ; $203 = ( $202 >>> 0 ) < ( 262 ) ; if ( ! ( $203 ) ) { break ; } $204 = $1 ; $205 = HEAP32 [ $204 >> 2 ] | 0 ; $206 = ( ( ( $205 ) ) + 4 | 0 ) ; $207 = HEAP32 [ $206 >> 2 ] | 0 ; $208 = ( $207 | 0 ) != ( 0 ) ; if ( ! ( $208 ) ) { break ; } } $209 = $1 ; $210 = ( ( ( $209 ) ) + 5824 | 0 ) ; $211 = HEAP32 [ $210 >> 2 ] | 0 ; $212 = $1 ; $213 = ( ( ( $212 ) ) + 60 | 0 ) ; $214 = HEAP32 [ $213 >> 2 ] | 0 ; $215 = ( $211 >>> 0 ) < ( $214 >>> 0 ) ; if ( ! ( $215 ) ) { STACKTOP = sp ; return ; } $216 = $1 ; $217 = ( ( ( $216 ) ) + 108 | 0 ) ; $218 = HEAP32 [ $217 >> 2 ] | 0 ; $219 = $1 ; $220 = ( ( ( $219 ) ) + 116 | 0 ) ; $221 = HEAP32 [ $220 >> 2 ] | 0 ; $222 = ( ( $218 ) + ( $221 ) ) | 0 ; $6 = $222 ; $223 = $1 ; $224 = ( ( ( $223 ) ) + 5824 | 0 ) ; $225 = HEAP32 [ $224 >> 2 ] | 0 ; $226 = $6 ; $227 = ( $225 >>> 0 ) < ( $226 >>> 0 ) ; $228 = $1 ; if ( $227 ) { $229 = ( ( ( $228 ) ) + 60 | 0 ) ; $230 = HEAP32 [ $229 >> 2 ] | 0 ; $231 = $6 ; $232 = ( ( $230 ) - ( $231 ) ) | 0 ; $7 = $232 ; $233 = $7 ; $234 = ( $233 >>> 0 ) > ( 258 ) ; $$ = $234 ? 258 : $232 ; $7 = $$ ; $235 = $1 ; $236 = ( ( ( $235 ) ) + 56 | 0 ) ; $237 = HEAP32 [ $236 >> 2 ] | 0 ; $238 = $6 ; $239 = ( ( $237 ) + ( $238 ) | 0 ) ; $240 = $7 ; _memset ( ( $239 | 0 ) , 0 , ( $240 | 0 ) ) | 0 ; $241 = $6 ; $242 = $7 ; $243 = ( ( $241 ) + ( $242 ) ) | 0 ; $244 = $1 ; $245 = ( ( ( $244 ) ) + 5824 | 0 ) ; HEAP32 [ $245 >> 2 ] = $243 ; STACKTOP = sp ; return ; } $246 = ( ( ( $228 ) ) + 5824 | 0 ) ; $247 = HEAP32 [ $246 >> 2 ] | 0 ; $248 = $6 ; $249 = ( ( $248 ) + 258 ) | 0 ; $250 = ( $247 >>> 0 ) < ( $249 >>> 0 ) ; if ( ! ( $250 ) ) { STACKTOP = sp ; return ; } $251 = $6 ; $252 = ( ( $251 ) + 258 ) | 0 ; $253 = $1 ; $254 = ( ( ( $253 ) ) + 5824 | 0 ) ; $255 = HEAP32 [ $254 >> 2 ] | 0 ; $256 = ( ( $252 ) - ( $255 ) ) | 0 ; $7 = $256 ; $257 = $7 ; $258 = $1 ; $259 = ( ( ( $258 ) ) + 60 | 0 ) ; $260 = HEAP32 [ $259 >> 2 ] | 0 ; $261 = $1 ; $262 = ( ( ( $261 ) ) + 5824 | 0 ) ; $263 = HEAP32 [ $262 >> 2 ] | 0 ; $264 = ( ( $260 ) - ( $263 ) ) | 0 ; $265 = ( $257 >>> 0 ) > ( $264 >>> 0 ) ; if ( $265 ) { $266 = $1 ; $267 = ( ( ( $266 ) ) + 60 | 0 ) ; $268 = HEAP32 [ $267 >> 2 ] | 0 ; $269 = $1 ; $270 = ( ( ( $269 ) ) + 5824 | 0 ) ; $271 = HEAP32 [ $270 >> 2 ] | 0 ; $272 = ( ( $268 ) - ( $271 ) ) | 0 ; $7 = $272 ; } $273 = $1 ; $274 = ( ( ( $273 ) ) + 56 | 0 ) ; $275 = HEAP32 [ $274 >> 2 ] | 0 ; $276 = $1 ; $277 = ( ( ( $276 ) ) + 5824 | 0 ) ; $278 = HEAP32 [ $277 >> 2 ] | 0 ; $279 = ( ( $275 ) + ( $278 ) | 0 ) ; $280 = $7 ; _memset ( ( $279 | 0 ) , 0 , ( $280 | 0 ) ) | 0 ; $281 = $7 ; $282 = $1 ; $283 = ( ( ( $282 ) ) + 5824 | 0 ) ; $284 = HEAP32 [ $283 >> 2 ] | 0 ; $285 = ( ( $284 ) + ( $281 ) ) | 0 ; HEAP32 [ $283 >> 2 ] = $285 ; STACKTOP = sp ; return ; } function _longest_match ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 ; var $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 ; var $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 ; var $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 ; var $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $2 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 ; var $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 ; var $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 ; var $244 = 0 , $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 ; var $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 ; var $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 ; var $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 ; var $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 64 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 64 | 0 ) ; $3 = $0 ; $4 = $1 ; $17 = $3 ; $18 = ( ( ( $17 ) ) + 124 | 0 ) ; $19 = HEAP32 [ $18 >> 2 ] | 0 ; $5 = $19 ; $20 = $3 ; $21 = ( ( ( $20 ) ) + 56 | 0 ) ; $22 = HEAP32 [ $21 >> 2 ] | 0 ; $23 = $3 ; $24 = ( ( ( $23 ) ) + 108 | 0 ) ; $25 = HEAP32 [ $24 >> 2 ] | 0 ; $26 = ( ( $22 ) + ( $25 ) | 0 ) ; $6 = $26 ; $27 = $3 ; $28 = ( ( ( $27 ) ) + 120 | 0 ) ; $29 = HEAP32 [ $28 >> 2 ] | 0 ; $9 = $29 ; $30 = $3 ; $31 = ( ( ( $30 ) ) + 144 | 0 ) ; $32 = HEAP32 [ $31 >> 2 ] | 0 ; $10 = $32 ; $33 = $3 ; $34 = ( ( ( $33 ) ) + 108 | 0 ) ; $35 = HEAP32 [ $34 >> 2 ] | 0 ; $36 = $3 ; $37 = ( ( ( $36 ) ) + 44 | 0 ) ; $38 = HEAP32 [ $37 >> 2 ] | 0 ; $39 = ( ( $38 ) - 262 ) | 0 ; $40 = ( $35 >>> 0 ) > ( $39 >>> 0 ) ; if ( $40 ) { $41 = $3 ; $42 = ( ( ( $41 ) ) + 108 | 0 ) ; $43 = HEAP32 [ $42 >> 2 ] | 0 ; $44 = $3 ; $45 = ( ( ( $44 ) ) + 44 | 0 ) ; $46 = HEAP32 [ $45 >> 2 ] | 0 ; $47 = ( ( $46 ) - 262 ) | 0 ; $48 = ( ( $43 ) - ( $47 ) ) | 0 ; $49 = $48 ; } else { $49 = 0 ; } $11 = $49 ; $50 = $3 ; $51 = ( ( ( $50 ) ) + 64 | 0 ) ; $52 = HEAP32 [ $51 >> 2 ] | 0 ; $12 = $52 ; $53 = $3 ; $54 = ( ( ( $53 ) ) + 52 | 0 ) ; $55 = HEAP32 [ $54 >> 2 ] | 0 ; $13 = $55 ; $56 = $3 ; $57 = ( ( ( $56 ) ) + 56 | 0 ) ; $58 = HEAP32 [ $57 >> 2 ] | 0 ; $59 = $3 ; $60 = ( ( ( $59 ) ) + 108 | 0 ) ; $61 = HEAP32 [ $60 >> 2 ] | 0 ; $62 = ( ( $58 ) + ( $61 ) | 0 ) ; $63 = ( ( ( $62 ) ) + 258 | 0 ) ; $14 = $63 ; $64 = $6 ; $65 = $9 ; $66 = ( ( $65 ) - 1 ) | 0 ; $67 = ( ( $64 ) + ( $66 ) | 0 ) ; $68 = HEAP8 [ $67 >> 0 ] | 0 ; $15 = $68 ; $69 = $6 ; $70 = $9 ; $71 = ( ( $69 ) + ( $70 ) | 0 ) ; $72 = HEAP8 [ $71 >> 0 ] | 0 ; $16 = $72 ; $73 = $3 ; $74 = ( ( ( $73 ) ) + 120 | 0 ) ; $75 = HEAP32 [ $74 >> 2 ] | 0 ; $76 = $3 ; $77 = ( ( ( $76 ) ) + 140 | 0 ) ; $78 = HEAP32 [ $77 >> 2 ] | 0 ; $79 = ( $75 >>> 0 ) >= ( $78 >>> 0 ) ; if ( $79 ) { $80 = $5 ; $81 = $80 >>> 2 ; $5 = $81 ; } $82 = $10 ; $83 = $3 ; $84 = ( ( ( $83 ) ) + 116 | 0 ) ; $85 = HEAP32 [ $84 >> 2 ] | 0 ; $86 = ( $82 >>> 0 ) > ( $85 >>> 0 ) ; if ( $86 ) { $87 = $3 ; $88 = ( ( ( $87 ) ) + 116 | 0 ) ; $89 = HEAP32 [ $88 >> 2 ] | 0 ; $10 = $89 ; } while ( 1 ) { $90 = $3 ; $91 = ( ( ( $90 ) ) + 56 | 0 ) ; $92 = HEAP32 [ $91 >> 2 ] | 0 ; $93 = $4 ; $94 = ( ( $92 ) + ( $93 ) | 0 ) ; $7 = $94 ; $95 = $7 ; $96 = $9 ; $97 = ( ( $95 ) + ( $96 ) | 0 ) ; $98 = HEAP8 [ $97 >> 0 ] | 0 ; $99 = $98 & 255 ; $100 = $16 ; $101 = $100 & 255 ; $102 = ( $99 | 0 ) != ( $101 | 0 ) ; if ( ! ( $102 ) ) { $103 = $7 ; $104 = $9 ; $105 = ( ( $104 ) - 1 ) | 0 ; $106 = ( ( $103 ) + ( $105 ) | 0 ) ; $107 = HEAP8 [ $106 >> 0 ] | 0 ; $108 = $107 & 255 ; $109 = $15 ; $110 = $109 & 255 ; $111 = ( $108 | 0 ) != ( $110 | 0 ) ; if ( ! ( $111 ) ) { $112 = $7 ; $113 = HEAP8 [ $112 >> 0 ] | 0 ; $114 = $113 & 255 ; $115 = $6 ; $116 = HEAP8 [ $115 >> 0 ] | 0 ; $117 = $116 & 255 ; $118 = ( $114 | 0 ) != ( $117 | 0 ) ; if ( ! ( $118 ) ) { $119 = $7 ; $120 = ( ( ( $119 ) ) + 1 | 0 ) ; $7 = $120 ; $121 = HEAP8 [ $120 >> 0 ] | 0 ; $122 = $121 & 255 ; $123 = $6 ; $124 = ( ( ( $123 ) ) + 1 | 0 ) ; $125 = HEAP8 [ $124 >> 0 ] | 0 ; $126 = $125 & 255 ; $127 = ( $122 | 0 ) != ( $126 | 0 ) ; if ( ! ( $127 ) ) { $128 = $6 ; $129 = ( ( ( $128 ) ) + 2 | 0 ) ; $6 = $129 ; $130 = $7 ; $131 = ( ( ( $130 ) ) + 1 | 0 ) ; $7 = $131 ; while ( 1 ) { $132 = $6 ; $133 = ( ( ( $132 ) ) + 1 | 0 ) ; $6 = $133 ; $134 = HEAP8 [ $133 >> 0 ] | 0 ; $135 = $134 & 255 ; $136 = $7 ; $137 = ( ( ( $136 ) ) + 1 | 0 ) ; $7 = $137 ; $138 = HEAP8 [ $137 >> 0 ] | 0 ; $139 = $138 & 255 ; $140 = ( $135 | 0 ) == ( $139 | 0 ) ; if ( ! ( $140 ) ) { break ; } $141 = $6 ; $142 = ( ( ( $141 ) ) + 1 | 0 ) ; $6 = $142 ; $143 = HEAP8 [ $142 >> 0 ] | 0 ; $144 = $143 & 255 ; $145 = $7 ; $146 = ( ( ( $145 ) ) + 1 | 0 ) ; $7 = $146 ; $147 = HEAP8 [ $146 >> 0 ] | 0 ; $148 = $147 & 255 ; $149 = ( $144 | 0 ) == ( $148 | 0 ) ; if ( ! ( $149 ) ) { break ; } $150 = $6 ; $151 = ( ( ( $150 ) ) + 1 | 0 ) ; $6 = $151 ; $152 = HEAP8 [ $151 >> 0 ] | 0 ; $153 = $152 & 255 ; $154 = $7 ; $155 = ( ( ( $154 ) ) + 1 | 0 ) ; $7 = $155 ; $156 = HEAP8 [ $155 >> 0 ] | 0 ; $157 = $156 & 255 ; $158 = ( $153 | 0 ) == ( $157 | 0 ) ; if ( ! ( $158 ) ) { break ; } $159 = $6 ; $160 = ( ( ( $159 ) ) + 1 | 0 ) ; $6 = $160 ; $161 = HEAP8 [ $160 >> 0 ] | 0 ; $162 = $161 & 255 ; $163 = $7 ; $164 = ( ( ( $163 ) ) + 1 | 0 ) ; $7 = $164 ; $165 = HEAP8 [ $164 >> 0 ] | 0 ; $166 = $165 & 255 ; $167 = ( $162 | 0 ) == ( $166 | 0 ) ; if ( ! ( $167 ) ) { break ; } $168 = $6 ; $169 = ( ( ( $168 ) ) + 1 | 0 ) ; $6 = $169 ; $170 = HEAP8 [ $169 >> 0 ] | 0 ; $171 = $170 & 255 ; $172 = $7 ; $173 = ( ( ( $172 ) ) + 1 | 0 ) ; $7 = $173 ; $174 = HEAP8 [ $173 >> 0 ] | 0 ; $175 = $174 & 255 ; $176 = ( $171 | 0 ) == ( $175 | 0 ) ; if ( ! ( $176 ) ) { break ; } $177 = $6 ; $178 = ( ( ( $177 ) ) + 1 | 0 ) ; $6 = $178 ; $179 = HEAP8 [ $178 >> 0 ] | 0 ; $180 = $179 & 255 ; $181 = $7 ; $182 = ( ( ( $181 ) ) + 1 | 0 ) ; $7 = $182 ; $183 = HEAP8 [ $182 >> 0 ] | 0 ; $184 = $183 & 255 ; $185 = ( $180 | 0 ) == ( $184 | 0 ) ; if ( ! ( $185 ) ) { break ; } $186 = $6 ; $187 = ( ( ( $186 ) ) + 1 | 0 ) ; $6 = $187 ; $188 = HEAP8 [ $187 >> 0 ] | 0 ; $189 = $188 & 255 ; $190 = $7 ; $191 = ( ( ( $190 ) ) + 1 | 0 ) ; $7 = $191 ; $192 = HEAP8 [ $191 >> 0 ] | 0 ; $193 = $192 & 255 ; $194 = ( $189 | 0 ) == ( $193 | 0 ) ; if ( ! ( $194 ) ) { break ; } $195 = $6 ; $196 = ( ( ( $195 ) ) + 1 | 0 ) ; $6 = $196 ; $197 = HEAP8 [ $196 >> 0 ] | 0 ; $198 = $197 & 255 ; $199 = $7 ; $200 = ( ( ( $199 ) ) + 1 | 0 ) ; $7 = $200 ; $201 = HEAP8 [ $200 >> 0 ] | 0 ; $202 = $201 & 255 ; $203 = ( $198 | 0 ) == ( $202 | 0 ) ; if ( ! ( $203 ) ) { break ; } $204 = $6 ; $205 = $14 ; $206 = ( $204 >>> 0 ) < ( $205 >>> 0 ) ; if ( ! ( $206 ) ) { break ; } } $207 = $14 ; $208 = $6 ; $209 = $207 ; $210 = $208 ; $211 = ( ( $209 ) - ( $210 ) ) | 0 ; $212 = ( 258 - ( $211 ) ) | 0 ; $8 = $212 ; $213 = $14 ; $214 = ( ( ( $213 ) ) + - 258 | 0 ) ; $6 = $214 ; $215 = $8 ; $216 = $9 ; $217 = ( $215 | 0 ) > ( $216 | 0 ) ; if ( $217 ) { $218 = $4 ; $219 = $3 ; $220 = ( ( ( $219 ) ) + 112 | 0 ) ; HEAP32 [ $220 >> 2 ] = $218 ; $221 = $8 ; $9 = $221 ; $222 = $8 ; $223 = $10 ; $224 = ( $222 | 0 ) >= ( $223 | 0 ) ; if ( $224 ) { break ; } $225 = $6 ; $226 = $9 ; $227 = ( ( $226 ) - 1 ) | 0 ; $228 = ( ( $225 ) + ( $227 ) | 0 ) ; $229 = HEAP8 [ $228 >> 0 ] | 0 ; $15 = $229 ; $230 = $6 ; $231 = $9 ; $232 = ( ( $230 ) + ( $231 ) | 0 ) ; $233 = HEAP8 [ $232 >> 0 ] | 0 ; $16 = $233 ; } } } } } $234 = $12 ; $235 = $4 ; $236 = $13 ; $237 = $235 & $236 ; $238 = ( ( $234 ) + ( $237 << 1 ) | 0 ) ; $239 = HEAP16 [ $238 >> 1 ] | 0 ; $240 = $239 & 65535 ; $4 = $240 ; $241 = $11 ; $242 = ( $240 >>> 0 ) > ( $241 >>> 0 ) ; if ( ! ( $242 ) ) { break ; } $243 = $5 ; $244 = ( ( $243 ) + - 1 ) | 0 ; $5 = $244 ; $245 = ( $244 | 0 ) != ( 0 ) ; if ( ! ( $245 ) ) { break ; } } $246 = $9 ; $247 = $3 ; $248 = ( ( ( $247 ) ) + 116 | 0 ) ; $249 = HEAP32 [ $248 >> 2 ] | 0 ; $250 = ( $246 >>> 0 ) <= ( $249 >>> 0 ) ; if ( $250 ) { $251 = $9 ; $2 = $251 ; $255 = $2 ; STACKTOP = sp ; return ( $255 | 0 ) ; } else { $252 = $3 ; $253 = ( ( ( $252 ) ) + 116 | 0 ) ; $254 = HEAP32 [ $253 >> 2 ] | 0 ; $2 = $254 ; $255 = $2 ; STACKTOP = sp ; return ( $255 | 0 ) ; } return ( 0 ) | 0 ; } function _flush_pending ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 ; var $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 ; var $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $7 = 0 , $8 = 0 ; var $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $4 = $1 ; $5 = ( ( ( $4 ) ) + 28 | 0 ) ; $6 = HEAP32 [ $5 >> 2 ] | 0 ; $3 = $6 ; $7 = $3 ; __tr_flush_bits ( $7 ) ; $8 = $3 ; $9 = ( ( ( $8 ) ) + 20 | 0 ) ; $10 = HEAP32 [ $9 >> 2 ] | 0 ; $2 = $10 ; $11 = $2 ; $12 = $1 ; $13 = ( ( ( $12 ) ) + 16 | 0 ) ; $14 = HEAP32 [ $13 >> 2 ] | 0 ; $15 = ( $11 >>> 0 ) > ( $14 >>> 0 ) ; if ( $15 ) { $16 = $1 ; $17 = ( ( ( $16 ) ) + 16 | 0 ) ; $18 = HEAP32 [ $17 >> 2 ] | 0 ; $2 = $18 ; } $19 = $2 ; $20 = ( $19 | 0 ) == ( 0 ) ; if ( $20 ) { STACKTOP = sp ; return ; } $21 = $1 ; $22 = ( ( ( $21 ) ) + 12 | 0 ) ; $23 = HEAP32 [ $22 >> 2 ] | 0 ; $24 = $3 ; $25 = ( ( ( $24 ) ) + 16 | 0 ) ; $26 = HEAP32 [ $25 >> 2 ] | 0 ; $27 = $2 ; _memcpy ( ( $23 | 0 ) , ( $26 | 0 ) , ( $27 | 0 ) ) | 0 ; $28 = $2 ; $29 = $1 ; $30 = ( ( ( $29 ) ) + 12 | 0 ) ; $31 = HEAP32 [ $30 >> 2 ] | 0 ; $32 = ( ( $31 ) + ( $28 ) | 0 ) ; HEAP32 [ $30 >> 2 ] = $32 ; $33 = $2 ; $34 = $3 ; $35 = ( ( ( $34 ) ) + 16 | 0 ) ; $36 = HEAP32 [ $35 >> 2 ] | 0 ; $37 = ( ( $36 ) + ( $33 ) | 0 ) ; HEAP32 [ $35 >> 2 ] = $37 ; $38 = $2 ; $39 = $1 ; $40 = ( ( ( $39 ) ) + 20 | 0 ) ; $41 = HEAP32 [ $40 >> 2 ] | 0 ; $42 = ( ( $41 ) + ( $38 ) ) | 0 ; HEAP32 [ $40 >> 2 ] = $42 ; $43 = $2 ; $44 = $1 ; $45 = ( ( ( $44 ) ) + 16 | 0 ) ; $46 = HEAP32 [ $45 >> 2 ] | 0 ; $47 = ( ( $46 ) - ( $43 ) ) | 0 ; HEAP32 [ $45 >> 2 ] = $47 ; $48 = $2 ; $49 = $3 ; $50 = ( ( ( $49 ) ) + 20 | 0 ) ; $51 = HEAP32 [ $50 >> 2 ] | 0 ; $52 = ( ( $51 ) - ( $48 ) ) | 0 ; HEAP32 [ $50 >> 2 ] = $52 ; $53 = $3 ; $54 = ( ( ( $53 ) ) + 20 | 0 ) ; $55 = HEAP32 [ $54 >> 2 ] | 0 ; $56 = ( $55 | 0 ) == ( 0 ) ; if ( ! ( $56 ) ) { STACKTOP = sp ; return ; } $57 = $3 ; $58 = ( ( ( $57 ) ) + 8 | 0 ) ; $59 = HEAP32 [ $58 >> 2 ] | 0 ; $60 = $3 ; $61 = ( ( ( $60 ) ) + 16 | 0 ) ; HEAP32 [ $61 >> 2 ] = $59 ; STACKTOP = sp ; return ; } function _slide_hash ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 ; var $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 ; var $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $1 = $0 ; $6 = $1 ; $7 = ( ( ( $6 ) ) + 44 | 0 ) ; $8 = HEAP32 [ $7 >> 2 ] | 0 ; $5 = $8 ; $9 = $1 ; $10 = ( ( ( $9 ) ) + 76 | 0 ) ; $11 = HEAP32 [ $10 >> 2 ] | 0 ; $2 = $11 ; $12 = $1 ; $13 = ( ( ( $12 ) ) + 68 | 0 ) ; $14 = HEAP32 [ $13 >> 2 ] | 0 ; $15 = $2 ; $16 = ( ( $14 ) + ( $15 << 1 ) | 0 ) ; $4 = $16 ; while ( 1 ) { $17 = $4 ; $18 = ( ( ( $17 ) ) + - 2 | 0 ) ; $4 = $18 ; $19 = HEAP16 [ $18 >> 1 ] | 0 ; $20 = $19 & 65535 ; $3 = $20 ; $21 = $3 ; $22 = $5 ; $23 = ( $21 >>> 0 ) >= ( $22 >>> 0 ) ; if ( $23 ) { $24 = $3 ; $25 = $5 ; $26 = ( ( $24 ) - ( $25 ) ) | 0 ; $28 = $26 ; } else { $28 = 0 ; } $27 = $28 & 65535 ; $29 = $4 ; HEAP16 [ $29 >> 1 ] = $27 ; $30 = $2 ; $31 = ( ( $30 ) + - 1 ) | 0 ; $2 = $31 ; $32 = ( $31 | 0 ) != ( 0 ) ; if ( ! ( $32 ) ) { break ; } } $33 = $5 ; $2 = $33 ; $34 = $1 ; $35 = ( ( ( $34 ) ) + 64 | 0 ) ; $36 = HEAP32 [ $35 >> 2 ] | 0 ; $37 = $2 ; $38 = ( ( $36 ) + ( $37 << 1 ) | 0 ) ; $4 = $38 ; while ( 1 ) { $39 = $4 ; $40 = ( ( ( $39 ) ) + - 2 | 0 ) ; $4 = $40 ; $41 = HEAP16 [ $40 >> 1 ] | 0 ; $42 = $41 & 65535 ; $3 = $42 ; $43 = $3 ; $44 = $5 ; $45 = ( $43 >>> 0 ) >= ( $44 >>> 0 ) ; if ( $45 ) { $46 = $3 ; $47 = $5 ; $48 = ( ( $46 ) - ( $47 ) ) | 0 ; $50 = $48 ; } else { $50 = 0 ; } $49 = $50 & 65535 ; $51 = $4 ; HEAP16 [ $51 >> 1 ] = $49 ; $52 = $2 ; $53 = ( ( $52 ) + - 1 ) | 0 ; $2 = $53 ; $54 = ( $53 | 0 ) != ( 0 ) ; if ( ! ( $54 ) ) { break ; } } STACKTOP = sp ; return ; } function _read_buf ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 ; var $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $8 = $4 ; $9 = ( ( ( $8 ) ) + 4 | 0 ) ; $10 = HEAP32 [ $9 >> 2 ] | 0 ; $7 = $10 ; $11 = $7 ; $12 = $6 ; $13 = ( $11 >>> 0 ) > ( $12 >>> 0 ) ; if ( $13 ) { $14 = $6 ; $7 = $14 ; } $15 = $7 ; $16 = ( $15 | 0 ) == ( 0 ) ; if ( $16 ) { $3 = 0 ; $50 = $3 ; STACKTOP = sp ; return ( $50 | 0 ) ; } $17 = $7 ; $18 = $4 ; $19 = ( ( ( $18 ) ) + 4 | 0 ) ; $20 = HEAP32 [ $19 >> 2 ] | 0 ; $21 = ( ( $20 ) - ( $17 ) ) | 0 ; HEAP32 [ $19 >> 2 ] = $21 ; $22 = $5 ; $23 = $4 ; $24 = HEAP32 [ $23 >> 2 ] | 0 ; $25 = $7 ; _memcpy ( ( $22 | 0 ) , ( $24 | 0 ) , ( $25 | 0 ) ) | 0 ; $26 = $4 ; $27 = ( ( ( $26 ) ) + 28 | 0 ) ; $28 = HEAP32 [ $27 >> 2 ] | 0 ; $29 = ( ( ( $28 ) ) + 24 | 0 ) ; $30 = HEAP32 [ $29 >> 2 ] | 0 ; $31 = ( $30 | 0 ) == ( 1 ) ; if ( $31 ) { $32 = $4 ; $33 = ( ( ( $32 ) ) + 48 | 0 ) ; $34 = HEAP32 [ $33 >> 2 ] | 0 ; $35 = $5 ; $36 = $7 ; $37 = ( _adler32 ( $34 , $35 , $36 ) | 0 ) ; $38 = $4 ; $39 = ( ( ( $38 ) ) + 48 | 0 ) ; HEAP32 [ $39 >> 2 ] = $37 ; } $40 = $7 ; $41 = $4 ; $42 = HEAP32 [ $41 >> 2 ] | 0 ; $43 = ( ( $42 ) + ( $40 ) | 0 ) ; HEAP32 [ $41 >> 2 ] = $43 ; $44 = $7 ; $45 = $4 ; $46 = ( ( ( $45 ) ) + 8 | 0 ) ; $47 = HEAP32 [ $46 >> 2 ] | 0 ; $48 = ( ( $47 ) + ( $44 ) ) | 0 ; HEAP32 [ $46 >> 2 ] = $48 ; $49 = $7 ; $3 = $49 ; $50 = $3 ; STACKTOP = sp ; return ( $50 | 0 ) ; } function _deflateStateCheck ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 ; var $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 ; var $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = $0 ; $4 = $2 ; $5 = ( $4 | 0 ) == ( 0 | 0 ) ; if ( ! ( $5 ) ) { $6 = $2 ; $7 = ( ( ( $6 ) ) + 32 | 0 ) ; $8 = HEAP32 [ $7 >> 2 ] | 0 ; $9 = ( $8 | 0 ) == ( 0 | 0 ) ; if ( ! ( $9 ) ) { $10 = $2 ; $11 = ( ( ( $10 ) ) + 36 | 0 ) ; $12 = HEAP32 [ $11 >> 2 ] | 0 ; $13 = ( $12 | 0 ) == ( 0 | 0 ) ; if ( ! ( $13 ) ) { $14 = $2 ; $15 = ( ( ( $14 ) ) + 28 | 0 ) ; $16 = HEAP32 [ $15 >> 2 ] | 0 ; $3 = $16 ; $17 = $3 ; $18 = ( $17 | 0 ) == ( 0 | 0 ) ; do { if ( ! ( $18 ) ) { $19 = $3 ; $20 = HEAP32 [ $19 >> 2 ] | 0 ; $21 = $2 ; $22 = ( $20 | 0 ) != ( $21 | 0 ) ; if ( ! ( $22 ) ) { $23 = $3 ; $24 = ( ( ( $23 ) ) + 4 | 0 ) ; $25 = HEAP32 [ $24 >> 2 ] | 0 ; $26 = ( $25 | 0 ) != ( 42 ) ; if ( $26 ) { $27 = $3 ; $28 = ( ( ( $27 ) ) + 4 | 0 ) ; $29 = HEAP32 [ $28 >> 2 ] | 0 ; $30 = ( $29 | 0 ) != ( 69 ) ; if ( $30 ) { $31 = $3 ; $32 = ( ( ( $31 ) ) + 4 | 0 ) ; $33 = HEAP32 [ $32 >> 2 ] | 0 ; $34 = ( $33 | 0 ) != ( 73 ) ; if ( $34 ) { $35 = $3 ; $36 = ( ( ( $35 ) ) + 4 | 0 ) ; $37 = HEAP32 [ $36 >> 2 ] | 0 ; $38 = ( $37 | 0 ) != ( 91 ) ; if ( $38 ) { $39 = $3 ; $40 = ( ( ( $39 ) ) + 4 | 0 ) ; $41 = HEAP32 [ $40 >> 2 ] | 0 ; $42 = ( $41 | 0 ) != ( 103 ) ; if ( $42 ) { $43 = $3 ; $44 = ( ( ( $43 ) ) + 4 | 0 ) ; $45 = HEAP32 [ $44 >> 2 ] | 0 ; $46 = ( $45 | 0 ) != ( 113 ) ; if ( $46 ) { $47 = $3 ; $48 = ( ( ( $47 ) ) + 4 | 0 ) ; $49 = HEAP32 [ $48 >> 2 ] | 0 ; $50 = ( $49 | 0 ) != ( 666 ) ; if ( $50 ) { break ; } } } } } } } $1 = 0 ; $51 = $1 ; STACKTOP = sp ; return ( $51 | 0 ) ; } } } while ( 0 ) ; $1 = 1 ; $51 = $1 ; STACKTOP = sp ; return ( $51 | 0 ) ; } } } $1 = 1 ; $51 = $1 ; STACKTOP = sp ; return ( $51 | 0 ) ; } function _deflate ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 ; var $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 ; var $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 ; var $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 ; var $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $2 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 ; var $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 ; var $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 ; var $244 = 0 , $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 , $258 = 0 , $259 = 0 , $26 = 0 , $260 = 0 , $261 = 0 ; var $262 = 0 , $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 , $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 , $270 = 0 , $271 = 0 , $272 = 0 , $273 = 0 , $274 = 0 , $275 = 0 , $276 = 0 , $277 = 0 , $278 = 0 , $279 = 0 , $28 = 0 ; var $280 = 0 , $281 = 0 , $282 = 0 , $283 = 0 , $284 = 0 , $285 = 0 , $286 = 0 , $287 = 0 , $288 = 0 , $289 = 0 , $29 = 0 , $290 = 0 , $291 = 0 , $292 = 0 , $293 = 0 , $294 = 0 , $295 = 0 , $296 = 0 , $297 = 0 , $298 = 0 ; var $299 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 ; var $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 ; var $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 ; var $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $or$cond = 0 , $or$cond11 = 0 ; var $or$cond3 = 0 , $or$cond5 = 0 , $or$cond7 = 0 , $or$cond9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $3 = $0 ; $4 = $1 ; $10 = $3 ; $11 = ( _deflateStateCheck ( $10 ) | 0 ) ; $12 = ( $11 | 0 ) != ( 0 ) ; $13 = $4 ; $14 = ( $13 | 0 ) > ( 5 ) ; $or$cond = $12 | $14 ; $15 = $4 ; $16 = ( $15 | 0 ) < ( 0 ) ; $or$cond3 = $or$cond | $16 ; if ( $or$cond3 ) { $2 = - 2 ; $299 = $2 ; STACKTOP = sp ; return ( $299 | 0 ) ; } $17 = $3 ; $18 = ( ( ( $17 ) ) + 28 | 0 ) ; $19 = HEAP32 [ $18 >> 2 ] | 0 ; $6 = $19 ; $20 = $3 ; $21 = ( ( ( $20 ) ) + 12 | 0 ) ; $22 = HEAP32 [ $21 >> 2 ] | 0 ; $23 = ( $22 | 0 ) == ( 0 | 0 ) ; do { if ( ! ( $23 ) ) { $24 = $3 ; $25 = ( ( ( $24 ) ) + 4 | 0 ) ; $26 = HEAP32 [ $25 >> 2 ] | 0 ; $27 = ( $26 | 0 ) != ( 0 ) ; if ( $27 ) { $28 = $3 ; $29 = HEAP32 [ $28 >> 2 ] | 0 ; $30 = ( $29 | 0 ) == ( 0 | 0 ) ; if ( $30 ) { break ; } } $31 = $6 ; $32 = ( ( ( $31 ) ) + 4 | 0 ) ; $33 = HEAP32 [ $32 >> 2 ] | 0 ; $34 = ( $33 | 0 ) == ( 666 ) ; $35 = $4 ; $36 = ( $35 | 0 ) != ( 4 ) ; $or$cond5 = $34 & $36 ; if ( ! ( $or$cond5 ) ) { $40 = $3 ; $41 = ( ( ( $40 ) ) + 16 | 0 ) ; $42 = HEAP32 [ $41 >> 2 ] | 0 ; $43 = ( $42 | 0 ) == ( 0 ) ; if ( $43 ) { $44 = HEAP32 [ ( 9440 ) >> 2 ] | 0 ; $45 = $3 ; $46 = ( ( ( $45 ) ) + 24 | 0 ) ; HEAP32 [ $46 >> 2 ] = $44 ; $2 = - 5 ; $299 = $2 ; STACKTOP = sp ; return ( $299 | 0 ) ; } $47 = $6 ; $48 = ( ( ( $47 ) ) + 40 | 0 ) ; $49 = HEAP32 [ $48 >> 2 ] | 0 ; $5 = $49 ; $50 = $4 ; $51 = $6 ; $52 = ( ( ( $51 ) ) + 40 | 0 ) ; HEAP32 [ $52 >> 2 ] = $50 ; $53 = $6 ; $54 = ( ( ( $53 ) ) + 20 | 0 ) ; $55 = HEAP32 [ $54 >> 2 ] | 0 ; $56 = ( $55 | 0 ) != ( 0 ) ; $57 = $3 ; if ( $56 ) { _flush_pending ( $57 ) ; $58 = $3 ; $59 = ( ( ( $58 ) ) + 16 | 0 ) ; $60 = HEAP32 [ $59 >> 2 ] | 0 ; $61 = ( $60 | 0 ) == ( 0 ) ; if ( $61 ) { $62 = $6 ; $63 = ( ( ( $62 ) ) + 40 | 0 ) ; HEAP32 [ $63 >> 2 ] = - 1 ; $2 = 0 ; $299 = $2 ; STACKTOP = sp ; return ( $299 | 0 ) ; } } else { $64 = ( ( ( $57 ) ) + 4 | 0 ) ; $65 = HEAP32 [ $64 >> 2 ] | 0 ; $66 = ( $65 | 0 ) == ( 0 ) ; if ( $66 ) { $67 = $4 ; $68 = $67 << 1 ; $69 = $4 ; $70 = ( $69 | 0 ) > ( 4 ) ; $71 = $70 ? 9 : 0 ; $72 = ( ( $68 ) - ( $71 ) ) | 0 ; $73 = $5 ; $74 = $73 << 1 ; $75 = $5 ; $76 = ( $75 | 0 ) > ( 4 ) ; $77 = $76 ? 9 : 0 ; $78 = ( ( $74 ) - ( $77 ) ) | 0 ; $79 = ( $72 | 0 ) <= ( $78 | 0 ) ; $80 = $4 ; $81 = ( $80 | 0 ) != ( 4 ) ; $or$cond7 = $79 & $81 ; if ( $or$cond7 ) { $82 = HEAP32 [ ( 9440 ) >> 2 ] | 0 ; $83 = $3 ; $84 = ( ( ( $83 ) ) + 24 | 0 ) ; HEAP32 [ $84 >> 2 ] = $82 ; $2 = - 5 ; $299 = $2 ; STACKTOP = sp ; return ( $299 | 0 ) ; } } } $85 = $6 ; $86 = ( ( ( $85 ) ) + 4 | 0 ) ; $87 = HEAP32 [ $86 >> 2 ] | 0 ; $88 = ( $87 | 0 ) == ( 666 ) ; if ( $88 ) { $89 = $3 ; $90 = ( ( ( $89 ) ) + 4 | 0 ) ; $91 = HEAP32 [ $90 >> 2 ] | 0 ; $92 = ( $91 | 0 ) != ( 0 ) ; if ( $92 ) { $93 = HEAP32 [ ( 9440 ) >> 2 ] | 0 ; $94 = $3 ; $95 = ( ( ( $94 ) ) + 24 | 0 ) ; HEAP32 [ $95 >> 2 ] = $93 ; $2 = - 5 ; $299 = $2 ; STACKTOP = sp ; return ( $299 | 0 ) ; } } $96 = $6 ; $97 = ( ( ( $96 ) ) + 4 | 0 ) ; $98 = HEAP32 [ $97 >> 2 ] | 0 ; $99 = ( $98 | 0 ) == ( 42 ) ; if ( $99 ) { $100 = $6 ; $101 = ( ( ( $100 ) ) + 48 | 0 ) ; $102 = HEAP32 [ $101 >> 2 ] | 0 ; $103 = ( ( $102 ) - 8 ) | 0 ; $104 = $103 << 4 ; $105 = ( 8 + ( $104 ) ) | 0 ; $106 = $105 << 8 ; $7 = $106 ; $107 = $6 ; $108 = ( ( ( $107 ) ) + 136 | 0 ) ; $109 = HEAP32 [ $108 >> 2 ] | 0 ; $110 = ( $109 | 0 ) >= ( 2 ) ; do { if ( $110 ) { label = 22 ; } else { $111 = $6 ; $112 = ( ( ( $111 ) ) + 132 | 0 ) ; $113 = HEAP32 [ $112 >> 2 ] | 0 ; $114 = ( $113 | 0 ) < ( 2 ) ; if ( $114 ) { label = 22 ; } else { $115 = $6 ; $116 = ( ( ( $115 ) ) + 132 | 0 ) ; $117 = HEAP32 [ $116 >> 2 ] | 0 ; $118 = ( $117 | 0 ) < ( 6 ) ; if ( $118 ) { $8 = 1 ; break ; } $119 = $6 ; $120 = ( ( ( $119 ) ) + 132 | 0 ) ; $121 = HEAP32 [ $120 >> 2 ] | 0 ; $122 = ( $121 | 0 ) == ( 6 ) ; if ( $122 ) { $8 = 2 ; break ; } else { $8 = 3 ; break ; } } } } while ( 0 ) ; if ( ( label | 0 ) == 22 ) { $8 = 0 ; } $123 = $8 ; $124 = $123 << 6 ; $125 = $7 ; $126 = $125 | $124 ; $7 = $126 ; $127 = $6 ; $128 = ( ( ( $127 ) ) + 108 | 0 ) ; $129 = HEAP32 [ $128 >> 2 ] | 0 ; $130 = ( $129 | 0 ) != ( 0 ) ; if ( $130 ) { $131 = $7 ; $132 = $131 | 32 ; $7 = $132 ; } $133 = $7 ; $134 = ( ( $133 >>> 0 ) % 31 ) & - 1 ; $135 = ( 31 - ( $134 ) ) | 0 ; $136 = $7 ; $137 = ( ( $136 ) + ( $135 ) ) | 0 ; $7 = $137 ; $138 = $6 ; $139 = $7 ; _putShortMSB ( $138 , $139 ) ; $140 = $6 ; $141 = ( ( ( $140 ) ) + 108 | 0 ) ; $142 = HEAP32 [ $141 >> 2 ] | 0 ; $143 = ( $142 | 0 ) != ( 0 ) ; if ( $143 ) { $144 = $6 ; $145 = $3 ; $146 = ( ( ( $145 ) ) + 48 | 0 ) ; $147 = HEAP32 [ $146 >> 2 ] | 0 ; $148 = $147 >>> 16 ; _putShortMSB ( $144 , $148 ) ; $149 = $6 ; $150 = $3 ; $151 = ( ( ( $150 ) ) + 48 | 0 ) ; $152 = HEAP32 [ $151 >> 2 ] | 0 ; $153 = $152 & 65535 ; _putShortMSB ( $149 , $153 ) ; } $154 = ( _adler32 ( 0 , 0 , 0 ) | 0 ) ; $155 = $3 ; $156 = ( ( ( $155 ) ) + 48 | 0 ) ; HEAP32 [ $156 >> 2 ] = $154 ; $157 = $6 ; $158 = ( ( ( $157 ) ) + 4 | 0 ) ; HEAP32 [ $158 >> 2 ] = 113 ; $159 = $3 ; _flush_pending ( $159 ) ; $160 = $6 ; $161 = ( ( ( $160 ) ) + 20 | 0 ) ; $162 = HEAP32 [ $161 >> 2 ] | 0 ; $163 = ( $162 | 0 ) != ( 0 ) ; if ( $163 ) { $164 = $6 ; $165 = ( ( ( $164 ) ) + 40 | 0 ) ; HEAP32 [ $165 >> 2 ] = - 1 ; $2 = 0 ; $299 = $2 ; STACKTOP = sp ; return ( $299 | 0 ) ; } } $166 = $3 ; $167 = ( ( ( $166 ) ) + 4 | 0 ) ; $168 = HEAP32 [ $167 >> 2 ] | 0 ; $169 = ( $168 | 0 ) != ( 0 ) ; if ( $169 ) { label = 38 ; } else { $170 = $6 ; $171 = ( ( ( $170 ) ) + 116 | 0 ) ; $172 = HEAP32 [ $171 >> 2 ] | 0 ; $173 = ( $172 | 0 ) != ( 0 ) ; if ( $173 ) { label = 38 ; } else { $174 = $4 ; $175 = ( $174 | 0 ) != ( 0 ) ; if ( $175 ) { $176 = $6 ; $177 = ( ( ( $176 ) ) + 4 | 0 ) ; $178 = HEAP32 [ $177 >> 2 ] | 0 ; $179 = ( $178 | 0 ) != ( 666 ) ; if ( $179 ) { label = 38 ; } } } } if ( ( label | 0 ) == 38 ) { $180 = $6 ; $181 = ( ( ( $180 ) ) + 132 | 0 ) ; $182 = HEAP32 [ $181 >> 2 ] | 0 ; $183 = ( $182 | 0 ) == ( 0 ) ; $184 = $6 ; do { if ( $183 ) { $185 = $4 ; $186 = ( _deflate_stored ( $184 , $185 ) | 0 ) ; $207 = $186 ; } else { $187 = ( ( ( $184 ) ) + 136 | 0 ) ; $188 = HEAP32 [ $187 >> 2 ] | 0 ; $189 = ( $188 | 0 ) == ( 2 ) ; $190 = $6 ; if ( $189 ) { $191 = $4 ; $192 = ( _deflate_huff ( $190 , $191 ) | 0 ) ; $207 = $192 ; break ; } $193 = ( ( ( $190 ) ) + 136 | 0 ) ; $194 = HEAP32 [ $193 >> 2 ] | 0 ; $195 = ( $194 | 0 ) == ( 3 ) ; $196 = $6 ; if ( $195 ) { $197 = $4 ; $198 = ( _deflate_rle ( $196 , $197 ) | 0 ) ; $207 = $198 ; break ; } else { $199 = ( ( ( $196 ) ) + 132 | 0 ) ; $200 = HEAP32 [ $199 >> 2 ] | 0 ; $201 = ( 8684 + ( ( $200 * 12 ) | 0 ) | 0 ) ; $202 = ( ( ( $201 ) ) + 8 | 0 ) ; $203 = HEAP32 [ $202 >> 2 ] | 0 ; $204 = $6 ; $205 = $4 ; $206 = ( FUNCTION_TABLE_iii [ $203 & 127 ] ( $204 , $205 ) | 0 ) ; $207 = $206 ; break ; } } } while ( 0 ) ; $9 = $207 ; $208 = $9 ; $209 = ( $208 | 0 ) == ( 2 ) ; $210 = $9 ; $211 = ( $210 | 0 ) == ( 3 ) ; $or$cond9 = $209 | $211 ; if ( $or$cond9 ) { $212 = $6 ; $213 = ( ( ( $212 ) ) + 4 | 0 ) ; HEAP32 [ $213 >> 2 ] = 666 ; } $214 = $9 ; $215 = ( $214 | 0 ) == ( 0 ) ; $216 = $9 ; $217 = ( $216 | 0 ) == ( 2 ) ; $or$cond11 = $215 | $217 ; if ( $or$cond11 ) { $218 = $3 ; $219 = ( ( ( $218 ) ) + 16 | 0 ) ; $220 = HEAP32 [ $219 >> 2 ] | 0 ; $221 = ( $220 | 0 ) == ( 0 ) ; if ( $221 ) { $222 = $6 ; $223 = ( ( ( $222 ) ) + 40 | 0 ) ; HEAP32 [ $223 >> 2 ] = - 1 ; } $2 = 0 ; $299 = $2 ; STACKTOP = sp ; return ( $299 | 0 ) ; } $224 = $9 ; $225 = ( $224 | 0 ) == ( 1 ) ; if ( $225 ) { $226 = $4 ; $227 = ( $226 | 0 ) == ( 1 ) ; if ( $227 ) { $228 = $6 ; __tr_align ( $228 ) ; } else { $229 = $4 ; $230 = ( $229 | 0 ) != ( 5 ) ; if ( $230 ) { $231 = $6 ; __tr_stored_block ( $231 , 0 , 0 , 0 ) ; $232 = $4 ; $233 = ( $232 | 0 ) == ( 3 ) ; if ( $233 ) { $234 = $6 ; $235 = ( ( ( $234 ) ) + 68 | 0 ) ; $236 = HEAP32 [ $235 >> 2 ] | 0 ; $237 = $6 ; $238 = ( ( ( $237 ) ) + 76 | 0 ) ; $239 = HEAP32 [ $238 >> 2 ] | 0 ; $240 = ( ( $239 ) - 1 ) | 0 ; $241 = ( ( $236 ) + ( $240 << 1 ) | 0 ) ; HEAP16 [ $241 >> 1 ] = 0 ; $242 = $6 ; $243 = ( ( ( $242 ) ) + 68 | 0 ) ; $244 = HEAP32 [ $243 >> 2 ] | 0 ; $245 = $6 ; $246 = ( ( ( $245 ) ) + 76 | 0 ) ; $247 = HEAP32 [ $246 >> 2 ] | 0 ; $248 = ( ( $247 ) - 1 ) | 0 ; $249 = $248 << 1 ; _memset ( ( $244 | 0 ) , 0 , ( $249 | 0 ) ) | 0 ; $250 = $6 ; $251 = ( ( ( $250 ) ) + 116 | 0 ) ; $252 = HEAP32 [ $251 >> 2 ] | 0 ; $253 = ( $252 | 0 ) == ( 0 ) ; if ( $253 ) { $254 = $6 ; $255 = ( ( ( $254 ) ) + 108 | 0 ) ; HEAP32 [ $255 >> 2 ] = 0 ; $256 = $6 ; $257 = ( ( ( $256 ) ) + 92 | 0 ) ; HEAP32 [ $257 >> 2 ] = 0 ; $258 = $6 ; $259 = ( ( ( $258 ) ) + 5812 | 0 ) ; HEAP32 [ $259 >> 2 ] = 0 ; } } } } $260 = $3 ; _flush_pending ( $260 ) ; $261 = $3 ; $262 = ( ( ( $261 ) ) + 16 | 0 ) ; $263 = HEAP32 [ $262 >> 2 ] | 0 ; $264 = ( $263 | 0 ) == ( 0 ) ; if ( $264 ) { $265 = $6 ; $266 = ( ( ( $265 ) ) + 40 | 0 ) ; HEAP32 [ $266 >> 2 ] = - 1 ; $2 = 0 ; $299 = $2 ; STACKTOP = sp ; return ( $299 | 0 ) ; } } } $267 = $4 ; $268 = ( $267 | 0 ) != ( 4 ) ; if ( $268 ) { $2 = 0 ; $299 = $2 ; STACKTOP = sp ; return ( $299 | 0 ) ; } $269 = $6 ; $270 = ( ( ( $269 ) ) + 24 | 0 ) ; $271 = HEAP32 [ $270 >> 2 ] | 0 ; $272 = ( $271 | 0 ) <= ( 0 ) ; if ( $272 ) { $2 = 1 ; $299 = $2 ; STACKTOP = sp ; return ( $299 | 0 ) ; } $273 = $6 ; $274 = $3 ; $275 = ( ( ( $274 ) ) + 48 | 0 ) ; $276 = HEAP32 [ $275 >> 2 ] | 0 ; $277 = $276 >>> 16 ; _putShortMSB ( $273 , $277 ) ; $278 = $6 ; $279 = $3 ; $280 = ( ( ( $279 ) ) + 48 | 0 ) ; $281 = HEAP32 [ $280 >> 2 ] | 0 ; $282 = $281 & 65535 ; _putShortMSB ( $278 , $282 ) ; $283 = $3 ; _flush_pending ( $283 ) ; $284 = $6 ; $285 = ( ( ( $284 ) ) + 24 | 0 ) ; $286 = HEAP32 [ $285 >> 2 ] | 0 ; $287 = ( $286 | 0 ) > ( 0 ) ; if ( $287 ) { $288 = $6 ; $289 = ( ( ( $288 ) ) + 24 | 0 ) ; $290 = HEAP32 [ $289 >> 2 ] | 0 ; $291 = ( 0 - ( $290 ) ) | 0 ; $292 = $6 ; $293 = ( ( ( $292 ) ) + 24 | 0 ) ; HEAP32 [ $293 >> 2 ] = $291 ; } $294 = $6 ; $295 = ( ( ( $294 ) ) + 20 | 0 ) ; $296 = HEAP32 [ $295 >> 2 ] | 0 ; $297 = ( $296 | 0 ) != ( 0 ) ; $298 = $297 ? 0 : 1 ; $2 = $298 ; $299 = $2 ; STACKTOP = sp ; return ( $299 | 0 ) ; } } } while ( 0 ) ; $37 = HEAP32 [ ( 9428 ) >> 2 ] | 0 ; $38 = $3 ; $39 = ( ( ( $38 ) ) + 24 | 0 ) ; HEAP32 [ $39 >> 2 ] = $37 ; $2 = - 2 ; $299 = $2 ; STACKTOP = sp ; return ( $299 | 0 ) ; } function _putShortMSB ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $3 = 0 , $4 = 0 , $5 = 0 ; var $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = $0 ; $3 = $1 ; $4 = $3 ; $5 = $4 >>> 8 ; $6 = $5 & 255 ; $7 = $2 ; $8 = ( ( ( $7 ) ) + 8 | 0 ) ; $9 = HEAP32 [ $8 >> 2 ] | 0 ; $10 = $2 ; $11 = ( ( ( $10 ) ) + 20 | 0 ) ; $12 = HEAP32 [ $11 >> 2 ] | 0 ; $13 = ( ( $12 ) + 1 ) | 0 ; HEAP32 [ $11 >> 2 ] = $13 ; $14 = ( ( $9 ) + ( $12 ) | 0 ) ; HEAP8 [ $14 >> 0 ] = $6 ; $15 = $3 ; $16 = $15 & 255 ; $17 = $16 & 255 ; $18 = $2 ; $19 = ( ( ( $18 ) ) + 8 | 0 ) ; $20 = HEAP32 [ $19 >> 2 ] | 0 ; $21 = $2 ; $22 = ( ( ( $21 ) ) + 20 | 0 ) ; $23 = HEAP32 [ $22 >> 2 ] | 0 ; $24 = ( ( $23 ) + 1 ) | 0 ; HEAP32 [ $22 >> 2 ] = $24 ; $25 = ( ( $20 ) + ( $23 ) | 0 ) ; HEAP8 [ $25 >> 0 ] = $17 ; STACKTOP = sp ; return ; } function _deflate_huff ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 ; var $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 ; var $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 ; var $172 = 0 , $173 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 ; var $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 ; var $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 ; var $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 ; var $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $3 = $0 ; $4 = $1 ; while ( 1 ) { $7 = $3 ; $8 = ( ( ( $7 ) ) + 116 | 0 ) ; $9 = HEAP32 [ $8 >> 2 ] | 0 ; $10 = ( $9 | 0 ) == ( 0 ) ; if ( $10 ) { $11 = $3 ; _fill_window ( $11 ) ; $12 = $3 ; $13 = ( ( ( $12 ) ) + 116 | 0 ) ; $14 = HEAP32 [ $13 >> 2 ] | 0 ; $15 = ( $14 | 0 ) == ( 0 ) ; if ( $15 ) { break ; } } $18 = $3 ; $19 = ( ( ( $18 ) ) + 96 | 0 ) ; HEAP32 [ $19 >> 2 ] = 0 ; $20 = $3 ; $21 = ( ( ( $20 ) ) + 56 | 0 ) ; $22 = HEAP32 [ $21 >> 2 ] | 0 ; $23 = $3 ; $24 = ( ( ( $23 ) ) + 108 | 0 ) ; $25 = HEAP32 [ $24 >> 2 ] | 0 ; $26 = ( ( $22 ) + ( $25 ) | 0 ) ; $27 = HEAP8 [ $26 >> 0 ] | 0 ; $6 = $27 ; $28 = $3 ; $29 = ( ( ( $28 ) ) + 5796 | 0 ) ; $30 = HEAP32 [ $29 >> 2 ] | 0 ; $31 = $3 ; $32 = ( ( ( $31 ) ) + 5792 | 0 ) ; $33 = HEAP32 [ $32 >> 2 ] | 0 ; $34 = ( ( $30 ) + ( $33 << 1 ) | 0 ) ; HEAP16 [ $34 >> 1 ] = 0 ; $35 = $6 ; $36 = $3 ; $37 = ( ( ( $36 ) ) + 5784 | 0 ) ; $38 = HEAP32 [ $37 >> 2 ] | 0 ; $39 = $3 ; $40 = ( ( ( $39 ) ) + 5792 | 0 ) ; $41 = HEAP32 [ $40 >> 2 ] | 0 ; $42 = ( ( $41 ) + 1 ) | 0 ; HEAP32 [ $40 >> 2 ] = $42 ; $43 = ( ( $38 ) + ( $41 ) | 0 ) ; HEAP8 [ $43 >> 0 ] = $35 ; $44 = $3 ; $45 = ( ( ( $44 ) ) + 148 | 0 ) ; $46 = $6 ; $47 = $46 & 255 ; $48 = ( ( $45 ) + ( $47 << 2 ) | 0 ) ; $49 = HEAP16 [ $48 >> 1 ] | 0 ; $50 = ( ( $49 ) + 1 ) << 16 >> 16 ; HEAP16 [ $48 >> 1 ] = $50 ; $51 = $3 ; $52 = ( ( ( $51 ) ) + 5792 | 0 ) ; $53 = HEAP32 [ $52 >> 2 ] | 0 ; $54 = $3 ; $55 = ( ( ( $54 ) ) + 5788 | 0 ) ; $56 = HEAP32 [ $55 >> 2 ] | 0 ; $57 = ( ( $56 ) - 1 ) | 0 ; $58 = ( $53 | 0 ) == ( $57 | 0 ) ; $59 = $58 & 1 ; $5 = $59 ; $60 = $3 ; $61 = ( ( ( $60 ) ) + 116 | 0 ) ; $62 = HEAP32 [ $61 >> 2 ] | 0 ; $63 = ( ( $62 ) + - 1 ) | 0 ; HEAP32 [ $61 >> 2 ] = $63 ; $64 = $3 ; $65 = ( ( ( $64 ) ) + 108 | 0 ) ; $66 = HEAP32 [ $65 >> 2 ] | 0 ; $67 = ( ( $66 ) + 1 ) | 0 ; HEAP32 [ $65 >> 2 ] = $67 ; $68 = $5 ; $69 = ( $68 | 0 ) != ( 0 ) ; if ( ! ( $69 ) ) { continue ; } $70 = $3 ; $71 = $3 ; $72 = ( ( ( $71 ) ) + 92 | 0 ) ; $73 = HEAP32 [ $72 >> 2 ] | 0 ; $74 = ( $73 | 0 ) >= ( 0 ) ; if ( $74 ) { $75 = $3 ; $76 = ( ( ( $75 ) ) + 56 | 0 ) ; $77 = HEAP32 [ $76 >> 2 ] | 0 ; $78 = $3 ; $79 = ( ( ( $78 ) ) + 92 | 0 ) ; $80 = HEAP32 [ $79 >> 2 ] | 0 ; $81 = ( ( $77 ) + ( $80 ) | 0 ) ; $89 = $81 ; } else { $89 = 0 ; } $82 = $3 ; $83 = ( ( ( $82 ) ) + 108 | 0 ) ; $84 = HEAP32 [ $83 >> 2 ] | 0 ; $85 = $3 ; $86 = ( ( ( $85 ) ) + 92 | 0 ) ; $87 = HEAP32 [ $86 >> 2 ] | 0 ; $88 = ( ( $84 ) - ( $87 ) ) | 0 ; __tr_flush_block ( $70 , $89 , $88 , 0 ) ; $90 = $3 ; $91 = ( ( ( $90 ) ) + 108 | 0 ) ; $92 = HEAP32 [ $91 >> 2 ] | 0 ; $93 = $3 ; $94 = ( ( ( $93 ) ) + 92 | 0 ) ; HEAP32 [ $94 >> 2 ] = $92 ; $95 = $3 ; $96 = HEAP32 [ $95 >> 2 ] | 0 ; _flush_pending ( $96 ) ; $97 = $3 ; $98 = HEAP32 [ $97 >> 2 ] | 0 ; $99 = ( ( ( $98 ) ) + 16 | 0 ) ; $100 = HEAP32 [ $99 >> 2 ] | 0 ; $101 = ( $100 | 0 ) == ( 0 ) ; if ( $101 ) { label = 10 ; break ; } } if ( ( label | 0 ) == 10 ) { $2 = 0 ; $173 = $2 ; STACKTOP = sp ; return ( $173 | 0 ) ; } $16 = $4 ; $17 = ( $16 | 0 ) == ( 0 ) ; if ( $17 ) { $2 = 0 ; $173 = $2 ; STACKTOP = sp ; return ( $173 | 0 ) ; } $102 = $3 ; $103 = ( ( ( $102 ) ) + 5812 | 0 ) ; HEAP32 [ $103 >> 2 ] = 0 ; $104 = $4 ; $105 = ( $104 | 0 ) == ( 4 ) ; $106 = $3 ; if ( $105 ) { $107 = $3 ; $108 = ( ( ( $107 ) ) + 92 | 0 ) ; $109 = HEAP32 [ $108 >> 2 ] | 0 ; $110 = ( $109 | 0 ) >= ( 0 ) ; if ( $110 ) { $111 = $3 ; $112 = ( ( ( $111 ) ) + 56 | 0 ) ; $113 = HEAP32 [ $112 >> 2 ] | 0 ; $114 = $3 ; $115 = ( ( ( $114 ) ) + 92 | 0 ) ; $116 = HEAP32 [ $115 >> 2 ] | 0 ; $117 = ( ( $113 ) + ( $116 ) | 0 ) ; $125 = $117 ; } else { $125 = 0 ; } $118 = $3 ; $119 = ( ( ( $118 ) ) + 108 | 0 ) ; $120 = HEAP32 [ $119 >> 2 ] | 0 ; $121 = $3 ; $122 = ( ( ( $121 ) ) + 92 | 0 ) ; $123 = HEAP32 [ $122 >> 2 ] | 0 ; $124 = ( ( $120 ) - ( $123 ) ) | 0 ; __tr_flush_block ( $106 , $125 , $124 , 1 ) ; $126 = $3 ; $127 = ( ( ( $126 ) ) + 108 | 0 ) ; $128 = HEAP32 [ $127 >> 2 ] | 0 ; $129 = $3 ; $130 = ( ( ( $129 ) ) + 92 | 0 ) ; HEAP32 [ $130 >> 2 ] = $128 ; $131 = $3 ; $132 = HEAP32 [ $131 >> 2 ] | 0 ; _flush_pending ( $132 ) ; $133 = $3 ; $134 = HEAP32 [ $133 >> 2 ] | 0 ; $135 = ( ( ( $134 ) ) + 16 | 0 ) ; $136 = HEAP32 [ $135 >> 2 ] | 0 ; $137 = ( $136 | 0 ) == ( 0 ) ; if ( $137 ) { $2 = 2 ; $173 = $2 ; STACKTOP = sp ; return ( $173 | 0 ) ; } else { $2 = 3 ; $173 = $2 ; STACKTOP = sp ; return ( $173 | 0 ) ; } } $138 = ( ( ( $106 ) ) + 5792 | 0 ) ; $139 = HEAP32 [ $138 >> 2 ] | 0 ; $140 = ( $139 | 0 ) != ( 0 ) ; if ( $140 ) { $141 = $3 ; $142 = $3 ; $143 = ( ( ( $142 ) ) + 92 | 0 ) ; $144 = HEAP32 [ $143 >> 2 ] | 0 ; $145 = ( $144 | 0 ) >= ( 0 ) ; if ( $145 ) { $146 = $3 ; $147 = ( ( ( $146 ) ) + 56 | 0 ) ; $148 = HEAP32 [ $147 >> 2 ] | 0 ; $149 = $3 ; $150 = ( ( ( $149 ) ) + 92 | 0 ) ; $151 = HEAP32 [ $150 >> 2 ] | 0 ; $152 = ( ( $148 ) + ( $151 ) | 0 ) ; $160 = $152 ; } else { $160 = 0 ; } $153 = $3 ; $154 = ( ( ( $153 ) ) + 108 | 0 ) ; $155 = HEAP32 [ $154 >> 2 ] | 0 ; $156 = $3 ; $157 = ( ( ( $156 ) ) + 92 | 0 ) ; $158 = HEAP32 [ $157 >> 2 ] | 0 ; $159 = ( ( $155 ) - ( $158 ) ) | 0 ; __tr_flush_block ( $141 , $160 , $159 , 0 ) ; $161 = $3 ; $162 = ( ( ( $161 ) ) + 108 | 0 ) ; $163 = HEAP32 [ $162 >> 2 ] | 0 ; $164 = $3 ; $165 = ( ( ( $164 ) ) + 92 | 0 ) ; HEAP32 [ $165 >> 2 ] = $163 ; $166 = $3 ; $167 = HEAP32 [ $166 >> 2 ] | 0 ; _flush_pending ( $167 ) ; $168 = $3 ; $169 = HEAP32 [ $168 >> 2 ] | 0 ; $170 = ( ( ( $169 ) ) + 16 | 0 ) ; $171 = HEAP32 [ $170 >> 2 ] | 0 ; $172 = ( $171 | 0 ) == ( 0 ) ; if ( $172 ) { $2 = 0 ; $173 = $2 ; STACKTOP = sp ; return ( $173 | 0 ) ; } } $2 = 1 ; $173 = $2 ; STACKTOP = sp ; return ( $173 | 0 ) ; } function _deflate_rle ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$sink = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 ; var $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 ; var $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 ; var $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 ; var $171 = 0 , $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 ; var $19 = 0 , $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $2 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 ; var $207 = 0 , $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 ; var $225 = 0 , $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 ; var $243 = 0 , $244 = 0 , $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 , $258 = 0 , $259 = 0 , $26 = 0 , $260 = 0 ; var $261 = 0 , $262 = 0 , $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 , $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 , $270 = 0 , $271 = 0 , $272 = 0 , $273 = 0 , $274 = 0 , $275 = 0 , $276 = 0 , $277 = 0 , $278 = 0 , $279 = 0 ; var $28 = 0 , $280 = 0 , $281 = 0 , $282 = 0 , $283 = 0 , $284 = 0 , $285 = 0 , $286 = 0 , $287 = 0 , $288 = 0 , $289 = 0 , $29 = 0 , $290 = 0 , $291 = 0 , $292 = 0 , $293 = 0 , $294 = 0 , $295 = 0 , $296 = 0 , $297 = 0 ; var $298 = 0 , $299 = 0 , $3 = 0 , $30 = 0 , $300 = 0 , $301 = 0 , $302 = 0 , $303 = 0 , $304 = 0 , $305 = 0 , $306 = 0 , $307 = 0 , $308 = 0 , $309 = 0 , $31 = 0 , $310 = 0 , $311 = 0 , $312 = 0 , $313 = 0 , $314 = 0 ; var $315 = 0 , $316 = 0 , $317 = 0 , $318 = 0 , $319 = 0 , $32 = 0 , $320 = 0 , $321 = 0 , $322 = 0 , $323 = 0 , $324 = 0 , $325 = 0 , $326 = 0 , $327 = 0 , $328 = 0 , $329 = 0 , $33 = 0 , $330 = 0 , $331 = 0 , $332 = 0 ; var $333 = 0 , $334 = 0 , $335 = 0 , $336 = 0 , $337 = 0 , $338 = 0 , $339 = 0 , $34 = 0 , $340 = 0 , $341 = 0 , $342 = 0 , $343 = 0 , $344 = 0 , $345 = 0 , $346 = 0 , $347 = 0 , $348 = 0 , $349 = 0 , $35 = 0 , $350 = 0 ; var $351 = 0 , $352 = 0 , $353 = 0 , $354 = 0 , $355 = 0 , $356 = 0 , $357 = 0 , $358 = 0 , $359 = 0 , $36 = 0 , $360 = 0 , $361 = 0 , $362 = 0 , $363 = 0 , $364 = 0 , $365 = 0 , $366 = 0 , $367 = 0 , $368 = 0 , $369 = 0 ; var $37 = 0 , $370 = 0 , $371 = 0 , $372 = 0 , $373 = 0 , $374 = 0 , $375 = 0 , $376 = 0 , $377 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 ; var $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 ; var $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 ; var $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $3 = $0 ; $4 = $1 ; while ( 1 ) { $12 = $3 ; $13 = ( ( ( $12 ) ) + 116 | 0 ) ; $14 = HEAP32 [ $13 >> 2 ] | 0 ; $15 = ( $14 >>> 0 ) <= ( 258 ) ; if ( $15 ) { $16 = $3 ; _fill_window ( $16 ) ; $17 = $3 ; $18 = ( ( ( $17 ) ) + 116 | 0 ) ; $19 = HEAP32 [ $18 >> 2 ] | 0 ; $20 = ( $19 >>> 0 ) <= ( 258 ) ; $21 = $4 ; $22 = ( $21 | 0 ) == ( 0 ) ; $or$cond = $20 & $22 ; if ( $or$cond ) { label = 4 ; break ; } $23 = $3 ; $24 = ( ( ( $23 ) ) + 116 | 0 ) ; $25 = HEAP32 [ $24 >> 2 ] | 0 ; $26 = ( $25 | 0 ) == ( 0 ) ; if ( $26 ) { label = 31 ; break ; } } $27 = $3 ; $28 = ( ( ( $27 ) ) + 96 | 0 ) ; HEAP32 [ $28 >> 2 ] = 0 ; $29 = $3 ; $30 = ( ( ( $29 ) ) + 116 | 0 ) ; $31 = HEAP32 [ $30 >> 2 ] | 0 ; $32 = ( $31 >>> 0 ) >= ( 3 ) ; if ( $32 ) { $33 = $3 ; $34 = ( ( ( $33 ) ) + 108 | 0 ) ; $35 = HEAP32 [ $34 >> 2 ] | 0 ; $36 = ( $35 >>> 0 ) > ( 0 ) ; if ( $36 ) { $37 = $3 ; $38 = ( ( ( $37 ) ) + 56 | 0 ) ; $39 = HEAP32 [ $38 >> 2 ] | 0 ; $40 = $3 ; $41 = ( ( ( $40 ) ) + 108 | 0 ) ; $42 = HEAP32 [ $41 >> 2 ] | 0 ; $43 = ( ( $39 ) + ( $42 ) | 0 ) ; $44 = ( ( ( $43 ) ) + - 1 | 0 ) ; $7 = $44 ; $45 = $7 ; $46 = HEAP8 [ $45 >> 0 ] | 0 ; $47 = $46 & 255 ; $6 = $47 ; $48 = $6 ; $49 = $7 ; $50 = ( ( ( $49 ) ) + 1 | 0 ) ; $7 = $50 ; $51 = HEAP8 [ $50 >> 0 ] | 0 ; $52 = $51 & 255 ; $53 = ( $48 | 0 ) == ( $52 | 0 ) ; if ( $53 ) { $54 = $6 ; $55 = $7 ; $56 = ( ( ( $55 ) ) + 1 | 0 ) ; $7 = $56 ; $57 = HEAP8 [ $56 >> 0 ] | 0 ; $58 = $57 & 255 ; $59 = ( $54 | 0 ) == ( $58 | 0 ) ; if ( $59 ) { $60 = $6 ; $61 = $7 ; $62 = ( ( ( $61 ) ) + 1 | 0 ) ; $7 = $62 ; $63 = HEAP8 [ $62 >> 0 ] | 0 ; $64 = $63 & 255 ; $65 = ( $60 | 0 ) == ( $64 | 0 ) ; if ( $65 ) { $66 = $3 ; $67 = ( ( ( $66 ) ) + 56 | 0 ) ; $68 = HEAP32 [ $67 >> 2 ] | 0 ; $69 = $3 ; $70 = ( ( ( $69 ) ) + 108 | 0 ) ; $71 = HEAP32 [ $70 >> 2 ] | 0 ; $72 = ( ( $68 ) + ( $71 ) | 0 ) ; $73 = ( ( ( $72 ) ) + 258 | 0 ) ; $8 = $73 ; while ( 1 ) { $74 = $6 ; $75 = $7 ; $76 = ( ( ( $75 ) ) + 1 | 0 ) ; $7 = $76 ; $77 = HEAP8 [ $76 >> 0 ] | 0 ; $78 = $77 & 255 ; $79 = ( $74 | 0 ) == ( $78 | 0 ) ; if ( ! ( $79 ) ) { break ; } $80 = $6 ; $81 = $7 ; $82 = ( ( ( $81 ) ) + 1 | 0 ) ; $7 = $82 ; $83 = HEAP8 [ $82 >> 0 ] | 0 ; $84 = $83 & 255 ; $85 = ( $80 | 0 ) == ( $84 | 0 ) ; if ( ! ( $85 ) ) { break ; } $86 = $6 ; $87 = $7 ; $88 = ( ( ( $87 ) ) + 1 | 0 ) ; $7 = $88 ; $89 = HEAP8 [ $88 >> 0 ] | 0 ; $90 = $89 & 255 ; $91 = ( $86 | 0 ) == ( $90 | 0 ) ; if ( ! ( $91 ) ) { break ; } $92 = $6 ; $93 = $7 ; $94 = ( ( ( $93 ) ) + 1 | 0 ) ; $7 = $94 ; $95 = HEAP8 [ $94 >> 0 ] | 0 ; $96 = $95 & 255 ; $97 = ( $92 | 0 ) == ( $96 | 0 ) ; if ( ! ( $97 ) ) { break ; } $98 = $6 ; $99 = $7 ; $100 = ( ( ( $99 ) ) + 1 | 0 ) ; $7 = $100 ; $101 = HEAP8 [ $100 >> 0 ] | 0 ; $102 = $101 & 255 ; $103 = ( $98 | 0 ) == ( $102 | 0 ) ; if ( ! ( $103 ) ) { break ; } $104 = $6 ; $105 = $7 ; $106 = ( ( ( $105 ) ) + 1 | 0 ) ; $7 = $106 ; $107 = HEAP8 [ $106 >> 0 ] | 0 ; $108 = $107 & 255 ; $109 = ( $104 | 0 ) == ( $108 | 0 ) ; if ( ! ( $109 ) ) { break ; } $110 = $6 ; $111 = $7 ; $112 = ( ( ( $111 ) ) + 1 | 0 ) ; $7 = $112 ; $113 = HEAP8 [ $112 >> 0 ] | 0 ; $114 = $113 & 255 ; $115 = ( $110 | 0 ) == ( $114 | 0 ) ; if ( ! ( $115 ) ) { break ; } $116 = $6 ; $117 = $7 ; $118 = ( ( ( $117 ) ) + 1 | 0 ) ; $7 = $118 ; $119 = HEAP8 [ $118 >> 0 ] | 0 ; $120 = $119 & 255 ; $121 = ( $116 | 0 ) == ( $120 | 0 ) ; if ( ! ( $121 ) ) { break ; } $122 = $7 ; $123 = $8 ; $124 = ( $122 >>> 0 ) < ( $123 >>> 0 ) ; if ( ! ( $124 ) ) { break ; } } $125 = $8 ; $126 = $7 ; $127 = $125 ; $128 = $126 ; $129 = ( ( $127 ) - ( $128 ) ) | 0 ; $130 = ( 258 - ( $129 ) ) | 0 ; $131 = $3 ; $132 = ( ( ( $131 ) ) + 96 | 0 ) ; HEAP32 [ $132 >> 2 ] = $130 ; $133 = $3 ; $134 = ( ( ( $133 ) ) + 96 | 0 ) ; $135 = HEAP32 [ $134 >> 2 ] | 0 ; $136 = $3 ; $137 = ( ( ( $136 ) ) + 116 | 0 ) ; $138 = HEAP32 [ $137 >> 2 ] | 0 ; $139 = ( $135 >>> 0 ) > ( $138 >>> 0 ) ; if ( $139 ) { $140 = $3 ; $141 = ( ( ( $140 ) ) + 116 | 0 ) ; $142 = HEAP32 [ $141 >> 2 ] | 0 ; $143 = $3 ; $144 = ( ( ( $143 ) ) + 96 | 0 ) ; HEAP32 [ $144 >> 2 ] = $142 ; } } } } } } $145 = $3 ; $146 = ( ( ( $145 ) ) + 96 | 0 ) ; $147 = HEAP32 [ $146 >> 2 ] | 0 ; $148 = ( $147 >>> 0 ) >= ( 3 ) ; $149 = $3 ; if ( $148 ) { $150 = ( ( ( $149 ) ) + 96 | 0 ) ; $151 = HEAP32 [ $150 >> 2 ] | 0 ; $152 = ( ( $151 ) - 3 ) | 0 ; $153 = $152 & 255 ; $9 = $153 ; $10 = 1 ; $154 = $10 ; $155 = $3 ; $156 = ( ( ( $155 ) ) + 5796 | 0 ) ; $157 = HEAP32 [ $156 >> 2 ] | 0 ; $158 = $3 ; $159 = ( ( ( $158 ) ) + 5792 | 0 ) ; $160 = HEAP32 [ $159 >> 2 ] | 0 ; $161 = ( ( $157 ) + ( $160 << 1 ) | 0 ) ; HEAP16 [ $161 >> 1 ] = $154 ; $162 = $9 ; $163 = $3 ; $164 = ( ( ( $163 ) ) + 5784 | 0 ) ; $165 = HEAP32 [ $164 >> 2 ] | 0 ; $166 = $3 ; $167 = ( ( ( $166 ) ) + 5792 | 0 ) ; $168 = HEAP32 [ $167 >> 2 ] | 0 ; $169 = ( ( $168 ) + 1 ) | 0 ; HEAP32 [ $167 >> 2 ] = $169 ; $170 = ( ( $165 ) + ( $168 ) | 0 ) ; HEAP8 [ $170 >> 0 ] = $162 ; $171 = $10 ; $172 = ( ( $171 ) + - 1 ) << 16 >> 16 ; $10 = $172 ; $173 = $3 ; $174 = ( ( ( $173 ) ) + 148 | 0 ) ; $175 = $9 ; $176 = $175 & 255 ; $177 = ( 29272 + ( $176 ) | 0 ) ; $178 = HEAP8 [ $177 >> 0 ] | 0 ; $179 = $178 & 255 ; $180 = ( ( $179 ) + 256 ) | 0 ; $181 = ( ( $180 ) + 1 ) | 0 ; $182 = ( ( $174 ) + ( $181 << 2 ) | 0 ) ; $183 = HEAP16 [ $182 >> 1 ] | 0 ; $184 = ( ( $183 ) + 1 ) << 16 >> 16 ; HEAP16 [ $182 >> 1 ] = $184 ; $185 = $3 ; $186 = ( ( ( $185 ) ) + 2440 | 0 ) ; $187 = $10 ; $188 = $187 & 65535 ; $189 = ( $188 | 0 ) < ( 256 ) ; $190 = $10 ; $191 = $190 & 65535 ; $192 = $191 >> 7 ; $193 = ( 256 + ( $192 ) ) | 0 ; $$sink = $189 ? $191 : $193 ; $194 = ( 28760 + ( $$sink ) | 0 ) ; $195 = HEAP8 [ $194 >> 0 ] | 0 ; $196 = $195 & 255 ; $197 = ( ( $186 ) + ( $196 << 2 ) | 0 ) ; $198 = HEAP16 [ $197 >> 1 ] | 0 ; $199 = ( ( $198 ) + 1 ) << 16 >> 16 ; HEAP16 [ $197 >> 1 ] = $199 ; $200 = $3 ; $201 = ( ( ( $200 ) ) + 5792 | 0 ) ; $202 = HEAP32 [ $201 >> 2 ] | 0 ; $203 = $3 ; $204 = ( ( ( $203 ) ) + 5788 | 0 ) ; $205 = HEAP32 [ $204 >> 2 ] | 0 ; $206 = ( ( $205 ) - 1 ) | 0 ; $207 = ( $202 | 0 ) == ( $206 | 0 ) ; $208 = $207 & 1 ; $5 = $208 ; $209 = $3 ; $210 = ( ( ( $209 ) ) + 96 | 0 ) ; $211 = HEAP32 [ $210 >> 2 ] | 0 ; $212 = $3 ; $213 = ( ( ( $212 ) ) + 116 | 0 ) ; $214 = HEAP32 [ $213 >> 2 ] | 0 ; $215 = ( ( $214 ) - ( $211 ) ) | 0 ; HEAP32 [ $213 >> 2 ] = $215 ; $216 = $3 ; $217 = ( ( ( $216 ) ) + 96 | 0 ) ; $218 = HEAP32 [ $217 >> 2 ] | 0 ; $219 = $3 ; $220 = ( ( ( $219 ) ) + 108 | 0 ) ; $221 = HEAP32 [ $220 >> 2 ] | 0 ; $222 = ( ( $221 ) + ( $218 ) ) | 0 ; HEAP32 [ $220 >> 2 ] = $222 ; $223 = $3 ; $224 = ( ( ( $223 ) ) + 96 | 0 ) ; HEAP32 [ $224 >> 2 ] = 0 ; } else { $225 = ( ( ( $149 ) ) + 56 | 0 ) ; $226 = HEAP32 [ $225 >> 2 ] | 0 ; $227 = $3 ; $228 = ( ( ( $227 ) ) + 108 | 0 ) ; $229 = HEAP32 [ $228 >> 2 ] | 0 ; $230 = ( ( $226 ) + ( $229 ) | 0 ) ; $231 = HEAP8 [ $230 >> 0 ] | 0 ; $11 = $231 ; $232 = $3 ; $233 = ( ( ( $232 ) ) + 5796 | 0 ) ; $234 = HEAP32 [ $233 >> 2 ] | 0 ; $235 = $3 ; $236 = ( ( ( $235 ) ) + 5792 | 0 ) ; $237 = HEAP32 [ $236 >> 2 ] | 0 ; $238 = ( ( $234 ) + ( $237 << 1 ) | 0 ) ; HEAP16 [ $238 >> 1 ] = 0 ; $239 = $11 ; $240 = $3 ; $241 = ( ( ( $240 ) ) + 5784 | 0 ) ; $242 = HEAP32 [ $241 >> 2 ] | 0 ; $243 = $3 ; $244 = ( ( ( $243 ) ) + 5792 | 0 ) ; $245 = HEAP32 [ $244 >> 2 ] | 0 ; $246 = ( ( $245 ) + 1 ) | 0 ; HEAP32 [ $244 >> 2 ] = $246 ; $247 = ( ( $242 ) + ( $245 ) | 0 ) ; HEAP8 [ $247 >> 0 ] = $239 ; $248 = $3 ; $249 = ( ( ( $248 ) ) + 148 | 0 ) ; $250 = $11 ; $251 = $250 & 255 ; $252 = ( ( $249 ) + ( $251 << 2 ) | 0 ) ; $253 = HEAP16 [ $252 >> 1 ] | 0 ; $254 = ( ( $253 ) + 1 ) << 16 >> 16 ; HEAP16 [ $252 >> 1 ] = $254 ; $255 = $3 ; $256 = ( ( ( $255 ) ) + 5792 | 0 ) ; $257 = HEAP32 [ $256 >> 2 ] | 0 ; $258 = $3 ; $259 = ( ( ( $258 ) ) + 5788 | 0 ) ; $260 = HEAP32 [ $259 >> 2 ] | 0 ; $261 = ( ( $260 ) - 1 ) | 0 ; $262 = ( $257 | 0 ) == ( $261 | 0 ) ; $263 = $262 & 1 ; $5 = $263 ; $264 = $3 ; $265 = ( ( ( $264 ) ) + 116 | 0 ) ; $266 = HEAP32 [ $265 >> 2 ] | 0 ; $267 = ( ( $266 ) + - 1 ) | 0 ; HEAP32 [ $265 >> 2 ] = $267 ; $268 = $3 ; $269 = ( ( ( $268 ) ) + 108 | 0 ) ; $270 = HEAP32 [ $269 >> 2 ] | 0 ; $271 = ( ( $270 ) + 1 ) | 0 ; HEAP32 [ $269 >> 2 ] = $271 ; } $272 = $5 ; $273 = ( $272 | 0 ) != ( 0 ) ; if ( ! ( $273 ) ) { continue ; } $274 = $3 ; $275 = $3 ; $276 = ( ( ( $275 ) ) + 92 | 0 ) ; $277 = HEAP32 [ $276 >> 2 ] | 0 ; $278 = ( $277 | 0 ) >= ( 0 ) ; if ( $278 ) { $279 = $3 ; $280 = ( ( ( $279 ) ) + 56 | 0 ) ; $281 = HEAP32 [ $280 >> 2 ] | 0 ; $282 = $3 ; $283 = ( ( ( $282 ) ) + 92 | 0 ) ; $284 = HEAP32 [ $283 >> 2 ] | 0 ; $285 = ( ( $281 ) + ( $284 ) | 0 ) ; $293 = $285 ; } else { $293 = 0 ; } $286 = $3 ; $287 = ( ( ( $286 ) ) + 108 | 0 ) ; $288 = HEAP32 [ $287 >> 2 ] | 0 ; $289 = $3 ; $290 = ( ( ( $289 ) ) + 92 | 0 ) ; $291 = HEAP32 [ $290 >> 2 ] | 0 ; $292 = ( ( $288 ) - ( $291 ) ) | 0 ; __tr_flush_block ( $274 , $293 , $292 , 0 ) ; $294 = $3 ; $295 = ( ( ( $294 ) ) + 108 | 0 ) ; $296 = HEAP32 [ $295 >> 2 ] | 0 ; $297 = $3 ; $298 = ( ( ( $297 ) ) + 92 | 0 ) ; HEAP32 [ $298 >> 2 ] = $296 ; $299 = $3 ; $300 = HEAP32 [ $299 >> 2 ] | 0 ; _flush_pending ( $300 ) ; $301 = $3 ; $302 = HEAP32 [ $301 >> 2 ] | 0 ; $303 = ( ( ( $302 ) ) + 16 | 0 ) ; $304 = HEAP32 [ $303 >> 2 ] | 0 ; $305 = ( $304 | 0 ) == ( 0 ) ; if ( $305 ) { label = 30 ; break ; } } if ( ( label | 0 ) == 4 ) { $2 = 0 ; $377 = $2 ; STACKTOP = sp ; return ( $377 | 0 ) ; } else if ( ( label | 0 ) == 30 ) { $2 = 0 ; $377 = $2 ; STACKTOP = sp ; return ( $377 | 0 ) ; } else if ( ( label | 0 ) == 31 ) { $306 = $3 ; $307 = ( ( ( $306 ) ) + 5812 | 0 ) ; HEAP32 [ $307 >> 2 ] = 0 ; $308 = $4 ; $309 = ( $308 | 0 ) == ( 4 ) ; $310 = $3 ; if ( $309 ) { $311 = $3 ; $312 = ( ( ( $311 ) ) + 92 | 0 ) ; $313 = HEAP32 [ $312 >> 2 ] | 0 ; $314 = ( $313 | 0 ) >= ( 0 ) ; if ( $314 ) { $315 = $3 ; $316 = ( ( ( $315 ) ) + 56 | 0 ) ; $317 = HEAP32 [ $316 >> 2 ] | 0 ; $318 = $3 ; $319 = ( ( ( $318 ) ) + 92 | 0 ) ; $320 = HEAP32 [ $319 >> 2 ] | 0 ; $321 = ( ( $317 ) + ( $320 ) | 0 ) ; $329 = $321 ; } else { $329 = 0 ; } $322 = $3 ; $323 = ( ( ( $322 ) ) + 108 | 0 ) ; $324 = HEAP32 [ $323 >> 2 ] | 0 ; $325 = $3 ; $326 = ( ( ( $325 ) ) + 92 | 0 ) ; $327 = HEAP32 [ $326 >> 2 ] | 0 ; $328 = ( ( $324 ) - ( $327 ) ) | 0 ; __tr_flush_block ( $310 , $329 , $328 , 1 ) ; $330 = $3 ; $331 = ( ( ( $330 ) ) + 108 | 0 ) ; $332 = HEAP32 [ $331 >> 2 ] | 0 ; $333 = $3 ; $334 = ( ( ( $333 ) ) + 92 | 0 ) ; HEAP32 [ $334 >> 2 ] = $332 ; $335 = $3 ; $336 = HEAP32 [ $335 >> 2 ] | 0 ; _flush_pending ( $336 ) ; $337 = $3 ; $338 = HEAP32 [ $337 >> 2 ] | 0 ; $339 = ( ( ( $338 ) ) + 16 | 0 ) ; $340 = HEAP32 [ $339 >> 2 ] | 0 ; $341 = ( $340 | 0 ) == ( 0 ) ; if ( $341 ) { $2 = 2 ; $377 = $2 ; STACKTOP = sp ; return ( $377 | 0 ) ; } else { $2 = 3 ; $377 = $2 ; STACKTOP = sp ; return ( $377 | 0 ) ; } } $342 = ( ( ( $310 ) ) + 5792 | 0 ) ; $343 = HEAP32 [ $342 >> 2 ] | 0 ; $344 = ( $343 | 0 ) != ( 0 ) ; if ( $344 ) { $345 = $3 ; $346 = $3 ; $347 = ( ( ( $346 ) ) + 92 | 0 ) ; $348 = HEAP32 [ $347 >> 2 ] | 0 ; $349 = ( $348 | 0 ) >= ( 0 ) ; if ( $349 ) { $350 = $3 ; $351 = ( ( ( $350 ) ) + 56 | 0 ) ; $352 = HEAP32 [ $351 >> 2 ] | 0 ; $353 = $3 ; $354 = ( ( ( $353 ) ) + 92 | 0 ) ; $355 = HEAP32 [ $354 >> 2 ] | 0 ; $356 = ( ( $352 ) + ( $355 ) | 0 ) ; $364 = $356 ; } else { $364 = 0 ; } $357 = $3 ; $358 = ( ( ( $357 ) ) + 108 | 0 ) ; $359 = HEAP32 [ $358 >> 2 ] | 0 ; $360 = $3 ; $361 = ( ( ( $360 ) ) + 92 | 0 ) ; $362 = HEAP32 [ $361 >> 2 ] | 0 ; $363 = ( ( $359 ) - ( $362 ) ) | 0 ; __tr_flush_block ( $345 , $364 , $363 , 0 ) ; $365 = $3 ; $366 = ( ( ( $365 ) ) + 108 | 0 ) ; $367 = HEAP32 [ $366 >> 2 ] | 0 ; $368 = $3 ; $369 = ( ( ( $368 ) ) + 92 | 0 ) ; HEAP32 [ $369 >> 2 ] = $367 ; $370 = $3 ; $371 = HEAP32 [ $370 >> 2 ] | 0 ; _flush_pending ( $371 ) ; $372 = $3 ; $373 = HEAP32 [ $372 >> 2 ] | 0 ; $374 = ( ( ( $373 ) ) + 16 | 0 ) ; $375 = HEAP32 [ $374 >> 2 ] | 0 ; $376 = ( $375 | 0 ) == ( 0 ) ; if ( $376 ) { $2 = 0 ; $377 = $2 ; STACKTOP = sp ; return ( $377 | 0 ) ; } } $2 = 1 ; $377 = $2 ; STACKTOP = sp ; return ( $377 | 0 ) ; } return ( 0 ) | 0 ; } function _inflateResetKeep ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 ; var $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 ; var $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = $0 ; $4 = $2 ; $5 = ( _inflateStateCheck ( $4 ) | 0 ) ; $6 = ( $5 | 0 ) != ( 0 ) ; if ( $6 ) { $1 = - 2 ; $54 = $1 ; STACKTOP = sp ; return ( $54 | 0 ) ; } $7 = $2 ; $8 = ( ( ( $7 ) ) + 28 | 0 ) ; $9 = HEAP32 [ $8 >> 2 ] | 0 ; $3 = $9 ; $10 = $3 ; $11 = ( ( ( $10 ) ) + 32 | 0 ) ; HEAP32 [ $11 >> 2 ] = 0 ; $12 = $2 ; $13 = ( ( ( $12 ) ) + 20 | 0 ) ; HEAP32 [ $13 >> 2 ] = 0 ; $14 = $2 ; $15 = ( ( ( $14 ) ) + 8 | 0 ) ; HEAP32 [ $15 >> 2 ] = 0 ; $16 = $2 ; $17 = ( ( ( $16 ) ) + 24 | 0 ) ; HEAP32 [ $17 >> 2 ] = 0 ; $18 = $3 ; $19 = ( ( ( $18 ) ) + 12 | 0 ) ; $20 = HEAP32 [ $19 >> 2 ] | 0 ; $21 = ( $20 | 0 ) != ( 0 ) ; if ( $21 ) { $22 = $3 ; $23 = ( ( ( $22 ) ) + 12 | 0 ) ; $24 = HEAP32 [ $23 >> 2 ] | 0 ; $25 = $24 & 1 ; $26 = $2 ; $27 = ( ( ( $26 ) ) + 48 | 0 ) ; HEAP32 [ $27 >> 2 ] = $25 ; } $28 = $3 ; $29 = ( ( ( $28 ) ) + 4 | 0 ) ; HEAP32 [ $29 >> 2 ] = 16180 ; $30 = $3 ; $31 = ( ( ( $30 ) ) + 8 | 0 ) ; HEAP32 [ $31 >> 2 ] = 0 ; $32 = $3 ; $33 = ( ( ( $32 ) ) + 16 | 0 ) ; HEAP32 [ $33 >> 2 ] = 0 ; $34 = $3 ; $35 = ( ( ( $34 ) ) + 24 | 0 ) ; HEAP32 [ $35 >> 2 ] = 32768 ; $36 = $3 ; $37 = ( ( ( $36 ) ) + 36 | 0 ) ; HEAP32 [ $37 >> 2 ] = 0 ; $38 = $3 ; $39 = ( ( ( $38 ) ) + 60 | 0 ) ; HEAP32 [ $39 >> 2 ] = 0 ; $40 = $3 ; $41 = ( ( ( $40 ) ) + 64 | 0 ) ; HEAP32 [ $41 >> 2 ] = 0 ; $42 = $3 ; $43 = ( ( ( $42 ) ) + 1332 | 0 ) ; $44 = $3 ; $45 = ( ( ( $44 ) ) + 112 | 0 ) ; HEAP32 [ $45 >> 2 ] = $43 ; $46 = $3 ; $47 = ( ( ( $46 ) ) + 84 | 0 ) ; HEAP32 [ $47 >> 2 ] = $43 ; $48 = $3 ; $49 = ( ( ( $48 ) ) + 80 | 0 ) ; HEAP32 [ $49 >> 2 ] = $43 ; $50 = $3 ; $51 = ( ( ( $50 ) ) + 7108 | 0 ) ; HEAP32 [ $51 >> 2 ] = 1 ; $52 = $3 ; $53 = ( ( ( $52 ) ) + 7112 | 0 ) ; HEAP32 [ $53 >> 2 ] = - 1 ; $1 = 0 ; $54 = $1 ; STACKTOP = sp ; return ( $54 | 0 ) ; } function _inflateStateCheck ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 ; var $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = $0 ; $4 = $2 ; $5 = ( $4 | 0 ) == ( 0 | 0 ) ; if ( ! ( $5 ) ) { $6 = $2 ; $7 = ( ( ( $6 ) ) + 32 | 0 ) ; $8 = HEAP32 [ $7 >> 2 ] | 0 ; $9 = ( $8 | 0 ) == ( 0 | 0 ) ; if ( ! ( $9 ) ) { $10 = $2 ; $11 = ( ( ( $10 ) ) + 36 | 0 ) ; $12 = HEAP32 [ $11 >> 2 ] | 0 ; $13 = ( $12 | 0 ) == ( 0 | 0 ) ; if ( ! ( $13 ) ) { $14 = $2 ; $15 = ( ( ( $14 ) ) + 28 | 0 ) ; $16 = HEAP32 [ $15 >> 2 ] | 0 ; $3 = $16 ; $17 = $3 ; $18 = ( $17 | 0 ) == ( 0 | 0 ) ; if ( ! ( $18 ) ) { $19 = $3 ; $20 = HEAP32 [ $19 >> 2 ] | 0 ; $21 = $2 ; $22 = ( $20 | 0 ) != ( $21 | 0 ) ; if ( ! ( $22 ) ) { $23 = $3 ; $24 = ( ( ( $23 ) ) + 4 | 0 ) ; $25 = HEAP32 [ $24 >> 2 ] | 0 ; $26 = ( $25 >>> 0 ) < ( 16180 ) ; if ( ! ( $26 ) ) { $27 = $3 ; $28 = ( ( ( $27 ) ) + 4 | 0 ) ; $29 = HEAP32 [ $28 >> 2 ] | 0 ; $30 = ( $29 >>> 0 ) > ( 16211 ) ; if ( ! ( $30 ) ) { $1 = 0 ; $31 = $1 ; STACKTOP = sp ; return ( $31 | 0 ) ; } } } } $1 = 1 ; $31 = $1 ; STACKTOP = sp ; return ( $31 | 0 ) ; } } } $1 = 1 ; $31 = $1 ; STACKTOP = sp ; return ( $31 | 0 ) ; } function _inflateReset ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = $0 ; $4 = $2 ; $5 = ( _inflateStateCheck ( $4 ) | 0 ) ; $6 = ( $5 | 0 ) != ( 0 ) ; if ( $6 ) { $1 = - 2 ; $18 = $1 ; STACKTOP = sp ; return ( $18 | 0 ) ; } else { $7 = $2 ; $8 = ( ( ( $7 ) ) + 28 | 0 ) ; $9 = HEAP32 [ $8 >> 2 ] | 0 ; $3 = $9 ; $10 = $3 ; $11 = ( ( ( $10 ) ) + 44 | 0 ) ; HEAP32 [ $11 >> 2 ] = 0 ; $12 = $3 ; $13 = ( ( ( $12 ) ) + 48 | 0 ) ; HEAP32 [ $13 >> 2 ] = 0 ; $14 = $3 ; $15 = ( ( ( $14 ) ) + 52 | 0 ) ; HEAP32 [ $15 >> 2 ] = 0 ; $16 = $2 ; $17 = ( _inflateResetKeep ( $16 ) | 0 ) ; $1 = $17 ; $18 = $1 ; STACKTOP = sp ; return ( $18 | 0 ) ; } return ( 0 ) | 0 ; } function _inflateReset2 ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 ; var $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 ; var $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $3 = $0 ; $4 = $1 ; $7 = $3 ; $8 = ( _inflateStateCheck ( $7 ) | 0 ) ; $9 = ( $8 | 0 ) != ( 0 ) ; if ( $9 ) { $2 = - 2 ; $54 = $2 ; STACKTOP = sp ; return ( $54 | 0 ) ; } $10 = $3 ; $11 = ( ( ( $10 ) ) + 28 | 0 ) ; $12 = HEAP32 [ $11 >> 2 ] | 0 ; $6 = $12 ; $13 = $4 ; $14 = ( $13 | 0 ) < ( 0 ) ; if ( $14 ) { $5 = 0 ; $15 = $4 ; $16 = ( 0 - ( $15 ) ) | 0 ; $4 = $16 ; } else { $17 = $4 ; $18 = $17 >> 4 ; $19 = ( ( $18 ) + 5 ) | 0 ; $5 = $19 ; } $20 = $4 ; $21 = ( $20 | 0 ) != ( 0 ) ; if ( $21 ) { $22 = $4 ; $23 = ( $22 | 0 ) < ( 8 ) ; $24 = $4 ; $25 = ( $24 | 0 ) > ( 15 ) ; $or$cond = $23 | $25 ; if ( $or$cond ) { $2 = - 2 ; $54 = $2 ; STACKTOP = sp ; return ( $54 | 0 ) ; } } $26 = $6 ; $27 = ( ( ( $26 ) ) + 56 | 0 ) ; $28 = HEAP32 [ $27 >> 2 ] | 0 ; $29 = ( $28 | 0 ) != ( 0 | 0 ) ; if ( $29 ) { $30 = $6 ; $31 = ( ( ( $30 ) ) + 40 | 0 ) ; $32 = HEAP32 [ $31 >> 2 ] | 0 ; $33 = $4 ; $34 = ( $32 | 0 ) != ( $33 | 0 ) ; if ( $34 ) { $35 = $3 ; $36 = ( ( ( $35 ) ) + 36 | 0 ) ; $37 = HEAP32 [ $36 >> 2 ] | 0 ; $38 = $3 ; $39 = ( ( ( $38 ) ) + 40 | 0 ) ; $40 = HEAP32 [ $39 >> 2 ] | 0 ; $41 = $6 ; $42 = ( ( ( $41 ) ) + 56 | 0 ) ; $43 = HEAP32 [ $42 >> 2 ] | 0 ; FUNCTION_TABLE_vii [ $37 & 127 ] ( $40 , $43 ) ; $44 = $6 ; $45 = ( ( ( $44 ) ) + 56 | 0 ) ; HEAP32 [ $45 >> 2 ] = 0 ; } } $46 = $5 ; $47 = $6 ; $48 = ( ( ( $47 ) ) + 12 | 0 ) ; HEAP32 [ $48 >> 2 ] = $46 ; $49 = $4 ; $50 = $6 ; $51 = ( ( ( $50 ) ) + 40 | 0 ) ; HEAP32 [ $51 >> 2 ] = $49 ; $52 = $3 ; $53 = ( _inflateReset ( $52 ) | 0 ) ; $2 = $53 ; $54 = $2 ; STACKTOP = sp ; return ( $54 | 0 ) ; } function _inflateInit2_ ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 ; var $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 ; var $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $5 = $0 ; $6 = $1 ; $7 = $2 ; $8 = $3 ; $11 = $7 ; $12 = ( $11 | 0 ) == ( 0 | 0 ) ; if ( ! ( $12 ) ) { $13 = $7 ; $14 = HEAP8 [ $13 >> 0 ] | 0 ; $15 = $14 << 24 >> 24 ; $16 = HEAP8 [ 29663 ] | 0 ; $17 = $16 << 24 >> 24 ; $18 = ( $15 | 0 ) != ( $17 | 0 ) ; $19 = $8 ; $20 = ( $19 | 0 ) != ( 56 ) ; $or$cond = $18 | $20 ; if ( ! ( $or$cond ) ) { $21 = $5 ; $22 = ( $21 | 0 ) == ( 0 | 0 ) ; if ( $22 ) { $4 = - 2 ; $72 = $4 ; STACKTOP = sp ; return ( $72 | 0 ) ; } $23 = $5 ; $24 = ( ( ( $23 ) ) + 24 | 0 ) ; HEAP32 [ $24 >> 2 ] = 0 ; $25 = $5 ; $26 = ( ( ( $25 ) ) + 32 | 0 ) ; $27 = HEAP32 [ $26 >> 2 ] | 0 ; $28 = ( $27 | 0 ) == ( 0 | 0 ) ; if ( $28 ) { $29 = $5 ; $30 = ( ( ( $29 ) ) + 32 | 0 ) ; HEAP32 [ $30 >> 2 ] = 102 ; $31 = $5 ; $32 = ( ( ( $31 ) ) + 40 | 0 ) ; HEAP32 [ $32 >> 2 ] = 0 ; } $33 = $5 ; $34 = ( ( ( $33 ) ) + 36 | 0 ) ; $35 = HEAP32 [ $34 >> 2 ] | 0 ; $36 = ( $35 | 0 ) == ( 0 | 0 ) ; if ( $36 ) { $37 = $5 ; $38 = ( ( ( $37 ) ) + 36 | 0 ) ; HEAP32 [ $38 >> 2 ] = 103 ; } $39 = $5 ; $40 = ( ( ( $39 ) ) + 32 | 0 ) ; $41 = HEAP32 [ $40 >> 2 ] | 0 ; $42 = $5 ; $43 = ( ( ( $42 ) ) + 40 | 0 ) ; $44 = HEAP32 [ $43 >> 2 ] | 0 ; $45 = ( FUNCTION_TABLE_iiii [ $41 & 127 ] ( $44 , 1 , 7120 ) | 0 ) ; $10 = $45 ; $46 = $10 ; $47 = ( $46 | 0 ) == ( 0 | 0 ) ; if ( $47 ) { $4 = - 4 ; $72 = $4 ; STACKTOP = sp ; return ( $72 | 0 ) ; } $48 = $10 ; $49 = $5 ; $50 = ( ( ( $49 ) ) + 28 | 0 ) ; HEAP32 [ $50 >> 2 ] = $48 ; $51 = $5 ; $52 = $10 ; HEAP32 [ $52 >> 2 ] = $51 ; $53 = $10 ; $54 = ( ( ( $53 ) ) + 56 | 0 ) ; HEAP32 [ $54 >> 2 ] = 0 ; $55 = $10 ; $56 = ( ( ( $55 ) ) + 4 | 0 ) ; HEAP32 [ $56 >> 2 ] = 16180 ; $57 = $5 ; $58 = $6 ; $59 = ( _inflateReset2 ( $57 , $58 ) | 0 ) ; $9 = $59 ; $60 = $9 ; $61 = ( $60 | 0 ) != ( 0 ) ; if ( $61 ) { $62 = $5 ; $63 = ( ( ( $62 ) ) + 36 | 0 ) ; $64 = HEAP32 [ $63 >> 2 ] | 0 ; $65 = $5 ; $66 = ( ( ( $65 ) ) + 40 | 0 ) ; $67 = HEAP32 [ $66 >> 2 ] | 0 ; $68 = $10 ; FUNCTION_TABLE_vii [ $64 & 127 ] ( $67 , $68 ) ; $69 = $5 ; $70 = ( ( ( $69 ) ) + 28 | 0 ) ; HEAP32 [ $70 >> 2 ] = 0 ; } $71 = $9 ; $4 = $71 ; $72 = $4 ; STACKTOP = sp ; return ( $72 | 0 ) ; } } $4 = - 6 ; $72 = $4 ; STACKTOP = sp ; return ( $72 | 0 ) ; } function _inflate ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$sink = 0 , $$sink19 = 0 , $$sink2 = 0 , $10 = 0 , $100 = 0 , $1000 = 0 , $1001 = 0 , $1002 = 0 , $1003 = 0 , $1004 = 0 , $1005 = 0 , $1006 = 0 , $1007 = 0 , $1008 = 0 , $1009 = 0 , $101 = 0 , $1010 = 0 , $1011 = 0 , $1012 = 0 , $1013 = 0 ; var $1014 = 0 , $1015 = 0 , $1016 = 0 , $1017 = 0 , $1018 = 0 , $1019 = 0 , $102 = 0 , $1020 = 0 , $1021 = 0 , $1022 = 0 , $1023 = 0 , $1024 = 0 , $1025 = 0 , $1026 = 0 , $1027 = 0 , $1028 = 0 , $1029 = 0 , $103 = 0 , $1030 = 0 , $1031 = 0 ; var $1032 = 0 , $1033 = 0 , $1034 = 0 , $1035 = 0 , $1036 = 0 , $1037 = 0 , $1038 = 0 , $1039 = 0 , $104 = 0 , $1040 = 0 , $1041 = 0 , $1042 = 0 , $1043 = 0 , $1044 = 0 , $1045 = 0 , $1046 = 0 , $1047 = 0 , $1048 = 0 , $1049 = 0 , $105 = 0 ; var $1050 = 0 , $1051 = 0 , $1052 = 0 , $1053 = 0 , $1054 = 0 , $1055 = 0 , $1056 = 0 , $1057 = 0 , $1058 = 0 , $1059 = 0 , $106 = 0 , $1060 = 0 , $1061 = 0 , $1062 = 0 , $1063 = 0 , $1064 = 0 , $1065 = 0 , $1066 = 0 , $1067 = 0 , $1068 = 0 ; var $1069 = 0 , $107 = 0 , $1070 = 0 , $1071 = 0 , $1072 = 0 , $1073 = 0 , $1074 = 0 , $1075 = 0 , $1076 = 0 , $1077 = 0 , $1078 = 0 , $1079 = 0 , $108 = 0 , $1080 = 0 , $1081 = 0 , $1082 = 0 , $1083 = 0 , $1084 = 0 , $1085 = 0 , $1086 = 0 ; var $1087 = 0 , $1088 = 0 , $1089 = 0 , $109 = 0 , $1090 = 0 , $1091 = 0 , $1092 = 0 , $1093 = 0 , $1094 = 0 , $1095 = 0 , $1096 = 0 , $1097 = 0 , $1098 = 0 , $1099 = 0 , $11 = 0 , $110 = 0 , $1100 = 0 , $1101 = 0 , $1102 = 0 , $1103 = 0 ; var $1104 = 0 , $1105 = 0 , $1106 = 0 , $1107 = 0 , $1108 = 0 , $1109 = 0 , $111 = 0 , $1110 = 0 , $1111 = 0 , $1112 = 0 , $1113 = 0 , $1114 = 0 , $1115 = 0 , $1116 = 0 , $1117 = 0 , $1118 = 0 , $1119 = 0 , $112 = 0 , $1120 = 0 , $1121 = 0 ; var $1122 = 0 , $1123 = 0 , $1124 = 0 , $1125 = 0 , $1126 = 0 , $1127 = 0 , $1128 = 0 , $1129 = 0 , $113 = 0 , $1130 = 0 , $1131 = 0 , $1132 = 0 , $1133 = 0 , $1134 = 0 , $1135 = 0 , $1136 = 0 , $1137 = 0 , $1138 = 0 , $1139 = 0 , $114 = 0 ; var $1140 = 0 , $1141 = 0 , $1142 = 0 , $1143 = 0 , $1144 = 0 , $1145 = 0 , $1146 = 0 , $1147 = 0 , $1148 = 0 , $1149 = 0 , $115 = 0 , $1150 = 0 , $1151 = 0 , $1152 = 0 , $1153 = 0 , $1154 = 0 , $1155 = 0 , $1156 = 0 , $1157 = 0 , $1158 = 0 ; var $1159 = 0 , $116 = 0 , $1160 = 0 , $1161 = 0 , $1162 = 0 , $1163 = 0 , $1164 = 0 , $1165 = 0 , $1166 = 0 , $1167 = 0 , $1168 = 0 , $1169 = 0 , $117 = 0 , $1170 = 0 , $1171 = 0 , $1172 = 0 , $1173 = 0 , $1174 = 0 , $1175 = 0 , $1176 = 0 ; var $1177 = 0 , $1178 = 0 , $1179 = 0 , $118 = 0 , $1180 = 0 , $1181 = 0 , $1182 = 0 , $1183 = 0 , $1184 = 0 , $1185 = 0 , $1186 = 0 , $1187 = 0 , $1188 = 0 , $1189 = 0 , $119 = 0 , $1190 = 0 , $1191 = 0 , $1192 = 0 , $1193 = 0 , $1194 = 0 ; var $1195 = 0 , $1196 = 0 , $1197 = 0 , $1198 = 0 , $1199 = 0 , $12 = 0 , $120 = 0 , $1200 = 0 , $1201 = 0 , $1202 = 0 , $1203 = 0 , $1204 = 0 , $1205 = 0 , $1206 = 0 , $1207 = 0 , $1208 = 0 , $1209 = 0 , $121 = 0 , $1210 = 0 , $1211 = 0 ; var $1212 = 0 , $1213 = 0 , $1214 = 0 , $1215 = 0 , $1216 = 0 , $1217 = 0 , $1218 = 0 , $1219 = 0 , $122 = 0 , $1220 = 0 , $1221 = 0 , $1222 = 0 , $1223 = 0 , $1224 = 0 , $1225 = 0 , $1226 = 0 , $1227 = 0 , $1228 = 0 , $1229 = 0 , $123 = 0 ; var $1230 = 0 , $1231 = 0 , $1232 = 0 , $1233 = 0 , $1234 = 0 , $1235 = 0 , $1236 = 0 , $1237 = 0 , $1238 = 0 , $1239 = 0 , $124 = 0 , $1240 = 0 , $1241 = 0 , $1242 = 0 , $1243 = 0 , $1244 = 0 , $1245 = 0 , $1246 = 0 , $1247 = 0 , $1248 = 0 ; var $1249 = 0 , $125 = 0 , $1250 = 0 , $1251 = 0 , $1252 = 0 , $1253 = 0 , $1254 = 0 , $1255 = 0 , $1256 = 0 , $1257 = 0 , $1258 = 0 , $1259 = 0 , $126 = 0 , $1260 = 0 , $1261 = 0 , $1262 = 0 , $1263 = 0 , $1264 = 0 , $1265 = 0 , $1266 = 0 ; var $1267 = 0 , $1268 = 0 , $1269 = 0 , $127 = 0 , $1270 = 0 , $1271 = 0 , $1272 = 0 , $1273 = 0 , $1274 = 0 , $1275 = 0 , $1276 = 0 , $1277 = 0 , $1278 = 0 , $1279 = 0 , $128 = 0 , $1280 = 0 , $1281 = 0 , $1282 = 0 , $1283 = 0 , $1284 = 0 ; var $1285 = 0 , $1286 = 0 , $1287 = 0 , $1288 = 0 , $1289 = 0 , $129 = 0 , $1290 = 0 , $1291 = 0 , $1292 = 0 , $1293 = 0 , $1294 = 0 , $1295 = 0 , $1296 = 0 , $1297 = 0 , $1298 = 0 , $1299 = 0 , $13 = 0 , $130 = 0 , $1300 = 0 , $1301 = 0 ; var $1302 = 0 , $1303 = 0 , $1304 = 0 , $1305 = 0 , $1306 = 0 , $1307 = 0 , $1308 = 0 , $1309 = 0 , $131 = 0 , $1310 = 0 , $1311 = 0 , $1312 = 0 , $1313 = 0 , $1314 = 0 , $1315 = 0 , $1316 = 0 , $1317 = 0 , $1318 = 0 , $1319 = 0 , $132 = 0 ; var $1320 = 0 , $1321 = 0 , $1322 = 0 , $1323 = 0 , $1324 = 0 , $1325 = 0 , $1326 = 0 , $1327 = 0 , $1328 = 0 , $1329 = 0 , $133 = 0 , $1330 = 0 , $1331 = 0 , $1332 = 0 , $1333 = 0 , $1334 = 0 , $1335 = 0 , $1336 = 0 , $1337 = 0 , $1338 = 0 ; var $1339 = 0 , $134 = 0 , $1340 = 0 , $1341 = 0 , $1342 = 0 , $1343 = 0 , $1344 = 0 , $1345 = 0 , $1346 = 0 , $1347 = 0 , $1348 = 0 , $1349 = 0 , $135 = 0 , $1350 = 0 , $1351 = 0 , $1352 = 0 , $1353 = 0 , $1354 = 0 , $1355 = 0 , $1356 = 0 ; var $1357 = 0 , $1358 = 0 , $1359 = 0 , $136 = 0 , $1360 = 0 , $1361 = 0 , $1362 = 0 , $1363 = 0 , $1364 = 0 , $1365 = 0 , $1366 = 0 , $1367 = 0 , $1368 = 0 , $1369 = 0 , $137 = 0 , $1370 = 0 , $1371 = 0 , $1372 = 0 , $1373 = 0 , $1374 = 0 ; var $1375 = 0 , $1376 = 0 , $1377 = 0 , $1378 = 0 , $1379 = 0 , $138 = 0 , $1380 = 0 , $1381 = 0 , $1382 = 0 , $1383 = 0 , $1384 = 0 , $1385 = 0 , $1386 = 0 , $1387 = 0 , $1388 = 0 , $1389 = 0 , $139 = 0 , $1390 = 0 , $1391 = 0 , $1392 = 0 ; var $1393 = 0 , $1394 = 0 , $1395 = 0 , $1396 = 0 , $1397 = 0 , $1398 = 0 , $1399 = 0 , $14 = 0 , $140 = 0 , $1400 = 0 , $1401 = 0 , $1402 = 0 , $1403 = 0 , $1404 = 0 , $1405 = 0 , $1406 = 0 , $1407 = 0 , $1408 = 0 , $1409 = 0 , $141 = 0 ; var $1410 = 0 , $1411 = 0 , $1412 = 0 , $1413 = 0 , $1414 = 0 , $1415 = 0 , $1416 = 0 , $1417 = 0 , $1418 = 0 , $1419 = 0 , $142 = 0 , $1420 = 0 , $1421 = 0 , $1422 = 0 , $1423 = 0 , $1424 = 0 , $1425 = 0 , $1426 = 0 , $1427 = 0 , $1428 = 0 ; var $1429 = 0 , $143 = 0 , $1430 = 0 , $1431 = 0 , $1432 = 0 , $1433 = 0 , $1434 = 0 , $1435 = 0 , $1436 = 0 , $1437 = 0 , $1438 = 0 , $1439 = 0 , $144 = 0 , $1440 = 0 , $1441 = 0 , $1442 = 0 , $1443 = 0 , $1444 = 0 , $1445 = 0 , $1446 = 0 ; var $1447 = 0 , $1448 = 0 , $1449 = 0 , $145 = 0 , $1450 = 0 , $1451 = 0 , $1452 = 0 , $1453 = 0 , $1454 = 0 , $1455 = 0 , $1456 = 0 , $1457 = 0 , $1458 = 0 , $1459 = 0 , $146 = 0 , $1460 = 0 , $1461 = 0 , $1462 = 0 , $1463 = 0 , $1464 = 0 ; var $1465 = 0 , $1466 = 0 , $1467 = 0 , $1468 = 0 , $1469 = 0 , $147 = 0 , $1470 = 0 , $1471 = 0 , $1472 = 0 , $1473 = 0 , $1474 = 0 , $1475 = 0 , $1476 = 0 , $1477 = 0 , $1478 = 0 , $1479 = 0 , $148 = 0 , $1480 = 0 , $1481 = 0 , $1482 = 0 ; var $1483 = 0 , $1484 = 0 , $1485 = 0 , $1486 = 0 , $1487 = 0 , $1488 = 0 , $1489 = 0 , $149 = 0 , $1490 = 0 , $1491 = 0 , $1492 = 0 , $1493 = 0 , $1494 = 0 , $1495 = 0 , $1496 = 0 , $1497 = 0 , $1498 = 0 , $1499 = 0 , $15 = 0 , $150 = 0 ; var $1500 = 0 , $1501 = 0 , $1502 = 0 , $1503 = 0 , $1504 = 0 , $1505 = 0 , $1506 = 0 , $1507 = 0 , $1508 = 0 , $1509 = 0 , $151 = 0 , $1510 = 0 , $1511 = 0 , $1512 = 0 , $1513 = 0 , $1514 = 0 , $1515 = 0 , $1516 = 0 , $1517 = 0 , $1518 = 0 ; var $1519 = 0 , $152 = 0 , $1520 = 0 , $1521 = 0 , $1522 = 0 , $1523 = 0 , $1524 = 0 , $1525 = 0 , $1526 = 0 , $1527 = 0 , $1528 = 0 , $1529 = 0 , $153 = 0 , $1530 = 0 , $1531 = 0 , $1532 = 0 , $1533 = 0 , $1534 = 0 , $1535 = 0 , $1536 = 0 ; var $1537 = 0 , $1538 = 0 , $1539 = 0 , $154 = 0 , $1540 = 0 , $1541 = 0 , $1542 = 0 , $1543 = 0 , $1544 = 0 , $1545 = 0 , $1546 = 0 , $1547 = 0 , $1548 = 0 , $1549 = 0 , $155 = 0 , $1550 = 0 , $1551 = 0 , $1552 = 0 , $1553 = 0 , $1554 = 0 ; var $1555 = 0 , $1556 = 0 , $1557 = 0 , $1558 = 0 , $1559 = 0 , $156 = 0 , $1560 = 0 , $1561 = 0 , $1562 = 0 , $1563 = 0 , $1564 = 0 , $1565 = 0 , $1566 = 0 , $1567 = 0 , $1568 = 0 , $1569 = 0 , $157 = 0 , $1570 = 0 , $1571 = 0 , $158 = 0 ; var $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 , $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 ; var $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 , $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 ; var $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $2 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 , $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 ; var $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 , $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 ; var $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 , $244 = 0 , $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 ; var $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 , $258 = 0 , $259 = 0 , $26 = 0 , $260 = 0 , $261 = 0 , $262 = 0 , $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 ; var $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 , $270 = 0 , $271 = 0 , $272 = 0 , $273 = 0 , $274 = 0 , $275 = 0 , $276 = 0 , $277 = 0 , $278 = 0 , $279 = 0 , $28 = 0 , $280 = 0 , $281 = 0 , $282 = 0 , $283 = 0 , $284 = 0 ; var $285 = 0 , $286 = 0 , $287 = 0 , $288 = 0 , $289 = 0 , $29 = 0 , $290 = 0 , $291 = 0 , $292 = 0 , $293 = 0 , $294 = 0 , $295 = 0 , $296 = 0 , $297 = 0 , $298 = 0 , $299 = 0 , $3 = 0 , $30 = 0 , $300 = 0 , $301 = 0 ; var $302 = 0 , $303 = 0 , $304 = 0 , $305 = 0 , $306 = 0 , $307 = 0 , $308 = 0 , $309 = 0 , $31 = 0 , $310 = 0 , $311 = 0 , $312 = 0 , $313 = 0 , $314 = 0 , $315 = 0 , $316 = 0 , $317 = 0 , $318 = 0 , $319 = 0 , $32 = 0 ; var $320 = 0 , $321 = 0 , $322 = 0 , $323 = 0 , $324 = 0 , $325 = 0 , $326 = 0 , $327 = 0 , $328 = 0 , $329 = 0 , $33 = 0 , $330 = 0 , $331 = 0 , $332 = 0 , $333 = 0 , $334 = 0 , $335 = 0 , $336 = 0 , $337 = 0 , $338 = 0 ; var $339 = 0 , $34 = 0 , $340 = 0 , $341 = 0 , $342 = 0 , $343 = 0 , $344 = 0 , $345 = 0 , $346 = 0 , $347 = 0 , $348 = 0 , $349 = 0 , $35 = 0 , $350 = 0 , $351 = 0 , $352 = 0 , $353 = 0 , $354 = 0 , $355 = 0 , $356 = 0 ; var $357 = 0 , $358 = 0 , $359 = 0 , $36 = 0 , $360 = 0 , $361 = 0 , $362 = 0 , $363 = 0 , $364 = 0 , $365 = 0 , $366 = 0 , $367 = 0 , $368 = 0 , $369 = 0 , $37 = 0 , $370 = 0 , $371 = 0 , $372 = 0 , $373 = 0 , $374 = 0 ; var $375 = 0 , $376 = 0 , $377 = 0 , $378 = 0 , $379 = 0 , $38 = 0 , $380 = 0 , $381 = 0 , $382 = 0 , $383 = 0 , $384 = 0 , $385 = 0 , $386 = 0 , $387 = 0 , $388 = 0 , $389 = 0 , $39 = 0 , $390 = 0 , $391 = 0 , $392 = 0 ; var $393 = 0 , $394 = 0 , $395 = 0 , $396 = 0 , $397 = 0 , $398 = 0 , $399 = 0 , $4 = 0 , $40 = 0 , $400 = 0 , $401 = 0 , $402 = 0 , $403 = 0 , $404 = 0 , $405 = 0 , $406 = 0 , $407 = 0 , $408 = 0 , $409 = 0 , $41 = 0 ; var $410 = 0 , $411 = 0 , $412 = 0 , $413 = 0 , $414 = 0 , $415 = 0 , $416 = 0 , $417 = 0 , $418 = 0 , $419 = 0 , $42 = 0 , $420 = 0 , $421 = 0 , $422 = 0 , $423 = 0 , $424 = 0 , $425 = 0 , $426 = 0 , $427 = 0 , $428 = 0 ; var $429 = 0 , $43 = 0 , $430 = 0 , $431 = 0 , $432 = 0 , $433 = 0 , $434 = 0 , $435 = 0 , $436 = 0 , $437 = 0 , $438 = 0 , $439 = 0 , $44 = 0 , $440 = 0 , $441 = 0 , $442 = 0 , $443 = 0 , $444 = 0 , $445 = 0 , $446 = 0 ; var $447 = 0 , $448 = 0 , $449 = 0 , $45 = 0 , $450 = 0 , $451 = 0 , $452 = 0 , $453 = 0 , $454 = 0 , $455 = 0 , $456 = 0 , $457 = 0 , $458 = 0 , $459 = 0 , $46 = 0 , $460 = 0 , $461 = 0 , $462 = 0 , $463 = 0 , $464 = 0 ; var $465 = 0 , $466 = 0 , $467 = 0 , $468 = 0 , $469 = 0 , $47 = 0 , $470 = 0 , $471 = 0 , $472 = 0 , $473 = 0 , $474 = 0 , $475 = 0 , $476 = 0 , $477 = 0 , $478 = 0 , $479 = 0 , $48 = 0 , $480 = 0 , $481 = 0 , $482 = 0 ; var $483 = 0 , $484 = 0 , $485 = 0 , $486 = 0 , $487 = 0 , $488 = 0 , $489 = 0 , $49 = 0 , $490 = 0 , $491 = 0 , $492 = 0 , $493 = 0 , $494 = 0 , $495 = 0 , $496 = 0 , $497 = 0 , $498 = 0 , $499 = 0 , $5 = 0 , $50 = 0 ; var $500 = 0 , $501 = 0 , $502 = 0 , $503 = 0 , $504 = 0 , $505 = 0 , $506 = 0 , $507 = 0 , $508 = 0 , $509 = 0 , $51 = 0 , $510 = 0 , $511 = 0 , $512 = 0 , $513 = 0 , $514 = 0 , $515 = 0 , $516 = 0 , $517 = 0 , $518 = 0 ; var $519 = 0 , $52 = 0 , $520 = 0 , $521 = 0 , $522 = 0 , $523 = 0 , $524 = 0 , $525 = 0 , $526 = 0 , $527 = 0 , $528 = 0 , $529 = 0 , $53 = 0 , $530 = 0 , $531 = 0 , $532 = 0 , $533 = 0 , $534 = 0 , $535 = 0 , $536 = 0 ; var $537 = 0 , $538 = 0 , $539 = 0 , $54 = 0 , $540 = 0 , $541 = 0 , $542 = 0 , $543 = 0 , $544 = 0 , $545 = 0 , $546 = 0 , $547 = 0 , $548 = 0 , $549 = 0 , $55 = 0 , $550 = 0 , $551 = 0 , $552 = 0 , $553 = 0 , $554 = 0 ; var $555 = 0 , $556 = 0 , $557 = 0 , $558 = 0 , $559 = 0 , $56 = 0 , $560 = 0 , $561 = 0 , $562 = 0 , $563 = 0 , $564 = 0 , $565 = 0 , $566 = 0 , $567 = 0 , $568 = 0 , $569 = 0 , $57 = 0 , $570 = 0 , $571 = 0 , $572 = 0 ; var $573 = 0 , $574 = 0 , $575 = 0 , $576 = 0 , $577 = 0 , $578 = 0 , $579 = 0 , $58 = 0 , $580 = 0 , $581 = 0 , $582 = 0 , $583 = 0 , $584 = 0 , $585 = 0 , $586 = 0 , $587 = 0 , $588 = 0 , $589 = 0 , $59 = 0 , $590 = 0 ; var $591 = 0 , $592 = 0 , $593 = 0 , $594 = 0 , $595 = 0 , $596 = 0 , $597 = 0 , $598 = 0 , $599 = 0 , $6 = 0 , $60 = 0 , $600 = 0 , $601 = 0 , $602 = 0 , $603 = 0 , $604 = 0 , $605 = 0 , $606 = 0 , $607 = 0 , $608 = 0 ; var $609 = 0 , $61 = 0 , $610 = 0 , $611 = 0 , $612 = 0 , $613 = 0 , $614 = 0 , $615 = 0 , $616 = 0 , $617 = 0 , $618 = 0 , $619 = 0 , $62 = 0 , $620 = 0 , $621 = 0 , $622 = 0 , $623 = 0 , $624 = 0 , $625 = 0 , $626 = 0 ; var $627 = 0 , $628 = 0 , $629 = 0 , $63 = 0 , $630 = 0 , $631 = 0 , $632 = 0 , $633 = 0 , $634 = 0 , $635 = 0 , $636 = 0 , $637 = 0 , $638 = 0 , $639 = 0 , $64 = 0 , $640 = 0 , $641 = 0 , $642 = 0 , $643 = 0 , $644 = 0 ; var $645 = 0 , $646 = 0 , $647 = 0 , $648 = 0 , $649 = 0 , $65 = 0 , $650 = 0 , $651 = 0 , $652 = 0 , $653 = 0 , $654 = 0 , $655 = 0 , $656 = 0 , $657 = 0 , $658 = 0 , $659 = 0 , $66 = 0 , $660 = 0 , $661 = 0 , $662 = 0 ; var $663 = 0 , $664 = 0 , $665 = 0 , $666 = 0 , $667 = 0 , $668 = 0 , $669 = 0 , $67 = 0 , $670 = 0 , $671 = 0 , $672 = 0 , $673 = 0 , $674 = 0 , $675 = 0 , $676 = 0 , $677 = 0 , $678 = 0 , $679 = 0 , $68 = 0 , $680 = 0 ; var $681 = 0 , $682 = 0 , $683 = 0 , $684 = 0 , $685 = 0 , $686 = 0 , $687 = 0 , $688 = 0 , $689 = 0 , $69 = 0 , $690 = 0 , $691 = 0 , $692 = 0 , $693 = 0 , $694 = 0 , $695 = 0 , $696 = 0 , $697 = 0 , $698 = 0 , $699 = 0 ; var $7 = 0 , $70 = 0 , $700 = 0 , $701 = 0 , $702 = 0 , $703 = 0 , $704 = 0 , $705 = 0 , $706 = 0 , $707 = 0 , $708 = 0 , $709 = 0 , $71 = 0 , $710 = 0 , $711 = 0 , $712 = 0 , $713 = 0 , $714 = 0 , $715 = 0 , $716 = 0 ; var $717 = 0 , $718 = 0 , $719 = 0 , $72 = 0 , $720 = 0 , $721 = 0 , $722 = 0 , $723 = 0 , $724 = 0 , $725 = 0 , $726 = 0 , $727 = 0 , $728 = 0 , $729 = 0 , $73 = 0 , $730 = 0 , $731 = 0 , $732 = 0 , $733 = 0 , $734 = 0 ; var $735 = 0 , $736 = 0 , $737 = 0 , $738 = 0 , $739 = 0 , $74 = 0 , $740 = 0 , $741 = 0 , $742 = 0 , $743 = 0 , $744 = 0 , $745 = 0 , $746 = 0 , $747 = 0 , $748 = 0 , $749 = 0 , $75 = 0 , $750 = 0 , $751 = 0 , $752 = 0 ; var $753 = 0 , $754 = 0 , $755 = 0 , $756 = 0 , $757 = 0 , $758 = 0 , $759 = 0 , $76 = 0 , $760 = 0 , $761 = 0 , $762 = 0 , $763 = 0 , $764 = 0 , $765 = 0 , $766 = 0 , $767 = 0 , $768 = 0 , $769 = 0 , $77 = 0 , $770 = 0 ; var $771 = 0 , $772 = 0 , $773 = 0 , $774 = 0 , $775 = 0 , $776 = 0 , $777 = 0 , $778 = 0 , $779 = 0 , $78 = 0 , $780 = 0 , $781 = 0 , $782 = 0 , $783 = 0 , $784 = 0 , $785 = 0 , $786 = 0 , $787 = 0 , $788 = 0 , $789 = 0 ; var $79 = 0 , $790 = 0 , $791 = 0 , $792 = 0 , $793 = 0 , $794 = 0 , $795 = 0 , $796 = 0 , $797 = 0 , $798 = 0 , $799 = 0 , $8 = 0 , $80 = 0 , $800 = 0 , $801 = 0 , $802 = 0 , $803 = 0 , $804 = 0 , $805 = 0 , $806 = 0 ; var $807 = 0 , $808 = 0 , $809 = 0 , $81 = 0 , $810 = 0 , $811 = 0 , $812 = 0 , $813 = 0 , $814 = 0 , $815 = 0 , $816 = 0 , $817 = 0 , $818 = 0 , $819 = 0 , $82 = 0 , $820 = 0 , $821 = 0 , $822 = 0 , $823 = 0 , $824 = 0 ; var $825 = 0 , $826 = 0 , $827 = 0 , $828 = 0 , $829 = 0 , $83 = 0 , $830 = 0 , $831 = 0 , $832 = 0 , $833 = 0 , $834 = 0 , $835 = 0 , $836 = 0 , $837 = 0 , $838 = 0 , $839 = 0 , $84 = 0 , $840 = 0 , $841 = 0 , $842 = 0 ; var $843 = 0 , $844 = 0 , $845 = 0 , $846 = 0 , $847 = 0 , $848 = 0 , $849 = 0 , $85 = 0 , $850 = 0 , $851 = 0 , $852 = 0 , $853 = 0 , $854 = 0 , $855 = 0 , $856 = 0 , $857 = 0 , $858 = 0 , $859 = 0 , $86 = 0 , $860 = 0 ; var $861 = 0 , $862 = 0 , $863 = 0 , $864 = 0 , $865 = 0 , $866 = 0 , $867 = 0 , $868 = 0 , $869 = 0 , $87 = 0 , $870 = 0 , $871 = 0 , $872 = 0 , $873 = 0 , $874 = 0 , $875 = 0 , $876 = 0 , $877 = 0 , $878 = 0 , $879 = 0 ; var $88 = 0 , $880 = 0 , $881 = 0 , $882 = 0 , $883 = 0 , $884 = 0 , $885 = 0 , $886 = 0 , $887 = 0 , $888 = 0 , $889 = 0 , $89 = 0 , $890 = 0 , $891 = 0 , $892 = 0 , $893 = 0 , $894 = 0 , $895 = 0 , $896 = 0 , $897 = 0 ; var $898 = 0 , $899 = 0 , $9 = 0 , $90 = 0 , $900 = 0 , $901 = 0 , $902 = 0 , $903 = 0 , $904 = 0 , $905 = 0 , $906 = 0 , $907 = 0 , $908 = 0 , $909 = 0 , $91 = 0 , $910 = 0 , $911 = 0 , $912 = 0 , $913 = 0 , $914 = 0 ; var $915 = 0 , $916 = 0 , $917 = 0 , $918 = 0 , $919 = 0 , $92 = 0 , $920 = 0 , $921 = 0 , $922 = 0 , $923 = 0 , $924 = 0 , $925 = 0 , $926 = 0 , $927 = 0 , $928 = 0 , $929 = 0 , $93 = 0 , $930 = 0 , $931 = 0 , $932 = 0 ; var $933 = 0 , $934 = 0 , $935 = 0 , $936 = 0 , $937 = 0 , $938 = 0 , $939 = 0 , $94 = 0 , $940 = 0 , $941 = 0 , $942 = 0 , $943 = 0 , $944 = 0 , $945 = 0 , $946 = 0 , $947 = 0 , $948 = 0 , $949 = 0 , $95 = 0 , $950 = 0 ; var $951 = 0 , $952 = 0 , $953 = 0 , $954 = 0 , $955 = 0 , $956 = 0 , $957 = 0 , $958 = 0 , $959 = 0 , $96 = 0 , $960 = 0 , $961 = 0 , $962 = 0 , $963 = 0 , $964 = 0 , $965 = 0 , $966 = 0 , $967 = 0 , $968 = 0 , $969 = 0 ; var $97 = 0 , $970 = 0 , $971 = 0 , $972 = 0 , $973 = 0 , $974 = 0 , $975 = 0 , $976 = 0 , $977 = 0 , $978 = 0 , $979 = 0 , $98 = 0 , $980 = 0 , $981 = 0 , $982 = 0 , $983 = 0 , $984 = 0 , $985 = 0 , $986 = 0 , $987 = 0 ; var $988 = 0 , $989 = 0 , $99 = 0 , $990 = 0 , $991 = 0 , $992 = 0 , $993 = 0 , $994 = 0 , $995 = 0 , $996 = 0 , $997 = 0 , $998 = 0 , $999 = 0 , $or$cond = 0 , $or$cond10 = 0 , $or$cond12 = 0 , $or$cond14 = 0 , $or$cond16 = 0 , $or$cond4 = 0 , $or$cond6 = 0 ; var $or$cond8 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 80 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 80 | 0 ) ; $16 = sp + 68 | 0 ; $17 = sp + 64 | 0 ; $3 = $0 ; $4 = $1 ; $20 = $3 ; $21 = ( _inflateStateCheck ( $20 ) | 0 ) ; $22 = ( $21 | 0 ) != ( 0 ) ; do { if ( ! ( $22 ) ) { $23 = $3 ; $24 = ( ( ( $23 ) ) + 12 | 0 ) ; $25 = HEAP32 [ $24 >> 2 ] | 0 ; $26 = ( $25 | 0 ) == ( 0 | 0 ) ; if ( ! ( $26 ) ) { $27 = $3 ; $28 = HEAP32 [ $27 >> 2 ] | 0 ; $29 = ( $28 | 0 ) == ( 0 | 0 ) ; if ( $29 ) { $30 = $3 ; $31 = ( ( ( $30 ) ) + 4 | 0 ) ; $32 = HEAP32 [ $31 >> 2 ] | 0 ; $33 = ( $32 | 0 ) != ( 0 ) ; if ( $33 ) { break ; } } $34 = $3 ; $35 = ( ( ( $34 ) ) + 28 | 0 ) ; $36 = HEAP32 [ $35 >> 2 ] | 0 ; $5 = $36 ; $37 = $5 ; $38 = ( ( ( $37 ) ) + 4 | 0 ) ; $39 = HEAP32 [ $38 >> 2 ] | 0 ; $40 = ( $39 | 0 ) == ( 16191 ) ; if ( $40 ) { $41 = $5 ; $42 = ( ( ( $41 ) ) + 4 | 0 ) ; HEAP32 [ $42 >> 2 ] = 16192 ; } $43 = $3 ; $44 = ( ( ( $43 ) ) + 12 | 0 ) ; $45 = HEAP32 [ $44 >> 2 ] | 0 ; $7 = $45 ; $46 = $3 ; $47 = ( ( ( $46 ) ) + 16 | 0 ) ; $48 = HEAP32 [ $47 >> 2 ] | 0 ; $9 = $48 ; $49 = $3 ; $50 = HEAP32 [ $49 >> 2 ] | 0 ; $6 = $50 ; $51 = $3 ; $52 = ( ( ( $51 ) ) + 4 | 0 ) ; $53 = HEAP32 [ $52 >> 2 ] | 0 ; $8 = $53 ; $54 = $5 ; $55 = ( ( ( $54 ) ) + 60 | 0 ) ; $56 = HEAP32 [ $55 >> 2 ] | 0 ; $10 = $56 ; $57 = $5 ; $58 = ( ( ( $57 ) ) + 64 | 0 ) ; $59 = HEAP32 [ $58 >> 2 ] | 0 ; $11 = $59 ; $60 = $8 ; $12 = $60 ; $61 = $9 ; $13 = $61 ; $19 = 0 ; L10 : while ( 1 ) { $62 = $5 ; $63 = ( ( ( $62 ) ) + 4 | 0 ) ; $64 = HEAP32 [ $63 >> 2 ] | 0 ; L12 : do { switch ( $64 | 0 ) { case 16208 : { label = 191 ; break L10 ; break ; } case 16209 : { label = 192 ; break L10 ; break ; } case 16210 : { label = 193 ; break L10 ; break ; } case 16180 : { $65 = $5 ; $66 = ( ( ( $65 ) ) + 12 | 0 ) ; $67 = HEAP32 [ $66 >> 2 ] | 0 ; $68 = ( $67 | 0 ) == ( 0 ) ; if ( $68 ) { $69 = $5 ; $70 = ( ( ( $69 ) ) + 4 | 0 ) ; HEAP32 [ $70 >> 2 ] = 16192 ; continue L10 ; } while ( 1 ) { $71 = $11 ; $72 = ( $71 >>> 0 ) < ( 16 ) ; if ( ! ( $72 ) ) { break ; } $73 = $8 ; $74 = ( $73 | 0 ) == ( 0 ) ; if ( $74 ) { break L10 ; } $75 = $8 ; $76 = ( ( $75 ) + - 1 ) | 0 ; $8 = $76 ; $77 = $6 ; $78 = ( ( ( $77 ) ) + 1 | 0 ) ; $6 = $78 ; $79 = HEAP8 [ $77 >> 0 ] | 0 ; $80 = $79 & 255 ; $81 = $11 ; $82 = $80 << $81 ; $83 = $10 ; $84 = ( ( $83 ) + ( $82 ) ) | 0 ; $10 = $84 ; $85 = $11 ; $86 = ( ( $85 ) + 8 ) | 0 ; $11 = $86 ; } $87 = $10 ; $88 = $87 & 255 ; $89 = $88 << 8 ; $90 = $10 ; $91 = $90 >>> 8 ; $92 = ( ( $89 ) + ( $91 ) ) | 0 ; $93 = ( ( $92 >>> 0 ) % 31 ) & - 1 ; $94 = ( $93 | 0 ) != ( 0 ) ; if ( $94 ) { $95 = $3 ; $96 = ( ( ( $95 ) ) + 24 | 0 ) ; HEAP32 [ $96 >> 2 ] = 28447 ; $97 = $5 ; $98 = ( ( ( $97 ) ) + 4 | 0 ) ; HEAP32 [ $98 >> 2 ] = 16209 ; continue L10 ; } $99 = $10 ; $100 = $99 & 15 ; $101 = ( $100 | 0 ) != ( 8 ) ; if ( $101 ) { $102 = $3 ; $103 = ( ( ( $102 ) ) + 24 | 0 ) ; HEAP32 [ $103 >> 2 ] = 28470 ; $104 = $5 ; $105 = ( ( ( $104 ) ) + 4 | 0 ) ; HEAP32 [ $105 >> 2 ] = 16209 ; continue L10 ; } $106 = $10 ; $107 = $106 >>> 4 ; $10 = $107 ; $108 = $11 ; $109 = ( ( $108 ) - 4 ) | 0 ; $11 = $109 ; $110 = $10 ; $111 = $110 & 15 ; $112 = ( ( $111 ) + 8 ) | 0 ; $18 = $112 ; $113 = $5 ; $114 = ( ( ( $113 ) ) + 40 | 0 ) ; $115 = HEAP32 [ $114 >> 2 ] | 0 ; $116 = ( $115 | 0 ) == ( 0 ) ; if ( $116 ) { $117 = $18 ; $118 = $5 ; $119 = ( ( ( $118 ) ) + 40 | 0 ) ; HEAP32 [ $119 >> 2 ] = $117 ; } $120 = $18 ; $121 = ( $120 >>> 0 ) > ( 15 ) ; if ( ! ( $121 ) ) { $122 = $18 ; $123 = $5 ; $124 = ( ( ( $123 ) ) + 40 | 0 ) ; $125 = HEAP32 [ $124 >> 2 ] | 0 ; $126 = ( $122 >>> 0 ) > ( $125 >>> 0 ) ; if ( ! ( $126 ) ) { $131 = $18 ; $132 = 1 << $131 ; $133 = $5 ; $134 = ( ( ( $133 ) ) + 24 | 0 ) ; HEAP32 [ $134 >> 2 ] = $132 ; $135 = ( _adler32 ( 0 , 0 , 0 ) | 0 ) ; $136 = $5 ; $137 = ( ( ( $136 ) ) + 28 | 0 ) ; HEAP32 [ $137 >> 2 ] = $135 ; $138 = $3 ; $139 = ( ( ( $138 ) ) + 48 | 0 ) ; HEAP32 [ $139 >> 2 ] = $135 ; $140 = $10 ; $141 = $140 & 512 ; $142 = ( $141 | 0 ) != ( 0 ) ; $143 = $142 ? 16189 : 16191 ; $144 = $5 ; $145 = ( ( ( $144 ) ) + 4 | 0 ) ; HEAP32 [ $145 >> 2 ] = $143 ; $10 = 0 ; $11 = 0 ; continue L10 ; } } $127 = $3 ; $128 = ( ( ( $127 ) ) + 24 | 0 ) ; HEAP32 [ $128 >> 2 ] = 28497 ; $129 = $5 ; $130 = ( ( ( $129 ) ) + 4 | 0 ) ; HEAP32 [ $130 >> 2 ] = 16209 ; continue L10 ; break ; } case 16189 : { while ( 1 ) { $146 = $11 ; $147 = ( $146 >>> 0 ) < ( 32 ) ; if ( ! ( $147 ) ) { break ; } $148 = $8 ; $149 = ( $148 | 0 ) == ( 0 ) ; if ( $149 ) { break L10 ; } $150 = $8 ; $151 = ( ( $150 ) + - 1 ) | 0 ; $8 = $151 ; $152 = $6 ; $153 = ( ( ( $152 ) ) + 1 | 0 ) ; $6 = $153 ; $154 = HEAP8 [ $152 >> 0 ] | 0 ; $155 = $154 & 255 ; $156 = $11 ; $157 = $155 << $156 ; $158 = $10 ; $159 = ( ( $158 ) + ( $157 ) ) | 0 ; $10 = $159 ; $160 = $11 ; $161 = ( ( $160 ) + 8 ) | 0 ; $11 = $161 ; } $162 = $10 ; $163 = $162 >>> 24 ; $164 = $163 & 255 ; $165 = $10 ; $166 = $165 >>> 8 ; $167 = $166 & 65280 ; $168 = ( ( $164 ) + ( $167 ) ) | 0 ; $169 = $10 ; $170 = $169 & 65280 ; $171 = $170 << 8 ; $172 = ( ( $168 ) + ( $171 ) ) | 0 ; $173 = $10 ; $174 = $173 & 255 ; $175 = $174 << 24 ; $176 = ( ( $172 ) + ( $175 ) ) | 0 ; $177 = $5 ; $178 = ( ( ( $177 ) ) + 28 | 0 ) ; HEAP32 [ $178 >> 2 ] = $176 ; $179 = $3 ; $180 = ( ( ( $179 ) ) + 48 | 0 ) ; HEAP32 [ $180 >> 2 ] = $176 ; $10 = 0 ; $11 = 0 ; $181 = $5 ; $182 = ( ( ( $181 ) ) + 4 | 0 ) ; HEAP32 [ $182 >> 2 ] = 16190 ; label = 29 ; break ; } case 16190 : { label = 29 ; break ; } case 16191 : { label = 32 ; break ; } case 16192 : { label = 33 ; break ; } case 16193 : { $274 = $11 ; $275 = $274 & 7 ; $276 = $10 ; $277 = $276 >>> $275 ; $10 = $277 ; $278 = $11 ; $279 = $278 & 7 ; $280 = $11 ; $281 = ( ( $280 ) - ( $279 ) ) | 0 ; $11 = $281 ; while ( 1 ) { $282 = $11 ; $283 = ( $282 >>> 0 ) < ( 32 ) ; if ( ! ( $283 ) ) { break ; } $284 = $8 ; $285 = ( $284 | 0 ) == ( 0 ) ; if ( $285 ) { break L10 ; } $286 = $8 ; $287 = ( ( $286 ) + - 1 ) | 0 ; $8 = $287 ; $288 = $6 ; $289 = ( ( ( $288 ) ) + 1 | 0 ) ; $6 = $289 ; $290 = HEAP8 [ $288 >> 0 ] | 0 ; $291 = $290 & 255 ; $292 = $11 ; $293 = $291 << $292 ; $294 = $10 ; $295 = ( ( $294 ) + ( $293 ) ) | 0 ; $10 = $295 ; $296 = $11 ; $297 = ( ( $296 ) + 8 ) | 0 ; $11 = $297 ; } $298 = $10 ; $299 = $298 & 65535 ; $300 = $10 ; $301 = $300 >>> 16 ; $302 = $301 ^ 65535 ; $303 = ( $299 | 0 ) != ( $302 | 0 ) ; if ( $303 ) { $304 = $3 ; $305 = ( ( ( $304 ) ) + 24 | 0 ) ; HEAP32 [ $305 >> 2 ] = 28536 ; $306 = $5 ; $307 = ( ( ( $306 ) ) + 4 | 0 ) ; HEAP32 [ $307 >> 2 ] = 16209 ; continue L10 ; } else { $308 = $10 ; $309 = $308 & 65535 ; $310 = $5 ; $311 = ( ( ( $310 ) ) + 68 | 0 ) ; HEAP32 [ $311 >> 2 ] = $309 ; $10 = 0 ; $11 = 0 ; $312 = $5 ; $313 = ( ( ( $312 ) ) + 4 | 0 ) ; HEAP32 [ $313 >> 2 ] = 16194 ; $314 = $4 ; $315 = ( $314 | 0 ) == ( 6 ) ; if ( $315 ) { break L10 ; } else { label = 54 ; break L12 ; } } break ; } case 16194 : { label = 54 ; break ; } case 16195 : { label = 55 ; break ; } case 16196 : { while ( 1 ) { $355 = $11 ; $356 = ( $355 >>> 0 ) < ( 14 ) ; if ( ! ( $356 ) ) { break ; } $357 = $8 ; $358 = ( $357 | 0 ) == ( 0 ) ; if ( $358 ) { break L10 ; } $359 = $8 ; $360 = ( ( $359 ) + - 1 ) | 0 ; $8 = $360 ; $361 = $6 ; $362 = ( ( ( $361 ) ) + 1 | 0 ) ; $6 = $362 ; $363 = HEAP8 [ $361 >> 0 ] | 0 ; $364 = $363 & 255 ; $365 = $11 ; $366 = $364 << $365 ; $367 = $10 ; $368 = ( ( $367 ) + ( $366 ) ) | 0 ; $10 = $368 ; $369 = $11 ; $370 = ( ( $369 ) + 8 ) | 0 ; $11 = $370 ; } $371 = $10 ; $372 = $371 & 31 ; $373 = ( ( $372 ) + 257 ) | 0 ; $374 = $5 ; $375 = ( ( ( $374 ) ) + 100 | 0 ) ; HEAP32 [ $375 >> 2 ] = $373 ; $376 = $10 ; $377 = $376 >>> 5 ; $10 = $377 ; $378 = $11 ; $379 = ( ( $378 ) - 5 ) | 0 ; $11 = $379 ; $380 = $10 ; $381 = $380 & 31 ; $382 = ( ( $381 ) + 1 ) | 0 ; $383 = $5 ; $384 = ( ( ( $383 ) ) + 104 | 0 ) ; HEAP32 [ $384 >> 2 ] = $382 ; $385 = $10 ; $386 = $385 >>> 5 ; $10 = $386 ; $387 = $11 ; $388 = ( ( $387 ) - 5 ) | 0 ; $11 = $388 ; $389 = $10 ; $390 = $389 & 15 ; $391 = ( ( $390 ) + 4 ) | 0 ; $392 = $5 ; $393 = ( ( ( $392 ) ) + 96 | 0 ) ; HEAP32 [ $393 >> 2 ] = $391 ; $394 = $10 ; $395 = $394 >>> 4 ; $10 = $395 ; $396 = $11 ; $397 = ( ( $396 ) - 4 ) | 0 ; $11 = $397 ; $398 = $5 ; $399 = ( ( ( $398 ) ) + 100 | 0 ) ; $400 = HEAP32 [ $399 >> 2 ] | 0 ; $401 = ( $400 >>> 0 ) > ( 286 ) ; if ( ! ( $401 ) ) { $402 = $5 ; $403 = ( ( ( $402 ) ) + 104 | 0 ) ; $404 = HEAP32 [ $403 >> 2 ] | 0 ; $405 = ( $404 >>> 0 ) > ( 30 ) ; if ( ! ( $405 ) ) { $410 = $5 ; $411 = ( ( ( $410 ) ) + 108 | 0 ) ; HEAP32 [ $411 >> 2 ] = 0 ; $412 = $5 ; $413 = ( ( ( $412 ) ) + 4 | 0 ) ; HEAP32 [ $413 >> 2 ] = 16197 ; label = 70 ; break L12 ; } } $406 = $3 ; $407 = ( ( ( $406 ) ) + 24 | 0 ) ; HEAP32 [ $407 >> 2 ] = 28565 ; $408 = $5 ; $409 = ( ( ( $408 ) ) + 4 | 0 ) ; HEAP32 [ $409 >> 2 ] = 16209 ; continue L10 ; break ; } case 16197 : { label = 70 ; break ; } case 16198 : { label = 80 ; break ; } case 16199 : { label = 115 ; break ; } case 16200 : { label = 116 ; break ; } case 16201 : { label = 137 ; break ; } case 16202 : { label = 143 ; break ; } case 16203 : { label = 155 ; break ; } case 16204 : { break ; } case 16205 : { $1342 = $9 ; $1343 = ( $1342 | 0 ) == ( 0 ) ; if ( $1343 ) { break L10 ; } $1344 = $5 ; $1345 = ( ( ( $1344 ) ) + 68 | 0 ) ; $1346 = HEAP32 [ $1345 >> 2 ] | 0 ; $1347 = $1346 & 255 ; $1348 = $7 ; $1349 = ( ( ( $1348 ) ) + 1 | 0 ) ; $7 = $1349 ; HEAP8 [ $1348 >> 0 ] = $1347 ; $1350 = $9 ; $1351 = ( ( $1350 ) + - 1 ) | 0 ; $9 = $1351 ; $1352 = $5 ; $1353 = ( ( ( $1352 ) ) + 4 | 0 ) ; HEAP32 [ $1353 >> 2 ] = 16200 ; continue L10 ; break ; } case 16206 : { $1354 = $5 ; $1355 = ( ( ( $1354 ) ) + 12 | 0 ) ; $1356 = HEAP32 [ $1355 >> 2 ] | 0 ; $1357 = ( $1356 | 0 ) != ( 0 ) ; if ( ! ( $1357 ) ) { label = 190 ; break L10 ; } while ( 1 ) { $1358 = $11 ; $1359 = ( $1358 >>> 0 ) < ( 32 ) ; if ( ! ( $1359 ) ) { break ; } $1360 = $8 ; $1361 = ( $1360 | 0 ) == ( 0 ) ; if ( $1361 ) { break L10 ; } $1362 = $8 ; $1363 = ( ( $1362 ) + - 1 ) | 0 ; $8 = $1363 ; $1364 = $6 ; $1365 = ( ( ( $1364 ) ) + 1 | 0 ) ; $6 = $1365 ; $1366 = HEAP8 [ $1364 >> 0 ] | 0 ; $1367 = $1366 & 255 ; $1368 = $11 ; $1369 = $1367 << $1368 ; $1370 = $10 ; $1371 = ( ( $1370 ) + ( $1369 ) ) | 0 ; $10 = $1371 ; $1372 = $11 ; $1373 = ( ( $1372 ) + 8 ) | 0 ; $11 = $1373 ; } $1374 = $9 ; $1375 = $13 ; $1376 = ( ( $1375 ) - ( $1374 ) ) | 0 ; $13 = $1376 ; $1377 = $13 ; $1378 = $3 ; $1379 = ( ( ( $1378 ) ) + 20 | 0 ) ; $1380 = HEAP32 [ $1379 >> 2 ] | 0 ; $1381 = ( ( $1380 ) + ( $1377 ) ) | 0 ; HEAP32 [ $1379 >> 2 ] = $1381 ; $1382 = $13 ; $1383 = $5 ; $1384 = ( ( ( $1383 ) ) + 32 | 0 ) ; $1385 = HEAP32 [ $1384 >> 2 ] | 0 ; $1386 = ( ( $1385 ) + ( $1382 ) ) | 0 ; HEAP32 [ $1384 >> 2 ] = $1386 ; $1387 = $5 ; $1388 = ( ( ( $1387 ) ) + 12 | 0 ) ; $1389 = HEAP32 [ $1388 >> 2 ] | 0 ; $1390 = $1389 & 4 ; $1391 = ( $1390 | 0 ) != ( 0 ) ; $1392 = $13 ; $1393 = ( $1392 | 0 ) != ( 0 ) ; $or$cond6 = $1391 & $1393 ; if ( $or$cond6 ) { $1394 = $5 ; $1395 = ( ( ( $1394 ) ) + 28 | 0 ) ; $1396 = HEAP32 [ $1395 >> 2 ] | 0 ; $1397 = $7 ; $1398 = $13 ; $1399 = ( 0 - ( $1398 ) ) | 0 ; $1400 = ( ( $1397 ) + ( $1399 ) | 0 ) ; $1401 = $13 ; $1402 = ( _adler32 ( $1396 , $1400 , $1401 ) | 0 ) ; $1403 = $5 ; $1404 = ( ( ( $1403 ) ) + 28 | 0 ) ; HEAP32 [ $1404 >> 2 ] = $1402 ; $1405 = $3 ; $1406 = ( ( ( $1405 ) ) + 48 | 0 ) ; HEAP32 [ $1406 >> 2 ] = $1402 ; } $1407 = $9 ; $13 = $1407 ; $1408 = $5 ; $1409 = ( ( ( $1408 ) ) + 12 | 0 ) ; $1410 = HEAP32 [ $1409 >> 2 ] | 0 ; $1411 = $1410 & 4 ; $1412 = ( $1411 | 0 ) != ( 0 ) ; if ( ! ( $1412 ) ) { label = 189 ; break L10 ; } $1413 = $10 ; $1414 = $1413 >>> 24 ; $1415 = $1414 & 255 ; $1416 = $10 ; $1417 = $1416 >>> 8 ; $1418 = $1417 & 65280 ; $1419 = ( ( $1415 ) + ( $1418 ) ) | 0 ; $1420 = $10 ; $1421 = $1420 & 65280 ; $1422 = $1421 << 8 ; $1423 = ( ( $1419 ) + ( $1422 ) ) | 0 ; $1424 = $10 ; $1425 = $1424 & 255 ; $1426 = $1425 << 24 ; $1427 = ( ( $1423 ) + ( $1426 ) ) | 0 ; $1428 = $5 ; $1429 = ( ( ( $1428 ) ) + 28 | 0 ) ; $1430 = HEAP32 [ $1429 >> 2 ] | 0 ; $1431 = ( $1427 | 0 ) != ( $1430 | 0 ) ; if ( ! ( $1431 ) ) { label = 189 ; break L10 ; } $1432 = $3 ; $1433 = ( ( ( $1432 ) ) + 24 | 0 ) ; HEAP32 [ $1433 >> 2 ] = 28739 ; $1434 = $5 ; $1435 = ( ( ( $1434 ) ) + 4 | 0 ) ; HEAP32 [ $1435 >> 2 ] = 16209 ; continue L10 ; break ; } default : { label = 194 ; break L10 ; } } } while ( 0 ) ; do { if ( ( label | 0 ) == 29 ) { label = 0 ; $183 = $5 ; $184 = ( ( ( $183 ) ) + 16 | 0 ) ; $185 = HEAP32 [ $184 >> 2 ] | 0 ; $186 = ( $185 | 0 ) == ( 0 ) ; if ( $186 ) { label = 30 ; break L10 ; } $204 = ( _adler32 ( 0 , 0 , 0 ) | 0 ) ; $205 = $5 ; $206 = ( ( ( $205 ) ) + 28 | 0 ) ; HEAP32 [ $206 >> 2 ] = $204 ; $207 = $3 ; $208 = ( ( ( $207 ) ) + 48 | 0 ) ; HEAP32 [ $208 >> 2 ] = $204 ; $209 = $5 ; $210 = ( ( ( $209 ) ) + 4 | 0 ) ; HEAP32 [ $210 >> 2 ] = 16191 ; label = 32 ; } else if ( ( label | 0 ) == 54 ) { label = 0 ; $316 = $5 ; $317 = ( ( ( $316 ) ) + 4 | 0 ) ; HEAP32 [ $317 >> 2 ] = 16195 ; label = 55 ; } else if ( ( label | 0 ) == 70 ) { while ( 1 ) { label = 0 ; $414 = $5 ; $415 = ( ( ( $414 ) ) + 108 | 0 ) ; $416 = HEAP32 [ $415 >> 2 ] | 0 ; $417 = $5 ; $418 = ( ( ( $417 ) ) + 96 | 0 ) ; $419 = HEAP32 [ $418 >> 2 ] | 0 ; $420 = ( $416 >>> 0 ) < ( $419 >>> 0 ) ; if ( ! ( $420 ) ) { break ; } while ( 1 ) { $421 = $11 ; $422 = ( $421 >>> 0 ) < ( 3 ) ; if ( ! ( $422 ) ) { break ; } $423 = $8 ; $424 = ( $423 | 0 ) == ( 0 ) ; if ( $424 ) { break L10 ; } $425 = $8 ; $426 = ( ( $425 ) + - 1 ) | 0 ; $8 = $426 ; $427 = $6 ; $428 = ( ( ( $427 ) ) + 1 | 0 ) ; $6 = $428 ; $429 = HEAP8 [ $427 >> 0 ] | 0 ; $430 = $429 & 255 ; $431 = $11 ; $432 = $430 << $431 ; $433 = $10 ; $434 = ( ( $433 ) + ( $432 ) ) | 0 ; $10 = $434 ; $435 = $11 ; $436 = ( ( $435 ) + 8 ) | 0 ; $11 = $436 ; } $437 = $10 ; $438 = $437 & 7 ; $439 = $438 & 65535 ; $440 = $5 ; $441 = ( ( ( $440 ) ) + 116 | 0 ) ; $442 = $5 ; $443 = ( ( ( $442 ) ) + 108 | 0 ) ; $444 = HEAP32 [ $443 >> 2 ] | 0 ; $445 = ( ( $444 ) + 1 ) | 0 ; HEAP32 [ $443 >> 2 ] = $445 ; $446 = ( 10088 + ( $444 << 1 ) | 0 ) ; $447 = HEAP16 [ $446 >> 1 ] | 0 ; $448 = $447 & 65535 ; $449 = ( ( $441 ) + ( $448 << 1 ) | 0 ) ; HEAP16 [ $449 >> 1 ] = $439 ; $450 = $10 ; $451 = $450 >>> 3 ; $10 = $451 ; $452 = $11 ; $453 = ( ( $452 ) - 3 ) | 0 ; $11 = $453 ; label = 70 ; } while ( 1 ) { $454 = $5 ; $455 = ( ( ( $454 ) ) + 108 | 0 ) ; $456 = HEAP32 [ $455 >> 2 ] | 0 ; $457 = ( $456 >>> 0 ) < ( 19 ) ; $458 = $5 ; if ( ! ( $457 ) ) { break ; } $459 = ( ( ( $458 ) ) + 116 | 0 ) ; $460 = $5 ; $461 = ( ( ( $460 ) ) + 108 | 0 ) ; $462 = HEAP32 [ $461 >> 2 ] | 0 ; $463 = ( ( $462 ) + 1 ) | 0 ; HEAP32 [ $461 >> 2 ] = $463 ; $464 = ( 10088 + ( $462 << 1 ) | 0 ) ; $465 = HEAP16 [ $464 >> 1 ] | 0 ; $466 = $465 & 65535 ; $467 = ( ( $459 ) + ( $466 << 1 ) | 0 ) ; HEAP16 [ $467 >> 1 ] = 0 ; } $468 = ( ( ( $458 ) ) + 1332 | 0 ) ; $469 = $5 ; $470 = ( ( ( $469 ) ) + 112 | 0 ) ; HEAP32 [ $470 >> 2 ] = $468 ; $471 = $5 ; $472 = ( ( ( $471 ) ) + 112 | 0 ) ; $473 = HEAP32 [ $472 >> 2 ] | 0 ; $474 = $5 ; $475 = ( ( ( $474 ) ) + 80 | 0 ) ; HEAP32 [ $475 >> 2 ] = $473 ; $476 = $5 ; $477 = ( ( ( $476 ) ) + 88 | 0 ) ; HEAP32 [ $477 >> 2 ] = 7 ; $478 = $5 ; $479 = ( ( ( $478 ) ) + 116 | 0 ) ; $480 = $5 ; $481 = ( ( ( $480 ) ) + 112 | 0 ) ; $482 = $5 ; $483 = ( ( ( $482 ) ) + 88 | 0 ) ; $484 = $5 ; $485 = ( ( ( $484 ) ) + 756 | 0 ) ; $486 = ( _inflate_table ( 0 , $479 , 19 , $481 , $483 , $485 ) | 0 ) ; $19 = $486 ; $487 = $19 ; $488 = ( $487 | 0 ) != ( 0 ) ; if ( $488 ) { $489 = $3 ; $490 = ( ( ( $489 ) ) + 24 | 0 ) ; HEAP32 [ $490 >> 2 ] = 28601 ; $491 = $5 ; $492 = ( ( ( $491 ) ) + 4 | 0 ) ; HEAP32 [ $492 >> 2 ] = 16209 ; continue L10 ; } else { $493 = $5 ; $494 = ( ( ( $493 ) ) + 108 | 0 ) ; HEAP32 [ $494 >> 2 ] = 0 ; $495 = $5 ; $496 = ( ( ( $495 ) ) + 4 | 0 ) ; HEAP32 [ $496 >> 2 ] = 16198 ; label = 80 ; break ; } } } while ( 0 ) ; do { if ( ( label | 0 ) == 32 ) { label = 0 ; $211 = $4 ; $212 = ( $211 | 0 ) == ( 5 ) ; $213 = $4 ; $214 = ( $213 | 0 ) == ( 6 ) ; $or$cond = $212 | $214 ; if ( $or$cond ) { break L10 ; } else { label = 33 ; } } else if ( ( label | 0 ) == 55 ) { label = 0 ; $318 = $5 ; $319 = ( ( ( $318 ) ) + 68 | 0 ) ; $320 = HEAP32 [ $319 >> 2 ] | 0 ; $14 = $320 ; $321 = $14 ; $322 = ( $321 | 0 ) != ( 0 ) ; if ( ! ( $322 ) ) { $353 = $5 ; $354 = ( ( ( $353 ) ) + 4 | 0 ) ; HEAP32 [ $354 >> 2 ] = 16191 ; continue L10 ; } $323 = $14 ; $324 = $8 ; $325 = ( $323 >>> 0 ) > ( $324 >>> 0 ) ; if ( $325 ) { $326 = $8 ; $14 = $326 ; } $327 = $14 ; $328 = $9 ; $329 = ( $327 >>> 0 ) > ( $328 >>> 0 ) ; if ( $329 ) { $330 = $9 ; $14 = $330 ; } $331 = $14 ; $332 = ( $331 | 0 ) == ( 0 ) ; if ( $332 ) { break L10 ; } $333 = $7 ; $334 = $6 ; $335 = $14 ; _memcpy ( ( $333 | 0 ) , ( $334 | 0 ) , ( $335 | 0 ) ) | 0 ; $336 = $14 ; $337 = $8 ; $338 = ( ( $337 ) - ( $336 ) ) | 0 ; $8 = $338 ; $339 = $14 ; $340 = $6 ; $341 = ( ( $340 ) + ( $339 ) | 0 ) ; $6 = $341 ; $342 = $14 ; $343 = $9 ; $344 = ( ( $343 ) - ( $342 ) ) | 0 ; $9 = $344 ; $345 = $14 ; $346 = $7 ; $347 = ( ( $346 ) + ( $345 ) | 0 ) ; $7 = $347 ; $348 = $14 ; $349 = $5 ; $350 = ( ( ( $349 ) ) + 68 | 0 ) ; $351 = HEAP32 [ $350 >> 2 ] | 0 ; $352 = ( ( $351 ) - ( $348 ) ) | 0 ; HEAP32 [ $350 >> 2 ] = $352 ; continue L10 ; } else if ( ( label | 0 ) == 80 ) { L101 : while ( 1 ) { label = 0 ; $497 = $5 ; $498 = ( ( ( $497 ) ) + 108 | 0 ) ; $499 = HEAP32 [ $498 >> 2 ] | 0 ; $500 = $5 ; $501 = ( ( ( $500 ) ) + 100 | 0 ) ; $502 = HEAP32 [ $501 >> 2 ] | 0 ; $503 = $5 ; $504 = ( ( ( $503 ) ) + 104 | 0 ) ; $505 = HEAP32 [ $504 >> 2 ] | 0 ; $506 = ( ( $502 ) + ( $505 ) ) | 0 ; $507 = ( $499 >>> 0 ) < ( $506 >>> 0 ) ; if ( ! ( $507 ) ) { break ; } while ( 1 ) { $508 = $5 ; $509 = ( ( ( $508 ) ) + 80 | 0 ) ; $510 = HEAP32 [ $509 >> 2 ] | 0 ; $511 = $10 ; $512 = $5 ; $513 = ( ( ( $512 ) ) + 88 | 0 ) ; $514 = HEAP32 [ $513 >> 2 ] | 0 ; $515 = 1 << $514 ; $516 = ( ( $515 ) - 1 ) | 0 ; $517 = $511 & $516 ; $518 = ( ( $510 ) + ( $517 << 2 ) | 0 ) ; ; HEAP16 [ $16 >> 1 ] = HEAP16 [ $518 >> 1 ] | 0 ; HEAP16 [ $16 + 2 >> 1 ] = HEAP16 [ $518 + 2 >> 1 ] | 0 ; $519 = ( ( ( $16 ) ) + 1 | 0 ) ; $520 = HEAP8 [ $519 >> 0 ] | 0 ; $521 = $520 & 255 ; $522 = $11 ; $523 = ( $521 >>> 0 ) <= ( $522 >>> 0 ) ; if ( $523 ) { break ; } $524 = $8 ; $525 = ( $524 | 0 ) == ( 0 ) ; if ( $525 ) { break L10 ; } $526 = $8 ; $527 = ( ( $526 ) + - 1 ) | 0 ; $8 = $527 ; $528 = $6 ; $529 = ( ( ( $528 ) ) + 1 | 0 ) ; $6 = $529 ; $530 = HEAP8 [ $528 >> 0 ] | 0 ; $531 = $530 & 255 ; $532 = $11 ; $533 = $531 << $532 ; $534 = $10 ; $535 = ( ( $534 ) + ( $533 ) ) | 0 ; $10 = $535 ; $536 = $11 ; $537 = ( ( $536 ) + 8 ) | 0 ; $11 = $537 ; } $538 = ( ( ( $16 ) ) + 2 | 0 ) ; $539 = HEAP16 [ $538 >> 1 ] | 0 ; $540 = $539 & 65535 ; $541 = ( $540 | 0 ) < ( 16 ) ; if ( $541 ) { $542 = ( ( ( $16 ) ) + 1 | 0 ) ; $543 = HEAP8 [ $542 >> 0 ] | 0 ; $544 = $543 & 255 ; $545 = $10 ; $546 = $545 >>> $544 ; $10 = $546 ; $547 = ( ( ( $16 ) ) + 1 | 0 ) ; $548 = HEAP8 [ $547 >> 0 ] | 0 ; $549 = $548 & 255 ; $550 = $11 ; $551 = ( ( $550 ) - ( $549 ) ) | 0 ; $11 = $551 ; $552 = ( ( ( $16 ) ) + 2 | 0 ) ; $553 = HEAP16 [ $552 >> 1 ] | 0 ; $554 = $5 ; $555 = ( ( ( $554 ) ) + 116 | 0 ) ; $556 = $5 ; $557 = ( ( ( $556 ) ) + 108 | 0 ) ; $558 = HEAP32 [ $557 >> 2 ] | 0 ; $559 = ( ( $558 ) + 1 ) | 0 ; HEAP32 [ $557 >> 2 ] = $559 ; $560 = ( ( $555 ) + ( $558 << 1 ) | 0 ) ; HEAP16 [ $560 >> 1 ] = $553 ; label = 80 ; continue ; } $561 = ( ( ( $16 ) ) + 2 | 0 ) ; $562 = HEAP16 [ $561 >> 1 ] | 0 ; $563 = $562 & 65535 ; $564 = ( $563 | 0 ) == ( 16 ) ; do { if ( $564 ) { while ( 1 ) { $565 = $11 ; $566 = ( ( ( $16 ) ) + 1 | 0 ) ; $567 = HEAP8 [ $566 >> 0 ] | 0 ; $568 = $567 & 255 ; $569 = ( ( $568 ) + 2 ) | 0 ; $570 = ( $565 >>> 0 ) < ( $569 >>> 0 ) ; if ( ! ( $570 ) ) { break ; } $571 = $8 ; $572 = ( $571 | 0 ) == ( 0 ) ; if ( $572 ) { break L10 ; } $573 = $8 ; $574 = ( ( $573 ) + - 1 ) | 0 ; $8 = $574 ; $575 = $6 ; $576 = ( ( ( $575 ) ) + 1 | 0 ) ; $6 = $576 ; $577 = HEAP8 [ $575 >> 0 ] | 0 ; $578 = $577 & 255 ; $579 = $11 ; $580 = $578 << $579 ; $581 = $10 ; $582 = ( ( $581 ) + ( $580 ) ) | 0 ; $10 = $582 ; $583 = $11 ; $584 = ( ( $583 ) + 8 ) | 0 ; $11 = $584 ; } $585 = ( ( ( $16 ) ) + 1 | 0 ) ; $586 = HEAP8 [ $585 >> 0 ] | 0 ; $587 = $586 & 255 ; $588 = $10 ; $589 = $588 >>> $587 ; $10 = $589 ; $590 = ( ( ( $16 ) ) + 1 | 0 ) ; $591 = HEAP8 [ $590 >> 0 ] | 0 ; $592 = $591 & 255 ; $593 = $11 ; $594 = ( ( $593 ) - ( $592 ) ) | 0 ; $11 = $594 ; $595 = $5 ; $596 = ( ( ( $595 ) ) + 108 | 0 ) ; $597 = HEAP32 [ $596 >> 2 ] | 0 ; $598 = ( $597 | 0 ) == ( 0 ) ; if ( $598 ) { label = 91 ; break L101 ; } $602 = $5 ; $603 = ( ( ( $602 ) ) + 116 | 0 ) ; $604 = $5 ; $605 = ( ( ( $604 ) ) + 108 | 0 ) ; $606 = HEAP32 [ $605 >> 2 ] | 0 ; $607 = ( ( $606 ) - 1 ) | 0 ; $608 = ( ( $603 ) + ( $607 << 1 ) | 0 ) ; $609 = HEAP16 [ $608 >> 1 ] | 0 ; $610 = $609 & 65535 ; $18 = $610 ; $611 = $10 ; $612 = $611 & 3 ; $613 = ( 3 + ( $612 ) ) | 0 ; $14 = $613 ; $614 = $10 ; $615 = $614 >>> 2 ; $10 = $615 ; $616 = $11 ; $617 = ( ( $616 ) - 2 ) | 0 ; $11 = $617 ; } else { $618 = ( ( ( $16 ) ) + 2 | 0 ) ; $619 = HEAP16 [ $618 >> 1 ] | 0 ; $620 = $619 & 65535 ; $621 = ( $620 | 0 ) == ( 17 ) ; if ( $621 ) { while ( 1 ) { $622 = $11 ; $623 = ( ( ( $16 ) ) + 1 | 0 ) ; $624 = HEAP8 [ $623 >> 0 ] | 0 ; $625 = $624 & 255 ; $626 = ( ( $625 ) + 3 ) | 0 ; $627 = ( $622 >>> 0 ) < ( $626 >>> 0 ) ; if ( ! ( $627 ) ) { break ; } $628 = $8 ; $629 = ( $628 | 0 ) == ( 0 ) ; if ( $629 ) { break L10 ; } $630 = $8 ; $631 = ( ( $630 ) + - 1 ) | 0 ; $8 = $631 ; $632 = $6 ; $633 = ( ( ( $632 ) ) + 1 | 0 ) ; $6 = $633 ; $634 = HEAP8 [ $632 >> 0 ] | 0 ; $635 = $634 & 255 ; $636 = $11 ; $637 = $635 << $636 ; $638 = $10 ; $639 = ( ( $638 ) + ( $637 ) ) | 0 ; $10 = $639 ; $640 = $11 ; $641 = ( ( $640 ) + 8 ) | 0 ; $11 = $641 ; } $642 = ( ( ( $16 ) ) + 1 | 0 ) ; $643 = HEAP8 [ $642 >> 0 ] | 0 ; $644 = $643 & 255 ; $645 = $10 ; $646 = $645 >>> $644 ; $10 = $646 ; $647 = ( ( ( $16 ) ) + 1 | 0 ) ; $648 = HEAP8 [ $647 >> 0 ] | 0 ; $649 = $648 & 255 ; $650 = $11 ; $651 = ( ( $650 ) - ( $649 ) ) | 0 ; $11 = $651 ; $18 = 0 ; $652 = $10 ; $653 = $652 & 7 ; $654 = ( 3 + ( $653 ) ) | 0 ; $14 = $654 ; $655 = $10 ; $656 = $655 >>> 3 ; $10 = $656 ; $657 = $11 ; $658 = ( ( $657 ) - 3 ) | 0 ; $11 = $658 ; break ; } else { while ( 1 ) { $659 = $11 ; $660 = ( ( ( $16 ) ) + 1 | 0 ) ; $661 = HEAP8 [ $660 >> 0 ] | 0 ; $662 = $661 & 255 ; $663 = ( ( $662 ) + 7 ) | 0 ; $664 = ( $659 >>> 0 ) < ( $663 >>> 0 ) ; if ( ! ( $664 ) ) { break ; } $665 = $8 ; $666 = ( $665 | 0 ) == ( 0 ) ; if ( $666 ) { break L10 ; } $667 = $8 ; $668 = ( ( $667 ) + - 1 ) | 0 ; $8 = $668 ; $669 = $6 ; $670 = ( ( ( $669 ) ) + 1 | 0 ) ; $6 = $670 ; $671 = HEAP8 [ $669 >> 0 ] | 0 ; $672 = $671 & 255 ; $673 = $11 ; $674 = $672 << $673 ; $675 = $10 ; $676 = ( ( $675 ) + ( $674 ) ) | 0 ; $10 = $676 ; $677 = $11 ; $678 = ( ( $677 ) + 8 ) | 0 ; $11 = $678 ; } $679 = ( ( ( $16 ) ) + 1 | 0 ) ; $680 = HEAP8 [ $679 >> 0 ] | 0 ; $681 = $680 & 255 ; $682 = $10 ; $683 = $682 >>> $681 ; $10 = $683 ; $684 = ( ( ( $16 ) ) + 1 | 0 ) ; $685 = HEAP8 [ $684 >> 0 ] | 0 ; $686 = $685 & 255 ; $687 = $11 ; $688 = ( ( $687 ) - ( $686 ) ) | 0 ; $11 = $688 ; $18 = 0 ; $689 = $10 ; $690 = $689 & 127 ; $691 = ( 11 + ( $690 ) ) | 0 ; $14 = $691 ; $692 = $10 ; $693 = $692 >>> 7 ; $10 = $693 ; $694 = $11 ; $695 = ( ( $694 ) - 7 ) | 0 ; $11 = $695 ; break ; } } } while ( 0 ) ; $696 = $5 ; $697 = ( ( ( $696 ) ) + 108 | 0 ) ; $698 = HEAP32 [ $697 >> 2 ] | 0 ; $699 = $14 ; $700 = ( ( $698 ) + ( $699 ) ) | 0 ; $701 = $5 ; $702 = ( ( ( $701 ) ) + 100 | 0 ) ; $703 = HEAP32 [ $702 >> 2 ] | 0 ; $704 = $5 ; $705 = ( ( ( $704 ) ) + 104 | 0 ) ; $706 = HEAP32 [ $705 >> 2 ] | 0 ; $707 = ( ( $703 ) + ( $706 ) ) | 0 ; $708 = ( $700 >>> 0 ) > ( $707 >>> 0 ) ; if ( $708 ) { label = 103 ; break ; } while ( 1 ) { $712 = $14 ; $713 = ( ( $712 ) + - 1 ) | 0 ; $14 = $713 ; $714 = ( $712 | 0 ) != ( 0 ) ; if ( ! ( $714 ) ) { label = 80 ; continue L101 ; } $715 = $18 ; $716 = $715 & 65535 ; $717 = $5 ; $718 = ( ( ( $717 ) ) + 116 | 0 ) ; $719 = $5 ; $720 = ( ( ( $719 ) ) + 108 | 0 ) ; $721 = HEAP32 [ $720 >> 2 ] | 0 ; $722 = ( ( $721 ) + 1 ) | 0 ; HEAP32 [ $720 >> 2 ] = $722 ; $723 = ( ( $718 ) + ( $721 << 1 ) | 0 ) ; HEAP16 [ $723 >> 1 ] = $716 ; } } if ( ( label | 0 ) == 91 ) { label = 0 ; $599 = $3 ; $600 = ( ( ( $599 ) ) + 24 | 0 ) ; HEAP32 [ $600 >> 2 ] = 28626 ; $601 = $5 ; $$sink2 = $601 ; label = 106 ; } else if ( ( label | 0 ) == 103 ) { label = 0 ; $709 = $3 ; $710 = ( ( ( $709 ) ) + 24 | 0 ) ; HEAP32 [ $710 >> 2 ] = 28626 ; $711 = $5 ; $$sink2 = $711 ; label = 106 ; } if ( ( label | 0 ) == 106 ) { label = 0 ; $724 = ( ( ( $$sink2 ) ) + 4 | 0 ) ; HEAP32 [ $724 >> 2 ] = 16209 ; } $725 = $5 ; $726 = ( ( ( $725 ) ) + 4 | 0 ) ; $727 = HEAP32 [ $726 >> 2 ] | 0 ; $728 = ( $727 | 0 ) == ( 16209 ) ; if ( $728 ) { continue L10 ; } $729 = $5 ; $730 = ( ( ( $729 ) ) + 116 | 0 ) ; $731 = ( ( ( $730 ) ) + 512 | 0 ) ; $732 = HEAP16 [ $731 >> 1 ] | 0 ; $733 = $732 & 65535 ; $734 = ( $733 | 0 ) == ( 0 ) ; if ( $734 ) { $735 = $3 ; $736 = ( ( ( $735 ) ) + 24 | 0 ) ; HEAP32 [ $736 >> 2 ] = 28652 ; $737 = $5 ; $738 = ( ( ( $737 ) ) + 4 | 0 ) ; HEAP32 [ $738 >> 2 ] = 16209 ; continue L10 ; } $739 = $5 ; $740 = ( ( ( $739 ) ) + 1332 | 0 ) ; $741 = $5 ; $742 = ( ( ( $741 ) ) + 112 | 0 ) ; HEAP32 [ $742 >> 2 ] = $740 ; $743 = $5 ; $744 = ( ( ( $743 ) ) + 112 | 0 ) ; $745 = HEAP32 [ $744 >> 2 ] | 0 ; $746 = $5 ; $747 = ( ( ( $746 ) ) + 80 | 0 ) ; HEAP32 [ $747 >> 2 ] = $745 ; $748 = $5 ; $749 = ( ( ( $748 ) ) + 88 | 0 ) ; HEAP32 [ $749 >> 2 ] = 9 ; $750 = $5 ; $751 = ( ( ( $750 ) ) + 116 | 0 ) ; $752 = $5 ; $753 = ( ( ( $752 ) ) + 100 | 0 ) ; $754 = HEAP32 [ $753 >> 2 ] | 0 ; $755 = $5 ; $756 = ( ( ( $755 ) ) + 112 | 0 ) ; $757 = $5 ; $758 = ( ( ( $757 ) ) + 88 | 0 ) ; $759 = $5 ; $760 = ( ( ( $759 ) ) + 756 | 0 ) ; $761 = ( _inflate_table ( 1 , $751 , $754 , $756 , $758 , $760 ) | 0 ) ; $19 = $761 ; $762 = $19 ; $763 = ( $762 | 0 ) != ( 0 ) ; if ( $763 ) { $764 = $3 ; $765 = ( ( ( $764 ) ) + 24 | 0 ) ; HEAP32 [ $765 >> 2 ] = 28689 ; $766 = $5 ; $767 = ( ( ( $766 ) ) + 4 | 0 ) ; HEAP32 [ $767 >> 2 ] = 16209 ; continue L10 ; } $768 = $5 ; $769 = ( ( ( $768 ) ) + 112 | 0 ) ; $770 = HEAP32 [ $769 >> 2 ] | 0 ; $771 = $5 ; $772 = ( ( ( $771 ) ) + 84 | 0 ) ; HEAP32 [ $772 >> 2 ] = $770 ; $773 = $5 ; $774 = ( ( ( $773 ) ) + 92 | 0 ) ; HEAP32 [ $774 >> 2 ] = 6 ; $775 = $5 ; $776 = ( ( ( $775 ) ) + 116 | 0 ) ; $777 = $5 ; $778 = ( ( ( $777 ) ) + 100 | 0 ) ; $779 = HEAP32 [ $778 >> 2 ] | 0 ; $780 = ( ( $776 ) + ( $779 << 1 ) | 0 ) ; $781 = $5 ; $782 = ( ( ( $781 ) ) + 104 | 0 ) ; $783 = HEAP32 [ $782 >> 2 ] | 0 ; $784 = $5 ; $785 = ( ( ( $784 ) ) + 112 | 0 ) ; $786 = $5 ; $787 = ( ( ( $786 ) ) + 92 | 0 ) ; $788 = $5 ; $789 = ( ( ( $788 ) ) + 756 | 0 ) ; $790 = ( _inflate_table ( 2 , $780 , $783 , $785 , $787 , $789 ) | 0 ) ; $19 = $790 ; $791 = $19 ; $792 = ( $791 | 0 ) != ( 0 ) ; if ( $792 ) { $793 = $3 ; $794 = ( ( ( $793 ) ) + 24 | 0 ) ; HEAP32 [ $794 >> 2 ] = 28717 ; $795 = $5 ; $796 = ( ( ( $795 ) ) + 4 | 0 ) ; HEAP32 [ $796 >> 2 ] = 16209 ; continue L10 ; } else { $797 = $5 ; $798 = ( ( ( $797 ) ) + 4 | 0 ) ; HEAP32 [ $798 >> 2 ] = 16199 ; $799 = $4 ; $800 = ( $799 | 0 ) == ( 6 ) ; if ( $800 ) { break L10 ; } else { label = 115 ; break ; } } } } while ( 0 ) ; if ( ( label | 0 ) == 33 ) { label = 0 ; $215 = $5 ; $216 = ( ( ( $215 ) ) + 8 | 0 ) ; $217 = HEAP32 [ $216 >> 2 ] | 0 ; $218 = ( $217 | 0 ) != ( 0 ) ; if ( $218 ) { $219 = $11 ; $220 = $219 & 7 ; $221 = $10 ; $222 = $221 >>> $220 ; $10 = $222 ; $223 = $11 ; $224 = $223 & 7 ; $225 = $11 ; $226 = ( ( $225 ) - ( $224 ) ) | 0 ; $11 = $226 ; $227 = $5 ; $228 = ( ( ( $227 ) ) + 4 | 0 ) ; HEAP32 [ $228 >> 2 ] = 16206 ; continue ; } while ( 1 ) { $229 = $11 ; $230 = ( $229 >>> 0 ) < ( 3 ) ; if ( ! ( $230 ) ) { break ; } $231 = $8 ; $232 = ( $231 | 0 ) == ( 0 ) ; if ( $232 ) { break L10 ; } $233 = $8 ; $234 = ( ( $233 ) + - 1 ) | 0 ; $8 = $234 ; $235 = $6 ; $236 = ( ( ( $235 ) ) + 1 | 0 ) ; $6 = $236 ; $237 = HEAP8 [ $235 >> 0 ] | 0 ; $238 = $237 & 255 ; $239 = $11 ; $240 = $238 << $239 ; $241 = $10 ; $242 = ( ( $241 ) + ( $240 ) ) | 0 ; $10 = $242 ; $243 = $11 ; $244 = ( ( $243 ) + 8 ) | 0 ; $11 = $244 ; } $245 = $10 ; $246 = $245 & 1 ; $247 = $5 ; $248 = ( ( ( $247 ) ) + 8 | 0 ) ; HEAP32 [ $248 >> 2 ] = $246 ; $249 = $10 ; $250 = $249 >>> 1 ; $10 = $250 ; $251 = $11 ; $252 = ( ( $251 ) - 1 ) | 0 ; $11 = $252 ; $253 = $10 ; $254 = $253 & 3 ; switch ( $254 | 0 ) { case 0 : { $255 = $5 ; $$sink = 16193 ; $$sink19 = $255 ; label = 45 ; break ; } case 1 : { $256 = $5 ; _fixedtables ( $256 ) ; $257 = $5 ; $258 = ( ( ( $257 ) ) + 4 | 0 ) ; HEAP32 [ $258 >> 2 ] = 16199 ; $259 = $4 ; $260 = ( $259 | 0 ) == ( 6 ) ; if ( $260 ) { label = 41 ; break L10 ; } break ; } case 2 : { $265 = $5 ; $$sink = 16196 ; $$sink19 = $265 ; label = 45 ; break ; } case 3 : { $266 = $3 ; $267 = ( ( ( $266 ) ) + 24 | 0 ) ; HEAP32 [ $267 >> 2 ] = 28517 ; $268 = $5 ; $$sink = 16209 ; $$sink19 = $268 ; label = 45 ; break ; } default : { label = 44 ; break L10 ; } } if ( ( label | 0 ) == 45 ) { label = 0 ; $269 = ( ( ( $$sink19 ) ) + 4 | 0 ) ; HEAP32 [ $269 >> 2 ] = $$sink ; } $270 = $10 ; $271 = $270 >>> 2 ; $10 = $271 ; $272 = $11 ; $273 = ( ( $272 ) - 2 ) | 0 ; $11 = $273 ; continue ; } else if ( ( label | 0 ) == 115 ) { label = 0 ; $801 = $5 ; $802 = ( ( ( $801 ) ) + 4 | 0 ) ; HEAP32 [ $802 >> 2 ] = 16200 ; label = 116 ; } do { if ( ( label | 0 ) == 116 ) { label = 0 ; $803 = $8 ; $804 = ( $803 >>> 0 ) >= ( 6 ) ; $805 = $9 ; $806 = ( $805 >>> 0 ) >= ( 258 ) ; $or$cond4 = $804 & $806 ; if ( $or$cond4 ) { $807 = $7 ; $808 = $3 ; $809 = ( ( ( $808 ) ) + 12 | 0 ) ; HEAP32 [ $809 >> 2 ] = $807 ; $810 = $9 ; $811 = $3 ; $812 = ( ( ( $811 ) ) + 16 | 0 ) ; HEAP32 [ $812 >> 2 ] = $810 ; $813 = $6 ; $814 = $3 ; HEAP32 [ $814 >> 2 ] = $813 ; $815 = $8 ; $816 = $3 ; $817 = ( ( ( $816 ) ) + 4 | 0 ) ; HEAP32 [ $817 >> 2 ] = $815 ; $818 = $10 ; $819 = $5 ; $820 = ( ( ( $819 ) ) + 60 | 0 ) ; HEAP32 [ $820 >> 2 ] = $818 ; $821 = $11 ; $822 = $5 ; $823 = ( ( ( $822 ) ) + 64 | 0 ) ; HEAP32 [ $823 >> 2 ] = $821 ; $824 = $3 ; $825 = $13 ; _inflate_fast ( $824 , $825 ) ; $826 = $3 ; $827 = ( ( ( $826 ) ) + 12 | 0 ) ; $828 = HEAP32 [ $827 >> 2 ] | 0 ; $7 = $828 ; $829 = $3 ; $830 = ( ( ( $829 ) ) + 16 | 0 ) ; $831 = HEAP32 [ $830 >> 2 ] | 0 ; $9 = $831 ; $832 = $3 ; $833 = HEAP32 [ $832 >> 2 ] | 0 ; $6 = $833 ; $834 = $3 ; $835 = ( ( ( $834 ) ) + 4 | 0 ) ; $836 = HEAP32 [ $835 >> 2 ] | 0 ; $8 = $836 ; $837 = $5 ; $838 = ( ( ( $837 ) ) + 60 | 0 ) ; $839 = HEAP32 [ $838 >> 2 ] | 0 ; $10 = $839 ; $840 = $5 ; $841 = ( ( ( $840 ) ) + 64 | 0 ) ; $842 = HEAP32 [ $841 >> 2 ] | 0 ; $11 = $842 ; $843 = $5 ; $844 = ( ( ( $843 ) ) + 4 | 0 ) ; $845 = HEAP32 [ $844 >> 2 ] | 0 ; $846 = ( $845 | 0 ) == ( 16191 ) ; if ( ! ( $846 ) ) { continue L10 ; } $847 = $5 ; $848 = ( ( ( $847 ) ) + 7112 | 0 ) ; HEAP32 [ $848 >> 2 ] = - 1 ; continue L10 ; } $849 = $5 ; $850 = ( ( ( $849 ) ) + 7112 | 0 ) ; HEAP32 [ $850 >> 2 ] = 0 ; while ( 1 ) { $851 = $5 ; $852 = ( ( ( $851 ) ) + 80 | 0 ) ; $853 = HEAP32 [ $852 >> 2 ] | 0 ; $854 = $10 ; $855 = $5 ; $856 = ( ( ( $855 ) ) + 88 | 0 ) ; $857 = HEAP32 [ $856 >> 2 ] | 0 ; $858 = 1 << $857 ; $859 = ( ( $858 ) - 1 ) | 0 ; $860 = $854 & $859 ; $861 = ( ( $853 ) + ( $860 << 2 ) | 0 ) ; ; HEAP16 [ $16 >> 1 ] = HEAP16 [ $861 >> 1 ] | 0 ; HEAP16 [ $16 + 2 >> 1 ] = HEAP16 [ $861 + 2 >> 1 ] | 0 ; $862 = ( ( ( $16 ) ) + 1 | 0 ) ; $863 = HEAP8 [ $862 >> 0 ] | 0 ; $864 = $863 & 255 ; $865 = $11 ; $866 = ( $864 >>> 0 ) <= ( $865 >>> 0 ) ; if ( $866 ) { break ; } $867 = $8 ; $868 = ( $867 | 0 ) == ( 0 ) ; if ( $868 ) { break L10 ; } $869 = $8 ; $870 = ( ( $869 ) + - 1 ) | 0 ; $8 = $870 ; $871 = $6 ; $872 = ( ( ( $871 ) ) + 1 | 0 ) ; $6 = $872 ; $873 = HEAP8 [ $871 >> 0 ] | 0 ; $874 = $873 & 255 ; $875 = $11 ; $876 = $874 << $875 ; $877 = $10 ; $878 = ( ( $877 ) + ( $876 ) ) | 0 ; $10 = $878 ; $879 = $11 ; $880 = ( ( $879 ) + 8 ) | 0 ; $11 = $880 ; } $881 = HEAP8 [ $16 >> 0 ] | 0 ; $882 = $881 & 255 ; $883 = ( $882 | 0 ) != ( 0 ) ; if ( $883 ) { $884 = HEAP8 [ $16 >> 0 ] | 0 ; $885 = $884 & 255 ; $886 = $885 & 240 ; $887 = ( $886 | 0 ) == ( 0 ) ; if ( $887 ) { ; HEAP16 [ $17 >> 1 ] = HEAP16 [ $16 >> 1 ] | 0 ; HEAP16 [ $17 + 2 >> 1 ] = HEAP16 [ $16 + 2 >> 1 ] | 0 ; while ( 1 ) { $888 = $5 ; $889 = ( ( ( $888 ) ) + 80 | 0 ) ; $890 = HEAP32 [ $889 >> 2 ] | 0 ; $891 = ( ( ( $17 ) ) + 2 | 0 ) ; $892 = HEAP16 [ $891 >> 1 ] | 0 ; $893 = $892 & 65535 ; $894 = $10 ; $895 = ( ( ( $17 ) ) + 1 | 0 ) ; $896 = HEAP8 [ $895 >> 0 ] | 0 ; $897 = $896 & 255 ; $898 = HEAP8 [ $17 >> 0 ] | 0 ; $899 = $898 & 255 ; $900 = ( ( $897 ) + ( $899 ) ) | 0 ; $901 = 1 << $900 ; $902 = ( ( $901 ) - 1 ) | 0 ; $903 = $894 & $902 ; $904 = ( ( ( $17 ) ) + 1 | 0 ) ; $905 = HEAP8 [ $904 >> 0 ] | 0 ; $906 = $905 & 255 ; $907 = $903 >>> $906 ; $908 = ( ( $893 ) + ( $907 ) ) | 0 ; $909 = ( ( $890 ) + ( $908 << 2 ) | 0 ) ; ; HEAP16 [ $16 >> 1 ] = HEAP16 [ $909 >> 1 ] | 0 ; HEAP16 [ $16 + 2 >> 1 ] = HEAP16 [ $909 + 2 >> 1 ] | 0 ; $910 = ( ( ( $17 ) ) + 1 | 0 ) ; $911 = HEAP8 [ $910 >> 0 ] | 0 ; $912 = $911 & 255 ; $913 = ( ( ( $16 ) ) + 1 | 0 ) ; $914 = HEAP8 [ $913 >> 0 ] | 0 ; $915 = $914 & 255 ; $916 = ( ( $912 ) + ( $915 ) ) | 0 ; $917 = $11 ; $918 = ( $916 >>> 0 ) <= ( $917 >>> 0 ) ; if ( $918 ) { break ; } $919 = $8 ; $920 = ( $919 | 0 ) == ( 0 ) ; if ( $920 ) { break L10 ; } $921 = $8 ; $922 = ( ( $921 ) + - 1 ) | 0 ; $8 = $922 ; $923 = $6 ; $924 = ( ( ( $923 ) ) + 1 | 0 ) ; $6 = $924 ; $925 = HEAP8 [ $923 >> 0 ] | 0 ; $926 = $925 & 255 ; $927 = $11 ; $928 = $926 << $927 ; $929 = $10 ; $930 = ( ( $929 ) + ( $928 ) ) | 0 ; $10 = $930 ; $931 = $11 ; $932 = ( ( $931 ) + 8 ) | 0 ; $11 = $932 ; } $933 = ( ( ( $17 ) ) + 1 | 0 ) ; $934 = HEAP8 [ $933 >> 0 ] | 0 ; $935 = $934 & 255 ; $936 = $10 ; $937 = $936 >>> $935 ; $10 = $937 ; $938 = ( ( ( $17 ) ) + 1 | 0 ) ; $939 = HEAP8 [ $938 >> 0 ] | 0 ; $940 = $939 & 255 ; $941 = $11 ; $942 = ( ( $941 ) - ( $940 ) ) | 0 ; $11 = $942 ; $943 = ( ( ( $17 ) ) + 1 | 0 ) ; $944 = HEAP8 [ $943 >> 0 ] | 0 ; $945 = $944 & 255 ; $946 = $5 ; $947 = ( ( ( $946 ) ) + 7112 | 0 ) ; $948 = HEAP32 [ $947 >> 2 ] | 0 ; $949 = ( ( $948 ) + ( $945 ) ) | 0 ; HEAP32 [ $947 >> 2 ] = $949 ; } } $950 = ( ( ( $16 ) ) + 1 | 0 ) ; $951 = HEAP8 [ $950 >> 0 ] | 0 ; $952 = $951 & 255 ; $953 = $10 ; $954 = $953 >>> $952 ; $10 = $954 ; $955 = ( ( ( $16 ) ) + 1 | 0 ) ; $956 = HEAP8 [ $955 >> 0 ] | 0 ; $957 = $956 & 255 ; $958 = $11 ; $959 = ( ( $958 ) - ( $957 ) ) | 0 ; $11 = $959 ; $960 = ( ( ( $16 ) ) + 1 | 0 ) ; $961 = HEAP8 [ $960 >> 0 ] | 0 ; $962 = $961 & 255 ; $963 = $5 ; $964 = ( ( ( $963 ) ) + 7112 | 0 ) ; $965 = HEAP32 [ $964 >> 2 ] | 0 ; $966 = ( ( $965 ) + ( $962 ) ) | 0 ; HEAP32 [ $964 >> 2 ] = $966 ; $967 = ( ( ( $16 ) ) + 2 | 0 ) ; $968 = HEAP16 [ $967 >> 1 ] | 0 ; $969 = $968 & 65535 ; $970 = $5 ; $971 = ( ( ( $970 ) ) + 68 | 0 ) ; HEAP32 [ $971 >> 2 ] = $969 ; $972 = HEAP8 [ $16 >> 0 ] | 0 ; $973 = $972 & 255 ; $974 = ( $973 | 0 ) == ( 0 ) ; if ( $974 ) { $975 = $5 ; $976 = ( ( ( $975 ) ) + 4 | 0 ) ; HEAP32 [ $976 >> 2 ] = 16205 ; continue L10 ; } $977 = HEAP8 [ $16 >> 0 ] | 0 ; $978 = $977 & 255 ; $979 = $978 & 32 ; $980 = ( $979 | 0 ) != ( 0 ) ; if ( $980 ) { $981 = $5 ; $982 = ( ( ( $981 ) ) + 7112 | 0 ) ; HEAP32 [ $982 >> 2 ] = - 1 ; $983 = $5 ; $984 = ( ( ( $983 ) ) + 4 | 0 ) ; HEAP32 [ $984 >> 2 ] = 16191 ; continue L10 ; } $985 = HEAP8 [ $16 >> 0 ] | 0 ; $986 = $985 & 255 ; $987 = $986 & 64 ; $988 = ( $987 | 0 ) != ( 0 ) ; if ( $988 ) { $989 = $3 ; $990 = ( ( ( $989 ) ) + 24 | 0 ) ; HEAP32 [ $990 >> 2 ] = 29730 ; $991 = $5 ; $992 = ( ( ( $991 ) ) + 4 | 0 ) ; HEAP32 [ $992 >> 2 ] = 16209 ; continue L10 ; } else { $993 = HEAP8 [ $16 >> 0 ] | 0 ; $994 = $993 & 255 ; $995 = $994 & 15 ; $996 = $5 ; $997 = ( ( ( $996 ) ) + 76 | 0 ) ; HEAP32 [ $997 >> 2 ] = $995 ; $998 = $5 ; $999 = ( ( ( $998 ) ) + 4 | 0 ) ; HEAP32 [ $999 >> 2 ] = 16201 ; label = 137 ; break ; } } } while ( 0 ) ; if ( ( label | 0 ) == 137 ) { label = 0 ; $1000 = $5 ; $1001 = ( ( ( $1000 ) ) + 76 | 0 ) ; $1002 = HEAP32 [ $1001 >> 2 ] | 0 ; $1003 = ( $1002 | 0 ) != ( 0 ) ; if ( $1003 ) { while ( 1 ) { $1004 = $11 ; $1005 = $5 ; $1006 = ( ( ( $1005 ) ) + 76 | 0 ) ; $1007 = HEAP32 [ $1006 >> 2 ] | 0 ; $1008 = ( $1004 >>> 0 ) < ( $1007 >>> 0 ) ; if ( ! ( $1008 ) ) { break ; } $1009 = $8 ; $1010 = ( $1009 | 0 ) == ( 0 ) ; if ( $1010 ) { break L10 ; } $1011 = $8 ; $1012 = ( ( $1011 ) + - 1 ) | 0 ; $8 = $1012 ; $1013 = $6 ; $1014 = ( ( ( $1013 ) ) + 1 | 0 ) ; $6 = $1014 ; $1015 = HEAP8 [ $1013 >> 0 ] | 0 ; $1016 = $1015 & 255 ; $1017 = $11 ; $1018 = $1016 << $1017 ; $1019 = $10 ; $1020 = ( ( $1019 ) + ( $1018 ) ) | 0 ; $10 = $1020 ; $1021 = $11 ; $1022 = ( ( $1021 ) + 8 ) | 0 ; $11 = $1022 ; } $1023 = $10 ; $1024 = $5 ; $1025 = ( ( ( $1024 ) ) + 76 | 0 ) ; $1026 = HEAP32 [ $1025 >> 2 ] | 0 ; $1027 = 1 << $1026 ; $1028 = ( ( $1027 ) - 1 ) | 0 ; $1029 = $1023 & $1028 ; $1030 = $5 ; $1031 = ( ( ( $1030 ) ) + 68 | 0 ) ; $1032 = HEAP32 [ $1031 >> 2 ] | 0 ; $1033 = ( ( $1032 ) + ( $1029 ) ) | 0 ; HEAP32 [ $1031 >> 2 ] = $1033 ; $1034 = $5 ; $1035 = ( ( ( $1034 ) ) + 76 | 0 ) ; $1036 = HEAP32 [ $1035 >> 2 ] | 0 ; $1037 = $10 ; $1038 = $1037 >>> $1036 ; $10 = $1038 ; $1039 = $5 ; $1040 = ( ( ( $1039 ) ) + 76 | 0 ) ; $1041 = HEAP32 [ $1040 >> 2 ] | 0 ; $1042 = $11 ; $1043 = ( ( $1042 ) - ( $1041 ) ) | 0 ; $11 = $1043 ; $1044 = $5 ; $1045 = ( ( ( $1044 ) ) + 76 | 0 ) ; $1046 = HEAP32 [ $1045 >> 2 ] | 0 ; $1047 = $5 ; $1048 = ( ( ( $1047 ) ) + 7112 | 0 ) ; $1049 = HEAP32 [ $1048 >> 2 ] | 0 ; $1050 = ( ( $1049 ) + ( $1046 ) ) | 0 ; HEAP32 [ $1048 >> 2 ] = $1050 ; } $1051 = $5 ; $1052 = ( ( ( $1051 ) ) + 68 | 0 ) ; $1053 = HEAP32 [ $1052 >> 2 ] | 0 ; $1054 = $5 ; $1055 = ( ( ( $1054 ) ) + 7116 | 0 ) ; HEAP32 [ $1055 >> 2 ] = $1053 ; $1056 = $5 ; $1057 = ( ( ( $1056 ) ) + 4 | 0 ) ; HEAP32 [ $1057 >> 2 ] = 16202 ; label = 143 ; } do { if ( ( label | 0 ) == 143 ) { while ( 1 ) { label = 0 ; $1058 = $5 ; $1059 = ( ( ( $1058 ) ) + 84 | 0 ) ; $1060 = HEAP32 [ $1059 >> 2 ] | 0 ; $1061 = $10 ; $1062 = $5 ; $1063 = ( ( ( $1062 ) ) + 92 | 0 ) ; $1064 = HEAP32 [ $1063 >> 2 ] | 0 ; $1065 = 1 << $1064 ; $1066 = ( ( $1065 ) - 1 ) | 0 ; $1067 = $1061 & $1066 ; $1068 = ( ( $1060 ) + ( $1067 << 2 ) | 0 ) ; ; HEAP16 [ $16 >> 1 ] = HEAP16 [ $1068 >> 1 ] | 0 ; HEAP16 [ $16 + 2 >> 1 ] = HEAP16 [ $1068 + 2 >> 1 ] | 0 ; $1069 = ( ( ( $16 ) ) + 1 | 0 ) ; $1070 = HEAP8 [ $1069 >> 0 ] | 0 ; $1071 = $1070 & 255 ; $1072 = $11 ; $1073 = ( $1071 >>> 0 ) <= ( $1072 >>> 0 ) ; if ( $1073 ) { break ; } $1074 = $8 ; $1075 = ( $1074 | 0 ) == ( 0 ) ; if ( $1075 ) { break L10 ; } $1076 = $8 ; $1077 = ( ( $1076 ) + - 1 ) | 0 ; $8 = $1077 ; $1078 = $6 ; $1079 = ( ( ( $1078 ) ) + 1 | 0 ) ; $6 = $1079 ; $1080 = HEAP8 [ $1078 >> 0 ] | 0 ; $1081 = $1080 & 255 ; $1082 = $11 ; $1083 = $1081 << $1082 ; $1084 = $10 ; $1085 = ( ( $1084 ) + ( $1083 ) ) | 0 ; $10 = $1085 ; $1086 = $11 ; $1087 = ( ( $1086 ) + 8 ) | 0 ; $11 = $1087 ; label = 143 ; } $1088 = HEAP8 [ $16 >> 0 ] | 0 ; $1089 = $1088 & 255 ; $1090 = $1089 & 240 ; $1091 = ( $1090 | 0 ) == ( 0 ) ; if ( $1091 ) { ; HEAP16 [ $17 >> 1 ] = HEAP16 [ $16 >> 1 ] | 0 ; HEAP16 [ $17 + 2 >> 1 ] = HEAP16 [ $16 + 2 >> 1 ] | 0 ; while ( 1 ) { $1092 = $5 ; $1093 = ( ( ( $1092 ) ) + 84 | 0 ) ; $1094 = HEAP32 [ $1093 >> 2 ] | 0 ; $1095 = ( ( ( $17 ) ) + 2 | 0 ) ; $1096 = HEAP16 [ $1095 >> 1 ] | 0 ; $1097 = $1096 & 65535 ; $1098 = $10 ; $1099 = ( ( ( $17 ) ) + 1 | 0 ) ; $1100 = HEAP8 [ $1099 >> 0 ] | 0 ; $1101 = $1100 & 255 ; $1102 = HEAP8 [ $17 >> 0 ] | 0 ; $1103 = $1102 & 255 ; $1104 = ( ( $1101 ) + ( $1103 ) ) | 0 ; $1105 = 1 << $1104 ; $1106 = ( ( $1105 ) - 1 ) | 0 ; $1107 = $1098 & $1106 ; $1108 = ( ( ( $17 ) ) + 1 | 0 ) ; $1109 = HEAP8 [ $1108 >> 0 ] | 0 ; $1110 = $1109 & 255 ; $1111 = $1107 >>> $1110 ; $1112 = ( ( $1097 ) + ( $1111 ) ) | 0 ; $1113 = ( ( $1094 ) + ( $1112 << 2 ) | 0 ) ; ; HEAP16 [ $16 >> 1 ] = HEAP16 [ $1113 >> 1 ] | 0 ; HEAP16 [ $16 + 2 >> 1 ] = HEAP16 [ $1113 + 2 >> 1 ] | 0 ; $1114 = ( ( ( $17 ) ) + 1 | 0 ) ; $1115 = HEAP8 [ $1114 >> 0 ] | 0 ; $1116 = $1115 & 255 ; $1117 = ( ( ( $16 ) ) + 1 | 0 ) ; $1118 = HEAP8 [ $1117 >> 0 ] | 0 ; $1119 = $1118 & 255 ; $1120 = ( ( $1116 ) + ( $1119 ) ) | 0 ; $1121 = $11 ; $1122 = ( $1120 >>> 0 ) <= ( $1121 >>> 0 ) ; if ( $1122 ) { break ; } $1123 = $8 ; $1124 = ( $1123 | 0 ) == ( 0 ) ; if ( $1124 ) { break L10 ; } $1125 = $8 ; $1126 = ( ( $1125 ) + - 1 ) | 0 ; $8 = $1126 ; $1127 = $6 ; $1128 = ( ( ( $1127 ) ) + 1 | 0 ) ; $6 = $1128 ; $1129 = HEAP8 [ $1127 >> 0 ] | 0 ; $1130 = $1129 & 255 ; $1131 = $11 ; $1132 = $1130 << $1131 ; $1133 = $10 ; $1134 = ( ( $1133 ) + ( $1132 ) ) | 0 ; $10 = $1134 ; $1135 = $11 ; $1136 = ( ( $1135 ) + 8 ) | 0 ; $11 = $1136 ; } $1137 = ( ( ( $17 ) ) + 1 | 0 ) ; $1138 = HEAP8 [ $1137 >> 0 ] | 0 ; $1139 = $1138 & 255 ; $1140 = $10 ; $1141 = $1140 >>> $1139 ; $10 = $1141 ; $1142 = ( ( ( $17 ) ) + 1 | 0 ) ; $1143 = HEAP8 [ $1142 >> 0 ] | 0 ; $1144 = $1143 & 255 ; $1145 = $11 ; $1146 = ( ( $1145 ) - ( $1144 ) ) | 0 ; $11 = $1146 ; $1147 = ( ( ( $17 ) ) + 1 | 0 ) ; $1148 = HEAP8 [ $1147 >> 0 ] | 0 ; $1149 = $1148 & 255 ; $1150 = $5 ; $1151 = ( ( ( $1150 ) ) + 7112 | 0 ) ; $1152 = HEAP32 [ $1151 >> 2 ] | 0 ; $1153 = ( ( $1152 ) + ( $1149 ) ) | 0 ; HEAP32 [ $1151 >> 2 ] = $1153 ; } $1154 = ( ( ( $16 ) ) + 1 | 0 ) ; $1155 = HEAP8 [ $1154 >> 0 ] | 0 ; $1156 = $1155 & 255 ; $1157 = $10 ; $1158 = $1157 >>> $1156 ; $10 = $1158 ; $1159 = ( ( ( $16 ) ) + 1 | 0 ) ; $1160 = HEAP8 [ $1159 >> 0 ] | 0 ; $1161 = $1160 & 255 ; $1162 = $11 ; $1163 = ( ( $1162 ) - ( $1161 ) ) | 0 ; $11 = $1163 ; $1164 = ( ( ( $16 ) ) + 1 | 0 ) ; $1165 = HEAP8 [ $1164 >> 0 ] | 0 ; $1166 = $1165 & 255 ; $1167 = $5 ; $1168 = ( ( ( $1167 ) ) + 7112 | 0 ) ; $1169 = HEAP32 [ $1168 >> 2 ] | 0 ; $1170 = ( ( $1169 ) + ( $1166 ) ) | 0 ; HEAP32 [ $1168 >> 2 ] = $1170 ; $1171 = HEAP8 [ $16 >> 0 ] | 0 ; $1172 = $1171 & 255 ; $1173 = $1172 & 64 ; $1174 = ( $1173 | 0 ) != ( 0 ) ; if ( $1174 ) { $1175 = $3 ; $1176 = ( ( ( $1175 ) ) + 24 | 0 ) ; HEAP32 [ $1176 >> 2 ] = 29708 ; $1177 = $5 ; $1178 = ( ( ( $1177 ) ) + 4 | 0 ) ; HEAP32 [ $1178 >> 2 ] = 16209 ; continue L10 ; } else { $1179 = ( ( ( $16 ) ) + 2 | 0 ) ; $1180 = HEAP16 [ $1179 >> 1 ] | 0 ; $1181 = $1180 & 65535 ; $1182 = $5 ; $1183 = ( ( ( $1182 ) ) + 72 | 0 ) ; HEAP32 [ $1183 >> 2 ] = $1181 ; $1184 = HEAP8 [ $16 >> 0 ] | 0 ; $1185 = $1184 & 255 ; $1186 = $1185 & 15 ; $1187 = $5 ; $1188 = ( ( ( $1187 ) ) + 76 | 0 ) ; HEAP32 [ $1188 >> 2 ] = $1186 ; $1189 = $5 ; $1190 = ( ( ( $1189 ) ) + 4 | 0 ) ; HEAP32 [ $1190 >> 2 ] = 16203 ; label = 155 ; break ; } } } while ( 0 ) ; if ( ( label | 0 ) == 155 ) { label = 0 ; $1191 = $5 ; $1192 = ( ( ( $1191 ) ) + 76 | 0 ) ; $1193 = HEAP32 [ $1192 >> 2 ] | 0 ; $1194 = ( $1193 | 0 ) != ( 0 ) ; if ( $1194 ) { while ( 1 ) { $1195 = $11 ; $1196 = $5 ; $1197 = ( ( ( $1196 ) ) + 76 | 0 ) ; $1198 = HEAP32 [ $1197 >> 2 ] | 0 ; $1199 = ( $1195 >>> 0 ) < ( $1198 >>> 0 ) ; if ( ! ( $1199 ) ) { break ; } $1200 = $8 ; $1201 = ( $1200 | 0 ) == ( 0 ) ; if ( $1201 ) { break L10 ; } $1202 = $8 ; $1203 = ( ( $1202 ) + - 1 ) | 0 ; $8 = $1203 ; $1204 = $6 ; $1205 = ( ( ( $1204 ) ) + 1 | 0 ) ; $6 = $1205 ; $1206 = HEAP8 [ $1204 >> 0 ] | 0 ; $1207 = $1206 & 255 ; $1208 = $11 ; $1209 = $1207 << $1208 ; $1210 = $10 ; $1211 = ( ( $1210 ) + ( $1209 ) ) | 0 ; $10 = $1211 ; $1212 = $11 ; $1213 = ( ( $1212 ) + 8 ) | 0 ; $11 = $1213 ; } $1214 = $10 ; $1215 = $5 ; $1216 = ( ( ( $1215 ) ) + 76 | 0 ) ; $1217 = HEAP32 [ $1216 >> 2 ] | 0 ; $1218 = 1 << $1217 ; $1219 = ( ( $1218 ) - 1 ) | 0 ; $1220 = $1214 & $1219 ; $1221 = $5 ; $1222 = ( ( ( $1221 ) ) + 72 | 0 ) ; $1223 = HEAP32 [ $1222 >> 2 ] | 0 ; $1224 = ( ( $1223 ) + ( $1220 ) ) | 0 ; HEAP32 [ $1222 >> 2 ] = $1224 ; $1225 = $5 ; $1226 = ( ( ( $1225 ) ) + 76 | 0 ) ; $1227 = HEAP32 [ $1226 >> 2 ] | 0 ; $1228 = $10 ; $1229 = $1228 >>> $1227 ; $10 = $1229 ; $1230 = $5 ; $1231 = ( ( ( $1230 ) ) + 76 | 0 ) ; $1232 = HEAP32 [ $1231 >> 2 ] | 0 ; $1233 = $11 ; $1234 = ( ( $1233 ) - ( $1232 ) ) | 0 ; $11 = $1234 ; $1235 = $5 ; $1236 = ( ( ( $1235 ) ) + 76 | 0 ) ; $1237 = HEAP32 [ $1236 >> 2 ] | 0 ; $1238 = $5 ; $1239 = ( ( ( $1238 ) ) + 7112 | 0 ) ; $1240 = HEAP32 [ $1239 >> 2 ] | 0 ; $1241 = ( ( $1240 ) + ( $1237 ) ) | 0 ; HEAP32 [ $1239 >> 2 ] = $1241 ; } $1242 = $5 ; $1243 = ( ( ( $1242 ) ) + 4 | 0 ) ; HEAP32 [ $1243 >> 2 ] = 16204 ; } $1244 = $9 ; $1245 = ( $1244 | 0 ) == ( 0 ) ; if ( $1245 ) { break ; } $1246 = $13 ; $1247 = $9 ; $1248 = ( ( $1246 ) - ( $1247 ) ) | 0 ; $14 = $1248 ; $1249 = $5 ; $1250 = ( ( ( $1249 ) ) + 72 | 0 ) ; $1251 = HEAP32 [ $1250 >> 2 ] | 0 ; $1252 = $14 ; $1253 = ( $1251 >>> 0 ) > ( $1252 >>> 0 ) ; if ( $1253 ) { $1254 = $5 ; $1255 = ( ( ( $1254 ) ) + 72 | 0 ) ; $1256 = HEAP32 [ $1255 >> 2 ] | 0 ; $1257 = $14 ; $1258 = ( ( $1256 ) - ( $1257 ) ) | 0 ; $14 = $1258 ; $1259 = $14 ; $1260 = $5 ; $1261 = ( ( ( $1260 ) ) + 48 | 0 ) ; $1262 = HEAP32 [ $1261 >> 2 ] | 0 ; $1263 = ( $1259 >>> 0 ) > ( $1262 >>> 0 ) ; if ( $1263 ) { $1264 = $5 ; $1265 = ( ( ( $1264 ) ) + 7108 | 0 ) ; $1266 = HEAP32 [ $1265 >> 2 ] | 0 ; $1267 = ( $1266 | 0 ) != ( 0 ) ; if ( $1267 ) { $1268 = $3 ; $1269 = ( ( ( $1268 ) ) + 24 | 0 ) ; HEAP32 [ $1269 >> 2 ] = 29678 ; $1270 = $5 ; $1271 = ( ( ( $1270 ) ) + 4 | 0 ) ; HEAP32 [ $1271 >> 2 ] = 16209 ; continue ; } } $1272 = $14 ; $1273 = $5 ; $1274 = ( ( ( $1273 ) ) + 52 | 0 ) ; $1275 = HEAP32 [ $1274 >> 2 ] | 0 ; $1276 = ( $1272 >>> 0 ) > ( $1275 >>> 0 ) ; $1277 = $5 ; if ( $1276 ) { $1278 = ( ( ( $1277 ) ) + 52 | 0 ) ; $1279 = HEAP32 [ $1278 >> 2 ] | 0 ; $1280 = $14 ; $1281 = ( ( $1280 ) - ( $1279 ) ) | 0 ; $14 = $1281 ; $1282 = $5 ; $1283 = ( ( ( $1282 ) ) + 56 | 0 ) ; $1284 = HEAP32 [ $1283 >> 2 ] | 0 ; $1285 = $5 ; $1286 = ( ( ( $1285 ) ) + 44 | 0 ) ; $1287 = HEAP32 [ $1286 >> 2 ] | 0 ; $1288 = $14 ; $1289 = ( ( $1287 ) - ( $1288 ) ) | 0 ; $1290 = ( ( $1284 ) + ( $1289 ) | 0 ) ; $15 = $1290 ; } else { $1291 = ( ( ( $1277 ) ) + 56 | 0 ) ; $1292 = HEAP32 [ $1291 >> 2 ] | 0 ; $1293 = $5 ; $1294 = ( ( ( $1293 ) ) + 52 | 0 ) ; $1295 = HEAP32 [ $1294 >> 2 ] | 0 ; $1296 = $14 ; $1297 = ( ( $1295 ) - ( $1296 ) ) | 0 ; $1298 = ( ( $1292 ) + ( $1297 ) | 0 ) ; $15 = $1298 ; } $1299 = $14 ; $1300 = $5 ; $1301 = ( ( ( $1300 ) ) + 68 | 0 ) ; $1302 = HEAP32 [ $1301 >> 2 ] | 0 ; $1303 = ( $1299 >>> 0 ) > ( $1302 >>> 0 ) ; if ( $1303 ) { $1304 = $5 ; $1305 = ( ( ( $1304 ) ) + 68 | 0 ) ; $1306 = HEAP32 [ $1305 >> 2 ] | 0 ; $14 = $1306 ; } } else { $1307 = $7 ; $1308 = $5 ; $1309 = ( ( ( $1308 ) ) + 72 | 0 ) ; $1310 = HEAP32 [ $1309 >> 2 ] | 0 ; $1311 = ( 0 - ( $1310 ) ) | 0 ; $1312 = ( ( $1307 ) + ( $1311 ) | 0 ) ; $15 = $1312 ; $1313 = $5 ; $1314 = ( ( ( $1313 ) ) + 68 | 0 ) ; $1315 = HEAP32 [ $1314 >> 2 ] | 0 ; $14 = $1315 ; } $1316 = $14 ; $1317 = $9 ; $1318 = ( $1316 >>> 0 ) > ( $1317 >>> 0 ) ; if ( $1318 ) { $1319 = $9 ; $14 = $1319 ; } $1320 = $14 ; $1321 = $9 ; $1322 = ( ( $1321 ) - ( $1320 ) ) | 0 ; $9 = $1322 ; $1323 = $14 ; $1324 = $5 ; $1325 = ( ( ( $1324 ) ) + 68 | 0 ) ; $1326 = HEAP32 [ $1325 >> 2 ] | 0 ; $1327 = ( ( $1326 ) - ( $1323 ) ) | 0 ; HEAP32 [ $1325 >> 2 ] = $1327 ; while ( 1 ) { $1328 = $15 ; $1329 = ( ( ( $1328 ) ) + 1 | 0 ) ; $15 = $1329 ; $1330 = HEAP8 [ $1328 >> 0 ] | 0 ; $1331 = $7 ; $1332 = ( ( ( $1331 ) ) + 1 | 0 ) ; $7 = $1332 ; HEAP8 [ $1331 >> 0 ] = $1330 ; $1333 = $14 ; $1334 = ( ( $1333 ) + - 1 ) | 0 ; $14 = $1334 ; $1335 = ( $1334 | 0 ) != ( 0 ) ; if ( ! ( $1335 ) ) { break ; } } $1336 = $5 ; $1337 = ( ( ( $1336 ) ) + 68 | 0 ) ; $1338 = HEAP32 [ $1337 >> 2 ] | 0 ; $1339 = ( $1338 | 0 ) == ( 0 ) ; if ( ! ( $1339 ) ) { continue ; } $1340 = $5 ; $1341 = ( ( ( $1340 ) ) + 4 | 0 ) ; HEAP32 [ $1341 >> 2 ] = 16200 ; } if ( ( label | 0 ) == 30 ) { $187 = $7 ; $188 = $3 ; $189 = ( ( ( $188 ) ) + 12 | 0 ) ; HEAP32 [ $189 >> 2 ] = $187 ; $190 = $9 ; $191 = $3 ; $192 = ( ( ( $191 ) ) + 16 | 0 ) ; HEAP32 [ $192 >> 2 ] = $190 ; $193 = $6 ; $194 = $3 ; HEAP32 [ $194 >> 2 ] = $193 ; $195 = $8 ; $196 = $3 ; $197 = ( ( ( $196 ) ) + 4 | 0 ) ; HEAP32 [ $197 >> 2 ] = $195 ; $198 = $10 ; $199 = $5 ; $200 = ( ( ( $199 ) ) + 60 | 0 ) ; HEAP32 [ $200 >> 2 ] = $198 ; $201 = $11 ; $202 = $5 ; $203 = ( ( ( $202 ) ) + 64 | 0 ) ; HEAP32 [ $203 >> 2 ] = $201 ; $2 = 2 ; $1571 = $2 ; STACKTOP = sp ; return ( $1571 | 0 ) ; } else if ( ( label | 0 ) == 41 ) { $261 = $10 ; $262 = $261 >>> 2 ; $10 = $262 ; $263 = $11 ; $264 = ( ( $263 ) - 2 ) | 0 ; $11 = $264 ; } else if ( ( label | 0 ) == 44 ) { // unreachable; } else if ( ( label | 0 ) == 189 ) { $10 = 0 ; $11 = 0 ; label = 190 ; } else if ( ( label | 0 ) == 192 ) { $19 = - 3 ; } else if ( ( label | 0 ) == 193 ) { $2 = - 4 ; $1571 = $2 ; STACKTOP = sp ; return ( $1571 | 0 ) ; } else if ( ( label | 0 ) == 194 ) { $2 = - 2 ; $1571 = $2 ; STACKTOP = sp ; return ( $1571 | 0 ) ; } if ( ( label | 0 ) == 190 ) { $1436 = $5 ; $1437 = ( ( ( $1436 ) ) + 4 | 0 ) ; HEAP32 [ $1437 >> 2 ] = 16208 ; label = 191 ; } if ( ( label | 0 ) == 191 ) { $19 = 1 ; } $1438 = $7 ; $1439 = $3 ; $1440 = ( ( ( $1439 ) ) + 12 | 0 ) ; HEAP32 [ $1440 >> 2 ] = $1438 ; $1441 = $9 ; $1442 = $3 ; $1443 = ( ( ( $1442 ) ) + 16 | 0 ) ; HEAP32 [ $1443 >> 2 ] = $1441 ; $1444 = $6 ; $1445 = $3 ; HEAP32 [ $1445 >> 2 ] = $1444 ; $1446 = $8 ; $1447 = $3 ; $1448 = ( ( ( $1447 ) ) + 4 | 0 ) ; HEAP32 [ $1448 >> 2 ] = $1446 ; $1449 = $10 ; $1450 = $5 ; $1451 = ( ( ( $1450 ) ) + 60 | 0 ) ; HEAP32 [ $1451 >> 2 ] = $1449 ; $1452 = $11 ; $1453 = $5 ; $1454 = ( ( ( $1453 ) ) + 64 | 0 ) ; HEAP32 [ $1454 >> 2 ] = $1452 ; $1455 = $5 ; $1456 = ( ( ( $1455 ) ) + 44 | 0 ) ; $1457 = HEAP32 [ $1456 >> 2 ] | 0 ; $1458 = ( $1457 | 0 ) != ( 0 ) ; if ( $1458 ) { label = 199 ; } else { $1459 = $13 ; $1460 = $3 ; $1461 = ( ( ( $1460 ) ) + 16 | 0 ) ; $1462 = HEAP32 [ $1461 >> 2 ] | 0 ; $1463 = ( $1459 | 0 ) != ( $1462 | 0 ) ; if ( $1463 ) { $1464 = $5 ; $1465 = ( ( ( $1464 ) ) + 4 | 0 ) ; $1466 = HEAP32 [ $1465 >> 2 ] | 0 ; $1467 = ( $1466 >>> 0 ) < ( 16209 ) ; if ( $1467 ) { $1468 = $5 ; $1469 = ( ( ( $1468 ) ) + 4 | 0 ) ; $1470 = HEAP32 [ $1469 >> 2 ] | 0 ; $1471 = ( $1470 >>> 0 ) < ( 16206 ) ; $1472 = $4 ; $1473 = ( $1472 | 0 ) != ( 4 ) ; $or$cond8 = $1471 | $1473 ; if ( $or$cond8 ) { label = 199 ; } } } } if ( ( label | 0 ) == 199 ) { $1474 = $3 ; $1475 = $3 ; $1476 = ( ( ( $1475 ) ) + 12 | 0 ) ; $1477 = HEAP32 [ $1476 >> 2 ] | 0 ; $1478 = $13 ; $1479 = $3 ; $1480 = ( ( ( $1479 ) ) + 16 | 0 ) ; $1481 = HEAP32 [ $1480 >> 2 ] | 0 ; $1482 = ( ( $1478 ) - ( $1481 ) ) | 0 ; $1483 = ( _updatewindow ( $1474 , $1477 , $1482 ) | 0 ) ; $1484 = ( $1483 | 0 ) != ( 0 ) ; if ( $1484 ) { $1485 = $5 ; $1486 = ( ( ( $1485 ) ) + 4 | 0 ) ; HEAP32 [ $1486 >> 2 ] = 16210 ; $2 = - 4 ; $1571 = $2 ; STACKTOP = sp ; return ( $1571 | 0 ) ; } } $1487 = $3 ; $1488 = ( ( ( $1487 ) ) + 4 | 0 ) ; $1489 = HEAP32 [ $1488 >> 2 ] | 0 ; $1490 = $12 ; $1491 = ( ( $1490 ) - ( $1489 ) ) | 0 ; $12 = $1491 ; $1492 = $3 ; $1493 = ( ( ( $1492 ) ) + 16 | 0 ) ; $1494 = HEAP32 [ $1493 >> 2 ] | 0 ; $1495 = $13 ; $1496 = ( ( $1495 ) - ( $1494 ) ) | 0 ; $13 = $1496 ; $1497 = $12 ; $1498 = $3 ; $1499 = ( ( ( $1498 ) ) + 8 | 0 ) ; $1500 = HEAP32 [ $1499 >> 2 ] | 0 ; $1501 = ( ( $1500 ) + ( $1497 ) ) | 0 ; HEAP32 [ $1499 >> 2 ] = $1501 ; $1502 = $13 ; $1503 = $3 ; $1504 = ( ( ( $1503 ) ) + 20 | 0 ) ; $1505 = HEAP32 [ $1504 >> 2 ] | 0 ; $1506 = ( ( $1505 ) + ( $1502 ) ) | 0 ; HEAP32 [ $1504 >> 2 ] = $1506 ; $1507 = $13 ; $1508 = $5 ; $1509 = ( ( ( $1508 ) ) + 32 | 0 ) ; $1510 = HEAP32 [ $1509 >> 2 ] | 0 ; $1511 = ( ( $1510 ) + ( $1507 ) ) | 0 ; HEAP32 [ $1509 >> 2 ] = $1511 ; $1512 = $5 ; $1513 = ( ( ( $1512 ) ) + 12 | 0 ) ; $1514 = HEAP32 [ $1513 >> 2 ] | 0 ; $1515 = $1514 & 4 ; $1516 = ( $1515 | 0 ) != ( 0 ) ; $1517 = $13 ; $1518 = ( $1517 | 0 ) != ( 0 ) ; $or$cond10 = $1516 & $1518 ; if ( $or$cond10 ) { $1519 = $5 ; $1520 = ( ( ( $1519 ) ) + 28 | 0 ) ; $1521 = HEAP32 [ $1520 >> 2 ] | 0 ; $1522 = $3 ; $1523 = ( ( ( $1522 ) ) + 12 | 0 ) ; $1524 = HEAP32 [ $1523 >> 2 ] | 0 ; $1525 = $13 ; $1526 = ( 0 - ( $1525 ) ) | 0 ; $1527 = ( ( $1524 ) + ( $1526 ) | 0 ) ; $1528 = $13 ; $1529 = ( _adler32 ( $1521 , $1527 , $1528 ) | 0 ) ; $1530 = $5 ; $1531 = ( ( ( $1530 ) ) + 28 | 0 ) ; HEAP32 [ $1531 >> 2 ] = $1529 ; $1532 = $3 ; $1533 = ( ( ( $1532 ) ) + 48 | 0 ) ; HEAP32 [ $1533 >> 2 ] = $1529 ; } $1534 = $5 ; $1535 = ( ( ( $1534 ) ) + 64 | 0 ) ; $1536 = HEAP32 [ $1535 >> 2 ] | 0 ; $1537 = $5 ; $1538 = ( ( ( $1537 ) ) + 8 | 0 ) ; $1539 = HEAP32 [ $1538 >> 2 ] | 0 ; $1540 = ( $1539 | 0 ) != ( 0 ) ; $1541 = $1540 ? 64 : 0 ; $1542 = ( ( $1536 ) + ( $1541 ) ) | 0 ; $1543 = $5 ; $1544 = ( ( ( $1543 ) ) + 4 | 0 ) ; $1545 = HEAP32 [ $1544 >> 2 ] | 0 ; $1546 = ( $1545 | 0 ) == ( 16191 ) ; $1547 = $1546 ? 128 : 0 ; $1548 = ( ( $1542 ) + ( $1547 ) ) | 0 ; $1549 = $5 ; $1550 = ( ( ( $1549 ) ) + 4 | 0 ) ; $1551 = HEAP32 [ $1550 >> 2 ] | 0 ; $1552 = ( $1551 | 0 ) == ( 16199 ) ; if ( $1552 ) { $1557 = 1 ; } else { $1553 = $5 ; $1554 = ( ( ( $1553 ) ) + 4 | 0 ) ; $1555 = HEAP32 [ $1554 >> 2 ] | 0 ; $1556 = ( $1555 | 0 ) == ( 16194 ) ; $1557 = $1556 ; } $1558 = $1557 ? 256 : 0 ; $1559 = ( ( $1548 ) + ( $1558 ) ) | 0 ; $1560 = $3 ; $1561 = ( ( ( $1560 ) ) + 44 | 0 ) ; HEAP32 [ $1561 >> 2 ] = $1559 ; $1562 = $12 ; $1563 = ( $1562 | 0 ) == ( 0 ) ; $1564 = $13 ; $1565 = ( $1564 | 0 ) == ( 0 ) ; $or$cond12 = $1563 & $1565 ; $1566 = $4 ; $1567 = ( $1566 | 0 ) == ( 4 ) ; $or$cond14 = $or$cond12 | $1567 ; $1568 = $19 ; $1569 = ( $1568 | 0 ) == ( 0 ) ; $or$cond16 = $or$cond14 & $1569 ; if ( $or$cond16 ) { $19 = - 5 ; } $1570 = $19 ; $2 = $1570 ; $1571 = $2 ; STACKTOP = sp ; return ( $1571 | 0 ) ; } } } while ( 0 ) ; $2 = - 2 ; $1571 = $2 ; STACKTOP = sp ; return ( $1571 | 0 ) ; } function _fixedtables ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $2 = $1 ; $3 = ( ( ( $2 ) ) + 80 | 0 ) ; HEAP32 [ $3 >> 2 ] = 10126 ; $4 = $1 ; $5 = ( ( ( $4 ) ) + 88 | 0 ) ; HEAP32 [ $5 >> 2 ] = 9 ; $6 = $1 ; $7 = ( ( ( $6 ) ) + 84 | 0 ) ; HEAP32 [ $7 >> 2 ] = 12174 ; $8 = $1 ; $9 = ( ( ( $8 ) ) + 92 | 0 ) ; HEAP32 [ $9 >> 2 ] = 5 ; STACKTOP = sp ; return ; } function _updatewindow ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 ; var $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 ; var $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 ; var $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 ; var $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 ; var $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $9 = $4 ; $10 = ( ( ( $9 ) ) + 28 | 0 ) ; $11 = HEAP32 [ $10 >> 2 ] | 0 ; $7 = $11 ; $12 = $7 ; $13 = ( ( ( $12 ) ) + 56 | 0 ) ; $14 = HEAP32 [ $13 >> 2 ] | 0 ; $15 = ( $14 | 0 ) == ( 0 | 0 ) ; if ( $15 ) { $16 = $4 ; $17 = ( ( ( $16 ) ) + 32 | 0 ) ; $18 = HEAP32 [ $17 >> 2 ] | 0 ; $19 = $4 ; $20 = ( ( ( $19 ) ) + 40 | 0 ) ; $21 = HEAP32 [ $20 >> 2 ] | 0 ; $22 = $7 ; $23 = ( ( ( $22 ) ) + 40 | 0 ) ; $24 = HEAP32 [ $23 >> 2 ] | 0 ; $25 = 1 << $24 ; $26 = ( FUNCTION_TABLE_iiii [ $18 & 127 ] ( $21 , $25 , 1 ) | 0 ) ; $27 = $7 ; $28 = ( ( ( $27 ) ) + 56 | 0 ) ; HEAP32 [ $28 >> 2 ] = $26 ; $29 = $7 ; $30 = ( ( ( $29 ) ) + 56 | 0 ) ; $31 = HEAP32 [ $30 >> 2 ] | 0 ; $32 = ( $31 | 0 ) == ( 0 | 0 ) ; if ( $32 ) { $3 = 1 ; $140 = $3 ; STACKTOP = sp ; return ( $140 | 0 ) ; } } $33 = $7 ; $34 = ( ( ( $33 ) ) + 44 | 0 ) ; $35 = HEAP32 [ $34 >> 2 ] | 0 ; $36 = ( $35 | 0 ) == ( 0 ) ; if ( $36 ) { $37 = $7 ; $38 = ( ( ( $37 ) ) + 40 | 0 ) ; $39 = HEAP32 [ $38 >> 2 ] | 0 ; $40 = 1 << $39 ; $41 = $7 ; $42 = ( ( ( $41 ) ) + 44 | 0 ) ; HEAP32 [ $42 >> 2 ] = $40 ; $43 = $7 ; $44 = ( ( ( $43 ) ) + 52 | 0 ) ; HEAP32 [ $44 >> 2 ] = 0 ; $45 = $7 ; $46 = ( ( ( $45 ) ) + 48 | 0 ) ; HEAP32 [ $46 >> 2 ] = 0 ; } $47 = $6 ; $48 = $7 ; $49 = ( ( ( $48 ) ) + 44 | 0 ) ; $50 = HEAP32 [ $49 >> 2 ] | 0 ; $51 = ( $47 >>> 0 ) >= ( $50 >>> 0 ) ; $52 = $7 ; do { if ( $51 ) { $53 = ( ( ( $52 ) ) + 56 | 0 ) ; $54 = HEAP32 [ $53 >> 2 ] | 0 ; $55 = $5 ; $56 = $7 ; $57 = ( ( ( $56 ) ) + 44 | 0 ) ; $58 = HEAP32 [ $57 >> 2 ] | 0 ; $59 = ( 0 - ( $58 ) ) | 0 ; $60 = ( ( $55 ) + ( $59 ) | 0 ) ; $61 = $7 ; $62 = ( ( ( $61 ) ) + 44 | 0 ) ; $63 = HEAP32 [ $62 >> 2 ] | 0 ; _memcpy ( ( $54 | 0 ) , ( $60 | 0 ) , ( $63 | 0 ) ) | 0 ; $64 = $7 ; $65 = ( ( ( $64 ) ) + 52 | 0 ) ; HEAP32 [ $65 >> 2 ] = 0 ; $66 = $7 ; $67 = ( ( ( $66 ) ) + 44 | 0 ) ; $68 = HEAP32 [ $67 >> 2 ] | 0 ; $69 = $7 ; $70 = ( ( ( $69 ) ) + 48 | 0 ) ; HEAP32 [ $70 >> 2 ] = $68 ; } else { $71 = ( ( ( $52 ) ) + 44 | 0 ) ; $72 = HEAP32 [ $71 >> 2 ] | 0 ; $73 = $7 ; $74 = ( ( ( $73 ) ) + 52 | 0 ) ; $75 = HEAP32 [ $74 >> 2 ] | 0 ; $76 = ( ( $72 ) - ( $75 ) ) | 0 ; $8 = $76 ; $77 = $8 ; $78 = $6 ; $79 = ( $77 >>> 0 ) > ( $78 >>> 0 ) ; if ( $79 ) { $80 = $6 ; $8 = $80 ; } $81 = $7 ; $82 = ( ( ( $81 ) ) + 56 | 0 ) ; $83 = HEAP32 [ $82 >> 2 ] | 0 ; $84 = $7 ; $85 = ( ( ( $84 ) ) + 52 | 0 ) ; $86 = HEAP32 [ $85 >> 2 ] | 0 ; $87 = ( ( $83 ) + ( $86 ) | 0 ) ; $88 = $5 ; $89 = $6 ; $90 = ( 0 - ( $89 ) ) | 0 ; $91 = ( ( $88 ) + ( $90 ) | 0 ) ; $92 = $8 ; _memcpy ( ( $87 | 0 ) , ( $91 | 0 ) , ( $92 | 0 ) ) | 0 ; $93 = $8 ; $94 = $6 ; $95 = ( ( $94 ) - ( $93 ) ) | 0 ; $6 = $95 ; $96 = $6 ; $97 = ( $96 | 0 ) != ( 0 ) ; if ( $97 ) { $98 = $7 ; $99 = ( ( ( $98 ) ) + 56 | 0 ) ; $100 = HEAP32 [ $99 >> 2 ] | 0 ; $101 = $5 ; $102 = $6 ; $103 = ( 0 - ( $102 ) ) | 0 ; $104 = ( ( $101 ) + ( $103 ) | 0 ) ; $105 = $6 ; _memcpy ( ( $100 | 0 ) , ( $104 | 0 ) , ( $105 | 0 ) ) | 0 ; $106 = $6 ; $107 = $7 ; $108 = ( ( ( $107 ) ) + 52 | 0 ) ; HEAP32 [ $108 >> 2 ] = $106 ; $109 = $7 ; $110 = ( ( ( $109 ) ) + 44 | 0 ) ; $111 = HEAP32 [ $110 >> 2 ] | 0 ; $112 = $7 ; $113 = ( ( ( $112 ) ) + 48 | 0 ) ; HEAP32 [ $113 >> 2 ] = $111 ; break ; } $114 = $8 ; $115 = $7 ; $116 = ( ( ( $115 ) ) + 52 | 0 ) ; $117 = HEAP32 [ $116 >> 2 ] | 0 ; $118 = ( ( $117 ) + ( $114 ) ) | 0 ; HEAP32 [ $116 >> 2 ] = $118 ; $119 = $7 ; $120 = ( ( ( $119 ) ) + 52 | 0 ) ; $121 = HEAP32 [ $120 >> 2 ] | 0 ; $122 = $7 ; $123 = ( ( ( $122 ) ) + 44 | 0 ) ; $124 = HEAP32 [ $123 >> 2 ] | 0 ; $125 = ( $121 | 0 ) == ( $124 | 0 ) ; if ( $125 ) { $126 = $7 ; $127 = ( ( ( $126 ) ) + 52 | 0 ) ; HEAP32 [ $127 >> 2 ] = 0 ; } $128 = $7 ; $129 = ( ( ( $128 ) ) + 48 | 0 ) ; $130 = HEAP32 [ $129 >> 2 ] | 0 ; $131 = $7 ; $132 = ( ( ( $131 ) ) + 44 | 0 ) ; $133 = HEAP32 [ $132 >> 2 ] | 0 ; $134 = ( $130 >>> 0 ) < ( $133 >>> 0 ) ; if ( $134 ) { $135 = $8 ; $136 = $7 ; $137 = ( ( ( $136 ) ) + 48 | 0 ) ; $138 = HEAP32 [ $137 >> 2 ] | 0 ; $139 = ( ( $138 ) + ( $135 ) ) | 0 ; HEAP32 [ $137 >> 2 ] = $139 ; } } } while ( 0 ) ; $3 = 0 ; $140 = $3 ; STACKTOP = sp ; return ( $140 | 0 ) ; } function _inflateEnd ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 ; var $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = $0 ; $4 = $2 ; $5 = ( _inflateStateCheck ( $4 ) | 0 ) ; $6 = ( $5 | 0 ) != ( 0 ) ; if ( $6 ) { $1 = - 2 ; $34 = $1 ; STACKTOP = sp ; return ( $34 | 0 ) ; } $7 = $2 ; $8 = ( ( ( $7 ) ) + 28 | 0 ) ; $9 = HEAP32 [ $8 >> 2 ] | 0 ; $3 = $9 ; $10 = $3 ; $11 = ( ( ( $10 ) ) + 56 | 0 ) ; $12 = HEAP32 [ $11 >> 2 ] | 0 ; $13 = ( $12 | 0 ) != ( 0 | 0 ) ; if ( $13 ) { $14 = $2 ; $15 = ( ( ( $14 ) ) + 36 | 0 ) ; $16 = HEAP32 [ $15 >> 2 ] | 0 ; $17 = $2 ; $18 = ( ( ( $17 ) ) + 40 | 0 ) ; $19 = HEAP32 [ $18 >> 2 ] | 0 ; $20 = $3 ; $21 = ( ( ( $20 ) ) + 56 | 0 ) ; $22 = HEAP32 [ $21 >> 2 ] | 0 ; FUNCTION_TABLE_vii [ $16 & 127 ] ( $19 , $22 ) ; } $23 = $2 ; $24 = ( ( ( $23 ) ) + 36 | 0 ) ; $25 = HEAP32 [ $24 >> 2 ] | 0 ; $26 = $2 ; $27 = ( ( ( $26 ) ) + 40 | 0 ) ; $28 = HEAP32 [ $27 >> 2 ] | 0 ; $29 = $2 ; $30 = ( ( ( $29 ) ) + 28 | 0 ) ; $31 = HEAP32 [ $30 >> 2 ] | 0 ; FUNCTION_TABLE_vii [ $25 & 127 ] ( $28 , $31 ) ; $32 = $2 ; $33 = ( ( ( $32 ) ) + 28 | 0 ) ; HEAP32 [ $33 >> 2 ] = 0 ; $1 = 0 ; $34 = $1 ; STACKTOP = sp ; return ( $34 | 0 ) ; } function _inflate_table ( $0 , $1 , $2 , $3 , $4 , $5 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; $4 = $4 | 0 ; $5 = $5 | 0 ; var $$sink$sink = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 ; var $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 ; var $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 ; var $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 ; var $171 = 0 , $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 ; var $19 = 0 , $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 ; var $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 ; var $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 ; var $244 = 0 , $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 , $258 = 0 , $259 = 0 , $26 = 0 , $260 = 0 , $261 = 0 ; var $262 = 0 , $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 , $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 , $270 = 0 , $271 = 0 , $272 = 0 , $273 = 0 , $274 = 0 , $275 = 0 , $276 = 0 , $277 = 0 , $278 = 0 , $279 = 0 , $28 = 0 ; var $280 = 0 , $281 = 0 , $282 = 0 , $283 = 0 , $284 = 0 , $285 = 0 , $286 = 0 , $287 = 0 , $288 = 0 , $289 = 0 , $29 = 0 , $290 = 0 , $291 = 0 , $292 = 0 , $293 = 0 , $294 = 0 , $295 = 0 , $296 = 0 , $297 = 0 , $298 = 0 ; var $299 = 0 , $30 = 0 , $300 = 0 , $301 = 0 , $302 = 0 , $303 = 0 , $304 = 0 , $305 = 0 , $306 = 0 , $307 = 0 , $308 = 0 , $309 = 0 , $31 = 0 , $310 = 0 , $311 = 0 , $312 = 0 , $313 = 0 , $314 = 0 , $315 = 0 , $316 = 0 ; var $317 = 0 , $318 = 0 , $319 = 0 , $32 = 0 , $320 = 0 , $321 = 0 , $322 = 0 , $323 = 0 , $324 = 0 , $325 = 0 , $326 = 0 , $327 = 0 , $328 = 0 , $329 = 0 , $33 = 0 , $330 = 0 , $331 = 0 , $332 = 0 , $333 = 0 , $334 = 0 ; var $335 = 0 , $336 = 0 , $337 = 0 , $338 = 0 , $339 = 0 , $34 = 0 , $340 = 0 , $341 = 0 , $342 = 0 , $343 = 0 , $344 = 0 , $345 = 0 , $346 = 0 , $347 = 0 , $348 = 0 , $349 = 0 , $35 = 0 , $350 = 0 , $351 = 0 , $352 = 0 ; var $353 = 0 , $354 = 0 , $355 = 0 , $356 = 0 , $357 = 0 , $358 = 0 , $359 = 0 , $36 = 0 , $360 = 0 , $361 = 0 , $362 = 0 , $363 = 0 , $364 = 0 , $365 = 0 , $366 = 0 , $367 = 0 , $368 = 0 , $369 = 0 , $37 = 0 , $370 = 0 ; var $38 = 0 , $39 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 ; var $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 ; var $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 ; var $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $or$cond = 0 , $or$cond11 = 0 , $or$cond3 = 0 , $or$cond5 = 0 , $or$cond9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 176 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 176 | 0 ) ; $27 = sp + 168 | 0 ; $32 = sp + 136 | 0 ; $33 = sp + 104 | 0 ; $7 = $0 ; $8 = $1 ; $9 = $2 ; $10 = $3 ; $11 = $4 ; $12 = $5 ; $13 = 0 ; while ( 1 ) { $34 = $13 ; $35 = ( $34 >>> 0 ) <= ( 15 ) ; if ( ! ( $35 ) ) { break ; } $36 = $13 ; $37 = ( ( $32 ) + ( $36 << 1 ) | 0 ) ; HEAP16 [ $37 >> 1 ] = 0 ; $38 = $13 ; $39 = ( ( $38 ) + 1 ) | 0 ; $13 = $39 ; } $14 = 0 ; while ( 1 ) { $40 = $14 ; $41 = $9 ; $42 = ( $40 >>> 0 ) < ( $41 >>> 0 ) ; if ( ! ( $42 ) ) { break ; } $43 = $8 ; $44 = $14 ; $45 = ( ( $43 ) + ( $44 << 1 ) | 0 ) ; $46 = HEAP16 [ $45 >> 1 ] | 0 ; $47 = $46 & 65535 ; $48 = ( ( $32 ) + ( $47 << 1 ) | 0 ) ; $49 = HEAP16 [ $48 >> 1 ] | 0 ; $50 = ( ( $49 ) + 1 ) << 16 >> 16 ; HEAP16 [ $48 >> 1 ] = $50 ; $51 = $14 ; $52 = ( ( $51 ) + 1 ) | 0 ; $14 = $52 ; } $53 = $11 ; $54 = HEAP32 [ $53 >> 2 ] | 0 ; $17 = $54 ; $16 = 15 ; while ( 1 ) { $55 = $16 ; $56 = ( $55 >>> 0 ) >= ( 1 ) ; if ( ! ( $56 ) ) { break ; } $57 = $16 ; $58 = ( ( $32 ) + ( $57 << 1 ) | 0 ) ; $59 = HEAP16 [ $58 >> 1 ] | 0 ; $60 = $59 & 65535 ; $61 = ( $60 | 0 ) != ( 0 ) ; if ( $61 ) { break ; } $62 = $16 ; $63 = ( ( $62 ) + - 1 ) | 0 ; $16 = $63 ; } $64 = $17 ; $65 = $16 ; $66 = ( $64 >>> 0 ) > ( $65 >>> 0 ) ; if ( $66 ) { $67 = $16 ; $17 = $67 ; } $68 = $16 ; $69 = ( $68 | 0 ) == ( 0 ) ; if ( $69 ) { HEAP8 [ $27 >> 0 ] = 64 ; $70 = ( ( ( $27 ) ) + 1 | 0 ) ; HEAP8 [ $70 >> 0 ] = 1 ; $71 = ( ( ( $27 ) ) + 2 | 0 ) ; HEAP16 [ $71 >> 1 ] = 0 ; $72 = $10 ; $73 = HEAP32 [ $72 >> 2 ] | 0 ; $74 = ( ( ( $73 ) ) + 4 | 0 ) ; HEAP32 [ $72 >> 2 ] = $74 ; ; HEAP16 [ $73 >> 1 ] = HEAP16 [ $27 >> 1 ] | 0 ; HEAP16 [ $73 + 2 >> 1 ] = HEAP16 [ $27 + 2 >> 1 ] | 0 ; $75 = $10 ; $76 = HEAP32 [ $75 >> 2 ] | 0 ; $77 = ( ( ( $76 ) ) + 4 | 0 ) ; HEAP32 [ $75 >> 2 ] = $77 ; ; HEAP16 [ $76 >> 1 ] = HEAP16 [ $27 >> 1 ] | 0 ; HEAP16 [ $76 + 2 >> 1 ] = HEAP16 [ $27 + 2 >> 1 ] | 0 ; $78 = $11 ; HEAP32 [ $78 >> 2 ] = 1 ; $6 = 0 ; $370 = $6 ; STACKTOP = sp ; return ( $370 | 0 ) ; } $15 = 1 ; while ( 1 ) { $79 = $15 ; $80 = $16 ; $81 = ( $79 >>> 0 ) < ( $80 >>> 0 ) ; if ( ! ( $81 ) ) { break ; } $82 = $15 ; $83 = ( ( $32 ) + ( $82 << 1 ) | 0 ) ; $84 = HEAP16 [ $83 >> 1 ] | 0 ; $85 = $84 & 65535 ; $86 = ( $85 | 0 ) != ( 0 ) ; if ( $86 ) { break ; } $87 = $15 ; $88 = ( ( $87 ) + 1 ) | 0 ; $15 = $88 ; } $89 = $17 ; $90 = $15 ; $91 = ( $89 >>> 0 ) < ( $90 >>> 0 ) ; if ( $91 ) { $92 = $15 ; $17 = $92 ; } $20 = 1 ; $13 = 1 ; while ( 1 ) { $93 = $13 ; $94 = ( $93 >>> 0 ) <= ( 15 ) ; $95 = $20 ; if ( ! ( $94 ) ) { break ; } $96 = $95 << 1 ; $20 = $96 ; $97 = $13 ; $98 = ( ( $32 ) + ( $97 << 1 ) | 0 ) ; $99 = HEAP16 [ $98 >> 1 ] | 0 ; $100 = $99 & 65535 ; $101 = $20 ; $102 = ( ( $101 ) - ( $100 ) ) | 0 ; $20 = $102 ; $103 = $20 ; $104 = ( $103 | 0 ) < ( 0 ) ; if ( $104 ) { label = 24 ; break ; } $105 = $13 ; $106 = ( ( $105 ) + 1 ) | 0 ; $13 = $106 ; } if ( ( label | 0 ) == 24 ) { $6 = - 1 ; $370 = $6 ; STACKTOP = sp ; return ( $370 | 0 ) ; } $107 = ( $95 | 0 ) > ( 0 ) ; if ( $107 ) { $108 = $7 ; $109 = ( $108 | 0 ) == ( 0 ) ; $110 = $16 ; $111 = ( $110 | 0 ) != ( 1 ) ; $or$cond = $109 | $111 ; if ( $or$cond ) { $6 = - 1 ; $370 = $6 ; STACKTOP = sp ; return ( $370 | 0 ) ; } } $112 = ( ( ( $33 ) ) + 2 | 0 ) ; HEAP16 [ $112 >> 1 ] = 0 ; $13 = 1 ; while ( 1 ) { $113 = $13 ; $114 = ( $113 >>> 0 ) < ( 15 ) ; if ( ! ( $114 ) ) { break ; } $115 = $13 ; $116 = ( ( $33 ) + ( $115 << 1 ) | 0 ) ; $117 = HEAP16 [ $116 >> 1 ] | 0 ; $118 = $117 & 65535 ; $119 = $13 ; $120 = ( ( $32 ) + ( $119 << 1 ) | 0 ) ; $121 = HEAP16 [ $120 >> 1 ] | 0 ; $122 = $121 & 65535 ; $123 = ( ( $118 ) + ( $122 ) ) | 0 ; $124 = $123 & 65535 ; $125 = $13 ; $126 = ( ( $125 ) + 1 ) | 0 ; $127 = ( ( $33 ) + ( $126 << 1 ) | 0 ) ; HEAP16 [ $127 >> 1 ] = $124 ; $128 = $13 ; $129 = ( ( $128 ) + 1 ) | 0 ; $13 = $129 ; } $14 = 0 ; while ( 1 ) { $130 = $14 ; $131 = $9 ; $132 = ( $130 >>> 0 ) < ( $131 >>> 0 ) ; if ( ! ( $132 ) ) { break ; } $133 = $8 ; $134 = $14 ; $135 = ( ( $133 ) + ( $134 << 1 ) | 0 ) ; $136 = HEAP16 [ $135 >> 1 ] | 0 ; $137 = $136 & 65535 ; $138 = ( $137 | 0 ) != ( 0 ) ; if ( $138 ) { $139 = $14 ; $140 = $139 & 65535 ; $141 = $12 ; $142 = $8 ; $143 = $14 ; $144 = ( ( $142 ) + ( $143 << 1 ) | 0 ) ; $145 = HEAP16 [ $144 >> 1 ] | 0 ; $146 = $145 & 65535 ; $147 = ( ( $33 ) + ( $146 << 1 ) | 0 ) ; $148 = HEAP16 [ $147 >> 1 ] | 0 ; $149 = ( ( $148 ) + 1 ) << 16 >> 16 ; HEAP16 [ $147 >> 1 ] = $149 ; $150 = $148 & 65535 ; $151 = ( ( $141 ) + ( $150 << 1 ) | 0 ) ; HEAP16 [ $151 >> 1 ] = $140 ; } $152 = $14 ; $153 = ( ( $152 ) + 1 ) | 0 ; $14 = $153 ; } $154 = $7 ; switch ( $154 | 0 ) { case 0 : { $155 = $12 ; $30 = $155 ; $29 = $155 ; $31 = 20 ; break ; } case 1 : { $29 = 12302 ; $30 = 12364 ; $31 = 257 ; break ; } default : { $29 = 12426 ; $30 = 12490 ; $31 = 0 ; } } $22 = 0 ; $14 = 0 ; $156 = $15 ; $13 = $156 ; $157 = $10 ; $158 = HEAP32 [ $157 >> 2 ] | 0 ; $28 = $158 ; $159 = $17 ; $18 = $159 ; $19 = 0 ; $25 = - 1 ; $160 = $17 ; $161 = 1 << $160 ; $21 = $161 ; $162 = $21 ; $163 = ( ( $162 ) - 1 ) | 0 ; $26 = $163 ; $164 = $7 ; $165 = ( $164 | 0 ) == ( 1 ) ; $166 = $21 ; $167 = ( $166 >>> 0 ) > ( 852 ) ; $or$cond3 = $165 & $167 ; if ( ! ( $or$cond3 ) ) { $168 = $7 ; $169 = ( $168 | 0 ) == ( 2 ) ; $170 = $21 ; $171 = ( $170 >>> 0 ) > ( 592 ) ; $or$cond5 = $169 & $171 ; if ( ! ( $or$cond5 ) ) { while ( 1 ) { $172 = $13 ; $173 = $19 ; $174 = ( ( $172 ) - ( $173 ) ) | 0 ; $175 = $174 & 255 ; $176 = ( ( ( $27 ) ) + 1 | 0 ) ; HEAP8 [ $176 >> 0 ] = $175 ; $177 = $12 ; $178 = $14 ; $179 = ( ( $177 ) + ( $178 << 1 ) | 0 ) ; $180 = HEAP16 [ $179 >> 1 ] | 0 ; $181 = $180 & 65535 ; $182 = ( ( $181 ) + 1 ) | 0 ; $183 = $31 ; $184 = ( $182 >>> 0 ) < ( $183 >>> 0 ) ; do { if ( $184 ) { HEAP8 [ $27 >> 0 ] = 0 ; $185 = $12 ; $186 = $14 ; $187 = ( ( $185 ) + ( $186 << 1 ) | 0 ) ; $188 = HEAP16 [ $187 >> 1 ] | 0 ; $$sink$sink = $188 ; } else { $189 = $12 ; $190 = $14 ; $191 = ( ( $189 ) + ( $190 << 1 ) | 0 ) ; $192 = HEAP16 [ $191 >> 1 ] | 0 ; $193 = $192 & 65535 ; $194 = $31 ; $195 = ( $193 >>> 0 ) >= ( $194 >>> 0 ) ; if ( $195 ) { $196 = $30 ; $197 = $12 ; $198 = $14 ; $199 = ( ( $197 ) + ( $198 << 1 ) | 0 ) ; $200 = HEAP16 [ $199 >> 1 ] | 0 ; $201 = $200 & 65535 ; $202 = $31 ; $203 = ( ( $201 ) - ( $202 ) ) | 0 ; $204 = ( ( $196 ) + ( $203 << 1 ) | 0 ) ; $205 = HEAP16 [ $204 >> 1 ] | 0 ; $206 = $205 & 255 ; HEAP8 [ $27 >> 0 ] = $206 ; $207 = $29 ; $208 = $12 ; $209 = $14 ; $210 = ( ( $208 ) + ( $209 << 1 ) | 0 ) ; $211 = HEAP16 [ $210 >> 1 ] | 0 ; $212 = $211 & 65535 ; $213 = $31 ; $214 = ( ( $212 ) - ( $213 ) ) | 0 ; $215 = ( ( $207 ) + ( $214 << 1 ) | 0 ) ; $216 = HEAP16 [ $215 >> 1 ] | 0 ; $$sink$sink = $216 ; break ; } else { HEAP8 [ $27 >> 0 ] = 96 ; $$sink$sink = 0 ; break ; } } } while ( 0 ) ; $217 = ( ( ( $27 ) ) + 2 | 0 ) ; HEAP16 [ $217 >> 1 ] = $$sink$sink ; $218 = $13 ; $219 = $19 ; $220 = ( ( $218 ) - ( $219 ) ) | 0 ; $221 = 1 << $220 ; $23 = $221 ; $222 = $18 ; $223 = 1 << $222 ; $24 = $223 ; $224 = $24 ; $15 = $224 ; while ( 1 ) { $225 = $23 ; $226 = $24 ; $227 = ( ( $226 ) - ( $225 ) ) | 0 ; $24 = $227 ; $228 = $28 ; $229 = $22 ; $230 = $19 ; $231 = $229 >>> $230 ; $232 = $24 ; $233 = ( ( $231 ) + ( $232 ) ) | 0 ; $234 = ( ( $228 ) + ( $233 << 2 ) | 0 ) ; ; HEAP16 [ $234 >> 1 ] = HEAP16 [ $27 >> 1 ] | 0 ; HEAP16 [ $234 + 2 >> 1 ] = HEAP16 [ $27 + 2 >> 1 ] | 0 ; $235 = $24 ; $236 = ( $235 | 0 ) != ( 0 ) ; if ( ! ( $236 ) ) { break ; } } $237 = $13 ; $238 = ( ( $237 ) - 1 ) | 0 ; $239 = 1 << $238 ; $23 = $239 ; while ( 1 ) { $240 = $22 ; $241 = $23 ; $242 = $240 & $241 ; $243 = ( $242 | 0 ) != ( 0 ) ; $244 = $23 ; if ( ! ( $243 ) ) { break ; } $245 = $244 >>> 1 ; $23 = $245 ; } $246 = ( $244 | 0 ) != ( 0 ) ; if ( $246 ) { $247 = $23 ; $248 = ( ( $247 ) - 1 ) | 0 ; $249 = $22 ; $250 = $249 & $248 ; $22 = $250 ; $251 = $23 ; $252 = $22 ; $253 = ( ( $252 ) + ( $251 ) ) | 0 ; $22 = $253 ; } else { $22 = 0 ; } $254 = $14 ; $255 = ( ( $254 ) + 1 ) | 0 ; $14 = $255 ; $256 = $13 ; $257 = ( ( $32 ) + ( $256 << 1 ) | 0 ) ; $258 = HEAP16 [ $257 >> 1 ] | 0 ; $259 = ( ( $258 ) + - 1 ) << 16 >> 16 ; HEAP16 [ $257 >> 1 ] = $259 ; $260 = $259 & 65535 ; $261 = ( $260 | 0 ) == ( 0 ) ; if ( $261 ) { $262 = $13 ; $263 = $16 ; $264 = ( $262 | 0 ) == ( $263 | 0 ) ; if ( $264 ) { break ; } $265 = $8 ; $266 = $12 ; $267 = $14 ; $268 = ( ( $266 ) + ( $267 << 1 ) | 0 ) ; $269 = HEAP16 [ $268 >> 1 ] | 0 ; $270 = $269 & 65535 ; $271 = ( ( $265 ) + ( $270 << 1 ) | 0 ) ; $272 = HEAP16 [ $271 >> 1 ] | 0 ; $273 = $272 & 65535 ; $13 = $273 ; } $274 = $13 ; $275 = $17 ; $276 = ( $274 >>> 0 ) > ( $275 >>> 0 ) ; if ( ! ( $276 ) ) { continue ; } $277 = $22 ; $278 = $26 ; $279 = $277 & $278 ; $280 = $25 ; $281 = ( $279 | 0 ) != ( $280 | 0 ) ; if ( ! ( $281 ) ) { continue ; } $282 = $19 ; $283 = ( $282 | 0 ) == ( 0 ) ; if ( $283 ) { $284 = $17 ; $19 = $284 ; } $285 = $15 ; $286 = $28 ; $287 = ( ( $286 ) + ( $285 << 2 ) | 0 ) ; $28 = $287 ; $288 = $13 ; $289 = $19 ; $290 = ( ( $288 ) - ( $289 ) ) | 0 ; $18 = $290 ; $291 = $18 ; $292 = 1 << $291 ; $20 = $292 ; while ( 1 ) { $293 = $18 ; $294 = $19 ; $295 = ( ( $293 ) + ( $294 ) ) | 0 ; $296 = $16 ; $297 = ( $295 >>> 0 ) < ( $296 >>> 0 ) ; if ( ! ( $297 ) ) { break ; } $298 = $18 ; $299 = $19 ; $300 = ( ( $298 ) + ( $299 ) ) | 0 ; $301 = ( ( $32 ) + ( $300 << 1 ) | 0 ) ; $302 = HEAP16 [ $301 >> 1 ] | 0 ; $303 = $302 & 65535 ; $304 = $20 ; $305 = ( ( $304 ) - ( $303 ) ) | 0 ; $20 = $305 ; $306 = $20 ; $307 = ( $306 | 0 ) <= ( 0 ) ; if ( $307 ) { break ; } $308 = $18 ; $309 = ( ( $308 ) + 1 ) | 0 ; $18 = $309 ; $310 = $20 ; $311 = $310 << 1 ; $20 = $311 ; } $312 = $18 ; $313 = 1 << $312 ; $314 = $21 ; $315 = ( ( $314 ) + ( $313 ) ) | 0 ; $21 = $315 ; $316 = $7 ; $317 = ( $316 | 0 ) == ( 1 ) ; $318 = $21 ; $319 = ( $318 >>> 0 ) > ( 852 ) ; $or$cond9 = $317 & $319 ; if ( $or$cond9 ) { label = 70 ; break ; } $320 = $7 ; $321 = ( $320 | 0 ) == ( 2 ) ; $322 = $21 ; $323 = ( $322 >>> 0 ) > ( 592 ) ; $or$cond11 = $321 & $323 ; if ( $or$cond11 ) { label = 70 ; break ; } $324 = $22 ; $325 = $26 ; $326 = $324 & $325 ; $25 = $326 ; $327 = $18 ; $328 = $327 & 255 ; $329 = $10 ; $330 = HEAP32 [ $329 >> 2 ] | 0 ; $331 = $25 ; $332 = ( ( $330 ) + ( $331 << 2 ) | 0 ) ; HEAP8 [ $332 >> 0 ] = $328 ; $333 = $17 ; $334 = $333 & 255 ; $335 = $10 ; $336 = HEAP32 [ $335 >> 2 ] | 0 ; $337 = $25 ; $338 = ( ( $336 ) + ( $337 << 2 ) | 0 ) ; $339 = ( ( ( $338 ) ) + 1 | 0 ) ; HEAP8 [ $339 >> 0 ] = $334 ; $340 = $28 ; $341 = $10 ; $342 = HEAP32 [ $341 >> 2 ] | 0 ; $343 = $340 ; $344 = $342 ; $345 = ( ( $343 ) - ( $344 ) ) | 0 ; $346 = ( ( $345 | 0 ) / 4 ) & - 1 ; $347 = $346 & 65535 ; $348 = $10 ; $349 = HEAP32 [ $348 >> 2 ] | 0 ; $350 = $25 ; $351 = ( ( $349 ) + ( $350 << 2 ) | 0 ) ; $352 = ( ( ( $351 ) ) + 2 | 0 ) ; HEAP16 [ $352 >> 1 ] = $347 ; } if ( ( label | 0 ) == 70 ) { $6 = 1 ; $370 = $6 ; STACKTOP = sp ; return ( $370 | 0 ) ; } $353 = $22 ; $354 = ( $353 | 0 ) != ( 0 ) ; if ( $354 ) { HEAP8 [ $27 >> 0 ] = 64 ; $355 = $13 ; $356 = $19 ; $357 = ( ( $355 ) - ( $356 ) ) | 0 ; $358 = $357 & 255 ; $359 = ( ( ( $27 ) ) + 1 | 0 ) ; HEAP8 [ $359 >> 0 ] = $358 ; $360 = ( ( ( $27 ) ) + 2 | 0 ) ; HEAP16 [ $360 >> 1 ] = 0 ; $361 = $28 ; $362 = $22 ; $363 = ( ( $361 ) + ( $362 << 2 ) | 0 ) ; ; HEAP16 [ $363 >> 1 ] = HEAP16 [ $27 >> 1 ] | 0 ; HEAP16 [ $363 + 2 >> 1 ] = HEAP16 [ $27 + 2 >> 1 ] | 0 ; } $364 = $21 ; $365 = $10 ; $366 = HEAP32 [ $365 >> 2 ] | 0 ; $367 = ( ( $366 ) + ( $364 << 2 ) | 0 ) ; HEAP32 [ $365 >> 2 ] = $367 ; $368 = $17 ; $369 = $11 ; HEAP32 [ $369 >> 2 ] = $368 ; $6 = 0 ; $370 = $6 ; STACKTOP = sp ; return ( $370 | 0 ) ; } } $6 = 1 ; $370 = $6 ; STACKTOP = sp ; return ( $370 | 0 ) ; } function __tr_init ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 ; var $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; _tr_static_init ( ) ; $2 = $1 ; $3 = ( ( ( $2 ) ) + 148 | 0 ) ; $4 = $1 ; $5 = ( ( ( $4 ) ) + 2840 | 0 ) ; HEAP32 [ $5 >> 2 ] = $3 ; $6 = $1 ; $7 = ( ( ( $6 ) ) + 2840 | 0 ) ; $8 = ( ( ( $7 ) ) + 8 | 0 ) ; HEAP32 [ $8 >> 2 ] = 8804 ; $9 = $1 ; $10 = ( ( ( $9 ) ) + 2440 | 0 ) ; $11 = $1 ; $12 = ( ( ( $11 ) ) + 2852 | 0 ) ; HEAP32 [ $12 >> 2 ] = $10 ; $13 = $1 ; $14 = ( ( ( $13 ) ) + 2852 | 0 ) ; $15 = ( ( ( $14 ) ) + 8 | 0 ) ; HEAP32 [ $15 >> 2 ] = 8824 ; $16 = $1 ; $17 = ( ( ( $16 ) ) + 2684 | 0 ) ; $18 = $1 ; $19 = ( ( ( $18 ) ) + 2864 | 0 ) ; HEAP32 [ $19 >> 2 ] = $17 ; $20 = $1 ; $21 = ( ( ( $20 ) ) + 2864 | 0 ) ; $22 = ( ( ( $21 ) ) + 8 | 0 ) ; HEAP32 [ $22 >> 2 ] = 8844 ; $23 = $1 ; $24 = ( ( ( $23 ) ) + 5816 | 0 ) ; HEAP16 [ $24 >> 1 ] = 0 ; $25 = $1 ; $26 = ( ( ( $25 ) ) + 5820 | 0 ) ; HEAP32 [ $26 >> 2 ] = 0 ; $27 = $1 ; _init_block ( $27 ) ; STACKTOP = sp ; return ; } function _tr_static_init ( ) { var label = 0 , sp = 0 ; sp = STACKTOP ; return ; } function _init_block ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 ; var $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $2 = 0 ; while ( 1 ) { $3 = $2 ; $4 = ( $3 | 0 ) < ( 286 ) ; if ( ! ( $4 ) ) { break ; } $5 = $1 ; $6 = ( ( ( $5 ) ) + 148 | 0 ) ; $7 = $2 ; $8 = ( ( $6 ) + ( $7 << 2 ) | 0 ) ; HEAP16 [ $8 >> 1 ] = 0 ; $9 = $2 ; $10 = ( ( $9 ) + 1 ) | 0 ; $2 = $10 ; } $2 = 0 ; while ( 1 ) { $11 = $2 ; $12 = ( $11 | 0 ) < ( 30 ) ; if ( ! ( $12 ) ) { break ; } $13 = $1 ; $14 = ( ( ( $13 ) ) + 2440 | 0 ) ; $15 = $2 ; $16 = ( ( $14 ) + ( $15 << 2 ) | 0 ) ; HEAP16 [ $16 >> 1 ] = 0 ; $17 = $2 ; $18 = ( ( $17 ) + 1 ) | 0 ; $2 = $18 ; } $2 = 0 ; while ( 1 ) { $19 = $2 ; $20 = ( $19 | 0 ) < ( 19 ) ; $21 = $1 ; if ( ! ( $20 ) ) { break ; } $22 = ( ( ( $21 ) ) + 2684 | 0 ) ; $23 = $2 ; $24 = ( ( $22 ) + ( $23 << 2 ) | 0 ) ; HEAP16 [ $24 >> 1 ] = 0 ; $25 = $2 ; $26 = ( ( $25 ) + 1 ) | 0 ; $2 = $26 ; } $27 = ( ( ( $21 ) ) + 148 | 0 ) ; $28 = ( ( ( $27 ) ) + 1024 | 0 ) ; HEAP16 [ $28 >> 1 ] = 1 ; $29 = $1 ; $30 = ( ( ( $29 ) ) + 5804 | 0 ) ; HEAP32 [ $30 >> 2 ] = 0 ; $31 = $1 ; $32 = ( ( ( $31 ) ) + 5800 | 0 ) ; HEAP32 [ $32 >> 2 ] = 0 ; $33 = $1 ; $34 = ( ( ( $33 ) ) + 5808 | 0 ) ; HEAP32 [ $34 >> 2 ] = 0 ; $35 = $1 ; $36 = ( ( ( $35 ) ) + 5792 | 0 ) ; HEAP32 [ $36 >> 2 ] = 0 ; STACKTOP = sp ; return ; } function __tr_stored_block ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $$sink3 = 0 , $$sink4 = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 ; var $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 ; var $134 = 0 , $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 ; var $152 = 0 , $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 ; var $29 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 ; var $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 ; var $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 ; var $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $7 = $3 ; $8 = 3 ; $10 = $4 ; $11 = ( ( ( $10 ) ) + 5820 | 0 ) ; $12 = HEAP32 [ $11 >> 2 ] | 0 ; $13 = $8 ; $14 = ( 16 - ( $13 ) ) | 0 ; $15 = ( $12 | 0 ) > ( $14 | 0 ) ; $16 = $7 ; $17 = ( 0 + ( $16 ) ) | 0 ; if ( $15 ) { $9 = $17 ; $18 = $9 ; $19 = $18 & 65535 ; $20 = $19 & 65535 ; $21 = $4 ; $22 = ( ( ( $21 ) ) + 5820 | 0 ) ; $23 = HEAP32 [ $22 >> 2 ] | 0 ; $24 = $20 << $23 ; $25 = $4 ; $26 = ( ( ( $25 ) ) + 5816 | 0 ) ; $27 = HEAP16 [ $26 >> 1 ] | 0 ; $28 = $27 & 65535 ; $29 = $28 | $24 ; $30 = $29 & 65535 ; HEAP16 [ $26 >> 1 ] = $30 ; $31 = $4 ; $32 = ( ( ( $31 ) ) + 5816 | 0 ) ; $33 = HEAP16 [ $32 >> 1 ] | 0 ; $34 = $33 & 65535 ; $35 = $34 & 255 ; $36 = $35 & 255 ; $37 = $4 ; $38 = ( ( ( $37 ) ) + 8 | 0 ) ; $39 = HEAP32 [ $38 >> 2 ] | 0 ; $40 = $4 ; $41 = ( ( ( $40 ) ) + 20 | 0 ) ; $42 = HEAP32 [ $41 >> 2 ] | 0 ; $43 = ( ( $42 ) + 1 ) | 0 ; HEAP32 [ $41 >> 2 ] = $43 ; $44 = ( ( $39 ) + ( $42 ) | 0 ) ; HEAP8 [ $44 >> 0 ] = $36 ; $45 = $4 ; $46 = ( ( ( $45 ) ) + 5816 | 0 ) ; $47 = HEAP16 [ $46 >> 1 ] | 0 ; $48 = $47 & 65535 ; $49 = $48 >> 8 ; $50 = $49 & 255 ; $51 = $4 ; $52 = ( ( ( $51 ) ) + 8 | 0 ) ; $53 = HEAP32 [ $52 >> 2 ] | 0 ; $54 = $4 ; $55 = ( ( ( $54 ) ) + 20 | 0 ) ; $56 = HEAP32 [ $55 >> 2 ] | 0 ; $57 = ( ( $56 ) + 1 ) | 0 ; HEAP32 [ $55 >> 2 ] = $57 ; $58 = ( ( $53 ) + ( $56 ) | 0 ) ; HEAP8 [ $58 >> 0 ] = $50 ; $59 = $9 ; $60 = $59 & 65535 ; $61 = $60 & 65535 ; $62 = $4 ; $63 = ( ( ( $62 ) ) + 5820 | 0 ) ; $64 = HEAP32 [ $63 >> 2 ] | 0 ; $65 = ( 16 - ( $64 ) ) | 0 ; $66 = $61 >> $65 ; $67 = $66 & 65535 ; $68 = $4 ; $69 = ( ( ( $68 ) ) + 5816 | 0 ) ; HEAP16 [ $69 >> 1 ] = $67 ; $70 = $8 ; $71 = ( ( $70 ) - 16 ) | 0 ; $72 = $4 ; $$sink3 = $71 ; $$sink4 = $72 ; } else { $73 = $17 & 65535 ; $74 = $73 & 65535 ; $75 = $4 ; $76 = ( ( ( $75 ) ) + 5820 | 0 ) ; $77 = HEAP32 [ $76 >> 2 ] | 0 ; $78 = $74 << $77 ; $79 = $4 ; $80 = ( ( ( $79 ) ) + 5816 | 0 ) ; $81 = HEAP16 [ $80 >> 1 ] | 0 ; $82 = $81 & 65535 ; $83 = $82 | $78 ; $84 = $83 & 65535 ; HEAP16 [ $80 >> 1 ] = $84 ; $85 = $8 ; $86 = $4 ; $$sink3 = $85 ; $$sink4 = $86 ; } $87 = ( ( ( $$sink4 ) ) + 5820 | 0 ) ; $88 = HEAP32 [ $87 >> 2 ] | 0 ; $89 = ( ( $88 ) + ( $$sink3 ) ) | 0 ; HEAP32 [ $87 >> 2 ] = $89 ; $90 = $4 ; _bi_windup ( $90 ) ; $91 = $6 ; $92 = $91 & 65535 ; $93 = $92 & 65535 ; $94 = $93 & 255 ; $95 = $94 & 255 ; $96 = $4 ; $97 = ( ( ( $96 ) ) + 8 | 0 ) ; $98 = HEAP32 [ $97 >> 2 ] | 0 ; $99 = $4 ; $100 = ( ( ( $99 ) ) + 20 | 0 ) ; $101 = HEAP32 [ $100 >> 2 ] | 0 ; $102 = ( ( $101 ) + 1 ) | 0 ; HEAP32 [ $100 >> 2 ] = $102 ; $103 = ( ( $98 ) + ( $101 ) | 0 ) ; HEAP8 [ $103 >> 0 ] = $95 ; $104 = $6 ; $105 = $104 & 65535 ; $106 = $105 & 65535 ; $107 = $106 >> 8 ; $108 = $107 & 255 ; $109 = $4 ; $110 = ( ( ( $109 ) ) + 8 | 0 ) ; $111 = HEAP32 [ $110 >> 2 ] | 0 ; $112 = $4 ; $113 = ( ( ( $112 ) ) + 20 | 0 ) ; $114 = HEAP32 [ $113 >> 2 ] | 0 ; $115 = ( ( $114 ) + 1 ) | 0 ; HEAP32 [ $113 >> 2 ] = $115 ; $116 = ( ( $111 ) + ( $114 ) | 0 ) ; HEAP8 [ $116 >> 0 ] = $108 ; $117 = $6 ; $118 = $117 ^ - 1 ; $119 = $118 & 65535 ; $120 = $119 & 65535 ; $121 = $120 & 255 ; $122 = $121 & 255 ; $123 = $4 ; $124 = ( ( ( $123 ) ) + 8 | 0 ) ; $125 = HEAP32 [ $124 >> 2 ] | 0 ; $126 = $4 ; $127 = ( ( ( $126 ) ) + 20 | 0 ) ; $128 = HEAP32 [ $127 >> 2 ] | 0 ; $129 = ( ( $128 ) + 1 ) | 0 ; HEAP32 [ $127 >> 2 ] = $129 ; $130 = ( ( $125 ) + ( $128 ) | 0 ) ; HEAP8 [ $130 >> 0 ] = $122 ; $131 = $6 ; $132 = $131 ^ - 1 ; $133 = $132 & 65535 ; $134 = $133 & 65535 ; $135 = $134 >> 8 ; $136 = $135 & 255 ; $137 = $4 ; $138 = ( ( ( $137 ) ) + 8 | 0 ) ; $139 = HEAP32 [ $138 >> 2 ] | 0 ; $140 = $4 ; $141 = ( ( ( $140 ) ) + 20 | 0 ) ; $142 = HEAP32 [ $141 >> 2 ] | 0 ; $143 = ( ( $142 ) + 1 ) | 0 ; HEAP32 [ $141 >> 2 ] = $143 ; $144 = ( ( $139 ) + ( $142 ) | 0 ) ; HEAP8 [ $144 >> 0 ] = $136 ; $145 = $4 ; $146 = ( ( ( $145 ) ) + 8 | 0 ) ; $147 = HEAP32 [ $146 >> 2 ] | 0 ; $148 = $4 ; $149 = ( ( ( $148 ) ) + 20 | 0 ) ; $150 = HEAP32 [ $149 >> 2 ] | 0 ; $151 = ( ( $147 ) + ( $150 ) | 0 ) ; $152 = $5 ; $153 = $6 ; _memcpy ( ( $151 | 0 ) , ( $152 | 0 ) , ( $153 | 0 ) ) | 0 ; $154 = $6 ; $155 = $4 ; $156 = ( ( ( $155 ) ) + 20 | 0 ) ; $157 = HEAP32 [ $156 >> 2 ] | 0 ; $158 = ( ( $157 ) + ( $154 ) ) | 0 ; HEAP32 [ $156 >> 2 ] = $158 ; STACKTOP = sp ; return ; } function _bi_windup ( $0 ) { $0 = $0 | 0 ; var $$sink = 0 , $$sink1 = 0 , $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 ; var $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 ; var $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $2 = $1 ; $3 = ( ( ( $2 ) ) + 5820 | 0 ) ; $4 = HEAP32 [ $3 >> 2 ] | 0 ; $5 = ( $4 | 0 ) > ( 8 ) ; $6 = $1 ; do { if ( $5 ) { $7 = ( ( ( $6 ) ) + 5816 | 0 ) ; $8 = HEAP16 [ $7 >> 1 ] | 0 ; $9 = $8 & 65535 ; $10 = $9 & 255 ; $11 = $10 & 255 ; $12 = $1 ; $13 = ( ( ( $12 ) ) + 8 | 0 ) ; $14 = HEAP32 [ $13 >> 2 ] | 0 ; $15 = $1 ; $16 = ( ( ( $15 ) ) + 20 | 0 ) ; $17 = HEAP32 [ $16 >> 2 ] | 0 ; $18 = ( ( $17 ) + 1 ) | 0 ; HEAP32 [ $16 >> 2 ] = $18 ; $19 = ( ( $14 ) + ( $17 ) | 0 ) ; HEAP8 [ $19 >> 0 ] = $11 ; $20 = $1 ; $21 = ( ( ( $20 ) ) + 5816 | 0 ) ; $22 = HEAP16 [ $21 >> 1 ] | 0 ; $23 = $22 & 65535 ; $24 = $23 >> 8 ; $25 = $24 & 255 ; $26 = $1 ; $27 = ( ( ( $26 ) ) + 8 | 0 ) ; $28 = HEAP32 [ $27 >> 2 ] | 0 ; $29 = $1 ; $30 = ( ( ( $29 ) ) + 20 | 0 ) ; $31 = HEAP32 [ $30 >> 2 ] | 0 ; $32 = ( ( $31 ) + 1 ) | 0 ; HEAP32 [ $30 >> 2 ] = $32 ; $33 = ( ( $28 ) + ( $31 ) | 0 ) ; $$sink = $25 ; $$sink1 = $33 ; } else { $34 = ( ( ( $6 ) ) + 5820 | 0 ) ; $35 = HEAP32 [ $34 >> 2 ] | 0 ; $36 = ( $35 | 0 ) > ( 0 ) ; if ( $36 ) { $37 = $1 ; $38 = ( ( ( $37 ) ) + 5816 | 0 ) ; $39 = HEAP16 [ $38 >> 1 ] | 0 ; $40 = $39 & 255 ; $41 = $1 ; $42 = ( ( ( $41 ) ) + 8 | 0 ) ; $43 = HEAP32 [ $42 >> 2 ] | 0 ; $44 = $1 ; $45 = ( ( ( $44 ) ) + 20 | 0 ) ; $46 = HEAP32 [ $45 >> 2 ] | 0 ; $47 = ( ( $46 ) + 1 ) | 0 ; HEAP32 [ $45 >> 2 ] = $47 ; $48 = ( ( $43 ) + ( $46 ) | 0 ) ; $$sink = $40 ; $$sink1 = $48 ; break ; } else { $49 = $1 ; $50 = ( ( ( $49 ) ) + 5816 | 0 ) ; HEAP16 [ $50 >> 1 ] = 0 ; $51 = $1 ; $52 = ( ( ( $51 ) ) + 5820 | 0 ) ; HEAP32 [ $52 >> 2 ] = 0 ; STACKTOP = sp ; return ; } } } while ( 0 ) ; HEAP8 [ $$sink1 >> 0 ] = $$sink ; $49 = $1 ; $50 = ( ( ( $49 ) ) + 5816 | 0 ) ; HEAP16 [ $50 >> 1 ] = 0 ; $51 = $1 ; $52 = ( ( ( $51 ) ) + 5820 | 0 ) ; HEAP32 [ $52 >> 2 ] = 0 ; STACKTOP = sp ; return ; } function __tr_flush_bits ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $2 = $1 ; _bi_flush ( $2 ) ; STACKTOP = sp ; return ; } function _bi_flush ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 ; var $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 ; var $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $7 = 0 ; var $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $2 = $1 ; $3 = ( ( ( $2 ) ) + 5820 | 0 ) ; $4 = HEAP32 [ $3 >> 2 ] | 0 ; $5 = ( $4 | 0 ) == ( 16 ) ; $6 = $1 ; if ( $5 ) { $7 = ( ( ( $6 ) ) + 5816 | 0 ) ; $8 = HEAP16 [ $7 >> 1 ] | 0 ; $9 = $8 & 65535 ; $10 = $9 & 255 ; $11 = $10 & 255 ; $12 = $1 ; $13 = ( ( ( $12 ) ) + 8 | 0 ) ; $14 = HEAP32 [ $13 >> 2 ] | 0 ; $15 = $1 ; $16 = ( ( ( $15 ) ) + 20 | 0 ) ; $17 = HEAP32 [ $16 >> 2 ] | 0 ; $18 = ( ( $17 ) + 1 ) | 0 ; HEAP32 [ $16 >> 2 ] = $18 ; $19 = ( ( $14 ) + ( $17 ) | 0 ) ; HEAP8 [ $19 >> 0 ] = $11 ; $20 = $1 ; $21 = ( ( ( $20 ) ) + 5816 | 0 ) ; $22 = HEAP16 [ $21 >> 1 ] | 0 ; $23 = $22 & 65535 ; $24 = $23 >> 8 ; $25 = $24 & 255 ; $26 = $1 ; $27 = ( ( ( $26 ) ) + 8 | 0 ) ; $28 = HEAP32 [ $27 >> 2 ] | 0 ; $29 = $1 ; $30 = ( ( ( $29 ) ) + 20 | 0 ) ; $31 = HEAP32 [ $30 >> 2 ] | 0 ; $32 = ( ( $31 ) + 1 ) | 0 ; HEAP32 [ $30 >> 2 ] = $32 ; $33 = ( ( $28 ) + ( $31 ) | 0 ) ; HEAP8 [ $33 >> 0 ] = $25 ; $34 = $1 ; $35 = ( ( ( $34 ) ) + 5816 | 0 ) ; HEAP16 [ $35 >> 1 ] = 0 ; $36 = $1 ; $37 = ( ( ( $36 ) ) + 5820 | 0 ) ; HEAP32 [ $37 >> 2 ] = 0 ; STACKTOP = sp ; return ; } $38 = ( ( ( $6 ) ) + 5820 | 0 ) ; $39 = HEAP32 [ $38 >> 2 ] | 0 ; $40 = ( $39 | 0 ) >= ( 8 ) ; if ( ! ( $40 ) ) { STACKTOP = sp ; return ; } $41 = $1 ; $42 = ( ( ( $41 ) ) + 5816 | 0 ) ; $43 = HEAP16 [ $42 >> 1 ] | 0 ; $44 = $43 & 255 ; $45 = $1 ; $46 = ( ( ( $45 ) ) + 8 | 0 ) ; $47 = HEAP32 [ $46 >> 2 ] | 0 ; $48 = $1 ; $49 = ( ( ( $48 ) ) + 20 | 0 ) ; $50 = HEAP32 [ $49 >> 2 ] | 0 ; $51 = ( ( $50 ) + 1 ) | 0 ; HEAP32 [ $49 >> 2 ] = $51 ; $52 = ( ( $47 ) + ( $50 ) | 0 ) ; HEAP8 [ $52 >> 0 ] = $44 ; $53 = $1 ; $54 = ( ( ( $53 ) ) + 5816 | 0 ) ; $55 = HEAP16 [ $54 >> 1 ] | 0 ; $56 = $55 & 65535 ; $57 = $56 >> 8 ; $58 = $57 & 65535 ; HEAP16 [ $54 >> 1 ] = $58 ; $59 = $1 ; $60 = ( ( ( $59 ) ) + 5820 | 0 ) ; $61 = HEAP32 [ $60 >> 2 ] | 0 ; $62 = ( ( $61 ) - 8 ) | 0 ; HEAP32 [ $60 >> 2 ] = $62 ; STACKTOP = sp ; return ; } function __tr_align ( $0 ) { $0 = $0 | 0 ; var $$sink = 0 , $$sink3 = 0 , $$sink7 = 0 , $$sink9 = 0 , $1 = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 ; var $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 ; var $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 ; var $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 ; var $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 ; var $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 ; var $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 ; var $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 ; var $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $1 = $0 ; $2 = 3 ; $6 = $1 ; $7 = ( ( ( $6 ) ) + 5820 | 0 ) ; $8 = HEAP32 [ $7 >> 2 ] | 0 ; $9 = $2 ; $10 = ( 16 - ( $9 ) ) | 0 ; $11 = ( $8 | 0 ) > ( $10 | 0 ) ; if ( $11 ) { $3 = 2 ; $12 = $3 ; $13 = $12 & 65535 ; $14 = $13 & 65535 ; $15 = $1 ; $16 = ( ( ( $15 ) ) + 5820 | 0 ) ; $17 = HEAP32 [ $16 >> 2 ] | 0 ; $18 = $14 << $17 ; $19 = $1 ; $20 = ( ( ( $19 ) ) + 5816 | 0 ) ; $21 = HEAP16 [ $20 >> 1 ] | 0 ; $22 = $21 & 65535 ; $23 = $22 | $18 ; $24 = $23 & 65535 ; HEAP16 [ $20 >> 1 ] = $24 ; $25 = $1 ; $26 = ( ( ( $25 ) ) + 5816 | 0 ) ; $27 = HEAP16 [ $26 >> 1 ] | 0 ; $28 = $27 & 65535 ; $29 = $28 & 255 ; $30 = $29 & 255 ; $31 = $1 ; $32 = ( ( ( $31 ) ) + 8 | 0 ) ; $33 = HEAP32 [ $32 >> 2 ] | 0 ; $34 = $1 ; $35 = ( ( ( $34 ) ) + 20 | 0 ) ; $36 = HEAP32 [ $35 >> 2 ] | 0 ; $37 = ( ( $36 ) + 1 ) | 0 ; HEAP32 [ $35 >> 2 ] = $37 ; $38 = ( ( $33 ) + ( $36 ) | 0 ) ; HEAP8 [ $38 >> 0 ] = $30 ; $39 = $1 ; $40 = ( ( ( $39 ) ) + 5816 | 0 ) ; $41 = HEAP16 [ $40 >> 1 ] | 0 ; $42 = $41 & 65535 ; $43 = $42 >> 8 ; $44 = $43 & 255 ; $45 = $1 ; $46 = ( ( ( $45 ) ) + 8 | 0 ) ; $47 = HEAP32 [ $46 >> 2 ] | 0 ; $48 = $1 ; $49 = ( ( ( $48 ) ) + 20 | 0 ) ; $50 = HEAP32 [ $49 >> 2 ] | 0 ; $51 = ( ( $50 ) + 1 ) | 0 ; HEAP32 [ $49 >> 2 ] = $51 ; $52 = ( ( $47 ) + ( $50 ) | 0 ) ; HEAP8 [ $52 >> 0 ] = $44 ; $53 = $3 ; $54 = $53 & 65535 ; $55 = $54 & 65535 ; $56 = $1 ; $57 = ( ( ( $56 ) ) + 5820 | 0 ) ; $58 = HEAP32 [ $57 >> 2 ] | 0 ; $59 = ( 16 - ( $58 ) ) | 0 ; $60 = $55 >> $59 ; $61 = $60 & 65535 ; $62 = $1 ; $63 = ( ( ( $62 ) ) + 5816 | 0 ) ; HEAP16 [ $63 >> 1 ] = $61 ; $64 = $2 ; $65 = ( ( $64 ) - 16 ) | 0 ; $66 = $1 ; $$sink3 = $65 ; $$sink9 = $66 ; } else { $67 = $1 ; $68 = ( ( ( $67 ) ) + 5820 | 0 ) ; $69 = HEAP32 [ $68 >> 2 ] | 0 ; $70 = 2 << $69 ; $71 = $1 ; $72 = ( ( ( $71 ) ) + 5816 | 0 ) ; $73 = HEAP16 [ $72 >> 1 ] | 0 ; $74 = $73 & 65535 ; $75 = $74 | $70 ; $76 = $75 & 65535 ; HEAP16 [ $72 >> 1 ] = $76 ; $77 = $2 ; $78 = $1 ; $$sink3 = $77 ; $$sink9 = $78 ; } $79 = ( ( ( $$sink9 ) ) + 5820 | 0 ) ; $80 = HEAP32 [ $79 >> 2 ] | 0 ; $81 = ( ( $80 ) + ( $$sink3 ) ) | 0 ; HEAP32 [ $79 >> 2 ] = $81 ; $82 = HEAP16 [ ( 13700 ) >> 1 ] | 0 ; $83 = $82 & 65535 ; $4 = $83 ; $84 = $1 ; $85 = ( ( ( $84 ) ) + 5820 | 0 ) ; $86 = HEAP32 [ $85 >> 2 ] | 0 ; $87 = $4 ; $88 = ( 16 - ( $87 ) ) | 0 ; $89 = ( $86 | 0 ) > ( $88 | 0 ) ; $90 = HEAP16 [ ( 13698 ) >> 1 ] | 0 ; $91 = $90 & 65535 ; if ( $89 ) { $5 = $91 ; $92 = $5 ; $93 = $92 & 65535 ; $94 = $93 & 65535 ; $95 = $1 ; $96 = ( ( ( $95 ) ) + 5820 | 0 ) ; $97 = HEAP32 [ $96 >> 2 ] | 0 ; $98 = $94 << $97 ; $99 = $1 ; $100 = ( ( ( $99 ) ) + 5816 | 0 ) ; $101 = HEAP16 [ $100 >> 1 ] | 0 ; $102 = $101 & 65535 ; $103 = $102 | $98 ; $104 = $103 & 65535 ; HEAP16 [ $100 >> 1 ] = $104 ; $105 = $1 ; $106 = ( ( ( $105 ) ) + 5816 | 0 ) ; $107 = HEAP16 [ $106 >> 1 ] | 0 ; $108 = $107 & 65535 ; $109 = $108 & 255 ; $110 = $109 & 255 ; $111 = $1 ; $112 = ( ( ( $111 ) ) + 8 | 0 ) ; $113 = HEAP32 [ $112 >> 2 ] | 0 ; $114 = $1 ; $115 = ( ( ( $114 ) ) + 20 | 0 ) ; $116 = HEAP32 [ $115 >> 2 ] | 0 ; $117 = ( ( $116 ) + 1 ) | 0 ; HEAP32 [ $115 >> 2 ] = $117 ; $118 = ( ( $113 ) + ( $116 ) | 0 ) ; HEAP8 [ $118 >> 0 ] = $110 ; $119 = $1 ; $120 = ( ( ( $119 ) ) + 5816 | 0 ) ; $121 = HEAP16 [ $120 >> 1 ] | 0 ; $122 = $121 & 65535 ; $123 = $122 >> 8 ; $124 = $123 & 255 ; $125 = $1 ; $126 = ( ( ( $125 ) ) + 8 | 0 ) ; $127 = HEAP32 [ $126 >> 2 ] | 0 ; $128 = $1 ; $129 = ( ( ( $128 ) ) + 20 | 0 ) ; $130 = HEAP32 [ $129 >> 2 ] | 0 ; $131 = ( ( $130 ) + 1 ) | 0 ; HEAP32 [ $129 >> 2 ] = $131 ; $132 = ( ( $127 ) + ( $130 ) | 0 ) ; HEAP8 [ $132 >> 0 ] = $124 ; $133 = $5 ; $134 = $133 & 65535 ; $135 = $134 & 65535 ; $136 = $1 ; $137 = ( ( ( $136 ) ) + 5820 | 0 ) ; $138 = HEAP32 [ $137 >> 2 ] | 0 ; $139 = ( 16 - ( $138 ) ) | 0 ; $140 = $135 >> $139 ; $141 = $140 & 65535 ; $142 = $1 ; $143 = ( ( ( $142 ) ) + 5816 | 0 ) ; HEAP16 [ $143 >> 1 ] = $141 ; $144 = $4 ; $145 = ( ( $144 ) - 16 ) | 0 ; $146 = $1 ; $$sink = $146 ; $$sink7 = $145 ; $159 = ( ( ( $$sink ) ) + 5820 | 0 ) ; $160 = HEAP32 [ $159 >> 2 ] | 0 ; $161 = ( ( $160 ) + ( $$sink7 ) ) | 0 ; HEAP32 [ $159 >> 2 ] = $161 ; $162 = $1 ; _bi_flush ( $162 ) ; STACKTOP = sp ; return ; } else { $147 = $1 ; $148 = ( ( ( $147 ) ) + 5820 | 0 ) ; $149 = HEAP32 [ $148 >> 2 ] | 0 ; $150 = $91 << $149 ; $151 = $1 ; $152 = ( ( ( $151 ) ) + 5816 | 0 ) ; $153 = HEAP16 [ $152 >> 1 ] | 0 ; $154 = $153 & 65535 ; $155 = $154 | $150 ; $156 = $155 & 65535 ; HEAP16 [ $152 >> 1 ] = $156 ; $157 = $4 ; $158 = $1 ; $$sink = $158 ; $$sink7 = $157 ; $159 = ( ( ( $$sink ) ) + 5820 | 0 ) ; $160 = HEAP32 [ $159 >> 2 ] | 0 ; $161 = ( ( $160 ) + ( $$sink7 ) ) | 0 ; HEAP32 [ $159 >> 2 ] = $161 ; $162 = $1 ; _bi_flush ( $162 ) ; STACKTOP = sp ; return ; } } function __tr_flush_block ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $$sink = 0 , $$sink10 = 0 , $$sink4 = 0 , $$sink8 = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 ; var $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 ; var $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 ; var $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 ; var $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 , $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 ; var $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 , $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 ; var $205 = 0 , $206 = 0 , $207 = 0 , $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 ; var $223 = 0 , $224 = 0 , $225 = 0 , $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 ; var $241 = 0 , $242 = 0 , $243 = 0 , $244 = 0 , $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $30 = 0 , $31 = 0 ; var $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 ; var $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 ; var $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 ; var $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 48 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 48 | 0 ) ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $7 = $3 ; $10 = 0 ; $15 = $4 ; $16 = ( ( ( $15 ) ) + 132 | 0 ) ; $17 = HEAP32 [ $16 >> 2 ] | 0 ; $18 = ( $17 | 0 ) > ( 0 ) ; if ( $18 ) { $19 = $4 ; $20 = HEAP32 [ $19 >> 2 ] | 0 ; $21 = ( ( ( $20 ) ) + 44 | 0 ) ; $22 = HEAP32 [ $21 >> 2 ] | 0 ; $23 = ( $22 | 0 ) == ( 2 ) ; if ( $23 ) { $24 = $4 ; $25 = ( _detect_data_type ( $24 ) | 0 ) ; $26 = $4 ; $27 = HEAP32 [ $26 >> 2 ] | 0 ; $28 = ( ( ( $27 ) ) + 44 | 0 ) ; HEAP32 [ $28 >> 2 ] = $25 ; } $29 = $4 ; $30 = $4 ; $31 = ( ( ( $30 ) ) + 2840 | 0 ) ; _build_tree ( $29 , $31 ) ; $32 = $4 ; $33 = $4 ; $34 = ( ( ( $33 ) ) + 2852 | 0 ) ; _build_tree ( $32 , $34 ) ; $35 = $4 ; $36 = ( _build_bl_tree ( $35 ) | 0 ) ; $10 = $36 ; $37 = $4 ; $38 = ( ( ( $37 ) ) + 5800 | 0 ) ; $39 = HEAP32 [ $38 >> 2 ] | 0 ; $40 = ( ( $39 ) + 3 ) | 0 ; $41 = ( ( $40 ) + 7 ) | 0 ; $42 = $41 >>> 3 ; $8 = $42 ; $43 = $4 ; $44 = ( ( ( $43 ) ) + 5804 | 0 ) ; $45 = HEAP32 [ $44 >> 2 ] | 0 ; $46 = ( ( $45 ) + 3 ) | 0 ; $47 = ( ( $46 ) + 7 ) | 0 ; $48 = $47 >>> 3 ; $9 = $48 ; $49 = $9 ; $50 = $8 ; $51 = ( $49 >>> 0 ) <= ( $50 >>> 0 ) ; if ( $51 ) { $52 = $9 ; $8 = $52 ; } } else { $53 = $6 ; $54 = ( ( $53 ) + 5 ) | 0 ; $9 = $54 ; $8 = $54 ; } $55 = $6 ; $56 = ( ( $55 ) + 4 ) | 0 ; $57 = $8 ; $58 = ( $56 >>> 0 ) <= ( $57 >>> 0 ) ; $59 = $5 ; $60 = ( $59 | 0 ) != ( 0 | 0 ) ; $or$cond = $58 & $60 ; $61 = $4 ; do { if ( $or$cond ) { $62 = $5 ; $63 = $6 ; $64 = $7 ; __tr_stored_block ( $61 , $62 , $63 , $64 ) ; } else { $65 = ( ( ( $61 ) ) + 136 | 0 ) ; $66 = HEAP32 [ $65 >> 2 ] | 0 ; $67 = ( $66 | 0 ) == ( 4 ) ; if ( ! ( $67 ) ) { $68 = $9 ; $69 = $8 ; $70 = ( $68 | 0 ) == ( $69 | 0 ) ; if ( ! ( $70 ) ) { $13 = 3 ; $152 = $4 ; $153 = ( ( ( $152 ) ) + 5820 | 0 ) ; $154 = HEAP32 [ $153 >> 2 ] | 0 ; $155 = $13 ; $156 = ( 16 - ( $155 ) ) | 0 ; $157 = ( $154 | 0 ) > ( $156 | 0 ) ; $158 = $7 ; $159 = ( 4 + ( $158 ) ) | 0 ; if ( $157 ) { $14 = $159 ; $160 = $14 ; $161 = $160 & 65535 ; $162 = $161 & 65535 ; $163 = $4 ; $164 = ( ( ( $163 ) ) + 5820 | 0 ) ; $165 = HEAP32 [ $164 >> 2 ] | 0 ; $166 = $162 << $165 ; $167 = $4 ; $168 = ( ( ( $167 ) ) + 5816 | 0 ) ; $169 = HEAP16 [ $168 >> 1 ] | 0 ; $170 = $169 & 65535 ; $171 = $170 | $166 ; $172 = $171 & 65535 ; HEAP16 [ $168 >> 1 ] = $172 ; $173 = $4 ; $174 = ( ( ( $173 ) ) + 5816 | 0 ) ; $175 = HEAP16 [ $174 >> 1 ] | 0 ; $176 = $175 & 65535 ; $177 = $176 & 255 ; $178 = $177 & 255 ; $179 = $4 ; $180 = ( ( ( $179 ) ) + 8 | 0 ) ; $181 = HEAP32 [ $180 >> 2 ] | 0 ; $182 = $4 ; $183 = ( ( ( $182 ) ) + 20 | 0 ) ; $184 = HEAP32 [ $183 >> 2 ] | 0 ; $185 = ( ( $184 ) + 1 ) | 0 ; HEAP32 [ $183 >> 2 ] = $185 ; $186 = ( ( $181 ) + ( $184 ) | 0 ) ; HEAP8 [ $186 >> 0 ] = $178 ; $187 = $4 ; $188 = ( ( ( $187 ) ) + 5816 | 0 ) ; $189 = HEAP16 [ $188 >> 1 ] | 0 ; $190 = $189 & 65535 ; $191 = $190 >> 8 ; $192 = $191 & 255 ; $193 = $4 ; $194 = ( ( ( $193 ) ) + 8 | 0 ) ; $195 = HEAP32 [ $194 >> 2 ] | 0 ; $196 = $4 ; $197 = ( ( ( $196 ) ) + 20 | 0 ) ; $198 = HEAP32 [ $197 >> 2 ] | 0 ; $199 = ( ( $198 ) + 1 ) | 0 ; HEAP32 [ $197 >> 2 ] = $199 ; $200 = ( ( $195 ) + ( $198 ) | 0 ) ; HEAP8 [ $200 >> 0 ] = $192 ; $201 = $14 ; $202 = $201 & 65535 ; $203 = $202 & 65535 ; $204 = $4 ; $205 = ( ( ( $204 ) ) + 5820 | 0 ) ; $206 = HEAP32 [ $205 >> 2 ] | 0 ; $207 = ( 16 - ( $206 ) ) | 0 ; $208 = $203 >> $207 ; $209 = $208 & 65535 ; $210 = $4 ; $211 = ( ( ( $210 ) ) + 5816 | 0 ) ; HEAP16 [ $211 >> 1 ] = $209 ; $212 = $13 ; $213 = ( ( $212 ) - 16 ) | 0 ; $214 = $4 ; $$sink = $214 ; $$sink8 = $213 ; } else { $215 = $159 & 65535 ; $216 = $215 & 65535 ; $217 = $4 ; $218 = ( ( ( $217 ) ) + 5820 | 0 ) ; $219 = HEAP32 [ $218 >> 2 ] | 0 ; $220 = $216 << $219 ; $221 = $4 ; $222 = ( ( ( $221 ) ) + 5816 | 0 ) ; $223 = HEAP16 [ $222 >> 1 ] | 0 ; $224 = $223 & 65535 ; $225 = $224 | $220 ; $226 = $225 & 65535 ; HEAP16 [ $222 >> 1 ] = $226 ; $227 = $13 ; $228 = $4 ; $$sink = $228 ; $$sink8 = $227 ; } $229 = ( ( ( $$sink ) ) + 5820 | 0 ) ; $230 = HEAP32 [ $229 >> 2 ] | 0 ; $231 = ( ( $230 ) + ( $$sink8 ) ) | 0 ; HEAP32 [ $229 >> 2 ] = $231 ; $232 = $4 ; $233 = $4 ; $234 = ( ( ( $233 ) ) + 2840 | 0 ) ; $235 = ( ( ( $234 ) ) + 4 | 0 ) ; $236 = HEAP32 [ $235 >> 2 ] | 0 ; $237 = ( ( $236 ) + 1 ) | 0 ; $238 = $4 ; $239 = ( ( ( $238 ) ) + 2852 | 0 ) ; $240 = ( ( ( $239 ) ) + 4 | 0 ) ; $241 = HEAP32 [ $240 >> 2 ] | 0 ; $242 = ( ( $241 ) + 1 ) | 0 ; $243 = $10 ; $244 = ( ( $243 ) + 1 ) | 0 ; _send_all_trees ( $232 , $237 , $242 , $244 ) ; $245 = $4 ; $246 = $4 ; $247 = ( ( ( $246 ) ) + 148 | 0 ) ; $248 = $4 ; $249 = ( ( ( $248 ) ) + 2440 | 0 ) ; _compress_block ( $245 , $247 , $249 ) ; break ; } } $11 = 3 ; $71 = $4 ; $72 = ( ( ( $71 ) ) + 5820 | 0 ) ; $73 = HEAP32 [ $72 >> 2 ] | 0 ; $74 = $11 ; $75 = ( 16 - ( $74 ) ) | 0 ; $76 = ( $73 | 0 ) > ( $75 | 0 ) ; $77 = $7 ; $78 = ( 2 + ( $77 ) ) | 0 ; if ( $76 ) { $12 = $78 ; $79 = $12 ; $80 = $79 & 65535 ; $81 = $80 & 65535 ; $82 = $4 ; $83 = ( ( ( $82 ) ) + 5820 | 0 ) ; $84 = HEAP32 [ $83 >> 2 ] | 0 ; $85 = $81 << $84 ; $86 = $4 ; $87 = ( ( ( $86 ) ) + 5816 | 0 ) ; $88 = HEAP16 [ $87 >> 1 ] | 0 ; $89 = $88 & 65535 ; $90 = $89 | $85 ; $91 = $90 & 65535 ; HEAP16 [ $87 >> 1 ] = $91 ; $92 = $4 ; $93 = ( ( ( $92 ) ) + 5816 | 0 ) ; $94 = HEAP16 [ $93 >> 1 ] | 0 ; $95 = $94 & 65535 ; $96 = $95 & 255 ; $97 = $96 & 255 ; $98 = $4 ; $99 = ( ( ( $98 ) ) + 8 | 0 ) ; $100 = HEAP32 [ $99 >> 2 ] | 0 ; $101 = $4 ; $102 = ( ( ( $101 ) ) + 20 | 0 ) ; $103 = HEAP32 [ $102 >> 2 ] | 0 ; $104 = ( ( $103 ) + 1 ) | 0 ; HEAP32 [ $102 >> 2 ] = $104 ; $105 = ( ( $100 ) + ( $103 ) | 0 ) ; HEAP8 [ $105 >> 0 ] = $97 ; $106 = $4 ; $107 = ( ( ( $106 ) ) + 5816 | 0 ) ; $108 = HEAP16 [ $107 >> 1 ] | 0 ; $109 = $108 & 65535 ; $110 = $109 >> 8 ; $111 = $110 & 255 ; $112 = $4 ; $113 = ( ( ( $112 ) ) + 8 | 0 ) ; $114 = HEAP32 [ $113 >> 2 ] | 0 ; $115 = $4 ; $116 = ( ( ( $115 ) ) + 20 | 0 ) ; $117 = HEAP32 [ $116 >> 2 ] | 0 ; $118 = ( ( $117 ) + 1 ) | 0 ; HEAP32 [ $116 >> 2 ] = $118 ; $119 = ( ( $114 ) + ( $117 ) | 0 ) ; HEAP8 [ $119 >> 0 ] = $111 ; $120 = $12 ; $121 = $120 & 65535 ; $122 = $121 & 65535 ; $123 = $4 ; $124 = ( ( ( $123 ) ) + 5820 | 0 ) ; $125 = HEAP32 [ $124 >> 2 ] | 0 ; $126 = ( 16 - ( $125 ) ) | 0 ; $127 = $122 >> $126 ; $128 = $127 & 65535 ; $129 = $4 ; $130 = ( ( ( $129 ) ) + 5816 | 0 ) ; HEAP16 [ $130 >> 1 ] = $128 ; $131 = $11 ; $132 = ( ( $131 ) - 16 ) | 0 ; $133 = $4 ; $$sink10 = $133 ; $$sink4 = $132 ; } else { $134 = $78 & 65535 ; $135 = $134 & 65535 ; $136 = $4 ; $137 = ( ( ( $136 ) ) + 5820 | 0 ) ; $138 = HEAP32 [ $137 >> 2 ] | 0 ; $139 = $135 << $138 ; $140 = $4 ; $141 = ( ( ( $140 ) ) + 5816 | 0 ) ; $142 = HEAP16 [ $141 >> 1 ] | 0 ; $143 = $142 & 65535 ; $144 = $143 | $139 ; $145 = $144 & 65535 ; HEAP16 [ $141 >> 1 ] = $145 ; $146 = $11 ; $147 = $4 ; $$sink10 = $147 ; $$sink4 = $146 ; } $148 = ( ( ( $$sink10 ) ) + 5820 | 0 ) ; $149 = HEAP32 [ $148 >> 2 ] | 0 ; $150 = ( ( $149 ) + ( $$sink4 ) ) | 0 ; HEAP32 [ $148 >> 2 ] = $150 ; $151 = $4 ; _compress_block ( $151 , 12674 , 12554 ) ; } } while ( 0 ) ; $250 = $4 ; _init_block ( $250 ) ; $251 = $7 ; $252 = ( $251 | 0 ) != ( 0 ) ; if ( ! ( $252 ) ) { STACKTOP = sp ; return ; } $253 = $4 ; _bi_windup ( $253 ) ; STACKTOP = sp ; return ; } function _detect_data_type ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 ; var $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 ; var $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = $0 ; $3 = - 201342849 ; $4 = 0 ; while ( 1 ) { $5 = $4 ; $6 = ( $5 | 0 ) <= ( 31 ) ; if ( ! ( $6 ) ) { break ; } $7 = $3 ; $8 = $7 & 1 ; $9 = ( $8 | 0 ) != ( 0 ) ; if ( $9 ) { $10 = $2 ; $11 = ( ( ( $10 ) ) + 148 | 0 ) ; $12 = $4 ; $13 = ( ( $11 ) + ( $12 << 2 ) | 0 ) ; $14 = HEAP16 [ $13 >> 1 ] | 0 ; $15 = $14 & 65535 ; $16 = ( $15 | 0 ) != ( 0 ) ; if ( $16 ) { label = 5 ; break ; } } $17 = $4 ; $18 = ( ( $17 ) + 1 ) | 0 ; $4 = $18 ; $19 = $3 ; $20 = $19 >>> 1 ; $3 = $20 ; } if ( ( label | 0 ) == 5 ) { $1 = 0 ; $50 = $1 ; STACKTOP = sp ; return ( $50 | 0 ) ; } $21 = $2 ; $22 = ( ( ( $21 ) ) + 148 | 0 ) ; $23 = ( ( ( $22 ) ) + 36 | 0 ) ; $24 = HEAP16 [ $23 >> 1 ] | 0 ; $25 = $24 & 65535 ; $26 = ( $25 | 0 ) != ( 0 ) ; if ( ! ( $26 ) ) { $27 = $2 ; $28 = ( ( ( $27 ) ) + 148 | 0 ) ; $29 = ( ( ( $28 ) ) + 40 | 0 ) ; $30 = HEAP16 [ $29 >> 1 ] | 0 ; $31 = $30 & 65535 ; $32 = ( $31 | 0 ) != ( 0 ) ; if ( ! ( $32 ) ) { $33 = $2 ; $34 = ( ( ( $33 ) ) + 148 | 0 ) ; $35 = ( ( ( $34 ) ) + 52 | 0 ) ; $36 = HEAP16 [ $35 >> 1 ] | 0 ; $37 = $36 & 65535 ; $38 = ( $37 | 0 ) != ( 0 ) ; if ( ! ( $38 ) ) { $4 = 32 ; while ( 1 ) { $39 = $4 ; $40 = ( $39 | 0 ) < ( 256 ) ; if ( ! ( $40 ) ) { label = 16 ; break ; } $41 = $2 ; $42 = ( ( ( $41 ) ) + 148 | 0 ) ; $43 = $4 ; $44 = ( ( $42 ) + ( $43 << 2 ) | 0 ) ; $45 = HEAP16 [ $44 >> 1 ] | 0 ; $46 = $45 & 65535 ; $47 = ( $46 | 0 ) != ( 0 ) ; if ( $47 ) { label = 14 ; break ; } $48 = $4 ; $49 = ( ( $48 ) + 1 ) | 0 ; $4 = $49 ; } if ( ( label | 0 ) == 14 ) { $1 = 1 ; $50 = $1 ; STACKTOP = sp ; return ( $50 | 0 ) ; } else if ( ( label | 0 ) == 16 ) { $1 = 0 ; $50 = $1 ; STACKTOP = sp ; return ( $50 | 0 ) ; } } } } $1 = 1 ; $50 = $1 ; STACKTOP = sp ; return ( $50 | 0 ) ; } function _build_tree ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$sink = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 ; var $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 ; var $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 ; var $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 ; var $171 = 0 , $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 ; var $19 = 0 , $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $2 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 ; var $207 = 0 , $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $23 = 0 , $24 = 0 , $25 = 0 ; var $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 ; var $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 ; var $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 ; var $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 ; var $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 48 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 48 | 0 ) ; $2 = $0 ; $3 = $1 ; $11 = $3 ; $12 = HEAP32 [ $11 >> 2 ] | 0 ; $4 = $12 ; $13 = $3 ; $14 = ( ( ( $13 ) ) + 8 | 0 ) ; $15 = HEAP32 [ $14 >> 2 ] | 0 ; $16 = HEAP32 [ $15 >> 2 ] | 0 ; $5 = $16 ; $17 = $3 ; $18 = ( ( ( $17 ) ) + 8 | 0 ) ; $19 = HEAP32 [ $18 >> 2 ] | 0 ; $20 = ( ( ( $19 ) ) + 12 | 0 ) ; $21 = HEAP32 [ $20 >> 2 ] | 0 ; $6 = $21 ; $9 = - 1 ; $22 = $2 ; $23 = ( ( ( $22 ) ) + 5200 | 0 ) ; HEAP32 [ $23 >> 2 ] = 0 ; $24 = $2 ; $25 = ( ( ( $24 ) ) + 5204 | 0 ) ; HEAP32 [ $25 >> 2 ] = 573 ; $7 = 0 ; while ( 1 ) { $26 = $7 ; $27 = $6 ; $28 = ( $26 | 0 ) < ( $27 | 0 ) ; if ( ! ( $28 ) ) { break ; } $29 = $4 ; $30 = $7 ; $31 = ( ( $29 ) + ( $30 << 2 ) | 0 ) ; $32 = HEAP16 [ $31 >> 1 ] | 0 ; $33 = $32 & 65535 ; $34 = ( $33 | 0 ) != ( 0 ) ; if ( $34 ) { $35 = $7 ; $9 = $35 ; $36 = $2 ; $37 = ( ( ( $36 ) ) + 2908 | 0 ) ; $38 = $2 ; $39 = ( ( ( $38 ) ) + 5200 | 0 ) ; $40 = HEAP32 [ $39 >> 2 ] | 0 ; $41 = ( ( $40 ) + 1 ) | 0 ; HEAP32 [ $39 >> 2 ] = $41 ; $42 = ( ( $37 ) + ( $41 << 2 ) | 0 ) ; HEAP32 [ $42 >> 2 ] = $35 ; $43 = $2 ; $44 = ( ( ( $43 ) ) + 5208 | 0 ) ; $45 = $7 ; $46 = ( ( $44 ) + ( $45 ) | 0 ) ; HEAP8 [ $46 >> 0 ] = 0 ; } else { $47 = $4 ; $48 = $7 ; $49 = ( ( $47 ) + ( $48 << 2 ) | 0 ) ; $50 = ( ( ( $49 ) ) + 2 | 0 ) ; HEAP16 [ $50 >> 1 ] = 0 ; } $51 = $7 ; $52 = ( ( $51 ) + 1 ) | 0 ; $7 = $52 ; } while ( 1 ) { $53 = $2 ; $54 = ( ( ( $53 ) ) + 5200 | 0 ) ; $55 = HEAP32 [ $54 >> 2 ] | 0 ; $56 = ( $55 | 0 ) < ( 2 ) ; $57 = $9 ; if ( ! ( $56 ) ) { break ; } $58 = ( $57 | 0 ) < ( 2 ) ; if ( $58 ) { $59 = $9 ; $60 = ( ( $59 ) + 1 ) | 0 ; $9 = $60 ; $68 = $60 ; } else { $68 = 0 ; } $61 = $2 ; $62 = ( ( ( $61 ) ) + 2908 | 0 ) ; $63 = $2 ; $64 = ( ( ( $63 ) ) + 5200 | 0 ) ; $65 = HEAP32 [ $64 >> 2 ] | 0 ; $66 = ( ( $65 ) + 1 ) | 0 ; HEAP32 [ $64 >> 2 ] = $66 ; $67 = ( ( $62 ) + ( $66 << 2 ) | 0 ) ; HEAP32 [ $67 >> 2 ] = $68 ; $10 = $68 ; $69 = $4 ; $70 = $10 ; $71 = ( ( $69 ) + ( $70 << 2 ) | 0 ) ; HEAP16 [ $71 >> 1 ] = 1 ; $72 = $2 ; $73 = ( ( ( $72 ) ) + 5208 | 0 ) ; $74 = $10 ; $75 = ( ( $73 ) + ( $74 ) | 0 ) ; HEAP8 [ $75 >> 0 ] = 0 ; $76 = $2 ; $77 = ( ( ( $76 ) ) + 5800 | 0 ) ; $78 = HEAP32 [ $77 >> 2 ] | 0 ; $79 = ( ( $78 ) + - 1 ) | 0 ; HEAP32 [ $77 >> 2 ] = $79 ; $80 = $5 ; $81 = ( $80 | 0 ) != ( 0 | 0 ) ; if ( ! ( $81 ) ) { continue ; } $82 = $5 ; $83 = $10 ; $84 = ( ( $82 ) + ( $83 << 2 ) | 0 ) ; $85 = ( ( ( $84 ) ) + 2 | 0 ) ; $86 = HEAP16 [ $85 >> 1 ] | 0 ; $87 = $86 & 65535 ; $88 = $2 ; $89 = ( ( ( $88 ) ) + 5804 | 0 ) ; $90 = HEAP32 [ $89 >> 2 ] | 0 ; $91 = ( ( $90 ) - ( $87 ) ) | 0 ; HEAP32 [ $89 >> 2 ] = $91 ; } $92 = $3 ; $93 = ( ( ( $92 ) ) + 4 | 0 ) ; HEAP32 [ $93 >> 2 ] = $57 ; $94 = $2 ; $95 = ( ( ( $94 ) ) + 5200 | 0 ) ; $96 = HEAP32 [ $95 >> 2 ] | 0 ; $97 = ( ( $96 | 0 ) / 2 ) & - 1 ; $7 = $97 ; while ( 1 ) { $98 = $7 ; $99 = ( $98 | 0 ) >= ( 1 ) ; if ( ! ( $99 ) ) { break ; } $100 = $2 ; $101 = $4 ; $102 = $7 ; _pqdownheap ( $100 , $101 , $102 ) ; $103 = $7 ; $104 = ( ( $103 ) + - 1 ) | 0 ; $7 = $104 ; } $105 = $6 ; $10 = $105 ; while ( 1 ) { $106 = $2 ; $107 = ( ( ( $106 ) ) + 2908 | 0 ) ; $108 = ( ( ( $107 ) ) + 4 | 0 ) ; $109 = HEAP32 [ $108 >> 2 ] | 0 ; $7 = $109 ; $110 = $2 ; $111 = ( ( ( $110 ) ) + 2908 | 0 ) ; $112 = $2 ; $113 = ( ( ( $112 ) ) + 5200 | 0 ) ; $114 = HEAP32 [ $113 >> 2 ] | 0 ; $115 = ( ( $114 ) + - 1 ) | 0 ; HEAP32 [ $113 >> 2 ] = $115 ; $116 = ( ( $111 ) + ( $114 << 2 ) | 0 ) ; $117 = HEAP32 [ $116 >> 2 ] | 0 ; $118 = $2 ; $119 = ( ( ( $118 ) ) + 2908 | 0 ) ; $120 = ( ( ( $119 ) ) + 4 | 0 ) ; HEAP32 [ $120 >> 2 ] = $117 ; $121 = $2 ; $122 = $4 ; _pqdownheap ( $121 , $122 , 1 ) ; $123 = $2 ; $124 = ( ( ( $123 ) ) + 2908 | 0 ) ; $125 = ( ( ( $124 ) ) + 4 | 0 ) ; $126 = HEAP32 [ $125 >> 2 ] | 0 ; $8 = $126 ; $127 = $7 ; $128 = $2 ; $129 = ( ( ( $128 ) ) + 2908 | 0 ) ; $130 = $2 ; $131 = ( ( ( $130 ) ) + 5204 | 0 ) ; $132 = HEAP32 [ $131 >> 2 ] | 0 ; $133 = ( ( $132 ) + - 1 ) | 0 ; HEAP32 [ $131 >> 2 ] = $133 ; $134 = ( ( $129 ) + ( $133 << 2 ) | 0 ) ; HEAP32 [ $134 >> 2 ] = $127 ; $135 = $8 ; $136 = $2 ; $137 = ( ( ( $136 ) ) + 2908 | 0 ) ; $138 = $2 ; $139 = ( ( ( $138 ) ) + 5204 | 0 ) ; $140 = HEAP32 [ $139 >> 2 ] | 0 ; $141 = ( ( $140 ) + - 1 ) | 0 ; HEAP32 [ $139 >> 2 ] = $141 ; $142 = ( ( $137 ) + ( $141 << 2 ) | 0 ) ; HEAP32 [ $142 >> 2 ] = $135 ; $143 = $4 ; $144 = $7 ; $145 = ( ( $143 ) + ( $144 << 2 ) | 0 ) ; $146 = HEAP16 [ $145 >> 1 ] | 0 ; $147 = $146 & 65535 ; $148 = $4 ; $149 = $8 ; $150 = ( ( $148 ) + ( $149 << 2 ) | 0 ) ; $151 = HEAP16 [ $150 >> 1 ] | 0 ; $152 = $151 & 65535 ; $153 = ( ( $147 ) + ( $152 ) ) | 0 ; $154 = $153 & 65535 ; $155 = $4 ; $156 = $10 ; $157 = ( ( $155 ) + ( $156 << 2 ) | 0 ) ; HEAP16 [ $157 >> 1 ] = $154 ; $158 = $2 ; $159 = ( ( ( $158 ) ) + 5208 | 0 ) ; $160 = $7 ; $161 = ( ( $159 ) + ( $160 ) | 0 ) ; $162 = HEAP8 [ $161 >> 0 ] | 0 ; $163 = $162 & 255 ; $164 = $2 ; $165 = ( ( ( $164 ) ) + 5208 | 0 ) ; $166 = $8 ; $167 = ( ( $165 ) + ( $166 ) | 0 ) ; $168 = HEAP8 [ $167 >> 0 ] | 0 ; $169 = $168 & 255 ; $170 = ( $163 | 0 ) >= ( $169 | 0 ) ; $171 = $2 ; $172 = ( ( ( $171 ) ) + 5208 | 0 ) ; $173 = $8 ; $174 = $7 ; $$sink = $170 ? $174 : $173 ; $175 = ( ( $172 ) + ( $$sink ) | 0 ) ; $176 = HEAP8 [ $175 >> 0 ] | 0 ; $177 = $176 & 255 ; $178 = ( ( $177 ) + 1 ) | 0 ; $179 = $178 & 255 ; $180 = $2 ; $181 = ( ( ( $180 ) ) + 5208 | 0 ) ; $182 = $10 ; $183 = ( ( $181 ) + ( $182 ) | 0 ) ; HEAP8 [ $183 >> 0 ] = $179 ; $184 = $10 ; $185 = $184 & 65535 ; $186 = $4 ; $187 = $8 ; $188 = ( ( $186 ) + ( $187 << 2 ) | 0 ) ; $189 = ( ( ( $188 ) ) + 2 | 0 ) ; HEAP16 [ $189 >> 1 ] = $185 ; $190 = $4 ; $191 = $7 ; $192 = ( ( $190 ) + ( $191 << 2 ) | 0 ) ; $193 = ( ( ( $192 ) ) + 2 | 0 ) ; HEAP16 [ $193 >> 1 ] = $185 ; $194 = $10 ; $195 = ( ( $194 ) + 1 ) | 0 ; $10 = $195 ; $196 = $2 ; $197 = ( ( ( $196 ) ) + 2908 | 0 ) ; $198 = ( ( ( $197 ) ) + 4 | 0 ) ; HEAP32 [ $198 >> 2 ] = $194 ; $199 = $2 ; $200 = $4 ; _pqdownheap ( $199 , $200 , 1 ) ; $201 = $2 ; $202 = ( ( ( $201 ) ) + 5200 | 0 ) ; $203 = HEAP32 [ $202 >> 2 ] | 0 ; $204 = ( $203 | 0 ) >= ( 2 ) ; if ( ! ( $204 ) ) { break ; } } $205 = $2 ; $206 = ( ( ( $205 ) ) + 2908 | 0 ) ; $207 = ( ( ( $206 ) ) + 4 | 0 ) ; $208 = HEAP32 [ $207 >> 2 ] | 0 ; $209 = $2 ; $210 = ( ( ( $209 ) ) + 2908 | 0 ) ; $211 = $2 ; $212 = ( ( ( $211 ) ) + 5204 | 0 ) ; $213 = HEAP32 [ $212 >> 2 ] | 0 ; $214 = ( ( $213 ) + - 1 ) | 0 ; HEAP32 [ $212 >> 2 ] = $214 ; $215 = ( ( $210 ) + ( $214 << 2 ) | 0 ) ; HEAP32 [ $215 >> 2 ] = $208 ; $216 = $2 ; $217 = $3 ; _gen_bitlen ( $216 , $217 ) ; $218 = $4 ; $219 = $9 ; $220 = $2 ; $221 = ( ( ( $220 ) ) + 2876 | 0 ) ; _gen_codes ( $218 , $219 , $221 ) ; STACKTOP = sp ; return ; } function _build_bl_tree ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 ; var $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 ; var $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $3 = $1 ; $4 = $1 ; $5 = ( ( ( $4 ) ) + 148 | 0 ) ; $6 = $1 ; $7 = ( ( ( $6 ) ) + 2840 | 0 ) ; $8 = ( ( ( $7 ) ) + 4 | 0 ) ; $9 = HEAP32 [ $8 >> 2 ] | 0 ; _scan_tree ( $3 , $5 , $9 ) ; $10 = $1 ; $11 = $1 ; $12 = ( ( ( $11 ) ) + 2440 | 0 ) ; $13 = $1 ; $14 = ( ( ( $13 ) ) + 2852 | 0 ) ; $15 = ( ( ( $14 ) ) + 4 | 0 ) ; $16 = HEAP32 [ $15 >> 2 ] | 0 ; _scan_tree ( $10 , $12 , $16 ) ; $17 = $1 ; $18 = $1 ; $19 = ( ( ( $18 ) ) + 2864 | 0 ) ; _build_tree ( $17 , $19 ) ; $2 = 18 ; while ( 1 ) { $20 = $2 ; $21 = ( $20 | 0 ) >= ( 3 ) ; if ( ! ( $21 ) ) { break ; } $22 = $1 ; $23 = ( ( ( $22 ) ) + 2684 | 0 ) ; $24 = $2 ; $25 = ( 29528 + ( $24 ) | 0 ) ; $26 = HEAP8 [ $25 >> 0 ] | 0 ; $27 = $26 & 255 ; $28 = ( ( $23 ) + ( $27 << 2 ) | 0 ) ; $29 = ( ( ( $28 ) ) + 2 | 0 ) ; $30 = HEAP16 [ $29 >> 1 ] | 0 ; $31 = $30 & 65535 ; $32 = ( $31 | 0 ) != ( 0 ) ; if ( $32 ) { break ; } $33 = $2 ; $34 = ( ( $33 ) + - 1 ) | 0 ; $2 = $34 ; } $35 = $2 ; $36 = ( ( $35 ) + 1 ) | 0 ; $37 = ( $36 * 3 ) | 0 ; $38 = ( ( $37 ) + 5 ) | 0 ; $39 = ( ( $38 ) + 5 ) | 0 ; $40 = ( ( $39 ) + 4 ) | 0 ; $41 = $1 ; $42 = ( ( ( $41 ) ) + 5800 | 0 ) ; $43 = HEAP32 [ $42 >> 2 ] | 0 ; $44 = ( ( $43 ) + ( $40 ) ) | 0 ; HEAP32 [ $42 >> 2 ] = $44 ; $45 = $2 ; STACKTOP = sp ; return ( $45 | 0 ) ; } function _compress_block ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$sink12 = 0 , $$sink16 = 0 , $$sink20 = 0 , $$sink3$sink = 0 , $$sink30 = 0 , $$sink35 = 0 , $$sink36 = 0 , $$sink37 = 0 , $$sink38$sink = 0 , $$sink39 = 0 , $$sink7 = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 ; var $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 ; var $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 ; var $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 ; var $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 , $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 ; var $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 , $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 ; var $199 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 , $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 ; var $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 , $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 ; var $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 , $244 = 0 , $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 ; var $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 , $258 = 0 , $259 = 0 , $26 = 0 , $260 = 0 , $261 = 0 , $262 = 0 , $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 , $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 , $270 = 0 ; var $271 = 0 , $272 = 0 , $273 = 0 , $274 = 0 , $275 = 0 , $276 = 0 , $277 = 0 , $278 = 0 , $279 = 0 , $28 = 0 , $280 = 0 , $281 = 0 , $282 = 0 , $283 = 0 , $284 = 0 , $285 = 0 , $286 = 0 , $287 = 0 , $288 = 0 , $289 = 0 ; var $29 = 0 , $290 = 0 , $291 = 0 , $292 = 0 , $293 = 0 , $294 = 0 , $295 = 0 , $296 = 0 , $297 = 0 , $298 = 0 , $299 = 0 , $3 = 0 , $30 = 0 , $300 = 0 , $301 = 0 , $302 = 0 , $303 = 0 , $304 = 0 , $305 = 0 , $306 = 0 ; var $307 = 0 , $308 = 0 , $309 = 0 , $31 = 0 , $310 = 0 , $311 = 0 , $312 = 0 , $313 = 0 , $314 = 0 , $315 = 0 , $316 = 0 , $317 = 0 , $318 = 0 , $319 = 0 , $32 = 0 , $320 = 0 , $321 = 0 , $322 = 0 , $323 = 0 , $324 = 0 ; var $325 = 0 , $326 = 0 , $327 = 0 , $328 = 0 , $329 = 0 , $33 = 0 , $330 = 0 , $331 = 0 , $332 = 0 , $333 = 0 , $334 = 0 , $335 = 0 , $336 = 0 , $337 = 0 , $338 = 0 , $339 = 0 , $34 = 0 , $340 = 0 , $341 = 0 , $342 = 0 ; var $343 = 0 , $344 = 0 , $345 = 0 , $346 = 0 , $347 = 0 , $348 = 0 , $349 = 0 , $35 = 0 , $350 = 0 , $351 = 0 , $352 = 0 , $353 = 0 , $354 = 0 , $355 = 0 , $356 = 0 , $357 = 0 , $358 = 0 , $359 = 0 , $36 = 0 , $360 = 0 ; var $361 = 0 , $362 = 0 , $363 = 0 , $364 = 0 , $365 = 0 , $366 = 0 , $367 = 0 , $368 = 0 , $369 = 0 , $37 = 0 , $370 = 0 , $371 = 0 , $372 = 0 , $373 = 0 , $374 = 0 , $375 = 0 , $376 = 0 , $377 = 0 , $378 = 0 , $379 = 0 ; var $38 = 0 , $380 = 0 , $381 = 0 , $382 = 0 , $383 = 0 , $384 = 0 , $385 = 0 , $386 = 0 , $387 = 0 , $388 = 0 , $389 = 0 , $39 = 0 , $390 = 0 , $391 = 0 , $392 = 0 , $393 = 0 , $394 = 0 , $395 = 0 , $396 = 0 , $397 = 0 ; var $398 = 0 , $399 = 0 , $4 = 0 , $40 = 0 , $400 = 0 , $401 = 0 , $402 = 0 , $403 = 0 , $404 = 0 , $405 = 0 , $406 = 0 , $407 = 0 , $408 = 0 , $409 = 0 , $41 = 0 , $410 = 0 , $411 = 0 , $412 = 0 , $413 = 0 , $414 = 0 ; var $415 = 0 , $416 = 0 , $417 = 0 , $418 = 0 , $419 = 0 , $42 = 0 , $420 = 0 , $421 = 0 , $422 = 0 , $423 = 0 , $424 = 0 , $425 = 0 , $426 = 0 , $427 = 0 , $428 = 0 , $429 = 0 , $43 = 0 , $430 = 0 , $431 = 0 , $432 = 0 ; var $433 = 0 , $434 = 0 , $435 = 0 , $436 = 0 , $437 = 0 , $438 = 0 , $439 = 0 , $44 = 0 , $440 = 0 , $441 = 0 , $442 = 0 , $443 = 0 , $444 = 0 , $445 = 0 , $446 = 0 , $447 = 0 , $448 = 0 , $449 = 0 , $45 = 0 , $450 = 0 ; var $451 = 0 , $452 = 0 , $453 = 0 , $454 = 0 , $455 = 0 , $456 = 0 , $457 = 0 , $458 = 0 , $459 = 0 , $46 = 0 , $460 = 0 , $461 = 0 , $462 = 0 , $463 = 0 , $464 = 0 , $465 = 0 , $466 = 0 , $467 = 0 , $468 = 0 , $469 = 0 ; var $47 = 0 , $470 = 0 , $471 = 0 , $472 = 0 , $473 = 0 , $474 = 0 , $475 = 0 , $476 = 0 , $477 = 0 , $478 = 0 , $479 = 0 , $48 = 0 , $480 = 0 , $481 = 0 , $482 = 0 , $483 = 0 , $484 = 0 , $485 = 0 , $486 = 0 , $487 = 0 ; var $488 = 0 , $489 = 0 , $49 = 0 , $490 = 0 , $491 = 0 , $492 = 0 , $493 = 0 , $494 = 0 , $495 = 0 , $496 = 0 , $497 = 0 , $498 = 0 , $499 = 0 , $5 = 0 , $50 = 0 , $500 = 0 , $501 = 0 , $502 = 0 , $503 = 0 , $504 = 0 ; var $505 = 0 , $506 = 0 , $507 = 0 , $508 = 0 , $509 = 0 , $51 = 0 , $510 = 0 , $511 = 0 , $512 = 0 , $513 = 0 , $514 = 0 , $515 = 0 , $516 = 0 , $517 = 0 , $518 = 0 , $519 = 0 , $52 = 0 , $520 = 0 , $521 = 0 , $522 = 0 ; var $523 = 0 , $524 = 0 , $525 = 0 , $526 = 0 , $527 = 0 , $528 = 0 , $529 = 0 , $53 = 0 , $530 = 0 , $531 = 0 , $532 = 0 , $533 = 0 , $534 = 0 , $535 = 0 , $536 = 0 , $537 = 0 , $538 = 0 , $539 = 0 , $54 = 0 , $540 = 0 ; var $541 = 0 , $542 = 0 , $543 = 0 , $544 = 0 , $545 = 0 , $546 = 0 , $547 = 0 , $548 = 0 , $549 = 0 , $55 = 0 , $550 = 0 , $551 = 0 , $552 = 0 , $553 = 0 , $554 = 0 , $555 = 0 , $556 = 0 , $557 = 0 , $558 = 0 , $559 = 0 ; var $56 = 0 , $560 = 0 , $561 = 0 , $562 = 0 , $563 = 0 , $564 = 0 , $565 = 0 , $566 = 0 , $567 = 0 , $568 = 0 , $569 = 0 , $57 = 0 , $570 = 0 , $571 = 0 , $572 = 0 , $573 = 0 , $574 = 0 , $575 = 0 , $576 = 0 , $577 = 0 ; var $578 = 0 , $579 = 0 , $58 = 0 , $580 = 0 , $581 = 0 , $582 = 0 , $583 = 0 , $584 = 0 , $585 = 0 , $586 = 0 , $587 = 0 , $588 = 0 , $589 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 ; var $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 ; var $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 80 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 80 | 0 ) ; $3 = $0 ; $4 = $1 ; $5 = $2 ; $8 = 0 ; $23 = $3 ; $24 = ( ( ( $23 ) ) + 5792 | 0 ) ; $25 = HEAP32 [ $24 >> 2 ] | 0 ; $26 = ( $25 | 0 ) != ( 0 ) ; if ( $26 ) { while ( 1 ) { $27 = $3 ; $28 = ( ( ( $27 ) ) + 5796 | 0 ) ; $29 = HEAP32 [ $28 >> 2 ] | 0 ; $30 = $8 ; $31 = ( ( $29 ) + ( $30 << 1 ) | 0 ) ; $32 = HEAP16 [ $31 >> 1 ] | 0 ; $33 = $32 & 65535 ; $6 = $33 ; $34 = $3 ; $35 = ( ( ( $34 ) ) + 5784 | 0 ) ; $36 = HEAP32 [ $35 >> 2 ] | 0 ; $37 = $8 ; $38 = ( ( $37 ) + 1 ) | 0 ; $8 = $38 ; $39 = ( ( $36 ) + ( $37 ) | 0 ) ; $40 = HEAP8 [ $39 >> 0 ] | 0 ; $41 = $40 & 255 ; $7 = $41 ; $42 = $6 ; $43 = ( $42 | 0 ) == ( 0 ) ; do { if ( $43 ) { $44 = $4 ; $45 = $7 ; $46 = ( ( $44 ) + ( $45 << 2 ) | 0 ) ; $47 = ( ( ( $46 ) ) + 2 | 0 ) ; $48 = HEAP16 [ $47 >> 1 ] | 0 ; $49 = $48 & 65535 ; $11 = $49 ; $50 = $3 ; $51 = ( ( ( $50 ) ) + 5820 | 0 ) ; $52 = HEAP32 [ $51 >> 2 ] | 0 ; $53 = $11 ; $54 = ( 16 - ( $53 ) ) | 0 ; $55 = ( $52 | 0 ) > ( $54 | 0 ) ; $56 = $4 ; $57 = $7 ; $58 = ( ( $56 ) + ( $57 << 2 ) | 0 ) ; $59 = HEAP16 [ $58 >> 1 ] | 0 ; $60 = $59 & 65535 ; if ( $55 ) { $12 = $60 ; $61 = $12 ; $62 = $61 & 65535 ; $63 = $62 & 65535 ; $64 = $3 ; $65 = ( ( ( $64 ) ) + 5820 | 0 ) ; $66 = HEAP32 [ $65 >> 2 ] | 0 ; $67 = $63 << $66 ; $68 = $3 ; $69 = ( ( ( $68 ) ) + 5816 | 0 ) ; $70 = HEAP16 [ $69 >> 1 ] | 0 ; $71 = $70 & 65535 ; $72 = $71 | $67 ; $73 = $72 & 65535 ; HEAP16 [ $69 >> 1 ] = $73 ; $74 = $3 ; $75 = ( ( ( $74 ) ) + 5816 | 0 ) ; $76 = HEAP16 [ $75 >> 1 ] | 0 ; $77 = $76 & 65535 ; $78 = $77 & 255 ; $79 = $78 & 255 ; $80 = $3 ; $81 = ( ( ( $80 ) ) + 8 | 0 ) ; $82 = HEAP32 [ $81 >> 2 ] | 0 ; $83 = $3 ; $84 = ( ( ( $83 ) ) + 20 | 0 ) ; $85 = HEAP32 [ $84 >> 2 ] | 0 ; $86 = ( ( $85 ) + 1 ) | 0 ; HEAP32 [ $84 >> 2 ] = $86 ; $87 = ( ( $82 ) + ( $85 ) | 0 ) ; HEAP8 [ $87 >> 0 ] = $79 ; $88 = $3 ; $89 = ( ( ( $88 ) ) + 5816 | 0 ) ; $90 = HEAP16 [ $89 >> 1 ] | 0 ; $91 = $90 & 65535 ; $92 = $91 >> 8 ; $93 = $92 & 255 ; $94 = $3 ; $95 = ( ( ( $94 ) ) + 8 | 0 ) ; $96 = HEAP32 [ $95 >> 2 ] | 0 ; $97 = $3 ; $98 = ( ( ( $97 ) ) + 20 | 0 ) ; $99 = HEAP32 [ $98 >> 2 ] | 0 ; $100 = ( ( $99 ) + 1 ) | 0 ; HEAP32 [ $98 >> 2 ] = $100 ; $101 = ( ( $96 ) + ( $99 ) | 0 ) ; HEAP8 [ $101 >> 0 ] = $93 ; $102 = $12 ; $103 = $102 & 65535 ; $104 = $103 & 65535 ; $105 = $3 ; $106 = ( ( ( $105 ) ) + 5820 | 0 ) ; $107 = HEAP32 [ $106 >> 2 ] | 0 ; $108 = ( 16 - ( $107 ) ) | 0 ; $109 = $104 >> $108 ; $110 = $109 & 65535 ; $111 = $3 ; $112 = ( ( ( $111 ) ) + 5816 | 0 ) ; HEAP16 [ $112 >> 1 ] = $110 ; $113 = $11 ; $114 = ( ( $113 ) - 16 ) | 0 ; $115 = $3 ; $$sink3$sink = $114 ; $$sink38$sink = $115 ; label = 21 ; break ; } else { $116 = $3 ; $117 = ( ( ( $116 ) ) + 5820 | 0 ) ; $118 = HEAP32 [ $117 >> 2 ] | 0 ; $119 = $60 << $118 ; $120 = $3 ; $121 = ( ( ( $120 ) ) + 5816 | 0 ) ; $122 = HEAP16 [ $121 >> 1 ] | 0 ; $123 = $122 & 65535 ; $124 = $123 | $119 ; $125 = $124 & 65535 ; HEAP16 [ $121 >> 1 ] = $125 ; $126 = $11 ; $127 = $3 ; $$sink3$sink = $126 ; $$sink38$sink = $127 ; label = 21 ; break ; } } else { $128 = $7 ; $129 = ( 29272 + ( $128 ) | 0 ) ; $130 = HEAP8 [ $129 >> 0 ] | 0 ; $131 = $130 & 255 ; $9 = $131 ; $132 = $4 ; $133 = $9 ; $134 = ( ( $133 ) + 256 ) | 0 ; $135 = ( ( $134 ) + 1 ) | 0 ; $136 = ( ( $132 ) + ( $135 << 2 ) | 0 ) ; $137 = ( ( ( $136 ) ) + 2 | 0 ) ; $138 = HEAP16 [ $137 >> 1 ] | 0 ; $139 = $138 & 65535 ; $13 = $139 ; $140 = $3 ; $141 = ( ( ( $140 ) ) + 5820 | 0 ) ; $142 = HEAP32 [ $141 >> 2 ] | 0 ; $143 = $13 ; $144 = ( 16 - ( $143 ) ) | 0 ; $145 = ( $142 | 0 ) > ( $144 | 0 ) ; $146 = $4 ; $147 = $9 ; $148 = ( ( $147 ) + 256 ) | 0 ; $149 = ( ( $148 ) + 1 ) | 0 ; $150 = ( ( $146 ) + ( $149 << 2 ) | 0 ) ; $151 = HEAP16 [ $150 >> 1 ] | 0 ; $152 = $151 & 65535 ; if ( $145 ) { $14 = $152 ; $153 = $14 ; $154 = $153 & 65535 ; $155 = $154 & 65535 ; $156 = $3 ; $157 = ( ( ( $156 ) ) + 5820 | 0 ) ; $158 = HEAP32 [ $157 >> 2 ] | 0 ; $159 = $155 << $158 ; $160 = $3 ; $161 = ( ( ( $160 ) ) + 5816 | 0 ) ; $162 = HEAP16 [ $161 >> 1 ] | 0 ; $163 = $162 & 65535 ; $164 = $163 | $159 ; $165 = $164 & 65535 ; HEAP16 [ $161 >> 1 ] = $165 ; $166 = $3 ; $167 = ( ( ( $166 ) ) + 5816 | 0 ) ; $168 = HEAP16 [ $167 >> 1 ] | 0 ; $169 = $168 & 65535 ; $170 = $169 & 255 ; $171 = $170 & 255 ; $172 = $3 ; $173 = ( ( ( $172 ) ) + 8 | 0 ) ; $174 = HEAP32 [ $173 >> 2 ] | 0 ; $175 = $3 ; $176 = ( ( ( $175 ) ) + 20 | 0 ) ; $177 = HEAP32 [ $176 >> 2 ] | 0 ; $178 = ( ( $177 ) + 1 ) | 0 ; HEAP32 [ $176 >> 2 ] = $178 ; $179 = ( ( $174 ) + ( $177 ) | 0 ) ; HEAP8 [ $179 >> 0 ] = $171 ; $180 = $3 ; $181 = ( ( ( $180 ) ) + 5816 | 0 ) ; $182 = HEAP16 [ $181 >> 1 ] | 0 ; $183 = $182 & 65535 ; $184 = $183 >> 8 ; $185 = $184 & 255 ; $186 = $3 ; $187 = ( ( ( $186 ) ) + 8 | 0 ) ; $188 = HEAP32 [ $187 >> 2 ] | 0 ; $189 = $3 ; $190 = ( ( ( $189 ) ) + 20 | 0 ) ; $191 = HEAP32 [ $190 >> 2 ] | 0 ; $192 = ( ( $191 ) + 1 ) | 0 ; HEAP32 [ $190 >> 2 ] = $192 ; $193 = ( ( $188 ) + ( $191 ) | 0 ) ; HEAP8 [ $193 >> 0 ] = $185 ; $194 = $14 ; $195 = $194 & 65535 ; $196 = $195 & 65535 ; $197 = $3 ; $198 = ( ( ( $197 ) ) + 5820 | 0 ) ; $199 = HEAP32 [ $198 >> 2 ] | 0 ; $200 = ( 16 - ( $199 ) ) | 0 ; $201 = $196 >> $200 ; $202 = $201 & 65535 ; $203 = $3 ; $204 = ( ( ( $203 ) ) + 5816 | 0 ) ; HEAP16 [ $204 >> 1 ] = $202 ; $205 = $13 ; $206 = ( ( $205 ) - 16 ) | 0 ; $207 = $3 ; $$sink35 = $207 ; $$sink7 = $206 ; } else { $208 = $3 ; $209 = ( ( ( $208 ) ) + 5820 | 0 ) ; $210 = HEAP32 [ $209 >> 2 ] | 0 ; $211 = $152 << $210 ; $212 = $3 ; $213 = ( ( ( $212 ) ) + 5816 | 0 ) ; $214 = HEAP16 [ $213 >> 1 ] | 0 ; $215 = $214 & 65535 ; $216 = $215 | $211 ; $217 = $216 & 65535 ; HEAP16 [ $213 >> 1 ] = $217 ; $218 = $13 ; $219 = $3 ; $$sink35 = $219 ; $$sink7 = $218 ; } $220 = ( ( ( $$sink35 ) ) + 5820 | 0 ) ; $221 = HEAP32 [ $220 >> 2 ] | 0 ; $222 = ( ( $221 ) + ( $$sink7 ) ) | 0 ; HEAP32 [ $220 >> 2 ] = $222 ; $223 = $9 ; $224 = ( 9060 + ( $223 << 2 ) | 0 ) ; $225 = HEAP32 [ $224 >> 2 ] | 0 ; $10 = $225 ; $226 = $10 ; $227 = ( $226 | 0 ) != ( 0 ) ; if ( $227 ) { $228 = $9 ; $229 = ( 9176 + ( $228 << 2 ) | 0 ) ; $230 = HEAP32 [ $229 >> 2 ] | 0 ; $231 = $7 ; $232 = ( ( $231 ) - ( $230 ) ) | 0 ; $7 = $232 ; $233 = $10 ; $15 = $233 ; $234 = $3 ; $235 = ( ( ( $234 ) ) + 5820 | 0 ) ; $236 = HEAP32 [ $235 >> 2 ] | 0 ; $237 = $15 ; $238 = ( 16 - ( $237 ) ) | 0 ; $239 = ( $236 | 0 ) > ( $238 | 0 ) ; $240 = $7 ; if ( $239 ) { $16 = $240 ; $241 = $16 ; $242 = $241 & 65535 ; $243 = $242 & 65535 ; $244 = $3 ; $245 = ( ( ( $244 ) ) + 5820 | 0 ) ; $246 = HEAP32 [ $245 >> 2 ] | 0 ; $247 = $243 << $246 ; $248 = $3 ; $249 = ( ( ( $248 ) ) + 5816 | 0 ) ; $250 = HEAP16 [ $249 >> 1 ] | 0 ; $251 = $250 & 65535 ; $252 = $251 | $247 ; $253 = $252 & 65535 ; HEAP16 [ $249 >> 1 ] = $253 ; $254 = $3 ; $255 = ( ( ( $254 ) ) + 5816 | 0 ) ; $256 = HEAP16 [ $255 >> 1 ] | 0 ; $257 = $256 & 65535 ; $258 = $257 & 255 ; $259 = $258 & 255 ; $260 = $3 ; $261 = ( ( ( $260 ) ) + 8 | 0 ) ; $262 = HEAP32 [ $261 >> 2 ] | 0 ; $263 = $3 ; $264 = ( ( ( $263 ) ) + 20 | 0 ) ; $265 = HEAP32 [ $264 >> 2 ] | 0 ; $266 = ( ( $265 ) + 1 ) | 0 ; HEAP32 [ $264 >> 2 ] = $266 ; $267 = ( ( $262 ) + ( $265 ) | 0 ) ; HEAP8 [ $267 >> 0 ] = $259 ; $268 = $3 ; $269 = ( ( ( $268 ) ) + 5816 | 0 ) ; $270 = HEAP16 [ $269 >> 1 ] | 0 ; $271 = $270 & 65535 ; $272 = $271 >> 8 ; $273 = $272 & 255 ; $274 = $3 ; $275 = ( ( ( $274 ) ) + 8 | 0 ) ; $276 = HEAP32 [ $275 >> 2 ] | 0 ; $277 = $3 ; $278 = ( ( ( $277 ) ) + 20 | 0 ) ; $279 = HEAP32 [ $278 >> 2 ] | 0 ; $280 = ( ( $279 ) + 1 ) | 0 ; HEAP32 [ $278 >> 2 ] = $280 ; $281 = ( ( $276 ) + ( $279 ) | 0 ) ; HEAP8 [ $281 >> 0 ] = $273 ; $282 = $16 ; $283 = $282 & 65535 ; $284 = $283 & 65535 ; $285 = $3 ; $286 = ( ( ( $285 ) ) + 5820 | 0 ) ; $287 = HEAP32 [ $286 >> 2 ] | 0 ; $288 = ( 16 - ( $287 ) ) | 0 ; $289 = $284 >> $288 ; $290 = $289 & 65535 ; $291 = $3 ; $292 = ( ( ( $291 ) ) + 5816 | 0 ) ; HEAP16 [ $292 >> 1 ] = $290 ; $293 = $15 ; $294 = ( ( $293 ) - 16 ) | 0 ; $295 = $3 ; $$sink12 = $294 ; $$sink36 = $295 ; } else { $296 = $240 & 65535 ; $297 = $296 & 65535 ; $298 = $3 ; $299 = ( ( ( $298 ) ) + 5820 | 0 ) ; $300 = HEAP32 [ $299 >> 2 ] | 0 ; $301 = $297 << $300 ; $302 = $3 ; $303 = ( ( ( $302 ) ) + 5816 | 0 ) ; $304 = HEAP16 [ $303 >> 1 ] | 0 ; $305 = $304 & 65535 ; $306 = $305 | $301 ; $307 = $306 & 65535 ; HEAP16 [ $303 >> 1 ] = $307 ; $308 = $15 ; $309 = $3 ; $$sink12 = $308 ; $$sink36 = $309 ; } $310 = ( ( ( $$sink36 ) ) + 5820 | 0 ) ; $311 = HEAP32 [ $310 >> 2 ] | 0 ; $312 = ( ( $311 ) + ( $$sink12 ) ) | 0 ; HEAP32 [ $310 >> 2 ] = $312 ; } $313 = $6 ; $314 = ( ( $313 ) + - 1 ) | 0 ; $6 = $314 ; $315 = $6 ; $316 = ( $315 >>> 0 ) < ( 256 ) ; $317 = $6 ; $318 = $317 >>> 7 ; $319 = ( 256 + ( $318 ) ) | 0 ; $$sink16 = $316 ? $317 : $319 ; $320 = ( 28760 + ( $$sink16 ) | 0 ) ; $321 = HEAP8 [ $320 >> 0 ] | 0 ; $322 = $321 & 255 ; $9 = $322 ; $323 = $5 ; $324 = $9 ; $325 = ( ( $323 ) + ( $324 << 2 ) | 0 ) ; $326 = ( ( ( $325 ) ) + 2 | 0 ) ; $327 = HEAP16 [ $326 >> 1 ] | 0 ; $328 = $327 & 65535 ; $17 = $328 ; $329 = $3 ; $330 = ( ( ( $329 ) ) + 5820 | 0 ) ; $331 = HEAP32 [ $330 >> 2 ] | 0 ; $332 = $17 ; $333 = ( 16 - ( $332 ) ) | 0 ; $334 = ( $331 | 0 ) > ( $333 | 0 ) ; $335 = $5 ; $336 = $9 ; $337 = ( ( $335 ) + ( $336 << 2 ) | 0 ) ; $338 = HEAP16 [ $337 >> 1 ] | 0 ; $339 = $338 & 65535 ; if ( $334 ) { $18 = $339 ; $340 = $18 ; $341 = $340 & 65535 ; $342 = $341 & 65535 ; $343 = $3 ; $344 = ( ( ( $343 ) ) + 5820 | 0 ) ; $345 = HEAP32 [ $344 >> 2 ] | 0 ; $346 = $342 << $345 ; $347 = $3 ; $348 = ( ( ( $347 ) ) + 5816 | 0 ) ; $349 = HEAP16 [ $348 >> 1 ] | 0 ; $350 = $349 & 65535 ; $351 = $350 | $346 ; $352 = $351 & 65535 ; HEAP16 [ $348 >> 1 ] = $352 ; $353 = $3 ; $354 = ( ( ( $353 ) ) + 5816 | 0 ) ; $355 = HEAP16 [ $354 >> 1 ] | 0 ; $356 = $355 & 65535 ; $357 = $356 & 255 ; $358 = $357 & 255 ; $359 = $3 ; $360 = ( ( ( $359 ) ) + 8 | 0 ) ; $361 = HEAP32 [ $360 >> 2 ] | 0 ; $362 = $3 ; $363 = ( ( ( $362 ) ) + 20 | 0 ) ; $364 = HEAP32 [ $363 >> 2 ] | 0 ; $365 = ( ( $364 ) + 1 ) | 0 ; HEAP32 [ $363 >> 2 ] = $365 ; $366 = ( ( $361 ) + ( $364 ) | 0 ) ; HEAP8 [ $366 >> 0 ] = $358 ; $367 = $3 ; $368 = ( ( ( $367 ) ) + 5816 | 0 ) ; $369 = HEAP16 [ $368 >> 1 ] | 0 ; $370 = $369 & 65535 ; $371 = $370 >> 8 ; $372 = $371 & 255 ; $373 = $3 ; $374 = ( ( ( $373 ) ) + 8 | 0 ) ; $375 = HEAP32 [ $374 >> 2 ] | 0 ; $376 = $3 ; $377 = ( ( ( $376 ) ) + 20 | 0 ) ; $378 = HEAP32 [ $377 >> 2 ] | 0 ; $379 = ( ( $378 ) + 1 ) | 0 ; HEAP32 [ $377 >> 2 ] = $379 ; $380 = ( ( $375 ) + ( $378 ) | 0 ) ; HEAP8 [ $380 >> 0 ] = $372 ; $381 = $18 ; $382 = $381 & 65535 ; $383 = $382 & 65535 ; $384 = $3 ; $385 = ( ( ( $384 ) ) + 5820 | 0 ) ; $386 = HEAP32 [ $385 >> 2 ] | 0 ; $387 = ( 16 - ( $386 ) ) | 0 ; $388 = $383 >> $387 ; $389 = $388 & 65535 ; $390 = $3 ; $391 = ( ( ( $390 ) ) + 5816 | 0 ) ; HEAP16 [ $391 >> 1 ] = $389 ; $392 = $17 ; $393 = ( ( $392 ) - 16 ) | 0 ; $394 = $3 ; $$sink20 = $393 ; $$sink37 = $394 ; } else { $395 = $3 ; $396 = ( ( ( $395 ) ) + 5820 | 0 ) ; $397 = HEAP32 [ $396 >> 2 ] | 0 ; $398 = $339 << $397 ; $399 = $3 ; $400 = ( ( ( $399 ) ) + 5816 | 0 ) ; $401 = HEAP16 [ $400 >> 1 ] | 0 ; $402 = $401 & 65535 ; $403 = $402 | $398 ; $404 = $403 & 65535 ; HEAP16 [ $400 >> 1 ] = $404 ; $405 = $17 ; $406 = $3 ; $$sink20 = $405 ; $$sink37 = $406 ; } $407 = ( ( ( $$sink37 ) ) + 5820 | 0 ) ; $408 = HEAP32 [ $407 >> 2 ] | 0 ; $409 = ( ( $408 ) + ( $$sink20 ) ) | 0 ; HEAP32 [ $407 >> 2 ] = $409 ; $410 = $9 ; $411 = ( 8940 + ( $410 << 2 ) | 0 ) ; $412 = HEAP32 [ $411 >> 2 ] | 0 ; $10 = $412 ; $413 = $10 ; $414 = ( $413 | 0 ) != ( 0 ) ; if ( $414 ) { $415 = $9 ; $416 = ( 9292 + ( $415 << 2 ) | 0 ) ; $417 = HEAP32 [ $416 >> 2 ] | 0 ; $418 = $6 ; $419 = ( ( $418 ) - ( $417 ) ) | 0 ; $6 = $419 ; $420 = $10 ; $19 = $420 ; $421 = $3 ; $422 = ( ( ( $421 ) ) + 5820 | 0 ) ; $423 = HEAP32 [ $422 >> 2 ] | 0 ; $424 = $19 ; $425 = ( 16 - ( $424 ) ) | 0 ; $426 = ( $423 | 0 ) > ( $425 | 0 ) ; $427 = $6 ; if ( $426 ) { $20 = $427 ; $428 = $20 ; $429 = $428 & 65535 ; $430 = $429 & 65535 ; $431 = $3 ; $432 = ( ( ( $431 ) ) + 5820 | 0 ) ; $433 = HEAP32 [ $432 >> 2 ] | 0 ; $434 = $430 << $433 ; $435 = $3 ; $436 = ( ( ( $435 ) ) + 5816 | 0 ) ; $437 = HEAP16 [ $436 >> 1 ] | 0 ; $438 = $437 & 65535 ; $439 = $438 | $434 ; $440 = $439 & 65535 ; HEAP16 [ $436 >> 1 ] = $440 ; $441 = $3 ; $442 = ( ( ( $441 ) ) + 5816 | 0 ) ; $443 = HEAP16 [ $442 >> 1 ] | 0 ; $444 = $443 & 65535 ; $445 = $444 & 255 ; $446 = $445 & 255 ; $447 = $3 ; $448 = ( ( ( $447 ) ) + 8 | 0 ) ; $449 = HEAP32 [ $448 >> 2 ] | 0 ; $450 = $3 ; $451 = ( ( ( $450 ) ) + 20 | 0 ) ; $452 = HEAP32 [ $451 >> 2 ] | 0 ; $453 = ( ( $452 ) + 1 ) | 0 ; HEAP32 [ $451 >> 2 ] = $453 ; $454 = ( ( $449 ) + ( $452 ) | 0 ) ; HEAP8 [ $454 >> 0 ] = $446 ; $455 = $3 ; $456 = ( ( ( $455 ) ) + 5816 | 0 ) ; $457 = HEAP16 [ $456 >> 1 ] | 0 ; $458 = $457 & 65535 ; $459 = $458 >> 8 ; $460 = $459 & 255 ; $461 = $3 ; $462 = ( ( ( $461 ) ) + 8 | 0 ) ; $463 = HEAP32 [ $462 >> 2 ] | 0 ; $464 = $3 ; $465 = ( ( ( $464 ) ) + 20 | 0 ) ; $466 = HEAP32 [ $465 >> 2 ] | 0 ; $467 = ( ( $466 ) + 1 ) | 0 ; HEAP32 [ $465 >> 2 ] = $467 ; $468 = ( ( $463 ) + ( $466 ) | 0 ) ; HEAP8 [ $468 >> 0 ] = $460 ; $469 = $20 ; $470 = $469 & 65535 ; $471 = $470 & 65535 ; $472 = $3 ; $473 = ( ( ( $472 ) ) + 5820 | 0 ) ; $474 = HEAP32 [ $473 >> 2 ] | 0 ; $475 = ( 16 - ( $474 ) ) | 0 ; $476 = $471 >> $475 ; $477 = $476 & 65535 ; $478 = $3 ; $479 = ( ( ( $478 ) ) + 5816 | 0 ) ; HEAP16 [ $479 >> 1 ] = $477 ; $480 = $19 ; $481 = ( ( $480 ) - 16 ) | 0 ; $482 = $3 ; $$sink3$sink = $481 ; $$sink38$sink = $482 ; label = 21 ; break ; } else { $483 = $427 & 65535 ; $484 = $483 & 65535 ; $485 = $3 ; $486 = ( ( ( $485 ) ) + 5820 | 0 ) ; $487 = HEAP32 [ $486 >> 2 ] | 0 ; $488 = $484 << $487 ; $489 = $3 ; $490 = ( ( ( $489 ) ) + 5816 | 0 ) ; $491 = HEAP16 [ $490 >> 1 ] | 0 ; $492 = $491 & 65535 ; $493 = $492 | $488 ; $494 = $493 & 65535 ; HEAP16 [ $490 >> 1 ] = $494 ; $495 = $19 ; $496 = $3 ; $$sink3$sink = $495 ; $$sink38$sink = $496 ; label = 21 ; break ; } } } } while ( 0 ) ; if ( ( label | 0 ) == 21 ) { label = 0 ; $497 = ( ( ( $$sink38$sink ) ) + 5820 | 0 ) ; $498 = HEAP32 [ $497 >> 2 ] | 0 ; $499 = ( ( $498 ) + ( $$sink3$sink ) ) | 0 ; HEAP32 [ $497 >> 2 ] = $499 ; } $500 = $8 ; $501 = $3 ; $502 = ( ( ( $501 ) ) + 5792 | 0 ) ; $503 = HEAP32 [ $502 >> 2 ] | 0 ; $504 = ( $500 >>> 0 ) < ( $503 >>> 0 ) ; if ( ! ( $504 ) ) { break ; } } } $505 = $4 ; $506 = ( ( ( $505 ) ) + 1024 | 0 ) ; $507 = ( ( ( $506 ) ) + 2 | 0 ) ; $508 = HEAP16 [ $507 >> 1 ] | 0 ; $509 = $508 & 65535 ; $21 = $509 ; $510 = $3 ; $511 = ( ( ( $510 ) ) + 5820 | 0 ) ; $512 = HEAP32 [ $511 >> 2 ] | 0 ; $513 = $21 ; $514 = ( 16 - ( $513 ) ) | 0 ; $515 = ( $512 | 0 ) > ( $514 | 0 ) ; $516 = $4 ; $517 = ( ( ( $516 ) ) + 1024 | 0 ) ; $518 = HEAP16 [ $517 >> 1 ] | 0 ; $519 = $518 & 65535 ; if ( $515 ) { $22 = $519 ; $520 = $22 ; $521 = $520 & 65535 ; $522 = $521 & 65535 ; $523 = $3 ; $524 = ( ( ( $523 ) ) + 5820 | 0 ) ; $525 = HEAP32 [ $524 >> 2 ] | 0 ; $526 = $522 << $525 ; $527 = $3 ; $528 = ( ( ( $527 ) ) + 5816 | 0 ) ; $529 = HEAP16 [ $528 >> 1 ] | 0 ; $530 = $529 & 65535 ; $531 = $530 | $526 ; $532 = $531 & 65535 ; HEAP16 [ $528 >> 1 ] = $532 ; $533 = $3 ; $534 = ( ( ( $533 ) ) + 5816 | 0 ) ; $535 = HEAP16 [ $534 >> 1 ] | 0 ; $536 = $535 & 65535 ; $537 = $536 & 255 ; $538 = $537 & 255 ; $539 = $3 ; $540 = ( ( ( $539 ) ) + 8 | 0 ) ; $541 = HEAP32 [ $540 >> 2 ] | 0 ; $542 = $3 ; $543 = ( ( ( $542 ) ) + 20 | 0 ) ; $544 = HEAP32 [ $543 >> 2 ] | 0 ; $545 = ( ( $544 ) + 1 ) | 0 ; HEAP32 [ $543 >> 2 ] = $545 ; $546 = ( ( $541 ) + ( $544 ) | 0 ) ; HEAP8 [ $546 >> 0 ] = $538 ; $547 = $3 ; $548 = ( ( ( $547 ) ) + 5816 | 0 ) ; $549 = HEAP16 [ $548 >> 1 ] | 0 ; $550 = $549 & 65535 ; $551 = $550 >> 8 ; $552 = $551 & 255 ; $553 = $3 ; $554 = ( ( ( $553 ) ) + 8 | 0 ) ; $555 = HEAP32 [ $554 >> 2 ] | 0 ; $556 = $3 ; $557 = ( ( ( $556 ) ) + 20 | 0 ) ; $558 = HEAP32 [ $557 >> 2 ] | 0 ; $559 = ( ( $558 ) + 1 ) | 0 ; HEAP32 [ $557 >> 2 ] = $559 ; $560 = ( ( $555 ) + ( $558 ) | 0 ) ; HEAP8 [ $560 >> 0 ] = $552 ; $561 = $22 ; $562 = $561 & 65535 ; $563 = $562 & 65535 ; $564 = $3 ; $565 = ( ( ( $564 ) ) + 5820 | 0 ) ; $566 = HEAP32 [ $565 >> 2 ] | 0 ; $567 = ( 16 - ( $566 ) ) | 0 ; $568 = $563 >> $567 ; $569 = $568 & 65535 ; $570 = $3 ; $571 = ( ( ( $570 ) ) + 5816 | 0 ) ; HEAP16 [ $571 >> 1 ] = $569 ; $572 = $21 ; $573 = ( ( $572 ) - 16 ) | 0 ; $574 = $3 ; $$sink30 = $573 ; $$sink39 = $574 ; $587 = ( ( ( $$sink39 ) ) + 5820 | 0 ) ; $588 = HEAP32 [ $587 >> 2 ] | 0 ; $589 = ( ( $588 ) + ( $$sink30 ) ) | 0 ; HEAP32 [ $587 >> 2 ] = $589 ; STACKTOP = sp ; return ; } else { $575 = $3 ; $576 = ( ( ( $575 ) ) + 5820 | 0 ) ; $577 = HEAP32 [ $576 >> 2 ] | 0 ; $578 = $519 << $577 ; $579 = $3 ; $580 = ( ( ( $579 ) ) + 5816 | 0 ) ; $581 = HEAP16 [ $580 >> 1 ] | 0 ; $582 = $581 & 65535 ; $583 = $582 | $578 ; $584 = $583 & 65535 ; HEAP16 [ $580 >> 1 ] = $584 ; $585 = $21 ; $586 = $3 ; $$sink30 = $585 ; $$sink39 = $586 ; $587 = ( ( ( $$sink39 ) ) + 5820 | 0 ) ; $588 = HEAP32 [ $587 >> 2 ] | 0 ; $589 = ( ( $588 ) + ( $$sink30 ) ) | 0 ; HEAP32 [ $587 >> 2 ] = $589 ; STACKTOP = sp ; return ; } } function _send_all_trees ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $$sink = 0 , $$sink12 = 0 , $$sink17 = 0 , $$sink19 = 0 , $$sink20 = 0 , $$sink21 = 0 , $$sink3 = 0 , $$sink7 = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 ; var $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 ; var $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 ; var $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 ; var $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 , $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 ; var $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 , $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $20 = 0 , $200 = 0 ; var $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 , $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 ; var $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 , $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 ; var $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 , $244 = 0 , $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 ; var $256 = 0 , $257 = 0 , $258 = 0 , $259 = 0 , $26 = 0 , $260 = 0 , $261 = 0 , $262 = 0 , $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 , $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 , $270 = 0 , $271 = 0 , $272 = 0 , $273 = 0 ; var $274 = 0 , $275 = 0 , $276 = 0 , $277 = 0 , $278 = 0 , $279 = 0 , $28 = 0 , $280 = 0 , $281 = 0 , $282 = 0 , $283 = 0 , $284 = 0 , $285 = 0 , $286 = 0 , $287 = 0 , $288 = 0 , $289 = 0 , $29 = 0 , $290 = 0 , $291 = 0 ; var $292 = 0 , $293 = 0 , $294 = 0 , $295 = 0 , $296 = 0 , $297 = 0 , $298 = 0 , $299 = 0 , $30 = 0 , $300 = 0 , $301 = 0 , $302 = 0 , $303 = 0 , $304 = 0 , $305 = 0 , $306 = 0 , $307 = 0 , $308 = 0 , $309 = 0 , $31 = 0 ; var $310 = 0 , $311 = 0 , $312 = 0 , $313 = 0 , $314 = 0 , $315 = 0 , $316 = 0 , $317 = 0 , $318 = 0 , $319 = 0 , $32 = 0 , $320 = 0 , $321 = 0 , $322 = 0 , $323 = 0 , $324 = 0 , $325 = 0 , $326 = 0 , $327 = 0 , $328 = 0 ; var $329 = 0 , $33 = 0 , $330 = 0 , $331 = 0 , $332 = 0 , $333 = 0 , $334 = 0 , $335 = 0 , $336 = 0 , $337 = 0 , $338 = 0 , $339 = 0 , $34 = 0 , $340 = 0 , $341 = 0 , $342 = 0 , $343 = 0 , $344 = 0 , $345 = 0 , $346 = 0 ; var $347 = 0 , $348 = 0 , $349 = 0 , $35 = 0 , $350 = 0 , $351 = 0 , $352 = 0 , $353 = 0 , $354 = 0 , $355 = 0 , $356 = 0 , $357 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 ; var $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 ; var $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 ; var $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 ; var $98 = 0 , $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 64 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 64 | 0 ) ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $7 = $3 ; $9 = 5 ; $17 = $4 ; $18 = ( ( ( $17 ) ) + 5820 | 0 ) ; $19 = HEAP32 [ $18 >> 2 ] | 0 ; $20 = $9 ; $21 = ( 16 - ( $20 ) ) | 0 ; $22 = ( $19 | 0 ) > ( $21 | 0 ) ; $23 = $5 ; $24 = ( ( $23 ) - 257 ) | 0 ; if ( $22 ) { $10 = $24 ; $25 = $10 ; $26 = $25 & 65535 ; $27 = $26 & 65535 ; $28 = $4 ; $29 = ( ( ( $28 ) ) + 5820 | 0 ) ; $30 = HEAP32 [ $29 >> 2 ] | 0 ; $31 = $27 << $30 ; $32 = $4 ; $33 = ( ( ( $32 ) ) + 5816 | 0 ) ; $34 = HEAP16 [ $33 >> 1 ] | 0 ; $35 = $34 & 65535 ; $36 = $35 | $31 ; $37 = $36 & 65535 ; HEAP16 [ $33 >> 1 ] = $37 ; $38 = $4 ; $39 = ( ( ( $38 ) ) + 5816 | 0 ) ; $40 = HEAP16 [ $39 >> 1 ] | 0 ; $41 = $40 & 65535 ; $42 = $41 & 255 ; $43 = $42 & 255 ; $44 = $4 ; $45 = ( ( ( $44 ) ) + 8 | 0 ) ; $46 = HEAP32 [ $45 >> 2 ] | 0 ; $47 = $4 ; $48 = ( ( ( $47 ) ) + 20 | 0 ) ; $49 = HEAP32 [ $48 >> 2 ] | 0 ; $50 = ( ( $49 ) + 1 ) | 0 ; HEAP32 [ $48 >> 2 ] = $50 ; $51 = ( ( $46 ) + ( $49 ) | 0 ) ; HEAP8 [ $51 >> 0 ] = $43 ; $52 = $4 ; $53 = ( ( ( $52 ) ) + 5816 | 0 ) ; $54 = HEAP16 [ $53 >> 1 ] | 0 ; $55 = $54 & 65535 ; $56 = $55 >> 8 ; $57 = $56 & 255 ; $58 = $4 ; $59 = ( ( ( $58 ) ) + 8 | 0 ) ; $60 = HEAP32 [ $59 >> 2 ] | 0 ; $61 = $4 ; $62 = ( ( ( $61 ) ) + 20 | 0 ) ; $63 = HEAP32 [ $62 >> 2 ] | 0 ; $64 = ( ( $63 ) + 1 ) | 0 ; HEAP32 [ $62 >> 2 ] = $64 ; $65 = ( ( $60 ) + ( $63 ) | 0 ) ; HEAP8 [ $65 >> 0 ] = $57 ; $66 = $10 ; $67 = $66 & 65535 ; $68 = $67 & 65535 ; $69 = $4 ; $70 = ( ( ( $69 ) ) + 5820 | 0 ) ; $71 = HEAP32 [ $70 >> 2 ] | 0 ; $72 = ( 16 - ( $71 ) ) | 0 ; $73 = $68 >> $72 ; $74 = $73 & 65535 ; $75 = $4 ; $76 = ( ( ( $75 ) ) + 5816 | 0 ) ; HEAP16 [ $76 >> 1 ] = $74 ; $77 = $9 ; $78 = ( ( $77 ) - 16 ) | 0 ; $79 = $4 ; $$sink19 = $79 ; $$sink3 = $78 ; } else { $80 = $24 & 65535 ; $81 = $80 & 65535 ; $82 = $4 ; $83 = ( ( ( $82 ) ) + 5820 | 0 ) ; $84 = HEAP32 [ $83 >> 2 ] | 0 ; $85 = $81 << $84 ; $86 = $4 ; $87 = ( ( ( $86 ) ) + 5816 | 0 ) ; $88 = HEAP16 [ $87 >> 1 ] | 0 ; $89 = $88 & 65535 ; $90 = $89 | $85 ; $91 = $90 & 65535 ; HEAP16 [ $87 >> 1 ] = $91 ; $92 = $9 ; $93 = $4 ; $$sink19 = $93 ; $$sink3 = $92 ; } $94 = ( ( ( $$sink19 ) ) + 5820 | 0 ) ; $95 = HEAP32 [ $94 >> 2 ] | 0 ; $96 = ( ( $95 ) + ( $$sink3 ) ) | 0 ; HEAP32 [ $94 >> 2 ] = $96 ; $11 = 5 ; $97 = $4 ; $98 = ( ( ( $97 ) ) + 5820 | 0 ) ; $99 = HEAP32 [ $98 >> 2 ] | 0 ; $100 = $11 ; $101 = ( 16 - ( $100 ) ) | 0 ; $102 = ( $99 | 0 ) > ( $101 | 0 ) ; $103 = $6 ; $104 = ( ( $103 ) - 1 ) | 0 ; if ( $102 ) { $12 = $104 ; $105 = $12 ; $106 = $105 & 65535 ; $107 = $106 & 65535 ; $108 = $4 ; $109 = ( ( ( $108 ) ) + 5820 | 0 ) ; $110 = HEAP32 [ $109 >> 2 ] | 0 ; $111 = $107 << $110 ; $112 = $4 ; $113 = ( ( ( $112 ) ) + 5816 | 0 ) ; $114 = HEAP16 [ $113 >> 1 ] | 0 ; $115 = $114 & 65535 ; $116 = $115 | $111 ; $117 = $116 & 65535 ; HEAP16 [ $113 >> 1 ] = $117 ; $118 = $4 ; $119 = ( ( ( $118 ) ) + 5816 | 0 ) ; $120 = HEAP16 [ $119 >> 1 ] | 0 ; $121 = $120 & 65535 ; $122 = $121 & 255 ; $123 = $122 & 255 ; $124 = $4 ; $125 = ( ( ( $124 ) ) + 8 | 0 ) ; $126 = HEAP32 [ $125 >> 2 ] | 0 ; $127 = $4 ; $128 = ( ( ( $127 ) ) + 20 | 0 ) ; $129 = HEAP32 [ $128 >> 2 ] | 0 ; $130 = ( ( $129 ) + 1 ) | 0 ; HEAP32 [ $128 >> 2 ] = $130 ; $131 = ( ( $126 ) + ( $129 ) | 0 ) ; HEAP8 [ $131 >> 0 ] = $123 ; $132 = $4 ; $133 = ( ( ( $132 ) ) + 5816 | 0 ) ; $134 = HEAP16 [ $133 >> 1 ] | 0 ; $135 = $134 & 65535 ; $136 = $135 >> 8 ; $137 = $136 & 255 ; $138 = $4 ; $139 = ( ( ( $138 ) ) + 8 | 0 ) ; $140 = HEAP32 [ $139 >> 2 ] | 0 ; $141 = $4 ; $142 = ( ( ( $141 ) ) + 20 | 0 ) ; $143 = HEAP32 [ $142 >> 2 ] | 0 ; $144 = ( ( $143 ) + 1 ) | 0 ; HEAP32 [ $142 >> 2 ] = $144 ; $145 = ( ( $140 ) + ( $143 ) | 0 ) ; HEAP8 [ $145 >> 0 ] = $137 ; $146 = $12 ; $147 = $146 & 65535 ; $148 = $147 & 65535 ; $149 = $4 ; $150 = ( ( ( $149 ) ) + 5820 | 0 ) ; $151 = HEAP32 [ $150 >> 2 ] | 0 ; $152 = ( 16 - ( $151 ) ) | 0 ; $153 = $148 >> $152 ; $154 = $153 & 65535 ; $155 = $4 ; $156 = ( ( ( $155 ) ) + 5816 | 0 ) ; HEAP16 [ $156 >> 1 ] = $154 ; $157 = $11 ; $158 = ( ( $157 ) - 16 ) | 0 ; $159 = $4 ; $$sink = $159 ; $$sink7 = $158 ; } else { $160 = $104 & 65535 ; $161 = $160 & 65535 ; $162 = $4 ; $163 = ( ( ( $162 ) ) + 5820 | 0 ) ; $164 = HEAP32 [ $163 >> 2 ] | 0 ; $165 = $161 << $164 ; $166 = $4 ; $167 = ( ( ( $166 ) ) + 5816 | 0 ) ; $168 = HEAP16 [ $167 >> 1 ] | 0 ; $169 = $168 & 65535 ; $170 = $169 | $165 ; $171 = $170 & 65535 ; HEAP16 [ $167 >> 1 ] = $171 ; $172 = $11 ; $173 = $4 ; $$sink = $173 ; $$sink7 = $172 ; } $174 = ( ( ( $$sink ) ) + 5820 | 0 ) ; $175 = HEAP32 [ $174 >> 2 ] | 0 ; $176 = ( ( $175 ) + ( $$sink7 ) ) | 0 ; HEAP32 [ $174 >> 2 ] = $176 ; $13 = 4 ; $177 = $4 ; $178 = ( ( ( $177 ) ) + 5820 | 0 ) ; $179 = HEAP32 [ $178 >> 2 ] | 0 ; $180 = $13 ; $181 = ( 16 - ( $180 ) ) | 0 ; $182 = ( $179 | 0 ) > ( $181 | 0 ) ; $183 = $7 ; $184 = ( ( $183 ) - 4 ) | 0 ; if ( $182 ) { $14 = $184 ; $185 = $14 ; $186 = $185 & 65535 ; $187 = $186 & 65535 ; $188 = $4 ; $189 = ( ( ( $188 ) ) + 5820 | 0 ) ; $190 = HEAP32 [ $189 >> 2 ] | 0 ; $191 = $187 << $190 ; $192 = $4 ; $193 = ( ( ( $192 ) ) + 5816 | 0 ) ; $194 = HEAP16 [ $193 >> 1 ] | 0 ; $195 = $194 & 65535 ; $196 = $195 | $191 ; $197 = $196 & 65535 ; HEAP16 [ $193 >> 1 ] = $197 ; $198 = $4 ; $199 = ( ( ( $198 ) ) + 5816 | 0 ) ; $200 = HEAP16 [ $199 >> 1 ] | 0 ; $201 = $200 & 65535 ; $202 = $201 & 255 ; $203 = $202 & 255 ; $204 = $4 ; $205 = ( ( ( $204 ) ) + 8 | 0 ) ; $206 = HEAP32 [ $205 >> 2 ] | 0 ; $207 = $4 ; $208 = ( ( ( $207 ) ) + 20 | 0 ) ; $209 = HEAP32 [ $208 >> 2 ] | 0 ; $210 = ( ( $209 ) + 1 ) | 0 ; HEAP32 [ $208 >> 2 ] = $210 ; $211 = ( ( $206 ) + ( $209 ) | 0 ) ; HEAP8 [ $211 >> 0 ] = $203 ; $212 = $4 ; $213 = ( ( ( $212 ) ) + 5816 | 0 ) ; $214 = HEAP16 [ $213 >> 1 ] | 0 ; $215 = $214 & 65535 ; $216 = $215 >> 8 ; $217 = $216 & 255 ; $218 = $4 ; $219 = ( ( ( $218 ) ) + 8 | 0 ) ; $220 = HEAP32 [ $219 >> 2 ] | 0 ; $221 = $4 ; $222 = ( ( ( $221 ) ) + 20 | 0 ) ; $223 = HEAP32 [ $222 >> 2 ] | 0 ; $224 = ( ( $223 ) + 1 ) | 0 ; HEAP32 [ $222 >> 2 ] = $224 ; $225 = ( ( $220 ) + ( $223 ) | 0 ) ; HEAP8 [ $225 >> 0 ] = $217 ; $226 = $14 ; $227 = $226 & 65535 ; $228 = $227 & 65535 ; $229 = $4 ; $230 = ( ( ( $229 ) ) + 5820 | 0 ) ; $231 = HEAP32 [ $230 >> 2 ] | 0 ; $232 = ( 16 - ( $231 ) ) | 0 ; $233 = $228 >> $232 ; $234 = $233 & 65535 ; $235 = $4 ; $236 = ( ( ( $235 ) ) + 5816 | 0 ) ; HEAP16 [ $236 >> 1 ] = $234 ; $237 = $13 ; $238 = ( ( $237 ) - 16 ) | 0 ; $239 = $4 ; $$sink12 = $238 ; $$sink20 = $239 ; } else { $240 = $184 & 65535 ; $241 = $240 & 65535 ; $242 = $4 ; $243 = ( ( ( $242 ) ) + 5820 | 0 ) ; $244 = HEAP32 [ $243 >> 2 ] | 0 ; $245 = $241 << $244 ; $246 = $4 ; $247 = ( ( ( $246 ) ) + 5816 | 0 ) ; $248 = HEAP16 [ $247 >> 1 ] | 0 ; $249 = $248 & 65535 ; $250 = $249 | $245 ; $251 = $250 & 65535 ; HEAP16 [ $247 >> 1 ] = $251 ; $252 = $13 ; $253 = $4 ; $$sink12 = $252 ; $$sink20 = $253 ; } $254 = ( ( ( $$sink20 ) ) + 5820 | 0 ) ; $255 = HEAP32 [ $254 >> 2 ] | 0 ; $256 = ( ( $255 ) + ( $$sink12 ) ) | 0 ; HEAP32 [ $254 >> 2 ] = $256 ; $8 = 0 ; while ( 1 ) { $257 = $8 ; $258 = $7 ; $259 = ( $257 | 0 ) < ( $258 | 0 ) ; if ( ! ( $259 ) ) { break ; } $15 = 3 ; $260 = $4 ; $261 = ( ( ( $260 ) ) + 5820 | 0 ) ; $262 = HEAP32 [ $261 >> 2 ] | 0 ; $263 = $15 ; $264 = ( 16 - ( $263 ) ) | 0 ; $265 = ( $262 | 0 ) > ( $264 | 0 ) ; $266 = $4 ; $267 = ( ( ( $266 ) ) + 2684 | 0 ) ; $268 = $8 ; $269 = ( 29528 + ( $268 ) | 0 ) ; $270 = HEAP8 [ $269 >> 0 ] | 0 ; $271 = $270 & 255 ; $272 = ( ( $267 ) + ( $271 << 2 ) | 0 ) ; $273 = ( ( ( $272 ) ) + 2 | 0 ) ; $274 = HEAP16 [ $273 >> 1 ] | 0 ; $275 = $274 & 65535 ; if ( $265 ) { $16 = $275 ; $276 = $16 ; $277 = $276 & 65535 ; $278 = $277 & 65535 ; $279 = $4 ; $280 = ( ( ( $279 ) ) + 5820 | 0 ) ; $281 = HEAP32 [ $280 >> 2 ] | 0 ; $282 = $278 << $281 ; $283 = $4 ; $284 = ( ( ( $283 ) ) + 5816 | 0 ) ; $285 = HEAP16 [ $284 >> 1 ] | 0 ; $286 = $285 & 65535 ; $287 = $286 | $282 ; $288 = $287 & 65535 ; HEAP16 [ $284 >> 1 ] = $288 ; $289 = $4 ; $290 = ( ( ( $289 ) ) + 5816 | 0 ) ; $291 = HEAP16 [ $290 >> 1 ] | 0 ; $292 = $291 & 65535 ; $293 = $292 & 255 ; $294 = $293 & 255 ; $295 = $4 ; $296 = ( ( ( $295 ) ) + 8 | 0 ) ; $297 = HEAP32 [ $296 >> 2 ] | 0 ; $298 = $4 ; $299 = ( ( ( $298 ) ) + 20 | 0 ) ; $300 = HEAP32 [ $299 >> 2 ] | 0 ; $301 = ( ( $300 ) + 1 ) | 0 ; HEAP32 [ $299 >> 2 ] = $301 ; $302 = ( ( $297 ) + ( $300 ) | 0 ) ; HEAP8 [ $302 >> 0 ] = $294 ; $303 = $4 ; $304 = ( ( ( $303 ) ) + 5816 | 0 ) ; $305 = HEAP16 [ $304 >> 1 ] | 0 ; $306 = $305 & 65535 ; $307 = $306 >> 8 ; $308 = $307 & 255 ; $309 = $4 ; $310 = ( ( ( $309 ) ) + 8 | 0 ) ; $311 = HEAP32 [ $310 >> 2 ] | 0 ; $312 = $4 ; $313 = ( ( ( $312 ) ) + 20 | 0 ) ; $314 = HEAP32 [ $313 >> 2 ] | 0 ; $315 = ( ( $314 ) + 1 ) | 0 ; HEAP32 [ $313 >> 2 ] = $315 ; $316 = ( ( $311 ) + ( $314 ) | 0 ) ; HEAP8 [ $316 >> 0 ] = $308 ; $317 = $16 ; $318 = $317 & 65535 ; $319 = $318 & 65535 ; $320 = $4 ; $321 = ( ( ( $320 ) ) + 5820 | 0 ) ; $322 = HEAP32 [ $321 >> 2 ] | 0 ; $323 = ( 16 - ( $322 ) ) | 0 ; $324 = $319 >> $323 ; $325 = $324 & 65535 ; $326 = $4 ; $327 = ( ( ( $326 ) ) + 5816 | 0 ) ; HEAP16 [ $327 >> 1 ] = $325 ; $328 = $15 ; $329 = ( ( $328 ) - 16 ) | 0 ; $330 = $4 ; $$sink17 = $329 ; $$sink21 = $330 ; } else { $331 = $4 ; $332 = ( ( ( $331 ) ) + 5820 | 0 ) ; $333 = HEAP32 [ $332 >> 2 ] | 0 ; $334 = $275 << $333 ; $335 = $4 ; $336 = ( ( ( $335 ) ) + 5816 | 0 ) ; $337 = HEAP16 [ $336 >> 1 ] | 0 ; $338 = $337 & 65535 ; $339 = $338 | $334 ; $340 = $339 & 65535 ; HEAP16 [ $336 >> 1 ] = $340 ; $341 = $15 ; $342 = $4 ; $$sink17 = $341 ; $$sink21 = $342 ; } $343 = ( ( ( $$sink21 ) ) + 5820 | 0 ) ; $344 = HEAP32 [ $343 >> 2 ] | 0 ; $345 = ( ( $344 ) + ( $$sink17 ) ) | 0 ; HEAP32 [ $343 >> 2 ] = $345 ; $346 = $8 ; $347 = ( ( $346 ) + 1 ) | 0 ; $8 = $347 ; } $348 = $4 ; $349 = $4 ; $350 = ( ( ( $349 ) ) + 148 | 0 ) ; $351 = $5 ; $352 = ( ( $351 ) - 1 ) | 0 ; _send_tree ( $348 , $350 , $352 ) ; $353 = $4 ; $354 = $4 ; $355 = ( ( ( $354 ) ) + 2440 | 0 ) ; $356 = $6 ; $357 = ( ( $356 ) - 1 ) | 0 ; _send_tree ( $353 , $355 , $357 ) ; STACKTOP = sp ; return ; } function _send_tree ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$sink = 0 , $$sink12 = 0 , $$sink22 = 0 , $$sink3 = 0 , $$sink32 = 0 , $$sink37$sink$sink = 0 , $$sink45 = 0 , $$sink46 = 0 , $$sink48 = 0 , $$sink50 = 0 , $$sink51$sink$sink = 0 , $$sink7 = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 ; var $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 ; var $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 ; var $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 ; var $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 , $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 ; var $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 , $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 ; var $198 = 0 , $199 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 , $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 ; var $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 , $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 ; var $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 , $244 = 0 , $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 ; var $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 , $258 = 0 , $259 = 0 , $26 = 0 , $260 = 0 , $261 = 0 , $262 = 0 , $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 , $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 ; var $270 = 0 , $271 = 0 , $272 = 0 , $273 = 0 , $274 = 0 , $275 = 0 , $276 = 0 , $277 = 0 , $278 = 0 , $279 = 0 , $28 = 0 , $280 = 0 , $281 = 0 , $282 = 0 , $283 = 0 , $284 = 0 , $285 = 0 , $286 = 0 , $287 = 0 , $288 = 0 ; var $289 = 0 , $29 = 0 , $290 = 0 , $291 = 0 , $292 = 0 , $293 = 0 , $294 = 0 , $295 = 0 , $296 = 0 , $297 = 0 , $298 = 0 , $299 = 0 , $3 = 0 , $30 = 0 , $300 = 0 , $301 = 0 , $302 = 0 , $303 = 0 , $304 = 0 , $305 = 0 ; var $306 = 0 , $307 = 0 , $308 = 0 , $309 = 0 , $31 = 0 , $310 = 0 , $311 = 0 , $312 = 0 , $313 = 0 , $314 = 0 , $315 = 0 , $316 = 0 , $317 = 0 , $318 = 0 , $319 = 0 , $32 = 0 , $320 = 0 , $321 = 0 , $322 = 0 , $323 = 0 ; var $324 = 0 , $325 = 0 , $326 = 0 , $327 = 0 , $328 = 0 , $329 = 0 , $33 = 0 , $330 = 0 , $331 = 0 , $332 = 0 , $333 = 0 , $334 = 0 , $335 = 0 , $336 = 0 , $337 = 0 , $338 = 0 , $339 = 0 , $34 = 0 , $340 = 0 , $341 = 0 ; var $342 = 0 , $343 = 0 , $344 = 0 , $345 = 0 , $346 = 0 , $347 = 0 , $348 = 0 , $349 = 0 , $35 = 0 , $350 = 0 , $351 = 0 , $352 = 0 , $353 = 0 , $354 = 0 , $355 = 0 , $356 = 0 , $357 = 0 , $358 = 0 , $359 = 0 , $36 = 0 ; var $360 = 0 , $361 = 0 , $362 = 0 , $363 = 0 , $364 = 0 , $365 = 0 , $366 = 0 , $367 = 0 , $368 = 0 , $369 = 0 , $37 = 0 , $370 = 0 , $371 = 0 , $372 = 0 , $373 = 0 , $374 = 0 , $375 = 0 , $376 = 0 , $377 = 0 , $378 = 0 ; var $379 = 0 , $38 = 0 , $380 = 0 , $381 = 0 , $382 = 0 , $383 = 0 , $384 = 0 , $385 = 0 , $386 = 0 , $387 = 0 , $388 = 0 , $389 = 0 , $39 = 0 , $390 = 0 , $391 = 0 , $392 = 0 , $393 = 0 , $394 = 0 , $395 = 0 , $396 = 0 ; var $397 = 0 , $398 = 0 , $399 = 0 , $4 = 0 , $40 = 0 , $400 = 0 , $401 = 0 , $402 = 0 , $403 = 0 , $404 = 0 , $405 = 0 , $406 = 0 , $407 = 0 , $408 = 0 , $409 = 0 , $41 = 0 , $410 = 0 , $411 = 0 , $412 = 0 , $413 = 0 ; var $414 = 0 , $415 = 0 , $416 = 0 , $417 = 0 , $418 = 0 , $419 = 0 , $42 = 0 , $420 = 0 , $421 = 0 , $422 = 0 , $423 = 0 , $424 = 0 , $425 = 0 , $426 = 0 , $427 = 0 , $428 = 0 , $429 = 0 , $43 = 0 , $430 = 0 , $431 = 0 ; var $432 = 0 , $433 = 0 , $434 = 0 , $435 = 0 , $436 = 0 , $437 = 0 , $438 = 0 , $439 = 0 , $44 = 0 , $440 = 0 , $441 = 0 , $442 = 0 , $443 = 0 , $444 = 0 , $445 = 0 , $446 = 0 , $447 = 0 , $448 = 0 , $449 = 0 , $45 = 0 ; var $450 = 0 , $451 = 0 , $452 = 0 , $453 = 0 , $454 = 0 , $455 = 0 , $456 = 0 , $457 = 0 , $458 = 0 , $459 = 0 , $46 = 0 , $460 = 0 , $461 = 0 , $462 = 0 , $463 = 0 , $464 = 0 , $465 = 0 , $466 = 0 , $467 = 0 , $468 = 0 ; var $469 = 0 , $47 = 0 , $470 = 0 , $471 = 0 , $472 = 0 , $473 = 0 , $474 = 0 , $475 = 0 , $476 = 0 , $477 = 0 , $478 = 0 , $479 = 0 , $48 = 0 , $480 = 0 , $481 = 0 , $482 = 0 , $483 = 0 , $484 = 0 , $485 = 0 , $486 = 0 ; var $487 = 0 , $488 = 0 , $489 = 0 , $49 = 0 , $490 = 0 , $491 = 0 , $492 = 0 , $493 = 0 , $494 = 0 , $495 = 0 , $496 = 0 , $497 = 0 , $498 = 0 , $499 = 0 , $5 = 0 , $50 = 0 , $500 = 0 , $501 = 0 , $502 = 0 , $503 = 0 ; var $504 = 0 , $505 = 0 , $506 = 0 , $507 = 0 , $508 = 0 , $509 = 0 , $51 = 0 , $510 = 0 , $511 = 0 , $512 = 0 , $513 = 0 , $514 = 0 , $515 = 0 , $516 = 0 , $517 = 0 , $518 = 0 , $519 = 0 , $52 = 0 , $520 = 0 , $521 = 0 ; var $522 = 0 , $523 = 0 , $524 = 0 , $525 = 0 , $526 = 0 , $527 = 0 , $528 = 0 , $529 = 0 , $53 = 0 , $530 = 0 , $531 = 0 , $532 = 0 , $533 = 0 , $534 = 0 , $535 = 0 , $536 = 0 , $537 = 0 , $538 = 0 , $539 = 0 , $54 = 0 ; var $540 = 0 , $541 = 0 , $542 = 0 , $543 = 0 , $544 = 0 , $545 = 0 , $546 = 0 , $547 = 0 , $548 = 0 , $549 = 0 , $55 = 0 , $550 = 0 , $551 = 0 , $552 = 0 , $553 = 0 , $554 = 0 , $555 = 0 , $556 = 0 , $557 = 0 , $558 = 0 ; var $559 = 0 , $56 = 0 , $560 = 0 , $561 = 0 , $562 = 0 , $563 = 0 , $564 = 0 , $565 = 0 , $566 = 0 , $567 = 0 , $568 = 0 , $569 = 0 , $57 = 0 , $570 = 0 , $571 = 0 , $572 = 0 , $573 = 0 , $574 = 0 , $575 = 0 , $576 = 0 ; var $577 = 0 , $578 = 0 , $579 = 0 , $58 = 0 , $580 = 0 , $581 = 0 , $582 = 0 , $583 = 0 , $584 = 0 , $585 = 0 , $586 = 0 , $587 = 0 , $588 = 0 , $589 = 0 , $59 = 0 , $590 = 0 , $591 = 0 , $592 = 0 , $593 = 0 , $594 = 0 ; var $595 = 0 , $596 = 0 , $597 = 0 , $598 = 0 , $599 = 0 , $6 = 0 , $60 = 0 , $600 = 0 , $601 = 0 , $602 = 0 , $603 = 0 , $604 = 0 , $605 = 0 , $606 = 0 , $607 = 0 , $608 = 0 , $609 = 0 , $61 = 0 , $610 = 0 , $611 = 0 ; var $612 = 0 , $613 = 0 , $614 = 0 , $615 = 0 , $616 = 0 , $617 = 0 , $618 = 0 , $619 = 0 , $62 = 0 , $620 = 0 , $621 = 0 , $622 = 0 , $623 = 0 , $624 = 0 , $625 = 0 , $626 = 0 , $627 = 0 , $628 = 0 , $629 = 0 , $63 = 0 ; var $630 = 0 , $631 = 0 , $632 = 0 , $633 = 0 , $634 = 0 , $635 = 0 , $636 = 0 , $637 = 0 , $638 = 0 , $639 = 0 , $64 = 0 , $640 = 0 , $641 = 0 , $642 = 0 , $643 = 0 , $644 = 0 , $645 = 0 , $646 = 0 , $647 = 0 , $648 = 0 ; var $649 = 0 , $65 = 0 , $650 = 0 , $651 = 0 , $652 = 0 , $653 = 0 , $654 = 0 , $655 = 0 , $656 = 0 , $657 = 0 , $658 = 0 , $659 = 0 , $66 = 0 , $660 = 0 , $661 = 0 , $662 = 0 , $663 = 0 , $664 = 0 , $665 = 0 , $666 = 0 ; var $667 = 0 , $668 = 0 , $669 = 0 , $67 = 0 , $670 = 0 , $671 = 0 , $672 = 0 , $673 = 0 , $674 = 0 , $675 = 0 , $676 = 0 , $677 = 0 , $678 = 0 , $679 = 0 , $68 = 0 , $680 = 0 , $681 = 0 , $682 = 0 , $683 = 0 , $684 = 0 ; var $685 = 0 , $686 = 0 , $687 = 0 , $688 = 0 , $689 = 0 , $69 = 0 , $690 = 0 , $691 = 0 , $692 = 0 , $693 = 0 , $694 = 0 , $695 = 0 , $696 = 0 , $697 = 0 , $698 = 0 , $699 = 0 , $7 = 0 , $70 = 0 , $700 = 0 , $701 = 0 ; var $702 = 0 , $703 = 0 , $704 = 0 , $705 = 0 , $706 = 0 , $707 = 0 , $708 = 0 , $709 = 0 , $71 = 0 , $710 = 0 , $711 = 0 , $712 = 0 , $713 = 0 , $714 = 0 , $715 = 0 , $716 = 0 , $717 = 0 , $718 = 0 , $719 = 0 , $72 = 0 ; var $720 = 0 , $721 = 0 , $722 = 0 , $723 = 0 , $724 = 0 , $725 = 0 , $726 = 0 , $727 = 0 , $728 = 0 , $729 = 0 , $73 = 0 , $730 = 0 , $731 = 0 , $732 = 0 , $733 = 0 , $734 = 0 , $735 = 0 , $736 = 0 , $737 = 0 , $738 = 0 ; var $739 = 0 , $74 = 0 , $740 = 0 , $741 = 0 , $742 = 0 , $743 = 0 , $744 = 0 , $745 = 0 , $746 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 ; var $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 112 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 112 | 0 ) ; $3 = $0 ; $4 = $1 ; $5 = $2 ; $7 = - 1 ; $29 = $4 ; $30 = ( ( ( $29 ) ) + 2 | 0 ) ; $31 = HEAP16 [ $30 >> 1 ] | 0 ; $32 = $31 & 65535 ; $9 = $32 ; $10 = 0 ; $11 = 7 ; $12 = 4 ; $33 = $9 ; $34 = ( $33 | 0 ) == ( 0 ) ; if ( $34 ) { $11 = 138 ; $12 = 3 ; } $6 = 0 ; while ( 1 ) { $35 = $6 ; $36 = $5 ; $37 = ( $35 | 0 ) <= ( $36 | 0 ) ; if ( ! ( $37 ) ) { break ; } $38 = $9 ; $8 = $38 ; $39 = $4 ; $40 = $6 ; $41 = ( ( $40 ) + 1 ) | 0 ; $42 = ( ( $39 ) + ( $41 << 2 ) | 0 ) ; $43 = ( ( ( $42 ) ) + 2 | 0 ) ; $44 = HEAP16 [ $43 >> 1 ] | 0 ; $45 = $44 & 65535 ; $9 = $45 ; $46 = $10 ; $47 = ( ( $46 ) + 1 ) | 0 ; $10 = $47 ; $48 = $11 ; $49 = ( $47 | 0 ) < ( $48 | 0 ) ; if ( $49 ) { $50 = $8 ; $51 = $9 ; $52 = ( $50 | 0 ) == ( $51 | 0 ) ; if ( ! ( $52 ) ) { label = 7 ; } } else { label = 7 ; } do { if ( ( label | 0 ) == 7 ) { label = 0 ; $53 = $10 ; $54 = $12 ; $55 = ( $53 | 0 ) < ( $54 | 0 ) ; if ( $55 ) { while ( 1 ) { $56 = $3 ; $57 = ( ( ( $56 ) ) + 2684 | 0 ) ; $58 = $8 ; $59 = ( ( $57 ) + ( $58 << 2 ) | 0 ) ; $60 = ( ( ( $59 ) ) + 2 | 0 ) ; $61 = HEAP16 [ $60 >> 1 ] | 0 ; $62 = $61 & 65535 ; $13 = $62 ; $63 = $3 ; $64 = ( ( ( $63 ) ) + 5820 | 0 ) ; $65 = HEAP32 [ $64 >> 2 ] | 0 ; $66 = $13 ; $67 = ( 16 - ( $66 ) ) | 0 ; $68 = ( $65 | 0 ) > ( $67 | 0 ) ; $69 = $3 ; $70 = ( ( ( $69 ) ) + 2684 | 0 ) ; $71 = $8 ; $72 = ( ( $70 ) + ( $71 << 2 ) | 0 ) ; $73 = HEAP16 [ $72 >> 1 ] | 0 ; $74 = $73 & 65535 ; if ( $68 ) { $14 = $74 ; $75 = $14 ; $76 = $75 & 65535 ; $77 = $76 & 65535 ; $78 = $3 ; $79 = ( ( ( $78 ) ) + 5820 | 0 ) ; $80 = HEAP32 [ $79 >> 2 ] | 0 ; $81 = $77 << $80 ; $82 = $3 ; $83 = ( ( ( $82 ) ) + 5816 | 0 ) ; $84 = HEAP16 [ $83 >> 1 ] | 0 ; $85 = $84 & 65535 ; $86 = $85 | $81 ; $87 = $86 & 65535 ; HEAP16 [ $83 >> 1 ] = $87 ; $88 = $3 ; $89 = ( ( ( $88 ) ) + 5816 | 0 ) ; $90 = HEAP16 [ $89 >> 1 ] | 0 ; $91 = $90 & 65535 ; $92 = $91 & 255 ; $93 = $92 & 255 ; $94 = $3 ; $95 = ( ( ( $94 ) ) + 8 | 0 ) ; $96 = HEAP32 [ $95 >> 2 ] | 0 ; $97 = $3 ; $98 = ( ( ( $97 ) ) + 20 | 0 ) ; $99 = HEAP32 [ $98 >> 2 ] | 0 ; $100 = ( ( $99 ) + 1 ) | 0 ; HEAP32 [ $98 >> 2 ] = $100 ; $101 = ( ( $96 ) + ( $99 ) | 0 ) ; HEAP8 [ $101 >> 0 ] = $93 ; $102 = $3 ; $103 = ( ( ( $102 ) ) + 5816 | 0 ) ; $104 = HEAP16 [ $103 >> 1 ] | 0 ; $105 = $104 & 65535 ; $106 = $105 >> 8 ; $107 = $106 & 255 ; $108 = $3 ; $109 = ( ( ( $108 ) ) + 8 | 0 ) ; $110 = HEAP32 [ $109 >> 2 ] | 0 ; $111 = $3 ; $112 = ( ( ( $111 ) ) + 20 | 0 ) ; $113 = HEAP32 [ $112 >> 2 ] | 0 ; $114 = ( ( $113 ) + 1 ) | 0 ; HEAP32 [ $112 >> 2 ] = $114 ; $115 = ( ( $110 ) + ( $113 ) | 0 ) ; HEAP8 [ $115 >> 0 ] = $107 ; $116 = $14 ; $117 = $116 & 65535 ; $118 = $117 & 65535 ; $119 = $3 ; $120 = ( ( ( $119 ) ) + 5820 | 0 ) ; $121 = HEAP32 [ $120 >> 2 ] | 0 ; $122 = ( 16 - ( $121 ) ) | 0 ; $123 = $118 >> $122 ; $124 = $123 & 65535 ; $125 = $3 ; $126 = ( ( ( $125 ) ) + 5816 | 0 ) ; HEAP16 [ $126 >> 1 ] = $124 ; $127 = $13 ; $128 = ( ( $127 ) - 16 ) | 0 ; $129 = $3 ; $$sink3 = $128 ; $$sink45 = $129 ; } else { $130 = $3 ; $131 = ( ( ( $130 ) ) + 5820 | 0 ) ; $132 = HEAP32 [ $131 >> 2 ] | 0 ; $133 = $74 << $132 ; $134 = $3 ; $135 = ( ( ( $134 ) ) + 5816 | 0 ) ; $136 = HEAP16 [ $135 >> 1 ] | 0 ; $137 = $136 & 65535 ; $138 = $137 | $133 ; $139 = $138 & 65535 ; HEAP16 [ $135 >> 1 ] = $139 ; $140 = $13 ; $141 = $3 ; $$sink3 = $140 ; $$sink45 = $141 ; } $142 = ( ( ( $$sink45 ) ) + 5820 | 0 ) ; $143 = HEAP32 [ $142 >> 2 ] | 0 ; $144 = ( ( $143 ) + ( $$sink3 ) ) | 0 ; HEAP32 [ $142 >> 2 ] = $144 ; $145 = $10 ; $146 = ( ( $145 ) + - 1 ) | 0 ; $10 = $146 ; $147 = ( $146 | 0 ) != ( 0 ) ; if ( ! ( $147 ) ) { break ; } } } else { $148 = $8 ; $149 = ( $148 | 0 ) != ( 0 ) ; do { if ( $149 ) { $150 = $8 ; $151 = $7 ; $152 = ( $150 | 0 ) != ( $151 | 0 ) ; if ( $152 ) { $153 = $3 ; $154 = ( ( ( $153 ) ) + 2684 | 0 ) ; $155 = $8 ; $156 = ( ( $154 ) + ( $155 << 2 ) | 0 ) ; $157 = ( ( ( $156 ) ) + 2 | 0 ) ; $158 = HEAP16 [ $157 >> 1 ] | 0 ; $159 = $158 & 65535 ; $15 = $159 ; $160 = $3 ; $161 = ( ( ( $160 ) ) + 5820 | 0 ) ; $162 = HEAP32 [ $161 >> 2 ] | 0 ; $163 = $15 ; $164 = ( 16 - ( $163 ) ) | 0 ; $165 = ( $162 | 0 ) > ( $164 | 0 ) ; $166 = $3 ; $167 = ( ( ( $166 ) ) + 2684 | 0 ) ; $168 = $8 ; $169 = ( ( $167 ) + ( $168 << 2 ) | 0 ) ; $170 = HEAP16 [ $169 >> 1 ] | 0 ; $171 = $170 & 65535 ; if ( $165 ) { $16 = $171 ; $172 = $16 ; $173 = $172 & 65535 ; $174 = $173 & 65535 ; $175 = $3 ; $176 = ( ( ( $175 ) ) + 5820 | 0 ) ; $177 = HEAP32 [ $176 >> 2 ] | 0 ; $178 = $174 << $177 ; $179 = $3 ; $180 = ( ( ( $179 ) ) + 5816 | 0 ) ; $181 = HEAP16 [ $180 >> 1 ] | 0 ; $182 = $181 & 65535 ; $183 = $182 | $178 ; $184 = $183 & 65535 ; HEAP16 [ $180 >> 1 ] = $184 ; $185 = $3 ; $186 = ( ( ( $185 ) ) + 5816 | 0 ) ; $187 = HEAP16 [ $186 >> 1 ] | 0 ; $188 = $187 & 65535 ; $189 = $188 & 255 ; $190 = $189 & 255 ; $191 = $3 ; $192 = ( ( ( $191 ) ) + 8 | 0 ) ; $193 = HEAP32 [ $192 >> 2 ] | 0 ; $194 = $3 ; $195 = ( ( ( $194 ) ) + 20 | 0 ) ; $196 = HEAP32 [ $195 >> 2 ] | 0 ; $197 = ( ( $196 ) + 1 ) | 0 ; HEAP32 [ $195 >> 2 ] = $197 ; $198 = ( ( $193 ) + ( $196 ) | 0 ) ; HEAP8 [ $198 >> 0 ] = $190 ; $199 = $3 ; $200 = ( ( ( $199 ) ) + 5816 | 0 ) ; $201 = HEAP16 [ $200 >> 1 ] | 0 ; $202 = $201 & 65535 ; $203 = $202 >> 8 ; $204 = $203 & 255 ; $205 = $3 ; $206 = ( ( ( $205 ) ) + 8 | 0 ) ; $207 = HEAP32 [ $206 >> 2 ] | 0 ; $208 = $3 ; $209 = ( ( ( $208 ) ) + 20 | 0 ) ; $210 = HEAP32 [ $209 >> 2 ] | 0 ; $211 = ( ( $210 ) + 1 ) | 0 ; HEAP32 [ $209 >> 2 ] = $211 ; $212 = ( ( $207 ) + ( $210 ) | 0 ) ; HEAP8 [ $212 >> 0 ] = $204 ; $213 = $16 ; $214 = $213 & 65535 ; $215 = $214 & 65535 ; $216 = $3 ; $217 = ( ( ( $216 ) ) + 5820 | 0 ) ; $218 = HEAP32 [ $217 >> 2 ] | 0 ; $219 = ( 16 - ( $218 ) ) | 0 ; $220 = $215 >> $219 ; $221 = $220 & 65535 ; $222 = $3 ; $223 = ( ( ( $222 ) ) + 5816 | 0 ) ; HEAP16 [ $223 >> 1 ] = $221 ; $224 = $15 ; $225 = ( ( $224 ) - 16 ) | 0 ; $226 = $3 ; $$sink = $226 ; $$sink7 = $225 ; } else { $227 = $3 ; $228 = ( ( ( $227 ) ) + 5820 | 0 ) ; $229 = HEAP32 [ $228 >> 2 ] | 0 ; $230 = $171 << $229 ; $231 = $3 ; $232 = ( ( ( $231 ) ) + 5816 | 0 ) ; $233 = HEAP16 [ $232 >> 1 ] | 0 ; $234 = $233 & 65535 ; $235 = $234 | $230 ; $236 = $235 & 65535 ; HEAP16 [ $232 >> 1 ] = $236 ; $237 = $15 ; $238 = $3 ; $$sink = $238 ; $$sink7 = $237 ; } $239 = ( ( ( $$sink ) ) + 5820 | 0 ) ; $240 = HEAP32 [ $239 >> 2 ] | 0 ; $241 = ( ( $240 ) + ( $$sink7 ) ) | 0 ; HEAP32 [ $239 >> 2 ] = $241 ; $242 = $10 ; $243 = ( ( $242 ) + - 1 ) | 0 ; $10 = $243 ; } $244 = $3 ; $245 = ( ( ( $244 ) ) + 2684 | 0 ) ; $246 = ( ( ( $245 ) ) + 64 | 0 ) ; $247 = ( ( ( $246 ) ) + 2 | 0 ) ; $248 = HEAP16 [ $247 >> 1 ] | 0 ; $249 = $248 & 65535 ; $17 = $249 ; $250 = $3 ; $251 = ( ( ( $250 ) ) + 5820 | 0 ) ; $252 = HEAP32 [ $251 >> 2 ] | 0 ; $253 = $17 ; $254 = ( 16 - ( $253 ) ) | 0 ; $255 = ( $252 | 0 ) > ( $254 | 0 ) ; $256 = $3 ; $257 = ( ( ( $256 ) ) + 2684 | 0 ) ; $258 = ( ( ( $257 ) ) + 64 | 0 ) ; $259 = HEAP16 [ $258 >> 1 ] | 0 ; $260 = $259 & 65535 ; if ( $255 ) { $18 = $260 ; $261 = $18 ; $262 = $261 & 65535 ; $263 = $262 & 65535 ; $264 = $3 ; $265 = ( ( ( $264 ) ) + 5820 | 0 ) ; $266 = HEAP32 [ $265 >> 2 ] | 0 ; $267 = $263 << $266 ; $268 = $3 ; $269 = ( ( ( $268 ) ) + 5816 | 0 ) ; $270 = HEAP16 [ $269 >> 1 ] | 0 ; $271 = $270 & 65535 ; $272 = $271 | $267 ; $273 = $272 & 65535 ; HEAP16 [ $269 >> 1 ] = $273 ; $274 = $3 ; $275 = ( ( ( $274 ) ) + 5816 | 0 ) ; $276 = HEAP16 [ $275 >> 1 ] | 0 ; $277 = $276 & 65535 ; $278 = $277 & 255 ; $279 = $278 & 255 ; $280 = $3 ; $281 = ( ( ( $280 ) ) + 8 | 0 ) ; $282 = HEAP32 [ $281 >> 2 ] | 0 ; $283 = $3 ; $284 = ( ( ( $283 ) ) + 20 | 0 ) ; $285 = HEAP32 [ $284 >> 2 ] | 0 ; $286 = ( ( $285 ) + 1 ) | 0 ; HEAP32 [ $284 >> 2 ] = $286 ; $287 = ( ( $282 ) + ( $285 ) | 0 ) ; HEAP8 [ $287 >> 0 ] = $279 ; $288 = $3 ; $289 = ( ( ( $288 ) ) + 5816 | 0 ) ; $290 = HEAP16 [ $289 >> 1 ] | 0 ; $291 = $290 & 65535 ; $292 = $291 >> 8 ; $293 = $292 & 255 ; $294 = $3 ; $295 = ( ( ( $294 ) ) + 8 | 0 ) ; $296 = HEAP32 [ $295 >> 2 ] | 0 ; $297 = $3 ; $298 = ( ( ( $297 ) ) + 20 | 0 ) ; $299 = HEAP32 [ $298 >> 2 ] | 0 ; $300 = ( ( $299 ) + 1 ) | 0 ; HEAP32 [ $298 >> 2 ] = $300 ; $301 = ( ( $296 ) + ( $299 ) | 0 ) ; HEAP8 [ $301 >> 0 ] = $293 ; $302 = $18 ; $303 = $302 & 65535 ; $304 = $303 & 65535 ; $305 = $3 ; $306 = ( ( ( $305 ) ) + 5820 | 0 ) ; $307 = HEAP32 [ $306 >> 2 ] | 0 ; $308 = ( 16 - ( $307 ) ) | 0 ; $309 = $304 >> $308 ; $310 = $309 & 65535 ; $311 = $3 ; $312 = ( ( ( $311 ) ) + 5816 | 0 ) ; HEAP16 [ $312 >> 1 ] = $310 ; $313 = $17 ; $314 = ( ( $313 ) - 16 ) | 0 ; $315 = $3 ; $$sink12 = $314 ; $$sink46 = $315 ; } else { $316 = $3 ; $317 = ( ( ( $316 ) ) + 5820 | 0 ) ; $318 = HEAP32 [ $317 >> 2 ] | 0 ; $319 = $260 << $318 ; $320 = $3 ; $321 = ( ( ( $320 ) ) + 5816 | 0 ) ; $322 = HEAP16 [ $321 >> 1 ] | 0 ; $323 = $322 & 65535 ; $324 = $323 | $319 ; $325 = $324 & 65535 ; HEAP16 [ $321 >> 1 ] = $325 ; $326 = $17 ; $327 = $3 ; $$sink12 = $326 ; $$sink46 = $327 ; } $328 = ( ( ( $$sink46 ) ) + 5820 | 0 ) ; $329 = HEAP32 [ $328 >> 2 ] | 0 ; $330 = ( ( $329 ) + ( $$sink12 ) ) | 0 ; HEAP32 [ $328 >> 2 ] = $330 ; $19 = 2 ; $331 = $3 ; $332 = ( ( ( $331 ) ) + 5820 | 0 ) ; $333 = HEAP32 [ $332 >> 2 ] | 0 ; $334 = $19 ; $335 = ( 16 - ( $334 ) ) | 0 ; $336 = ( $333 | 0 ) > ( $335 | 0 ) ; $337 = $10 ; $338 = ( ( $337 ) - 3 ) | 0 ; if ( $336 ) { $20 = $338 ; $339 = $20 ; $340 = $339 & 65535 ; $341 = $340 & 65535 ; $342 = $3 ; $343 = ( ( ( $342 ) ) + 5820 | 0 ) ; $344 = HEAP32 [ $343 >> 2 ] | 0 ; $345 = $341 << $344 ; $346 = $3 ; $347 = ( ( ( $346 ) ) + 5816 | 0 ) ; $348 = HEAP16 [ $347 >> 1 ] | 0 ; $349 = $348 & 65535 ; $350 = $349 | $345 ; $351 = $350 & 65535 ; HEAP16 [ $347 >> 1 ] = $351 ; $352 = $3 ; $353 = ( ( ( $352 ) ) + 5816 | 0 ) ; $354 = HEAP16 [ $353 >> 1 ] | 0 ; $355 = $354 & 65535 ; $356 = $355 & 255 ; $357 = $356 & 255 ; $358 = $3 ; $359 = ( ( ( $358 ) ) + 8 | 0 ) ; $360 = HEAP32 [ $359 >> 2 ] | 0 ; $361 = $3 ; $362 = ( ( ( $361 ) ) + 20 | 0 ) ; $363 = HEAP32 [ $362 >> 2 ] | 0 ; $364 = ( ( $363 ) + 1 ) | 0 ; HEAP32 [ $362 >> 2 ] = $364 ; $365 = ( ( $360 ) + ( $363 ) | 0 ) ; HEAP8 [ $365 >> 0 ] = $357 ; $366 = $3 ; $367 = ( ( ( $366 ) ) + 5816 | 0 ) ; $368 = HEAP16 [ $367 >> 1 ] | 0 ; $369 = $368 & 65535 ; $370 = $369 >> 8 ; $371 = $370 & 255 ; $372 = $3 ; $373 = ( ( ( $372 ) ) + 8 | 0 ) ; $374 = HEAP32 [ $373 >> 2 ] | 0 ; $375 = $3 ; $376 = ( ( ( $375 ) ) + 20 | 0 ) ; $377 = HEAP32 [ $376 >> 2 ] | 0 ; $378 = ( ( $377 ) + 1 ) | 0 ; HEAP32 [ $376 >> 2 ] = $378 ; $379 = ( ( $374 ) + ( $377 ) | 0 ) ; HEAP8 [ $379 >> 0 ] = $371 ; $380 = $20 ; $381 = $380 & 65535 ; $382 = $381 & 65535 ; $383 = $3 ; $384 = ( ( ( $383 ) ) + 5820 | 0 ) ; $385 = HEAP32 [ $384 >> 2 ] | 0 ; $386 = ( 16 - ( $385 ) ) | 0 ; $387 = $382 >> $386 ; $388 = $387 & 65535 ; $389 = $3 ; $390 = ( ( ( $389 ) ) + 5816 | 0 ) ; HEAP16 [ $390 >> 1 ] = $388 ; $391 = $19 ; $392 = ( ( $391 ) - 16 ) | 0 ; $393 = $3 ; $$sink37$sink$sink = $392 ; $$sink51$sink$sink = $393 ; break ; } else { $394 = $338 & 65535 ; $395 = $394 & 65535 ; $396 = $3 ; $397 = ( ( ( $396 ) ) + 5820 | 0 ) ; $398 = HEAP32 [ $397 >> 2 ] | 0 ; $399 = $395 << $398 ; $400 = $3 ; $401 = ( ( ( $400 ) ) + 5816 | 0 ) ; $402 = HEAP16 [ $401 >> 1 ] | 0 ; $403 = $402 & 65535 ; $404 = $403 | $399 ; $405 = $404 & 65535 ; HEAP16 [ $401 >> 1 ] = $405 ; $406 = $19 ; $407 = $3 ; $$sink37$sink$sink = $406 ; $$sink51$sink$sink = $407 ; break ; } } else { $408 = $10 ; $409 = ( $408 | 0 ) <= ( 10 ) ; $410 = $3 ; $411 = ( ( ( $410 ) ) + 2684 | 0 ) ; if ( $409 ) { $412 = ( ( ( $411 ) ) + 68 | 0 ) ; $413 = ( ( ( $412 ) ) + 2 | 0 ) ; $414 = HEAP16 [ $413 >> 1 ] | 0 ; $415 = $414 & 65535 ; $21 = $415 ; $416 = $3 ; $417 = ( ( ( $416 ) ) + 5820 | 0 ) ; $418 = HEAP32 [ $417 >> 2 ] | 0 ; $419 = $21 ; $420 = ( 16 - ( $419 ) ) | 0 ; $421 = ( $418 | 0 ) > ( $420 | 0 ) ; $422 = $3 ; $423 = ( ( ( $422 ) ) + 2684 | 0 ) ; $424 = ( ( ( $423 ) ) + 68 | 0 ) ; $425 = HEAP16 [ $424 >> 1 ] | 0 ; $426 = $425 & 65535 ; if ( $421 ) { $22 = $426 ; $427 = $22 ; $428 = $427 & 65535 ; $429 = $428 & 65535 ; $430 = $3 ; $431 = ( ( ( $430 ) ) + 5820 | 0 ) ; $432 = HEAP32 [ $431 >> 2 ] | 0 ; $433 = $429 << $432 ; $434 = $3 ; $435 = ( ( ( $434 ) ) + 5816 | 0 ) ; $436 = HEAP16 [ $435 >> 1 ] | 0 ; $437 = $436 & 65535 ; $438 = $437 | $433 ; $439 = $438 & 65535 ; HEAP16 [ $435 >> 1 ] = $439 ; $440 = $3 ; $441 = ( ( ( $440 ) ) + 5816 | 0 ) ; $442 = HEAP16 [ $441 >> 1 ] | 0 ; $443 = $442 & 65535 ; $444 = $443 & 255 ; $445 = $444 & 255 ; $446 = $3 ; $447 = ( ( ( $446 ) ) + 8 | 0 ) ; $448 = HEAP32 [ $447 >> 2 ] | 0 ; $449 = $3 ; $450 = ( ( ( $449 ) ) + 20 | 0 ) ; $451 = HEAP32 [ $450 >> 2 ] | 0 ; $452 = ( ( $451 ) + 1 ) | 0 ; HEAP32 [ $450 >> 2 ] = $452 ; $453 = ( ( $448 ) + ( $451 ) | 0 ) ; HEAP8 [ $453 >> 0 ] = $445 ; $454 = $3 ; $455 = ( ( ( $454 ) ) + 5816 | 0 ) ; $456 = HEAP16 [ $455 >> 1 ] | 0 ; $457 = $456 & 65535 ; $458 = $457 >> 8 ; $459 = $458 & 255 ; $460 = $3 ; $461 = ( ( ( $460 ) ) + 8 | 0 ) ; $462 = HEAP32 [ $461 >> 2 ] | 0 ; $463 = $3 ; $464 = ( ( ( $463 ) ) + 20 | 0 ) ; $465 = HEAP32 [ $464 >> 2 ] | 0 ; $466 = ( ( $465 ) + 1 ) | 0 ; HEAP32 [ $464 >> 2 ] = $466 ; $467 = ( ( $462 ) + ( $465 ) | 0 ) ; HEAP8 [ $467 >> 0 ] = $459 ; $468 = $22 ; $469 = $468 & 65535 ; $470 = $469 & 65535 ; $471 = $3 ; $472 = ( ( ( $471 ) ) + 5820 | 0 ) ; $473 = HEAP32 [ $472 >> 2 ] | 0 ; $474 = ( 16 - ( $473 ) ) | 0 ; $475 = $470 >> $474 ; $476 = $475 & 65535 ; $477 = $3 ; $478 = ( ( ( $477 ) ) + 5816 | 0 ) ; HEAP16 [ $478 >> 1 ] = $476 ; $479 = $21 ; $480 = ( ( $479 ) - 16 ) | 0 ; $481 = $3 ; $$sink22 = $480 ; $$sink48 = $481 ; } else { $482 = $3 ; $483 = ( ( ( $482 ) ) + 5820 | 0 ) ; $484 = HEAP32 [ $483 >> 2 ] | 0 ; $485 = $426 << $484 ; $486 = $3 ; $487 = ( ( ( $486 ) ) + 5816 | 0 ) ; $488 = HEAP16 [ $487 >> 1 ] | 0 ; $489 = $488 & 65535 ; $490 = $489 | $485 ; $491 = $490 & 65535 ; HEAP16 [ $487 >> 1 ] = $491 ; $492 = $21 ; $493 = $3 ; $$sink22 = $492 ; $$sink48 = $493 ; } $494 = ( ( ( $$sink48 ) ) + 5820 | 0 ) ; $495 = HEAP32 [ $494 >> 2 ] | 0 ; $496 = ( ( $495 ) + ( $$sink22 ) ) | 0 ; HEAP32 [ $494 >> 2 ] = $496 ; $23 = 3 ; $497 = $3 ; $498 = ( ( ( $497 ) ) + 5820 | 0 ) ; $499 = HEAP32 [ $498 >> 2 ] | 0 ; $500 = $23 ; $501 = ( 16 - ( $500 ) ) | 0 ; $502 = ( $499 | 0 ) > ( $501 | 0 ) ; $503 = $10 ; $504 = ( ( $503 ) - 3 ) | 0 ; if ( $502 ) { $24 = $504 ; $505 = $24 ; $506 = $505 & 65535 ; $507 = $506 & 65535 ; $508 = $3 ; $509 = ( ( ( $508 ) ) + 5820 | 0 ) ; $510 = HEAP32 [ $509 >> 2 ] | 0 ; $511 = $507 << $510 ; $512 = $3 ; $513 = ( ( ( $512 ) ) + 5816 | 0 ) ; $514 = HEAP16 [ $513 >> 1 ] | 0 ; $515 = $514 & 65535 ; $516 = $515 | $511 ; $517 = $516 & 65535 ; HEAP16 [ $513 >> 1 ] = $517 ; $518 = $3 ; $519 = ( ( ( $518 ) ) + 5816 | 0 ) ; $520 = HEAP16 [ $519 >> 1 ] | 0 ; $521 = $520 & 65535 ; $522 = $521 & 255 ; $523 = $522 & 255 ; $524 = $3 ; $525 = ( ( ( $524 ) ) + 8 | 0 ) ; $526 = HEAP32 [ $525 >> 2 ] | 0 ; $527 = $3 ; $528 = ( ( ( $527 ) ) + 20 | 0 ) ; $529 = HEAP32 [ $528 >> 2 ] | 0 ; $530 = ( ( $529 ) + 1 ) | 0 ; HEAP32 [ $528 >> 2 ] = $530 ; $531 = ( ( $526 ) + ( $529 ) | 0 ) ; HEAP8 [ $531 >> 0 ] = $523 ; $532 = $3 ; $533 = ( ( ( $532 ) ) + 5816 | 0 ) ; $534 = HEAP16 [ $533 >> 1 ] | 0 ; $535 = $534 & 65535 ; $536 = $535 >> 8 ; $537 = $536 & 255 ; $538 = $3 ; $539 = ( ( ( $538 ) ) + 8 | 0 ) ; $540 = HEAP32 [ $539 >> 2 ] | 0 ; $541 = $3 ; $542 = ( ( ( $541 ) ) + 20 | 0 ) ; $543 = HEAP32 [ $542 >> 2 ] | 0 ; $544 = ( ( $543 ) + 1 ) | 0 ; HEAP32 [ $542 >> 2 ] = $544 ; $545 = ( ( $540 ) + ( $543 ) | 0 ) ; HEAP8 [ $545 >> 0 ] = $537 ; $546 = $24 ; $547 = $546 & 65535 ; $548 = $547 & 65535 ; $549 = $3 ; $550 = ( ( ( $549 ) ) + 5820 | 0 ) ; $551 = HEAP32 [ $550 >> 2 ] | 0 ; $552 = ( 16 - ( $551 ) ) | 0 ; $553 = $548 >> $552 ; $554 = $553 & 65535 ; $555 = $3 ; $556 = ( ( ( $555 ) ) + 5816 | 0 ) ; HEAP16 [ $556 >> 1 ] = $554 ; $557 = $23 ; $558 = ( ( $557 ) - 16 ) | 0 ; $559 = $3 ; $$sink37$sink$sink = $558 ; $$sink51$sink$sink = $559 ; break ; } else { $560 = $504 & 65535 ; $561 = $560 & 65535 ; $562 = $3 ; $563 = ( ( ( $562 ) ) + 5820 | 0 ) ; $564 = HEAP32 [ $563 >> 2 ] | 0 ; $565 = $561 << $564 ; $566 = $3 ; $567 = ( ( ( $566 ) ) + 5816 | 0 ) ; $568 = HEAP16 [ $567 >> 1 ] | 0 ; $569 = $568 & 65535 ; $570 = $569 | $565 ; $571 = $570 & 65535 ; HEAP16 [ $567 >> 1 ] = $571 ; $572 = $23 ; $573 = $3 ; $$sink37$sink$sink = $572 ; $$sink51$sink$sink = $573 ; break ; } } else { $574 = ( ( ( $411 ) ) + 72 | 0 ) ; $575 = ( ( ( $574 ) ) + 2 | 0 ) ; $576 = HEAP16 [ $575 >> 1 ] | 0 ; $577 = $576 & 65535 ; $25 = $577 ; $578 = $3 ; $579 = ( ( ( $578 ) ) + 5820 | 0 ) ; $580 = HEAP32 [ $579 >> 2 ] | 0 ; $581 = $25 ; $582 = ( 16 - ( $581 ) ) | 0 ; $583 = ( $580 | 0 ) > ( $582 | 0 ) ; $584 = $3 ; $585 = ( ( ( $584 ) ) + 2684 | 0 ) ; $586 = ( ( ( $585 ) ) + 72 | 0 ) ; $587 = HEAP16 [ $586 >> 1 ] | 0 ; $588 = $587 & 65535 ; if ( $583 ) { $26 = $588 ; $589 = $26 ; $590 = $589 & 65535 ; $591 = $590 & 65535 ; $592 = $3 ; $593 = ( ( ( $592 ) ) + 5820 | 0 ) ; $594 = HEAP32 [ $593 >> 2 ] | 0 ; $595 = $591 << $594 ; $596 = $3 ; $597 = ( ( ( $596 ) ) + 5816 | 0 ) ; $598 = HEAP16 [ $597 >> 1 ] | 0 ; $599 = $598 & 65535 ; $600 = $599 | $595 ; $601 = $600 & 65535 ; HEAP16 [ $597 >> 1 ] = $601 ; $602 = $3 ; $603 = ( ( ( $602 ) ) + 5816 | 0 ) ; $604 = HEAP16 [ $603 >> 1 ] | 0 ; $605 = $604 & 65535 ; $606 = $605 & 255 ; $607 = $606 & 255 ; $608 = $3 ; $609 = ( ( ( $608 ) ) + 8 | 0 ) ; $610 = HEAP32 [ $609 >> 2 ] | 0 ; $611 = $3 ; $612 = ( ( ( $611 ) ) + 20 | 0 ) ; $613 = HEAP32 [ $612 >> 2 ] | 0 ; $614 = ( ( $613 ) + 1 ) | 0 ; HEAP32 [ $612 >> 2 ] = $614 ; $615 = ( ( $610 ) + ( $613 ) | 0 ) ; HEAP8 [ $615 >> 0 ] = $607 ; $616 = $3 ; $617 = ( ( ( $616 ) ) + 5816 | 0 ) ; $618 = HEAP16 [ $617 >> 1 ] | 0 ; $619 = $618 & 65535 ; $620 = $619 >> 8 ; $621 = $620 & 255 ; $622 = $3 ; $623 = ( ( ( $622 ) ) + 8 | 0 ) ; $624 = HEAP32 [ $623 >> 2 ] | 0 ; $625 = $3 ; $626 = ( ( ( $625 ) ) + 20 | 0 ) ; $627 = HEAP32 [ $626 >> 2 ] | 0 ; $628 = ( ( $627 ) + 1 ) | 0 ; HEAP32 [ $626 >> 2 ] = $628 ; $629 = ( ( $624 ) + ( $627 ) | 0 ) ; HEAP8 [ $629 >> 0 ] = $621 ; $630 = $26 ; $631 = $630 & 65535 ; $632 = $631 & 65535 ; $633 = $3 ; $634 = ( ( ( $633 ) ) + 5820 | 0 ) ; $635 = HEAP32 [ $634 >> 2 ] | 0 ; $636 = ( 16 - ( $635 ) ) | 0 ; $637 = $632 >> $636 ; $638 = $637 & 65535 ; $639 = $3 ; $640 = ( ( ( $639 ) ) + 5816 | 0 ) ; HEAP16 [ $640 >> 1 ] = $638 ; $641 = $25 ; $642 = ( ( $641 ) - 16 ) | 0 ; $643 = $3 ; $$sink32 = $642 ; $$sink50 = $643 ; } else { $644 = $3 ; $645 = ( ( ( $644 ) ) + 5820 | 0 ) ; $646 = HEAP32 [ $645 >> 2 ] | 0 ; $647 = $588 << $646 ; $648 = $3 ; $649 = ( ( ( $648 ) ) + 5816 | 0 ) ; $650 = HEAP16 [ $649 >> 1 ] | 0 ; $651 = $650 & 65535 ; $652 = $651 | $647 ; $653 = $652 & 65535 ; HEAP16 [ $649 >> 1 ] = $653 ; $654 = $25 ; $655 = $3 ; $$sink32 = $654 ; $$sink50 = $655 ; } $656 = ( ( ( $$sink50 ) ) + 5820 | 0 ) ; $657 = HEAP32 [ $656 >> 2 ] | 0 ; $658 = ( ( $657 ) + ( $$sink32 ) ) | 0 ; HEAP32 [ $656 >> 2 ] = $658 ; $27 = 7 ; $659 = $3 ; $660 = ( ( ( $659 ) ) + 5820 | 0 ) ; $661 = HEAP32 [ $660 >> 2 ] | 0 ; $662 = $27 ; $663 = ( 16 - ( $662 ) ) | 0 ; $664 = ( $661 | 0 ) > ( $663 | 0 ) ; $665 = $10 ; $666 = ( ( $665 ) - 11 ) | 0 ; if ( $664 ) { $28 = $666 ; $667 = $28 ; $668 = $667 & 65535 ; $669 = $668 & 65535 ; $670 = $3 ; $671 = ( ( ( $670 ) ) + 5820 | 0 ) ; $672 = HEAP32 [ $671 >> 2 ] | 0 ; $673 = $669 << $672 ; $674 = $3 ; $675 = ( ( ( $674 ) ) + 5816 | 0 ) ; $676 = HEAP16 [ $675 >> 1 ] | 0 ; $677 = $676 & 65535 ; $678 = $677 | $673 ; $679 = $678 & 65535 ; HEAP16 [ $675 >> 1 ] = $679 ; $680 = $3 ; $681 = ( ( ( $680 ) ) + 5816 | 0 ) ; $682 = HEAP16 [ $681 >> 1 ] | 0 ; $683 = $682 & 65535 ; $684 = $683 & 255 ; $685 = $684 & 255 ; $686 = $3 ; $687 = ( ( ( $686 ) ) + 8 | 0 ) ; $688 = HEAP32 [ $687 >> 2 ] | 0 ; $689 = $3 ; $690 = ( ( ( $689 ) ) + 20 | 0 ) ; $691 = HEAP32 [ $690 >> 2 ] | 0 ; $692 = ( ( $691 ) + 1 ) | 0 ; HEAP32 [ $690 >> 2 ] = $692 ; $693 = ( ( $688 ) + ( $691 ) | 0 ) ; HEAP8 [ $693 >> 0 ] = $685 ; $694 = $3 ; $695 = ( ( ( $694 ) ) + 5816 | 0 ) ; $696 = HEAP16 [ $695 >> 1 ] | 0 ; $697 = $696 & 65535 ; $698 = $697 >> 8 ; $699 = $698 & 255 ; $700 = $3 ; $701 = ( ( ( $700 ) ) + 8 | 0 ) ; $702 = HEAP32 [ $701 >> 2 ] | 0 ; $703 = $3 ; $704 = ( ( ( $703 ) ) + 20 | 0 ) ; $705 = HEAP32 [ $704 >> 2 ] | 0 ; $706 = ( ( $705 ) + 1 ) | 0 ; HEAP32 [ $704 >> 2 ] = $706 ; $707 = ( ( $702 ) + ( $705 ) | 0 ) ; HEAP8 [ $707 >> 0 ] = $699 ; $708 = $28 ; $709 = $708 & 65535 ; $710 = $709 & 65535 ; $711 = $3 ; $712 = ( ( ( $711 ) ) + 5820 | 0 ) ; $713 = HEAP32 [ $712 >> 2 ] | 0 ; $714 = ( 16 - ( $713 ) ) | 0 ; $715 = $710 >> $714 ; $716 = $715 & 65535 ; $717 = $3 ; $718 = ( ( ( $717 ) ) + 5816 | 0 ) ; HEAP16 [ $718 >> 1 ] = $716 ; $719 = $27 ; $720 = ( ( $719 ) - 16 ) | 0 ; $721 = $3 ; $$sink37$sink$sink = $720 ; $$sink51$sink$sink = $721 ; break ; } else { $722 = $666 & 65535 ; $723 = $722 & 65535 ; $724 = $3 ; $725 = ( ( ( $724 ) ) + 5820 | 0 ) ; $726 = HEAP32 [ $725 >> 2 ] | 0 ; $727 = $723 << $726 ; $728 = $3 ; $729 = ( ( ( $728 ) ) + 5816 | 0 ) ; $730 = HEAP16 [ $729 >> 1 ] | 0 ; $731 = $730 & 65535 ; $732 = $731 | $727 ; $733 = $732 & 65535 ; HEAP16 [ $729 >> 1 ] = $733 ; $734 = $27 ; $735 = $3 ; $$sink37$sink$sink = $734 ; $$sink51$sink$sink = $735 ; break ; } } } } while ( 0 ) ; $736 = ( ( ( $$sink51$sink$sink ) ) + 5820 | 0 ) ; $737 = HEAP32 [ $736 >> 2 ] | 0 ; $738 = ( ( $737 ) + ( $$sink37$sink$sink ) ) | 0 ; HEAP32 [ $736 >> 2 ] = $738 ; } $10 = 0 ; $739 = $8 ; $7 = $739 ; $740 = $9 ; $741 = ( $740 | 0 ) == ( 0 ) ; if ( $741 ) { $11 = 138 ; $12 = 3 ; break ; } $742 = $8 ; $743 = $9 ; $744 = ( $742 | 0 ) == ( $743 | 0 ) ; if ( $744 ) { $11 = 6 ; $12 = 3 ; break ; } else { $11 = 7 ; $12 = 4 ; break ; } } } while ( 0 ) ; $745 = $6 ; $746 = ( ( $745 ) + 1 ) | 0 ; $6 = $746 ; } STACKTOP = sp ; return ; } function _scan_tree ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$sink = 0 , $$sink$sink5 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 ; var $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 ; var $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 ; var $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 ; var $82 = 0 , $83 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 48 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 48 | 0 ) ; $3 = $0 ; $4 = $1 ; $5 = $2 ; $7 = - 1 ; $13 = $4 ; $14 = ( ( ( $13 ) ) + 2 | 0 ) ; $15 = HEAP16 [ $14 >> 1 ] | 0 ; $16 = $15 & 65535 ; $9 = $16 ; $10 = 0 ; $11 = 7 ; $12 = 4 ; $17 = $9 ; $18 = ( $17 | 0 ) == ( 0 ) ; if ( $18 ) { $11 = 138 ; $12 = 3 ; } $19 = $4 ; $20 = $5 ; $21 = ( ( $20 ) + 1 ) | 0 ; $22 = ( ( $19 ) + ( $21 << 2 ) | 0 ) ; $23 = ( ( ( $22 ) ) + 2 | 0 ) ; HEAP16 [ $23 >> 1 ] = - 1 ; $6 = 0 ; while ( 1 ) { $24 = $6 ; $25 = $5 ; $26 = ( $24 | 0 ) <= ( $25 | 0 ) ; if ( ! ( $26 ) ) { break ; } $27 = $9 ; $8 = $27 ; $28 = $4 ; $29 = $6 ; $30 = ( ( $29 ) + 1 ) | 0 ; $31 = ( ( $28 ) + ( $30 << 2 ) | 0 ) ; $32 = ( ( ( $31 ) ) + 2 | 0 ) ; $33 = HEAP16 [ $32 >> 1 ] | 0 ; $34 = $33 & 65535 ; $9 = $34 ; $35 = $10 ; $36 = ( ( $35 ) + 1 ) | 0 ; $10 = $36 ; $37 = $11 ; $38 = ( $36 | 0 ) < ( $37 | 0 ) ; if ( $38 ) { $39 = $8 ; $40 = $9 ; $41 = ( $39 | 0 ) == ( $40 | 0 ) ; if ( ! ( $41 ) ) { label = 7 ; } } else { label = 7 ; } do { if ( ( label | 0 ) == 7 ) { label = 0 ; $42 = $10 ; $43 = $12 ; $44 = ( $42 | 0 ) < ( $43 | 0 ) ; if ( $44 ) { $45 = $10 ; $46 = $3 ; $47 = ( ( ( $46 ) ) + 2684 | 0 ) ; $48 = $8 ; $49 = ( ( $47 ) + ( $48 << 2 ) | 0 ) ; $50 = HEAP16 [ $49 >> 1 ] | 0 ; $51 = $50 & 65535 ; $52 = ( ( $51 ) + ( $45 ) ) | 0 ; $53 = $52 & 65535 ; HEAP16 [ $49 >> 1 ] = $53 ; } else { $54 = $8 ; $55 = ( $54 | 0 ) != ( 0 ) ; if ( $55 ) { $56 = $8 ; $57 = $7 ; $58 = ( $56 | 0 ) != ( $57 | 0 ) ; if ( $58 ) { $59 = $3 ; $60 = ( ( ( $59 ) ) + 2684 | 0 ) ; $61 = $8 ; $62 = ( ( $60 ) + ( $61 << 2 ) | 0 ) ; $63 = HEAP16 [ $62 >> 1 ] | 0 ; $64 = ( ( $63 ) + 1 ) << 16 >> 16 ; HEAP16 [ $62 >> 1 ] = $64 ; } $65 = $3 ; $66 = ( ( ( $65 ) ) + 2684 | 0 ) ; $67 = ( ( ( $66 ) ) + 64 | 0 ) ; $$sink$sink5 = $67 ; } else { $68 = $10 ; $69 = ( $68 | 0 ) <= ( 10 ) ; $70 = $3 ; $71 = ( ( ( $70 ) ) + 2684 | 0 ) ; $72 = ( ( ( $71 ) ) + 72 | 0 ) ; $73 = ( ( ( $71 ) ) + 68 | 0 ) ; $$sink = $69 ? $73 : $72 ; $$sink$sink5 = $$sink ; } $74 = HEAP16 [ $$sink$sink5 >> 1 ] | 0 ; $75 = ( ( $74 ) + 1 ) << 16 >> 16 ; HEAP16 [ $$sink$sink5 >> 1 ] = $75 ; } $10 = 0 ; $76 = $8 ; $7 = $76 ; $77 = $9 ; $78 = ( $77 | 0 ) == ( 0 ) ; if ( $78 ) { $11 = 138 ; $12 = 3 ; break ; } $79 = $8 ; $80 = $9 ; $81 = ( $79 | 0 ) == ( $80 | 0 ) ; if ( $81 ) { $11 = 6 ; $12 = 3 ; break ; } else { $11 = 7 ; $12 = 4 ; break ; } } } while ( 0 ) ; $82 = $6 ; $83 = ( ( $82 ) + 1 ) | 0 ; $6 = $83 ; } STACKTOP = sp ; return ; } function _pqdownheap ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 ; var $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $16 = 0 ; var $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 ; var $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 ; var $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 ; var $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 ; var $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $3 = $0 ; $4 = $1 ; $5 = $2 ; $8 = $3 ; $9 = ( ( ( $8 ) ) + 2908 | 0 ) ; $10 = $5 ; $11 = ( ( $9 ) + ( $10 << 2 ) | 0 ) ; $12 = HEAP32 [ $11 >> 2 ] | 0 ; $6 = $12 ; $13 = $5 ; $14 = $13 << 1 ; $7 = $14 ; while ( 1 ) { $15 = $7 ; $16 = $3 ; $17 = ( ( ( $16 ) ) + 5200 | 0 ) ; $18 = HEAP32 [ $17 >> 2 ] | 0 ; $19 = ( $15 | 0 ) <= ( $18 | 0 ) ; if ( ! ( $19 ) ) { label = 12 ; break ; } $20 = $7 ; $21 = $3 ; $22 = ( ( ( $21 ) ) + 5200 | 0 ) ; $23 = HEAP32 [ $22 >> 2 ] | 0 ; $24 = ( $20 | 0 ) < ( $23 | 0 ) ; do { if ( $24 ) { $25 = $4 ; $26 = $3 ; $27 = ( ( ( $26 ) ) + 2908 | 0 ) ; $28 = $7 ; $29 = ( ( $28 ) + 1 ) | 0 ; $30 = ( ( $27 ) + ( $29 << 2 ) | 0 ) ; $31 = HEAP32 [ $30 >> 2 ] | 0 ; $32 = ( ( $25 ) + ( $31 << 2 ) | 0 ) ; $33 = HEAP16 [ $32 >> 1 ] | 0 ; $34 = $33 & 65535 ; $35 = $4 ; $36 = $3 ; $37 = ( ( ( $36 ) ) + 2908 | 0 ) ; $38 = $7 ; $39 = ( ( $37 ) + ( $38 << 2 ) | 0 ) ; $40 = HEAP32 [ $39 >> 2 ] | 0 ; $41 = ( ( $35 ) + ( $40 << 2 ) | 0 ) ; $42 = HEAP16 [ $41 >> 1 ] | 0 ; $43 = $42 & 65535 ; $44 = ( $34 | 0 ) < ( $43 | 0 ) ; if ( ! ( $44 ) ) { $45 = $4 ; $46 = $3 ; $47 = ( ( ( $46 ) ) + 2908 | 0 ) ; $48 = $7 ; $49 = ( ( $48 ) + 1 ) | 0 ; $50 = ( ( $47 ) + ( $49 << 2 ) | 0 ) ; $51 = HEAP32 [ $50 >> 2 ] | 0 ; $52 = ( ( $45 ) + ( $51 << 2 ) | 0 ) ; $53 = HEAP16 [ $52 >> 1 ] | 0 ; $54 = $53 & 65535 ; $55 = $4 ; $56 = $3 ; $57 = ( ( ( $56 ) ) + 2908 | 0 ) ; $58 = $7 ; $59 = ( ( $57 ) + ( $58 << 2 ) | 0 ) ; $60 = HEAP32 [ $59 >> 2 ] | 0 ; $61 = ( ( $55 ) + ( $60 << 2 ) | 0 ) ; $62 = HEAP16 [ $61 >> 1 ] | 0 ; $63 = $62 & 65535 ; $64 = ( $54 | 0 ) == ( $63 | 0 ) ; if ( ! ( $64 ) ) { break ; } $65 = $3 ; $66 = ( ( ( $65 ) ) + 5208 | 0 ) ; $67 = $3 ; $68 = ( ( ( $67 ) ) + 2908 | 0 ) ; $69 = $7 ; $70 = ( ( $69 ) + 1 ) | 0 ; $71 = ( ( $68 ) + ( $70 << 2 ) | 0 ) ; $72 = HEAP32 [ $71 >> 2 ] | 0 ; $73 = ( ( $66 ) + ( $72 ) | 0 ) ; $74 = HEAP8 [ $73 >> 0 ] | 0 ; $75 = $74 & 255 ; $76 = $3 ; $77 = ( ( ( $76 ) ) + 5208 | 0 ) ; $78 = $3 ; $79 = ( ( ( $78 ) ) + 2908 | 0 ) ; $80 = $7 ; $81 = ( ( $79 ) + ( $80 << 2 ) | 0 ) ; $82 = HEAP32 [ $81 >> 2 ] | 0 ; $83 = ( ( $77 ) + ( $82 ) | 0 ) ; $84 = HEAP8 [ $83 >> 0 ] | 0 ; $85 = $84 & 255 ; $86 = ( $75 | 0 ) <= ( $85 | 0 ) ; if ( ! ( $86 ) ) { break ; } } $87 = $7 ; $88 = ( ( $87 ) + 1 ) | 0 ; $7 = $88 ; } } while ( 0 ) ; $89 = $4 ; $90 = $6 ; $91 = ( ( $89 ) + ( $90 << 2 ) | 0 ) ; $92 = HEAP16 [ $91 >> 1 ] | 0 ; $93 = $92 & 65535 ; $94 = $4 ; $95 = $3 ; $96 = ( ( ( $95 ) ) + 2908 | 0 ) ; $97 = $7 ; $98 = ( ( $96 ) + ( $97 << 2 ) | 0 ) ; $99 = HEAP32 [ $98 >> 2 ] | 0 ; $100 = ( ( $94 ) + ( $99 << 2 ) | 0 ) ; $101 = HEAP16 [ $100 >> 1 ] | 0 ; $102 = $101 & 65535 ; $103 = ( $93 | 0 ) < ( $102 | 0 ) ; if ( $103 ) { label = 12 ; break ; } $104 = $4 ; $105 = $6 ; $106 = ( ( $104 ) + ( $105 << 2 ) | 0 ) ; $107 = HEAP16 [ $106 >> 1 ] | 0 ; $108 = $107 & 65535 ; $109 = $4 ; $110 = $3 ; $111 = ( ( ( $110 ) ) + 2908 | 0 ) ; $112 = $7 ; $113 = ( ( $111 ) + ( $112 << 2 ) | 0 ) ; $114 = HEAP32 [ $113 >> 2 ] | 0 ; $115 = ( ( $109 ) + ( $114 << 2 ) | 0 ) ; $116 = HEAP16 [ $115 >> 1 ] | 0 ; $117 = $116 & 65535 ; $118 = ( $108 | 0 ) == ( $117 | 0 ) ; if ( $118 ) { $119 = $3 ; $120 = ( ( ( $119 ) ) + 5208 | 0 ) ; $121 = $6 ; $122 = ( ( $120 ) + ( $121 ) | 0 ) ; $123 = HEAP8 [ $122 >> 0 ] | 0 ; $124 = $123 & 255 ; $125 = $3 ; $126 = ( ( ( $125 ) ) + 5208 | 0 ) ; $127 = $3 ; $128 = ( ( ( $127 ) ) + 2908 | 0 ) ; $129 = $7 ; $130 = ( ( $128 ) + ( $129 << 2 ) | 0 ) ; $131 = HEAP32 [ $130 >> 2 ] | 0 ; $132 = ( ( $126 ) + ( $131 ) | 0 ) ; $133 = HEAP8 [ $132 >> 0 ] | 0 ; $134 = $133 & 255 ; $135 = ( $124 | 0 ) <= ( $134 | 0 ) ; if ( $135 ) { label = 12 ; break ; } } $136 = $3 ; $137 = ( ( ( $136 ) ) + 2908 | 0 ) ; $138 = $7 ; $139 = ( ( $137 ) + ( $138 << 2 ) | 0 ) ; $140 = HEAP32 [ $139 >> 2 ] | 0 ; $141 = $3 ; $142 = ( ( ( $141 ) ) + 2908 | 0 ) ; $143 = $5 ; $144 = ( ( $142 ) + ( $143 << 2 ) | 0 ) ; HEAP32 [ $144 >> 2 ] = $140 ; $145 = $7 ; $5 = $145 ; $146 = $7 ; $147 = $146 << 1 ; $7 = $147 ; } if ( ( label | 0 ) == 12 ) { $148 = $6 ; $149 = $3 ; $150 = ( ( ( $149 ) ) + 2908 | 0 ) ; $151 = $5 ; $152 = ( ( $150 ) + ( $151 << 2 ) | 0 ) ; HEAP32 [ $152 >> 2 ] = $148 ; STACKTOP = sp ; return ; } } function _gen_bitlen ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 ; var $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 ; var $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 ; var $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 ; var $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $2 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 ; var $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 ; var $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 ; var $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 ; var $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 ; var $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 64 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 64 | 0 ) ; $2 = $0 ; $3 = $1 ; $17 = $3 ; $18 = HEAP32 [ $17 >> 2 ] | 0 ; $4 = $18 ; $19 = $3 ; $20 = ( ( ( $19 ) ) + 4 | 0 ) ; $21 = HEAP32 [ $20 >> 2 ] | 0 ; $5 = $21 ; $22 = $3 ; $23 = ( ( ( $22 ) ) + 8 | 0 ) ; $24 = HEAP32 [ $23 >> 2 ] | 0 ; $25 = HEAP32 [ $24 >> 2 ] | 0 ; $6 = $25 ; $26 = $3 ; $27 = ( ( ( $26 ) ) + 8 | 0 ) ; $28 = HEAP32 [ $27 >> 2 ] | 0 ; $29 = ( ( ( $28 ) ) + 4 | 0 ) ; $30 = HEAP32 [ $29 >> 2 ] | 0 ; $7 = $30 ; $31 = $3 ; $32 = ( ( ( $31 ) ) + 8 | 0 ) ; $33 = HEAP32 [ $32 >> 2 ] | 0 ; $34 = ( ( ( $33 ) ) + 8 | 0 ) ; $35 = HEAP32 [ $34 >> 2 ] | 0 ; $8 = $35 ; $36 = $3 ; $37 = ( ( ( $36 ) ) + 8 | 0 ) ; $38 = HEAP32 [ $37 >> 2 ] | 0 ; $39 = ( ( ( $38 ) ) + 16 | 0 ) ; $40 = HEAP32 [ $39 >> 2 ] | 0 ; $9 = $40 ; $16 = 0 ; $13 = 0 ; while ( 1 ) { $41 = $13 ; $42 = ( $41 | 0 ) <= ( 15 ) ; if ( ! ( $42 ) ) { break ; } $43 = $2 ; $44 = ( ( ( $43 ) ) + 2876 | 0 ) ; $45 = $13 ; $46 = ( ( $44 ) + ( $45 << 1 ) | 0 ) ; HEAP16 [ $46 >> 1 ] = 0 ; $47 = $13 ; $48 = ( ( $47 ) + 1 ) | 0 ; $13 = $48 ; } $49 = $4 ; $50 = $2 ; $51 = ( ( ( $50 ) ) + 2908 | 0 ) ; $52 = $2 ; $53 = ( ( ( $52 ) ) + 5204 | 0 ) ; $54 = HEAP32 [ $53 >> 2 ] | 0 ; $55 = ( ( $51 ) + ( $54 << 2 ) | 0 ) ; $56 = HEAP32 [ $55 >> 2 ] | 0 ; $57 = ( ( $49 ) + ( $56 << 2 ) | 0 ) ; $58 = ( ( ( $57 ) ) + 2 | 0 ) ; HEAP16 [ $58 >> 1 ] = 0 ; $59 = $2 ; $60 = ( ( ( $59 ) ) + 5204 | 0 ) ; $61 = HEAP32 [ $60 >> 2 ] | 0 ; $62 = ( ( $61 ) + 1 ) | 0 ; $10 = $62 ; while ( 1 ) { $63 = $10 ; $64 = ( $63 | 0 ) < ( 573 ) ; if ( ! ( $64 ) ) { break ; } $65 = $2 ; $66 = ( ( ( $65 ) ) + 2908 | 0 ) ; $67 = $10 ; $68 = ( ( $66 ) + ( $67 << 2 ) | 0 ) ; $69 = HEAP32 [ $68 >> 2 ] | 0 ; $11 = $69 ; $70 = $4 ; $71 = $4 ; $72 = $11 ; $73 = ( ( $71 ) + ( $72 << 2 ) | 0 ) ; $74 = ( ( ( $73 ) ) + 2 | 0 ) ; $75 = HEAP16 [ $74 >> 1 ] | 0 ; $76 = $75 & 65535 ; $77 = ( ( $70 ) + ( $76 << 2 ) | 0 ) ; $78 = ( ( ( $77 ) ) + 2 | 0 ) ; $79 = HEAP16 [ $78 >> 1 ] | 0 ; $80 = $79 & 65535 ; $81 = ( ( $80 ) + 1 ) | 0 ; $13 = $81 ; $82 = $13 ; $83 = $9 ; $84 = ( $82 | 0 ) > ( $83 | 0 ) ; if ( $84 ) { $85 = $9 ; $13 = $85 ; $86 = $16 ; $87 = ( ( $86 ) + 1 ) | 0 ; $16 = $87 ; } $88 = $13 ; $89 = $88 & 65535 ; $90 = $4 ; $91 = $11 ; $92 = ( ( $90 ) + ( $91 << 2 ) | 0 ) ; $93 = ( ( ( $92 ) ) + 2 | 0 ) ; HEAP16 [ $93 >> 1 ] = $89 ; $94 = $11 ; $95 = $5 ; $96 = ( $94 | 0 ) > ( $95 | 0 ) ; if ( ! ( $96 ) ) { $97 = $2 ; $98 = ( ( ( $97 ) ) + 2876 | 0 ) ; $99 = $13 ; $100 = ( ( $98 ) + ( $99 << 1 ) | 0 ) ; $101 = HEAP16 [ $100 >> 1 ] | 0 ; $102 = ( ( $101 ) + 1 ) << 16 >> 16 ; HEAP16 [ $100 >> 1 ] = $102 ; $14 = 0 ; $103 = $11 ; $104 = $8 ; $105 = ( $103 | 0 ) >= ( $104 | 0 ) ; if ( $105 ) { $106 = $7 ; $107 = $11 ; $108 = $8 ; $109 = ( ( $107 ) - ( $108 ) ) | 0 ; $110 = ( ( $106 ) + ( $109 << 2 ) | 0 ) ; $111 = HEAP32 [ $110 >> 2 ] | 0 ; $14 = $111 ; } $112 = $4 ; $113 = $11 ; $114 = ( ( $112 ) + ( $113 << 2 ) | 0 ) ; $115 = HEAP16 [ $114 >> 1 ] | 0 ; $15 = $115 ; $116 = $15 ; $117 = $116 & 65535 ; $118 = $13 ; $119 = $14 ; $120 = ( ( $118 ) + ( $119 ) ) | 0 ; $121 = Math_imul ( $117 , $120 ) | 0 ; $122 = $2 ; $123 = ( ( ( $122 ) ) + 5800 | 0 ) ; $124 = HEAP32 [ $123 >> 2 ] | 0 ; $125 = ( ( $124 ) + ( $121 ) ) | 0 ; HEAP32 [ $123 >> 2 ] = $125 ; $126 = $6 ; $127 = ( $126 | 0 ) != ( 0 | 0 ) ; if ( $127 ) { $128 = $15 ; $129 = $128 & 65535 ; $130 = $6 ; $131 = $11 ; $132 = ( ( $130 ) + ( $131 << 2 ) | 0 ) ; $133 = ( ( ( $132 ) ) + 2 | 0 ) ; $134 = HEAP16 [ $133 >> 1 ] | 0 ; $135 = $134 & 65535 ; $136 = $14 ; $137 = ( ( $135 ) + ( $136 ) ) | 0 ; $138 = Math_imul ( $129 , $137 ) | 0 ; $139 = $2 ; $140 = ( ( ( $139 ) ) + 5804 | 0 ) ; $141 = HEAP32 [ $140 >> 2 ] | 0 ; $142 = ( ( $141 ) + ( $138 ) ) | 0 ; HEAP32 [ $140 >> 2 ] = $142 ; } } $143 = $10 ; $144 = ( ( $143 ) + 1 ) | 0 ; $10 = $144 ; } $145 = $16 ; $146 = ( $145 | 0 ) == ( 0 ) ; if ( $146 ) { STACKTOP = sp ; return ; } while ( 1 ) { $147 = $9 ; $148 = ( ( $147 ) - 1 ) | 0 ; $13 = $148 ; while ( 1 ) { $149 = $2 ; $150 = ( ( ( $149 ) ) + 2876 | 0 ) ; $151 = $13 ; $152 = ( ( $150 ) + ( $151 << 1 ) | 0 ) ; $153 = HEAP16 [ $152 >> 1 ] | 0 ; $154 = $153 & 65535 ; $155 = ( $154 | 0 ) == ( 0 ) ; if ( ! ( $155 ) ) { break ; } $156 = $13 ; $157 = ( ( $156 ) + - 1 ) | 0 ; $13 = $157 ; } $158 = $2 ; $159 = ( ( ( $158 ) ) + 2876 | 0 ) ; $160 = $13 ; $161 = ( ( $159 ) + ( $160 << 1 ) | 0 ) ; $162 = HEAP16 [ $161 >> 1 ] | 0 ; $163 = ( ( $162 ) + - 1 ) << 16 >> 16 ; HEAP16 [ $161 >> 1 ] = $163 ; $164 = $2 ; $165 = ( ( ( $164 ) ) + 2876 | 0 ) ; $166 = $13 ; $167 = ( ( $166 ) + 1 ) | 0 ; $168 = ( ( $165 ) + ( $167 << 1 ) | 0 ) ; $169 = HEAP16 [ $168 >> 1 ] | 0 ; $170 = $169 & 65535 ; $171 = ( ( $170 ) + 2 ) | 0 ; $172 = $171 & 65535 ; HEAP16 [ $168 >> 1 ] = $172 ; $173 = $2 ; $174 = ( ( ( $173 ) ) + 2876 | 0 ) ; $175 = $9 ; $176 = ( ( $174 ) + ( $175 << 1 ) | 0 ) ; $177 = HEAP16 [ $176 >> 1 ] | 0 ; $178 = ( ( $177 ) + - 1 ) << 16 >> 16 ; HEAP16 [ $176 >> 1 ] = $178 ; $179 = $16 ; $180 = ( ( $179 ) - 2 ) | 0 ; $16 = $180 ; $181 = $16 ; $182 = ( $181 | 0 ) > ( 0 ) ; if ( ! ( $182 ) ) { break ; } } $183 = $9 ; $13 = $183 ; while ( 1 ) { $184 = $13 ; $185 = ( $184 | 0 ) != ( 0 ) ; if ( ! ( $185 ) ) { break ; } $186 = $2 ; $187 = ( ( ( $186 ) ) + 2876 | 0 ) ; $188 = $13 ; $189 = ( ( $187 ) + ( $188 << 1 ) | 0 ) ; $190 = HEAP16 [ $189 >> 1 ] | 0 ; $191 = $190 & 65535 ; $11 = $191 ; while ( 1 ) { $192 = $11 ; $193 = ( $192 | 0 ) != ( 0 ) ; if ( ! ( $193 ) ) { break ; } $194 = $2 ; $195 = ( ( ( $194 ) ) + 2908 | 0 ) ; $196 = $10 ; $197 = ( ( $196 ) + - 1 ) | 0 ; $10 = $197 ; $198 = ( ( $195 ) + ( $197 << 2 ) | 0 ) ; $199 = HEAP32 [ $198 >> 2 ] | 0 ; $12 = $199 ; $200 = $12 ; $201 = $5 ; $202 = ( $200 | 0 ) > ( $201 | 0 ) ; if ( $202 ) { continue ; } $203 = $4 ; $204 = $12 ; $205 = ( ( $203 ) + ( $204 << 2 ) | 0 ) ; $206 = ( ( ( $205 ) ) + 2 | 0 ) ; $207 = HEAP16 [ $206 >> 1 ] | 0 ; $208 = $207 & 65535 ; $209 = $13 ; $210 = ( $208 | 0 ) != ( $209 | 0 ) ; if ( $210 ) { $211 = $13 ; $212 = $4 ; $213 = $12 ; $214 = ( ( $212 ) + ( $213 << 2 ) | 0 ) ; $215 = ( ( ( $214 ) ) + 2 | 0 ) ; $216 = HEAP16 [ $215 >> 1 ] | 0 ; $217 = $216 & 65535 ; $218 = ( ( $211 ) - ( $217 ) ) | 0 ; $219 = $4 ; $220 = $12 ; $221 = ( ( $219 ) + ( $220 << 2 ) | 0 ) ; $222 = HEAP16 [ $221 >> 1 ] | 0 ; $223 = $222 & 65535 ; $224 = Math_imul ( $218 , $223 ) | 0 ; $225 = $2 ; $226 = ( ( ( $225 ) ) + 5800 | 0 ) ; $227 = HEAP32 [ $226 >> 2 ] | 0 ; $228 = ( ( $227 ) + ( $224 ) ) | 0 ; HEAP32 [ $226 >> 2 ] = $228 ; $229 = $13 ; $230 = $229 & 65535 ; $231 = $4 ; $232 = $12 ; $233 = ( ( $231 ) + ( $232 << 2 ) | 0 ) ; $234 = ( ( ( $233 ) ) + 2 | 0 ) ; HEAP16 [ $234 >> 1 ] = $230 ; } $235 = $11 ; $236 = ( ( $235 ) + - 1 ) | 0 ; $11 = $236 ; } $237 = $13 ; $238 = ( ( $237 ) + - 1 ) | 0 ; $13 = $238 ; } STACKTOP = sp ; return ; } function _gen_codes ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 ; var $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 64 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 64 | 0 ) ; $6 = sp + 32 | 0 ; $3 = $0 ; $4 = $1 ; $5 = $2 ; $7 = 0 ; $8 = 1 ; while ( 1 ) { $11 = $8 ; $12 = ( $11 | 0 ) <= ( 15 ) ; if ( ! ( $12 ) ) { break ; } $13 = $7 ; $14 = $5 ; $15 = $8 ; $16 = ( ( $15 ) - 1 ) | 0 ; $17 = ( ( $14 ) + ( $16 << 1 ) | 0 ) ; $18 = HEAP16 [ $17 >> 1 ] | 0 ; $19 = $18 & 65535 ; $20 = ( ( $13 ) + ( $19 ) ) | 0 ; $21 = $20 << 1 ; $7 = $21 ; $22 = $7 ; $23 = $22 & 65535 ; $24 = $8 ; $25 = ( ( $6 ) + ( $24 << 1 ) | 0 ) ; HEAP16 [ $25 >> 1 ] = $23 ; $26 = $8 ; $27 = ( ( $26 ) + 1 ) | 0 ; $8 = $27 ; } $9 = 0 ; while ( 1 ) { $28 = $9 ; $29 = $4 ; $30 = ( $28 | 0 ) <= ( $29 | 0 ) ; if ( ! ( $30 ) ) { break ; } $31 = $3 ; $32 = $9 ; $33 = ( ( $31 ) + ( $32 << 2 ) | 0 ) ; $34 = ( ( ( $33 ) ) + 2 | 0 ) ; $35 = HEAP16 [ $34 >> 1 ] | 0 ; $36 = $35 & 65535 ; $10 = $36 ; $37 = $10 ; $38 = ( $37 | 0 ) == ( 0 ) ; if ( ! ( $38 ) ) { $39 = $10 ; $40 = ( ( $6 ) + ( $39 << 1 ) | 0 ) ; $41 = HEAP16 [ $40 >> 1 ] | 0 ; $42 = ( ( $41 ) + 1 ) << 16 >> 16 ; HEAP16 [ $40 >> 1 ] = $42 ; $43 = $41 & 65535 ; $44 = $10 ; $45 = ( _bi_reverse ( $43 , $44 ) | 0 ) ; $46 = $45 & 65535 ; $47 = $3 ; $48 = $9 ; $49 = ( ( $47 ) + ( $48 << 2 ) | 0 ) ; HEAP16 [ $49 >> 1 ] = $46 ; } $50 = $9 ; $51 = ( ( $50 ) + 1 ) | 0 ; $9 = $51 ; } STACKTOP = sp ; return ; } function _bi_reverse ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = $0 ; $3 = $1 ; $4 = 0 ; while ( 1 ) { $5 = $2 ; $6 = $5 & 1 ; $7 = $4 ; $8 = $7 | $6 ; $4 = $8 ; $9 = $2 ; $10 = $9 >>> 1 ; $2 = $10 ; $11 = $4 ; $12 = $11 << 1 ; $4 = $12 ; $13 = $3 ; $14 = ( ( $13 ) + - 1 ) | 0 ; $3 = $14 ; $15 = ( $14 | 0 ) > ( 0 ) ; if ( ! ( $15 ) ) { break ; } } $16 = $4 ; $17 = $16 >>> 1 ; STACKTOP = sp ; return ( $17 | 0 ) ; } function _zlibVersion ( ) { var label = 0 , sp = 0 ; sp = STACKTOP ; return ( 29663 | 0 ) ; } function _zcalloc ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $3 = $0 ; $4 = $1 ; $5 = $2 ; $6 = $4 ; $7 = $5 ; $8 = Math_imul ( $6 , $7 ) | 0 ; $9 = ( _malloc ( $8 ) | 0 ) ; STACKTOP = sp ; return ( $9 | 0 ) ; } function _zcfree ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $2 = 0 , $3 = 0 , $4 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = $0 ; $3 = $1 ; $4 = $3 ; _free ( $4 ) ; STACKTOP = sp ; return ; } function _adler32_z ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 ; var $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 ; var $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 ; var $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 ; var $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 , $208 = 0 ; var $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 , $226 = 0 ; var $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 , $244 = 0 ; var $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 , $258 = 0 , $259 = 0 , $26 = 0 , $260 = 0 , $261 = 0 , $262 = 0 ; var $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 , $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 , $270 = 0 , $271 = 0 , $272 = 0 , $273 = 0 , $274 = 0 , $275 = 0 , $276 = 0 , $277 = 0 , $278 = 0 , $279 = 0 , $28 = 0 , $280 = 0 ; var $281 = 0 , $282 = 0 , $283 = 0 , $284 = 0 , $285 = 0 , $286 = 0 , $287 = 0 , $288 = 0 , $289 = 0 , $29 = 0 , $290 = 0 , $291 = 0 , $292 = 0 , $293 = 0 , $294 = 0 , $295 = 0 , $296 = 0 , $297 = 0 , $298 = 0 , $299 = 0 ; var $3 = 0 , $30 = 0 , $300 = 0 , $301 = 0 , $302 = 0 , $303 = 0 , $304 = 0 , $305 = 0 , $306 = 0 , $307 = 0 , $308 = 0 , $309 = 0 , $31 = 0 , $310 = 0 , $311 = 0 , $312 = 0 , $313 = 0 , $314 = 0 , $315 = 0 , $316 = 0 ; var $317 = 0 , $318 = 0 , $319 = 0 , $32 = 0 , $320 = 0 , $321 = 0 , $322 = 0 , $323 = 0 , $324 = 0 , $325 = 0 , $326 = 0 , $327 = 0 , $328 = 0 , $329 = 0 , $33 = 0 , $330 = 0 , $331 = 0 , $332 = 0 , $333 = 0 , $334 = 0 ; var $335 = 0 , $336 = 0 , $337 = 0 , $338 = 0 , $339 = 0 , $34 = 0 , $340 = 0 , $341 = 0 , $342 = 0 , $343 = 0 , $344 = 0 , $345 = 0 , $346 = 0 , $347 = 0 , $348 = 0 , $349 = 0 , $35 = 0 , $350 = 0 , $351 = 0 , $352 = 0 ; var $353 = 0 , $354 = 0 , $355 = 0 , $356 = 0 , $357 = 0 , $358 = 0 , $359 = 0 , $36 = 0 , $360 = 0 , $361 = 0 , $362 = 0 , $363 = 0 , $364 = 0 , $365 = 0 , $366 = 0 , $367 = 0 , $368 = 0 , $369 = 0 , $37 = 0 , $370 = 0 ; var $371 = 0 , $372 = 0 , $373 = 0 , $374 = 0 , $375 = 0 , $376 = 0 , $377 = 0 , $378 = 0 , $379 = 0 , $38 = 0 , $380 = 0 , $381 = 0 , $382 = 0 , $383 = 0 , $384 = 0 , $385 = 0 , $386 = 0 , $387 = 0 , $39 = 0 , $4 = 0 ; var $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 ; var $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 ; var $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 ; var $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $9 = $4 ; $10 = $9 >>> 16 ; $11 = $10 & 65535 ; $7 = $11 ; $12 = $4 ; $13 = $12 & 65535 ; $4 = $13 ; $14 = $6 ; $15 = ( $14 | 0 ) == ( 1 ) ; $16 = $5 ; if ( $15 ) { $17 = HEAP8 [ $16 >> 0 ] | 0 ; $18 = $17 & 255 ; $19 = $4 ; $20 = ( ( $19 ) + ( $18 ) ) | 0 ; $4 = $20 ; $21 = $4 ; $22 = ( $21 >>> 0 ) >= ( 65521 ) ; if ( $22 ) { $23 = $4 ; $24 = ( ( $23 ) - 65521 ) | 0 ; $4 = $24 ; } $25 = $4 ; $26 = $7 ; $27 = ( ( $26 ) + ( $25 ) ) | 0 ; $7 = $27 ; $28 = $7 ; $29 = ( $28 >>> 0 ) >= ( 65521 ) ; if ( $29 ) { $30 = $7 ; $31 = ( ( $30 ) - 65521 ) | 0 ; $7 = $31 ; } $32 = $4 ; $33 = $7 ; $34 = $33 << 16 ; $35 = $32 | $34 ; $3 = $35 ; $387 = $3 ; STACKTOP = sp ; return ( $387 | 0 ) ; } $36 = ( $16 | 0 ) == ( 0 | 0 ) ; if ( $36 ) { $3 = 1 ; $387 = $3 ; STACKTOP = sp ; return ( $387 | 0 ) ; } $37 = $6 ; $38 = ( $37 >>> 0 ) < ( 16 ) ; if ( $38 ) { while ( 1 ) { $39 = $6 ; $40 = ( ( $39 ) + - 1 ) | 0 ; $6 = $40 ; $41 = ( $39 | 0 ) != ( 0 ) ; if ( ! ( $41 ) ) { break ; } $42 = $5 ; $43 = ( ( ( $42 ) ) + 1 | 0 ) ; $5 = $43 ; $44 = HEAP8 [ $42 >> 0 ] | 0 ; $45 = $44 & 255 ; $46 = $4 ; $47 = ( ( $46 ) + ( $45 ) ) | 0 ; $4 = $47 ; $48 = $4 ; $49 = $7 ; $50 = ( ( $49 ) + ( $48 ) ) | 0 ; $7 = $50 ; } $51 = $4 ; $52 = ( $51 >>> 0 ) >= ( 65521 ) ; if ( $52 ) { $53 = $4 ; $54 = ( ( $53 ) - 65521 ) | 0 ; $4 = $54 ; } $55 = $7 ; $56 = ( ( $55 >>> 0 ) % 65521 ) & - 1 ; $7 = $56 ; $57 = $4 ; $58 = $7 ; $59 = $58 << 16 ; $60 = $57 | $59 ; $3 = $60 ; $387 = $3 ; STACKTOP = sp ; return ( $387 | 0 ) ; } while ( 1 ) { $61 = $6 ; $62 = ( $61 >>> 0 ) >= ( 5552 ) ; $63 = $6 ; if ( ! ( $62 ) ) { break ; } $64 = ( ( $63 ) - 5552 ) | 0 ; $6 = $64 ; $8 = 347 ; while ( 1 ) { $65 = $5 ; $66 = HEAP8 [ $65 >> 0 ] | 0 ; $67 = $66 & 255 ; $68 = $4 ; $69 = ( ( $68 ) + ( $67 ) ) | 0 ; $4 = $69 ; $70 = $4 ; $71 = $7 ; $72 = ( ( $71 ) + ( $70 ) ) | 0 ; $7 = $72 ; $73 = $5 ; $74 = ( ( ( $73 ) ) + 1 | 0 ) ; $75 = HEAP8 [ $74 >> 0 ] | 0 ; $76 = $75 & 255 ; $77 = $4 ; $78 = ( ( $77 ) + ( $76 ) ) | 0 ; $4 = $78 ; $79 = $4 ; $80 = $7 ; $81 = ( ( $80 ) + ( $79 ) ) | 0 ; $7 = $81 ; $82 = $5 ; $83 = ( ( ( $82 ) ) + 2 | 0 ) ; $84 = HEAP8 [ $83 >> 0 ] | 0 ; $85 = $84 & 255 ; $86 = $4 ; $87 = ( ( $86 ) + ( $85 ) ) | 0 ; $4 = $87 ; $88 = $4 ; $89 = $7 ; $90 = ( ( $89 ) + ( $88 ) ) | 0 ; $7 = $90 ; $91 = $5 ; $92 = ( ( ( $91 ) ) + 3 | 0 ) ; $93 = HEAP8 [ $92 >> 0 ] | 0 ; $94 = $93 & 255 ; $95 = $4 ; $96 = ( ( $95 ) + ( $94 ) ) | 0 ; $4 = $96 ; $97 = $4 ; $98 = $7 ; $99 = ( ( $98 ) + ( $97 ) ) | 0 ; $7 = $99 ; $100 = $5 ; $101 = ( ( ( $100 ) ) + 4 | 0 ) ; $102 = HEAP8 [ $101 >> 0 ] | 0 ; $103 = $102 & 255 ; $104 = $4 ; $105 = ( ( $104 ) + ( $103 ) ) | 0 ; $4 = $105 ; $106 = $4 ; $107 = $7 ; $108 = ( ( $107 ) + ( $106 ) ) | 0 ; $7 = $108 ; $109 = $5 ; $110 = ( ( ( $109 ) ) + 5 | 0 ) ; $111 = HEAP8 [ $110 >> 0 ] | 0 ; $112 = $111 & 255 ; $113 = $4 ; $114 = ( ( $113 ) + ( $112 ) ) | 0 ; $4 = $114 ; $115 = $4 ; $116 = $7 ; $117 = ( ( $116 ) + ( $115 ) ) | 0 ; $7 = $117 ; $118 = $5 ; $119 = ( ( ( $118 ) ) + 6 | 0 ) ; $120 = HEAP8 [ $119 >> 0 ] | 0 ; $121 = $120 & 255 ; $122 = $4 ; $123 = ( ( $122 ) + ( $121 ) ) | 0 ; $4 = $123 ; $124 = $4 ; $125 = $7 ; $126 = ( ( $125 ) + ( $124 ) ) | 0 ; $7 = $126 ; $127 = $5 ; $128 = ( ( ( $127 ) ) + 7 | 0 ) ; $129 = HEAP8 [ $128 >> 0 ] | 0 ; $130 = $129 & 255 ; $131 = $4 ; $132 = ( ( $131 ) + ( $130 ) ) | 0 ; $4 = $132 ; $133 = $4 ; $134 = $7 ; $135 = ( ( $134 ) + ( $133 ) ) | 0 ; $7 = $135 ; $136 = $5 ; $137 = ( ( ( $136 ) ) + 8 | 0 ) ; $138 = HEAP8 [ $137 >> 0 ] | 0 ; $139 = $138 & 255 ; $140 = $4 ; $141 = ( ( $140 ) + ( $139 ) ) | 0 ; $4 = $141 ; $142 = $4 ; $143 = $7 ; $144 = ( ( $143 ) + ( $142 ) ) | 0 ; $7 = $144 ; $145 = $5 ; $146 = ( ( ( $145 ) ) + 9 | 0 ) ; $147 = HEAP8 [ $146 >> 0 ] | 0 ; $148 = $147 & 255 ; $149 = $4 ; $150 = ( ( $149 ) + ( $148 ) ) | 0 ; $4 = $150 ; $151 = $4 ; $152 = $7 ; $153 = ( ( $152 ) + ( $151 ) ) | 0 ; $7 = $153 ; $154 = $5 ; $155 = ( ( ( $154 ) ) + 10 | 0 ) ; $156 = HEAP8 [ $155 >> 0 ] | 0 ; $157 = $156 & 255 ; $158 = $4 ; $159 = ( ( $158 ) + ( $157 ) ) | 0 ; $4 = $159 ; $160 = $4 ; $161 = $7 ; $162 = ( ( $161 ) + ( $160 ) ) | 0 ; $7 = $162 ; $163 = $5 ; $164 = ( ( ( $163 ) ) + 11 | 0 ) ; $165 = HEAP8 [ $164 >> 0 ] | 0 ; $166 = $165 & 255 ; $167 = $4 ; $168 = ( ( $167 ) + ( $166 ) ) | 0 ; $4 = $168 ; $169 = $4 ; $170 = $7 ; $171 = ( ( $170 ) + ( $169 ) ) | 0 ; $7 = $171 ; $172 = $5 ; $173 = ( ( ( $172 ) ) + 12 | 0 ) ; $174 = HEAP8 [ $173 >> 0 ] | 0 ; $175 = $174 & 255 ; $176 = $4 ; $177 = ( ( $176 ) + ( $175 ) ) | 0 ; $4 = $177 ; $178 = $4 ; $179 = $7 ; $180 = ( ( $179 ) + ( $178 ) ) | 0 ; $7 = $180 ; $181 = $5 ; $182 = ( ( ( $181 ) ) + 13 | 0 ) ; $183 = HEAP8 [ $182 >> 0 ] | 0 ; $184 = $183 & 255 ; $185 = $4 ; $186 = ( ( $185 ) + ( $184 ) ) | 0 ; $4 = $186 ; $187 = $4 ; $188 = $7 ; $189 = ( ( $188 ) + ( $187 ) ) | 0 ; $7 = $189 ; $190 = $5 ; $191 = ( ( ( $190 ) ) + 14 | 0 ) ; $192 = HEAP8 [ $191 >> 0 ] | 0 ; $193 = $192 & 255 ; $194 = $4 ; $195 = ( ( $194 ) + ( $193 ) ) | 0 ; $4 = $195 ; $196 = $4 ; $197 = $7 ; $198 = ( ( $197 ) + ( $196 ) ) | 0 ; $7 = $198 ; $199 = $5 ; $200 = ( ( ( $199 ) ) + 15 | 0 ) ; $201 = HEAP8 [ $200 >> 0 ] | 0 ; $202 = $201 & 255 ; $203 = $4 ; $204 = ( ( $203 ) + ( $202 ) ) | 0 ; $4 = $204 ; $205 = $4 ; $206 = $7 ; $207 = ( ( $206 ) + ( $205 ) ) | 0 ; $7 = $207 ; $208 = $5 ; $209 = ( ( ( $208 ) ) + 16 | 0 ) ; $5 = $209 ; $210 = $8 ; $211 = ( ( $210 ) + - 1 ) | 0 ; $8 = $211 ; $212 = ( $211 | 0 ) != ( 0 ) ; if ( ! ( $212 ) ) { break ; } } $213 = $4 ; $214 = ( ( $213 >>> 0 ) % 65521 ) & - 1 ; $4 = $214 ; $215 = $7 ; $216 = ( ( $215 >>> 0 ) % 65521 ) & - 1 ; $7 = $216 ; } $217 = ( $63 | 0 ) != ( 0 ) ; if ( $217 ) { while ( 1 ) { $218 = $6 ; $219 = ( $218 >>> 0 ) >= ( 16 ) ; if ( ! ( $219 ) ) { break ; } $220 = $6 ; $221 = ( ( $220 ) - 16 ) | 0 ; $6 = $221 ; $222 = $5 ; $223 = HEAP8 [ $222 >> 0 ] | 0 ; $224 = $223 & 255 ; $225 = $4 ; $226 = ( ( $225 ) + ( $224 ) ) | 0 ; $4 = $226 ; $227 = $4 ; $228 = $7 ; $229 = ( ( $228 ) + ( $227 ) ) | 0 ; $7 = $229 ; $230 = $5 ; $231 = ( ( ( $230 ) ) + 1 | 0 ) ; $232 = HEAP8 [ $231 >> 0 ] | 0 ; $233 = $232 & 255 ; $234 = $4 ; $235 = ( ( $234 ) + ( $233 ) ) | 0 ; $4 = $235 ; $236 = $4 ; $237 = $7 ; $238 = ( ( $237 ) + ( $236 ) ) | 0 ; $7 = $238 ; $239 = $5 ; $240 = ( ( ( $239 ) ) + 2 | 0 ) ; $241 = HEAP8 [ $240 >> 0 ] | 0 ; $242 = $241 & 255 ; $243 = $4 ; $244 = ( ( $243 ) + ( $242 ) ) | 0 ; $4 = $244 ; $245 = $4 ; $246 = $7 ; $247 = ( ( $246 ) + ( $245 ) ) | 0 ; $7 = $247 ; $248 = $5 ; $249 = ( ( ( $248 ) ) + 3 | 0 ) ; $250 = HEAP8 [ $249 >> 0 ] | 0 ; $251 = $250 & 255 ; $252 = $4 ; $253 = ( ( $252 ) + ( $251 ) ) | 0 ; $4 = $253 ; $254 = $4 ; $255 = $7 ; $256 = ( ( $255 ) + ( $254 ) ) | 0 ; $7 = $256 ; $257 = $5 ; $258 = ( ( ( $257 ) ) + 4 | 0 ) ; $259 = HEAP8 [ $258 >> 0 ] | 0 ; $260 = $259 & 255 ; $261 = $4 ; $262 = ( ( $261 ) + ( $260 ) ) | 0 ; $4 = $262 ; $263 = $4 ; $264 = $7 ; $265 = ( ( $264 ) + ( $263 ) ) | 0 ; $7 = $265 ; $266 = $5 ; $267 = ( ( ( $266 ) ) + 5 | 0 ) ; $268 = HEAP8 [ $267 >> 0 ] | 0 ; $269 = $268 & 255 ; $270 = $4 ; $271 = ( ( $270 ) + ( $269 ) ) | 0 ; $4 = $271 ; $272 = $4 ; $273 = $7 ; $274 = ( ( $273 ) + ( $272 ) ) | 0 ; $7 = $274 ; $275 = $5 ; $276 = ( ( ( $275 ) ) + 6 | 0 ) ; $277 = HEAP8 [ $276 >> 0 ] | 0 ; $278 = $277 & 255 ; $279 = $4 ; $280 = ( ( $279 ) + ( $278 ) ) | 0 ; $4 = $280 ; $281 = $4 ; $282 = $7 ; $283 = ( ( $282 ) + ( $281 ) ) | 0 ; $7 = $283 ; $284 = $5 ; $285 = ( ( ( $284 ) ) + 7 | 0 ) ; $286 = HEAP8 [ $285 >> 0 ] | 0 ; $287 = $286 & 255 ; $288 = $4 ; $289 = ( ( $288 ) + ( $287 ) ) | 0 ; $4 = $289 ; $290 = $4 ; $291 = $7 ; $292 = ( ( $291 ) + ( $290 ) ) | 0 ; $7 = $292 ; $293 = $5 ; $294 = ( ( ( $293 ) ) + 8 | 0 ) ; $295 = HEAP8 [ $294 >> 0 ] | 0 ; $296 = $295 & 255 ; $297 = $4 ; $298 = ( ( $297 ) + ( $296 ) ) | 0 ; $4 = $298 ; $299 = $4 ; $300 = $7 ; $301 = ( ( $300 ) + ( $299 ) ) | 0 ; $7 = $301 ; $302 = $5 ; $303 = ( ( ( $302 ) ) + 9 | 0 ) ; $304 = HEAP8 [ $303 >> 0 ] | 0 ; $305 = $304 & 255 ; $306 = $4 ; $307 = ( ( $306 ) + ( $305 ) ) | 0 ; $4 = $307 ; $308 = $4 ; $309 = $7 ; $310 = ( ( $309 ) + ( $308 ) ) | 0 ; $7 = $310 ; $311 = $5 ; $312 = ( ( ( $311 ) ) + 10 | 0 ) ; $313 = HEAP8 [ $312 >> 0 ] | 0 ; $314 = $313 & 255 ; $315 = $4 ; $316 = ( ( $315 ) + ( $314 ) ) | 0 ; $4 = $316 ; $317 = $4 ; $318 = $7 ; $319 = ( ( $318 ) + ( $317 ) ) | 0 ; $7 = $319 ; $320 = $5 ; $321 = ( ( ( $320 ) ) + 11 | 0 ) ; $322 = HEAP8 [ $321 >> 0 ] | 0 ; $323 = $322 & 255 ; $324 = $4 ; $325 = ( ( $324 ) + ( $323 ) ) | 0 ; $4 = $325 ; $326 = $4 ; $327 = $7 ; $328 = ( ( $327 ) + ( $326 ) ) | 0 ; $7 = $328 ; $329 = $5 ; $330 = ( ( ( $329 ) ) + 12 | 0 ) ; $331 = HEAP8 [ $330 >> 0 ] | 0 ; $332 = $331 & 255 ; $333 = $4 ; $334 = ( ( $333 ) + ( $332 ) ) | 0 ; $4 = $334 ; $335 = $4 ; $336 = $7 ; $337 = ( ( $336 ) + ( $335 ) ) | 0 ; $7 = $337 ; $338 = $5 ; $339 = ( ( ( $338 ) ) + 13 | 0 ) ; $340 = HEAP8 [ $339 >> 0 ] | 0 ; $341 = $340 & 255 ; $342 = $4 ; $343 = ( ( $342 ) + ( $341 ) ) | 0 ; $4 = $343 ; $344 = $4 ; $345 = $7 ; $346 = ( ( $345 ) + ( $344 ) ) | 0 ; $7 = $346 ; $347 = $5 ; $348 = ( ( ( $347 ) ) + 14 | 0 ) ; $349 = HEAP8 [ $348 >> 0 ] | 0 ; $350 = $349 & 255 ; $351 = $4 ; $352 = ( ( $351 ) + ( $350 ) ) | 0 ; $4 = $352 ; $353 = $4 ; $354 = $7 ; $355 = ( ( $354 ) + ( $353 ) ) | 0 ; $7 = $355 ; $356 = $5 ; $357 = ( ( ( $356 ) ) + 15 | 0 ) ; $358 = HEAP8 [ $357 >> 0 ] | 0 ; $359 = $358 & 255 ; $360 = $4 ; $361 = ( ( $360 ) + ( $359 ) ) | 0 ; $4 = $361 ; $362 = $4 ; $363 = $7 ; $364 = ( ( $363 ) + ( $362 ) ) | 0 ; $7 = $364 ; $365 = $5 ; $366 = ( ( ( $365 ) ) + 16 | 0 ) ; $5 = $366 ; } while ( 1 ) { $367 = $6 ; $368 = ( ( $367 ) + - 1 ) | 0 ; $6 = $368 ; $369 = ( $367 | 0 ) != ( 0 ) ; if ( ! ( $369 ) ) { break ; } $370 = $5 ; $371 = ( ( ( $370 ) ) + 1 | 0 ) ; $5 = $371 ; $372 = HEAP8 [ $370 >> 0 ] | 0 ; $373 = $372 & 255 ; $374 = $4 ; $375 = ( ( $374 ) + ( $373 ) ) | 0 ; $4 = $375 ; $376 = $4 ; $377 = $7 ; $378 = ( ( $377 ) + ( $376 ) ) | 0 ; $7 = $378 ; } $379 = $4 ; $380 = ( ( $379 >>> 0 ) % 65521 ) & - 1 ; $4 = $380 ; $381 = $7 ; $382 = ( ( $381 >>> 0 ) % 65521 ) & - 1 ; $7 = $382 ; } $383 = $4 ; $384 = $7 ; $385 = $384 << 16 ; $386 = $383 | $385 ; $3 = $386 ; $387 = $3 ; STACKTOP = sp ; return ( $387 | 0 ) ; } function _adler32 ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $3 = $0 ; $4 = $1 ; $5 = $2 ; $6 = $3 ; $7 = $4 ; $8 = $5 ; $9 = ( _adler32_z ( $6 , $7 , $8 ) | 0 ) ; STACKTOP = sp ; return ( $9 | 0 ) ; } function _inflate_fast ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$sink = 0 , $$sink2 = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 ; var $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 ; var $134 = 0 , $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 ; var $152 = 0 , $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 ; var $170 = 0 , $171 = 0 , $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 ; var $189 = 0 , $19 = 0 , $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $2 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 ; var $206 = 0 , $207 = 0 , $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 ; var $224 = 0 , $225 = 0 , $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 ; var $242 = 0 , $243 = 0 , $244 = 0 , $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 , $258 = 0 , $259 = 0 , $26 = 0 ; var $260 = 0 , $261 = 0 , $262 = 0 , $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 , $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 , $270 = 0 , $271 = 0 , $272 = 0 , $273 = 0 , $274 = 0 , $275 = 0 , $276 = 0 , $277 = 0 , $278 = 0 ; var $279 = 0 , $28 = 0 , $280 = 0 , $281 = 0 , $282 = 0 , $283 = 0 , $284 = 0 , $285 = 0 , $286 = 0 , $287 = 0 , $288 = 0 , $289 = 0 , $29 = 0 , $290 = 0 , $291 = 0 , $292 = 0 , $293 = 0 , $294 = 0 , $295 = 0 , $296 = 0 ; var $297 = 0 , $298 = 0 , $299 = 0 , $3 = 0 , $30 = 0 , $300 = 0 , $301 = 0 , $302 = 0 , $303 = 0 , $304 = 0 , $305 = 0 , $306 = 0 , $307 = 0 , $308 = 0 , $309 = 0 , $31 = 0 , $310 = 0 , $311 = 0 , $312 = 0 , $313 = 0 ; var $314 = 0 , $315 = 0 , $316 = 0 , $317 = 0 , $318 = 0 , $319 = 0 , $32 = 0 , $320 = 0 , $321 = 0 , $322 = 0 , $323 = 0 , $324 = 0 , $325 = 0 , $326 = 0 , $327 = 0 , $328 = 0 , $329 = 0 , $33 = 0 , $330 = 0 , $331 = 0 ; var $332 = 0 , $333 = 0 , $334 = 0 , $335 = 0 , $336 = 0 , $337 = 0 , $338 = 0 , $339 = 0 , $34 = 0 , $340 = 0 , $341 = 0 , $342 = 0 , $343 = 0 , $344 = 0 , $345 = 0 , $346 = 0 , $347 = 0 , $348 = 0 , $349 = 0 , $35 = 0 ; var $350 = 0 , $351 = 0 , $352 = 0 , $353 = 0 , $354 = 0 , $355 = 0 , $356 = 0 , $357 = 0 , $358 = 0 , $359 = 0 , $36 = 0 , $360 = 0 , $361 = 0 , $362 = 0 , $363 = 0 , $364 = 0 , $365 = 0 , $366 = 0 , $367 = 0 , $368 = 0 ; var $369 = 0 , $37 = 0 , $370 = 0 , $371 = 0 , $372 = 0 , $373 = 0 , $374 = 0 , $375 = 0 , $376 = 0 , $377 = 0 , $378 = 0 , $379 = 0 , $38 = 0 , $380 = 0 , $381 = 0 , $382 = 0 , $383 = 0 , $384 = 0 , $385 = 0 , $386 = 0 ; var $387 = 0 , $388 = 0 , $389 = 0 , $39 = 0 , $390 = 0 , $391 = 0 , $392 = 0 , $393 = 0 , $394 = 0 , $395 = 0 , $396 = 0 , $397 = 0 , $398 = 0 , $399 = 0 , $4 = 0 , $40 = 0 , $400 = 0 , $401 = 0 , $402 = 0 , $403 = 0 ; var $404 = 0 , $405 = 0 , $406 = 0 , $407 = 0 , $408 = 0 , $409 = 0 , $41 = 0 , $410 = 0 , $411 = 0 , $412 = 0 , $413 = 0 , $414 = 0 , $415 = 0 , $416 = 0 , $417 = 0 , $418 = 0 , $419 = 0 , $42 = 0 , $420 = 0 , $421 = 0 ; var $422 = 0 , $423 = 0 , $424 = 0 , $425 = 0 , $426 = 0 , $427 = 0 , $428 = 0 , $429 = 0 , $43 = 0 , $430 = 0 , $431 = 0 , $432 = 0 , $433 = 0 , $434 = 0 , $435 = 0 , $436 = 0 , $437 = 0 , $438 = 0 , $439 = 0 , $44 = 0 ; var $440 = 0 , $441 = 0 , $442 = 0 , $443 = 0 , $444 = 0 , $445 = 0 , $446 = 0 , $447 = 0 , $448 = 0 , $449 = 0 , $45 = 0 , $450 = 0 , $451 = 0 , $452 = 0 , $453 = 0 , $454 = 0 , $455 = 0 , $456 = 0 , $457 = 0 , $458 = 0 ; var $459 = 0 , $46 = 0 , $460 = 0 , $461 = 0 , $462 = 0 , $463 = 0 , $464 = 0 , $465 = 0 , $466 = 0 , $467 = 0 , $468 = 0 , $469 = 0 , $47 = 0 , $470 = 0 , $471 = 0 , $472 = 0 , $473 = 0 , $474 = 0 , $475 = 0 , $476 = 0 ; var $477 = 0 , $478 = 0 , $479 = 0 , $48 = 0 , $480 = 0 , $481 = 0 , $482 = 0 , $483 = 0 , $484 = 0 , $485 = 0 , $486 = 0 , $487 = 0 , $488 = 0 , $489 = 0 , $49 = 0 , $490 = 0 , $491 = 0 , $492 = 0 , $493 = 0 , $494 = 0 ; var $495 = 0 , $496 = 0 , $497 = 0 , $498 = 0 , $499 = 0 , $5 = 0 , $50 = 0 , $500 = 0 , $501 = 0 , $502 = 0 , $503 = 0 , $504 = 0 , $505 = 0 , $506 = 0 , $507 = 0 , $508 = 0 , $509 = 0 , $51 = 0 , $510 = 0 , $511 = 0 ; var $512 = 0 , $513 = 0 , $514 = 0 , $515 = 0 , $516 = 0 , $517 = 0 , $518 = 0 , $519 = 0 , $52 = 0 , $520 = 0 , $521 = 0 , $522 = 0 , $523 = 0 , $524 = 0 , $525 = 0 , $526 = 0 , $527 = 0 , $528 = 0 , $529 = 0 , $53 = 0 ; var $530 = 0 , $531 = 0 , $532 = 0 , $533 = 0 , $534 = 0 , $535 = 0 , $536 = 0 , $537 = 0 , $538 = 0 , $539 = 0 , $54 = 0 , $540 = 0 , $541 = 0 , $542 = 0 , $543 = 0 , $544 = 0 , $545 = 0 , $546 = 0 , $55 = 0 , $56 = 0 ; var $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 ; var $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 ; var $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 96 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 96 | 0 ) ; $20 = sp + 88 | 0 ; $2 = $0 ; $3 = $1 ; $25 = $2 ; $26 = ( ( ( $25 ) ) + 28 | 0 ) ; $27 = HEAP32 [ $26 >> 2 ] | 0 ; $4 = $27 ; $28 = $2 ; $29 = HEAP32 [ $28 >> 2 ] | 0 ; $5 = $29 ; $30 = $5 ; $31 = $2 ; $32 = ( ( ( $31 ) ) + 4 | 0 ) ; $33 = HEAP32 [ $32 >> 2 ] | 0 ; $34 = ( ( $33 ) - 5 ) | 0 ; $35 = ( ( $30 ) + ( $34 ) | 0 ) ; $6 = $35 ; $36 = $2 ; $37 = ( ( ( $36 ) ) + 12 | 0 ) ; $38 = HEAP32 [ $37 >> 2 ] | 0 ; $7 = $38 ; $39 = $7 ; $40 = $3 ; $41 = $2 ; $42 = ( ( ( $41 ) ) + 16 | 0 ) ; $43 = HEAP32 [ $42 >> 2 ] | 0 ; $44 = ( ( $40 ) - ( $43 ) ) | 0 ; $45 = ( 0 - ( $44 ) ) | 0 ; $46 = ( ( $39 ) + ( $45 ) | 0 ) ; $8 = $46 ; $47 = $7 ; $48 = $2 ; $49 = ( ( ( $48 ) ) + 16 | 0 ) ; $50 = HEAP32 [ $49 >> 2 ] | 0 ; $51 = ( ( $50 ) - 257 ) | 0 ; $52 = ( ( $47 ) + ( $51 ) | 0 ) ; $9 = $52 ; $53 = $4 ; $54 = ( ( ( $53 ) ) + 44 | 0 ) ; $55 = HEAP32 [ $54 >> 2 ] | 0 ; $10 = $55 ; $56 = $4 ; $57 = ( ( ( $56 ) ) + 48 | 0 ) ; $58 = HEAP32 [ $57 >> 2 ] | 0 ; $11 = $58 ; $59 = $4 ; $60 = ( ( ( $59 ) ) + 52 | 0 ) ; $61 = HEAP32 [ $60 >> 2 ] | 0 ; $12 = $61 ; $62 = $4 ; $63 = ( ( ( $62 ) ) + 56 | 0 ) ; $64 = HEAP32 [ $63 >> 2 ] | 0 ; $13 = $64 ; $65 = $4 ; $66 = ( ( ( $65 ) ) + 60 | 0 ) ; $67 = HEAP32 [ $66 >> 2 ] | 0 ; $14 = $67 ; $68 = $4 ; $69 = ( ( ( $68 ) ) + 64 | 0 ) ; $70 = HEAP32 [ $69 >> 2 ] | 0 ; $15 = $70 ; $71 = $4 ; $72 = ( ( ( $71 ) ) + 80 | 0 ) ; $73 = HEAP32 [ $72 >> 2 ] | 0 ; $16 = $73 ; $74 = $4 ; $75 = ( ( ( $74 ) ) + 84 | 0 ) ; $76 = HEAP32 [ $75 >> 2 ] | 0 ; $17 = $76 ; $77 = $4 ; $78 = ( ( ( $77 ) ) + 88 | 0 ) ; $79 = HEAP32 [ $78 >> 2 ] | 0 ; $80 = 1 << $79 ; $81 = ( ( $80 ) - 1 ) | 0 ; $18 = $81 ; $82 = $4 ; $83 = ( ( ( $82 ) ) + 92 | 0 ) ; $84 = HEAP32 [ $83 >> 2 ] | 0 ; $85 = 1 << $84 ; $86 = ( ( $85 ) - 1 ) | 0 ; $19 = $86 ; L1 : while ( 1 ) { $87 = $15 ; $88 = ( $87 >>> 0 ) < ( 15 ) ; if ( $88 ) { $89 = $5 ; $90 = ( ( ( $89 ) ) + 1 | 0 ) ; $5 = $90 ; $91 = HEAP8 [ $89 >> 0 ] | 0 ; $92 = $91 & 255 ; $93 = $15 ; $94 = $92 << $93 ; $95 = $14 ; $96 = ( ( $95 ) + ( $94 ) ) | 0 ; $14 = $96 ; $97 = $15 ; $98 = ( ( $97 ) + 8 ) | 0 ; $15 = $98 ; $99 = $5 ; $100 = ( ( ( $99 ) ) + 1 | 0 ) ; $5 = $100 ; $101 = HEAP8 [ $99 >> 0 ] | 0 ; $102 = $101 & 255 ; $103 = $15 ; $104 = $102 << $103 ; $105 = $14 ; $106 = ( ( $105 ) + ( $104 ) ) | 0 ; $14 = $106 ; $107 = $15 ; $108 = ( ( $107 ) + 8 ) | 0 ; $15 = $108 ; } $109 = $16 ; $110 = $14 ; $111 = $18 ; $112 = $110 & $111 ; $113 = ( ( $109 ) + ( $112 << 2 ) | 0 ) ; ; HEAP16 [ $20 >> 1 ] = HEAP16 [ $113 >> 1 ] | 0 ; HEAP16 [ $20 + 2 >> 1 ] = HEAP16 [ $113 + 2 >> 1 ] | 0 ; while ( 1 ) { $114 = ( ( ( $20 ) ) + 1 | 0 ) ; $115 = HEAP8 [ $114 >> 0 ] | 0 ; $116 = $115 & 255 ; $21 = $116 ; $117 = $21 ; $118 = $14 ; $119 = $118 >>> $117 ; $14 = $119 ; $120 = $21 ; $121 = $15 ; $122 = ( ( $121 ) - ( $120 ) ) | 0 ; $15 = $122 ; $123 = HEAP8 [ $20 >> 0 ] | 0 ; $124 = $123 & 255 ; $21 = $124 ; $125 = $21 ; $126 = ( $125 | 0 ) == ( 0 ) ; if ( $126 ) { label = 6 ; break ; } $132 = $21 ; $133 = $132 & 16 ; $134 = ( $133 | 0 ) != ( 0 ) ; if ( $134 ) { label = 8 ; break ; } $457 = $21 ; $458 = $457 & 64 ; $459 = ( $458 | 0 ) == ( 0 ) ; if ( ! ( $459 ) ) { label = 55 ; break L1 ; } $460 = $16 ; $461 = ( ( ( $20 ) ) + 2 | 0 ) ; $462 = HEAP16 [ $461 >> 1 ] | 0 ; $463 = $462 & 65535 ; $464 = $14 ; $465 = $21 ; $466 = 1 << $465 ; $467 = ( ( $466 ) - 1 ) | 0 ; $468 = $464 & $467 ; $469 = ( ( $463 ) + ( $468 ) ) | 0 ; $470 = ( ( $460 ) + ( $469 << 2 ) | 0 ) ; ; HEAP16 [ $20 >> 1 ] = HEAP16 [ $470 >> 1 ] | 0 ; HEAP16 [ $20 + 2 >> 1 ] = HEAP16 [ $470 + 2 >> 1 ] | 0 ; } do { if ( ( label | 0 ) == 6 ) { label = 0 ; $127 = ( ( ( $20 ) ) + 2 | 0 ) ; $128 = HEAP16 [ $127 >> 1 ] | 0 ; $129 = $128 & 255 ; $130 = $7 ; $131 = ( ( ( $130 ) ) + 1 | 0 ) ; $7 = $131 ; HEAP8 [ $130 >> 0 ] = $129 ; } else if ( ( label | 0 ) == 8 ) { label = 0 ; $135 = ( ( ( $20 ) ) + 2 | 0 ) ; $136 = HEAP16 [ $135 >> 1 ] | 0 ; $137 = $136 & 65535 ; $22 = $137 ; $138 = $21 ; $139 = $138 & 15 ; $21 = $139 ; $140 = $21 ; $141 = ( $140 | 0 ) != ( 0 ) ; if ( $141 ) { $142 = $15 ; $143 = $21 ; $144 = ( $142 >>> 0 ) < ( $143 >>> 0 ) ; if ( $144 ) { $145 = $5 ; $146 = ( ( ( $145 ) ) + 1 | 0 ) ; $5 = $146 ; $147 = HEAP8 [ $145 >> 0 ] | 0 ; $148 = $147 & 255 ; $149 = $15 ; $150 = $148 << $149 ; $151 = $14 ; $152 = ( ( $151 ) + ( $150 ) ) | 0 ; $14 = $152 ; $153 = $15 ; $154 = ( ( $153 ) + 8 ) | 0 ; $15 = $154 ; } $155 = $14 ; $156 = $21 ; $157 = 1 << $156 ; $158 = ( ( $157 ) - 1 ) | 0 ; $159 = $155 & $158 ; $160 = $22 ; $161 = ( ( $160 ) + ( $159 ) ) | 0 ; $22 = $161 ; $162 = $21 ; $163 = $14 ; $164 = $163 >>> $162 ; $14 = $164 ; $165 = $21 ; $166 = $15 ; $167 = ( ( $166 ) - ( $165 ) ) | 0 ; $15 = $167 ; } $168 = $15 ; $169 = ( $168 >>> 0 ) < ( 15 ) ; if ( $169 ) { $170 = $5 ; $171 = ( ( ( $170 ) ) + 1 | 0 ) ; $5 = $171 ; $172 = HEAP8 [ $170 >> 0 ] | 0 ; $173 = $172 & 255 ; $174 = $15 ; $175 = $173 << $174 ; $176 = $14 ; $177 = ( ( $176 ) + ( $175 ) ) | 0 ; $14 = $177 ; $178 = $15 ; $179 = ( ( $178 ) + 8 ) | 0 ; $15 = $179 ; $180 = $5 ; $181 = ( ( ( $180 ) ) + 1 | 0 ) ; $5 = $181 ; $182 = HEAP8 [ $180 >> 0 ] | 0 ; $183 = $182 & 255 ; $184 = $15 ; $185 = $183 << $184 ; $186 = $14 ; $187 = ( ( $186 ) + ( $185 ) ) | 0 ; $14 = $187 ; $188 = $15 ; $189 = ( ( $188 ) + 8 ) | 0 ; $15 = $189 ; } $190 = $17 ; $191 = $14 ; $192 = $19 ; $193 = $191 & $192 ; $194 = ( ( $190 ) + ( $193 << 2 ) | 0 ) ; ; HEAP16 [ $20 >> 1 ] = HEAP16 [ $194 >> 1 ] | 0 ; HEAP16 [ $20 + 2 >> 1 ] = HEAP16 [ $194 + 2 >> 1 ] | 0 ; while ( 1 ) { $195 = ( ( ( $20 ) ) + 1 | 0 ) ; $196 = HEAP8 [ $195 >> 0 ] | 0 ; $197 = $196 & 255 ; $21 = $197 ; $198 = $21 ; $199 = $14 ; $200 = $199 >>> $198 ; $14 = $200 ; $201 = $21 ; $202 = $15 ; $203 = ( ( $202 ) - ( $201 ) ) | 0 ; $15 = $203 ; $204 = HEAP8 [ $20 >> 0 ] | 0 ; $205 = $204 & 255 ; $21 = $205 ; $206 = $21 ; $207 = $206 & 16 ; $208 = ( $207 | 0 ) != ( 0 ) ; if ( $208 ) { break ; } $440 = $21 ; $441 = $440 & 64 ; $442 = ( $441 | 0 ) == ( 0 ) ; if ( ! ( $442 ) ) { label = 52 ; break L1 ; } $443 = $17 ; $444 = ( ( ( $20 ) ) + 2 | 0 ) ; $445 = HEAP16 [ $444 >> 1 ] | 0 ; $446 = $445 & 65535 ; $447 = $14 ; $448 = $21 ; $449 = 1 << $448 ; $450 = ( ( $449 ) - 1 ) | 0 ; $451 = $447 & $450 ; $452 = ( ( $446 ) + ( $451 ) ) | 0 ; $453 = ( ( $443 ) + ( $452 << 2 ) | 0 ) ; ; HEAP16 [ $20 >> 1 ] = HEAP16 [ $453 >> 1 ] | 0 ; HEAP16 [ $20 + 2 >> 1 ] = HEAP16 [ $453 + 2 >> 1 ] | 0 ; } $209 = ( ( ( $20 ) ) + 2 | 0 ) ; $210 = HEAP16 [ $209 >> 1 ] | 0 ; $211 = $210 & 65535 ; $23 = $211 ; $212 = $21 ; $213 = $212 & 15 ; $21 = $213 ; $214 = $15 ; $215 = $21 ; $216 = ( $214 >>> 0 ) < ( $215 >>> 0 ) ; if ( $216 ) { $217 = $5 ; $218 = ( ( ( $217 ) ) + 1 | 0 ) ; $5 = $218 ; $219 = HEAP8 [ $217 >> 0 ] | 0 ; $220 = $219 & 255 ; $221 = $15 ; $222 = $220 << $221 ; $223 = $14 ; $224 = ( ( $223 ) + ( $222 ) ) | 0 ; $14 = $224 ; $225 = $15 ; $226 = ( ( $225 ) + 8 ) | 0 ; $15 = $226 ; $227 = $15 ; $228 = $21 ; $229 = ( $227 >>> 0 ) < ( $228 >>> 0 ) ; if ( $229 ) { $230 = $5 ; $231 = ( ( ( $230 ) ) + 1 | 0 ) ; $5 = $231 ; $232 = HEAP8 [ $230 >> 0 ] | 0 ; $233 = $232 & 255 ; $234 = $15 ; $235 = $233 << $234 ; $236 = $14 ; $237 = ( ( $236 ) + ( $235 ) ) | 0 ; $14 = $237 ; $238 = $15 ; $239 = ( ( $238 ) + 8 ) | 0 ; $15 = $239 ; } } $240 = $14 ; $241 = $21 ; $242 = 1 << $241 ; $243 = ( ( $242 ) - 1 ) | 0 ; $244 = $240 & $243 ; $245 = $23 ; $246 = ( ( $245 ) + ( $244 ) ) | 0 ; $23 = $246 ; $247 = $21 ; $248 = $14 ; $249 = $248 >>> $247 ; $14 = $249 ; $250 = $21 ; $251 = $15 ; $252 = ( ( $251 ) - ( $250 ) ) | 0 ; $15 = $252 ; $253 = $7 ; $254 = $8 ; $255 = $253 ; $256 = $254 ; $257 = ( ( $255 ) - ( $256 ) ) | 0 ; $21 = $257 ; $258 = $23 ; $259 = $21 ; $260 = ( $258 >>> 0 ) > ( $259 >>> 0 ) ; if ( ! ( $260 ) ) { $403 = $7 ; $404 = $23 ; $405 = ( 0 - ( $404 ) ) | 0 ; $406 = ( ( $403 ) + ( $405 ) | 0 ) ; $24 = $406 ; while ( 1 ) { $407 = $24 ; $408 = ( ( ( $407 ) ) + 1 | 0 ) ; $24 = $408 ; $409 = HEAP8 [ $407 >> 0 ] | 0 ; $410 = $7 ; $411 = ( ( ( $410 ) ) + 1 | 0 ) ; $7 = $411 ; HEAP8 [ $410 >> 0 ] = $409 ; $412 = $24 ; $413 = ( ( ( $412 ) ) + 1 | 0 ) ; $24 = $413 ; $414 = HEAP8 [ $412 >> 0 ] | 0 ; $415 = $7 ; $416 = ( ( ( $415 ) ) + 1 | 0 ) ; $7 = $416 ; HEAP8 [ $415 >> 0 ] = $414 ; $417 = $24 ; $418 = ( ( ( $417 ) ) + 1 | 0 ) ; $24 = $418 ; $419 = HEAP8 [ $417 >> 0 ] | 0 ; $420 = $7 ; $421 = ( ( ( $420 ) ) + 1 | 0 ) ; $7 = $421 ; HEAP8 [ $420 >> 0 ] = $419 ; $422 = $22 ; $423 = ( ( $422 ) - 3 ) | 0 ; $22 = $423 ; $424 = $22 ; $425 = ( $424 >>> 0 ) > ( 2 ) ; if ( ! ( $425 ) ) { break ; } } $426 = $22 ; $427 = ( $426 | 0 ) != ( 0 ) ; if ( ! ( $427 ) ) { break ; } $428 = $24 ; $429 = ( ( ( $428 ) ) + 1 | 0 ) ; $24 = $429 ; $430 = HEAP8 [ $428 >> 0 ] | 0 ; $431 = $7 ; $432 = ( ( ( $431 ) ) + 1 | 0 ) ; $7 = $432 ; HEAP8 [ $431 >> 0 ] = $430 ; $433 = $22 ; $434 = ( $433 >>> 0 ) > ( 1 ) ; if ( ! ( $434 ) ) { break ; } $435 = $24 ; $436 = ( ( ( $435 ) ) + 1 | 0 ) ; $24 = $436 ; $437 = HEAP8 [ $435 >> 0 ] | 0 ; $438 = $7 ; $439 = ( ( ( $438 ) ) + 1 | 0 ) ; $7 = $439 ; HEAP8 [ $438 >> 0 ] = $437 ; break ; } $261 = $23 ; $262 = $21 ; $263 = ( ( $261 ) - ( $262 ) ) | 0 ; $21 = $263 ; $264 = $21 ; $265 = $11 ; $266 = ( $264 >>> 0 ) > ( $265 >>> 0 ) ; if ( $266 ) { $267 = $4 ; $268 = ( ( ( $267 ) ) + 7108 | 0 ) ; $269 = HEAP32 [ $268 >> 2 ] | 0 ; $270 = ( $269 | 0 ) != ( 0 ) ; if ( $270 ) { label = 22 ; break L1 ; } } $274 = $13 ; $24 = $274 ; $275 = $12 ; $276 = ( $275 | 0 ) == ( 0 ) ; do { if ( $276 ) { $277 = $10 ; $278 = $21 ; $279 = ( ( $277 ) - ( $278 ) ) | 0 ; $280 = $24 ; $281 = ( ( $280 ) + ( $279 ) | 0 ) ; $24 = $281 ; $282 = $21 ; $283 = $22 ; $284 = ( $282 >>> 0 ) < ( $283 >>> 0 ) ; if ( $284 ) { $285 = $21 ; $286 = $22 ; $287 = ( ( $286 ) - ( $285 ) ) | 0 ; $22 = $287 ; while ( 1 ) { $288 = $24 ; $289 = ( ( ( $288 ) ) + 1 | 0 ) ; $24 = $289 ; $290 = HEAP8 [ $288 >> 0 ] | 0 ; $291 = $7 ; $292 = ( ( ( $291 ) ) + 1 | 0 ) ; $7 = $292 ; HEAP8 [ $291 >> 0 ] = $290 ; $293 = $21 ; $294 = ( ( $293 ) + - 1 ) | 0 ; $21 = $294 ; $295 = ( $294 | 0 ) != ( 0 ) ; if ( ! ( $295 ) ) { break ; } } $296 = $7 ; $297 = $23 ; $298 = ( 0 - ( $297 ) ) | 0 ; $299 = ( ( $296 ) + ( $298 ) | 0 ) ; $24 = $299 ; } } else { $300 = $12 ; $301 = $21 ; $302 = ( $300 >>> 0 ) < ( $301 >>> 0 ) ; if ( ! ( $302 ) ) { $347 = $12 ; $348 = $21 ; $349 = ( ( $347 ) - ( $348 ) ) | 0 ; $350 = $24 ; $351 = ( ( $350 ) + ( $349 ) | 0 ) ; $24 = $351 ; $352 = $21 ; $353 = $22 ; $354 = ( $352 >>> 0 ) < ( $353 >>> 0 ) ; if ( ! ( $354 ) ) { break ; } $355 = $21 ; $356 = $22 ; $357 = ( ( $356 ) - ( $355 ) ) | 0 ; $22 = $357 ; while ( 1 ) { $358 = $24 ; $359 = ( ( ( $358 ) ) + 1 | 0 ) ; $24 = $359 ; $360 = HEAP8 [ $358 >> 0 ] | 0 ; $361 = $7 ; $362 = ( ( ( $361 ) ) + 1 | 0 ) ; $7 = $362 ; HEAP8 [ $361 >> 0 ] = $360 ; $363 = $21 ; $364 = ( ( $363 ) + - 1 ) | 0 ; $21 = $364 ; $365 = ( $364 | 0 ) != ( 0 ) ; if ( ! ( $365 ) ) { break ; } } $366 = $7 ; $367 = $23 ; $368 = ( 0 - ( $367 ) ) | 0 ; $369 = ( ( $366 ) + ( $368 ) | 0 ) ; $24 = $369 ; break ; } $303 = $10 ; $304 = $12 ; $305 = ( ( $303 ) + ( $304 ) ) | 0 ; $306 = $21 ; $307 = ( ( $305 ) - ( $306 ) ) | 0 ; $308 = $24 ; $309 = ( ( $308 ) + ( $307 ) | 0 ) ; $24 = $309 ; $310 = $12 ; $311 = $21 ; $312 = ( ( $311 ) - ( $310 ) ) | 0 ; $21 = $312 ; $313 = $21 ; $314 = $22 ; $315 = ( $313 >>> 0 ) < ( $314 >>> 0 ) ; if ( $315 ) { $316 = $21 ; $317 = $22 ; $318 = ( ( $317 ) - ( $316 ) ) | 0 ; $22 = $318 ; while ( 1 ) { $319 = $24 ; $320 = ( ( ( $319 ) ) + 1 | 0 ) ; $24 = $320 ; $321 = HEAP8 [ $319 >> 0 ] | 0 ; $322 = $7 ; $323 = ( ( ( $322 ) ) + 1 | 0 ) ; $7 = $323 ; HEAP8 [ $322 >> 0 ] = $321 ; $324 = $21 ; $325 = ( ( $324 ) + - 1 ) | 0 ; $21 = $325 ; $326 = ( $325 | 0 ) != ( 0 ) ; if ( ! ( $326 ) ) { break ; } } $327 = $13 ; $24 = $327 ; $328 = $12 ; $329 = $22 ; $330 = ( $328 >>> 0 ) < ( $329 >>> 0 ) ; if ( $330 ) { $331 = $12 ; $21 = $331 ; $332 = $21 ; $333 = $22 ; $334 = ( ( $333 ) - ( $332 ) ) | 0 ; $22 = $334 ; while ( 1 ) { $335 = $24 ; $336 = ( ( ( $335 ) ) + 1 | 0 ) ; $24 = $336 ; $337 = HEAP8 [ $335 >> 0 ] | 0 ; $338 = $7 ; $339 = ( ( ( $338 ) ) + 1 | 0 ) ; $7 = $339 ; HEAP8 [ $338 >> 0 ] = $337 ; $340 = $21 ; $341 = ( ( $340 ) + - 1 ) | 0 ; $21 = $341 ; $342 = ( $341 | 0 ) != ( 0 ) ; if ( ! ( $342 ) ) { break ; } } $343 = $7 ; $344 = $23 ; $345 = ( 0 - ( $344 ) ) | 0 ; $346 = ( ( $343 ) + ( $345 ) | 0 ) ; $24 = $346 ; } } } } while ( 0 ) ; while ( 1 ) { $370 = $22 ; $371 = ( $370 >>> 0 ) > ( 2 ) ; if ( ! ( $371 ) ) { break ; } $372 = $24 ; $373 = ( ( ( $372 ) ) + 1 | 0 ) ; $24 = $373 ; $374 = HEAP8 [ $372 >> 0 ] | 0 ; $375 = $7 ; $376 = ( ( ( $375 ) ) + 1 | 0 ) ; $7 = $376 ; HEAP8 [ $375 >> 0 ] = $374 ; $377 = $24 ; $378 = ( ( ( $377 ) ) + 1 | 0 ) ; $24 = $378 ; $379 = HEAP8 [ $377 >> 0 ] | 0 ; $380 = $7 ; $381 = ( ( ( $380 ) ) + 1 | 0 ) ; $7 = $381 ; HEAP8 [ $380 >> 0 ] = $379 ; $382 = $24 ; $383 = ( ( ( $382 ) ) + 1 | 0 ) ; $24 = $383 ; $384 = HEAP8 [ $382 >> 0 ] | 0 ; $385 = $7 ; $386 = ( ( ( $385 ) ) + 1 | 0 ) ; $7 = $386 ; HEAP8 [ $385 >> 0 ] = $384 ; $387 = $22 ; $388 = ( ( $387 ) - 3 ) | 0 ; $22 = $388 ; } $389 = $22 ; $390 = ( $389 | 0 ) != ( 0 ) ; if ( $390 ) { $391 = $24 ; $392 = ( ( ( $391 ) ) + 1 | 0 ) ; $24 = $392 ; $393 = HEAP8 [ $391 >> 0 ] | 0 ; $394 = $7 ; $395 = ( ( ( $394 ) ) + 1 | 0 ) ; $7 = $395 ; HEAP8 [ $394 >> 0 ] = $393 ; $396 = $22 ; $397 = ( $396 >>> 0 ) > ( 1 ) ; if ( $397 ) { $398 = $24 ; $399 = ( ( ( $398 ) ) + 1 | 0 ) ; $24 = $399 ; $400 = HEAP8 [ $398 >> 0 ] | 0 ; $401 = $7 ; $402 = ( ( ( $401 ) ) + 1 | 0 ) ; $7 = $402 ; HEAP8 [ $401 >> 0 ] = $400 ; } } } } while ( 0 ) ; $478 = $5 ; $479 = $6 ; $480 = ( $478 >>> 0 ) < ( $479 >>> 0 ) ; if ( ! ( $480 ) ) { break ; } $481 = $7 ; $482 = $9 ; $483 = ( $481 >>> 0 ) < ( $482 >>> 0 ) ; if ( ! ( $483 ) ) { break ; } } do { if ( ( label | 0 ) == 22 ) { $271 = $2 ; $272 = ( ( ( $271 ) ) + 24 | 0 ) ; HEAP32 [ $272 >> 2 ] = 29678 ; $273 = $4 ; $$sink = 16209 ; $$sink2 = $273 ; label = 60 ; } else if ( ( label | 0 ) == 52 ) { $454 = $2 ; $455 = ( ( ( $454 ) ) + 24 | 0 ) ; HEAP32 [ $455 >> 2 ] = 29708 ; $456 = $4 ; $$sink = 16209 ; $$sink2 = $456 ; label = 60 ; } else if ( ( label | 0 ) == 55 ) { $471 = $21 ; $472 = $471 & 32 ; $473 = ( $472 | 0 ) != ( 0 ) ; if ( $473 ) { $474 = $4 ; $$sink = 16191 ; $$sink2 = $474 ; label = 60 ; break ; } else { $475 = $2 ; $476 = ( ( ( $475 ) ) + 24 | 0 ) ; HEAP32 [ $476 >> 2 ] = 29730 ; $477 = $4 ; $$sink = 16209 ; $$sink2 = $477 ; label = 60 ; break ; } } } while ( 0 ) ; if ( ( label | 0 ) == 60 ) { $484 = ( ( ( $$sink2 ) ) + 4 | 0 ) ; HEAP32 [ $484 >> 2 ] = $$sink ; } $485 = $15 ; $486 = $485 >>> 3 ; $22 = $486 ; $487 = $22 ; $488 = $5 ; $489 = ( 0 - ( $487 ) ) | 0 ; $490 = ( ( $488 ) + ( $489 ) | 0 ) ; $5 = $490 ; $491 = $22 ; $492 = $491 << 3 ; $493 = $15 ; $494 = ( ( $493 ) - ( $492 ) ) | 0 ; $15 = $494 ; $495 = $15 ; $496 = 1 << $495 ; $497 = ( ( $496 ) - 1 ) | 0 ; $498 = $14 ; $499 = $498 & $497 ; $14 = $499 ; $500 = $5 ; $501 = $2 ; HEAP32 [ $501 >> 2 ] = $500 ; $502 = $7 ; $503 = $2 ; $504 = ( ( ( $503 ) ) + 12 | 0 ) ; HEAP32 [ $504 >> 2 ] = $502 ; $505 = $5 ; $506 = $6 ; $507 = ( $505 >>> 0 ) < ( $506 >>> 0 ) ; if ( $507 ) { $508 = $6 ; $509 = $5 ; $510 = $508 ; $511 = $509 ; $512 = ( ( $510 ) - ( $511 ) ) | 0 ; $513 = ( 5 + ( $512 ) ) | 0 ; $522 = $513 ; } else { $514 = $5 ; $515 = $6 ; $516 = $514 ; $517 = $515 ; $518 = ( ( $516 ) - ( $517 ) ) | 0 ; $519 = ( 5 - ( $518 ) ) | 0 ; $522 = $519 ; } $520 = $2 ; $521 = ( ( ( $520 ) ) + 4 | 0 ) ; HEAP32 [ $521 >> 2 ] = $522 ; $523 = $7 ; $524 = $9 ; $525 = ( $523 >>> 0 ) < ( $524 >>> 0 ) ; if ( $525 ) { $526 = $9 ; $527 = $7 ; $528 = $526 ; $529 = $527 ; $530 = ( ( $528 ) - ( $529 ) ) | 0 ; $531 = ( 257 + ( $530 ) ) | 0 ; $540 = $531 ; $538 = $2 ; $539 = ( ( ( $538 ) ) + 16 | 0 ) ; HEAP32 [ $539 >> 2 ] = $540 ; $541 = $14 ; $542 = $4 ; $543 = ( ( ( $542 ) ) + 60 | 0 ) ; HEAP32 [ $543 >> 2 ] = $541 ; $544 = $15 ; $545 = $4 ; $546 = ( ( ( $545 ) ) + 64 | 0 ) ; HEAP32 [ $546 >> 2 ] = $544 ; STACKTOP = sp ; return ; } else { $532 = $7 ; $533 = $9 ; $534 = $532 ; $535 = $533 ; $536 = ( ( $534 ) - ( $535 ) ) | 0 ; $537 = ( 257 - ( $536 ) ) | 0 ; $540 = $537 ; $538 = $2 ; $539 = ( ( ( $538 ) ) + 16 | 0 ) ; HEAP32 [ $539 >> 2 ] = $540 ; $541 = $14 ; $542 = $4 ; $543 = ( ( ( $542 ) ) + 60 | 0 ) ; HEAP32 [ $543 >> 2 ] = $541 ; $544 = $15 ; $545 = $4 ; $546 = ( ( ( $545 ) ) + 64 | 0 ) ; HEAP32 [ $546 >> 2 ] = $544 ; STACKTOP = sp ; return ; } } function _DefaultError ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , $vararg_buffer = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $vararg_buffer = sp ; $1 = $0 ; $2 = HEAP32 [ 2398 ] | 0 ; $3 = $1 ; HEAP32 [ $vararg_buffer >> 2 ] = $3 ; ( _fprintf ( $2 , 29758 , $vararg_buffer ) | 0 ) ; _exit ( 1 ) ; // unreachable; } function _DefaultWarning ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , $vararg_buffer = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $vararg_buffer = sp ; $1 = $0 ; $2 = HEAP32 [ 2398 ] | 0 ; $3 = $1 ; HEAP32 [ $vararg_buffer >> 2 ] = $3 ; ( _fprintf ( $2 , 29758 , $vararg_buffer ) | 0 ) ; STACKTOP = sp ; return ; } function _GIFReadScreen ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $12 = 0 ; var $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 ; var $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 ; var $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 ; var $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 ; var $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $4 = sp + 8 | 0 ; $2 = $0 ; $3 = $1 ; $5 = $3 ; _ReadBytes ( $4 , 6 , $5 ) ; $6 = ( _memcmp ( $4 , 29762 , 3 ) | 0 ) ; $7 = ( $6 | 0 ) != ( 0 ) ; if ( $7 ) { $8 = HEAP32 [ 2363 ] | 0 ; FUNCTION_TABLE_vi [ $8 & 127 ] ( 29766 ) ; } $9 = ( ( ( $4 ) ) + 3 | 0 ) ; $10 = ( _memcmp ( $9 , 29781 , 3 ) | 0 ) ; $11 = ( $10 | 0 ) != ( 0 ) ; if ( $11 ) { $12 = ( ( ( $4 ) ) + 3 | 0 ) ; $13 = ( _memcmp ( $12 , 29785 , 3 ) | 0 ) ; $14 = ( $13 | 0 ) != ( 0 ) ; if ( $14 ) { $15 = HEAP32 [ 2364 ] | 0 ; FUNCTION_TABLE_vi [ $15 & 127 ] ( 29789 ) ; } } $16 = $3 ; _ReadBytes ( $4 , 7 , $16 ) ; $17 = HEAP8 [ $4 >> 0 ] | 0 ; $18 = $17 & 255 ; $19 = ( ( ( $4 ) ) + 1 | 0 ) ; $20 = HEAP8 [ $19 >> 0 ] | 0 ; $21 = $20 & 255 ; $22 = $21 << 8 ; $23 = ( ( $18 ) + ( $22 ) ) | 0 ; $24 = $2 ; HEAP32 [ $24 >> 2 ] = $23 ; $25 = ( ( ( $4 ) ) + 2 | 0 ) ; $26 = HEAP8 [ $25 >> 0 ] | 0 ; $27 = $26 & 255 ; $28 = ( ( ( $4 ) ) + 2 | 0 ) ; $29 = ( ( ( $28 ) ) + 1 | 0 ) ; $30 = HEAP8 [ $29 >> 0 ] | 0 ; $31 = $30 & 255 ; $32 = $31 << 8 ; $33 = ( ( $27 ) + ( $32 ) ) | 0 ; $34 = $2 ; $35 = ( ( ( $34 ) ) + 4 | 0 ) ; HEAP32 [ $35 >> 2 ] = $33 ; $36 = ( ( ( $4 ) ) + 4 | 0 ) ; $37 = HEAP8 [ $36 >> 0 ] | 0 ; $38 = $37 & 255 ; $39 = $38 & 128 ; $40 = ( $39 | 0 ) != ( 0 ) ; $41 = $40 ? 1 : 0 ; $42 = $2 ; $43 = ( ( ( $42 ) ) + 8 | 0 ) ; HEAP32 [ $43 >> 2 ] = $41 ; $44 = ( ( ( $4 ) ) + 4 | 0 ) ; $45 = HEAP8 [ $44 >> 0 ] | 0 ; $46 = $45 & 255 ; $47 = $46 & 112 ; $48 = $47 >> 3 ; $49 = ( ( $48 ) + 1 ) | 0 ; $50 = $2 ; $51 = ( ( ( $50 ) ) + 12 | 0 ) ; HEAP32 [ $51 >> 2 ] = $49 ; $52 = ( ( ( $4 ) ) + 4 | 0 ) ; $53 = HEAP8 [ $52 >> 0 ] | 0 ; $54 = $53 & 255 ; $55 = $54 & 8 ; $56 = ( $55 | 0 ) != ( 0 ) ; $57 = $56 ? 1 : 0 ; $58 = $2 ; $59 = ( ( ( $58 ) ) + 16 | 0 ) ; HEAP32 [ $59 >> 2 ] = $57 ; $60 = ( ( ( $4 ) ) + 4 | 0 ) ; $61 = HEAP8 [ $60 >> 0 ] | 0 ; $62 = $61 & 255 ; $63 = $62 & 7 ; $64 = 2 << $63 ; $65 = $2 ; $66 = ( ( ( $65 ) ) + 20 | 0 ) ; HEAP32 [ $66 >> 2 ] = $64 ; $67 = ( ( ( $4 ) ) + 5 | 0 ) ; $68 = HEAP8 [ $67 >> 0 ] | 0 ; $69 = $68 & 255 ; $70 = $2 ; $71 = ( ( ( $70 ) ) + 24 | 0 ) ; HEAP32 [ $71 >> 2 ] = $69 ; $72 = ( ( ( $4 ) ) + 6 | 0 ) ; $73 = HEAP8 [ $72 >> 0 ] | 0 ; $74 = $73 & 255 ; $75 = $2 ; $76 = ( ( ( $75 ) ) + 28 | 0 ) ; HEAP32 [ $76 >> 2 ] = $74 ; $77 = $2 ; $78 = ( ( ( $77 ) ) + 8 | 0 ) ; $79 = HEAP32 [ $78 >> 2 ] | 0 ; $80 = ( $79 | 0 ) != ( 0 ) ; if ( $80 ) { $81 = $2 ; $82 = ( ( ( $81 ) ) + 32 | 0 ) ; $83 = $2 ; $84 = ( ( ( $83 ) ) + 20 | 0 ) ; $85 = HEAP32 [ $84 >> 2 ] | 0 ; $86 = ( $85 * 3 ) | 0 ; $87 = $3 ; _ReadBytes ( $82 , $86 , $87 ) ; } $88 = $2 ; $89 = HEAP32 [ $88 >> 2 ] | 0 ; $90 = ( $89 | 0 ) == ( 0 ) ; if ( $90 ) { label = 10 ; } else { $91 = $2 ; $92 = ( ( ( $91 ) ) + 4 | 0 ) ; $93 = HEAP32 [ $92 >> 2 ] | 0 ; $94 = ( $93 | 0 ) == ( 0 ) ; if ( $94 ) { label = 10 ; } } if ( ( label | 0 ) == 10 ) { $95 = HEAP32 [ 2363 ] | 0 ; FUNCTION_TABLE_vi [ $95 & 127 ] ( 29836 ) ; } $96 = $2 ; $97 = ( ( ( $96 ) ) + 24 | 0 ) ; $98 = HEAP32 [ $97 >> 2 ] | 0 ; $99 = ( $98 >>> 0 ) > ( 0 ) ; if ( ! ( $99 ) ) { STACKTOP = sp ; return ; } $100 = $2 ; $101 = ( ( ( $100 ) ) + 8 | 0 ) ; $102 = HEAP32 [ $101 >> 2 ] | 0 ; $103 = ( $102 | 0 ) != ( 0 ) ; if ( $103 ) { $104 = $2 ; $105 = ( ( ( $104 ) ) + 24 | 0 ) ; $106 = HEAP32 [ $105 >> 2 ] | 0 ; $107 = $2 ; $108 = ( ( ( $107 ) ) + 20 | 0 ) ; $109 = HEAP32 [ $108 >> 2 ] | 0 ; $110 = ( $106 >>> 0 ) >= ( $109 >>> 0 ) ; if ( ! ( $110 ) ) { label = 14 ; } } else { label = 14 ; } if ( ( label | 0 ) == 14 ) { $111 = $2 ; $112 = ( ( ( $111 ) ) + 8 | 0 ) ; $113 = HEAP32 [ $112 >> 2 ] | 0 ; $114 = ( $113 | 0 ) != ( 0 ) ; if ( $114 ) { STACKTOP = sp ; return ; } } $115 = $2 ; $116 = ( ( ( $115 ) ) + 24 | 0 ) ; HEAP32 [ $116 >> 2 ] = 0 ; STACKTOP = sp ; return ; } function _ReadBytes ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $11 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $3 = $0 ; $4 = $1 ; $5 = $2 ; $6 = $3 ; $7 = $4 ; $8 = $5 ; $9 = ( _fread ( $6 , $7 , 1 , $8 ) | 0 ) ; $10 = ( $9 | 0 ) != ( 1 ) ; if ( ! ( $10 ) ) { STACKTOP = sp ; return ; } $11 = $5 ; _ErrorRead ( $11 ) ; STACKTOP = sp ; return ; } function _ErrorRead ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $2 = $1 ; $3 = ( _ferror ( $2 ) | 0 ) ; $4 = ( $3 | 0 ) != ( 0 ) ; $5 = HEAP32 [ 2363 ] | 0 ; if ( $4 ) { FUNCTION_TABLE_vi [ $5 & 127 ] ( 29868 ) ; STACKTOP = sp ; return ; } else { FUNCTION_TABLE_vi [ $5 & 127 ] ( 29891 ) ; STACKTOP = sp ; return ; } } function _GIFInitImage ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $3 = $0 ; $4 = $1 ; $5 = $2 ; $6 = $4 ; $7 = $3 ; HEAP32 [ $7 >> 2 ] = $6 ; $8 = $5 ; $9 = $3 ; $10 = ( ( ( $9 ) ) + 804 | 0 ) ; HEAP32 [ $10 >> 2 ] = $8 ; STACKTOP = sp ; return ; } function _GIFDestroyImage ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; STACKTOP = sp ; return ; } function _GIFReadNextBlock ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 ; var label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $8 = 0 ; L1 : while ( 1 ) { $9 = $6 ; $10 = ( _GetByte ( $9 ) | 0 ) ; $7 = $10 ; $11 = $7 ; switch ( $11 | 0 ) { case 44 : { label = 3 ; break L1 ; break ; } case 33 : { label = 4 ; break L1 ; break ; } case 59 : { label = 5 ; break L1 ; break ; } default : { } } $19 = $8 ; $20 = ( $19 | 0 ) != ( 0 ) ; if ( ! ( $20 ) ) { $21 = HEAP32 [ 2364 ] | 0 ; FUNCTION_TABLE_vi [ $21 & 127 ] ( 29918 ) ; } $8 = 1 ; } if ( ( label | 0 ) == 3 ) { $12 = $4 ; $13 = $6 ; _GIFReadNextImage ( $12 , $13 ) ; $14 = $7 ; $3 = $14 ; } else if ( ( label | 0 ) == 4 ) { $15 = $5 ; $16 = $6 ; _GIFReadNextExtension ( $15 , $16 ) ; $17 = $7 ; $3 = $17 ; } else if ( ( label | 0 ) == 5 ) { $18 = $7 ; $3 = $18 ; } $22 = $3 ; STACKTOP = sp ; return ( $22 | 0 ) ; } function _GetByte ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $3 = $1 ; $4 = ( _getc ( $3 ) | 0 ) ; $2 = $4 ; $5 = ( $4 | 0 ) == ( - 1 ) ; if ( $5 ) { $6 = $1 ; _ErrorRead ( $6 ) ; } $7 = $2 ; STACKTOP = sp ; return ( $7 | 0 ) ; } function _GIFReadNextImage ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $14 = 0 , $15 = 0 , $16 = 0 ; var $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 ; var $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 ; var $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 ; var $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 ; var $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $5 = sp + 12 | 0 ; $2 = $0 ; $3 = $1 ; $6 = $3 ; _ReadBytes ( $5 , 9 , $6 ) ; $7 = $2 ; $8 = ( $7 | 0 ) == ( 0 | 0 ) ; if ( $8 ) { $9 = $3 ; _GIFSkipDataBlocks ( $9 ) ; STACKTOP = sp ; return ; } $10 = HEAP8 [ $5 >> 0 ] | 0 ; $11 = $10 & 255 ; $12 = ( ( ( $5 ) ) + 1 | 0 ) ; $13 = HEAP8 [ $12 >> 0 ] | 0 ; $14 = $13 & 255 ; $15 = $14 << 8 ; $16 = ( ( $11 ) + ( $15 ) ) | 0 ; $17 = $2 ; $18 = ( ( ( $17 ) ) + 4 | 0 ) ; HEAP32 [ $18 >> 2 ] = $16 ; $19 = ( ( ( $5 ) ) + 2 | 0 ) ; $20 = HEAP8 [ $19 >> 0 ] | 0 ; $21 = $20 & 255 ; $22 = ( ( ( $5 ) ) + 2 | 0 ) ; $23 = ( ( ( $22 ) ) + 1 | 0 ) ; $24 = HEAP8 [ $23 >> 0 ] | 0 ; $25 = $24 & 255 ; $26 = $25 << 8 ; $27 = ( ( $21 ) + ( $26 ) ) | 0 ; $28 = $2 ; $29 = ( ( ( $28 ) ) + 8 | 0 ) ; HEAP32 [ $29 >> 2 ] = $27 ; $30 = ( ( ( $5 ) ) + 4 | 0 ) ; $31 = HEAP8 [ $30 >> 0 ] | 0 ; $32 = $31 & 255 ; $33 = ( ( ( $5 ) ) + 4 | 0 ) ; $34 = ( ( ( $33 ) ) + 1 | 0 ) ; $35 = HEAP8 [ $34 >> 0 ] | 0 ; $36 = $35 & 255 ; $37 = $36 << 8 ; $38 = ( ( $32 ) + ( $37 ) ) | 0 ; $39 = $2 ; $40 = ( ( ( $39 ) ) + 12 | 0 ) ; HEAP32 [ $40 >> 2 ] = $38 ; $41 = ( ( ( $5 ) ) + 6 | 0 ) ; $42 = HEAP8 [ $41 >> 0 ] | 0 ; $43 = $42 & 255 ; $44 = ( ( ( $5 ) ) + 6 | 0 ) ; $45 = ( ( ( $44 ) ) + 1 | 0 ) ; $46 = HEAP8 [ $45 >> 0 ] | 0 ; $47 = $46 & 255 ; $48 = $47 << 8 ; $49 = ( ( $43 ) + ( $48 ) ) | 0 ; $50 = $2 ; $51 = ( ( ( $50 ) ) + 16 | 0 ) ; HEAP32 [ $51 >> 2 ] = $49 ; $52 = ( ( ( $5 ) ) + 8 | 0 ) ; $53 = HEAP8 [ $52 >> 0 ] | 0 ; $54 = $53 & 255 ; $55 = $54 & 128 ; $56 = ( $55 | 0 ) != ( 0 ) ; $57 = $56 ? 1 : 0 ; $58 = $2 ; $59 = ( ( ( $58 ) ) + 20 | 0 ) ; HEAP32 [ $59 >> 2 ] = $57 ; $60 = ( ( ( $5 ) ) + 8 | 0 ) ; $61 = HEAP8 [ $60 >> 0 ] | 0 ; $62 = $61 & 255 ; $63 = $62 & 64 ; $64 = ( $63 | 0 ) != ( 0 ) ; $65 = $64 ? 1 : 0 ; $66 = $2 ; $67 = ( ( ( $66 ) ) + 24 | 0 ) ; HEAP32 [ $67 >> 2 ] = $65 ; $68 = ( ( ( $5 ) ) + 8 | 0 ) ; $69 = HEAP8 [ $68 >> 0 ] | 0 ; $70 = $69 & 255 ; $71 = $70 & 32 ; $72 = ( $71 | 0 ) != ( 0 ) ; $73 = $72 ? 1 : 0 ; $74 = $2 ; $75 = ( ( ( $74 ) ) + 28 | 0 ) ; HEAP32 [ $75 >> 2 ] = $73 ; $76 = $2 ; $77 = ( ( ( $76 ) ) + 20 | 0 ) ; $78 = HEAP32 [ $77 >> 2 ] | 0 ; $79 = ( $78 | 0 ) != ( 0 ) ; if ( $79 ) { $80 = ( ( ( $5 ) ) + 8 | 0 ) ; $81 = HEAP8 [ $80 >> 0 ] | 0 ; $82 = $81 & 255 ; $83 = $82 & 7 ; $84 = 2 << $83 ; $87 = $84 ; } else { $87 = 0 ; } $85 = $2 ; $86 = ( ( ( $85 ) ) + 32 | 0 ) ; HEAP32 [ $86 >> 2 ] = $87 ; $88 = $2 ; $89 = ( ( ( $88 ) ) + 20 | 0 ) ; $90 = HEAP32 [ $89 >> 2 ] | 0 ; $91 = ( $90 | 0 ) != ( 0 ) ; if ( $91 ) { $92 = $2 ; $93 = ( ( ( $92 ) ) + 36 | 0 ) ; $94 = $2 ; $95 = ( ( ( $94 ) ) + 32 | 0 ) ; $96 = HEAP32 [ $95 >> 2 ] | 0 ; $97 = ( $96 * 3 ) | 0 ; $98 = $3 ; _ReadBytes ( $93 , $97 , $98 ) ; } $99 = $2 ; $100 = HEAP32 [ $99 >> 2 ] | 0 ; $4 = $100 ; $101 = $2 ; $102 = ( ( ( $101 ) ) + 12 | 0 ) ; $103 = HEAP32 [ $102 >> 2 ] | 0 ; $104 = ( $103 | 0 ) == ( 0 ) ; if ( $104 ) { label = 11 ; } else { $105 = $2 ; $106 = ( ( ( $105 ) ) + 16 | 0 ) ; $107 = HEAP32 [ $106 >> 2 ] | 0 ; $108 = ( $107 | 0 ) == ( 0 ) ; if ( $108 ) { label = 11 ; } else { $109 = $2 ; $110 = ( ( ( $109 ) ) + 4 | 0 ) ; $111 = HEAP32 [ $110 >> 2 ] | 0 ; $112 = $2 ; $113 = ( ( ( $112 ) ) + 12 | 0 ) ; $114 = HEAP32 [ $113 >> 2 ] | 0 ; $115 = ( ( $111 ) + ( $114 ) ) | 0 ; $116 = $4 ; $117 = HEAP32 [ $116 >> 2 ] | 0 ; $118 = ( $115 >>> 0 ) > ( $117 >>> 0 ) ; if ( $118 ) { label = 11 ; } else { $119 = $2 ; $120 = ( ( ( $119 ) ) + 8 | 0 ) ; $121 = HEAP32 [ $120 >> 2 ] | 0 ; $122 = $2 ; $123 = ( ( ( $122 ) ) + 16 | 0 ) ; $124 = HEAP32 [ $123 >> 2 ] | 0 ; $125 = ( ( $121 ) + ( $124 ) ) | 0 ; $126 = $4 ; $127 = ( ( ( $126 ) ) + 4 | 0 ) ; $128 = HEAP32 [ $127 >> 2 ] | 0 ; $129 = ( $125 >>> 0 ) > ( $128 >>> 0 ) ; if ( $129 ) { label = 11 ; } } } } if ( ( label | 0 ) == 11 ) { $130 = HEAP32 [ 2363 ] | 0 ; FUNCTION_TABLE_vi [ $130 & 127 ] ( 29836 ) ; } $131 = $2 ; $132 = $3 ; _GIFReadImageData ( $131 , $132 ) ; STACKTOP = sp ; return ; } function _GIFReadNextExtension ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 ; var $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 ; var $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $2 = $0 ; $3 = $1 ; $10 = $3 ; $11 = ( _GetByte ( $10 ) | 0 ) ; $9 = $11 ; $12 = $2 ; $13 = ( $12 | 0 ) == ( 0 | 0 ) ; if ( $13 ) { $14 = $3 ; _GIFSkipDataBlocks ( $14 ) ; STACKTOP = sp ; return ; } $15 = $9 ; $16 = $15 & 255 ; $17 = $2 ; $18 = ( ( ( $17 ) ) + 12 | 0 ) ; HEAP8 [ $18 >> 0 ] = $16 ; $6 = 0 ; $19 = $2 ; $20 = ( ( ( $19 ) ) + 8 | 0 ) ; $21 = HEAP32 [ $20 >> 2 ] | 0 ; $7 = $21 ; while ( 1 ) { $22 = $7 ; $23 = ( $22 >>> 0 ) < ( 255 ) ; if ( $23 ) { $24 = $2 ; $25 = ( ( ( $24 ) ) + 8 | 0 ) ; $26 = HEAP32 [ $25 >> 2 ] | 0 ; $27 = ( ( $26 ) + 1024 ) | 0 ; $5 = $27 ; $28 = $2 ; $29 = ( ( ( $28 ) ) + 4 | 0 ) ; $30 = HEAP32 [ $29 >> 2 ] | 0 ; $31 = $5 ; $32 = ( _realloc ( $30 , $31 ) | 0 ) ; $4 = $32 ; $33 = $4 ; $34 = ( $33 | 0 ) == ( 0 | 0 ) ; if ( $34 ) { _ErrorAlloc ( ) ; } $35 = $5 ; $36 = $2 ; $37 = ( ( ( $36 ) ) + 8 | 0 ) ; HEAP32 [ $37 >> 2 ] = $35 ; $38 = $4 ; $39 = $2 ; $40 = ( ( ( $39 ) ) + 4 | 0 ) ; HEAP32 [ $40 >> 2 ] = $38 ; $41 = $7 ; $42 = ( ( $41 ) + 1024 ) | 0 ; $7 = $42 ; } $43 = $2 ; $44 = ( ( ( $43 ) ) + 4 | 0 ) ; $45 = HEAP32 [ $44 >> 2 ] | 0 ; $46 = $6 ; $47 = ( ( $45 ) + ( $46 ) | 0 ) ; $48 = $3 ; $49 = ( _GIFReadDataBlock ( $47 , $48 ) | 0 ) ; $8 = $49 ; $50 = $8 ; $51 = ( $50 | 0 ) == ( 0 ) ; if ( $51 ) { break ; } $52 = $8 ; $53 = $6 ; $54 = ( ( $53 ) + ( $52 ) ) | 0 ; $6 = $54 ; $55 = $8 ; $56 = $7 ; $57 = ( ( $56 ) - ( $55 ) ) | 0 ; $7 = $57 ; } STACKTOP = sp ; return ; } function _GIFSkipDataBlocks ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 272 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 272 | 0 ) ; $3 = sp + 8 | 0 ; $1 = $0 ; while ( 1 ) { $4 = $1 ; $5 = ( _GetByte ( $4 ) | 0 ) ; $2 = $5 ; $6 = $2 ; $7 = ( $6 | 0 ) > ( 0 ) ; if ( ! ( $7 ) ) { break ; } $8 = $2 ; $9 = $1 ; _ReadBytes ( $3 , $8 , $9 ) ; } STACKTOP = sp ; return ; } function _ErrorAlloc ( ) { var $0 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $0 = HEAP32 [ 2363 ] | 0 ; FUNCTION_TABLE_vi [ $0 & 127 ] ( 29941 ) ; return ; } function _GIFReadDataBlock ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = $0 ; $3 = $1 ; $5 = $3 ; $6 = ( _GetByte ( $5 ) | 0 ) ; $4 = $6 ; $7 = $4 ; HEAP32 [ 8528 ] = $7 ; $8 = $4 ; $9 = ( $8 | 0 ) > ( 0 ) ; if ( ! ( $9 ) ) { $13 = $4 ; STACKTOP = sp ; return ( $13 | 0 ) ; } $10 = $2 ; $11 = $4 ; $12 = $3 ; _ReadBytes ( $10 , $11 , $12 ) ; $13 = $4 ; STACKTOP = sp ; return ( $13 | 0 ) ; } function _GIFReadImageData ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 ; var $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 ; var $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 ; var $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 ; var $83 = 0 , $84 = 0 , $85 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 64 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 64 | 0 ) ; $9 = sp + 20 | 0 ; $10 = sp + 16 | 0 ; $2 = $0 ; $3 = $1 ; $15 = $3 ; $16 = ( _GetByte ( $15 ) | 0 ) ; $4 = $16 ; $17 = $4 ; $18 = ( $17 | 0 ) >= ( 12 ) ; if ( $18 ) { $19 = HEAP32 [ 2363 ] | 0 ; FUNCTION_TABLE_vi [ $19 & 127 ] ( 29970 ) ; } $20 = $4 ; $21 = $3 ; $22 = ( _LZWDecodeByte ( 1 , $20 , $21 ) | 0 ) ; $23 = ( $22 | 0 ) < ( 0 ) ; if ( $23 ) { $24 = HEAP32 [ 2363 ] | 0 ; FUNCTION_TABLE_vi [ $24 & 127 ] ( 29992 ) ; } $25 = $2 ; $26 = ( ( ( $25 ) ) + 804 | 0 ) ; $27 = HEAP32 [ $26 >> 2 ] | 0 ; $5 = $27 ; $28 = $5 ; $29 = ( $28 | 0 ) == ( 0 | 0 ) ; if ( $29 ) { $30 = $3 ; _GIFSkipDataBlocks ( $30 ) ; STACKTOP = sp ; return ; } $31 = $2 ; $32 = ( ( ( $31 ) ) + 12 | 0 ) ; $33 = HEAP32 [ $32 >> 2 ] | 0 ; $6 = $33 ; $34 = $2 ; $35 = ( ( ( $34 ) ) + 16 | 0 ) ; $36 = HEAP32 [ $35 >> 2 ] | 0 ; $7 = $36 ; $37 = $2 ; $38 = ( ( ( $37 ) ) + 24 | 0 ) ; $39 = HEAP32 [ $38 >> 2 ] | 0 ; $8 = $39 ; $40 = $2 ; _GIFGetColorTable ( $9 , $10 , $40 ) ; $12 = 0 ; $11 = 0 ; $13 = 0 ; L11 : while ( 1 ) { $41 = $4 ; $42 = $3 ; $43 = ( _LZWDecodeByte ( 0 , $41 , $42 ) | 0 ) ; $14 = $43 ; $44 = ( $43 | 0 ) >= ( 0 ) ; if ( ! ( $44 ) ) { break ; } $45 = $14 ; $46 = HEAP32 [ $10 >> 2 ] | 0 ; $47 = ( $45 >>> 0 ) >= ( $46 >>> 0 ) ; if ( $47 ) { $48 = HEAP32 [ 2364 ] | 0 ; FUNCTION_TABLE_vi [ $48 & 127 ] ( 30017 ) ; $49 = HEAP32 [ $10 >> 2 ] | 0 ; $50 = ( ( $49 ) - 1 ) | 0 ; $14 = $50 ; } $51 = $14 ; $52 = $51 & 255 ; $53 = $5 ; $54 = $12 ; $55 = ( ( $53 ) + ( $54 << 2 ) | 0 ) ; $56 = HEAP32 [ $55 >> 2 ] | 0 ; $57 = $11 ; $58 = ( ( $56 ) + ( $57 ) | 0 ) ; HEAP8 [ $58 >> 0 ] = $52 ; $59 = $11 ; $60 = ( ( $59 ) + 1 ) | 0 ; $11 = $60 ; $61 = $6 ; $62 = ( $60 | 0 ) == ( $61 | 0 ) ; L17 : do { if ( $62 ) { $11 = 0 ; $63 = $8 ; $64 = ( $63 | 0 ) != ( 0 ) ; if ( ! ( $64 ) ) { $77 = $12 ; $78 = ( ( $77 ) + 1 ) | 0 ; $12 = $78 ; break ; } $65 = $13 ; switch ( $65 | 0 ) { case 1 : case 0 : { $66 = $12 ; $67 = ( ( $66 ) + 8 ) | 0 ; $12 = $67 ; break ; } case 2 : { $68 = $12 ; $69 = ( ( $68 ) + 4 ) | 0 ; $12 = $69 ; break ; } case 3 : { $70 = $12 ; $71 = ( ( $70 ) + 2 ) | 0 ; $12 = $71 ; break ; } default : { } } $72 = $12 ; $73 = $7 ; $74 = ( $72 >>> 0 ) >= ( $73 >>> 0 ) ; if ( $74 ) { $75 = $13 ; $76 = ( ( $75 ) + 1 ) | 0 ; $13 = $76 ; switch ( $76 | 0 ) { case 1 : { $12 = 4 ; break L17 ; break ; } case 2 : { $12 = 2 ; break L17 ; break ; } case 3 : { $12 = 1 ; break L17 ; break ; } default : { break L11 ; } } } } } while ( 0 ) ; $79 = $12 ; $80 = $7 ; $81 = ( $79 >>> 0 ) >= ( $80 >>> 0 ) ; if ( $81 ) { break ; } } while ( 1 ) { $82 = $4 ; $83 = $3 ; $84 = ( _LZWDecodeByte ( 0 , $82 , $83 ) | 0 ) ; $85 = ( $84 | 0 ) >= ( 0 ) ; if ( ! ( $85 ) ) { break ; } } STACKTOP = sp ; return ; } function _LZWDecodeByte ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 ; var $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 ; var $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 ; var $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 ; var $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 ; var $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 ; var $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 304 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 304 | 0 ) ; $11 = sp + 32 | 0 ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $12 = $4 ; $13 = ( $12 | 0 ) != ( 0 ) ; if ( $13 ) { HEAP32 [ 8529 ] = 1 ; $14 = $5 ; HEAP32 [ 8530 ] = $14 ; $15 = HEAP32 [ 8530 ] | 0 ; $16 = ( ( $15 ) + 1 ) | 0 ; HEAP32 [ 8531 ] = $16 ; $17 = HEAP32 [ 8530 ] | 0 ; $18 = 1 << $17 ; HEAP32 [ 8532 ] = $18 ; $19 = HEAP32 [ 8532 ] | 0 ; $20 = ( ( $19 ) + 1 ) | 0 ; HEAP32 [ 8533 ] = $20 ; $21 = HEAP32 [ 8532 ] | 0 ; $22 = $21 << 1 ; HEAP32 [ 8534 ] = $22 ; $23 = HEAP32 [ 8532 ] | 0 ; $24 = ( ( $23 ) + 2 ) | 0 ; HEAP32 [ 8535 ] = $24 ; $25 = $6 ; ( _LZWGetCode ( 0 , 1 , $25 ) | 0 ) ; $9 = 0 ; while ( 1 ) { $26 = $9 ; $27 = HEAP32 [ 8532 ] | 0 ; $28 = ( $26 | 0 ) < ( $27 | 0 ) ; if ( ! ( $28 ) ) { break ; } $29 = $9 ; $30 = ( 67528 + ( $29 << 2 ) | 0 ) ; HEAP32 [ $30 >> 2 ] = 0 ; $31 = $9 ; $32 = $9 ; $33 = ( 83912 + ( $32 << 2 ) | 0 ) ; HEAP32 [ $33 >> 2 ] = $31 ; $34 = $9 ; $35 = ( ( $34 ) + 1 ) | 0 ; $9 = $35 ; } while ( 1 ) { $36 = $9 ; $37 = ( $36 | 0 ) <= ( 4095 ) ; if ( ! ( $37 ) ) { break ; } $38 = $9 ; $39 = ( 67528 + ( $38 << 2 ) | 0 ) ; HEAP32 [ $39 >> 2 ] = 0 ; $40 = $9 ; $41 = ( 83912 + ( $40 << 2 ) | 0 ) ; HEAP32 [ $41 >> 2 ] = 0 ; $42 = $9 ; $43 = ( ( $42 ) + 1 ) | 0 ; $9 = $43 ; } HEAP32 [ 16728 ] = 34144 ; $3 = 0 ; $158 = $3 ; STACKTOP = sp ; return ( $158 | 0 ) ; } $44 = HEAP32 [ 8529 ] | 0 ; $45 = ( $44 | 0 ) != ( 0 ) ; if ( $45 ) { HEAP32 [ 8529 ] = 0 ; while ( 1 ) { $46 = HEAP32 [ 8531 ] | 0 ; $47 = $6 ; $48 = ( _LZWGetCode ( $46 , 0 , $47 ) | 0 ) ; HEAP32 [ 16729 ] = $48 ; HEAP32 [ 16730 ] = $48 ; $49 = HEAP32 [ 16730 ] | 0 ; $50 = HEAP32 [ 8532 ] | 0 ; $51 = ( $49 | 0 ) == ( $50 | 0 ) ; if ( ! ( $51 ) ) { break ; } } $52 = HEAP32 [ 16730 ] | 0 ; $3 = $52 ; $158 = $3 ; STACKTOP = sp ; return ( $158 | 0 ) ; } $53 = HEAP32 [ 16728 ] | 0 ; $54 = ( $53 >>> 0 ) > ( 34144 >>> 0 ) ; if ( $54 ) { $55 = HEAP32 [ 16728 ] | 0 ; $56 = ( ( ( $55 ) ) + - 4 | 0 ) ; HEAP32 [ 16728 ] = $56 ; $57 = HEAP32 [ $56 >> 2 ] | 0 ; $3 = $57 ; $158 = $3 ; STACKTOP = sp ; return ( $158 | 0 ) ; } while ( 1 ) { $58 = HEAP32 [ 8531 ] | 0 ; $59 = $6 ; $60 = ( _LZWGetCode ( $58 , 0 , $59 ) | 0 ) ; $7 = $60 ; $61 = ( $60 | 0 ) >= ( 0 ) ; $62 = $7 ; if ( ! ( $61 ) ) { label = 39 ; break ; } $63 = HEAP32 [ 8532 ] | 0 ; $64 = ( $62 | 0 ) == ( $63 | 0 ) ; if ( $64 ) { label = 16 ; break ; } $93 = $7 ; $94 = HEAP32 [ 8533 ] | 0 ; $95 = ( $93 | 0 ) == ( $94 | 0 ) ; if ( $95 ) { label = 23 ; break ; } $101 = $7 ; $8 = $101 ; $102 = $7 ; $103 = HEAP32 [ 8535 ] | 0 ; $104 = ( $102 | 0 ) >= ( $103 | 0 ) ; if ( $104 ) { $105 = HEAP32 [ 16730 ] | 0 ; $106 = HEAP32 [ 16728 ] | 0 ; $107 = ( ( ( $106 ) ) + 4 | 0 ) ; HEAP32 [ 16728 ] = $107 ; HEAP32 [ $106 >> 2 ] = $105 ; $108 = HEAP32 [ 16729 ] | 0 ; $7 = $108 ; } while ( 1 ) { $109 = $7 ; $110 = HEAP32 [ 8532 ] | 0 ; $111 = ( $109 | 0 ) >= ( $110 | 0 ) ; $112 = $7 ; $113 = ( 83912 + ( $112 << 2 ) | 0 ) ; $114 = HEAP32 [ $113 >> 2 ] | 0 ; if ( ! ( $111 ) ) { break ; } $115 = HEAP32 [ 16728 ] | 0 ; $116 = ( ( ( $115 ) ) + 4 | 0 ) ; HEAP32 [ 16728 ] = $116 ; HEAP32 [ $115 >> 2 ] = $114 ; $117 = $7 ; $118 = $7 ; $119 = ( 67528 + ( $118 << 2 ) | 0 ) ; $120 = HEAP32 [ $119 >> 2 ] | 0 ; $121 = ( $117 | 0 ) == ( $120 | 0 ) ; if ( $121 ) { label = 32 ; } else { $122 = HEAP32 [ 16728 ] | 0 ; $123 = $122 ; $124 = ( ( $123 ) - ( 34144 ) ) | 0 ; $125 = ( ( $124 | 0 ) / 4 ) & - 1 ; $126 = ( $125 >>> 0 ) >= ( 8192 ) ; if ( $126 ) { label = 32 ; } } if ( ( label | 0 ) == 32 ) { label = 0 ; $127 = HEAP32 [ 2363 ] | 0 ; FUNCTION_TABLE_vi [ $127 & 127 ] ( 30079 ) ; } $128 = $7 ; $129 = ( 67528 + ( $128 << 2 ) | 0 ) ; $130 = HEAP32 [ $129 >> 2 ] | 0 ; $7 = $130 ; } HEAP32 [ 16730 ] = $114 ; $131 = HEAP32 [ 16728 ] | 0 ; $132 = ( ( ( $131 ) ) + 4 | 0 ) ; HEAP32 [ 16728 ] = $132 ; HEAP32 [ $131 >> 2 ] = $114 ; $133 = HEAP32 [ 8535 ] | 0 ; $7 = $133 ; $134 = ( $133 | 0 ) <= ( 4095 ) ; if ( $134 ) { $135 = HEAP32 [ 16729 ] | 0 ; $136 = $7 ; $137 = ( 67528 + ( $136 << 2 ) | 0 ) ; HEAP32 [ $137 >> 2 ] = $135 ; $138 = HEAP32 [ 16730 ] | 0 ; $139 = $7 ; $140 = ( 83912 + ( $139 << 2 ) | 0 ) ; HEAP32 [ $140 >> 2 ] = $138 ; $141 = HEAP32 [ 8535 ] | 0 ; $142 = ( ( $141 ) + 1 ) | 0 ; HEAP32 [ 8535 ] = $142 ; $143 = HEAP32 [ 8535 ] | 0 ; $144 = HEAP32 [ 8534 ] | 0 ; $145 = ( $143 | 0 ) >= ( $144 | 0 ) ; $146 = HEAP32 [ 8534 ] | 0 ; $147 = ( $146 | 0 ) <= ( 4095 ) ; $or$cond = $145 & $147 ; if ( $or$cond ) { $148 = HEAP32 [ 8534 ] | 0 ; $149 = $148 << 1 ; HEAP32 [ 8534 ] = $149 ; $150 = HEAP32 [ 8531 ] | 0 ; $151 = ( ( $150 ) + 1 ) | 0 ; HEAP32 [ 8531 ] = $151 ; } } $152 = $8 ; HEAP32 [ 16729 ] = $152 ; $153 = HEAP32 [ 16728 ] | 0 ; $154 = ( $153 >>> 0 ) > ( 34144 >>> 0 ) ; if ( $154 ) { label = 38 ; break ; } } if ( ( label | 0 ) == 16 ) { $9 = 0 ; while ( 1 ) { $65 = $9 ; $66 = HEAP32 [ 8532 ] | 0 ; $67 = ( $65 | 0 ) < ( $66 | 0 ) ; if ( ! ( $67 ) ) { break ; } $68 = $9 ; $69 = ( 67528 + ( $68 << 2 ) | 0 ) ; HEAP32 [ $69 >> 2 ] = 0 ; $70 = $9 ; $71 = $9 ; $72 = ( 83912 + ( $71 << 2 ) | 0 ) ; HEAP32 [ $72 >> 2 ] = $70 ; $73 = $9 ; $74 = ( ( $73 ) + 1 ) | 0 ; $9 = $74 ; } while ( 1 ) { $75 = $9 ; $76 = ( $75 | 0 ) <= ( 4095 ) ; if ( ! ( $76 ) ) { break ; } $77 = $9 ; $78 = ( 67528 + ( $77 << 2 ) | 0 ) ; HEAP32 [ $78 >> 2 ] = 0 ; $79 = $9 ; $80 = ( 83912 + ( $79 << 2 ) | 0 ) ; HEAP32 [ $80 >> 2 ] = 0 ; $81 = $9 ; $82 = ( ( $81 ) + 1 ) | 0 ; $9 = $82 ; } $83 = HEAP32 [ 8530 ] | 0 ; $84 = ( ( $83 ) + 1 ) | 0 ; HEAP32 [ 8531 ] = $84 ; $85 = HEAP32 [ 8532 ] | 0 ; $86 = $85 << 1 ; HEAP32 [ 8534 ] = $86 ; $87 = HEAP32 [ 8532 ] | 0 ; $88 = ( ( $87 ) + 2 ) | 0 ; HEAP32 [ 8535 ] = $88 ; HEAP32 [ 16728 ] = 34144 ; $89 = HEAP32 [ 8531 ] | 0 ; $90 = $6 ; $91 = ( _LZWGetCode ( $89 , 0 , $90 ) | 0 ) ; HEAP32 [ 16729 ] = $91 ; HEAP32 [ 16730 ] = $91 ; $92 = HEAP32 [ 16730 ] | 0 ; $3 = $92 ; $158 = $3 ; STACKTOP = sp ; return ( $158 | 0 ) ; } else if ( ( label | 0 ) == 23 ) { $96 = HEAP32 [ 8528 ] | 0 ; $97 = ( $96 | 0 ) == ( 0 ) ; if ( $97 ) { $3 = - 2 ; $158 = $3 ; STACKTOP = sp ; return ( $158 | 0 ) ; } while ( 1 ) { $98 = $6 ; $99 = ( _GIFReadDataBlock ( $11 , $98 ) | 0 ) ; $10 = $99 ; $100 = ( $99 | 0 ) > ( 0 ) ; if ( ! ( $100 ) ) { break ; } } $3 = - 2 ; $158 = $3 ; STACKTOP = sp ; return ( $158 | 0 ) ; } else if ( ( label | 0 ) == 38 ) { $155 = HEAP32 [ 16728 ] | 0 ; $156 = ( ( ( $155 ) ) + - 4 | 0 ) ; HEAP32 [ 16728 ] = $156 ; $157 = HEAP32 [ $156 >> 2 ] | 0 ; $3 = $157 ; $158 = $3 ; STACKTOP = sp ; return ( $158 | 0 ) ; } else if ( ( label | 0 ) == 39 ) { $3 = $62 ; $158 = $3 ; STACKTOP = sp ; return ( $158 | 0 ) ; } return ( 0 ) | 0 ; } function _GIFGetColorTable ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $3 = 0 , $30 = 0 , $31 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $3 = $0 ; $4 = $1 ; $5 = $2 ; $7 = $5 ; $8 = ( ( ( $7 ) ) + 20 | 0 ) ; $9 = HEAP32 [ $8 >> 2 ] | 0 ; $10 = ( $9 | 0 ) != ( 0 ) ; $11 = $5 ; if ( $10 ) { $12 = ( ( ( $11 ) ) + 36 | 0 ) ; $13 = $3 ; HEAP32 [ $13 >> 2 ] = $12 ; $14 = $5 ; $15 = ( ( ( $14 ) ) + 32 | 0 ) ; $16 = HEAP32 [ $15 >> 2 ] | 0 ; $17 = $4 ; HEAP32 [ $17 >> 2 ] = $16 ; STACKTOP = sp ; return ; } $18 = HEAP32 [ $11 >> 2 ] | 0 ; $6 = $18 ; $19 = $6 ; $20 = ( ( ( $19 ) ) + 8 | 0 ) ; $21 = HEAP32 [ $20 >> 2 ] | 0 ; $22 = ( $21 | 0 ) != ( 0 ) ; if ( $22 ) { $23 = $6 ; $24 = ( ( ( $23 ) ) + 32 | 0 ) ; $25 = $3 ; HEAP32 [ $25 >> 2 ] = $24 ; $26 = $6 ; $27 = ( ( ( $26 ) ) + 20 | 0 ) ; $28 = HEAP32 [ $27 >> 2 ] | 0 ; $29 = $4 ; HEAP32 [ $29 >> 2 ] = $28 ; STACKTOP = sp ; return ; } else { $30 = $3 ; HEAP32 [ $30 >> 2 ] = 30055 ; $31 = $4 ; HEAP32 [ $31 >> 2 ] = 8 ; STACKTOP = sp ; return ; } } function _LZWGetCode ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 ; var $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 ; var $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $11 = $5 ; $12 = ( $11 | 0 ) != ( 0 ) ; if ( $12 ) { HEAP32 [ 16731 ] = 0 ; HEAP32 [ 16732 ] = 0 ; HEAP32 [ 16733 ] = 2 ; HEAP32 [ 16734 ] = 0 ; $3 = 0 ; $71 = $3 ; STACKTOP = sp ; return ( $71 | 0 ) ; } $13 = HEAP32 [ 16731 ] | 0 ; $14 = $4 ; $15 = ( ( $13 ) + ( $14 ) ) | 0 ; $16 = HEAP32 [ 16732 ] | 0 ; $17 = ( $15 | 0 ) >= ( $16 | 0 ) ; do { if ( $17 ) { $18 = HEAP32 [ 16734 ] | 0 ; $19 = ( $18 | 0 ) != ( 0 ) ; if ( ! ( $19 ) ) { $24 = HEAP32 [ 16733 ] | 0 ; $25 = ( ( $24 ) - 2 ) | 0 ; $26 = ( 100297 + ( $25 ) | 0 ) ; $27 = HEAP8 [ $26 >> 0 ] | 0 ; HEAP8 [ 100297 ] = $27 ; $28 = HEAP32 [ 16733 ] | 0 ; $29 = ( ( $28 ) - 1 ) | 0 ; $30 = ( 100297 + ( $29 ) | 0 ) ; $31 = HEAP8 [ $30 >> 0 ] | 0 ; HEAP8 [ ( 100298 ) >> 0 ] = $31 ; $32 = $6 ; $33 = ( _GIFReadDataBlock ( ( 100299 ) , $32 ) | 0 ) ; $7 = $33 ; $34 = ( $33 | 0 ) == ( 0 ) ; if ( $34 ) { HEAP32 [ 16734 ] = 1 ; } $35 = $7 ; $36 = ( 2 + ( $35 ) ) | 0 ; HEAP32 [ 16733 ] = $36 ; $37 = HEAP32 [ 16731 ] | 0 ; $38 = HEAP32 [ 16732 ] | 0 ; $39 = ( ( $37 ) - ( $38 ) ) | 0 ; $40 = ( ( $39 ) + 16 ) | 0 ; HEAP32 [ 16731 ] = $40 ; $41 = $7 ; $42 = ( 2 + ( $41 ) ) | 0 ; $43 = $42 << 3 ; HEAP32 [ 16732 ] = $43 ; break ; } $20 = HEAP32 [ 16731 ] | 0 ; $21 = HEAP32 [ 16732 ] | 0 ; $22 = ( $20 | 0 ) >= ( $21 | 0 ) ; if ( $22 ) { $23 = HEAP32 [ 2363 ] | 0 ; FUNCTION_TABLE_vi [ $23 & 127 ] ( 30118 ) ; } $3 = - 1 ; $71 = $3 ; STACKTOP = sp ; return ( $71 | 0 ) ; } } while ( 0 ) ; $10 = 0 ; $44 = HEAP32 [ 16731 ] | 0 ; $8 = $44 ; $9 = 0 ; while ( 1 ) { $45 = $9 ; $46 = $4 ; $47 = ( $45 | 0 ) < ( $46 | 0 ) ; if ( ! ( $47 ) ) { break ; } $48 = $8 ; $49 = ( ( $48 | 0 ) / 8 ) & - 1 ; $50 = ( 100297 + ( $49 ) | 0 ) ; $51 = HEAP8 [ $50 >> 0 ] | 0 ; $52 = $51 & 255 ; $53 = $8 ; $54 = ( ( $53 | 0 ) % 8 ) & - 1 ; $55 = 1 << $54 ; $56 = $52 & $55 ; $57 = ( $56 | 0 ) != ( 0 ) ; $58 = $57 & 1 ; $59 = $9 ; $60 = $58 << $59 ; $61 = $10 ; $62 = $61 | $60 ; $10 = $62 ; $63 = $8 ; $64 = ( ( $63 ) + 1 ) | 0 ; $8 = $64 ; $65 = $9 ; $66 = ( ( $65 ) + 1 ) | 0 ; $9 = $66 ; } $67 = $4 ; $68 = HEAP32 [ 16731 ] | 0 ; $69 = ( ( $68 ) + ( $67 ) ) | 0 ; HEAP32 [ 16731 ] = $69 ; $70 = $10 ; $3 = $70 ; $71 = $3 ; STACKTOP = sp ; return ( $71 | 0 ) ; } function _GIFInitExtension ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$sink = 0 , $$sink2 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 ; var $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $3 = $0 ; $4 = $1 ; $5 = $2 ; $7 = $4 ; $8 = $3 ; HEAP32 [ $8 >> 2 ] = $7 ; $9 = $5 ; $10 = ( $9 >>> 0 ) > ( 0 ) ; if ( ! ( $10 ) ) { $20 = $3 ; $21 = ( ( ( $20 ) ) + 4 | 0 ) ; HEAP32 [ $21 >> 2 ] = 0 ; $22 = $3 ; $$sink = 0 ; $$sink2 = $22 ; $23 = ( ( ( $$sink2 ) ) + 8 | 0 ) ; HEAP32 [ $23 >> 2 ] = $$sink ; STACKTOP = sp ; return ; } $11 = $5 ; $12 = ( _malloc ( $11 ) | 0 ) ; $6 = $12 ; $13 = $6 ; $14 = ( $13 | 0 ) == ( 0 | 0 ) ; if ( $14 ) { _ErrorAlloc ( ) ; } $15 = $6 ; $16 = $3 ; $17 = ( ( ( $16 ) ) + 4 | 0 ) ; HEAP32 [ $17 >> 2 ] = $15 ; $18 = $5 ; $19 = $3 ; $$sink = $18 ; $$sink2 = $19 ; $23 = ( ( ( $$sink2 ) ) + 8 | 0 ) ; HEAP32 [ $23 >> 2 ] = $$sink ; STACKTOP = sp ; return ; } function _GIFDestroyExtension ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $2 = $1 ; $3 = ( ( ( $2 ) ) + 4 | 0 ) ; $4 = HEAP32 [ $3 >> 2 ] | 0 ; _free ( $4 ) ; STACKTOP = sp ; return ; } function _GIFGetGraphicCtl ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 ; var $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 ; var $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = $0 ; $3 = $1 ; $5 = $3 ; $6 = ( ( ( $5 ) ) + 12 | 0 ) ; $7 = HEAP8 [ $6 >> 0 ] | 0 ; $8 = $7 & 255 ; $9 = ( $8 | 0 ) != ( 249 ) ; if ( $9 ) { $10 = HEAP32 [ 2364 ] | 0 ; FUNCTION_TABLE_vi [ $10 & 127 ] ( 30164 ) ; STACKTOP = sp ; return ; } $11 = $3 ; $12 = ( ( ( $11 ) ) + 8 | 0 ) ; $13 = HEAP32 [ $12 >> 2 ] | 0 ; $14 = ( $13 >>> 0 ) < ( 4 ) ; if ( $14 ) { $15 = HEAP32 [ 2364 ] | 0 ; FUNCTION_TABLE_vi [ $15 & 127 ] ( 30208 ) ; STACKTOP = sp ; return ; } else { $16 = $3 ; $17 = ( ( ( $16 ) ) + 4 | 0 ) ; $18 = HEAP32 [ $17 >> 2 ] | 0 ; $4 = $18 ; $19 = $4 ; $20 = HEAP8 [ $19 >> 0 ] | 0 ; $21 = $20 & 255 ; $22 = $21 >> 2 ; $23 = $22 & 7 ; $24 = $2 ; HEAP32 [ $24 >> 2 ] = $23 ; $25 = $4 ; $26 = HEAP8 [ $25 >> 0 ] | 0 ; $27 = $26 & 255 ; $28 = $27 >> 1 ; $29 = $28 & 1 ; $30 = $2 ; $31 = ( ( ( $30 ) ) + 4 | 0 ) ; HEAP32 [ $31 >> 2 ] = $29 ; $32 = $4 ; $33 = HEAP8 [ $32 >> 0 ] | 0 ; $34 = $33 & 255 ; $35 = $34 & 1 ; $36 = $2 ; $37 = ( ( ( $36 ) ) + 8 | 0 ) ; HEAP32 [ $37 >> 2 ] = $35 ; $38 = $4 ; $39 = ( ( ( $38 ) ) + 1 | 0 ) ; $40 = HEAP8 [ $39 >> 0 ] | 0 ; $41 = $40 & 255 ; $42 = $4 ; $43 = ( ( ( $42 ) ) + 1 | 0 ) ; $44 = ( ( ( $43 ) ) + 1 | 0 ) ; $45 = HEAP8 [ $44 >> 0 ] | 0 ; $46 = $45 & 255 ; $47 = $46 << 8 ; $48 = ( ( $41 ) + ( $47 ) ) | 0 ; $49 = $2 ; $50 = ( ( ( $49 ) ) + 12 | 0 ) ; HEAP32 [ $50 >> 2 ] = $48 ; $51 = $4 ; $52 = ( ( ( $51 ) ) + 3 | 0 ) ; $53 = HEAP8 [ $52 >> 0 ] | 0 ; $54 = $53 & 255 ; $55 = $2 ; $56 = ( ( ( $55 ) ) + 16 | 0 ) ; HEAP32 [ $56 >> 2 ] = $54 ; STACKTOP = sp ; return ; } } function _pnm_fget_header ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 ; var $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 ; var $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 ; var $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , $or$cond11 = 0 , $or$cond3 = 0 , $or$cond5 = 0 , $or$cond7 = 0 , $or$cond9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $3 = $0 ; $4 = $1 ; $7 = $3 ; ; HEAP32 [ $7 >> 2 ] = 0 | 0 ; HEAP32 [ $7 + 4 >> 2 ] = 0 | 0 ; HEAP32 [ $7 + 8 >> 2 ] = 0 | 0 ; HEAP32 [ $7 + 12 >> 2 ] = 0 | 0 ; HEAP32 [ $7 + 16 >> 2 ] = 0 | 0 ; $8 = $4 ; $9 = ( _getc ( $8 ) | 0 ) ; $6 = $9 ; $10 = $6 ; $11 = ( $10 | 0 ) == ( - 1 ) ; if ( $11 ) { $2 = - 1 ; $71 = $2 ; STACKTOP = sp ; return ( $71 | 0 ) ; } $12 = $6 ; $13 = ( $12 | 0 ) != ( 80 ) ; if ( $13 ) { $2 = - 1 ; $71 = $2 ; STACKTOP = sp ; return ( $71 | 0 ) ; } $14 = $4 ; $15 = ( _getc ( $14 ) | 0 ) ; $6 = $15 ; $16 = $6 ; $17 = ( $16 | 0 ) < ( 49 ) ; $18 = $6 ; $19 = ( $18 | 0 ) > ( 57 ) ; $or$cond = $17 | $19 ; if ( $or$cond ) { $2 = - 1 ; $71 = $2 ; STACKTOP = sp ; return ( $71 | 0 ) ; } $20 = $6 ; $21 = ( ( $20 ) - 48 ) | 0 ; $5 = $21 ; $22 = $4 ; $23 = ( _pnm_fget_char ( $22 ) | 0 ) ; $6 = $23 ; $24 = $6 ; $25 = ( $24 | 0 ) == ( 32 ) ; $26 = $6 ; $27 = ( $26 | 0 ) == ( 9 ) ; $or$cond3 = $25 | $27 ; $28 = $6 ; $29 = ( $28 | 0 ) == ( 10 ) ; $or$cond5 = $or$cond3 | $29 ; $30 = $6 ; $31 = ( $30 | 0 ) == ( 13 ) ; $or$cond7 = $or$cond5 | $31 ; if ( ! ( $or$cond7 ) ) { $2 = - 1 ; $71 = $2 ; STACKTOP = sp ; return ( $71 | 0 ) ; } $32 = $5 ; $33 = $3 ; HEAP32 [ $33 >> 2 ] = $32 ; $34 = $5 ; $35 = ( $34 >>> 0 ) >= ( 1 ) ; $36 = $5 ; $37 = ( $36 >>> 0 ) <= ( 6 ) ; $or$cond9 = $35 & $37 ; if ( ! ( $or$cond9 ) ) { $2 = - 1 ; $71 = $2 ; STACKTOP = sp ; return ( $71 | 0 ) ; } $38 = $5 ; $39 = ( $38 | 0 ) == ( 3 ) ; $40 = $5 ; $41 = ( $40 | 0 ) == ( 6 ) ; $42 = $39 ? 1 : $41 ; $43 = $42 ? 3 : 1 ; $44 = $3 ; $45 = ( ( ( $44 ) ) + 4 | 0 ) ; HEAP32 [ $45 >> 2 ] = $43 ; $46 = $4 ; $47 = $3 ; $48 = ( ( ( $47 ) ) + 8 | 0 ) ; $49 = ( _pnm_fscan_uint ( $46 , $48 ) | 0 ) ; $50 = ( $49 | 0 ) != ( 1 ) ; if ( ! ( $50 ) ) { $51 = $4 ; $52 = $3 ; $53 = ( ( ( $52 ) ) + 12 | 0 ) ; $54 = ( _pnm_fscan_uint ( $51 , $53 ) | 0 ) ; $55 = ( $54 | 0 ) != ( 1 ) ; if ( ! ( $55 ) ) { $56 = $5 ; $57 = ( $56 | 0 ) == ( 1 ) ; $58 = $5 ; $59 = ( $58 | 0 ) == ( 4 ) ; $or$cond11 = $57 | $59 ; if ( $or$cond11 ) { $60 = $3 ; $61 = ( ( ( $60 ) ) + 16 | 0 ) ; HEAP32 [ $61 >> 2 ] = 1 ; } else { $62 = $4 ; $63 = $3 ; $64 = ( ( ( $63 ) ) + 16 | 0 ) ; $65 = ( _pnm_fscan_uint ( $62 , $64 ) | 0 ) ; $66 = ( $65 | 0 ) != ( 1 ) ; if ( $66 ) { $2 = - 1 ; $71 = $2 ; STACKTOP = sp ; return ( $71 | 0 ) ; } } $67 = $3 ; $68 = ( _pnm_is_valid ( $67 ) | 0 ) ; $69 = ( $68 | 0 ) != ( 0 ) ; $70 = $69 ? 1 : 0 ; $2 = $70 ; $71 = $2 ; STACKTOP = sp ; return ( $71 | 0 ) ; } } $2 = - 1 ; $71 = $2 ; STACKTOP = sp ; return ( $71 | 0 ) ; } function _pnm_fget_char ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 ; var $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , $or$cond3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $3 = $1 ; $4 = ( _getc ( $3 ) | 0 ) ; $2 = $4 ; $5 = $2 ; $6 = ( $5 | 0 ) == ( 35 ) ; if ( $6 ) { while ( 1 ) { $7 = $1 ; $8 = ( _getc ( $7 ) | 0 ) ; $2 = $8 ; $9 = $2 ; $10 = ( $9 | 0 ) != ( - 1 ) ; $11 = $2 ; $12 = ( $11 | 0 ) != ( 10 ) ; $or$cond = $10 & $12 ; $13 = $2 ; $14 = ( $13 | 0 ) != ( 13 ) ; $or$cond3 = $or$cond & $14 ; if ( ! ( $or$cond3 ) ) { break ; } } } $15 = $2 ; $16 = ( $15 | 0 ) == ( 13 ) ; if ( ! ( $16 ) ) { $23 = $2 ; STACKTOP = sp ; return ( $23 | 0 ) ; } $17 = $1 ; $18 = ( _getc ( $17 ) | 0 ) ; $2 = $18 ; $19 = $2 ; $20 = ( $19 | 0 ) != ( 10 ) ; if ( ! ( $20 ) ) { $23 = $2 ; STACKTOP = sp ; return ( $23 | 0 ) ; } $21 = $2 ; $22 = $1 ; ( _ungetc ( $21 , $22 ) | 0 ) ; $2 = 10 ; $23 = $2 ; STACKTOP = sp ; return ( $23 | 0 ) ; } function _pnm_fscan_uint ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 ; var $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 ; var $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , $or$cond11 = 0 , $or$cond13 = 0 , $or$cond3 = 0 ; var $or$cond5 = 0 , $or$cond7 = 0 , $or$cond9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $3 = $0 ; $4 = $1 ; while ( 1 ) { $7 = $3 ; $8 = ( _pnm_fget_char ( $7 ) | 0 ) ; $5 = $8 ; $9 = $5 ; $10 = ( $9 | 0 ) == ( 32 ) ; $11 = $5 ; $12 = ( $11 | 0 ) == ( 9 ) ; $or$cond = $10 | $12 ; $13 = $5 ; $14 = ( $13 | 0 ) == ( 10 ) ; $or$cond3 = $or$cond | $14 ; $15 = $5 ; $16 = ( $15 | 0 ) == ( 13 ) ; $or$cond13 = $or$cond3 | $16 ; if ( ! ( $or$cond13 ) ) { break ; } } $17 = $5 ; $18 = ( $17 | 0 ) == ( - 1 ) ; if ( $18 ) { $2 = - 1 ; $57 = $2 ; STACKTOP = sp ; return ( $57 | 0 ) ; } $19 = $5 ; $20 = ( $19 | 0 ) >= ( 48 ) ; $21 = $5 ; $22 = ( $21 | 0 ) <= ( 57 ) ; $or$cond5 = $20 & $22 ; if ( ! ( $or$cond5 ) ) { $23 = $5 ; $24 = $3 ; ( _ungetc ( $23 , $24 ) | 0 ) ; $2 = 0 ; $57 = $2 ; STACKTOP = sp ; return ( $57 | 0 ) ; } $25 = $4 ; HEAP32 [ $25 >> 2 ] = 0 ; while ( 1 ) { $26 = $4 ; $27 = HEAP32 [ $26 >> 2 ] | 0 ; $28 = ( $27 * 10 ) | 0 ; $29 = $5 ; $30 = ( ( $29 ) - 48 ) | 0 ; $31 = ( ( $28 ) + ( $30 ) ) | 0 ; $6 = $31 ; $32 = $6 ; $33 = $4 ; $34 = HEAP32 [ $33 >> 2 ] | 0 ; $35 = ( $32 >>> 0 ) >= ( $34 >>> 0 ) ; if ( $35 ) { $36 = $6 ; $37 = $4 ; HEAP32 [ $37 >> 2 ] = $36 ; } else { $38 = $4 ; HEAP32 [ $38 >> 2 ] = - 1 ; $39 = ( ___errno_location ( ) | 0 ) ; HEAP32 [ $39 >> 2 ] = 34 ; } $40 = $3 ; $41 = ( _getc ( $40 ) | 0 ) ; $5 = $41 ; $42 = $5 ; $43 = ( $42 | 0 ) >= ( 48 ) ; $44 = $5 ; $45 = ( $44 | 0 ) <= ( 57 ) ; $46 = $43 ? $45 : 0 ; if ( ! ( $46 ) ) { break ; } } $47 = $5 ; $48 = ( $47 | 0 ) == ( 32 ) ; $49 = $5 ; $50 = ( $49 | 0 ) == ( 9 ) ; $or$cond7 = $48 | $50 ; $51 = $5 ; $52 = ( $51 | 0 ) == ( 10 ) ; $or$cond9 = $or$cond7 | $52 ; $53 = $5 ; $54 = ( $53 | 0 ) == ( 13 ) ; $or$cond11 = $or$cond9 | $54 ; if ( ! ( $or$cond11 ) ) { $55 = $5 ; $56 = $3 ; ( _ungetc ( $55 , $56 ) | 0 ) ; } $2 = 1 ; $57 = $2 ; STACKTOP = sp ; return ( $57 | 0 ) ; } function _pnm_fget_values ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 ; var $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 ; var $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 ; var $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 ; var $29 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 ; var $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 ; var $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 ; var $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $or$cond = 0 , $or$cond3 = 0 , $or$cond5 = 0 ; var $or$cond7 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 80 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 80 | 0 ) ; $5 = $0 ; $6 = $1 ; $7 = $2 ; $8 = $3 ; $22 = $5 ; $23 = HEAP32 [ $22 >> 2 ] | 0 ; $9 = $23 ; $24 = $5 ; $25 = ( ( ( $24 ) ) + 4 | 0 ) ; $26 = HEAP32 [ $25 >> 2 ] | 0 ; $10 = $26 ; $27 = $5 ; $28 = ( ( ( $27 ) ) + 8 | 0 ) ; $29 = HEAP32 [ $28 >> 2 ] | 0 ; $11 = $29 ; $30 = $5 ; $31 = ( ( ( $30 ) ) + 16 | 0 ) ; $32 = HEAP32 [ $31 >> 2 ] | 0 ; $12 = $32 ; $33 = $10 ; $34 = $11 ; $35 = Math_imul ( $33 , $34 ) | 0 ; $13 = $35 ; $36 = $7 ; $37 = $13 ; $38 = Math_imul ( $36 , $37 ) | 0 ; $14 = $38 ; $39 = $9 ; L1 : do { switch ( $39 | 0 ) { case 1 : { $20 = 0 ; while ( 1 ) { $40 = $20 ; $41 = $14 ; $42 = ( $40 >>> 0 ) < ( $41 >>> 0 ) ; if ( ! ( $42 ) ) { break L1 ; } while ( 1 ) { $43 = $8 ; $44 = ( _pnm_fget_char ( $43 ) | 0 ) ; $15 = $44 ; $45 = $15 ; $46 = ( $45 | 0 ) == ( 32 ) ; $47 = $15 ; $48 = ( $47 | 0 ) == ( 9 ) ; $or$cond = $46 | $48 ; $49 = $15 ; $50 = ( $49 | 0 ) == ( 10 ) ; $or$cond3 = $or$cond | $50 ; $51 = $15 ; $52 = ( $51 | 0 ) == ( 13 ) ; $or$cond7 = $or$cond3 | $52 ; if ( ! ( $or$cond7 ) ) { break ; } } $53 = $15 ; $54 = ( $53 | 0 ) != ( 48 ) ; $55 = $15 ; $56 = ( $55 | 0 ) != ( 49 ) ; $or$cond5 = $54 & $56 ; $57 = $15 ; if ( $or$cond5 ) { break ; } $59 = ( $57 | 0 ) == ( 48 ) ; $60 = $59 ? 1 : 0 ; $61 = $6 ; $62 = $20 ; $63 = ( ( $61 ) + ( $62 << 2 ) | 0 ) ; HEAP32 [ $63 >> 2 ] = $60 ; $64 = $20 ; $65 = ( ( $64 ) + 1 ) | 0 ; $20 = $65 ; } $58 = $8 ; ( _ungetc ( $57 , $58 ) | 0 ) ; break ; } case 3 : case 2 : { $20 = 0 ; while ( 1 ) { $66 = $20 ; $67 = $14 ; $68 = ( $66 >>> 0 ) < ( $67 >>> 0 ) ; if ( ! ( $68 ) ) { break L1 ; } $69 = $8 ; $70 = $6 ; $71 = $20 ; $72 = ( ( $70 ) + ( $71 << 2 ) | 0 ) ; $73 = ( _pnm_fscan_uint ( $69 , $72 ) | 0 ) ; $74 = ( $73 | 0 ) != ( 1 ) ; if ( $74 ) { break L1 ; } $75 = $20 ; $76 = ( ( $75 ) + 1 ) | 0 ; $20 = $76 ; } break ; } case 4 : { $21 = 0 ; $20 = 0 ; L18 : while ( 1 ) { $77 = $20 ; $78 = $14 ; $79 = ( $77 >>> 0 ) < ( $78 >>> 0 ) ; if ( ! ( $79 ) ) { break L1 ; } $80 = $8 ; $81 = ( _getc ( $80 ) | 0 ) ; $15 = $81 ; $82 = $15 ; $83 = ( $82 | 0 ) == ( - 1 ) ; if ( $83 ) { break L1 ; } $19 = 128 ; while ( 1 ) { $84 = $19 ; $85 = ( $84 | 0 ) != ( 0 ) ; if ( ! ( $85 ) ) { continue L18 ; } $86 = $15 ; $87 = $19 ; $88 = $86 & $87 ; $89 = ( $88 | 0 ) != ( 0 ) ; $90 = $89 ? 0 : 1 ; $91 = $6 ; $92 = $20 ; $93 = ( ( $92 ) + 1 ) | 0 ; $20 = $93 ; $94 = ( ( $91 ) + ( $92 << 2 ) | 0 ) ; HEAP32 [ $94 >> 2 ] = $90 ; $95 = $21 ; $96 = ( ( $95 ) + 1 ) | 0 ; $21 = $96 ; $97 = $13 ; $98 = ( $96 | 0 ) == ( $97 | 0 ) ; if ( $98 ) { break ; } $99 = $19 ; $100 = $99 >> 1 ; $19 = $100 ; } $21 = 0 ; } break ; } case 7 : case 6 : case 5 : { $101 = $12 ; $102 = ( $101 >>> 0 ) <= ( 255 ) ; if ( $102 ) { $20 = 0 ; while ( 1 ) { $103 = $20 ; $104 = $14 ; $105 = ( $103 >>> 0 ) < ( $104 >>> 0 ) ; if ( ! ( $105 ) ) { break L1 ; } $106 = $8 ; $107 = ( _getc ( $106 ) | 0 ) ; $15 = $107 ; $108 = $15 ; $109 = ( $108 | 0 ) == ( - 1 ) ; if ( $109 ) { break L1 ; } $110 = $15 ; $111 = $6 ; $112 = $20 ; $113 = ( ( $111 ) + ( $112 << 2 ) | 0 ) ; HEAP32 [ $113 >> 2 ] = $110 ; $114 = $20 ; $115 = ( ( $114 ) + 1 ) | 0 ; $20 = $115 ; } } $116 = $12 ; $117 = ( $116 >>> 0 ) <= ( 65535 ) ; if ( $117 ) { $20 = 0 ; while ( 1 ) { $118 = $20 ; $119 = $14 ; $120 = ( $118 >>> 0 ) < ( $119 >>> 0 ) ; if ( ! ( $120 ) ) { break L1 ; } $121 = $8 ; $122 = ( _getc ( $121 ) | 0 ) ; $16 = $122 ; $123 = $8 ; $124 = ( _getc ( $123 ) | 0 ) ; $15 = $124 ; $125 = $15 ; $126 = ( $125 | 0 ) == ( - 1 ) ; if ( $126 ) { break L1 ; } $127 = $16 ; $128 = $127 << 8 ; $129 = $15 ; $130 = ( ( $128 ) + ( $129 ) ) | 0 ; $131 = $6 ; $132 = $20 ; $133 = ( ( $131 ) + ( $132 << 2 ) | 0 ) ; HEAP32 [ $133 >> 2 ] = $130 ; $134 = $20 ; $135 = ( ( $134 ) + 1 ) | 0 ; $20 = $135 ; } } $136 = $12 ; $137 = ( $136 >>> 0 ) <= ( 4294967295 ) ; if ( ! ( $137 ) ) { $168 = ( ___errno_location ( ) | 0 ) ; HEAP32 [ $168 >> 2 ] = 22 ; $4 = 0 ; $180 = $4 ; STACKTOP = sp ; return ( $180 | 0 ) ; } $18 = 0 ; $20 = 0 ; while ( 1 ) { $138 = $20 ; $139 = $14 ; $140 = ( $138 >>> 0 ) < ( $139 >>> 0 ) ; if ( ! ( $140 ) ) { break L1 ; } $141 = $12 ; $142 = ( $141 >>> 0 ) > ( 16777215 ) ; if ( $142 ) { $143 = $8 ; $144 = ( _getc ( $143 ) | 0 ) ; $18 = $144 ; } $145 = $8 ; $146 = ( _getc ( $145 ) | 0 ) ; $17 = $146 ; $147 = $8 ; $148 = ( _getc ( $147 ) | 0 ) ; $16 = $148 ; $149 = $8 ; $150 = ( _getc ( $149 ) | 0 ) ; $15 = $150 ; $151 = $15 ; $152 = ( $151 | 0 ) == ( - 1 ) ; if ( $152 ) { break L1 ; } $153 = $18 ; $154 = $153 << 24 ; $155 = $17 ; $156 = $155 << 16 ; $157 = ( ( $154 ) + ( $156 ) ) | 0 ; $158 = $16 ; $159 = $158 << 8 ; $160 = ( ( $157 ) + ( $159 ) ) | 0 ; $161 = $15 ; $162 = ( ( $160 ) + ( $161 ) ) | 0 ; $163 = $6 ; $164 = $20 ; $165 = ( ( $163 ) + ( $164 << 2 ) | 0 ) ; HEAP32 [ $165 >> 2 ] = $162 ; $166 = $20 ; $167 = ( ( $166 ) + 1 ) | 0 ; $20 = $167 ; } break ; } default : { $169 = ( ___errno_location ( ) | 0 ) ; HEAP32 [ $169 >> 2 ] = 22 ; $4 = 0 ; $180 = $4 ; STACKTOP = sp ; return ( $180 | 0 ) ; } } } while ( 0 ) ; $170 = $20 ; $171 = $14 ; $172 = ( $170 >>> 0 ) < ( $171 >>> 0 ) ; if ( $172 ) { $173 = $6 ; $174 = $20 ; $175 = ( ( $173 ) + ( $174 << 2 ) | 0 ) ; $176 = $14 ; $177 = $20 ; $178 = ( ( $176 ) - ( $177 ) ) | 0 ; $179 = $178 << 2 ; _memset ( ( $175 | 0 ) , 0 , ( $179 | 0 ) ) | 0 ; $4 = - 1 ; $180 = $4 ; STACKTOP = sp ; return ( $180 | 0 ) ; } else { $4 = 1 ; $180 = $4 ; STACKTOP = sp ; return ( $180 | 0 ) ; } return ( 0 ) | 0 ; } function _pnm_fget_bytes ( $0 , $1 , $2 , $3 , $4 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; $4 = $4 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 ; var $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 ; var $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 ; var $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 80 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 80 | 0 ) ; $6 = $0 ; $7 = $1 ; $8 = $2 ; $9 = $3 ; $10 = $4 ; $22 = $6 ; $23 = HEAP32 [ $22 >> 2 ] | 0 ; $11 = $23 ; $24 = $6 ; $25 = ( ( ( $24 ) ) + 4 | 0 ) ; $26 = HEAP32 [ $25 >> 2 ] | 0 ; $12 = $26 ; $27 = $6 ; $28 = ( ( ( $27 ) ) + 8 | 0 ) ; $29 = HEAP32 [ $28 >> 2 ] | 0 ; $13 = $29 ; $30 = $6 ; $31 = ( ( ( $30 ) ) + 16 | 0 ) ; $32 = HEAP32 [ $31 >> 2 ] | 0 ; $14 = $32 ; $33 = $12 ; $34 = $13 ; $35 = Math_imul ( $33 , $34 ) | 0 ; $15 = $35 ; $36 = $9 ; $37 = $15 ; $38 = Math_imul ( $36 , $37 ) | 0 ; $16 = $38 ; $39 = $14 ; $40 = ( $39 >>> 0 ) <= ( 255 ) ; do { if ( $40 ) { $17 = 1 ; } else { $41 = $14 ; $42 = ( $41 >>> 0 ) <= ( 65535 ) ; if ( $42 ) { $17 = 2 ; break ; } $43 = $14 ; $44 = ( $43 >>> 0 ) <= ( 16777215 ) ; if ( $44 ) { $17 = 3 ; break ; } $45 = $14 ; $46 = ( $45 >>> 0 ) <= ( 4294967295 ) ; if ( $46 ) { $17 = 4 ; break ; } else { $47 = $8 ; $48 = ( $47 | 0 ) != ( 0 ) ; $49 = $48 ^ 1 ; $50 = $49 & 1 ; $17 = $50 ; break ; } } } while ( 0 ) ; $51 = $17 ; $52 = $8 ; $53 = ( $51 | 0 ) != ( $52 | 0 ) ; if ( $53 ) { $54 = ( ___errno_location ( ) | 0 ) ; HEAP32 [ $54 >> 2 ] = 22 ; $5 = 0 ; $98 = $5 ; STACKTOP = sp ; return ( $98 | 0 ) ; } $55 = $11 ; L18 : do { switch ( $55 | 0 ) { case 4 : { $21 = 0 ; $20 = 0 ; L22 : while ( 1 ) { $56 = $20 ; $57 = $16 ; $58 = ( $56 >>> 0 ) < ( $57 >>> 0 ) ; if ( ! ( $58 ) ) { break L18 ; } $59 = $10 ; $60 = ( _getc ( $59 ) | 0 ) ; $18 = $60 ; $61 = $18 ; $62 = ( $61 | 0 ) == ( - 1 ) ; if ( $62 ) { break L18 ; } $19 = 128 ; while ( 1 ) { $63 = $19 ; $64 = ( $63 | 0 ) != ( 0 ) ; if ( ! ( $64 ) ) { continue L22 ; } $65 = $18 ; $66 = $19 ; $67 = $65 & $66 ; $68 = ( $67 | 0 ) != ( 0 ) ; $69 = $68 ? 0 : 1 ; $70 = $69 & 255 ; $71 = $7 ; $72 = $20 ; $73 = ( ( $72 ) + 1 ) | 0 ; $20 = $73 ; $74 = ( ( $71 ) + ( $72 ) | 0 ) ; HEAP8 [ $74 >> 0 ] = $70 ; $75 = $21 ; $76 = ( ( $75 ) + 1 ) | 0 ; $21 = $76 ; $77 = $15 ; $78 = ( $76 | 0 ) == ( $77 | 0 ) ; if ( $78 ) { break ; } $79 = $19 ; $80 = $79 >> 1 ; $19 = $80 ; } $21 = 0 ; } break ; } case 7 : case 6 : case 5 : { $81 = $7 ; $82 = $8 ; $83 = $16 ; $84 = $10 ; $85 = ( _fread ( $81 , $82 , $83 , $84 ) | 0 ) ; $20 = $85 ; break ; } default : { $86 = ( ___errno_location ( ) | 0 ) ; HEAP32 [ $86 >> 2 ] = 22 ; $5 = 0 ; $98 = $5 ; STACKTOP = sp ; return ( $98 | 0 ) ; } } } while ( 0 ) ; $87 = $20 ; $88 = $16 ; $89 = ( $87 >>> 0 ) < ( $88 >>> 0 ) ; if ( $89 ) { $90 = $7 ; $91 = $20 ; $92 = ( ( $90 ) + ( $91 ) | 0 ) ; $93 = $8 ; $94 = $16 ; $95 = Math_imul ( $93 , $94 ) | 0 ; $96 = $20 ; $97 = ( ( $95 ) - ( $96 ) ) | 0 ; _memset ( ( $92 | 0 ) , 0 , ( $97 | 0 ) ) | 0 ; $5 = - 1 ; $98 = $5 ; STACKTOP = sp ; return ( $98 | 0 ) ; } else { $5 = 1 ; $98 = $5 ; STACKTOP = sp ; return ( $98 | 0 ) ; } return ( 0 ) | 0 ; } function _pnm_is_valid ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 ; var $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $5 = 0 , $6 = 0 ; var $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , $or$cond3 = 0 , $or$cond5 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $2 = $0 ; $8 = $2 ; $9 = HEAP32 [ $8 >> 2 ] | 0 ; $3 = $9 ; $10 = $2 ; $11 = ( ( ( $10 ) ) + 4 | 0 ) ; $12 = HEAP32 [ $11 >> 2 ] | 0 ; $4 = $12 ; $13 = $2 ; $14 = ( ( ( $13 ) ) + 8 | 0 ) ; $15 = HEAP32 [ $14 >> 2 ] | 0 ; $5 = $15 ; $16 = $2 ; $17 = ( ( ( $16 ) ) + 12 | 0 ) ; $18 = HEAP32 [ $17 >> 2 ] | 0 ; $6 = $18 ; $19 = $2 ; $20 = ( ( ( $19 ) ) + 16 | 0 ) ; $21 = HEAP32 [ $20 >> 2 ] | 0 ; $7 = $21 ; $22 = $4 ; $23 = ( $22 | 0 ) == ( 0 ) ; $24 = $5 ; $25 = ( $24 | 0 ) == ( 0 ) ; $or$cond = $23 | $25 ; $26 = $6 ; $27 = ( $26 | 0 ) == ( 0 ) ; $or$cond3 = $or$cond | $27 ; $28 = $7 ; $29 = ( $28 | 0 ) == ( 0 ) ; $or$cond5 = $or$cond3 | $29 ; L1 : do { if ( $or$cond5 ) { $1 = 0 ; } else { $30 = $3 ; switch ( $30 | 0 ) { case 4 : case 1 : { $31 = $4 ; $32 = ( $31 | 0 ) == ( 1 ) ; $33 = $7 ; $34 = ( $33 | 0 ) == ( 1 ) ; $35 = $32 ? $34 : 0 ; $36 = $35 ? 1 : 0 ; $1 = $36 ; break L1 ; break ; } case 5 : case 2 : { $37 = $4 ; $38 = ( $37 | 0 ) == ( 1 ) ; $39 = $38 ? 1 : 0 ; $1 = $39 ; break L1 ; break ; } case 6 : case 3 : { $40 = $4 ; $41 = ( $40 | 0 ) == ( 3 ) ; $42 = $41 ? 1 : 0 ; $1 = $42 ; break L1 ; break ; } case 7 : { $1 = 1 ; break L1 ; break ; } default : { $1 = 0 ; break L1 ; } } } } while ( 0 ) ; $43 = $1 ; STACKTOP = sp ; return ( $43 | 0 ) ; } function _minitiff_read_info ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$sink = 0 , $$sink5 = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 ; var $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 ; var $134 = 0 , $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 ; var $152 = 0 , $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 ; var $170 = 0 , $171 = 0 , $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 ; var $189 = 0 , $19 = 0 , $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $2 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 ; var $206 = 0 , $207 = 0 , $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 ; var $224 = 0 , $225 = 0 , $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 ; var $242 = 0 , $243 = 0 , $244 = 0 , $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 , $258 = 0 , $259 = 0 , $26 = 0 ; var $260 = 0 , $261 = 0 , $262 = 0 , $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 , $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 , $270 = 0 , $271 = 0 , $272 = 0 , $273 = 0 , $274 = 0 , $275 = 0 , $276 = 0 , $277 = 0 , $278 = 0 ; var $279 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 ; var $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 ; var $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 ; var $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 ; var $get_ulong_i$sink = 0 , $get_ushort_i$sink = 0 , $or$cond = 0 , $or$cond3 = 0 , $switch$split242D = 0 , $switch$split272D = 0 , $switch$split2D = 0 , $switch$split302D = 0 , $switch$split332D = 0 , $switch$split362D = 0 , $switch$split392D = 0 , $switch$split422D = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 112 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 112 | 0 ) ; $4 = sp + 80 | 0 ; $5 = sp + 96 | 0 ; $7 = sp + 56 | 0 ; $2 = $0 ; $3 = $1 ; $21 = ( ( ( $5 ) ) + 8 | 0 ) ; $6 = $21 ; $22 = $3 ; $23 = ( _fread ( $5 , 8 , 1 , $22 ) | 0 ) ; $24 = ( $23 | 0 ) != ( 1 ) ; L1 : do { if ( $24 ) { label = 60 ; } else { $25 = ( _memcmp ( $5 , 30563 , 4 ) | 0 ) ; $26 = ( $25 | 0 ) == ( 0 ) ; do { if ( $26 ) { $27 = $2 ; $$sink = 77 ; $$sink5 = $27 ; $get_ulong_i$sink = 105 ; $get_ushort_i$sink = 104 ; } else { $28 = ( _memcmp ( $5 , 30567 , 4 ) | 0 ) ; $29 = ( $28 | 0 ) == ( 0 ) ; if ( $29 ) { $30 = $2 ; $$sink = 73 ; $$sink5 = $30 ; $get_ulong_i$sink = 107 ; $get_ushort_i$sink = 106 ; break ; } $31 = ( _memcmp ( $5 , 30571 , 4 ) | 0 ) ; $32 = ( $31 | 0 ) == ( 0 ) ; if ( ! ( $32 ) ) { $33 = ( _memcmp ( $5 , 30575 , 4 ) | 0 ) ; $34 = ( $33 | 0 ) == ( 0 ) ; if ( ! ( $34 ) ) { $36 = $2 ; _minitiff_error ( $36 , 30522 ) ; STACKTOP = sp ; return ; } } $35 = $2 ; _minitiff_error ( $35 , 30538 ) ; STACKTOP = sp ; return ; } } while ( 0 ) ; $37 = ( ( ( $$sink5 ) ) + 8 | 0 ) ; HEAP32 [ $37 >> 2 ] = $$sink ; HEAP32 [ $4 >> 2 ] = $get_ushort_i$sink ; $38 = ( ( ( $4 ) ) + 4 | 0 ) ; HEAP32 [ $38 >> 2 ] = $get_ulong_i$sink ; $15 = 0 ; $17 = 0 ; $16 = 0 ; $19 = 0 ; $18 = 0 ; $39 = ( ( ( $4 ) ) + 4 | 0 ) ; $40 = HEAP32 [ $39 >> 2 ] | 0 ; $41 = ( ( ( $5 ) ) + 4 | 0 ) ; $42 = ( FUNCTION_TABLE_ii [ $40 & 127 ] ( $41 ) | 0 ) ; $9 = $42 ; $43 = $9 ; $44 = ( $43 | 0 ) >= ( 0 ) ; $45 = $9 ; $46 = ( $45 | 0 ) < ( 8 ) ; $or$cond = $44 & $46 ; if ( $or$cond ) { label = 61 ; } else { $47 = $2 ; $48 = $9 ; $49 = $3 ; _seek_to_offset ( $47 , $48 , $49 ) ; $50 = $3 ; $51 = ( _fread ( $5 , 2 , 1 , $50 ) | 0 ) ; $52 = ( $51 | 0 ) != ( 1 ) ; if ( $52 ) { label = 60 ; } else { $53 = HEAP32 [ $4 >> 2 ] | 0 ; $54 = ( FUNCTION_TABLE_ii [ $53 & 127 ] ( $5 ) | 0 ) ; $10 = $54 ; $20 = 0 ; $11 = 0 ; while ( 1 ) { $55 = $11 ; $56 = $10 ; $57 = ( $55 >>> 0 ) < ( $56 >>> 0 ) ; $58 = $3 ; if ( ! ( $57 ) ) { break ; } $59 = ( _fread ( $5 , 12 , 1 , $58 ) | 0 ) ; $60 = ( $59 | 0 ) != ( 1 ) ; if ( $60 ) { label = 60 ; break L1 ; } $61 = HEAP32 [ $4 >> 2 ] | 0 ; $62 = ( FUNCTION_TABLE_ii [ $61 & 127 ] ( $5 ) | 0 ) ; $12 = $62 ; $63 = HEAP32 [ $4 >> 2 ] | 0 ; $64 = ( ( ( $5 ) ) + 2 | 0 ) ; $65 = ( FUNCTION_TABLE_ii [ $63 & 127 ] ( $64 ) | 0 ) ; $13 = $65 ; $66 = $2 ; $67 = ( ( ( $4 ) ) + 4 | 0 ) ; $68 = HEAP32 [ $67 >> 2 ] | 0 ; $69 = ( ( ( $5 ) ) + 4 | 0 ) ; $70 = ( FUNCTION_TABLE_ii [ $68 & 127 ] ( $69 ) | 0 ) ; $71 = ( _cast_ulong_to_uint ( $66 , $70 ) | 0 ) ; $14 = $71 ; $72 = $14 ; $73 = ( $72 | 0 ) == ( 0 ) ; if ( $73 ) { break L1 ; } $74 = $12 ; $switch$split2D = ( $74 | 0 ) < ( 278 ) ; L23 : do { if ( $switch$split2D ) { switch ( $74 | 0 ) { case 254 : { $75 = $14 ; $76 = ( $75 | 0 ) != ( 1 ) ; if ( $76 ) { break L1 ; } $77 = $13 ; $78 = $6 ; $79 = ( _get_ulong_value ( $4 , $77 , $78 ) | 0 ) ; $8 = $79 ; $80 = $8 ; $81 = ( $80 | 0 ) != ( 0 ) ; $82 = $8 ; $83 = ( $82 | 0 ) != ( 1 ) ; $or$cond3 = $81 & $83 ; if ( $or$cond3 ) { break L1 ; } else { break L23 ; } break ; } case 256 : { $84 = $14 ; $85 = ( $84 | 0 ) != ( 1 ) ; if ( $85 ) { break L1 ; } $86 = $13 ; $87 = $6 ; $88 = ( _get_ulong_value ( $4 , $86 , $87 ) | 0 ) ; $8 = $88 ; $89 = $2 ; $90 = $8 ; $91 = ( _cast_ulong_to_uint ( $89 , $90 ) | 0 ) ; $92 = $2 ; $93 = ( ( ( $92 ) ) + 12 | 0 ) ; HEAP32 [ $93 >> 2 ] = $91 ; break L23 ; break ; } case 257 : { $94 = $14 ; $95 = ( $94 | 0 ) != ( 1 ) ; if ( $95 ) { break L1 ; } $96 = $13 ; $97 = $6 ; $98 = ( _get_ulong_value ( $4 , $96 , $97 ) | 0 ) ; $8 = $98 ; $99 = $2 ; $100 = $8 ; $101 = ( _cast_ulong_to_uint ( $99 , $100 ) | 0 ) ; $102 = $2 ; $103 = ( ( ( $102 ) ) + 16 | 0 ) ; HEAP32 [ $103 >> 2 ] = $101 ; break L23 ; break ; } case 258 : { $104 = $14 ; $105 = ( $104 | 0 ) == ( 1 ) ; if ( $105 ) { $106 = $13 ; $107 = $6 ; $108 = ( _get_ulong_value ( $4 , $106 , $107 ) | 0 ) ; $8 = $108 ; $109 = $2 ; $110 = $8 ; $111 = ( _cast_ulong_to_uint ( $109 , $110 ) | 0 ) ; $112 = $2 ; $113 = ( ( ( $112 ) ) + 20 | 0 ) ; HEAP32 [ $113 >> 2 ] = $111 ; break L23 ; } else { $114 = $14 ; $15 = $114 ; $115 = $13 ; $16 = $115 ; $116 = ( ( ( $4 ) ) + 4 | 0 ) ; $117 = HEAP32 [ $116 >> 2 ] | 0 ; $118 = $6 ; $119 = ( FUNCTION_TABLE_ii [ $117 & 127 ] ( $118 ) | 0 ) ; $18 = $119 ; break L23 ; } break ; } case 259 : { $120 = $14 ; $121 = ( $120 | 0 ) != ( 1 ) ; if ( $121 ) { break L1 ; } $122 = $13 ; $123 = $6 ; $124 = ( _get_ulong_value ( $4 , $122 , $123 ) | 0 ) ; $8 = $124 ; $125 = $2 ; $126 = $8 ; $127 = ( _cast_ulong_to_uint ( $125 , $126 ) | 0 ) ; $128 = $2 ; $129 = ( ( ( $128 ) ) + 24 | 0 ) ; HEAP32 [ $129 >> 2 ] = $127 ; break L23 ; break ; } case 262 : { $130 = $14 ; $131 = ( $130 | 0 ) != ( 1 ) ; if ( $131 ) { break L1 ; } $132 = $13 ; $133 = $6 ; $134 = ( _get_ulong_value ( $4 , $132 , $133 ) | 0 ) ; $8 = $134 ; $135 = $2 ; $136 = $8 ; $137 = ( _cast_ulong_to_uint ( $135 , $136 ) | 0 ) ; $138 = $2 ; $139 = ( ( ( $138 ) ) + 28 | 0 ) ; HEAP32 [ $139 >> 2 ] = $137 ; break L23 ; break ; } case 273 : { $140 = $14 ; $141 = $2 ; $142 = ( ( ( $141 ) ) + 32 | 0 ) ; HEAP32 [ $142 >> 2 ] = $140 ; $143 = $14 ; $144 = ( $143 | 0 ) == ( 1 ) ; if ( ! ( $144 ) ) { $159 = $13 ; $17 = $159 ; $160 = ( ( ( $4 ) ) + 4 | 0 ) ; $161 = HEAP32 [ $160 >> 2 ] | 0 ; $162 = $6 ; $163 = ( FUNCTION_TABLE_ii [ $161 & 127 ] ( $162 ) | 0 ) ; $19 = $163 ; break L23 ; } $145 = $2 ; $146 = ( ( ( $145 ) ) + 36 | 0 ) ; $147 = HEAP32 [ $146 >> 2 ] | 0 ; $148 = ( $147 | 0 ) != ( 0 | 0 ) ; if ( $148 ) { label = 61 ; break L1 ; } $149 = $2 ; $150 = ( _alloc_ulong_array ( $149 , 1 ) | 0 ) ; $151 = $2 ; $152 = ( ( ( $151 ) ) + 36 | 0 ) ; HEAP32 [ $152 >> 2 ] = $150 ; $153 = $13 ; $154 = $6 ; $155 = ( _get_ulong_value ( $4 , $153 , $154 ) | 0 ) ; $156 = $2 ; $157 = ( ( ( $156 ) ) + 36 | 0 ) ; $158 = HEAP32 [ $157 >> 2 ] | 0 ; HEAP32 [ $158 >> 2 ] = $155 ; break L23 ; break ; } case 274 : { $164 = $14 ; $165 = ( $164 | 0 ) != ( 1 ) ; if ( $165 ) { break L1 ; } $166 = $13 ; $167 = $6 ; $168 = ( _get_ulong_value ( $4 , $166 , $167 ) | 0 ) ; $8 = $168 ; $169 = $2 ; $170 = $8 ; $171 = ( _cast_ulong_to_uint ( $169 , $170 ) | 0 ) ; $172 = $2 ; $173 = ( ( ( $172 ) ) + 40 | 0 ) ; HEAP32 [ $173 >> 2 ] = $171 ; break L23 ; break ; } case 277 : { $174 = $14 ; $175 = ( $174 | 0 ) != ( 1 ) ; if ( $175 ) { break L1 ; } $176 = $13 ; $177 = $6 ; $178 = ( _get_ulong_value ( $4 , $176 , $177 ) | 0 ) ; $8 = $178 ; $179 = $2 ; $180 = $8 ; $181 = ( _cast_ulong_to_uint ( $179 , $180 ) | 0 ) ; $182 = $2 ; $183 = ( ( ( $182 ) ) + 44 | 0 ) ; HEAP32 [ $183 >> 2 ] = $181 ; break L23 ; break ; } default : { break L23 ; } } } else { $switch$split242D = ( $74 | 0 ) < ( 34665 ) ; L50 : do { if ( $switch$split242D ) { $switch$split272D = ( $74 | 0 ) < ( 317 ) ; L52 : do { if ( $switch$split272D ) { switch ( $74 | 0 ) { case 284 : { break L52 ; break ; } case 278 : { break ; } default : { break L23 ; } } $184 = $14 ; $185 = ( $184 | 0 ) != ( 1 ) ; if ( $185 ) { break L1 ; } $186 = $13 ; $187 = $6 ; $188 = ( _get_ulong_value ( $4 , $186 , $187 ) | 0 ) ; $8 = $188 ; $189 = $2 ; $190 = $8 ; $191 = ( _cast_ulong_to_uint ( $189 , $190 ) | 0 ) ; $192 = $2 ; $193 = ( ( ( $192 ) ) + 48 | 0 ) ; HEAP32 [ $193 >> 2 ] = $191 ; break L23 ; } else { $switch$split332D = ( $74 | 0 ) < ( 700 ) ; if ( $switch$split332D ) { switch ( $74 | 0 ) { case 317 : { break L52 ; break ; } default : { break L23 ; } } } $switch$split392D = ( $74 | 0 ) < ( 33723 ) ; if ( $switch$split392D ) { switch ( $74 | 0 ) { case 700 : { break L50 ; break ; } default : { break L23 ; } } } else { switch ( $74 | 0 ) { case 33723 : { break L50 ; break ; } default : { break L23 ; } } } } } while ( 0 ) ; $194 = $14 ; $195 = ( $194 | 0 ) != ( 1 ) ; if ( $195 ) { break L1 ; } $196 = $13 ; $197 = $6 ; $198 = ( _get_ulong_value ( $4 , $196 , $197 ) | 0 ) ; $199 = ( $198 | 0 ) != ( 1 ) ; if ( $199 ) { break L1 ; } else { break L23 ; } } else { $switch$split302D = ( $74 | 0 ) < ( 34853 ) ; if ( $switch$split302D ) { switch ( $74 | 0 ) { case 34675 : case 34665 : { break L50 ; break ; } default : { break L23 ; } } } $switch$split362D = ( $74 | 0 ) < ( 40965 ) ; if ( $switch$split362D ) { switch ( $74 | 0 ) { case 34853 : { break L50 ; break ; } default : { break L23 ; } } } $switch$split422D = ( $74 | 0 ) < ( 50341 ) ; if ( $switch$split422D ) { switch ( $74 | 0 ) { case 40965 : { break L50 ; break ; } default : { break L23 ; } } } else { switch ( $74 | 0 ) { case 50341 : { break L50 ; break ; } default : { break L23 ; } } } } } while ( 0 ) ; $200 = $20 ; $201 = ( $200 | 0 ) != ( 0 ) ; if ( ! ( $201 ) ) { $20 = 1 ; $202 = $2 ; _minitiff_warning ( $202 , 30373 ) ; } } } while ( 0 ) ; $203 = $11 ; $204 = ( ( $203 ) + 1 ) | 0 ; $11 = $204 ; } $205 = ( _fread ( $5 , 4 , 1 , $58 ) | 0 ) ; $206 = ( $205 | 0 ) != ( 1 ) ; if ( $206 ) { label = 60 ; } else { $207 = ( ( ( $4 ) ) + 4 | 0 ) ; $208 = HEAP32 [ $207 >> 2 ] | 0 ; $209 = ( FUNCTION_TABLE_ii [ $208 & 127 ] ( $5 ) | 0 ) ; $210 = ( $209 | 0 ) != ( 0 ) ; if ( $210 ) { $211 = $2 ; _minitiff_warning ( $211 , 30325 ) ; } $212 = $18 ; $213 = ( $212 | 0 ) != ( 0 ) ; if ( $213 ) { $214 = $15 ; $14 = $214 ; $215 = $14 ; $216 = $2 ; $217 = ( ( ( $216 ) ) + 44 | 0 ) ; $218 = HEAP32 [ $217 >> 2 ] | 0 ; $219 = ( $215 | 0 ) != ( $218 | 0 ) ; if ( $219 ) { label = 61 ; break ; } $220 = $14 ; $221 = ( $220 >>> 0 ) > ( 4 ) ; if ( $221 ) { break ; } $222 = $2 ; $223 = $18 ; $224 = $3 ; _seek_to_offset ( $222 , $223 , $224 ) ; $225 = $16 ; $226 = $14 ; $227 = $3 ; $228 = ( _read_ulong_values ( $4 , $225 , $7 , $226 , $227 ) | 0 ) ; $229 = $14 ; $230 = ( $228 | 0 ) != ( $229 | 0 ) ; if ( $230 ) { label = 60 ; break ; } while ( 1 ) { $231 = $14 ; $232 = ( ( $231 ) + - 1 ) | 0 ; $14 = $232 ; $233 = ( $232 >>> 0 ) > ( 0 ) ; if ( ! ( $233 ) ) { break ; } $234 = HEAP32 [ $7 >> 2 ] | 0 ; $235 = $14 ; $236 = ( ( $7 ) + ( $235 << 2 ) | 0 ) ; $237 = HEAP32 [ $236 >> 2 ] | 0 ; $238 = ( $234 | 0 ) != ( $237 | 0 ) ; if ( $238 ) { break L1 ; } } $239 = $2 ; $240 = HEAP32 [ $7 >> 2 ] | 0 ; $241 = ( _cast_ulong_to_uint ( $239 , $240 ) | 0 ) ; $242 = $2 ; $243 = ( ( ( $242 ) ) + 20 | 0 ) ; HEAP32 [ $243 >> 2 ] = $241 ; } $244 = $19 ; $245 = ( $244 | 0 ) != ( 0 ) ; if ( ! ( $245 ) ) { STACKTOP = sp ; return ; } $246 = $2 ; $247 = ( ( ( $246 ) ) + 32 | 0 ) ; $248 = HEAP32 [ $247 >> 2 ] | 0 ; $14 = $248 ; $249 = $14 ; $250 = ( $249 | 0 ) == ( 0 ) ; if ( $250 ) { label = 61 ; } else { $251 = $14 ; $252 = $2 ; $253 = ( ( ( $252 ) ) + 16 | 0 ) ; $254 = HEAP32 [ $253 >> 2 ] | 0 ; $255 = ( $251 >>> 0 ) > ( $254 >>> 0 ) ; if ( $255 ) { label = 61 ; } else { $256 = $2 ; $257 = ( ( ( $256 ) ) + 36 | 0 ) ; $258 = HEAP32 [ $257 >> 2 ] | 0 ; $259 = ( $258 | 0 ) != ( 0 | 0 ) ; if ( $259 ) { label = 61 ; } else { $260 = $2 ; $261 = $14 ; $262 = ( _alloc_ulong_array ( $260 , $261 ) | 0 ) ; $263 = $2 ; $264 = ( ( ( $263 ) ) + 36 | 0 ) ; HEAP32 [ $264 >> 2 ] = $262 ; $265 = $2 ; $266 = $19 ; $267 = $3 ; _seek_to_offset ( $265 , $266 , $267 ) ; $268 = $17 ; $269 = $2 ; $270 = ( ( ( $269 ) ) + 36 | 0 ) ; $271 = HEAP32 [ $270 >> 2 ] | 0 ; $272 = $14 ; $273 = $3 ; $274 = ( _read_ulong_values ( $4 , $268 , $271 , $272 , $273 ) | 0 ) ; $275 = $14 ; $276 = ( $274 | 0 ) != ( $275 | 0 ) ; if ( $276 ) { label = 60 ; } else { STACKTOP = sp ; return ; } } } } } } } } } while ( 0 ) ; if ( ( label | 0 ) == 60 ) { $277 = $2 ; _minitiff_error ( $277 , 30301 ) ; label = 61 ; } if ( ( label | 0 ) == 61 ) { $278 = $2 ; _minitiff_error ( $278 , 30283 ) ; } $279 = $2 ; _minitiff_error ( $279 , 30253 ) ; STACKTOP = sp ; return ; } function _get_ushort_m ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $2 = $1 ; $3 = HEAP8 [ $2 >> 0 ] | 0 ; $4 = $3 & 255 ; $5 = $4 << 8 ; $6 = $1 ; $7 = ( ( ( $6 ) ) + 1 | 0 ) ; $8 = HEAP8 [ $7 >> 0 ] | 0 ; $9 = $8 & 255 ; $10 = ( ( $5 ) + ( $9 ) ) | 0 ; STACKTOP = sp ; return ( $10 | 0 ) ; } function _get_ulong_m ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 ; var $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $2 = $1 ; $3 = HEAP8 [ $2 >> 0 ] | 0 ; $4 = $3 & 255 ; $5 = $4 << 24 ; $6 = $1 ; $7 = ( ( ( $6 ) ) + 1 | 0 ) ; $8 = HEAP8 [ $7 >> 0 ] | 0 ; $9 = $8 & 255 ; $10 = $9 << 16 ; $11 = ( ( $5 ) + ( $10 ) ) | 0 ; $12 = $1 ; $13 = ( ( ( $12 ) ) + 2 | 0 ) ; $14 = HEAP8 [ $13 >> 0 ] | 0 ; $15 = $14 & 255 ; $16 = $15 << 8 ; $17 = ( ( $11 ) + ( $16 ) ) | 0 ; $18 = $1 ; $19 = ( ( ( $18 ) ) + 3 | 0 ) ; $20 = HEAP8 [ $19 >> 0 ] | 0 ; $21 = $20 & 255 ; $22 = ( ( $17 ) + ( $21 ) ) | 0 ; STACKTOP = sp ; return ( $22 | 0 ) ; } function _get_ushort_i ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $2 = $1 ; $3 = HEAP8 [ $2 >> 0 ] | 0 ; $4 = $3 & 255 ; $5 = $1 ; $6 = ( ( ( $5 ) ) + 1 | 0 ) ; $7 = HEAP8 [ $6 >> 0 ] | 0 ; $8 = $7 & 255 ; $9 = $8 << 8 ; $10 = ( ( $4 ) + ( $9 ) ) | 0 ; STACKTOP = sp ; return ( $10 | 0 ) ; } function _get_ulong_i ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 ; var $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $2 = $1 ; $3 = HEAP8 [ $2 >> 0 ] | 0 ; $4 = $3 & 255 ; $5 = $1 ; $6 = ( ( ( $5 ) ) + 1 | 0 ) ; $7 = HEAP8 [ $6 >> 0 ] | 0 ; $8 = $7 & 255 ; $9 = $8 << 8 ; $10 = ( ( $4 ) + ( $9 ) ) | 0 ; $11 = $1 ; $12 = ( ( ( $11 ) ) + 2 | 0 ) ; $13 = HEAP8 [ $12 >> 0 ] | 0 ; $14 = $13 & 255 ; $15 = $14 << 16 ; $16 = ( ( $10 ) + ( $15 ) ) | 0 ; $17 = $1 ; $18 = ( ( ( $17 ) ) + 3 | 0 ) ; $19 = HEAP8 [ $18 >> 0 ] | 0 ; $20 = $19 & 255 ; $21 = $20 << 24 ; $22 = ( ( $16 ) + ( $21 ) ) | 0 ; STACKTOP = sp ; return ( $22 | 0 ) ; } function _seek_to_offset ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $3 = $0 ; $4 = $1 ; $5 = $2 ; $6 = $4 ; $7 = ( $6 | 0 ) < ( 0 ) ; if ( $7 ) { $8 = $3 ; _minitiff_error ( $8 , 30446 ) ; } $9 = $5 ; $10 = ( _ftell ( $9 ) | 0 ) ; $11 = $4 ; $12 = ( $10 | 0 ) == ( $11 | 0 ) ; if ( $12 ) { STACKTOP = sp ; return ; } $13 = $5 ; $14 = $4 ; $15 = ( _fseek ( $13 , $14 , 0 ) | 0 ) ; $16 = ( $15 | 0 ) != ( 0 ) ; if ( ! ( $16 ) ) { STACKTOP = sp ; return ; } $17 = $3 ; _minitiff_error ( $17 , 30492 ) ; STACKTOP = sp ; return ; } function _cast_ulong_to_uint ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = $0 ; $3 = $1 ; $5 = $3 ; $4 = $5 ; $6 = $4 ; $7 = $3 ; $8 = ( $6 | 0 ) != ( $7 | 0 ) ; if ( $8 ) { $9 = $2 ; _minitiff_error ( $9 , 30446 ) ; } $10 = $4 ; STACKTOP = sp ; return ( $10 | 0 ) ; } function _get_ulong_value ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $7 = $5 ; switch ( $7 | 0 ) { case 1 : { $8 = $6 ; $9 = HEAP8 [ $8 >> 0 ] | 0 ; $10 = $9 & 255 ; $3 = $10 ; break ; } case 3 : { $11 = $4 ; $12 = HEAP32 [ $11 >> 2 ] | 0 ; $13 = $6 ; $14 = ( FUNCTION_TABLE_ii [ $12 & 127 ] ( $13 ) | 0 ) ; $3 = $14 ; break ; } case 4 : { $15 = $4 ; $16 = ( ( ( $15 ) ) + 4 | 0 ) ; $17 = HEAP32 [ $16 >> 2 ] | 0 ; $18 = $6 ; $19 = ( FUNCTION_TABLE_ii [ $17 & 127 ] ( $18 ) | 0 ) ; $3 = $19 ; break ; } default : { $3 = - 1 ; } } $20 = $3 ; STACKTOP = sp ; return ( $20 | 0 ) ; } function _alloc_ulong_array ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = $0 ; $3 = $1 ; $5 = $3 ; $6 = ( $5 >>> 0 ) > ( 1073741823 ) ; if ( $6 ) { $7 = $2 ; _minitiff_error ( $7 , 30446 ) ; } $8 = $3 ; $9 = $8 << 2 ; $10 = ( _malloc ( $9 ) | 0 ) ; $4 = $10 ; $11 = $4 ; $12 = ( $11 | 0 ) == ( 0 | 0 ) ; if ( ! ( $12 ) ) { $14 = $4 ; STACKTOP = sp ; return ( $14 | 0 ) ; } $13 = $2 ; _minitiff_error ( $13 , 30408 ) ; $14 = $4 ; STACKTOP = sp ; return ( $14 | 0 ) ; } function _read_ulong_values ( $0 , $1 , $2 , $3 , $4 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; $4 = $4 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $30 = 0 , $31 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 48 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 48 | 0 ) ; $11 = sp + 32 | 0 ; $6 = $0 ; $7 = $1 ; $8 = $2 ; $9 = $3 ; $10 = $4 ; $14 = $7 ; switch ( $14 | 0 ) { case 1 : { $12 = 1 ; break ; } case 3 : { $12 = 2 ; break ; } case 4 : { $12 = 4 ; break ; } default : { $5 = 0 ; $31 = $5 ; STACKTOP = sp ; return ( $31 | 0 ) ; } } $13 = 0 ; while ( 1 ) { $15 = $13 ; $16 = $9 ; $17 = ( $15 >>> 0 ) < ( $16 >>> 0 ) ; if ( ! ( $17 ) ) { break ; } $18 = $12 ; $19 = $10 ; $20 = ( _fread ( $11 , $18 , 1 , $19 ) | 0 ) ; $21 = ( $20 | 0 ) != ( 1 ) ; if ( $21 ) { break ; } $22 = $6 ; $23 = $7 ; $24 = ( _get_ulong_value ( $22 , $23 , $11 ) | 0 ) ; $25 = $8 ; $26 = $13 ; $27 = ( ( $25 ) + ( $26 << 2 ) | 0 ) ; HEAP32 [ $27 >> 2 ] = $24 ; $28 = $13 ; $29 = ( ( $28 ) + 1 ) | 0 ; $13 = $29 ; } $30 = $13 ; $5 = $30 ; $31 = $5 ; STACKTOP = sp ; return ( $31 | 0 ) ; } function _minitiff_read_row ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 ; var $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 ; var $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 ; var $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 ; var $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 48 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 48 | 0 ) ; $4 = $0 ; $5 = $1 ; $6 = $2 ; $7 = $3 ; $14 = $4 ; $15 = ( ( ( $14 ) ) + 20 | 0 ) ; $16 = HEAP32 [ $15 >> 2 ] | 0 ; $17 = ( ( $16 ) + 7 ) | 0 ; $18 = ( ( $17 >>> 0 ) / 8 ) & - 1 ; $10 = $18 ; $19 = $4 ; $20 = ( ( ( $19 ) ) + 12 | 0 ) ; $21 = HEAP32 [ $20 >> 2 ] | 0 ; $22 = $4 ; $23 = ( ( ( $22 ) ) + 44 | 0 ) ; $24 = HEAP32 [ $23 >> 2 ] | 0 ; $25 = Math_imul ( $21 , $24 ) | 0 ; $26 = $10 ; $27 = Math_imul ( $25 , $26 ) | 0 ; $8 = $27 ; $28 = $6 ; $29 = $4 ; $30 = ( ( ( $29 ) ) + 48 | 0 ) ; $31 = HEAP32 [ $30 >> 2 ] | 0 ; $32 = ( ( $28 >>> 0 ) / ( $31 >>> 0 ) ) & - 1 ; $9 = $32 ; $33 = $9 ; $34 = $4 ; $35 = ( ( ( $34 ) ) + 32 | 0 ) ; $36 = HEAP32 [ $35 >> 2 ] | 0 ; $37 = ( $33 >>> 0 ) >= ( $36 >>> 0 ) ; do { if ( $37 ) { label = 10 ; } else { $38 = $4 ; $39 = ( ( ( $38 ) ) + 36 | 0 ) ; $40 = HEAP32 [ $39 >> 2 ] | 0 ; $41 = $9 ; $42 = ( ( $40 ) + ( $41 << 2 ) | 0 ) ; $43 = HEAP32 [ $42 >> 2 ] | 0 ; $44 = ( $43 | 0 ) < ( 0 ) ; if ( $44 ) { label = 11 ; } else { $45 = $4 ; $46 = ( ( ( $45 ) ) + 36 | 0 ) ; $47 = HEAP32 [ $46 >> 2 ] | 0 ; $48 = $9 ; $49 = ( ( $47 ) + ( $48 << 2 ) | 0 ) ; $50 = HEAP32 [ $49 >> 2 ] | 0 ; $51 = $8 ; $52 = $6 ; $53 = $4 ; $54 = ( ( ( $53 ) ) + 48 | 0 ) ; $55 = HEAP32 [ $54 >> 2 ] | 0 ; $56 = ( ( $52 >>> 0 ) % ( $55 >>> 0 ) ) & - 1 ; $57 = Math_imul ( $51 , $56 ) | 0 ; $58 = ( ( $50 ) + ( $57 ) ) | 0 ; $12 = $58 ; $59 = $4 ; $60 = $12 ; $61 = $7 ; _seek_to_offset ( $59 , $60 , $61 ) ; $62 = $5 ; $63 = $8 ; $64 = $7 ; $65 = ( _fread ( $62 , $63 , 1 , $64 ) | 0 ) ; $66 = ( $65 | 0 ) != ( 1 ) ; $67 = $4 ; if ( $66 ) { _minitiff_error ( $67 , 30301 ) ; label = 10 ; break ; } $68 = ( ( ( $67 ) ) + 28 | 0 ) ; $69 = HEAP32 [ $68 >> 2 ] | 0 ; $70 = ( $69 | 0 ) == ( 0 ) ; if ( ! ( $70 ) ) { STACKTOP = sp ; return ; } $71 = $10 ; $72 = ( $71 >>> 0 ) > ( 1 ) ; if ( ! ( $72 ) ) { $73 = $4 ; $74 = ( ( ( $73 ) ) + 20 | 0 ) ; $75 = HEAP32 [ $74 >> 2 ] | 0 ; $76 = 1 << $75 ; $77 = ( ( $76 ) - 1 ) | 0 ; $11 = $77 ; $13 = 0 ; while ( 1 ) { $78 = $13 ; $79 = $8 ; $80 = ( $78 >>> 0 ) < ( $79 >>> 0 ) ; if ( ! ( $80 ) ) { break ; } $81 = $11 ; $82 = $5 ; $83 = $13 ; $84 = ( ( $82 ) + ( $83 ) | 0 ) ; $85 = HEAP8 [ $84 >> 0 ] | 0 ; $86 = $85 & 255 ; $87 = ( ( $81 ) - ( $86 ) ) | 0 ; $88 = $87 & 255 ; $89 = $5 ; $90 = $13 ; $91 = ( ( $89 ) + ( $90 ) | 0 ) ; HEAP8 [ $91 >> 0 ] = $88 ; $92 = $13 ; $93 = ( ( $92 ) + 1 ) | 0 ; $13 = $93 ; } STACKTOP = sp ; return ; } } } } while ( 0 ) ; if ( ( label | 0 ) == 10 ) { $94 = $4 ; _minitiff_error ( $94 , 30283 ) ; label = 11 ; } if ( ( label | 0 ) == 11 ) { $95 = $4 ; _minitiff_error ( $95 , 30446 ) ; } $96 = $4 ; _minitiff_error ( $96 , 30253 ) ; STACKTOP = sp ; return ; } function _minitiff_init_info ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , dest = 0 , label = 0 , sp = 0 , stop = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $2 = $1 ; dest = $2 ; stop = dest + 52 | 0 ; do { HEAP32 [ dest >> 2 ] = 0 | 0 ; dest = dest + 4 | 0 ; } while ( ( dest | 0 ) < ( stop | 0 ) ) ; $3 = $1 ; $4 = ( ( ( $3 ) ) + 28 | 0 ) ; HEAP32 [ $4 >> 2 ] = - 1 ; STACKTOP = sp ; return ; } function _minitiff_validate_info ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 ; var $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $2 = $1 ; $3 = ( ( ( $2 ) ) + 12 | 0 ) ; $4 = HEAP32 [ $3 >> 2 ] | 0 ; $5 = ( $4 | 0 ) == ( 0 ) ; if ( $5 ) { label = 3 ; } else { $6 = $1 ; $7 = ( ( ( $6 ) ) + 16 | 0 ) ; $8 = HEAP32 [ $7 >> 2 ] | 0 ; $9 = ( $8 | 0 ) == ( 0 ) ; if ( $9 ) { label = 3 ; } } if ( ( label | 0 ) == 3 ) { $10 = $1 ; _minitiff_error ( $10 , 30579 ) ; } $11 = $1 ; $12 = ( ( ( $11 ) ) + 20 | 0 ) ; $13 = HEAP32 [ $12 >> 2 ] | 0 ; $14 = ( $13 | 0 ) == ( 0 ) ; if ( $14 ) { label = 6 ; } else { $15 = $1 ; $16 = ( ( ( $15 ) ) + 44 | 0 ) ; $17 = HEAP32 [ $16 >> 2 ] | 0 ; $18 = ( $17 | 0 ) == ( 0 ) ; if ( $18 ) { label = 6 ; } } if ( ( label | 0 ) == 6 ) { $19 = $1 ; _minitiff_error ( $19 , 30617 ) ; } $20 = $1 ; $21 = ( ( ( $20 ) ) + 36 | 0 ) ; $22 = HEAP32 [ $21 >> 2 ] | 0 ; $23 = ( $22 | 0 ) == ( 0 | 0 ) ; if ( $23 ) { label = 9 ; } else { $24 = $1 ; $25 = ( ( ( $24 ) ) + 48 | 0 ) ; $26 = HEAP32 [ $25 >> 2 ] | 0 ; $27 = ( $26 | 0 ) == ( 0 ) ; if ( $27 ) { label = 9 ; } } if ( ( label | 0 ) == 9 ) { $28 = $1 ; _minitiff_error ( $28 , 30649 ) ; } $29 = $1 ; $30 = ( ( ( $29 ) ) + 24 | 0 ) ; $31 = HEAP32 [ $30 >> 2 ] | 0 ; $32 = ( $31 | 0 ) != ( 1 ) ; if ( $32 ) { $33 = $1 ; _minitiff_error ( $33 , 30681 ) ; } $34 = $1 ; $35 = ( ( ( $34 ) ) + 28 | 0 ) ; $36 = HEAP32 [ $35 >> 2 ] | 0 ; $37 = ( $36 >>> 0 ) >= ( 3 ) ; if ( ! ( $37 ) ) { STACKTOP = sp ; return ; } $38 = $1 ; _minitiff_error ( $38 , 30725 ) ; STACKTOP = sp ; return ; } function _minitiff_error ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = $0 ; $3 = $1 ; $4 = $2 ; $5 = HEAP32 [ $4 >> 2 ] | 0 ; $6 = ( $5 | 0 ) != ( 0 | 0 ) ; if ( $6 ) { $7 = $2 ; $8 = HEAP32 [ $7 >> 2 ] | 0 ; $9 = $3 ; FUNCTION_TABLE_vi [ $8 & 127 ] ( $9 ) ; _abort ( ) ; // unreachable; } else { $10 = $3 ; _default_error_handler ( $10 ) ; _abort ( ) ; // unreachable; } } function _default_error_handler ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , $vararg_buffer = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $vararg_buffer = sp ; $1 = $0 ; $2 = HEAP32 [ 2398 ] | 0 ; $3 = $1 ; HEAP32 [ $vararg_buffer >> 2 ] = $3 ; ( _fprintf ( $2 , 30777 , $vararg_buffer ) | 0 ) ; _exit ( 1 ) ; // unreachable; } function _minitiff_destroy_info ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = $0 ; $2 = $1 ; $3 = ( ( ( $2 ) ) + 36 | 0 ) ; $4 = HEAP32 [ $3 >> 2 ] | 0 ; $5 = ( $4 | 0 ) != ( 0 | 0 ) ; if ( ! ( $5 ) ) { STACKTOP = sp ; return ; } $6 = $1 ; $7 = ( ( ( $6 ) ) + 36 | 0 ) ; $8 = HEAP32 [ $7 >> 2 ] | 0 ; _free ( $8 ) ; STACKTOP = sp ; return ; } function _minitiff_warning ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = $0 ; $3 = $1 ; $4 = $2 ; $5 = ( ( ( $4 ) ) + 4 | 0 ) ; $6 = HEAP32 [ $5 >> 2 ] | 0 ; $7 = ( $6 | 0 ) != ( 0 | 0 ) ; if ( $7 ) { $8 = $2 ; $9 = ( ( ( $8 ) ) + 4 | 0 ) ; $10 = HEAP32 [ $9 >> 2 ] | 0 ; $11 = $3 ; FUNCTION_TABLE_vi [ $10 & 127 ] ( $11 ) ; STACKTOP = sp ; return ; } else { $12 = $3 ; _default_warning_handler ( $12 ) ; STACKTOP = sp ; return ; } } function _default_warning_handler ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , $vararg_buffer = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $vararg_buffer = sp ; $1 = $0 ; $2 = HEAP32 [ 2398 ] | 0 ; $3 = $1 ; HEAP32 [ $vararg_buffer >> 2 ] = $3 ; ( _fprintf ( $2 , 30798 , $vararg_buffer ) | 0 ) ; STACKTOP = sp ; return ; } function _malloc ( $0 ) { $0 = $0 | 0 ; var $$$0172$i = 0 , $$$0173$i = 0 , $$$4236$i = 0 , $$$4329$i = 0 , $$$i = 0 , $$0 = 0 , $$0$i = 0 , $$0$i$i = 0 , $$0$i$i$i = 0 , $$0$i20$i = 0 , $$0172$lcssa$i = 0 , $$01724$i = 0 , $$0173$lcssa$i = 0 , $$01733$i = 0 , $$0192 = 0 , $$0194 = 0 , $$0201$i$i = 0 , $$0202$i$i = 0 , $$0206$i$i = 0 , $$0207$i$i = 0 ; var $$024367$i = 0 , $$0260$i$i = 0 , $$0261$i$i = 0 , $$0262$i$i = 0 , $$0268$i$i = 0 , $$0269$i$i = 0 , $$0320$i = 0 , $$0322$i = 0 , $$0323$i = 0 , $$0325$i = 0 , $$0331$i = 0 , $$0336$i = 0 , $$0337$$i = 0 , $$0337$i = 0 , $$0339$i = 0 , $$0340$i = 0 , $$0345$i = 0 , $$1176$i = 0 , $$1178$i = 0 , $$124466$i = 0 ; var $$1264$i$i = 0 , $$1266$i$i = 0 , $$1321$i = 0 , $$1326$i = 0 , $$1341$i = 0 , $$1347$i = 0 , $$1351$i = 0 , $$2234243136$i = 0 , $$2247$ph$i = 0 , $$2253$ph$i = 0 , $$2333$i = 0 , $$3$i = 0 , $$3$i$i = 0 , $$3$i199 = 0 , $$3328$i = 0 , $$3349$i = 0 , $$4$lcssa$i = 0 , $$4$ph$i = 0 , $$4236$i = 0 , $$4329$lcssa$i = 0 ; var $$43298$i = 0 , $$4335$$4$i = 0 , $$4335$ph$i = 0 , $$43357$i = 0 , $$49$i = 0 , $$723947$i = 0 , $$748$i = 0 , $$pre = 0 , $$pre$i = 0 , $$pre$i$i = 0 , $$pre$i17$i = 0 , $$pre$i195 = 0 , $$pre$i207 = 0 , $$pre$phi$i$iZ2D = 0 , $$pre$phi$i18$iZ2D = 0 , $$pre$phi$i208Z2D = 0 , $$pre$phi$iZ2D = 0 , $$pre$phiZ2D = 0 , $$sink1$i = 0 , $$sink1$i$i = 0 ; var $$sink12$i = 0 , $$sink2$i = 0 , $$sink2$i202 = 0 , $$sink3$i = 0 , $1 = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 ; var $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 ; var $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 ; var $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 ; var $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 , $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 ; var $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 , $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $2 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 ; var $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 , $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 ; var $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 , $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 ; var $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 , $244 = 0 , $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 ; var $258 = 0 , $259 = 0 , $26 = 0 , $260 = 0 , $261 = 0 , $262 = 0 , $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 , $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 , $270 = 0 , $271 = 0 , $272 = 0 , $273 = 0 , $274 = 0 , $275 = 0 ; var $276 = 0 , $277 = 0 , $278 = 0 , $279 = 0 , $28 = 0 , $280 = 0 , $281 = 0 , $282 = 0 , $283 = 0 , $284 = 0 , $285 = 0 , $286 = 0 , $287 = 0 , $288 = 0 , $289 = 0 , $29 = 0 , $290 = 0 , $291 = 0 , $292 = 0 , $293 = 0 ; var $294 = 0 , $295 = 0 , $296 = 0 , $297 = 0 , $298 = 0 , $299 = 0 , $3 = 0 , $30 = 0 , $300 = 0 , $301 = 0 , $302 = 0 , $303 = 0 , $304 = 0 , $305 = 0 , $306 = 0 , $307 = 0 , $308 = 0 , $309 = 0 , $31 = 0 , $310 = 0 ; var $311 = 0 , $312 = 0 , $313 = 0 , $314 = 0 , $315 = 0 , $316 = 0 , $317 = 0 , $318 = 0 , $319 = 0 , $32 = 0 , $320 = 0 , $321 = 0 , $322 = 0 , $323 = 0 , $324 = 0 , $325 = 0 , $326 = 0 , $327 = 0 , $328 = 0 , $329 = 0 ; var $33 = 0 , $330 = 0 , $331 = 0 , $332 = 0 , $333 = 0 , $334 = 0 , $335 = 0 , $336 = 0 , $337 = 0 , $338 = 0 , $339 = 0 , $34 = 0 , $340 = 0 , $341 = 0 , $342 = 0 , $343 = 0 , $344 = 0 , $345 = 0 , $346 = 0 , $347 = 0 ; var $348 = 0 , $349 = 0 , $35 = 0 , $350 = 0 , $351 = 0 , $352 = 0 , $353 = 0 , $354 = 0 , $355 = 0 , $356 = 0 , $357 = 0 , $358 = 0 , $359 = 0 , $36 = 0 , $360 = 0 , $361 = 0 , $362 = 0 , $363 = 0 , $364 = 0 , $365 = 0 ; var $366 = 0 , $367 = 0 , $368 = 0 , $369 = 0 , $37 = 0 , $370 = 0 , $371 = 0 , $372 = 0 , $373 = 0 , $374 = 0 , $375 = 0 , $376 = 0 , $377 = 0 , $378 = 0 , $379 = 0 , $38 = 0 , $380 = 0 , $381 = 0 , $382 = 0 , $383 = 0 ; var $384 = 0 , $385 = 0 , $386 = 0 , $387 = 0 , $388 = 0 , $389 = 0 , $39 = 0 , $390 = 0 , $391 = 0 , $392 = 0 , $393 = 0 , $394 = 0 , $395 = 0 , $396 = 0 , $397 = 0 , $398 = 0 , $399 = 0 , $4 = 0 , $40 = 0 , $400 = 0 ; var $401 = 0 , $402 = 0 , $403 = 0 , $404 = 0 , $405 = 0 , $406 = 0 , $407 = 0 , $408 = 0 , $409 = 0 , $41 = 0 , $410 = 0 , $411 = 0 , $412 = 0 , $413 = 0 , $414 = 0 , $415 = 0 , $416 = 0 , $417 = 0 , $418 = 0 , $419 = 0 ; var $42 = 0 , $420 = 0 , $421 = 0 , $422 = 0 , $423 = 0 , $424 = 0 , $425 = 0 , $426 = 0 , $427 = 0 , $428 = 0 , $429 = 0 , $43 = 0 , $430 = 0 , $431 = 0 , $432 = 0 , $433 = 0 , $434 = 0 , $435 = 0 , $436 = 0 , $437 = 0 ; var $438 = 0 , $439 = 0 , $44 = 0 , $440 = 0 , $441 = 0 , $442 = 0 , $443 = 0 , $444 = 0 , $445 = 0 , $446 = 0 , $447 = 0 , $448 = 0 , $449 = 0 , $45 = 0 , $450 = 0 , $451 = 0 , $452 = 0 , $453 = 0 , $454 = 0 , $455 = 0 ; var $456 = 0 , $457 = 0 , $458 = 0 , $459 = 0 , $46 = 0 , $460 = 0 , $461 = 0 , $462 = 0 , $463 = 0 , $464 = 0 , $465 = 0 , $466 = 0 , $467 = 0 , $468 = 0 , $469 = 0 , $47 = 0 , $470 = 0 , $471 = 0 , $472 = 0 , $473 = 0 ; var $474 = 0 , $475 = 0 , $476 = 0 , $477 = 0 , $478 = 0 , $479 = 0 , $48 = 0 , $480 = 0 , $481 = 0 , $482 = 0 , $483 = 0 , $484 = 0 , $485 = 0 , $486 = 0 , $487 = 0 , $488 = 0 , $489 = 0 , $49 = 0 , $490 = 0 , $491 = 0 ; var $492 = 0 , $493 = 0 , $494 = 0 , $495 = 0 , $496 = 0 , $497 = 0 , $498 = 0 , $499 = 0 , $5 = 0 , $50 = 0 , $500 = 0 , $501 = 0 , $502 = 0 , $503 = 0 , $504 = 0 , $505 = 0 , $506 = 0 , $507 = 0 , $508 = 0 , $509 = 0 ; var $51 = 0 , $510 = 0 , $511 = 0 , $512 = 0 , $513 = 0 , $514 = 0 , $515 = 0 , $516 = 0 , $517 = 0 , $518 = 0 , $519 = 0 , $52 = 0 , $520 = 0 , $521 = 0 , $522 = 0 , $523 = 0 , $524 = 0 , $525 = 0 , $526 = 0 , $527 = 0 ; var $528 = 0 , $529 = 0 , $53 = 0 , $530 = 0 , $531 = 0 , $532 = 0 , $533 = 0 , $534 = 0 , $535 = 0 , $536 = 0 , $537 = 0 , $538 = 0 , $539 = 0 , $54 = 0 , $540 = 0 , $541 = 0 , $542 = 0 , $543 = 0 , $544 = 0 , $545 = 0 ; var $546 = 0 , $547 = 0 , $548 = 0 , $549 = 0 , $55 = 0 , $550 = 0 , $551 = 0 , $552 = 0 , $553 = 0 , $554 = 0 , $555 = 0 , $556 = 0 , $557 = 0 , $558 = 0 , $559 = 0 , $56 = 0 , $560 = 0 , $561 = 0 , $562 = 0 , $563 = 0 ; var $564 = 0 , $565 = 0 , $566 = 0 , $567 = 0 , $568 = 0 , $569 = 0 , $57 = 0 , $570 = 0 , $571 = 0 , $572 = 0 , $573 = 0 , $574 = 0 , $575 = 0 , $576 = 0 , $577 = 0 , $578 = 0 , $579 = 0 , $58 = 0 , $580 = 0 , $581 = 0 ; var $582 = 0 , $583 = 0 , $584 = 0 , $585 = 0 , $586 = 0 , $587 = 0 , $588 = 0 , $589 = 0 , $59 = 0 , $590 = 0 , $591 = 0 , $592 = 0 , $593 = 0 , $594 = 0 , $595 = 0 , $596 = 0 , $597 = 0 , $598 = 0 , $599 = 0 , $6 = 0 ; var $60 = 0 , $600 = 0 , $601 = 0 , $602 = 0 , $603 = 0 , $604 = 0 , $605 = 0 , $606 = 0 , $607 = 0 , $608 = 0 , $609 = 0 , $61 = 0 , $610 = 0 , $611 = 0 , $612 = 0 , $613 = 0 , $614 = 0 , $615 = 0 , $616 = 0 , $617 = 0 ; var $618 = 0 , $619 = 0 , $62 = 0 , $620 = 0 , $621 = 0 , $622 = 0 , $623 = 0 , $624 = 0 , $625 = 0 , $626 = 0 , $627 = 0 , $628 = 0 , $629 = 0 , $63 = 0 , $630 = 0 , $631 = 0 , $632 = 0 , $633 = 0 , $634 = 0 , $635 = 0 ; var $636 = 0 , $637 = 0 , $638 = 0 , $639 = 0 , $64 = 0 , $640 = 0 , $641 = 0 , $642 = 0 , $643 = 0 , $644 = 0 , $645 = 0 , $646 = 0 , $647 = 0 , $648 = 0 , $649 = 0 , $65 = 0 , $650 = 0 , $651 = 0 , $652 = 0 , $653 = 0 ; var $654 = 0 , $655 = 0 , $656 = 0 , $657 = 0 , $658 = 0 , $659 = 0 , $66 = 0 , $660 = 0 , $661 = 0 , $662 = 0 , $663 = 0 , $664 = 0 , $665 = 0 , $666 = 0 , $667 = 0 , $668 = 0 , $669 = 0 , $67 = 0 , $670 = 0 , $671 = 0 ; var $672 = 0 , $673 = 0 , $674 = 0 , $675 = 0 , $676 = 0 , $677 = 0 , $678 = 0 , $679 = 0 , $68 = 0 , $680 = 0 , $681 = 0 , $682 = 0 , $683 = 0 , $684 = 0 , $685 = 0 , $686 = 0 , $687 = 0 , $688 = 0 , $689 = 0 , $69 = 0 ; var $690 = 0 , $691 = 0 , $692 = 0 , $693 = 0 , $694 = 0 , $695 = 0 , $696 = 0 , $697 = 0 , $698 = 0 , $699 = 0 , $7 = 0 , $70 = 0 , $700 = 0 , $701 = 0 , $702 = 0 , $703 = 0 , $704 = 0 , $705 = 0 , $706 = 0 , $707 = 0 ; var $708 = 0 , $709 = 0 , $71 = 0 , $710 = 0 , $711 = 0 , $712 = 0 , $713 = 0 , $714 = 0 , $715 = 0 , $716 = 0 , $717 = 0 , $718 = 0 , $719 = 0 , $72 = 0 , $720 = 0 , $721 = 0 , $722 = 0 , $723 = 0 , $724 = 0 , $725 = 0 ; var $726 = 0 , $727 = 0 , $728 = 0 , $729 = 0 , $73 = 0 , $730 = 0 , $731 = 0 , $732 = 0 , $733 = 0 , $734 = 0 , $735 = 0 , $736 = 0 , $737 = 0 , $738 = 0 , $739 = 0 , $74 = 0 , $740 = 0 , $741 = 0 , $742 = 0 , $743 = 0 ; var $744 = 0 , $745 = 0 , $746 = 0 , $747 = 0 , $748 = 0 , $749 = 0 , $75 = 0 , $750 = 0 , $751 = 0 , $752 = 0 , $753 = 0 , $754 = 0 , $755 = 0 , $756 = 0 , $757 = 0 , $758 = 0 , $759 = 0 , $76 = 0 , $760 = 0 , $761 = 0 ; var $762 = 0 , $763 = 0 , $764 = 0 , $765 = 0 , $766 = 0 , $767 = 0 , $768 = 0 , $769 = 0 , $77 = 0 , $770 = 0 , $771 = 0 , $772 = 0 , $773 = 0 , $774 = 0 , $775 = 0 , $776 = 0 , $777 = 0 , $778 = 0 , $779 = 0 , $78 = 0 ; var $780 = 0 , $781 = 0 , $782 = 0 , $783 = 0 , $784 = 0 , $785 = 0 , $786 = 0 , $787 = 0 , $788 = 0 , $789 = 0 , $79 = 0 , $790 = 0 , $791 = 0 , $792 = 0 , $793 = 0 , $794 = 0 , $795 = 0 , $796 = 0 , $797 = 0 , $798 = 0 ; var $799 = 0 , $8 = 0 , $80 = 0 , $800 = 0 , $801 = 0 , $802 = 0 , $803 = 0 , $804 = 0 , $805 = 0 , $806 = 0 , $807 = 0 , $808 = 0 , $809 = 0 , $81 = 0 , $810 = 0 , $811 = 0 , $812 = 0 , $813 = 0 , $814 = 0 , $815 = 0 ; var $816 = 0 , $817 = 0 , $818 = 0 , $819 = 0 , $82 = 0 , $820 = 0 , $821 = 0 , $822 = 0 , $823 = 0 , $824 = 0 , $825 = 0 , $826 = 0 , $827 = 0 , $828 = 0 , $829 = 0 , $83 = 0 , $830 = 0 , $831 = 0 , $832 = 0 , $833 = 0 ; var $834 = 0 , $835 = 0 , $836 = 0 , $837 = 0 , $838 = 0 , $839 = 0 , $84 = 0 , $840 = 0 , $841 = 0 , $842 = 0 , $843 = 0 , $844 = 0 , $845 = 0 , $846 = 0 , $847 = 0 , $848 = 0 , $849 = 0 , $85 = 0 , $850 = 0 , $851 = 0 ; var $852 = 0 , $853 = 0 , $854 = 0 , $855 = 0 , $856 = 0 , $857 = 0 , $858 = 0 , $859 = 0 , $86 = 0 , $860 = 0 , $861 = 0 , $862 = 0 , $863 = 0 , $864 = 0 , $865 = 0 , $866 = 0 , $867 = 0 , $868 = 0 , $869 = 0 , $87 = 0 ; var $870 = 0 , $871 = 0 , $872 = 0 , $873 = 0 , $874 = 0 , $875 = 0 , $876 = 0 , $877 = 0 , $878 = 0 , $879 = 0 , $88 = 0 , $880 = 0 , $881 = 0 , $882 = 0 , $883 = 0 , $884 = 0 , $885 = 0 , $886 = 0 , $887 = 0 , $888 = 0 ; var $889 = 0 , $89 = 0 , $890 = 0 , $891 = 0 , $892 = 0 , $893 = 0 , $894 = 0 , $895 = 0 , $896 = 0 , $897 = 0 , $898 = 0 , $899 = 0 , $9 = 0 , $90 = 0 , $900 = 0 , $901 = 0 , $902 = 0 , $903 = 0 , $904 = 0 , $905 = 0 ; var $906 = 0 , $907 = 0 , $908 = 0 , $909 = 0 , $91 = 0 , $910 = 0 , $911 = 0 , $912 = 0 , $913 = 0 , $914 = 0 , $915 = 0 , $916 = 0 , $917 = 0 , $918 = 0 , $919 = 0 , $92 = 0 , $920 = 0 , $921 = 0 , $922 = 0 , $923 = 0 ; var $924 = 0 , $925 = 0 , $926 = 0 , $927 = 0 , $928 = 0 , $929 = 0 , $93 = 0 , $930 = 0 , $931 = 0 , $932 = 0 , $933 = 0 , $934 = 0 , $935 = 0 , $936 = 0 , $937 = 0 , $938 = 0 , $939 = 0 , $94 = 0 , $940 = 0 , $941 = 0 ; var $942 = 0 , $943 = 0 , $944 = 0 , $945 = 0 , $946 = 0 , $947 = 0 , $948 = 0 , $949 = 0 , $95 = 0 , $950 = 0 , $951 = 0 , $952 = 0 , $953 = 0 , $954 = 0 , $955 = 0 , $956 = 0 , $957 = 0 , $958 = 0 , $959 = 0 , $96 = 0 ; var $960 = 0 , $961 = 0 , $962 = 0 , $963 = 0 , $964 = 0 , $965 = 0 , $966 = 0 , $967 = 0 , $968 = 0 , $969 = 0 , $97 = 0 , $970 = 0 , $971 = 0 , $98 = 0 , $99 = 0 , $cond$i = 0 , $cond$i$i = 0 , $cond$i206 = 0 , $not$$i = 0 , $not$3$i = 0 ; var $or$cond$i = 0 , $or$cond$i200 = 0 , $or$cond1$i = 0 , $or$cond1$i198 = 0 , $or$cond10$i = 0 , $or$cond11$i = 0 , $or$cond11$not$i = 0 , $or$cond12$i = 0 , $or$cond2$i = 0 , $or$cond49$i = 0 , $or$cond5$i = 0 , $or$cond50$i = 0 , $or$cond7$i = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = sp ; $2 = ( $0 >>> 0 ) < ( 245 ) ; do { if ( $2 ) { $3 = ( $0 >>> 0 ) < ( 11 ) ; $4 = ( ( $0 ) + 11 ) | 0 ; $5 = $4 & - 8 ; $6 = $3 ? 16 : $5 ; $7 = $6 >>> 3 ; $8 = HEAP32 [ 16735 ] | 0 ; $9 = $8 >>> $7 ; $10 = $9 & 3 ; $11 = ( $10 | 0 ) == ( 0 ) ; if ( ! ( $11 ) ) { $12 = $9 & 1 ; $13 = $12 ^ 1 ; $14 = ( ( $13 ) + ( $7 ) ) | 0 ; $15 = $14 << 1 ; $16 = ( 66980 + ( $15 << 2 ) | 0 ) ; $17 = ( ( ( $16 ) ) + 8 | 0 ) ; $18 = HEAP32 [ $17 >> 2 ] | 0 ; $19 = ( ( ( $18 ) ) + 8 | 0 ) ; $20 = HEAP32 [ $19 >> 2 ] | 0 ; $21 = ( $20 | 0 ) == ( $16 | 0 ) ; if ( $21 ) { $22 = 1 << $14 ; $23 = $22 ^ - 1 ; $24 = $8 & $23 ; HEAP32 [ 16735 ] = $24 ; } else { $25 = ( ( ( $20 ) ) + 12 | 0 ) ; HEAP32 [ $25 >> 2 ] = $16 ; HEAP32 [ $17 >> 2 ] = $20 ; } $26 = $14 << 3 ; $27 = $26 | 3 ; $28 = ( ( ( $18 ) ) + 4 | 0 ) ; HEAP32 [ $28 >> 2 ] = $27 ; $29 = ( ( $18 ) + ( $26 ) | 0 ) ; $30 = ( ( ( $29 ) ) + 4 | 0 ) ; $31 = HEAP32 [ $30 >> 2 ] | 0 ; $32 = $31 | 1 ; HEAP32 [ $30 >> 2 ] = $32 ; $$0 = $19 ; STACKTOP = sp ; return ( $$0 | 0 ) ; } $33 = HEAP32 [ ( 66948 ) >> 2 ] | 0 ; $34 = ( $6 >>> 0 ) > ( $33 >>> 0 ) ; if ( $34 ) { $35 = ( $9 | 0 ) == ( 0 ) ; if ( ! ( $35 ) ) { $36 = $9 << $7 ; $37 = 2 << $7 ; $38 = ( 0 - ( $37 ) ) | 0 ; $39 = $37 | $38 ; $40 = $36 & $39 ; $41 = ( 0 - ( $40 ) ) | 0 ; $42 = $40 & $41 ; $43 = ( ( $42 ) + - 1 ) | 0 ; $44 = $43 >>> 12 ; $45 = $44 & 16 ; $46 = $43 >>> $45 ; $47 = $46 >>> 5 ; $48 = $47 & 8 ; $49 = $48 | $45 ; $50 = $46 >>> $48 ; $51 = $50 >>> 2 ; $52 = $51 & 4 ; $53 = $49 | $52 ; $54 = $50 >>> $52 ; $55 = $54 >>> 1 ; $56 = $55 & 2 ; $57 = $53 | $56 ; $58 = $54 >>> $56 ; $59 = $58 >>> 1 ; $60 = $59 & 1 ; $61 = $57 | $60 ; $62 = $58 >>> $60 ; $63 = ( ( $61 ) + ( $62 ) ) | 0 ; $64 = $63 << 1 ; $65 = ( 66980 + ( $64 << 2 ) | 0 ) ; $66 = ( ( ( $65 ) ) + 8 | 0 ) ; $67 = HEAP32 [ $66 >> 2 ] | 0 ; $68 = ( ( ( $67 ) ) + 8 | 0 ) ; $69 = HEAP32 [ $68 >> 2 ] | 0 ; $70 = ( $69 | 0 ) == ( $65 | 0 ) ; if ( $70 ) { $71 = 1 << $63 ; $72 = $71 ^ - 1 ; $73 = $8 & $72 ; HEAP32 [ 16735 ] = $73 ; $90 = $73 ; } else { $74 = ( ( ( $69 ) ) + 12 | 0 ) ; HEAP32 [ $74 >> 2 ] = $65 ; HEAP32 [ $66 >> 2 ] = $69 ; $90 = $8 ; } $75 = $63 << 3 ; $76 = ( ( $75 ) - ( $6 ) ) | 0 ; $77 = $6 | 3 ; $78 = ( ( ( $67 ) ) + 4 | 0 ) ; HEAP32 [ $78 >> 2 ] = $77 ; $79 = ( ( $67 ) + ( $6 ) | 0 ) ; $80 = $76 | 1 ; $81 = ( ( ( $79 ) ) + 4 | 0 ) ; HEAP32 [ $81 >> 2 ] = $80 ; $82 = ( ( $67 ) + ( $75 ) | 0 ) ; HEAP32 [ $82 >> 2 ] = $76 ; $83 = ( $33 | 0 ) == ( 0 ) ; if ( ! ( $83 ) ) { $84 = HEAP32 [ ( 66960 ) >> 2 ] | 0 ; $85 = $33 >>> 3 ; $86 = $85 << 1 ; $87 = ( 66980 + ( $86 << 2 ) | 0 ) ; $88 = 1 << $85 ; $89 = $90 & $88 ; $91 = ( $89 | 0 ) == ( 0 ) ; if ( $91 ) { $92 = $90 | $88 ; HEAP32 [ 16735 ] = $92 ; $$pre = ( ( ( $87 ) ) + 8 | 0 ) ; $$0194 = $87 ; $$pre$phiZ2D = $$pre ; } else { $93 = ( ( ( $87 ) ) + 8 | 0 ) ; $94 = HEAP32 [ $93 >> 2 ] | 0 ; $$0194 = $94 ; $$pre$phiZ2D = $93 ; } HEAP32 [ $$pre$phiZ2D >> 2 ] = $84 ; $95 = ( ( ( $$0194 ) ) + 12 | 0 ) ; HEAP32 [ $95 >> 2 ] = $84 ; $96 = ( ( ( $84 ) ) + 8 | 0 ) ; HEAP32 [ $96 >> 2 ] = $$0194 ; $97 = ( ( ( $84 ) ) + 12 | 0 ) ; HEAP32 [ $97 >> 2 ] = $87 ; } HEAP32 [ ( 66948 ) >> 2 ] = $76 ; HEAP32 [ ( 66960 ) >> 2 ] = $79 ; $$0 = $68 ; STACKTOP = sp ; return ( $$0 | 0 ) ; } $98 = HEAP32 [ ( 66944 ) >> 2 ] | 0 ; $99 = ( $98 | 0 ) == ( 0 ) ; if ( $99 ) { $$0192 = $6 ; } else { $100 = ( 0 - ( $98 ) ) | 0 ; $101 = $98 & $100 ; $102 = ( ( $101 ) + - 1 ) | 0 ; $103 = $102 >>> 12 ; $104 = $103 & 16 ; $105 = $102 >>> $104 ; $106 = $105 >>> 5 ; $107 = $106 & 8 ; $108 = $107 | $104 ; $109 = $105 >>> $107 ; $110 = $109 >>> 2 ; $111 = $110 & 4 ; $112 = $108 | $111 ; $113 = $109 >>> $111 ; $114 = $113 >>> 1 ; $115 = $114 & 2 ; $116 = $112 | $115 ; $117 = $113 >>> $115 ; $118 = $117 >>> 1 ; $119 = $118 & 1 ; $120 = $116 | $119 ; $121 = $117 >>> $119 ; $122 = ( ( $120 ) + ( $121 ) ) | 0 ; $123 = ( 67244 + ( $122 << 2 ) | 0 ) ; $124 = HEAP32 [ $123 >> 2 ] | 0 ; $125 = ( ( ( $124 ) ) + 4 | 0 ) ; $126 = HEAP32 [ $125 >> 2 ] | 0 ; $127 = $126 & - 8 ; $128 = ( ( $127 ) - ( $6 ) ) | 0 ; $129 = ( ( ( $124 ) ) + 16 | 0 ) ; $130 = HEAP32 [ $129 >> 2 ] | 0 ; $131 = ( $130 | 0 ) == ( 0 | 0 ) ; $$sink12$i = $131 & 1 ; $132 = ( ( ( ( $124 ) ) + 16 | 0 ) + ( $$sink12$i << 2 ) | 0 ) ; $133 = HEAP32 [ $132 >> 2 ] | 0 ; $134 = ( $133 | 0 ) == ( 0 | 0 ) ; if ( $134 ) { $$0172$lcssa$i = $124 ; $$0173$lcssa$i = $128 ; } else { $$01724$i = $124 ; $$01733$i = $128 ; $136 = $133 ; while ( 1 ) { $135 = ( ( ( $136 ) ) + 4 | 0 ) ; $137 = HEAP32 [ $135 >> 2 ] | 0 ; $138 = $137 & - 8 ; $139 = ( ( $138 ) - ( $6 ) ) | 0 ; $140 = ( $139 >>> 0 ) < ( $$01733$i >>> 0 ) ; $$$0173$i = $140 ? $139 : $$01733$i ; $$$0172$i = $140 ? $136 : $$01724$i ; $141 = ( ( ( $136 ) ) + 16 | 0 ) ; $142 = HEAP32 [ $141 >> 2 ] | 0 ; $143 = ( $142 | 0 ) == ( 0 | 0 ) ; $$sink1$i = $143 & 1 ; $144 = ( ( ( ( $136 ) ) + 16 | 0 ) + ( $$sink1$i << 2 ) | 0 ) ; $145 = HEAP32 [ $144 >> 2 ] | 0 ; $146 = ( $145 | 0 ) == ( 0 | 0 ) ; if ( $146 ) { $$0172$lcssa$i = $$$0172$i ; $$0173$lcssa$i = $$$0173$i ; break ; } else { $$01724$i = $$$0172$i ; $$01733$i = $$$0173$i ; $136 = $145 ; } } } $147 = ( ( $$0172$lcssa$i ) + ( $6 ) | 0 ) ; $148 = ( $147 >>> 0 ) > ( $$0172$lcssa$i >>> 0 ) ; if ( $148 ) { $149 = ( ( ( $$0172$lcssa$i ) ) + 24 | 0 ) ; $150 = HEAP32 [ $149 >> 2 ] | 0 ; $151 = ( ( ( $$0172$lcssa$i ) ) + 12 | 0 ) ; $152 = HEAP32 [ $151 >> 2 ] | 0 ; $153 = ( $152 | 0 ) == ( $$0172$lcssa$i | 0 ) ; do { if ( $153 ) { $158 = ( ( ( $$0172$lcssa$i ) ) + 20 | 0 ) ; $159 = HEAP32 [ $158 >> 2 ] | 0 ; $160 = ( $159 | 0 ) == ( 0 | 0 ) ; if ( $160 ) { $161 = ( ( ( $$0172$lcssa$i ) ) + 16 | 0 ) ; $162 = HEAP32 [ $161 >> 2 ] | 0 ; $163 = ( $162 | 0 ) == ( 0 | 0 ) ; if ( $163 ) { $$3$i = 0 ; break ; } else { $$1176$i = $162 ; $$1178$i = $161 ; } } else { $$1176$i = $159 ; $$1178$i = $158 ; } while ( 1 ) { $164 = ( ( ( $$1176$i ) ) + 20 | 0 ) ; $165 = HEAP32 [ $164 >> 2 ] | 0 ; $166 = ( $165 | 0 ) == ( 0 | 0 ) ; if ( ! ( $166 ) ) { $$1176$i = $165 ; $$1178$i = $164 ; continue ; } $167 = ( ( ( $$1176$i ) ) + 16 | 0 ) ; $168 = HEAP32 [ $167 >> 2 ] | 0 ; $169 = ( $168 | 0 ) == ( 0 | 0 ) ; if ( $169 ) { break ; } else { $$1176$i = $168 ; $$1178$i = $167 ; } } HEAP32 [ $$1178$i >> 2 ] = 0 ; $$3$i = $$1176$i ; } else { $154 = ( ( ( $$0172$lcssa$i ) ) + 8 | 0 ) ; $155 = HEAP32 [ $154 >> 2 ] | 0 ; $156 = ( ( ( $155 ) ) + 12 | 0 ) ; HEAP32 [ $156 >> 2 ] = $152 ; $157 = ( ( ( $152 ) ) + 8 | 0 ) ; HEAP32 [ $157 >> 2 ] = $155 ; $$3$i = $152 ; } } while ( 0 ) ; $170 = ( $150 | 0 ) == ( 0 | 0 ) ; do { if ( ! ( $170 ) ) { $171 = ( ( ( $$0172$lcssa$i ) ) + 28 | 0 ) ; $172 = HEAP32 [ $171 >> 2 ] | 0 ; $173 = ( 67244 + ( $172 << 2 ) | 0 ) ; $174 = HEAP32 [ $173 >> 2 ] | 0 ; $175 = ( $$0172$lcssa$i | 0 ) == ( $174 | 0 ) ; if ( $175 ) { HEAP32 [ $173 >> 2 ] = $$3$i ; $cond$i = ( $$3$i | 0 ) == ( 0 | 0 ) ; if ( $cond$i ) { $176 = 1 << $172 ; $177 = $176 ^ - 1 ; $178 = $98 & $177 ; HEAP32 [ ( 66944 ) >> 2 ] = $178 ; break ; } } else { $179 = ( ( ( $150 ) ) + 16 | 0 ) ; $180 = HEAP32 [ $179 >> 2 ] | 0 ; $181 = ( $180 | 0 ) != ( $$0172$lcssa$i | 0 ) ; $$sink2$i = $181 & 1 ; $182 = ( ( ( ( $150 ) ) + 16 | 0 ) + ( $$sink2$i << 2 ) | 0 ) ; HEAP32 [ $182 >> 2 ] = $$3$i ; $183 = ( $$3$i | 0 ) == ( 0 | 0 ) ; if ( $183 ) { break ; } } $184 = ( ( ( $$3$i ) ) + 24 | 0 ) ; HEAP32 [ $184 >> 2 ] = $150 ; $185 = ( ( ( $$0172$lcssa$i ) ) + 16 | 0 ) ; $186 = HEAP32 [ $185 >> 2 ] | 0 ; $187 = ( $186 | 0 ) == ( 0 | 0 ) ; if ( ! ( $187 ) ) { $188 = ( ( ( $$3$i ) ) + 16 | 0 ) ; HEAP32 [ $188 >> 2 ] = $186 ; $189 = ( ( ( $186 ) ) + 24 | 0 ) ; HEAP32 [ $189 >> 2 ] = $$3$i ; } $190 = ( ( ( $$0172$lcssa$i ) ) + 20 | 0 ) ; $191 = HEAP32 [ $190 >> 2 ] | 0 ; $192 = ( $191 | 0 ) == ( 0 | 0 ) ; if ( ! ( $192 ) ) { $193 = ( ( ( $$3$i ) ) + 20 | 0 ) ; HEAP32 [ $193 >> 2 ] = $191 ; $194 = ( ( ( $191 ) ) + 24 | 0 ) ; HEAP32 [ $194 >> 2 ] = $$3$i ; } } } while ( 0 ) ; $195 = ( $$0173$lcssa$i >>> 0 ) < ( 16 ) ; if ( $195 ) { $196 = ( ( $$0173$lcssa$i ) + ( $6 ) ) | 0 ; $197 = $196 | 3 ; $198 = ( ( ( $$0172$lcssa$i ) ) + 4 | 0 ) ; HEAP32 [ $198 >> 2 ] = $197 ; $199 = ( ( $$0172$lcssa$i ) + ( $196 ) | 0 ) ; $200 = ( ( ( $199 ) ) + 4 | 0 ) ; $201 = HEAP32 [ $200 >> 2 ] | 0 ; $202 = $201 | 1 ; HEAP32 [ $200 >> 2 ] = $202 ; } else { $203 = $6 | 3 ; $204 = ( ( ( $$0172$lcssa$i ) ) + 4 | 0 ) ; HEAP32 [ $204 >> 2 ] = $203 ; $205 = $$0173$lcssa$i | 1 ; $206 = ( ( ( $147 ) ) + 4 | 0 ) ; HEAP32 [ $206 >> 2 ] = $205 ; $207 = ( ( $147 ) + ( $$0173$lcssa$i ) | 0 ) ; HEAP32 [ $207 >> 2 ] = $$0173$lcssa$i ; $208 = ( $33 | 0 ) == ( 0 ) ; if ( ! ( $208 ) ) { $209 = HEAP32 [ ( 66960 ) >> 2 ] | 0 ; $210 = $33 >>> 3 ; $211 = $210 << 1 ; $212 = ( 66980 + ( $211 << 2 ) | 0 ) ; $213 = 1 << $210 ; $214 = $8 & $213 ; $215 = ( $214 | 0 ) == ( 0 ) ; if ( $215 ) { $216 = $8 | $213 ; HEAP32 [ 16735 ] = $216 ; $$pre$i = ( ( ( $212 ) ) + 8 | 0 ) ; $$0$i = $212 ; $$pre$phi$iZ2D = $$pre$i ; } else { $217 = ( ( ( $212 ) ) + 8 | 0 ) ; $218 = HEAP32 [ $217 >> 2 ] | 0 ; $$0$i = $218 ; $$pre$phi$iZ2D = $217 ; } HEAP32 [ $$pre$phi$iZ2D >> 2 ] = $209 ; $219 = ( ( ( $$0$i ) ) + 12 | 0 ) ; HEAP32 [ $219 >> 2 ] = $209 ; $220 = ( ( ( $209 ) ) + 8 | 0 ) ; HEAP32 [ $220 >> 2 ] = $$0$i ; $221 = ( ( ( $209 ) ) + 12 | 0 ) ; HEAP32 [ $221 >> 2 ] = $212 ; } HEAP32 [ ( 66948 ) >> 2 ] = $$0173$lcssa$i ; HEAP32 [ ( 66960 ) >> 2 ] = $147 ; } $222 = ( ( ( $$0172$lcssa$i ) ) + 8 | 0 ) ; $$0 = $222 ; STACKTOP = sp ; return ( $$0 | 0 ) ; } else { $$0192 = $6 ; } } } else { $$0192 = $6 ; } } else { $223 = ( $0 >>> 0 ) > ( 4294967231 ) ; if ( $223 ) { $$0192 = - 1 ; } else { $224 = ( ( $0 ) + 11 ) | 0 ; $225 = $224 & - 8 ; $226 = HEAP32 [ ( 66944 ) >> 2 ] | 0 ; $227 = ( $226 | 0 ) == ( 0 ) ; if ( $227 ) { $$0192 = $225 ; } else { $228 = ( 0 - ( $225 ) ) | 0 ; $229 = $224 >>> 8 ; $230 = ( $229 | 0 ) == ( 0 ) ; if ( $230 ) { $$0336$i = 0 ; } else { $231 = ( $225 >>> 0 ) > ( 16777215 ) ; if ( $231 ) { $$0336$i = 31 ; } else { $232 = ( ( $229 ) + 1048320 ) | 0 ; $233 = $232 >>> 16 ; $234 = $233 & 8 ; $235 = $229 << $234 ; $236 = ( ( $235 ) + 520192 ) | 0 ; $237 = $236 >>> 16 ; $238 = $237 & 4 ; $239 = $238 | $234 ; $240 = $235 << $238 ; $241 = ( ( $240 ) + 245760 ) | 0 ; $242 = $241 >>> 16 ; $243 = $242 & 2 ; $244 = $239 | $243 ; $245 = ( 14 - ( $244 ) ) | 0 ; $246 = $240 << $243 ; $247 = $246 >>> 15 ; $248 = ( ( $245 ) + ( $247 ) ) | 0 ; $249 = $248 << 1 ; $250 = ( ( $248 ) + 7 ) | 0 ; $251 = $225 >>> $250 ; $252 = $251 & 1 ; $253 = $252 | $249 ; $$0336$i = $253 ; } } $254 = ( 67244 + ( $$0336$i << 2 ) | 0 ) ; $255 = HEAP32 [ $254 >> 2 ] | 0 ; $256 = ( $255 | 0 ) == ( 0 | 0 ) ; L74 : do { if ( $256 ) { $$2333$i = 0 ; $$3$i199 = 0 ; $$3328$i = $228 ; label = 57 ; } else { $257 = ( $$0336$i | 0 ) == ( 31 ) ; $258 = $$0336$i >>> 1 ; $259 = ( 25 - ( $258 ) ) | 0 ; $260 = $257 ? 0 : $259 ; $261 = $225 << $260 ; $$0320$i = 0 ; $$0325$i = $228 ; $$0331$i = $255 ; $$0337$i = $261 ; $$0340$i = 0 ; while ( 1 ) { $262 = ( ( ( $$0331$i ) ) + 4 | 0 ) ; $263 = HEAP32 [ $262 >> 2 ] | 0 ; $264 = $263 & - 8 ; $265 = ( ( $264 ) - ( $225 ) ) | 0 ; $266 = ( $265 >>> 0 ) < ( $$0325$i >>> 0 ) ; if ( $266 ) { $267 = ( $265 | 0 ) == ( 0 ) ; if ( $267 ) { $$43298$i = 0 ; $$43357$i = $$0331$i ; $$49$i = $$0331$i ; label = 61 ; break L74 ; } else { $$1321$i = $$0331$i ; $$1326$i = $265 ; } } else { $$1321$i = $$0320$i ; $$1326$i = $$0325$i ; } $268 = ( ( ( $$0331$i ) ) + 20 | 0 ) ; $269 = HEAP32 [ $268 >> 2 ] | 0 ; $270 = $$0337$i >>> 31 ; $271 = ( ( ( ( $$0331$i ) ) + 16 | 0 ) + ( $270 << 2 ) | 0 ) ; $272 = HEAP32 [ $271 >> 2 ] | 0 ; $273 = ( $269 | 0 ) == ( 0 | 0 ) ; $274 = ( $269 | 0 ) == ( $272 | 0 ) ; $or$cond1$i198 = $273 | $274 ; $$1341$i = $or$cond1$i198 ? $$0340$i : $269 ; $275 = ( $272 | 0 ) == ( 0 | 0 ) ; $not$3$i = $275 ^ 1 ; $276 = $not$3$i & 1 ; $$0337$$i = $$0337$i << $276 ; if ( $275 ) { $$2333$i = $$1341$i ; $$3$i199 = $$1321$i ; $$3328$i = $$1326$i ; label = 57 ; break ; } else { $$0320$i = $$1321$i ; $$0325$i = $$1326$i ; $$0331$i = $272 ; $$0337$i = $$0337$$i ; $$0340$i = $$1341$i ; } } } } while ( 0 ) ; if ( ( label | 0 ) == 57 ) { $277 = ( $$2333$i | 0 ) == ( 0 | 0 ) ; $278 = ( $$3$i199 | 0 ) == ( 0 | 0 ) ; $or$cond$i200 = $277 & $278 ; if ( $or$cond$i200 ) { $279 = 2 << $$0336$i ; $280 = ( 0 - ( $279 ) ) | 0 ; $281 = $279 | $280 ; $282 = $226 & $281 ; $283 = ( $282 | 0 ) == ( 0 ) ; if ( $283 ) { $$0192 = $225 ; break ; } $284 = ( 0 - ( $282 ) ) | 0 ; $285 = $282 & $284 ; $286 = ( ( $285 ) + - 1 ) | 0 ; $287 = $286 >>> 12 ; $288 = $287 & 16 ; $289 = $286 >>> $288 ; $290 = $289 >>> 5 ; $291 = $290 & 8 ; $292 = $291 | $288 ; $293 = $289 >>> $291 ; $294 = $293 >>> 2 ; $295 = $294 & 4 ; $296 = $292 | $295 ; $297 = $293 >>> $295 ; $298 = $297 >>> 1 ; $299 = $298 & 2 ; $300 = $296 | $299 ; $301 = $297 >>> $299 ; $302 = $301 >>> 1 ; $303 = $302 & 1 ; $304 = $300 | $303 ; $305 = $301 >>> $303 ; $306 = ( ( $304 ) + ( $305 ) ) | 0 ; $307 = ( 67244 + ( $306 << 2 ) | 0 ) ; $308 = HEAP32 [ $307 >> 2 ] | 0 ; $$4$ph$i = 0 ; $$4335$ph$i = $308 ; } else { $$4$ph$i = $$3$i199 ; $$4335$ph$i = $$2333$i ; } $309 = ( $$4335$ph$i | 0 ) == ( 0 | 0 ) ; if ( $309 ) { $$4$lcssa$i = $$4$ph$i ; $$4329$lcssa$i = $$3328$i ; } else { $$43298$i = $$3328$i ; $$43357$i = $$4335$ph$i ; $$49$i = $$4$ph$i ; label = 61 ; } } if ( ( label | 0 ) == 61 ) { while ( 1 ) { label = 0 ; $310 = ( ( ( $$43357$i ) ) + 4 | 0 ) ; $311 = HEAP32 [ $310 >> 2 ] | 0 ; $312 = $311 & - 8 ; $313 = ( ( $312 ) - ( $225 ) ) | 0 ; $314 = ( $313 >>> 0 ) < ( $$43298$i >>> 0 ) ; $$$4329$i = $314 ? $313 : $$43298$i ; $$4335$$4$i = $314 ? $$43357$i : $$49$i ; $315 = ( ( ( $$43357$i ) ) + 16 | 0 ) ; $316 = HEAP32 [ $315 >> 2 ] | 0 ; $317 = ( $316 | 0 ) == ( 0 | 0 ) ; $$sink2$i202 = $317 & 1 ; $318 = ( ( ( ( $$43357$i ) ) + 16 | 0 ) + ( $$sink2$i202 << 2 ) | 0 ) ; $319 = HEAP32 [ $318 >> 2 ] | 0 ; $320 = ( $319 | 0 ) == ( 0 | 0 ) ; if ( $320 ) { $$4$lcssa$i = $$4335$$4$i ; $$4329$lcssa$i = $$$4329$i ; break ; } else { $$43298$i = $$$4329$i ; $$43357$i = $319 ; $$49$i = $$4335$$4$i ; label = 61 ; } } } $321 = ( $$4$lcssa$i | 0 ) == ( 0 | 0 ) ; if ( $321 ) { $$0192 = $225 ; } else { $322 = HEAP32 [ ( 66948 ) >> 2 ] | 0 ; $323 = ( ( $322 ) - ( $225 ) ) | 0 ; $324 = ( $$4329$lcssa$i >>> 0 ) < ( $323 >>> 0 ) ; if ( $324 ) { $325 = ( ( $$4$lcssa$i ) + ( $225 ) | 0 ) ; $326 = ( $325 >>> 0 ) > ( $$4$lcssa$i >>> 0 ) ; if ( ! ( $326 ) ) { $$0 = 0 ; STACKTOP = sp ; return ( $$0 | 0 ) ; } $327 = ( ( ( $$4$lcssa$i ) ) + 24 | 0 ) ; $328 = HEAP32 [ $327 >> 2 ] | 0 ; $329 = ( ( ( $$4$lcssa$i ) ) + 12 | 0 ) ; $330 = HEAP32 [ $329 >> 2 ] | 0 ; $331 = ( $330 | 0 ) == ( $$4$lcssa$i | 0 ) ; do { if ( $331 ) { $336 = ( ( ( $$4$lcssa$i ) ) + 20 | 0 ) ; $337 = HEAP32 [ $336 >> 2 ] | 0 ; $338 = ( $337 | 0 ) == ( 0 | 0 ) ; if ( $338 ) { $339 = ( ( ( $$4$lcssa$i ) ) + 16 | 0 ) ; $340 = HEAP32 [ $339 >> 2 ] | 0 ; $341 = ( $340 | 0 ) == ( 0 | 0 ) ; if ( $341 ) { $$3349$i = 0 ; break ; } else { $$1347$i = $340 ; $$1351$i = $339 ; } } else { $$1347$i = $337 ; $$1351$i = $336 ; } while ( 1 ) { $342 = ( ( ( $$1347$i ) ) + 20 | 0 ) ; $343 = HEAP32 [ $342 >> 2 ] | 0 ; $344 = ( $343 | 0 ) == ( 0 | 0 ) ; if ( ! ( $344 ) ) { $$1347$i = $343 ; $$1351$i = $342 ; continue ; } $345 = ( ( ( $$1347$i ) ) + 16 | 0 ) ; $346 = HEAP32 [ $345 >> 2 ] | 0 ; $347 = ( $346 | 0 ) == ( 0 | 0 ) ; if ( $347 ) { break ; } else { $$1347$i = $346 ; $$1351$i = $345 ; } } HEAP32 [ $$1351$i >> 2 ] = 0 ; $$3349$i = $$1347$i ; } else { $332 = ( ( ( $$4$lcssa$i ) ) + 8 | 0 ) ; $333 = HEAP32 [ $332 >> 2 ] | 0 ; $334 = ( ( ( $333 ) ) + 12 | 0 ) ; HEAP32 [ $334 >> 2 ] = $330 ; $335 = ( ( ( $330 ) ) + 8 | 0 ) ; HEAP32 [ $335 >> 2 ] = $333 ; $$3349$i = $330 ; } } while ( 0 ) ; $348 = ( $328 | 0 ) == ( 0 | 0 ) ; do { if ( $348 ) { $431 = $226 ; } else { $349 = ( ( ( $$4$lcssa$i ) ) + 28 | 0 ) ; $350 = HEAP32 [ $349 >> 2 ] | 0 ; $351 = ( 67244 + ( $350 << 2 ) | 0 ) ; $352 = HEAP32 [ $351 >> 2 ] | 0 ; $353 = ( $$4$lcssa$i | 0 ) == ( $352 | 0 ) ; if ( $353 ) { HEAP32 [ $351 >> 2 ] = $$3349$i ; $cond$i206 = ( $$3349$i | 0 ) == ( 0 | 0 ) ; if ( $cond$i206 ) { $354 = 1 << $350 ; $355 = $354 ^ - 1 ; $356 = $226 & $355 ; HEAP32 [ ( 66944 ) >> 2 ] = $356 ; $431 = $356 ; break ; } } else { $357 = ( ( ( $328 ) ) + 16 | 0 ) ; $358 = HEAP32 [ $357 >> 2 ] | 0 ; $359 = ( $358 | 0 ) != ( $$4$lcssa$i | 0 ) ; $$sink3$i = $359 & 1 ; $360 = ( ( ( ( $328 ) ) + 16 | 0 ) + ( $$sink3$i << 2 ) | 0 ) ; HEAP32 [ $360 >> 2 ] = $$3349$i ; $361 = ( $$3349$i | 0 ) == ( 0 | 0 ) ; if ( $361 ) { $431 = $226 ; break ; } } $362 = ( ( ( $$3349$i ) ) + 24 | 0 ) ; HEAP32 [ $362 >> 2 ] = $328 ; $363 = ( ( ( $$4$lcssa$i ) ) + 16 | 0 ) ; $364 = HEAP32 [ $363 >> 2 ] | 0 ; $365 = ( $364 | 0 ) == ( 0 | 0 ) ; if ( ! ( $365 ) ) { $366 = ( ( ( $$3349$i ) ) + 16 | 0 ) ; HEAP32 [ $366 >> 2 ] = $364 ; $367 = ( ( ( $364 ) ) + 24 | 0 ) ; HEAP32 [ $367 >> 2 ] = $$3349$i ; } $368 = ( ( ( $$4$lcssa$i ) ) + 20 | 0 ) ; $369 = HEAP32 [ $368 >> 2 ] | 0 ; $370 = ( $369 | 0 ) == ( 0 | 0 ) ; if ( $370 ) { $431 = $226 ; } else { $371 = ( ( ( $$3349$i ) ) + 20 | 0 ) ; HEAP32 [ $371 >> 2 ] = $369 ; $372 = ( ( ( $369 ) ) + 24 | 0 ) ; HEAP32 [ $372 >> 2 ] = $$3349$i ; $431 = $226 ; } } } while ( 0 ) ; $373 = ( $$4329$lcssa$i >>> 0 ) < ( 16 ) ; do { if ( $373 ) { $374 = ( ( $$4329$lcssa$i ) + ( $225 ) ) | 0 ; $375 = $374 | 3 ; $376 = ( ( ( $$4$lcssa$i ) ) + 4 | 0 ) ; HEAP32 [ $376 >> 2 ] = $375 ; $377 = ( ( $$4$lcssa$i ) + ( $374 ) | 0 ) ; $378 = ( ( ( $377 ) ) + 4 | 0 ) ; $379 = HEAP32 [ $378 >> 2 ] | 0 ; $380 = $379 | 1 ; HEAP32 [ $378 >> 2 ] = $380 ; } else { $381 = $225 | 3 ; $382 = ( ( ( $$4$lcssa$i ) ) + 4 | 0 ) ; HEAP32 [ $382 >> 2 ] = $381 ; $383 = $$4329$lcssa$i | 1 ; $384 = ( ( ( $325 ) ) + 4 | 0 ) ; HEAP32 [ $384 >> 2 ] = $383 ; $385 = ( ( $325 ) + ( $$4329$lcssa$i ) | 0 ) ; HEAP32 [ $385 >> 2 ] = $$4329$lcssa$i ; $386 = $$4329$lcssa$i >>> 3 ; $387 = ( $$4329$lcssa$i >>> 0 ) < ( 256 ) ; if ( $387 ) { $388 = $386 << 1 ; $389 = ( 66980 + ( $388 << 2 ) | 0 ) ; $390 = HEAP32 [ 16735 ] | 0 ; $391 = 1 << $386 ; $392 = $390 & $391 ; $393 = ( $392 | 0 ) == ( 0 ) ; if ( $393 ) { $394 = $390 | $391 ; HEAP32 [ 16735 ] = $394 ; $$pre$i207 = ( ( ( $389 ) ) + 8 | 0 ) ; $$0345$i = $389 ; $$pre$phi$i208Z2D = $$pre$i207 ; } else { $395 = ( ( ( $389 ) ) + 8 | 0 ) ; $396 = HEAP32 [ $395 >> 2 ] | 0 ; $$0345$i = $396 ; $$pre$phi$i208Z2D = $395 ; } HEAP32 [ $$pre$phi$i208Z2D >> 2 ] = $325 ; $397 = ( ( ( $$0345$i ) ) + 12 | 0 ) ; HEAP32 [ $397 >> 2 ] = $325 ; $398 = ( ( ( $325 ) ) + 8 | 0 ) ; HEAP32 [ $398 >> 2 ] = $$0345$i ; $399 = ( ( ( $325 ) ) + 12 | 0 ) ; HEAP32 [ $399 >> 2 ] = $389 ; break ; } $400 = $$4329$lcssa$i >>> 8 ; $401 = ( $400 | 0 ) == ( 0 ) ; if ( $401 ) { $$0339$i = 0 ; } else { $402 = ( $$4329$lcssa$i >>> 0 ) > ( 16777215 ) ; if ( $402 ) { $$0339$i = 31 ; } else { $403 = ( ( $400 ) + 1048320 ) | 0 ; $404 = $403 >>> 16 ; $405 = $404 & 8 ; $406 = $400 << $405 ; $407 = ( ( $406 ) + 520192 ) | 0 ; $408 = $407 >>> 16 ; $409 = $408 & 4 ; $410 = $409 | $405 ; $411 = $406 << $409 ; $412 = ( ( $411 ) + 245760 ) | 0 ; $413 = $412 >>> 16 ; $414 = $413 & 2 ; $415 = $410 | $414 ; $416 = ( 14 - ( $415 ) ) | 0 ; $417 = $411 << $414 ; $418 = $417 >>> 15 ; $419 = ( ( $416 ) + ( $418 ) ) | 0 ; $420 = $419 << 1 ; $421 = ( ( $419 ) + 7 ) | 0 ; $422 = $$4329$lcssa$i >>> $421 ; $423 = $422 & 1 ; $424 = $423 | $420 ; $$0339$i = $424 ; } } $425 = ( 67244 + ( $$0339$i << 2 ) | 0 ) ; $426 = ( ( ( $325 ) ) + 28 | 0 ) ; HEAP32 [ $426 >> 2 ] = $$0339$i ; $427 = ( ( ( $325 ) ) + 16 | 0 ) ; $428 = ( ( ( $427 ) ) + 4 | 0 ) ; HEAP32 [ $428 >> 2 ] = 0 ; HEAP32 [ $427 >> 2 ] = 0 ; $429 = 1 << $$0339$i ; $430 = $431 & $429 ; $432 = ( $430 | 0 ) == ( 0 ) ; if ( $432 ) { $433 = $431 | $429 ; HEAP32 [ ( 66944 ) >> 2 ] = $433 ; HEAP32 [ $425 >> 2 ] = $325 ; $434 = ( ( ( $325 ) ) + 24 | 0 ) ; HEAP32 [ $434 >> 2 ] = $425 ; $435 = ( ( ( $325 ) ) + 12 | 0 ) ; HEAP32 [ $435 >> 2 ] = $325 ; $436 = ( ( ( $325 ) ) + 8 | 0 ) ; HEAP32 [ $436 >> 2 ] = $325 ; break ; } $437 = HEAP32 [ $425 >> 2 ] | 0 ; $438 = ( $$0339$i | 0 ) == ( 31 ) ; $439 = $$0339$i >>> 1 ; $440 = ( 25 - ( $439 ) ) | 0 ; $441 = $438 ? 0 : $440 ; $442 = $$4329$lcssa$i << $441 ; $$0322$i = $442 ; $$0323$i = $437 ; while ( 1 ) { $443 = ( ( ( $$0323$i ) ) + 4 | 0 ) ; $444 = HEAP32 [ $443 >> 2 ] | 0 ; $445 = $444 & - 8 ; $446 = ( $445 | 0 ) == ( $$4329$lcssa$i | 0 ) ; if ( $446 ) { label = 97 ; break ; } $447 = $$0322$i >>> 31 ; $448 = ( ( ( ( $$0323$i ) ) + 16 | 0 ) + ( $447 << 2 ) | 0 ) ; $449 = $$0322$i << 1 ; $450 = HEAP32 [ $448 >> 2 ] | 0 ; $451 = ( $450 | 0 ) == ( 0 | 0 ) ; if ( $451 ) { label = 96 ; break ; } else { $$0322$i = $449 ; $$0323$i = $450 ; } } if ( ( label | 0 ) == 96 ) { HEAP32 [ $448 >> 2 ] = $325 ; $452 = ( ( ( $325 ) ) + 24 | 0 ) ; HEAP32 [ $452 >> 2 ] = $$0323$i ; $453 = ( ( ( $325 ) ) + 12 | 0 ) ; HEAP32 [ $453 >> 2 ] = $325 ; $454 = ( ( ( $325 ) ) + 8 | 0 ) ; HEAP32 [ $454 >> 2 ] = $325 ; break ; } else if ( ( label | 0 ) == 97 ) { $455 = ( ( ( $$0323$i ) ) + 8 | 0 ) ; $456 = HEAP32 [ $455 >> 2 ] | 0 ; $457 = ( ( ( $456 ) ) + 12 | 0 ) ; HEAP32 [ $457 >> 2 ] = $325 ; HEAP32 [ $455 >> 2 ] = $325 ; $458 = ( ( ( $325 ) ) + 8 | 0 ) ; HEAP32 [ $458 >> 2 ] = $456 ; $459 = ( ( ( $325 ) ) + 12 | 0 ) ; HEAP32 [ $459 >> 2 ] = $$0323$i ; $460 = ( ( ( $325 ) ) + 24 | 0 ) ; HEAP32 [ $460 >> 2 ] = 0 ; break ; } } } while ( 0 ) ; $461 = ( ( ( $$4$lcssa$i ) ) + 8 | 0 ) ; $$0 = $461 ; STACKTOP = sp ; return ( $$0 | 0 ) ; } else { $$0192 = $225 ; } } } } } } while ( 0 ) ; $462 = HEAP32 [ ( 66948 ) >> 2 ] | 0 ; $463 = ( $462 >>> 0 ) < ( $$0192 >>> 0 ) ; if ( ! ( $463 ) ) { $464 = ( ( $462 ) - ( $$0192 ) ) | 0 ; $465 = HEAP32 [ ( 66960 ) >> 2 ] | 0 ; $466 = ( $464 >>> 0 ) > ( 15 ) ; if ( $466 ) { $467 = ( ( $465 ) + ( $$0192 ) | 0 ) ; HEAP32 [ ( 66960 ) >> 2 ] = $467 ; HEAP32 [ ( 66948 ) >> 2 ] = $464 ; $468 = $464 | 1 ; $469 = ( ( ( $467 ) ) + 4 | 0 ) ; HEAP32 [ $469 >> 2 ] = $468 ; $470 = ( ( $465 ) + ( $462 ) | 0 ) ; HEAP32 [ $470 >> 2 ] = $464 ; $471 = $$0192 | 3 ; $472 = ( ( ( $465 ) ) + 4 | 0 ) ; HEAP32 [ $472 >> 2 ] = $471 ; } else { HEAP32 [ ( 66948 ) >> 2 ] = 0 ; HEAP32 [ ( 66960 ) >> 2 ] = 0 ; $473 = $462 | 3 ; $474 = ( ( ( $465 ) ) + 4 | 0 ) ; HEAP32 [ $474 >> 2 ] = $473 ; $475 = ( ( $465 ) + ( $462 ) | 0 ) ; $476 = ( ( ( $475 ) ) + 4 | 0 ) ; $477 = HEAP32 [ $476 >> 2 ] | 0 ; $478 = $477 | 1 ; HEAP32 [ $476 >> 2 ] = $478 ; } $479 = ( ( ( $465 ) ) + 8 | 0 ) ; $$0 = $479 ; STACKTOP = sp ; return ( $$0 | 0 ) ; } $480 = HEAP32 [ ( 66952 ) >> 2 ] | 0 ; $481 = ( $480 >>> 0 ) > ( $$0192 >>> 0 ) ; if ( $481 ) { $482 = ( ( $480 ) - ( $$0192 ) ) | 0 ; HEAP32 [ ( 66952 ) >> 2 ] = $482 ; $483 = HEAP32 [ ( 66964 ) >> 2 ] | 0 ; $484 = ( ( $483 ) + ( $$0192 ) | 0 ) ; HEAP32 [ ( 66964 ) >> 2 ] = $484 ; $485 = $482 | 1 ; $486 = ( ( ( $484 ) ) + 4 | 0 ) ; HEAP32 [ $486 >> 2 ] = $485 ; $487 = $$0192 | 3 ; $488 = ( ( ( $483 ) ) + 4 | 0 ) ; HEAP32 [ $488 >> 2 ] = $487 ; $489 = ( ( ( $483 ) ) + 8 | 0 ) ; $$0 = $489 ; STACKTOP = sp ; return ( $$0 | 0 ) ; } $490 = HEAP32 [ 16853 ] | 0 ; $491 = ( $490 | 0 ) == ( 0 ) ; if ( $491 ) { HEAP32 [ ( 67420 ) >> 2 ] = 4096 ; HEAP32 [ ( 67416 ) >> 2 ] = 4096 ; HEAP32 [ ( 67424 ) >> 2 ] = - 1 ; HEAP32 [ ( 67428 ) >> 2 ] = - 1 ; HEAP32 [ ( 67432 ) >> 2 ] = 0 ; HEAP32 [ ( 67384 ) >> 2 ] = 0 ; $492 = $1 ; $493 = $492 & - 16 ; $494 = $493 ^ 1431655768 ; HEAP32 [ 16853 ] = $494 ; $498 = 4096 ; } else { $$pre$i195 = HEAP32 [ ( 67420 ) >> 2 ] | 0 ; $498 = $$pre$i195 ; } $495 = ( ( $$0192 ) + 48 ) | 0 ; $496 = ( ( $$0192 ) + 47 ) | 0 ; $497 = ( ( $498 ) + ( $496 ) ) | 0 ; $499 = ( 0 - ( $498 ) ) | 0 ; $500 = $497 & $499 ; $501 = ( $500 >>> 0 ) > ( $$0192 >>> 0 ) ; if ( ! ( $501 ) ) { $$0 = 0 ; STACKTOP = sp ; return ( $$0 | 0 ) ; } $502 = HEAP32 [ ( 67380 ) >> 2 ] | 0 ; $503 = ( $502 | 0 ) == ( 0 ) ; if ( ! ( $503 ) ) { $504 = HEAP32 [ ( 67372 ) >> 2 ] | 0 ; $505 = ( ( $504 ) + ( $500 ) ) | 0 ; $506 = ( $505 >>> 0 ) <= ( $504 >>> 0 ) ; $507 = ( $505 >>> 0 ) > ( $502 >>> 0 ) ; $or$cond1$i = $506 | $507 ; if ( $or$cond1$i ) { $$0 = 0 ; STACKTOP = sp ; return ( $$0 | 0 ) ; } } $508 = HEAP32 [ ( 67384 ) >> 2 ] | 0 ; $509 = $508 & 4 ; $510 = ( $509 | 0 ) == ( 0 ) ; L167 : do { if ( $510 ) { $511 = HEAP32 [ ( 66964 ) >> 2 ] | 0 ; $512 = ( $511 | 0 ) == ( 0 | 0 ) ; L169 : do { if ( $512 ) { label = 118 ; } else { $$0$i20$i = ( 67388 ) ; while ( 1 ) { $513 = HEAP32 [ $$0$i20$i >> 2 ] | 0 ; $514 = ( $513 >>> 0 ) > ( $511 >>> 0 ) ; if ( ! ( $514 ) ) { $515 = ( ( ( $$0$i20$i ) ) + 4 | 0 ) ; $516 = HEAP32 [ $515 >> 2 ] | 0 ; $517 = ( ( $513 ) + ( $516 ) | 0 ) ; $518 = ( $517 >>> 0 ) > ( $511 >>> 0 ) ; if ( $518 ) { break ; } } $519 = ( ( ( $$0$i20$i ) ) + 8 | 0 ) ; $520 = HEAP32 [ $519 >> 2 ] | 0 ; $521 = ( $520 | 0 ) == ( 0 | 0 ) ; if ( $521 ) { label = 118 ; break L169 ; } else { $$0$i20$i = $520 ; } } $544 = ( ( $497 ) - ( $480 ) ) | 0 ; $545 = $544 & $499 ; $546 = ( $545 >>> 0 ) < ( 2147483647 ) ; if ( $546 ) { $547 = ( _sbrk ( ( $545 | 0 ) ) | 0 ) ; $548 = HEAP32 [ $$0$i20$i >> 2 ] | 0 ; $549 = HEAP32 [ $515 >> 2 ] | 0 ; $550 = ( ( $548 ) + ( $549 ) | 0 ) ; $551 = ( $547 | 0 ) == ( $550 | 0 ) ; if ( $551 ) { $552 = ( $547 | 0 ) == ( ( - 1 ) | 0 ) ; if ( $552 ) { $$2234243136$i = $545 ; } else { $$723947$i = $545 ; $$748$i = $547 ; label = 135 ; break L167 ; } } else { $$2247$ph$i = $547 ; $$2253$ph$i = $545 ; label = 126 ; } } else { $$2234243136$i = 0 ; } } } while ( 0 ) ; do { if ( ( label | 0 ) == 118 ) { $522 = ( _sbrk ( 0 ) | 0 ) ; $523 = ( $522 | 0 ) == ( ( - 1 ) | 0 ) ; if ( $523 ) { $$2234243136$i = 0 ; } else { $524 = $522 ; $525 = HEAP32 [ ( 67416 ) >> 2 ] | 0 ; $526 = ( ( $525 ) + - 1 ) | 0 ; $527 = $526 & $524 ; $528 = ( $527 | 0 ) == ( 0 ) ; $529 = ( ( $526 ) + ( $524 ) ) | 0 ; $530 = ( 0 - ( $525 ) ) | 0 ; $531 = $529 & $530 ; $532 = ( ( $531 ) - ( $524 ) ) | 0 ; $533 = $528 ? 0 : $532 ; $$$i = ( ( $533 ) + ( $500 ) ) | 0 ; $534 = HEAP32 [ ( 67372 ) >> 2 ] | 0 ; $535 = ( ( $$$i ) + ( $534 ) ) | 0 ; $536 = ( $$$i >>> 0 ) > ( $$0192 >>> 0 ) ; $537 = ( $$$i >>> 0 ) < ( 2147483647 ) ; $or$cond$i = $536 & $537 ; if ( $or$cond$i ) { $538 = HEAP32 [ ( 67380 ) >> 2 ] | 0 ; $539 = ( $538 | 0 ) == ( 0 ) ; if ( ! ( $539 ) ) { $540 = ( $535 >>> 0 ) <= ( $534 >>> 0 ) ; $541 = ( $535 >>> 0 ) > ( $538 >>> 0 ) ; $or$cond2$i = $540 | $541 ; if ( $or$cond2$i ) { $$2234243136$i = 0 ; break ; } } $542 = ( _sbrk ( ( $$$i | 0 ) ) | 0 ) ; $543 = ( $542 | 0 ) == ( $522 | 0 ) ; if ( $543 ) { $$723947$i = $$$i ; $$748$i = $522 ; label = 135 ; break L167 ; } else { $$2247$ph$i = $542 ; $$2253$ph$i = $$$i ; label = 126 ; } } else { $$2234243136$i = 0 ; } } } } while ( 0 ) ; do { if ( ( label | 0 ) == 126 ) { $553 = ( 0 - ( $$2253$ph$i ) ) | 0 ; $554 = ( $$2247$ph$i | 0 ) != ( ( - 1 ) | 0 ) ; $555 = ( $$2253$ph$i >>> 0 ) < ( 2147483647 ) ; $or$cond7$i = $555 & $554 ; $556 = ( $495 >>> 0 ) > ( $$2253$ph$i >>> 0 ) ; $or$cond10$i = $556 & $or$cond7$i ; if ( ! ( $or$cond10$i ) ) { $566 = ( $$2247$ph$i | 0 ) == ( ( - 1 ) | 0 ) ; if ( $566 ) { $$2234243136$i = 0 ; break ; } else { $$723947$i = $$2253$ph$i ; $$748$i = $$2247$ph$i ; label = 135 ; break L167 ; } } $557 = HEAP32 [ ( 67420 ) >> 2 ] | 0 ; $558 = ( ( $496 ) - ( $$2253$ph$i ) ) | 0 ; $559 = ( ( $558 ) + ( $557 ) ) | 0 ; $560 = ( 0 - ( $557 ) ) | 0 ; $561 = $559 & $560 ; $562 = ( $561 >>> 0 ) < ( 2147483647 ) ; if ( ! ( $562 ) ) { $$723947$i = $$2253$ph$i ; $$748$i = $$2247$ph$i ; label = 135 ; break L167 ; } $563 = ( _sbrk ( ( $561 | 0 ) ) | 0 ) ; $564 = ( $563 | 0 ) == ( ( - 1 ) | 0 ) ; if ( $564 ) { ( _sbrk ( ( $553 | 0 ) ) | 0 ) ; $$2234243136$i = 0 ; break ; } else { $565 = ( ( $561 ) + ( $$2253$ph$i ) ) | 0 ; $$723947$i = $565 ; $$748$i = $$2247$ph$i ; label = 135 ; break L167 ; } } } while ( 0 ) ; $567 = HEAP32 [ ( 67384 ) >> 2 ] | 0 ; $568 = $567 | 4 ; HEAP32 [ ( 67384 ) >> 2 ] = $568 ; $$4236$i = $$2234243136$i ; label = 133 ; } else { $$4236$i = 0 ; label = 133 ; } } while ( 0 ) ; if ( ( label | 0 ) == 133 ) { $569 = ( $500 >>> 0 ) < ( 2147483647 ) ; if ( $569 ) { $570 = ( _sbrk ( ( $500 | 0 ) ) | 0 ) ; $571 = ( _sbrk ( 0 ) | 0 ) ; $572 = ( $570 | 0 ) != ( ( - 1 ) | 0 ) ; $573 = ( $571 | 0 ) != ( ( - 1 ) | 0 ) ; $or$cond5$i = $572 & $573 ; $574 = ( $570 >>> 0 ) < ( $571 >>> 0 ) ; $or$cond11$i = $574 & $or$cond5$i ; $575 = $571 ; $576 = $570 ; $577 = ( ( $575 ) - ( $576 ) ) | 0 ; $578 = ( ( $$0192 ) + 40 ) | 0 ; $579 = ( $577 >>> 0 ) > ( $578 >>> 0 ) ; $$$4236$i = $579 ? $577 : $$4236$i ; $or$cond11$not$i = $or$cond11$i ^ 1 ; $580 = ( $570 | 0 ) == ( ( - 1 ) | 0 ) ; $not$$i = $579 ^ 1 ; $581 = $580 | $not$$i ; $or$cond49$i = $581 | $or$cond11$not$i ; if ( ! ( $or$cond49$i ) ) { $$723947$i = $$$4236$i ; $$748$i = $570 ; label = 135 ; } } } if ( ( label | 0 ) == 135 ) { $582 = HEAP32 [ ( 67372 ) >> 2 ] | 0 ; $583 = ( ( $582 ) + ( $$723947$i ) ) | 0 ; HEAP32 [ ( 67372 ) >> 2 ] = $583 ; $584 = HEAP32 [ ( 67376 ) >> 2 ] | 0 ; $585 = ( $583 >>> 0 ) > ( $584 >>> 0 ) ; if ( $585 ) { HEAP32 [ ( 67376 ) >> 2 ] = $583 ; } $586 = HEAP32 [ ( 66964 ) >> 2 ] | 0 ; $587 = ( $586 | 0 ) == ( 0 | 0 ) ; do { if ( $587 ) { $588 = HEAP32 [ ( 66956 ) >> 2 ] | 0 ; $589 = ( $588 | 0 ) == ( 0 | 0 ) ; $590 = ( $$748$i >>> 0 ) < ( $588 >>> 0 ) ; $or$cond12$i = $589 | $590 ; if ( $or$cond12$i ) { HEAP32 [ ( 66956 ) >> 2 ] = $$748$i ; } HEAP32 [ ( 67388 ) >> 2 ] = $$748$i ; HEAP32 [ ( 67392 ) >> 2 ] = $$723947$i ; HEAP32 [ ( 67400 ) >> 2 ] = 0 ; $591 = HEAP32 [ 16853 ] | 0 ; HEAP32 [ ( 66976 ) >> 2 ] = $591 ; HEAP32 [ ( 66972 ) >> 2 ] = - 1 ; HEAP32 [ ( 66992 ) >> 2 ] = ( 66980 ) ; HEAP32 [ ( 66988 ) >> 2 ] = ( 66980 ) ; HEAP32 [ ( 67000 ) >> 2 ] = ( 66988 ) ; HEAP32 [ ( 66996 ) >> 2 ] = ( 66988 ) ; HEAP32 [ ( 67008 ) >> 2 ] = ( 66996 ) ; HEAP32 [ ( 67004 ) >> 2 ] = ( 66996 ) ; HEAP32 [ ( 67016 ) >> 2 ] = ( 67004 ) ; HEAP32 [ ( 67012 ) >> 2 ] = ( 67004 ) ; HEAP32 [ ( 67024 ) >> 2 ] = ( 67012 ) ; HEAP32 [ ( 67020 ) >> 2 ] = ( 67012 ) ; HEAP32 [ ( 67032 ) >> 2 ] = ( 67020 ) ; HEAP32 [ ( 67028 ) >> 2 ] = ( 67020 ) ; HEAP32 [ ( 67040 ) >> 2 ] = ( 67028 ) ; HEAP32 [ ( 67036 ) >> 2 ] = ( 67028 ) ; HEAP32 [ ( 67048 ) >> 2 ] = ( 67036 ) ; HEAP32 [ ( 67044 ) >> 2 ] = ( 67036 ) ; HEAP32 [ ( 67056 ) >> 2 ] = ( 67044 ) ; HEAP32 [ ( 67052 ) >> 2 ] = ( 67044 ) ; HEAP32 [ ( 67064 ) >> 2 ] = ( 67052 ) ; HEAP32 [ ( 67060 ) >> 2 ] = ( 67052 ) ; HEAP32 [ ( 67072 ) >> 2 ] = ( 67060 ) ; HEAP32 [ ( 67068 ) >> 2 ] = ( 67060 ) ; HEAP32 [ ( 67080 ) >> 2 ] = ( 67068 ) ; HEAP32 [ ( 67076 ) >> 2 ] = ( 67068 ) ; HEAP32 [ ( 67088 ) >> 2 ] = ( 67076 ) ; HEAP32 [ ( 67084 ) >> 2 ] = ( 67076 ) ; HEAP32 [ ( 67096 ) >> 2 ] = ( 67084 ) ; HEAP32 [ ( 67092 ) >> 2 ] = ( 67084 ) ; HEAP32 [ ( 67104 ) >> 2 ] = ( 67092 ) ; HEAP32 [ ( 67100 ) >> 2 ] = ( 67092 ) ; HEAP32 [ ( 67112 ) >> 2 ] = ( 67100 ) ; HEAP32 [ ( 67108 ) >> 2 ] = ( 67100 ) ; HEAP32 [ ( 67120 ) >> 2 ] = ( 67108 ) ; HEAP32 [ ( 67116 ) >> 2 ] = ( 67108 ) ; HEAP32 [ ( 67128 ) >> 2 ] = ( 67116 ) ; HEAP32 [ ( 67124 ) >> 2 ] = ( 67116 ) ; HEAP32 [ ( 67136 ) >> 2 ] = ( 67124 ) ; HEAP32 [ ( 67132 ) >> 2 ] = ( 67124 ) ; HEAP32 [ ( 67144 ) >> 2 ] = ( 67132 ) ; HEAP32 [ ( 67140 ) >> 2 ] = ( 67132 ) ; HEAP32 [ ( 67152 ) >> 2 ] = ( 67140 ) ; HEAP32 [ ( 67148 ) >> 2 ] = ( 67140 ) ; HEAP32 [ ( 67160 ) >> 2 ] = ( 67148 ) ; HEAP32 [ ( 67156 ) >> 2 ] = ( 67148 ) ; HEAP32 [ ( 67168 ) >> 2 ] = ( 67156 ) ; HEAP32 [ ( 67164 ) >> 2 ] = ( 67156 ) ; HEAP32 [ ( 67176 ) >> 2 ] = ( 67164 ) ; HEAP32 [ ( 67172 ) >> 2 ] = ( 67164 ) ; HEAP32 [ ( 67184 ) >> 2 ] = ( 67172 ) ; HEAP32 [ ( 67180 ) >> 2 ] = ( 67172 ) ; HEAP32 [ ( 67192 ) >> 2 ] = ( 67180 ) ; HEAP32 [ ( 67188 ) >> 2 ] = ( 67180 ) ; HEAP32 [ ( 67200 ) >> 2 ] = ( 67188 ) ; HEAP32 [ ( 67196 ) >> 2 ] = ( 67188 ) ; HEAP32 [ ( 67208 ) >> 2 ] = ( 67196 ) ; HEAP32 [ ( 67204 ) >> 2 ] = ( 67196 ) ; HEAP32 [ ( 67216 ) >> 2 ] = ( 67204 ) ; HEAP32 [ ( 67212 ) >> 2 ] = ( 67204 ) ; HEAP32 [ ( 67224 ) >> 2 ] = ( 67212 ) ; HEAP32 [ ( 67220 ) >> 2 ] = ( 67212 ) ; HEAP32 [ ( 67232 ) >> 2 ] = ( 67220 ) ; HEAP32 [ ( 67228 ) >> 2 ] = ( 67220 ) ; HEAP32 [ ( 67240 ) >> 2 ] = ( 67228 ) ; HEAP32 [ ( 67236 ) >> 2 ] = ( 67228 ) ; $592 = ( ( $$723947$i ) + - 40 ) | 0 ; $593 = ( ( ( $$748$i ) ) + 8 | 0 ) ; $594 = $593 ; $595 = $594 & 7 ; $596 = ( $595 | 0 ) == ( 0 ) ; $597 = ( 0 - ( $594 ) ) | 0 ; $598 = $597 & 7 ; $599 = $596 ? 0 : $598 ; $600 = ( ( $$748$i ) + ( $599 ) | 0 ) ; $601 = ( ( $592 ) - ( $599 ) ) | 0 ; HEAP32 [ ( 66964 ) >> 2 ] = $600 ; HEAP32 [ ( 66952 ) >> 2 ] = $601 ; $602 = $601 | 1 ; $603 = ( ( ( $600 ) ) + 4 | 0 ) ; HEAP32 [ $603 >> 2 ] = $602 ; $604 = ( ( $$748$i ) + ( $592 ) | 0 ) ; $605 = ( ( ( $604 ) ) + 4 | 0 ) ; HEAP32 [ $605 >> 2 ] = 40 ; $606 = HEAP32 [ ( 67428 ) >> 2 ] | 0 ; HEAP32 [ ( 66968 ) >> 2 ] = $606 ; } else { $$024367$i = ( 67388 ) ; while ( 1 ) { $607 = HEAP32 [ $$024367$i >> 2 ] | 0 ; $608 = ( ( ( $$024367$i ) ) + 4 | 0 ) ; $609 = HEAP32 [ $608 >> 2 ] | 0 ; $610 = ( ( $607 ) + ( $609 ) | 0 ) ; $611 = ( $$748$i | 0 ) == ( $610 | 0 ) ; if ( $611 ) { label = 143 ; break ; } $612 = ( ( ( $$024367$i ) ) + 8 | 0 ) ; $613 = HEAP32 [ $612 >> 2 ] | 0 ; $614 = ( $613 | 0 ) == ( 0 | 0 ) ; if ( $614 ) { break ; } else { $$024367$i = $613 ; } } if ( ( label | 0 ) == 143 ) { $615 = ( ( ( $$024367$i ) ) + 12 | 0 ) ; $616 = HEAP32 [ $615 >> 2 ] | 0 ; $617 = $616 & 8 ; $618 = ( $617 | 0 ) == ( 0 ) ; if ( $618 ) { $619 = ( $607 >>> 0 ) <= ( $586 >>> 0 ) ; $620 = ( $$748$i >>> 0 ) > ( $586 >>> 0 ) ; $or$cond50$i = $620 & $619 ; if ( $or$cond50$i ) { $621 = ( ( $609 ) + ( $$723947$i ) ) | 0 ; HEAP32 [ $608 >> 2 ] = $621 ; $622 = HEAP32 [ ( 66952 ) >> 2 ] | 0 ; $623 = ( ( $622 ) + ( $$723947$i ) ) | 0 ; $624 = ( ( ( $586 ) ) + 8 | 0 ) ; $625 = $624 ; $626 = $625 & 7 ; $627 = ( $626 | 0 ) == ( 0 ) ; $628 = ( 0 - ( $625 ) ) | 0 ; $629 = $628 & 7 ; $630 = $627 ? 0 : $629 ; $631 = ( ( $586 ) + ( $630 ) | 0 ) ; $632 = ( ( $623 ) - ( $630 ) ) | 0 ; HEAP32 [ ( 66964 ) >> 2 ] = $631 ; HEAP32 [ ( 66952 ) >> 2 ] = $632 ; $633 = $632 | 1 ; $634 = ( ( ( $631 ) ) + 4 | 0 ) ; HEAP32 [ $634 >> 2 ] = $633 ; $635 = ( ( $586 ) + ( $623 ) | 0 ) ; $636 = ( ( ( $635 ) ) + 4 | 0 ) ; HEAP32 [ $636 >> 2 ] = 40 ; $637 = HEAP32 [ ( 67428 ) >> 2 ] | 0 ; HEAP32 [ ( 66968 ) >> 2 ] = $637 ; break ; } } } $638 = HEAP32 [ ( 66956 ) >> 2 ] | 0 ; $639 = ( $$748$i >>> 0 ) < ( $638 >>> 0 ) ; if ( $639 ) { HEAP32 [ ( 66956 ) >> 2 ] = $$748$i ; } $640 = ( ( $$748$i ) + ( $$723947$i ) | 0 ) ; $$124466$i = ( 67388 ) ; while ( 1 ) { $641 = HEAP32 [ $$124466$i >> 2 ] | 0 ; $642 = ( $641 | 0 ) == ( $640 | 0 ) ; if ( $642 ) { label = 151 ; break ; } $643 = ( ( ( $$124466$i ) ) + 8 | 0 ) ; $644 = HEAP32 [ $643 >> 2 ] | 0 ; $645 = ( $644 | 0 ) == ( 0 | 0 ) ; if ( $645 ) { $$0$i$i$i = ( 67388 ) ; break ; } else { $$124466$i = $644 ; } } if ( ( label | 0 ) == 151 ) { $646 = ( ( ( $$124466$i ) ) + 12 | 0 ) ; $647 = HEAP32 [ $646 >> 2 ] | 0 ; $648 = $647 & 8 ; $649 = ( $648 | 0 ) == ( 0 ) ; if ( $649 ) { HEAP32 [ $$124466$i >> 2 ] = $$748$i ; $650 = ( ( ( $$124466$i ) ) + 4 | 0 ) ; $651 = HEAP32 [ $650 >> 2 ] | 0 ; $652 = ( ( $651 ) + ( $$723947$i ) ) | 0 ; HEAP32 [ $650 >> 2 ] = $652 ; $653 = ( ( ( $$748$i ) ) + 8 | 0 ) ; $654 = $653 ; $655 = $654 & 7 ; $656 = ( $655 | 0 ) == ( 0 ) ; $657 = ( 0 - ( $654 ) ) | 0 ; $658 = $657 & 7 ; $659 = $656 ? 0 : $658 ; $660 = ( ( $$748$i ) + ( $659 ) | 0 ) ; $661 = ( ( ( $640 ) ) + 8 | 0 ) ; $662 = $661 ; $663 = $662 & 7 ; $664 = ( $663 | 0 ) == ( 0 ) ; $665 = ( 0 - ( $662 ) ) | 0 ; $666 = $665 & 7 ; $667 = $664 ? 0 : $666 ; $668 = ( ( $640 ) + ( $667 ) | 0 ) ; $669 = $668 ; $670 = $660 ; $671 = ( ( $669 ) - ( $670 ) ) | 0 ; $672 = ( ( $660 ) + ( $$0192 ) | 0 ) ; $673 = ( ( $671 ) - ( $$0192 ) ) | 0 ; $674 = $$0192 | 3 ; $675 = ( ( ( $660 ) ) + 4 | 0 ) ; HEAP32 [ $675 >> 2 ] = $674 ; $676 = ( $586 | 0 ) == ( $668 | 0 ) ; do { if ( $676 ) { $677 = HEAP32 [ ( 66952 ) >> 2 ] | 0 ; $678 = ( ( $677 ) + ( $673 ) ) | 0 ; HEAP32 [ ( 66952 ) >> 2 ] = $678 ; HEAP32 [ ( 66964 ) >> 2 ] = $672 ; $679 = $678 | 1 ; $680 = ( ( ( $672 ) ) + 4 | 0 ) ; HEAP32 [ $680 >> 2 ] = $679 ; } else { $681 = HEAP32 [ ( 66960 ) >> 2 ] | 0 ; $682 = ( $681 | 0 ) == ( $668 | 0 ) ; if ( $682 ) { $683 = HEAP32 [ ( 66948 ) >> 2 ] | 0 ; $684 = ( ( $683 ) + ( $673 ) ) | 0 ; HEAP32 [ ( 66948 ) >> 2 ] = $684 ; HEAP32 [ ( 66960 ) >> 2 ] = $672 ; $685 = $684 | 1 ; $686 = ( ( ( $672 ) ) + 4 | 0 ) ; HEAP32 [ $686 >> 2 ] = $685 ; $687 = ( ( $672 ) + ( $684 ) | 0 ) ; HEAP32 [ $687 >> 2 ] = $684 ; break ; } $688 = ( ( ( $668 ) ) + 4 | 0 ) ; $689 = HEAP32 [ $688 >> 2 ] | 0 ; $690 = $689 & 3 ; $691 = ( $690 | 0 ) == ( 1 ) ; if ( $691 ) { $692 = $689 & - 8 ; $693 = $689 >>> 3 ; $694 = ( $689 >>> 0 ) < ( 256 ) ; L234 : do { if ( $694 ) { $695 = ( ( ( $668 ) ) + 8 | 0 ) ; $696 = HEAP32 [ $695 >> 2 ] | 0 ; $697 = ( ( ( $668 ) ) + 12 | 0 ) ; $698 = HEAP32 [ $697 >> 2 ] | 0 ; $699 = ( $698 | 0 ) == ( $696 | 0 ) ; if ( $699 ) { $700 = 1 << $693 ; $701 = $700 ^ - 1 ; $702 = HEAP32 [ 16735 ] | 0 ; $703 = $702 & $701 ; HEAP32 [ 16735 ] = $703 ; break ; } else { $704 = ( ( ( $696 ) ) + 12 | 0 ) ; HEAP32 [ $704 >> 2 ] = $698 ; $705 = ( ( ( $698 ) ) + 8 | 0 ) ; HEAP32 [ $705 >> 2 ] = $696 ; break ; } } else { $706 = ( ( ( $668 ) ) + 24 | 0 ) ; $707 = HEAP32 [ $706 >> 2 ] | 0 ; $708 = ( ( ( $668 ) ) + 12 | 0 ) ; $709 = HEAP32 [ $708 >> 2 ] | 0 ; $710 = ( $709 | 0 ) == ( $668 | 0 ) ; do { if ( $710 ) { $715 = ( ( ( $668 ) ) + 16 | 0 ) ; $716 = ( ( ( $715 ) ) + 4 | 0 ) ; $717 = HEAP32 [ $716 >> 2 ] | 0 ; $718 = ( $717 | 0 ) == ( 0 | 0 ) ; if ( $718 ) { $719 = HEAP32 [ $715 >> 2 ] | 0 ; $720 = ( $719 | 0 ) == ( 0 | 0 ) ; if ( $720 ) { $$3$i$i = 0 ; break ; } else { $$1264$i$i = $719 ; $$1266$i$i = $715 ; } } else { $$1264$i$i = $717 ; $$1266$i$i = $716 ; } while ( 1 ) { $721 = ( ( ( $$1264$i$i ) ) + 20 | 0 ) ; $722 = HEAP32 [ $721 >> 2 ] | 0 ; $723 = ( $722 | 0 ) == ( 0 | 0 ) ; if ( ! ( $723 ) ) { $$1264$i$i = $722 ; $$1266$i$i = $721 ; continue ; } $724 = ( ( ( $$1264$i$i ) ) + 16 | 0 ) ; $725 = HEAP32 [ $724 >> 2 ] | 0 ; $726 = ( $725 | 0 ) == ( 0 | 0 ) ; if ( $726 ) { break ; } else { $$1264$i$i = $725 ; $$1266$i$i = $724 ; } } HEAP32 [ $$1266$i$i >> 2 ] = 0 ; $$3$i$i = $$1264$i$i ; } else { $711 = ( ( ( $668 ) ) + 8 | 0 ) ; $712 = HEAP32 [ $711 >> 2 ] | 0 ; $713 = ( ( ( $712 ) ) + 12 | 0 ) ; HEAP32 [ $713 >> 2 ] = $709 ; $714 = ( ( ( $709 ) ) + 8 | 0 ) ; HEAP32 [ $714 >> 2 ] = $712 ; $$3$i$i = $709 ; } } while ( 0 ) ; $727 = ( $707 | 0 ) == ( 0 | 0 ) ; if ( $727 ) { break ; } $728 = ( ( ( $668 ) ) + 28 | 0 ) ; $729 = HEAP32 [ $728 >> 2 ] | 0 ; $730 = ( 67244 + ( $729 << 2 ) | 0 ) ; $731 = HEAP32 [ $730 >> 2 ] | 0 ; $732 = ( $731 | 0 ) == ( $668 | 0 ) ; do { if ( $732 ) { HEAP32 [ $730 >> 2 ] = $$3$i$i ; $cond$i$i = ( $$3$i$i | 0 ) == ( 0 | 0 ) ; if ( ! ( $cond$i$i ) ) { break ; } $733 = 1 << $729 ; $734 = $733 ^ - 1 ; $735 = HEAP32 [ ( 66944 ) >> 2 ] | 0 ; $736 = $735 & $734 ; HEAP32 [ ( 66944 ) >> 2 ] = $736 ; break L234 ; } else { $737 = ( ( ( $707 ) ) + 16 | 0 ) ; $738 = HEAP32 [ $737 >> 2 ] | 0 ; $739 = ( $738 | 0 ) != ( $668 | 0 ) ; $$sink1$i$i = $739 & 1 ; $740 = ( ( ( ( $707 ) ) + 16 | 0 ) + ( $$sink1$i$i << 2 ) | 0 ) ; HEAP32 [ $740 >> 2 ] = $$3$i$i ; $741 = ( $$3$i$i | 0 ) == ( 0 | 0 ) ; if ( $741 ) { break L234 ; } } } while ( 0 ) ; $742 = ( ( ( $$3$i$i ) ) + 24 | 0 ) ; HEAP32 [ $742 >> 2 ] = $707 ; $743 = ( ( ( $668 ) ) + 16 | 0 ) ; $744 = HEAP32 [ $743 >> 2 ] | 0 ; $745 = ( $744 | 0 ) == ( 0 | 0 ) ; if ( ! ( $745 ) ) { $746 = ( ( ( $$3$i$i ) ) + 16 | 0 ) ; HEAP32 [ $746 >> 2 ] = $744 ; $747 = ( ( ( $744 ) ) + 24 | 0 ) ; HEAP32 [ $747 >> 2 ] = $$3$i$i ; } $748 = ( ( ( $743 ) ) + 4 | 0 ) ; $749 = HEAP32 [ $748 >> 2 ] | 0 ; $750 = ( $749 | 0 ) == ( 0 | 0 ) ; if ( $750 ) { break ; } $751 = ( ( ( $$3$i$i ) ) + 20 | 0 ) ; HEAP32 [ $751 >> 2 ] = $749 ; $752 = ( ( ( $749 ) ) + 24 | 0 ) ; HEAP32 [ $752 >> 2 ] = $$3$i$i ; } } while ( 0 ) ; $753 = ( ( $668 ) + ( $692 ) | 0 ) ; $754 = ( ( $692 ) + ( $673 ) ) | 0 ; $$0$i$i = $753 ; $$0260$i$i = $754 ; } else { $$0$i$i = $668 ; $$0260$i$i = $673 ; } $755 = ( ( ( $$0$i$i ) ) + 4 | 0 ) ; $756 = HEAP32 [ $755 >> 2 ] | 0 ; $757 = $756 & - 2 ; HEAP32 [ $755 >> 2 ] = $757 ; $758 = $$0260$i$i | 1 ; $759 = ( ( ( $672 ) ) + 4 | 0 ) ; HEAP32 [ $759 >> 2 ] = $758 ; $760 = ( ( $672 ) + ( $$0260$i$i ) | 0 ) ; HEAP32 [ $760 >> 2 ] = $$0260$i$i ; $761 = $$0260$i$i >>> 3 ; $762 = ( $$0260$i$i >>> 0 ) < ( 256 ) ; if ( $762 ) { $763 = $761 << 1 ; $764 = ( 66980 + ( $763 << 2 ) | 0 ) ; $765 = HEAP32 [ 16735 ] | 0 ; $766 = 1 << $761 ; $767 = $765 & $766 ; $768 = ( $767 | 0 ) == ( 0 ) ; if ( $768 ) { $769 = $765 | $766 ; HEAP32 [ 16735 ] = $769 ; $$pre$i17$i = ( ( ( $764 ) ) + 8 | 0 ) ; $$0268$i$i = $764 ; $$pre$phi$i18$iZ2D = $$pre$i17$i ; } else { $770 = ( ( ( $764 ) ) + 8 | 0 ) ; $771 = HEAP32 [ $770 >> 2 ] | 0 ; $$0268$i$i = $771 ; $$pre$phi$i18$iZ2D = $770 ; } HEAP32 [ $$pre$phi$i18$iZ2D >> 2 ] = $672 ; $772 = ( ( ( $$0268$i$i ) ) + 12 | 0 ) ; HEAP32 [ $772 >> 2 ] = $672 ; $773 = ( ( ( $672 ) ) + 8 | 0 ) ; HEAP32 [ $773 >> 2 ] = $$0268$i$i ; $774 = ( ( ( $672 ) ) + 12 | 0 ) ; HEAP32 [ $774 >> 2 ] = $764 ; break ; } $775 = $$0260$i$i >>> 8 ; $776 = ( $775 | 0 ) == ( 0 ) ; do { if ( $776 ) { $$0269$i$i = 0 ; } else { $777 = ( $$0260$i$i >>> 0 ) > ( 16777215 ) ; if ( $777 ) { $$0269$i$i = 31 ; break ; } $778 = ( ( $775 ) + 1048320 ) | 0 ; $779 = $778 >>> 16 ; $780 = $779 & 8 ; $781 = $775 << $780 ; $782 = ( ( $781 ) + 520192 ) | 0 ; $783 = $782 >>> 16 ; $784 = $783 & 4 ; $785 = $784 | $780 ; $786 = $781 << $784 ; $787 = ( ( $786 ) + 245760 ) | 0 ; $788 = $787 >>> 16 ; $789 = $788 & 2 ; $790 = $785 | $789 ; $791 = ( 14 - ( $790 ) ) | 0 ; $792 = $786 << $789 ; $793 = $792 >>> 15 ; $794 = ( ( $791 ) + ( $793 ) ) | 0 ; $795 = $794 << 1 ; $796 = ( ( $794 ) + 7 ) | 0 ; $797 = $$0260$i$i >>> $796 ; $798 = $797 & 1 ; $799 = $798 | $795 ; $$0269$i$i = $799 ; } } while ( 0 ) ; $800 = ( 67244 + ( $$0269$i$i << 2 ) | 0 ) ; $801 = ( ( ( $672 ) ) + 28 | 0 ) ; HEAP32 [ $801 >> 2 ] = $$0269$i$i ; $802 = ( ( ( $672 ) ) + 16 | 0 ) ; $803 = ( ( ( $802 ) ) + 4 | 0 ) ; HEAP32 [ $803 >> 2 ] = 0 ; HEAP32 [ $802 >> 2 ] = 0 ; $804 = HEAP32 [ ( 66944 ) >> 2 ] | 0 ; $805 = 1 << $$0269$i$i ; $806 = $804 & $805 ; $807 = ( $806 | 0 ) == ( 0 ) ; if ( $807 ) { $808 = $804 | $805 ; HEAP32 [ ( 66944 ) >> 2 ] = $808 ; HEAP32 [ $800 >> 2 ] = $672 ; $809 = ( ( ( $672 ) ) + 24 | 0 ) ; HEAP32 [ $809 >> 2 ] = $800 ; $810 = ( ( ( $672 ) ) + 12 | 0 ) ; HEAP32 [ $810 >> 2 ] = $672 ; $811 = ( ( ( $672 ) ) + 8 | 0 ) ; HEAP32 [ $811 >> 2 ] = $672 ; break ; } $812 = HEAP32 [ $800 >> 2 ] | 0 ; $813 = ( $$0269$i$i | 0 ) == ( 31 ) ; $814 = $$0269$i$i >>> 1 ; $815 = ( 25 - ( $814 ) ) | 0 ; $816 = $813 ? 0 : $815 ; $817 = $$0260$i$i << $816 ; $$0261$i$i = $817 ; $$0262$i$i = $812 ; while ( 1 ) { $818 = ( ( ( $$0262$i$i ) ) + 4 | 0 ) ; $819 = HEAP32 [ $818 >> 2 ] | 0 ; $820 = $819 & - 8 ; $821 = ( $820 | 0 ) == ( $$0260$i$i | 0 ) ; if ( $821 ) { label = 192 ; break ; } $822 = $$0261$i$i >>> 31 ; $823 = ( ( ( ( $$0262$i$i ) ) + 16 | 0 ) + ( $822 << 2 ) | 0 ) ; $824 = $$0261$i$i << 1 ; $825 = HEAP32 [ $823 >> 2 ] | 0 ; $826 = ( $825 | 0 ) == ( 0 | 0 ) ; if ( $826 ) { label = 191 ; break ; } else { $$0261$i$i = $824 ; $$0262$i$i = $825 ; } } if ( ( label | 0 ) == 191 ) { HEAP32 [ $823 >> 2 ] = $672 ; $827 = ( ( ( $672 ) ) + 24 | 0 ) ; HEAP32 [ $827 >> 2 ] = $$0262$i$i ; $828 = ( ( ( $672 ) ) + 12 | 0 ) ; HEAP32 [ $828 >> 2 ] = $672 ; $829 = ( ( ( $672 ) ) + 8 | 0 ) ; HEAP32 [ $829 >> 2 ] = $672 ; break ; } else if ( ( label | 0 ) == 192 ) { $830 = ( ( ( $$0262$i$i ) ) + 8 | 0 ) ; $831 = HEAP32 [ $830 >> 2 ] | 0 ; $832 = ( ( ( $831 ) ) + 12 | 0 ) ; HEAP32 [ $832 >> 2 ] = $672 ; HEAP32 [ $830 >> 2 ] = $672 ; $833 = ( ( ( $672 ) ) + 8 | 0 ) ; HEAP32 [ $833 >> 2 ] = $831 ; $834 = ( ( ( $672 ) ) + 12 | 0 ) ; HEAP32 [ $834 >> 2 ] = $$0262$i$i ; $835 = ( ( ( $672 ) ) + 24 | 0 ) ; HEAP32 [ $835 >> 2 ] = 0 ; break ; } } } while ( 0 ) ; $960 = ( ( ( $660 ) ) + 8 | 0 ) ; $$0 = $960 ; STACKTOP = sp ; return ( $$0 | 0 ) ; } else { $$0$i$i$i = ( 67388 ) ; } } while ( 1 ) { $836 = HEAP32 [ $$0$i$i$i >> 2 ] | 0 ; $837 = ( $836 >>> 0 ) > ( $586 >>> 0 ) ; if ( ! ( $837 ) ) { $838 = ( ( ( $$0$i$i$i ) ) + 4 | 0 ) ; $839 = HEAP32 [ $838 >> 2 ] | 0 ; $840 = ( ( $836 ) + ( $839 ) | 0 ) ; $841 = ( $840 >>> 0 ) > ( $586 >>> 0 ) ; if ( $841 ) { break ; } } $842 = ( ( ( $$0$i$i$i ) ) + 8 | 0 ) ; $843 = HEAP32 [ $842 >> 2 ] | 0 ; $$0$i$i$i = $843 ; } $844 = ( ( ( $840 ) ) + - 47 | 0 ) ; $845 = ( ( ( $844 ) ) + 8 | 0 ) ; $846 = $845 ; $847 = $846 & 7 ; $848 = ( $847 | 0 ) == ( 0 ) ; $849 = ( 0 - ( $846 ) ) | 0 ; $850 = $849 & 7 ; $851 = $848 ? 0 : $850 ; $852 = ( ( $844 ) + ( $851 ) | 0 ) ; $853 = ( ( ( $586 ) ) + 16 | 0 ) ; $854 = ( $852 >>> 0 ) < ( $853 >>> 0 ) ; $855 = $854 ? $586 : $852 ; $856 = ( ( ( $855 ) ) + 8 | 0 ) ; $857 = ( ( ( $855 ) ) + 24 | 0 ) ; $858 = ( ( $$723947$i ) + - 40 ) | 0 ; $859 = ( ( ( $$748$i ) ) + 8 | 0 ) ; $860 = $859 ; $861 = $860 & 7 ; $862 = ( $861 | 0 ) == ( 0 ) ; $863 = ( 0 - ( $860 ) ) | 0 ; $864 = $863 & 7 ; $865 = $862 ? 0 : $864 ; $866 = ( ( $$748$i ) + ( $865 ) | 0 ) ; $867 = ( ( $858 ) - ( $865 ) ) | 0 ; HEAP32 [ ( 66964 ) >> 2 ] = $866 ; HEAP32 [ ( 66952 ) >> 2 ] = $867 ; $868 = $867 | 1 ; $869 = ( ( ( $866 ) ) + 4 | 0 ) ; HEAP32 [ $869 >> 2 ] = $868 ; $870 = ( ( $$748$i ) + ( $858 ) | 0 ) ; $871 = ( ( ( $870 ) ) + 4 | 0 ) ; HEAP32 [ $871 >> 2 ] = 40 ; $872 = HEAP32 [ ( 67428 ) >> 2 ] | 0 ; HEAP32 [ ( 66968 ) >> 2 ] = $872 ; $873 = ( ( ( $855 ) ) + 4 | 0 ) ; HEAP32 [ $873 >> 2 ] = 27 ; ; HEAP32 [ $856 >> 2 ] = HEAP32 [ ( 67388 ) >> 2 ] | 0 ; HEAP32 [ $856 + 4 >> 2 ] = HEAP32 [ ( 67388 ) + 4 >> 2 ] | 0 ; HEAP32 [ $856 + 8 >> 2 ] = HEAP32 [ ( 67388 ) + 8 >> 2 ] | 0 ; HEAP32 [ $856 + 12 >> 2 ] = HEAP32 [ ( 67388 ) + 12 >> 2 ] | 0 ; HEAP32 [ ( 67388 ) >> 2 ] = $$748$i ; HEAP32 [ ( 67392 ) >> 2 ] = $$723947$i ; HEAP32 [ ( 67400 ) >> 2 ] = 0 ; HEAP32 [ ( 67396 ) >> 2 ] = $856 ; $875 = $857 ; while ( 1 ) { $874 = ( ( ( $875 ) ) + 4 | 0 ) ; HEAP32 [ $874 >> 2 ] = 7 ; $876 = ( ( ( $875 ) ) + 8 | 0 ) ; $877 = ( $876 >>> 0 ) < ( $840 >>> 0 ) ; if ( $877 ) { $875 = $874 ; } else { break ; } } $878 = ( $855 | 0 ) == ( $586 | 0 ) ; if ( ! ( $878 ) ) { $879 = $855 ; $880 = $586 ; $881 = ( ( $879 ) - ( $880 ) ) | 0 ; $882 = HEAP32 [ $873 >> 2 ] | 0 ; $883 = $882 & - 2 ; HEAP32 [ $873 >> 2 ] = $883 ; $884 = $881 | 1 ; $885 = ( ( ( $586 ) ) + 4 | 0 ) ; HEAP32 [ $885 >> 2 ] = $884 ; HEAP32 [ $855 >> 2 ] = $881 ; $886 = $881 >>> 3 ; $887 = ( $881 >>> 0 ) < ( 256 ) ; if ( $887 ) { $888 = $886 << 1 ; $889 = ( 66980 + ( $888 << 2 ) | 0 ) ; $890 = HEAP32 [ 16735 ] | 0 ; $891 = 1 << $886 ; $892 = $890 & $891 ; $893 = ( $892 | 0 ) == ( 0 ) ; if ( $893 ) { $894 = $890 | $891 ; HEAP32 [ 16735 ] = $894 ; $$pre$i$i = ( ( ( $889 ) ) + 8 | 0 ) ; $$0206$i$i = $889 ; $$pre$phi$i$iZ2D = $$pre$i$i ; } else { $895 = ( ( ( $889 ) ) + 8 | 0 ) ; $896 = HEAP32 [ $895 >> 2 ] | 0 ; $$0206$i$i = $896 ; $$pre$phi$i$iZ2D = $895 ; } HEAP32 [ $$pre$phi$i$iZ2D >> 2 ] = $586 ; $897 = ( ( ( $$0206$i$i ) ) + 12 | 0 ) ; HEAP32 [ $897 >> 2 ] = $586 ; $898 = ( ( ( $586 ) ) + 8 | 0 ) ; HEAP32 [ $898 >> 2 ] = $$0206$i$i ; $899 = ( ( ( $586 ) ) + 12 | 0 ) ; HEAP32 [ $899 >> 2 ] = $889 ; break ; } $900 = $881 >>> 8 ; $901 = ( $900 | 0 ) == ( 0 ) ; if ( $901 ) { $$0207$i$i = 0 ; } else { $902 = ( $881 >>> 0 ) > ( 16777215 ) ; if ( $902 ) { $$0207$i$i = 31 ; } else { $903 = ( ( $900 ) + 1048320 ) | 0 ; $904 = $903 >>> 16 ; $905 = $904 & 8 ; $906 = $900 << $905 ; $907 = ( ( $906 ) + 520192 ) | 0 ; $908 = $907 >>> 16 ; $909 = $908 & 4 ; $910 = $909 | $905 ; $911 = $906 << $909 ; $912 = ( ( $911 ) + 245760 ) | 0 ; $913 = $912 >>> 16 ; $914 = $913 & 2 ; $915 = $910 | $914 ; $916 = ( 14 - ( $915 ) ) | 0 ; $917 = $911 << $914 ; $918 = $917 >>> 15 ; $919 = ( ( $916 ) + ( $918 ) ) | 0 ; $920 = $919 << 1 ; $921 = ( ( $919 ) + 7 ) | 0 ; $922 = $881 >>> $921 ; $923 = $922 & 1 ; $924 = $923 | $920 ; $$0207$i$i = $924 ; } } $925 = ( 67244 + ( $$0207$i$i << 2 ) | 0 ) ; $926 = ( ( ( $586 ) ) + 28 | 0 ) ; HEAP32 [ $926 >> 2 ] = $$0207$i$i ; $927 = ( ( ( $586 ) ) + 20 | 0 ) ; HEAP32 [ $927 >> 2 ] = 0 ; HEAP32 [ $853 >> 2 ] = 0 ; $928 = HEAP32 [ ( 66944 ) >> 2 ] | 0 ; $929 = 1 << $$0207$i$i ; $930 = $928 & $929 ; $931 = ( $930 | 0 ) == ( 0 ) ; if ( $931 ) { $932 = $928 | $929 ; HEAP32 [ ( 66944 ) >> 2 ] = $932 ; HEAP32 [ $925 >> 2 ] = $586 ; $933 = ( ( ( $586 ) ) + 24 | 0 ) ; HEAP32 [ $933 >> 2 ] = $925 ; $934 = ( ( ( $586 ) ) + 12 | 0 ) ; HEAP32 [ $934 >> 2 ] = $586 ; $935 = ( ( ( $586 ) ) + 8 | 0 ) ; HEAP32 [ $935 >> 2 ] = $586 ; break ; } $936 = HEAP32 [ $925 >> 2 ] | 0 ; $937 = ( $$0207$i$i | 0 ) == ( 31 ) ; $938 = $$0207$i$i >>> 1 ; $939 = ( 25 - ( $938 ) ) | 0 ; $940 = $937 ? 0 : $939 ; $941 = $881 << $940 ; $$0201$i$i = $941 ; $$0202$i$i = $936 ; while ( 1 ) { $942 = ( ( ( $$0202$i$i ) ) + 4 | 0 ) ; $943 = HEAP32 [ $942 >> 2 ] | 0 ; $944 = $943 & - 8 ; $945 = ( $944 | 0 ) == ( $881 | 0 ) ; if ( $945 ) { label = 213 ; break ; } $946 = $$0201$i$i >>> 31 ; $947 = ( ( ( ( $$0202$i$i ) ) + 16 | 0 ) + ( $946 << 2 ) | 0 ) ; $948 = $$0201$i$i << 1 ; $949 = HEAP32 [ $947 >> 2 ] | 0 ; $950 = ( $949 | 0 ) == ( 0 | 0 ) ; if ( $950 ) { label = 212 ; break ; } else { $$0201$i$i = $948 ; $$0202$i$i = $949 ; } } if ( ( label | 0 ) == 212 ) { HEAP32 [ $947 >> 2 ] = $586 ; $951 = ( ( ( $586 ) ) + 24 | 0 ) ; HEAP32 [ $951 >> 2 ] = $$0202$i$i ; $952 = ( ( ( $586 ) ) + 12 | 0 ) ; HEAP32 [ $952 >> 2 ] = $586 ; $953 = ( ( ( $586 ) ) + 8 | 0 ) ; HEAP32 [ $953 >> 2 ] = $586 ; break ; } else if ( ( label | 0 ) == 213 ) { $954 = ( ( ( $$0202$i$i ) ) + 8 | 0 ) ; $955 = HEAP32 [ $954 >> 2 ] | 0 ; $956 = ( ( ( $955 ) ) + 12 | 0 ) ; HEAP32 [ $956 >> 2 ] = $586 ; HEAP32 [ $954 >> 2 ] = $586 ; $957 = ( ( ( $586 ) ) + 8 | 0 ) ; HEAP32 [ $957 >> 2 ] = $955 ; $958 = ( ( ( $586 ) ) + 12 | 0 ) ; HEAP32 [ $958 >> 2 ] = $$0202$i$i ; $959 = ( ( ( $586 ) ) + 24 | 0 ) ; HEAP32 [ $959 >> 2 ] = 0 ; break ; } } } } while ( 0 ) ; $961 = HEAP32 [ ( 66952 ) >> 2 ] | 0 ; $962 = ( $961 >>> 0 ) > ( $$0192 >>> 0 ) ; if ( $962 ) { $963 = ( ( $961 ) - ( $$0192 ) ) | 0 ; HEAP32 [ ( 66952 ) >> 2 ] = $963 ; $964 = HEAP32 [ ( 66964 ) >> 2 ] | 0 ; $965 = ( ( $964 ) + ( $$0192 ) | 0 ) ; HEAP32 [ ( 66964 ) >> 2 ] = $965 ; $966 = $963 | 1 ; $967 = ( ( ( $965 ) ) + 4 | 0 ) ; HEAP32 [ $967 >> 2 ] = $966 ; $968 = $$0192 | 3 ; $969 = ( ( ( $964 ) ) + 4 | 0 ) ; HEAP32 [ $969 >> 2 ] = $968 ; $970 = ( ( ( $964 ) ) + 8 | 0 ) ; $$0 = $970 ; STACKTOP = sp ; return ( $$0 | 0 ) ; } } $971 = ( ___errno_location ( ) | 0 ) ; HEAP32 [ $971 >> 2 ] = 12 ; $$0 = 0 ; STACKTOP = sp ; return ( $$0 | 0 ) ; } function _free ( $0 ) { $0 = $0 | 0 ; var $$0195$i = 0 , $$0195$in$i = 0 , $$0348 = 0 , $$0349 = 0 , $$0361 = 0 , $$0368 = 0 , $$1 = 0 , $$1347 = 0 , $$1352 = 0 , $$1355 = 0 , $$1363 = 0 , $$1367 = 0 , $$2 = 0 , $$3 = 0 , $$3365 = 0 , $$pre = 0 , $$pre$phiZ2D = 0 , $$sink3 = 0 , $$sink5 = 0 , $1 = 0 ; var $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 ; var $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 ; var $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 ; var $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 ; var $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 ; var $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $2 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 ; var $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 ; var $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 ; var $244 = 0 , $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 , $258 = 0 , $259 = 0 , $26 = 0 , $260 = 0 , $27 = 0 ; var $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 ; var $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 ; var $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 ; var $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $cond373 = 0 ; var $cond374 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $1 ) { return ; } $2 = ( ( ( $0 ) ) + - 8 | 0 ) ; $3 = HEAP32 [ ( 66956 ) >> 2 ] | 0 ; $4 = ( ( ( $0 ) ) + - 4 | 0 ) ; $5 = HEAP32 [ $4 >> 2 ] | 0 ; $6 = $5 & - 8 ; $7 = ( ( $2 ) + ( $6 ) | 0 ) ; $8 = $5 & 1 ; $9 = ( $8 | 0 ) == ( 0 ) ; do { if ( $9 ) { $10 = HEAP32 [ $2 >> 2 ] | 0 ; $11 = $5 & 3 ; $12 = ( $11 | 0 ) == ( 0 ) ; if ( $12 ) { return ; } $13 = ( 0 - ( $10 ) ) | 0 ; $14 = ( ( $2 ) + ( $13 ) | 0 ) ; $15 = ( ( $10 ) + ( $6 ) ) | 0 ; $16 = ( $14 >>> 0 ) < ( $3 >>> 0 ) ; if ( $16 ) { return ; } $17 = HEAP32 [ ( 66960 ) >> 2 ] | 0 ; $18 = ( $17 | 0 ) == ( $14 | 0 ) ; if ( $18 ) { $79 = ( ( ( $7 ) ) + 4 | 0 ) ; $80 = HEAP32 [ $79 >> 2 ] | 0 ; $81 = $80 & 3 ; $82 = ( $81 | 0 ) == ( 3 ) ; if ( ! ( $82 ) ) { $$1 = $14 ; $$1347 = $15 ; $87 = $14 ; break ; } HEAP32 [ ( 66948 ) >> 2 ] = $15 ; $83 = $80 & - 2 ; HEAP32 [ $79 >> 2 ] = $83 ; $84 = $15 | 1 ; $85 = ( ( ( $14 ) ) + 4 | 0 ) ; HEAP32 [ $85 >> 2 ] = $84 ; $86 = ( ( $14 ) + ( $15 ) | 0 ) ; HEAP32 [ $86 >> 2 ] = $15 ; return ; } $19 = $10 >>> 3 ; $20 = ( $10 >>> 0 ) < ( 256 ) ; if ( $20 ) { $21 = ( ( ( $14 ) ) + 8 | 0 ) ; $22 = HEAP32 [ $21 >> 2 ] | 0 ; $23 = ( ( ( $14 ) ) + 12 | 0 ) ; $24 = HEAP32 [ $23 >> 2 ] | 0 ; $25 = ( $24 | 0 ) == ( $22 | 0 ) ; if ( $25 ) { $26 = 1 << $19 ; $27 = $26 ^ - 1 ; $28 = HEAP32 [ 16735 ] | 0 ; $29 = $28 & $27 ; HEAP32 [ 16735 ] = $29 ; $$1 = $14 ; $$1347 = $15 ; $87 = $14 ; break ; } else { $30 = ( ( ( $22 ) ) + 12 | 0 ) ; HEAP32 [ $30 >> 2 ] = $24 ; $31 = ( ( ( $24 ) ) + 8 | 0 ) ; HEAP32 [ $31 >> 2 ] = $22 ; $$1 = $14 ; $$1347 = $15 ; $87 = $14 ; break ; } } $32 = ( ( ( $14 ) ) + 24 | 0 ) ; $33 = HEAP32 [ $32 >> 2 ] | 0 ; $34 = ( ( ( $14 ) ) + 12 | 0 ) ; $35 = HEAP32 [ $34 >> 2 ] | 0 ; $36 = ( $35 | 0 ) == ( $14 | 0 ) ; do { if ( $36 ) { $41 = ( ( ( $14 ) ) + 16 | 0 ) ; $42 = ( ( ( $41 ) ) + 4 | 0 ) ; $43 = HEAP32 [ $42 >> 2 ] | 0 ; $44 = ( $43 | 0 ) == ( 0 | 0 ) ; if ( $44 ) { $45 = HEAP32 [ $41 >> 2 ] | 0 ; $46 = ( $45 | 0 ) == ( 0 | 0 ) ; if ( $46 ) { $$3 = 0 ; break ; } else { $$1352 = $45 ; $$1355 = $41 ; } } else { $$1352 = $43 ; $$1355 = $42 ; } while ( 1 ) { $47 = ( ( ( $$1352 ) ) + 20 | 0 ) ; $48 = HEAP32 [ $47 >> 2 ] | 0 ; $49 = ( $48 | 0 ) == ( 0 | 0 ) ; if ( ! ( $49 ) ) { $$1352 = $48 ; $$1355 = $47 ; continue ; } $50 = ( ( ( $$1352 ) ) + 16 | 0 ) ; $51 = HEAP32 [ $50 >> 2 ] | 0 ; $52 = ( $51 | 0 ) == ( 0 | 0 ) ; if ( $52 ) { break ; } else { $$1352 = $51 ; $$1355 = $50 ; } } HEAP32 [ $$1355 >> 2 ] = 0 ; $$3 = $$1352 ; } else { $37 = ( ( ( $14 ) ) + 8 | 0 ) ; $38 = HEAP32 [ $37 >> 2 ] | 0 ; $39 = ( ( ( $38 ) ) + 12 | 0 ) ; HEAP32 [ $39 >> 2 ] = $35 ; $40 = ( ( ( $35 ) ) + 8 | 0 ) ; HEAP32 [ $40 >> 2 ] = $38 ; $$3 = $35 ; } } while ( 0 ) ; $53 = ( $33 | 0 ) == ( 0 | 0 ) ; if ( $53 ) { $$1 = $14 ; $$1347 = $15 ; $87 = $14 ; } else { $54 = ( ( ( $14 ) ) + 28 | 0 ) ; $55 = HEAP32 [ $54 >> 2 ] | 0 ; $56 = ( 67244 + ( $55 << 2 ) | 0 ) ; $57 = HEAP32 [ $56 >> 2 ] | 0 ; $58 = ( $57 | 0 ) == ( $14 | 0 ) ; if ( $58 ) { HEAP32 [ $56 >> 2 ] = $$3 ; $cond373 = ( $$3 | 0 ) == ( 0 | 0 ) ; if ( $cond373 ) { $59 = 1 << $55 ; $60 = $59 ^ - 1 ; $61 = HEAP32 [ ( 66944 ) >> 2 ] | 0 ; $62 = $61 & $60 ; HEAP32 [ ( 66944 ) >> 2 ] = $62 ; $$1 = $14 ; $$1347 = $15 ; $87 = $14 ; break ; } } else { $63 = ( ( ( $33 ) ) + 16 | 0 ) ; $64 = HEAP32 [ $63 >> 2 ] | 0 ; $65 = ( $64 | 0 ) != ( $14 | 0 ) ; $$sink3 = $65 & 1 ; $66 = ( ( ( ( $33 ) ) + 16 | 0 ) + ( $$sink3 << 2 ) | 0 ) ; HEAP32 [ $66 >> 2 ] = $$3 ; $67 = ( $$3 | 0 ) == ( 0 | 0 ) ; if ( $67 ) { $$1 = $14 ; $$1347 = $15 ; $87 = $14 ; break ; } } $68 = ( ( ( $$3 ) ) + 24 | 0 ) ; HEAP32 [ $68 >> 2 ] = $33 ; $69 = ( ( ( $14 ) ) + 16 | 0 ) ; $70 = HEAP32 [ $69 >> 2 ] | 0 ; $71 = ( $70 | 0 ) == ( 0 | 0 ) ; if ( ! ( $71 ) ) { $72 = ( ( ( $$3 ) ) + 16 | 0 ) ; HEAP32 [ $72 >> 2 ] = $70 ; $73 = ( ( ( $70 ) ) + 24 | 0 ) ; HEAP32 [ $73 >> 2 ] = $$3 ; } $74 = ( ( ( $69 ) ) + 4 | 0 ) ; $75 = HEAP32 [ $74 >> 2 ] | 0 ; $76 = ( $75 | 0 ) == ( 0 | 0 ) ; if ( $76 ) { $$1 = $14 ; $$1347 = $15 ; $87 = $14 ; } else { $77 = ( ( ( $$3 ) ) + 20 | 0 ) ; HEAP32 [ $77 >> 2 ] = $75 ; $78 = ( ( ( $75 ) ) + 24 | 0 ) ; HEAP32 [ $78 >> 2 ] = $$3 ; $$1 = $14 ; $$1347 = $15 ; $87 = $14 ; } } } else { $$1 = $2 ; $$1347 = $6 ; $87 = $2 ; } } while ( 0 ) ; $88 = ( $87 >>> 0 ) < ( $7 >>> 0 ) ; if ( ! ( $88 ) ) { return ; } $89 = ( ( ( $7 ) ) + 4 | 0 ) ; $90 = HEAP32 [ $89 >> 2 ] | 0 ; $91 = $90 & 1 ; $92 = ( $91 | 0 ) == ( 0 ) ; if ( $92 ) { return ; } $93 = $90 & 2 ; $94 = ( $93 | 0 ) == ( 0 ) ; if ( $94 ) { $95 = HEAP32 [ ( 66964 ) >> 2 ] | 0 ; $96 = ( $95 | 0 ) == ( $7 | 0 ) ; if ( $96 ) { $97 = HEAP32 [ ( 66952 ) >> 2 ] | 0 ; $98 = ( ( $97 ) + ( $$1347 ) ) | 0 ; HEAP32 [ ( 66952 ) >> 2 ] = $98 ; HEAP32 [ ( 66964 ) >> 2 ] = $$1 ; $99 = $98 | 1 ; $100 = ( ( ( $$1 ) ) + 4 | 0 ) ; HEAP32 [ $100 >> 2 ] = $99 ; $101 = HEAP32 [ ( 66960 ) >> 2 ] | 0 ; $102 = ( $$1 | 0 ) == ( $101 | 0 ) ; if ( ! ( $102 ) ) { return ; } HEAP32 [ ( 66960 ) >> 2 ] = 0 ; HEAP32 [ ( 66948 ) >> 2 ] = 0 ; return ; } $103 = HEAP32 [ ( 66960 ) >> 2 ] | 0 ; $104 = ( $103 | 0 ) == ( $7 | 0 ) ; if ( $104 ) { $105 = HEAP32 [ ( 66948 ) >> 2 ] | 0 ; $106 = ( ( $105 ) + ( $$1347 ) ) | 0 ; HEAP32 [ ( 66948 ) >> 2 ] = $106 ; HEAP32 [ ( 66960 ) >> 2 ] = $87 ; $107 = $106 | 1 ; $108 = ( ( ( $$1 ) ) + 4 | 0 ) ; HEAP32 [ $108 >> 2 ] = $107 ; $109 = ( ( $87 ) + ( $106 ) | 0 ) ; HEAP32 [ $109 >> 2 ] = $106 ; return ; } $110 = $90 & - 8 ; $111 = ( ( $110 ) + ( $$1347 ) ) | 0 ; $112 = $90 >>> 3 ; $113 = ( $90 >>> 0 ) < ( 256 ) ; do { if ( $113 ) { $114 = ( ( ( $7 ) ) + 8 | 0 ) ; $115 = HEAP32 [ $114 >> 2 ] | 0 ; $116 = ( ( ( $7 ) ) + 12 | 0 ) ; $117 = HEAP32 [ $116 >> 2 ] | 0 ; $118 = ( $117 | 0 ) == ( $115 | 0 ) ; if ( $118 ) { $119 = 1 << $112 ; $120 = $119 ^ - 1 ; $121 = HEAP32 [ 16735 ] | 0 ; $122 = $121 & $120 ; HEAP32 [ 16735 ] = $122 ; break ; } else { $123 = ( ( ( $115 ) ) + 12 | 0 ) ; HEAP32 [ $123 >> 2 ] = $117 ; $124 = ( ( ( $117 ) ) + 8 | 0 ) ; HEAP32 [ $124 >> 2 ] = $115 ; break ; } } else { $125 = ( ( ( $7 ) ) + 24 | 0 ) ; $126 = HEAP32 [ $125 >> 2 ] | 0 ; $127 = ( ( ( $7 ) ) + 12 | 0 ) ; $128 = HEAP32 [ $127 >> 2 ] | 0 ; $129 = ( $128 | 0 ) == ( $7 | 0 ) ; do { if ( $129 ) { $134 = ( ( ( $7 ) ) + 16 | 0 ) ; $135 = ( ( ( $134 ) ) + 4 | 0 ) ; $136 = HEAP32 [ $135 >> 2 ] | 0 ; $137 = ( $136 | 0 ) == ( 0 | 0 ) ; if ( $137 ) { $138 = HEAP32 [ $134 >> 2 ] | 0 ; $139 = ( $138 | 0 ) == ( 0 | 0 ) ; if ( $139 ) { $$3365 = 0 ; break ; } else { $$1363 = $138 ; $$1367 = $134 ; } } else { $$1363 = $136 ; $$1367 = $135 ; } while ( 1 ) { $140 = ( ( ( $$1363 ) ) + 20 | 0 ) ; $141 = HEAP32 [ $140 >> 2 ] | 0 ; $142 = ( $141 | 0 ) == ( 0 | 0 ) ; if ( ! ( $142 ) ) { $$1363 = $141 ; $$1367 = $140 ; continue ; } $143 = ( ( ( $$1363 ) ) + 16 | 0 ) ; $144 = HEAP32 [ $143 >> 2 ] | 0 ; $145 = ( $144 | 0 ) == ( 0 | 0 ) ; if ( $145 ) { break ; } else { $$1363 = $144 ; $$1367 = $143 ; } } HEAP32 [ $$1367 >> 2 ] = 0 ; $$3365 = $$1363 ; } else { $130 = ( ( ( $7 ) ) + 8 | 0 ) ; $131 = HEAP32 [ $130 >> 2 ] | 0 ; $132 = ( ( ( $131 ) ) + 12 | 0 ) ; HEAP32 [ $132 >> 2 ] = $128 ; $133 = ( ( ( $128 ) ) + 8 | 0 ) ; HEAP32 [ $133 >> 2 ] = $131 ; $$3365 = $128 ; } } while ( 0 ) ; $146 = ( $126 | 0 ) == ( 0 | 0 ) ; if ( ! ( $146 ) ) { $147 = ( ( ( $7 ) ) + 28 | 0 ) ; $148 = HEAP32 [ $147 >> 2 ] | 0 ; $149 = ( 67244 + ( $148 << 2 ) | 0 ) ; $150 = HEAP32 [ $149 >> 2 ] | 0 ; $151 = ( $150 | 0 ) == ( $7 | 0 ) ; if ( $151 ) { HEAP32 [ $149 >> 2 ] = $$3365 ; $cond374 = ( $$3365 | 0 ) == ( 0 | 0 ) ; if ( $cond374 ) { $152 = 1 << $148 ; $153 = $152 ^ - 1 ; $154 = HEAP32 [ ( 66944 ) >> 2 ] | 0 ; $155 = $154 & $153 ; HEAP32 [ ( 66944 ) >> 2 ] = $155 ; break ; } } else { $156 = ( ( ( $126 ) ) + 16 | 0 ) ; $157 = HEAP32 [ $156 >> 2 ] | 0 ; $158 = ( $157 | 0 ) != ( $7 | 0 ) ; $$sink5 = $158 & 1 ; $159 = ( ( ( ( $126 ) ) + 16 | 0 ) + ( $$sink5 << 2 ) | 0 ) ; HEAP32 [ $159 >> 2 ] = $$3365 ; $160 = ( $$3365 | 0 ) == ( 0 | 0 ) ; if ( $160 ) { break ; } } $161 = ( ( ( $$3365 ) ) + 24 | 0 ) ; HEAP32 [ $161 >> 2 ] = $126 ; $162 = ( ( ( $7 ) ) + 16 | 0 ) ; $163 = HEAP32 [ $162 >> 2 ] | 0 ; $164 = ( $163 | 0 ) == ( 0 | 0 ) ; if ( ! ( $164 ) ) { $165 = ( ( ( $$3365 ) ) + 16 | 0 ) ; HEAP32 [ $165 >> 2 ] = $163 ; $166 = ( ( ( $163 ) ) + 24 | 0 ) ; HEAP32 [ $166 >> 2 ] = $$3365 ; } $167 = ( ( ( $162 ) ) + 4 | 0 ) ; $168 = HEAP32 [ $167 >> 2 ] | 0 ; $169 = ( $168 | 0 ) == ( 0 | 0 ) ; if ( ! ( $169 ) ) { $170 = ( ( ( $$3365 ) ) + 20 | 0 ) ; HEAP32 [ $170 >> 2 ] = $168 ; $171 = ( ( ( $168 ) ) + 24 | 0 ) ; HEAP32 [ $171 >> 2 ] = $$3365 ; } } } } while ( 0 ) ; $172 = $111 | 1 ; $173 = ( ( ( $$1 ) ) + 4 | 0 ) ; HEAP32 [ $173 >> 2 ] = $172 ; $174 = ( ( $87 ) + ( $111 ) | 0 ) ; HEAP32 [ $174 >> 2 ] = $111 ; $175 = HEAP32 [ ( 66960 ) >> 2 ] | 0 ; $176 = ( $$1 | 0 ) == ( $175 | 0 ) ; if ( $176 ) { HEAP32 [ ( 66948 ) >> 2 ] = $111 ; return ; } else { $$2 = $111 ; } } else { $177 = $90 & - 2 ; HEAP32 [ $89 >> 2 ] = $177 ; $178 = $$1347 | 1 ; $179 = ( ( ( $$1 ) ) + 4 | 0 ) ; HEAP32 [ $179 >> 2 ] = $178 ; $180 = ( ( $87 ) + ( $$1347 ) | 0 ) ; HEAP32 [ $180 >> 2 ] = $$1347 ; $$2 = $$1347 ; } $181 = $$2 >>> 3 ; $182 = ( $$2 >>> 0 ) < ( 256 ) ; if ( $182 ) { $183 = $181 << 1 ; $184 = ( 66980 + ( $183 << 2 ) | 0 ) ; $185 = HEAP32 [ 16735 ] | 0 ; $186 = 1 << $181 ; $187 = $185 & $186 ; $188 = ( $187 | 0 ) == ( 0 ) ; if ( $188 ) { $189 = $185 | $186 ; HEAP32 [ 16735 ] = $189 ; $$pre = ( ( ( $184 ) ) + 8 | 0 ) ; $$0368 = $184 ; $$pre$phiZ2D = $$pre ; } else { $190 = ( ( ( $184 ) ) + 8 | 0 ) ; $191 = HEAP32 [ $190 >> 2 ] | 0 ; $$0368 = $191 ; $$pre$phiZ2D = $190 ; } HEAP32 [ $$pre$phiZ2D >> 2 ] = $$1 ; $192 = ( ( ( $$0368 ) ) + 12 | 0 ) ; HEAP32 [ $192 >> 2 ] = $$1 ; $193 = ( ( ( $$1 ) ) + 8 | 0 ) ; HEAP32 [ $193 >> 2 ] = $$0368 ; $194 = ( ( ( $$1 ) ) + 12 | 0 ) ; HEAP32 [ $194 >> 2 ] = $184 ; return ; } $195 = $$2 >>> 8 ; $196 = ( $195 | 0 ) == ( 0 ) ; if ( $196 ) { $$0361 = 0 ; } else { $197 = ( $$2 >>> 0 ) > ( 16777215 ) ; if ( $197 ) { $$0361 = 31 ; } else { $198 = ( ( $195 ) + 1048320 ) | 0 ; $199 = $198 >>> 16 ; $200 = $199 & 8 ; $201 = $195 << $200 ; $202 = ( ( $201 ) + 520192 ) | 0 ; $203 = $202 >>> 16 ; $204 = $203 & 4 ; $205 = $204 | $200 ; $206 = $201 << $204 ; $207 = ( ( $206 ) + 245760 ) | 0 ; $208 = $207 >>> 16 ; $209 = $208 & 2 ; $210 = $205 | $209 ; $211 = ( 14 - ( $210 ) ) | 0 ; $212 = $206 << $209 ; $213 = $212 >>> 15 ; $214 = ( ( $211 ) + ( $213 ) ) | 0 ; $215 = $214 << 1 ; $216 = ( ( $214 ) + 7 ) | 0 ; $217 = $$2 >>> $216 ; $218 = $217 & 1 ; $219 = $218 | $215 ; $$0361 = $219 ; } } $220 = ( 67244 + ( $$0361 << 2 ) | 0 ) ; $221 = ( ( ( $$1 ) ) + 28 | 0 ) ; HEAP32 [ $221 >> 2 ] = $$0361 ; $222 = ( ( ( $$1 ) ) + 16 | 0 ) ; $223 = ( ( ( $$1 ) ) + 20 | 0 ) ; HEAP32 [ $223 >> 2 ] = 0 ; HEAP32 [ $222 >> 2 ] = 0 ; $224 = HEAP32 [ ( 66944 ) >> 2 ] | 0 ; $225 = 1 << $$0361 ; $226 = $224 & $225 ; $227 = ( $226 | 0 ) == ( 0 ) ; do { if ( $227 ) { $228 = $224 | $225 ; HEAP32 [ ( 66944 ) >> 2 ] = $228 ; HEAP32 [ $220 >> 2 ] = $$1 ; $229 = ( ( ( $$1 ) ) + 24 | 0 ) ; HEAP32 [ $229 >> 2 ] = $220 ; $230 = ( ( ( $$1 ) ) + 12 | 0 ) ; HEAP32 [ $230 >> 2 ] = $$1 ; $231 = ( ( ( $$1 ) ) + 8 | 0 ) ; HEAP32 [ $231 >> 2 ] = $$1 ; } else { $232 = HEAP32 [ $220 >> 2 ] | 0 ; $233 = ( $$0361 | 0 ) == ( 31 ) ; $234 = $$0361 >>> 1 ; $235 = ( 25 - ( $234 ) ) | 0 ; $236 = $233 ? 0 : $235 ; $237 = $$2 << $236 ; $$0348 = $237 ; $$0349 = $232 ; while ( 1 ) { $238 = ( ( ( $$0349 ) ) + 4 | 0 ) ; $239 = HEAP32 [ $238 >> 2 ] | 0 ; $240 = $239 & - 8 ; $241 = ( $240 | 0 ) == ( $$2 | 0 ) ; if ( $241 ) { label = 73 ; break ; } $242 = $$0348 >>> 31 ; $243 = ( ( ( ( $$0349 ) ) + 16 | 0 ) + ( $242 << 2 ) | 0 ) ; $244 = $$0348 << 1 ; $245 = HEAP32 [ $243 >> 2 ] | 0 ; $246 = ( $245 | 0 ) == ( 0 | 0 ) ; if ( $246 ) { label = 72 ; break ; } else { $$0348 = $244 ; $$0349 = $245 ; } } if ( ( label | 0 ) == 72 ) { HEAP32 [ $243 >> 2 ] = $$1 ; $247 = ( ( ( $$1 ) ) + 24 | 0 ) ; HEAP32 [ $247 >> 2 ] = $$0349 ; $248 = ( ( ( $$1 ) ) + 12 | 0 ) ; HEAP32 [ $248 >> 2 ] = $$1 ; $249 = ( ( ( $$1 ) ) + 8 | 0 ) ; HEAP32 [ $249 >> 2 ] = $$1 ; break ; } else if ( ( label | 0 ) == 73 ) { $250 = ( ( ( $$0349 ) ) + 8 | 0 ) ; $251 = HEAP32 [ $250 >> 2 ] | 0 ; $252 = ( ( ( $251 ) ) + 12 | 0 ) ; HEAP32 [ $252 >> 2 ] = $$1 ; HEAP32 [ $250 >> 2 ] = $$1 ; $253 = ( ( ( $$1 ) ) + 8 | 0 ) ; HEAP32 [ $253 >> 2 ] = $251 ; $254 = ( ( ( $$1 ) ) + 12 | 0 ) ; HEAP32 [ $254 >> 2 ] = $$0349 ; $255 = ( ( ( $$1 ) ) + 24 | 0 ) ; HEAP32 [ $255 >> 2 ] = 0 ; break ; } } } while ( 0 ) ; $256 = HEAP32 [ ( 66972 ) >> 2 ] | 0 ; $257 = ( ( $256 ) + - 1 ) | 0 ; HEAP32 [ ( 66972 ) >> 2 ] = $257 ; $258 = ( $257 | 0 ) == ( 0 ) ; if ( $258 ) { $$0195$in$i = ( 67396 ) ; } else { return ; } while ( 1 ) { $$0195$i = HEAP32 [ $$0195$in$i >> 2 ] | 0 ; $259 = ( $$0195$i | 0 ) == ( 0 | 0 ) ; $260 = ( ( ( $$0195$i ) ) + 8 | 0 ) ; if ( $259 ) { break ; } else { $$0195$in$i = $260 ; } } HEAP32 [ ( 66972 ) >> 2 ] = - 1 ; return ; } function _realloc ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $3 = 0 , $4 = 0 , $5 = 0 ; var $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $2 ) { $3 = ( _malloc ( $1 ) | 0 ) ; $$1 = $3 ; return ( $$1 | 0 ) ; } $4 = ( $1 >>> 0 ) > ( 4294967231 ) ; if ( $4 ) { $5 = ( ___errno_location ( ) | 0 ) ; HEAP32 [ $5 >> 2 ] = 12 ; $$1 = 0 ; return ( $$1 | 0 ) ; } $6 = ( $1 >>> 0 ) < ( 11 ) ; $7 = ( ( $1 ) + 11 ) | 0 ; $8 = $7 & - 8 ; $9 = $6 ? 16 : $8 ; $10 = ( ( ( $0 ) ) + - 8 | 0 ) ; $11 = ( _try_realloc_chunk ( $10 , $9 ) | 0 ) ; $12 = ( $11 | 0 ) == ( 0 | 0 ) ; if ( ! ( $12 ) ) { $13 = ( ( ( $11 ) ) + 8 | 0 ) ; $$1 = $13 ; return ( $$1 | 0 ) ; } $14 = ( _malloc ( $1 ) | 0 ) ; $15 = ( $14 | 0 ) == ( 0 | 0 ) ; if ( $15 ) { $$1 = 0 ; return ( $$1 | 0 ) ; } $16 = ( ( ( $0 ) ) + - 4 | 0 ) ; $17 = HEAP32 [ $16 >> 2 ] | 0 ; $18 = $17 & - 8 ; $19 = $17 & 3 ; $20 = ( $19 | 0 ) == ( 0 ) ; $21 = $20 ? 8 : 4 ; $22 = ( ( $18 ) - ( $21 ) ) | 0 ; $23 = ( $22 >>> 0 ) < ( $1 >>> 0 ) ; $24 = $23 ? $22 : $1 ; ( _memcpy ( ( $14 | 0 ) , ( $0 | 0 ) , ( $24 | 0 ) ) | 0 ) ; _free ( $0 ) ; $$1 = $14 ; return ( $$1 | 0 ) ; } function _try_realloc_chunk ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$1246 = 0 , $$1249 = 0 , $$2 = 0 , $$3 = 0 , $$sink1 = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 ; var $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 ; var $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $15 = 0 ; var $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 ; var $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 ; var $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 ; var $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 ; var $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $cond = 0 , $storemerge = 0 , $storemerge1 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( ( ( $0 ) ) + 4 | 0 ) ; $3 = HEAP32 [ $2 >> 2 ] | 0 ; $4 = $3 & - 8 ; $5 = ( ( $0 ) + ( $4 ) | 0 ) ; $6 = $3 & 3 ; $7 = ( $6 | 0 ) == ( 0 ) ; if ( $7 ) { $8 = ( $1 >>> 0 ) < ( 256 ) ; if ( $8 ) { $$2 = 0 ; return ( $$2 | 0 ) ; } $9 = ( ( $1 ) + 4 ) | 0 ; $10 = ( $4 >>> 0 ) < ( $9 >>> 0 ) ; if ( ! ( $10 ) ) { $11 = ( ( $4 ) - ( $1 ) ) | 0 ; $12 = HEAP32 [ ( 67420 ) >> 2 ] | 0 ; $13 = $12 << 1 ; $14 = ( $11 >>> 0 ) > ( $13 >>> 0 ) ; if ( ! ( $14 ) ) { $$2 = $0 ; return ( $$2 | 0 ) ; } } $$2 = 0 ; return ( $$2 | 0 ) ; } $15 = ( $4 >>> 0 ) < ( $1 >>> 0 ) ; if ( ! ( $15 ) ) { $16 = ( ( $4 ) - ( $1 ) ) | 0 ; $17 = ( $16 >>> 0 ) > ( 15 ) ; if ( ! ( $17 ) ) { $$2 = $0 ; return ( $$2 | 0 ) ; } $18 = ( ( $0 ) + ( $1 ) | 0 ) ; $19 = $3 & 1 ; $20 = $19 | $1 ; $21 = $20 | 2 ; HEAP32 [ $2 >> 2 ] = $21 ; $22 = ( ( ( $18 ) ) + 4 | 0 ) ; $23 = $16 | 3 ; HEAP32 [ $22 >> 2 ] = $23 ; $24 = ( ( ( $5 ) ) + 4 | 0 ) ; $25 = HEAP32 [ $24 >> 2 ] | 0 ; $26 = $25 | 1 ; HEAP32 [ $24 >> 2 ] = $26 ; _dispose_chunk ( $18 , $16 ) ; $$2 = $0 ; return ( $$2 | 0 ) ; } $27 = HEAP32 [ ( 66964 ) >> 2 ] | 0 ; $28 = ( $27 | 0 ) == ( $5 | 0 ) ; if ( $28 ) { $29 = HEAP32 [ ( 66952 ) >> 2 ] | 0 ; $30 = ( ( $29 ) + ( $4 ) ) | 0 ; $31 = ( $30 >>> 0 ) > ( $1 >>> 0 ) ; $32 = ( ( $30 ) - ( $1 ) ) | 0 ; $33 = ( ( $0 ) + ( $1 ) | 0 ) ; if ( ! ( $31 ) ) { $$2 = 0 ; return ( $$2 | 0 ) ; } $34 = $32 | 1 ; $35 = ( ( ( $33 ) ) + 4 | 0 ) ; $36 = $3 & 1 ; $37 = $36 | $1 ; $38 = $37 | 2 ; HEAP32 [ $2 >> 2 ] = $38 ; HEAP32 [ $35 >> 2 ] = $34 ; HEAP32 [ ( 66964 ) >> 2 ] = $33 ; HEAP32 [ ( 66952 ) >> 2 ] = $32 ; $$2 = $0 ; return ( $$2 | 0 ) ; } $39 = HEAP32 [ ( 66960 ) >> 2 ] | 0 ; $40 = ( $39 | 0 ) == ( $5 | 0 ) ; if ( $40 ) { $41 = HEAP32 [ ( 66948 ) >> 2 ] | 0 ; $42 = ( ( $41 ) + ( $4 ) ) | 0 ; $43 = ( $42 >>> 0 ) < ( $1 >>> 0 ) ; if ( $43 ) { $$2 = 0 ; return ( $$2 | 0 ) ; } $44 = ( ( $42 ) - ( $1 ) ) | 0 ; $45 = ( $44 >>> 0 ) > ( 15 ) ; if ( $45 ) { $46 = ( ( $0 ) + ( $1 ) | 0 ) ; $47 = ( ( $0 ) + ( $42 ) | 0 ) ; $48 = $3 & 1 ; $49 = $48 | $1 ; $50 = $49 | 2 ; HEAP32 [ $2 >> 2 ] = $50 ; $51 = ( ( ( $46 ) ) + 4 | 0 ) ; $52 = $44 | 1 ; HEAP32 [ $51 >> 2 ] = $52 ; HEAP32 [ $47 >> 2 ] = $44 ; $53 = ( ( ( $47 ) ) + 4 | 0 ) ; $54 = HEAP32 [ $53 >> 2 ] | 0 ; $55 = $54 & - 2 ; HEAP32 [ $53 >> 2 ] = $55 ; $storemerge = $46 ; $storemerge1 = $44 ; } else { $56 = $3 & 1 ; $57 = $56 | $42 ; $58 = $57 | 2 ; HEAP32 [ $2 >> 2 ] = $58 ; $59 = ( ( $0 ) + ( $42 ) | 0 ) ; $60 = ( ( ( $59 ) ) + 4 | 0 ) ; $61 = HEAP32 [ $60 >> 2 ] | 0 ; $62 = $61 | 1 ; HEAP32 [ $60 >> 2 ] = $62 ; $storemerge = 0 ; $storemerge1 = 0 ; } HEAP32 [ ( 66948 ) >> 2 ] = $storemerge1 ; HEAP32 [ ( 66960 ) >> 2 ] = $storemerge ; $$2 = $0 ; return ( $$2 | 0 ) ; } $63 = ( ( ( $5 ) ) + 4 | 0 ) ; $64 = HEAP32 [ $63 >> 2 ] | 0 ; $65 = $64 & 2 ; $66 = ( $65 | 0 ) == ( 0 ) ; if ( ! ( $66 ) ) { $$2 = 0 ; return ( $$2 | 0 ) ; } $67 = $64 & - 8 ; $68 = ( ( $67 ) + ( $4 ) ) | 0 ; $69 = ( $68 >>> 0 ) < ( $1 >>> 0 ) ; if ( $69 ) { $$2 = 0 ; return ( $$2 | 0 ) ; } $70 = ( ( $68 ) - ( $1 ) ) | 0 ; $71 = $64 >>> 3 ; $72 = ( $64 >>> 0 ) < ( 256 ) ; do { if ( $72 ) { $73 = ( ( ( $5 ) ) + 8 | 0 ) ; $74 = HEAP32 [ $73 >> 2 ] | 0 ; $75 = ( ( ( $5 ) ) + 12 | 0 ) ; $76 = HEAP32 [ $75 >> 2 ] | 0 ; $77 = ( $76 | 0 ) == ( $74 | 0 ) ; if ( $77 ) { $78 = 1 << $71 ; $79 = $78 ^ - 1 ; $80 = HEAP32 [ 16735 ] | 0 ; $81 = $80 & $79 ; HEAP32 [ 16735 ] = $81 ; break ; } else { $82 = ( ( ( $74 ) ) + 12 | 0 ) ; HEAP32 [ $82 >> 2 ] = $76 ; $83 = ( ( ( $76 ) ) + 8 | 0 ) ; HEAP32 [ $83 >> 2 ] = $74 ; break ; } } else { $84 = ( ( ( $5 ) ) + 24 | 0 ) ; $85 = HEAP32 [ $84 >> 2 ] | 0 ; $86 = ( ( ( $5 ) ) + 12 | 0 ) ; $87 = HEAP32 [ $86 >> 2 ] | 0 ; $88 = ( $87 | 0 ) == ( $5 | 0 ) ; do { if ( $88 ) { $93 = ( ( ( $5 ) ) + 16 | 0 ) ; $94 = ( ( ( $93 ) ) + 4 | 0 ) ; $95 = HEAP32 [ $94 >> 2 ] | 0 ; $96 = ( $95 | 0 ) == ( 0 | 0 ) ; if ( $96 ) { $97 = HEAP32 [ $93 >> 2 ] | 0 ; $98 = ( $97 | 0 ) == ( 0 | 0 ) ; if ( $98 ) { $$3 = 0 ; break ; } else { $$1246 = $97 ; $$1249 = $93 ; } } else { $$1246 = $95 ; $$1249 = $94 ; } while ( 1 ) { $99 = ( ( ( $$1246 ) ) + 20 | 0 ) ; $100 = HEAP32 [ $99 >> 2 ] | 0 ; $101 = ( $100 | 0 ) == ( 0 | 0 ) ; if ( ! ( $101 ) ) { $$1246 = $100 ; $$1249 = $99 ; continue ; } $102 = ( ( ( $$1246 ) ) + 16 | 0 ) ; $103 = HEAP32 [ $102 >> 2 ] | 0 ; $104 = ( $103 | 0 ) == ( 0 | 0 ) ; if ( $104 ) { break ; } else { $$1246 = $103 ; $$1249 = $102 ; } } HEAP32 [ $$1249 >> 2 ] = 0 ; $$3 = $$1246 ; } else { $89 = ( ( ( $5 ) ) + 8 | 0 ) ; $90 = HEAP32 [ $89 >> 2 ] | 0 ; $91 = ( ( ( $90 ) ) + 12 | 0 ) ; HEAP32 [ $91 >> 2 ] = $87 ; $92 = ( ( ( $87 ) ) + 8 | 0 ) ; HEAP32 [ $92 >> 2 ] = $90 ; $$3 = $87 ; } } while ( 0 ) ; $105 = ( $85 | 0 ) == ( 0 | 0 ) ; if ( ! ( $105 ) ) { $106 = ( ( ( $5 ) ) + 28 | 0 ) ; $107 = HEAP32 [ $106 >> 2 ] | 0 ; $108 = ( 67244 + ( $107 << 2 ) | 0 ) ; $109 = HEAP32 [ $108 >> 2 ] | 0 ; $110 = ( $109 | 0 ) == ( $5 | 0 ) ; if ( $110 ) { HEAP32 [ $108 >> 2 ] = $$3 ; $cond = ( $$3 | 0 ) == ( 0 | 0 ) ; if ( $cond ) { $111 = 1 << $107 ; $112 = $111 ^ - 1 ; $113 = HEAP32 [ ( 66944 ) >> 2 ] | 0 ; $114 = $113 & $112 ; HEAP32 [ ( 66944 ) >> 2 ] = $114 ; break ; } } else { $115 = ( ( ( $85 ) ) + 16 | 0 ) ; $116 = HEAP32 [ $115 >> 2 ] | 0 ; $117 = ( $116 | 0 ) != ( $5 | 0 ) ; $$sink1 = $117 & 1 ; $118 = ( ( ( ( $85 ) ) + 16 | 0 ) + ( $$sink1 << 2 ) | 0 ) ; HEAP32 [ $118 >> 2 ] = $$3 ; $119 = ( $$3 | 0 ) == ( 0 | 0 ) ; if ( $119 ) { break ; } } $120 = ( ( ( $$3 ) ) + 24 | 0 ) ; HEAP32 [ $120 >> 2 ] = $85 ; $121 = ( ( ( $5 ) ) + 16 | 0 ) ; $122 = HEAP32 [ $121 >> 2 ] | 0 ; $123 = ( $122 | 0 ) == ( 0 | 0 ) ; if ( ! ( $123 ) ) { $124 = ( ( ( $$3 ) ) + 16 | 0 ) ; HEAP32 [ $124 >> 2 ] = $122 ; $125 = ( ( ( $122 ) ) + 24 | 0 ) ; HEAP32 [ $125 >> 2 ] = $$3 ; } $126 = ( ( ( $121 ) ) + 4 | 0 ) ; $127 = HEAP32 [ $126 >> 2 ] | 0 ; $128 = ( $127 | 0 ) == ( 0 | 0 ) ; if ( ! ( $128 ) ) { $129 = ( ( ( $$3 ) ) + 20 | 0 ) ; HEAP32 [ $129 >> 2 ] = $127 ; $130 = ( ( ( $127 ) ) + 24 | 0 ) ; HEAP32 [ $130 >> 2 ] = $$3 ; } } } } while ( 0 ) ; $131 = ( $70 >>> 0 ) < ( 16 ) ; if ( $131 ) { $132 = $3 & 1 ; $133 = $68 | $132 ; $134 = $133 | 2 ; HEAP32 [ $2 >> 2 ] = $134 ; $135 = ( ( $0 ) + ( $68 ) | 0 ) ; $136 = ( ( ( $135 ) ) + 4 | 0 ) ; $137 = HEAP32 [ $136 >> 2 ] | 0 ; $138 = $137 | 1 ; HEAP32 [ $136 >> 2 ] = $138 ; $$2 = $0 ; return ( $$2 | 0 ) ; } else { $139 = ( ( $0 ) + ( $1 ) | 0 ) ; $140 = $3 & 1 ; $141 = $140 | $1 ; $142 = $141 | 2 ; HEAP32 [ $2 >> 2 ] = $142 ; $143 = ( ( ( $139 ) ) + 4 | 0 ) ; $144 = $70 | 3 ; HEAP32 [ $143 >> 2 ] = $144 ; $145 = ( ( $0 ) + ( $68 ) | 0 ) ; $146 = ( ( ( $145 ) ) + 4 | 0 ) ; $147 = HEAP32 [ $146 >> 2 ] | 0 ; $148 = $147 | 1 ; HEAP32 [ $146 >> 2 ] = $148 ; _dispose_chunk ( $139 , $70 ) ; $$2 = $0 ; return ( $$2 | 0 ) ; } return ( 0 ) | 0 ; } function _dispose_chunk ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$0366 = 0 , $$0367 = 0 , $$0378 = 0 , $$0385 = 0 , $$1 = 0 , $$1365 = 0 , $$1373 = 0 , $$1376 = 0 , $$1380 = 0 , $$1384 = 0 , $$2 = 0 , $$3 = 0 , $$3382 = 0 , $$pre = 0 , $$pre$phiZ2D = 0 , $$sink2 = 0 , $$sink4 = 0 , $10 = 0 , $100 = 0 , $101 = 0 ; var $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 ; var $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 ; var $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 ; var $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 , $172 = 0 , $173 = 0 , $174 = 0 ; var $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 , $190 = 0 , $191 = 0 , $192 = 0 ; var $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $2 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 , $208 = 0 , $209 = 0 , $21 = 0 ; var $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 , $226 = 0 , $227 = 0 , $228 = 0 ; var $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 , $244 = 0 , $245 = 0 , $246 = 0 ; var $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 ; var $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 ; var $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 ; var $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 ; var $98 = 0 , $99 = 0 , $cond = 0 , $cond3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( ( $0 ) + ( $1 ) | 0 ) ; $3 = ( ( ( $0 ) ) + 4 | 0 ) ; $4 = HEAP32 [ $3 >> 2 ] | 0 ; $5 = $4 & 1 ; $6 = ( $5 | 0 ) == ( 0 ) ; do { if ( $6 ) { $7 = HEAP32 [ $0 >> 2 ] | 0 ; $8 = $4 & 3 ; $9 = ( $8 | 0 ) == ( 0 ) ; if ( $9 ) { return ; } $10 = ( 0 - ( $7 ) ) | 0 ; $11 = ( ( $0 ) + ( $10 ) | 0 ) ; $12 = ( ( $7 ) + ( $1 ) ) | 0 ; $13 = HEAP32 [ ( 66960 ) >> 2 ] | 0 ; $14 = ( $13 | 0 ) == ( $11 | 0 ) ; if ( $14 ) { $75 = ( ( ( $2 ) ) + 4 | 0 ) ; $76 = HEAP32 [ $75 >> 2 ] | 0 ; $77 = $76 & 3 ; $78 = ( $77 | 0 ) == ( 3 ) ; if ( ! ( $78 ) ) { $$1 = $11 ; $$1365 = $12 ; break ; } HEAP32 [ ( 66948 ) >> 2 ] = $12 ; $79 = $76 & - 2 ; HEAP32 [ $75 >> 2 ] = $79 ; $80 = $12 | 1 ; $81 = ( ( ( $11 ) ) + 4 | 0 ) ; HEAP32 [ $81 >> 2 ] = $80 ; HEAP32 [ $2 >> 2 ] = $12 ; return ; } $15 = $7 >>> 3 ; $16 = ( $7 >>> 0 ) < ( 256 ) ; if ( $16 ) { $17 = ( ( ( $11 ) ) + 8 | 0 ) ; $18 = HEAP32 [ $17 >> 2 ] | 0 ; $19 = ( ( ( $11 ) ) + 12 | 0 ) ; $20 = HEAP32 [ $19 >> 2 ] | 0 ; $21 = ( $20 | 0 ) == ( $18 | 0 ) ; if ( $21 ) { $22 = 1 << $15 ; $23 = $22 ^ - 1 ; $24 = HEAP32 [ 16735 ] | 0 ; $25 = $24 & $23 ; HEAP32 [ 16735 ] = $25 ; $$1 = $11 ; $$1365 = $12 ; break ; } else { $26 = ( ( ( $18 ) ) + 12 | 0 ) ; HEAP32 [ $26 >> 2 ] = $20 ; $27 = ( ( ( $20 ) ) + 8 | 0 ) ; HEAP32 [ $27 >> 2 ] = $18 ; $$1 = $11 ; $$1365 = $12 ; break ; } } $28 = ( ( ( $11 ) ) + 24 | 0 ) ; $29 = HEAP32 [ $28 >> 2 ] | 0 ; $30 = ( ( ( $11 ) ) + 12 | 0 ) ; $31 = HEAP32 [ $30 >> 2 ] | 0 ; $32 = ( $31 | 0 ) == ( $11 | 0 ) ; do { if ( $32 ) { $37 = ( ( ( $11 ) ) + 16 | 0 ) ; $38 = ( ( ( $37 ) ) + 4 | 0 ) ; $39 = HEAP32 [ $38 >> 2 ] | 0 ; $40 = ( $39 | 0 ) == ( 0 | 0 ) ; if ( $40 ) { $41 = HEAP32 [ $37 >> 2 ] | 0 ; $42 = ( $41 | 0 ) == ( 0 | 0 ) ; if ( $42 ) { $$3 = 0 ; break ; } else { $$1373 = $41 ; $$1376 = $37 ; } } else { $$1373 = $39 ; $$1376 = $38 ; } while ( 1 ) { $43 = ( ( ( $$1373 ) ) + 20 | 0 ) ; $44 = HEAP32 [ $43 >> 2 ] | 0 ; $45 = ( $44 | 0 ) == ( 0 | 0 ) ; if ( ! ( $45 ) ) { $$1373 = $44 ; $$1376 = $43 ; continue ; } $46 = ( ( ( $$1373 ) ) + 16 | 0 ) ; $47 = HEAP32 [ $46 >> 2 ] | 0 ; $48 = ( $47 | 0 ) == ( 0 | 0 ) ; if ( $48 ) { break ; } else { $$1373 = $47 ; $$1376 = $46 ; } } HEAP32 [ $$1376 >> 2 ] = 0 ; $$3 = $$1373 ; } else { $33 = ( ( ( $11 ) ) + 8 | 0 ) ; $34 = HEAP32 [ $33 >> 2 ] | 0 ; $35 = ( ( ( $34 ) ) + 12 | 0 ) ; HEAP32 [ $35 >> 2 ] = $31 ; $36 = ( ( ( $31 ) ) + 8 | 0 ) ; HEAP32 [ $36 >> 2 ] = $34 ; $$3 = $31 ; } } while ( 0 ) ; $49 = ( $29 | 0 ) == ( 0 | 0 ) ; if ( $49 ) { $$1 = $11 ; $$1365 = $12 ; } else { $50 = ( ( ( $11 ) ) + 28 | 0 ) ; $51 = HEAP32 [ $50 >> 2 ] | 0 ; $52 = ( 67244 + ( $51 << 2 ) | 0 ) ; $53 = HEAP32 [ $52 >> 2 ] | 0 ; $54 = ( $53 | 0 ) == ( $11 | 0 ) ; if ( $54 ) { HEAP32 [ $52 >> 2 ] = $$3 ; $cond = ( $$3 | 0 ) == ( 0 | 0 ) ; if ( $cond ) { $55 = 1 << $51 ; $56 = $55 ^ - 1 ; $57 = HEAP32 [ ( 66944 ) >> 2 ] | 0 ; $58 = $57 & $56 ; HEAP32 [ ( 66944 ) >> 2 ] = $58 ; $$1 = $11 ; $$1365 = $12 ; break ; } } else { $59 = ( ( ( $29 ) ) + 16 | 0 ) ; $60 = HEAP32 [ $59 >> 2 ] | 0 ; $61 = ( $60 | 0 ) != ( $11 | 0 ) ; $$sink2 = $61 & 1 ; $62 = ( ( ( ( $29 ) ) + 16 | 0 ) + ( $$sink2 << 2 ) | 0 ) ; HEAP32 [ $62 >> 2 ] = $$3 ; $63 = ( $$3 | 0 ) == ( 0 | 0 ) ; if ( $63 ) { $$1 = $11 ; $$1365 = $12 ; break ; } } $64 = ( ( ( $$3 ) ) + 24 | 0 ) ; HEAP32 [ $64 >> 2 ] = $29 ; $65 = ( ( ( $11 ) ) + 16 | 0 ) ; $66 = HEAP32 [ $65 >> 2 ] | 0 ; $67 = ( $66 | 0 ) == ( 0 | 0 ) ; if ( ! ( $67 ) ) { $68 = ( ( ( $$3 ) ) + 16 | 0 ) ; HEAP32 [ $68 >> 2 ] = $66 ; $69 = ( ( ( $66 ) ) + 24 | 0 ) ; HEAP32 [ $69 >> 2 ] = $$3 ; } $70 = ( ( ( $65 ) ) + 4 | 0 ) ; $71 = HEAP32 [ $70 >> 2 ] | 0 ; $72 = ( $71 | 0 ) == ( 0 | 0 ) ; if ( $72 ) { $$1 = $11 ; $$1365 = $12 ; } else { $73 = ( ( ( $$3 ) ) + 20 | 0 ) ; HEAP32 [ $73 >> 2 ] = $71 ; $74 = ( ( ( $71 ) ) + 24 | 0 ) ; HEAP32 [ $74 >> 2 ] = $$3 ; $$1 = $11 ; $$1365 = $12 ; } } } else { $$1 = $0 ; $$1365 = $1 ; } } while ( 0 ) ; $82 = ( ( ( $2 ) ) + 4 | 0 ) ; $83 = HEAP32 [ $82 >> 2 ] | 0 ; $84 = $83 & 2 ; $85 = ( $84 | 0 ) == ( 0 ) ; if ( $85 ) { $86 = HEAP32 [ ( 66964 ) >> 2 ] | 0 ; $87 = ( $86 | 0 ) == ( $2 | 0 ) ; if ( $87 ) { $88 = HEAP32 [ ( 66952 ) >> 2 ] | 0 ; $89 = ( ( $88 ) + ( $$1365 ) ) | 0 ; HEAP32 [ ( 66952 ) >> 2 ] = $89 ; HEAP32 [ ( 66964 ) >> 2 ] = $$1 ; $90 = $89 | 1 ; $91 = ( ( ( $$1 ) ) + 4 | 0 ) ; HEAP32 [ $91 >> 2 ] = $90 ; $92 = HEAP32 [ ( 66960 ) >> 2 ] | 0 ; $93 = ( $$1 | 0 ) == ( $92 | 0 ) ; if ( ! ( $93 ) ) { return ; } HEAP32 [ ( 66960 ) >> 2 ] = 0 ; HEAP32 [ ( 66948 ) >> 2 ] = 0 ; return ; } $94 = HEAP32 [ ( 66960 ) >> 2 ] | 0 ; $95 = ( $94 | 0 ) == ( $2 | 0 ) ; if ( $95 ) { $96 = HEAP32 [ ( 66948 ) >> 2 ] | 0 ; $97 = ( ( $96 ) + ( $$1365 ) ) | 0 ; HEAP32 [ ( 66948 ) >> 2 ] = $97 ; HEAP32 [ ( 66960 ) >> 2 ] = $$1 ; $98 = $97 | 1 ; $99 = ( ( ( $$1 ) ) + 4 | 0 ) ; HEAP32 [ $99 >> 2 ] = $98 ; $100 = ( ( $$1 ) + ( $97 ) | 0 ) ; HEAP32 [ $100 >> 2 ] = $97 ; return ; } $101 = $83 & - 8 ; $102 = ( ( $101 ) + ( $$1365 ) ) | 0 ; $103 = $83 >>> 3 ; $104 = ( $83 >>> 0 ) < ( 256 ) ; do { if ( $104 ) { $105 = ( ( ( $2 ) ) + 8 | 0 ) ; $106 = HEAP32 [ $105 >> 2 ] | 0 ; $107 = ( ( ( $2 ) ) + 12 | 0 ) ; $108 = HEAP32 [ $107 >> 2 ] | 0 ; $109 = ( $108 | 0 ) == ( $106 | 0 ) ; if ( $109 ) { $110 = 1 << $103 ; $111 = $110 ^ - 1 ; $112 = HEAP32 [ 16735 ] | 0 ; $113 = $112 & $111 ; HEAP32 [ 16735 ] = $113 ; break ; } else { $114 = ( ( ( $106 ) ) + 12 | 0 ) ; HEAP32 [ $114 >> 2 ] = $108 ; $115 = ( ( ( $108 ) ) + 8 | 0 ) ; HEAP32 [ $115 >> 2 ] = $106 ; break ; } } else { $116 = ( ( ( $2 ) ) + 24 | 0 ) ; $117 = HEAP32 [ $116 >> 2 ] | 0 ; $118 = ( ( ( $2 ) ) + 12 | 0 ) ; $119 = HEAP32 [ $118 >> 2 ] | 0 ; $120 = ( $119 | 0 ) == ( $2 | 0 ) ; do { if ( $120 ) { $125 = ( ( ( $2 ) ) + 16 | 0 ) ; $126 = ( ( ( $125 ) ) + 4 | 0 ) ; $127 = HEAP32 [ $126 >> 2 ] | 0 ; $128 = ( $127 | 0 ) == ( 0 | 0 ) ; if ( $128 ) { $129 = HEAP32 [ $125 >> 2 ] | 0 ; $130 = ( $129 | 0 ) == ( 0 | 0 ) ; if ( $130 ) { $$3382 = 0 ; break ; } else { $$1380 = $129 ; $$1384 = $125 ; } } else { $$1380 = $127 ; $$1384 = $126 ; } while ( 1 ) { $131 = ( ( ( $$1380 ) ) + 20 | 0 ) ; $132 = HEAP32 [ $131 >> 2 ] | 0 ; $133 = ( $132 | 0 ) == ( 0 | 0 ) ; if ( ! ( $133 ) ) { $$1380 = $132 ; $$1384 = $131 ; continue ; } $134 = ( ( ( $$1380 ) ) + 16 | 0 ) ; $135 = HEAP32 [ $134 >> 2 ] | 0 ; $136 = ( $135 | 0 ) == ( 0 | 0 ) ; if ( $136 ) { break ; } else { $$1380 = $135 ; $$1384 = $134 ; } } HEAP32 [ $$1384 >> 2 ] = 0 ; $$3382 = $$1380 ; } else { $121 = ( ( ( $2 ) ) + 8 | 0 ) ; $122 = HEAP32 [ $121 >> 2 ] | 0 ; $123 = ( ( ( $122 ) ) + 12 | 0 ) ; HEAP32 [ $123 >> 2 ] = $119 ; $124 = ( ( ( $119 ) ) + 8 | 0 ) ; HEAP32 [ $124 >> 2 ] = $122 ; $$3382 = $119 ; } } while ( 0 ) ; $137 = ( $117 | 0 ) == ( 0 | 0 ) ; if ( ! ( $137 ) ) { $138 = ( ( ( $2 ) ) + 28 | 0 ) ; $139 = HEAP32 [ $138 >> 2 ] | 0 ; $140 = ( 67244 + ( $139 << 2 ) | 0 ) ; $141 = HEAP32 [ $140 >> 2 ] | 0 ; $142 = ( $141 | 0 ) == ( $2 | 0 ) ; if ( $142 ) { HEAP32 [ $140 >> 2 ] = $$3382 ; $cond3 = ( $$3382 | 0 ) == ( 0 | 0 ) ; if ( $cond3 ) { $143 = 1 << $139 ; $144 = $143 ^ - 1 ; $145 = HEAP32 [ ( 66944 ) >> 2 ] | 0 ; $146 = $145 & $144 ; HEAP32 [ ( 66944 ) >> 2 ] = $146 ; break ; } } else { $147 = ( ( ( $117 ) ) + 16 | 0 ) ; $148 = HEAP32 [ $147 >> 2 ] | 0 ; $149 = ( $148 | 0 ) != ( $2 | 0 ) ; $$sink4 = $149 & 1 ; $150 = ( ( ( ( $117 ) ) + 16 | 0 ) + ( $$sink4 << 2 ) | 0 ) ; HEAP32 [ $150 >> 2 ] = $$3382 ; $151 = ( $$3382 | 0 ) == ( 0 | 0 ) ; if ( $151 ) { break ; } } $152 = ( ( ( $$3382 ) ) + 24 | 0 ) ; HEAP32 [ $152 >> 2 ] = $117 ; $153 = ( ( ( $2 ) ) + 16 | 0 ) ; $154 = HEAP32 [ $153 >> 2 ] | 0 ; $155 = ( $154 | 0 ) == ( 0 | 0 ) ; if ( ! ( $155 ) ) { $156 = ( ( ( $$3382 ) ) + 16 | 0 ) ; HEAP32 [ $156 >> 2 ] = $154 ; $157 = ( ( ( $154 ) ) + 24 | 0 ) ; HEAP32 [ $157 >> 2 ] = $$3382 ; } $158 = ( ( ( $153 ) ) + 4 | 0 ) ; $159 = HEAP32 [ $158 >> 2 ] | 0 ; $160 = ( $159 | 0 ) == ( 0 | 0 ) ; if ( ! ( $160 ) ) { $161 = ( ( ( $$3382 ) ) + 20 | 0 ) ; HEAP32 [ $161 >> 2 ] = $159 ; $162 = ( ( ( $159 ) ) + 24 | 0 ) ; HEAP32 [ $162 >> 2 ] = $$3382 ; } } } } while ( 0 ) ; $163 = $102 | 1 ; $164 = ( ( ( $$1 ) ) + 4 | 0 ) ; HEAP32 [ $164 >> 2 ] = $163 ; $165 = ( ( $$1 ) + ( $102 ) | 0 ) ; HEAP32 [ $165 >> 2 ] = $102 ; $166 = HEAP32 [ ( 66960 ) >> 2 ] | 0 ; $167 = ( $$1 | 0 ) == ( $166 | 0 ) ; if ( $167 ) { HEAP32 [ ( 66948 ) >> 2 ] = $102 ; return ; } else { $$2 = $102 ; } } else { $168 = $83 & - 2 ; HEAP32 [ $82 >> 2 ] = $168 ; $169 = $$1365 | 1 ; $170 = ( ( ( $$1 ) ) + 4 | 0 ) ; HEAP32 [ $170 >> 2 ] = $169 ; $171 = ( ( $$1 ) + ( $$1365 ) | 0 ) ; HEAP32 [ $171 >> 2 ] = $$1365 ; $$2 = $$1365 ; } $172 = $$2 >>> 3 ; $173 = ( $$2 >>> 0 ) < ( 256 ) ; if ( $173 ) { $174 = $172 << 1 ; $175 = ( 66980 + ( $174 << 2 ) | 0 ) ; $176 = HEAP32 [ 16735 ] | 0 ; $177 = 1 << $172 ; $178 = $176 & $177 ; $179 = ( $178 | 0 ) == ( 0 ) ; if ( $179 ) { $180 = $176 | $177 ; HEAP32 [ 16735 ] = $180 ; $$pre = ( ( ( $175 ) ) + 8 | 0 ) ; $$0385 = $175 ; $$pre$phiZ2D = $$pre ; } else { $181 = ( ( ( $175 ) ) + 8 | 0 ) ; $182 = HEAP32 [ $181 >> 2 ] | 0 ; $$0385 = $182 ; $$pre$phiZ2D = $181 ; } HEAP32 [ $$pre$phiZ2D >> 2 ] = $$1 ; $183 = ( ( ( $$0385 ) ) + 12 | 0 ) ; HEAP32 [ $183 >> 2 ] = $$1 ; $184 = ( ( ( $$1 ) ) + 8 | 0 ) ; HEAP32 [ $184 >> 2 ] = $$0385 ; $185 = ( ( ( $$1 ) ) + 12 | 0 ) ; HEAP32 [ $185 >> 2 ] = $175 ; return ; } $186 = $$2 >>> 8 ; $187 = ( $186 | 0 ) == ( 0 ) ; if ( $187 ) { $$0378 = 0 ; } else { $188 = ( $$2 >>> 0 ) > ( 16777215 ) ; if ( $188 ) { $$0378 = 31 ; } else { $189 = ( ( $186 ) + 1048320 ) | 0 ; $190 = $189 >>> 16 ; $191 = $190 & 8 ; $192 = $186 << $191 ; $193 = ( ( $192 ) + 520192 ) | 0 ; $194 = $193 >>> 16 ; $195 = $194 & 4 ; $196 = $195 | $191 ; $197 = $192 << $195 ; $198 = ( ( $197 ) + 245760 ) | 0 ; $199 = $198 >>> 16 ; $200 = $199 & 2 ; $201 = $196 | $200 ; $202 = ( 14 - ( $201 ) ) | 0 ; $203 = $197 << $200 ; $204 = $203 >>> 15 ; $205 = ( ( $202 ) + ( $204 ) ) | 0 ; $206 = $205 << 1 ; $207 = ( ( $205 ) + 7 ) | 0 ; $208 = $$2 >>> $207 ; $209 = $208 & 1 ; $210 = $209 | $206 ; $$0378 = $210 ; } } $211 = ( 67244 + ( $$0378 << 2 ) | 0 ) ; $212 = ( ( ( $$1 ) ) + 28 | 0 ) ; HEAP32 [ $212 >> 2 ] = $$0378 ; $213 = ( ( ( $$1 ) ) + 16 | 0 ) ; $214 = ( ( ( $$1 ) ) + 20 | 0 ) ; HEAP32 [ $214 >> 2 ] = 0 ; HEAP32 [ $213 >> 2 ] = 0 ; $215 = HEAP32 [ ( 66944 ) >> 2 ] | 0 ; $216 = 1 << $$0378 ; $217 = $215 & $216 ; $218 = ( $217 | 0 ) == ( 0 ) ; if ( $218 ) { $219 = $215 | $216 ; HEAP32 [ ( 66944 ) >> 2 ] = $219 ; HEAP32 [ $211 >> 2 ] = $$1 ; $220 = ( ( ( $$1 ) ) + 24 | 0 ) ; HEAP32 [ $220 >> 2 ] = $211 ; $221 = ( ( ( $$1 ) ) + 12 | 0 ) ; HEAP32 [ $221 >> 2 ] = $$1 ; $222 = ( ( ( $$1 ) ) + 8 | 0 ) ; HEAP32 [ $222 >> 2 ] = $$1 ; return ; } $223 = HEAP32 [ $211 >> 2 ] | 0 ; $224 = ( $$0378 | 0 ) == ( 31 ) ; $225 = $$0378 >>> 1 ; $226 = ( 25 - ( $225 ) ) | 0 ; $227 = $224 ? 0 : $226 ; $228 = $$2 << $227 ; $$0366 = $228 ; $$0367 = $223 ; while ( 1 ) { $229 = ( ( ( $$0367 ) ) + 4 | 0 ) ; $230 = HEAP32 [ $229 >> 2 ] | 0 ; $231 = $230 & - 8 ; $232 = ( $231 | 0 ) == ( $$2 | 0 ) ; if ( $232 ) { label = 69 ; break ; } $233 = $$0366 >>> 31 ; $234 = ( ( ( ( $$0367 ) ) + 16 | 0 ) + ( $233 << 2 ) | 0 ) ; $235 = $$0366 << 1 ; $236 = HEAP32 [ $234 >> 2 ] | 0 ; $237 = ( $236 | 0 ) == ( 0 | 0 ) ; if ( $237 ) { label = 68 ; break ; } else { $$0366 = $235 ; $$0367 = $236 ; } } if ( ( label | 0 ) == 68 ) { HEAP32 [ $234 >> 2 ] = $$1 ; $238 = ( ( ( $$1 ) ) + 24 | 0 ) ; HEAP32 [ $238 >> 2 ] = $$0367 ; $239 = ( ( ( $$1 ) ) + 12 | 0 ) ; HEAP32 [ $239 >> 2 ] = $$1 ; $240 = ( ( ( $$1 ) ) + 8 | 0 ) ; HEAP32 [ $240 >> 2 ] = $$1 ; return ; } else if ( ( label | 0 ) == 69 ) { $241 = ( ( ( $$0367 ) ) + 8 | 0 ) ; $242 = HEAP32 [ $241 >> 2 ] | 0 ; $243 = ( ( ( $242 ) ) + 12 | 0 ) ; HEAP32 [ $243 >> 2 ] = $$1 ; HEAP32 [ $241 >> 2 ] = $$1 ; $244 = ( ( ( $$1 ) ) + 8 | 0 ) ; HEAP32 [ $244 >> 2 ] = $242 ; $245 = ( ( ( $$1 ) ) + 12 | 0 ) ; HEAP32 [ $245 >> 2 ] = $$0367 ; $246 = ( ( ( $$1 ) ) + 24 | 0 ) ; HEAP32 [ $246 >> 2 ] = 0 ; return ; } } function ___stdio_close ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $vararg_buffer = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $vararg_buffer = sp ; $1 = ( ( ( $0 ) ) + 60 | 0 ) ; $2 = HEAP32 [ $1 >> 2 ] | 0 ; $3 = ( _dummy_380 ( $2 ) | 0 ) ; HEAP32 [ $vararg_buffer >> 2 ] = $3 ; $4 = ( ___syscall6 ( 6 , ( $vararg_buffer | 0 ) ) | 0 ) ; $5 = ( ___syscall_ret ( $4 ) | 0 ) ; STACKTOP = sp ; return ( $5 | 0 ) ; } function ___stdio_read ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$0 = 0 , $$cast = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 ; var $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $vararg_buffer = 0 , $vararg_ptr1 = 0 , $vararg_ptr2 = 0 , label = 0 ; var sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $vararg_buffer = sp ; $3 = sp + 16 | 0 ; HEAP32 [ $3 >> 2 ] = $1 ; $4 = ( ( ( $3 ) ) + 4 | 0 ) ; $5 = ( ( ( $0 ) ) + 48 | 0 ) ; $6 = HEAP32 [ $5 >> 2 ] | 0 ; $7 = ( $6 | 0 ) != ( 0 ) ; $8 = $7 & 1 ; $9 = ( ( $2 ) - ( $8 ) ) | 0 ; HEAP32 [ $4 >> 2 ] = $9 ; $10 = ( ( ( $3 ) ) + 8 | 0 ) ; $11 = ( ( ( $0 ) ) + 44 | 0 ) ; $12 = HEAP32 [ $11 >> 2 ] | 0 ; HEAP32 [ $10 >> 2 ] = $12 ; $13 = ( ( ( $3 ) ) + 12 | 0 ) ; HEAP32 [ $13 >> 2 ] = $6 ; $14 = ( ( ( $0 ) ) + 60 | 0 ) ; $15 = HEAP32 [ $14 >> 2 ] | 0 ; $16 = $3 ; HEAP32 [ $vararg_buffer >> 2 ] = $15 ; $vararg_ptr1 = ( ( ( $vararg_buffer ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr1 >> 2 ] = $16 ; $vararg_ptr2 = ( ( ( $vararg_buffer ) ) + 8 | 0 ) ; HEAP32 [ $vararg_ptr2 >> 2 ] = 2 ; $17 = ( ___syscall145 ( 145 , ( $vararg_buffer | 0 ) ) | 0 ) ; $18 = ( ___syscall_ret ( $17 ) | 0 ) ; $19 = ( $18 | 0 ) < ( 1 ) ; if ( $19 ) { $20 = $18 & 48 ; $21 = $20 ^ 16 ; $22 = HEAP32 [ $0 >> 2 ] | 0 ; $23 = $22 | $21 ; HEAP32 [ $0 >> 2 ] = $23 ; $$0 = $18 ; } else { $24 = HEAP32 [ $4 >> 2 ] | 0 ; $25 = ( $18 >>> 0 ) > ( $24 >>> 0 ) ; if ( $25 ) { $26 = ( ( $18 ) - ( $24 ) ) | 0 ; $27 = HEAP32 [ $11 >> 2 ] | 0 ; $28 = ( ( ( $0 ) ) + 4 | 0 ) ; HEAP32 [ $28 >> 2 ] = $27 ; $$cast = $27 ; $29 = ( ( $$cast ) + ( $26 ) | 0 ) ; $30 = ( ( ( $0 ) ) + 8 | 0 ) ; HEAP32 [ $30 >> 2 ] = $29 ; $31 = HEAP32 [ $5 >> 2 ] | 0 ; $32 = ( $31 | 0 ) == ( 0 ) ; if ( $32 ) { $$0 = $2 ; } else { $33 = ( ( ( $$cast ) ) + 1 | 0 ) ; HEAP32 [ $28 >> 2 ] = $33 ; $34 = HEAP8 [ $$cast >> 0 ] | 0 ; $35 = ( ( $2 ) + - 1 ) | 0 ; $36 = ( ( $1 ) + ( $35 ) | 0 ) ; HEAP8 [ $36 >> 0 ] = $34 ; $$0 = $2 ; } } else { $$0 = $18 ; } } STACKTOP = sp ; return ( $$0 | 0 ) ; } function ___stdio_seek ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$pre = 0 , $10 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $vararg_buffer = 0 , $vararg_ptr1 = 0 , $vararg_ptr2 = 0 , $vararg_ptr3 = 0 , $vararg_ptr4 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $vararg_buffer = sp ; $3 = sp + 20 | 0 ; $4 = ( ( ( $0 ) ) + 60 | 0 ) ; $5 = HEAP32 [ $4 >> 2 ] | 0 ; $6 = $3 ; HEAP32 [ $vararg_buffer >> 2 ] = $5 ; $vararg_ptr1 = ( ( ( $vararg_buffer ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr1 >> 2 ] = 0 ; $vararg_ptr2 = ( ( ( $vararg_buffer ) ) + 8 | 0 ) ; HEAP32 [ $vararg_ptr2 >> 2 ] = $1 ; $vararg_ptr3 = ( ( ( $vararg_buffer ) ) + 12 | 0 ) ; HEAP32 [ $vararg_ptr3 >> 2 ] = $6 ; $vararg_ptr4 = ( ( ( $vararg_buffer ) ) + 16 | 0 ) ; HEAP32 [ $vararg_ptr4 >> 2 ] = $2 ; $7 = ( ___syscall140 ( 140 , ( $vararg_buffer | 0 ) ) | 0 ) ; $8 = ( ___syscall_ret ( $7 ) | 0 ) ; $9 = ( $8 | 0 ) < ( 0 ) ; if ( $9 ) { HEAP32 [ $3 >> 2 ] = - 1 ; $10 = - 1 ; } else { $$pre = HEAP32 [ $3 >> 2 ] | 0 ; $10 = $$pre ; } STACKTOP = sp ; return ( $10 | 0 ) ; } function ___syscall_ret ( $0 ) { $0 = $0 | 0 ; var $$0 = 0 , $1 = 0 , $2 = 0 , $3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( $0 >>> 0 ) > ( 4294963200 ) ; if ( $1 ) { $2 = ( 0 - ( $0 ) ) | 0 ; $3 = ( ___errno_location ( ) | 0 ) ; HEAP32 [ $3 >> 2 ] = $2 ; $$0 = - 1 ; } else { $$0 = $0 ; } return ( $$0 | 0 ) ; } function ___errno_location ( ) { var label = 0 , sp = 0 ; sp = STACKTOP ; return ( 67500 | 0 ) ; } function _dummy_380 ( $0 ) { $0 = $0 | 0 ; var label = 0 , sp = 0 ; sp = STACKTOP ; return ( $0 | 0 ) ; } function ___stdout_write ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $vararg_buffer = 0 , $vararg_ptr1 = 0 , $vararg_ptr2 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $vararg_buffer = sp ; $3 = sp + 16 | 0 ; $4 = ( ( ( $0 ) ) + 36 | 0 ) ; HEAP32 [ $4 >> 2 ] = 9 ; $5 = HEAP32 [ $0 >> 2 ] | 0 ; $6 = $5 & 64 ; $7 = ( $6 | 0 ) == ( 0 ) ; if ( $7 ) { $8 = ( ( ( $0 ) ) + 60 | 0 ) ; $9 = HEAP32 [ $8 >> 2 ] | 0 ; $10 = $3 ; HEAP32 [ $vararg_buffer >> 2 ] = $9 ; $vararg_ptr1 = ( ( ( $vararg_buffer ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr1 >> 2 ] = 21523 ; $vararg_ptr2 = ( ( ( $vararg_buffer ) ) + 8 | 0 ) ; HEAP32 [ $vararg_ptr2 >> 2 ] = $10 ; $11 = ( ___syscall54 ( 54 , ( $vararg_buffer | 0 ) ) | 0 ) ; $12 = ( $11 | 0 ) == ( 0 ) ; if ( ! ( $12 ) ) { $13 = ( ( ( $0 ) ) + 75 | 0 ) ; HEAP8 [ $13 >> 0 ] = - 1 ; } } $14 = ( ___stdio_write ( $0 , $1 , $2 ) | 0 ) ; STACKTOP = sp ; return ( $14 | 0 ) ; } function ___stdio_write ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$0 = 0 , $$04756 = 0 , $$04855 = 0 , $$04954 = 0 , $$051 = 0 , $$1 = 0 , $$150 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 ; var $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 ; var $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $vararg_buffer = 0 , $vararg_buffer3 = 0 , $vararg_ptr1 = 0 , $vararg_ptr2 = 0 ; var $vararg_ptr6 = 0 , $vararg_ptr7 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 48 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 48 | 0 ) ; $vararg_buffer3 = sp + 16 | 0 ; $vararg_buffer = sp ; $3 = sp + 32 | 0 ; $4 = ( ( ( $0 ) ) + 28 | 0 ) ; $5 = HEAP32 [ $4 >> 2 ] | 0 ; HEAP32 [ $3 >> 2 ] = $5 ; $6 = ( ( ( $3 ) ) + 4 | 0 ) ; $7 = ( ( ( $0 ) ) + 20 | 0 ) ; $8 = HEAP32 [ $7 >> 2 ] | 0 ; $9 = ( ( $8 ) - ( $5 ) ) | 0 ; HEAP32 [ $6 >> 2 ] = $9 ; $10 = ( ( ( $3 ) ) + 8 | 0 ) ; HEAP32 [ $10 >> 2 ] = $1 ; $11 = ( ( ( $3 ) ) + 12 | 0 ) ; HEAP32 [ $11 >> 2 ] = $2 ; $12 = ( ( $9 ) + ( $2 ) ) | 0 ; $13 = ( ( ( $0 ) ) + 60 | 0 ) ; $14 = HEAP32 [ $13 >> 2 ] | 0 ; $15 = $3 ; HEAP32 [ $vararg_buffer >> 2 ] = $14 ; $vararg_ptr1 = ( ( ( $vararg_buffer ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr1 >> 2 ] = $15 ; $vararg_ptr2 = ( ( ( $vararg_buffer ) ) + 8 | 0 ) ; HEAP32 [ $vararg_ptr2 >> 2 ] = 2 ; $16 = ( ___syscall146 ( 146 , ( $vararg_buffer | 0 ) ) | 0 ) ; $17 = ( ___syscall_ret ( $16 ) | 0 ) ; $18 = ( $12 | 0 ) == ( $17 | 0 ) ; L1 : do { if ( $18 ) { label = 3 ; } else { $$04756 = 2 ; $$04855 = $12 ; $$04954 = $3 ; $26 = $17 ; while ( 1 ) { $27 = ( $26 | 0 ) < ( 0 ) ; if ( $27 ) { break ; } $35 = ( ( $$04855 ) - ( $26 ) ) | 0 ; $36 = ( ( ( $$04954 ) ) + 4 | 0 ) ; $37 = HEAP32 [ $36 >> 2 ] | 0 ; $38 = ( $26 >>> 0 ) > ( $37 >>> 0 ) ; $39 = ( ( ( $$04954 ) ) + 8 | 0 ) ; $$150 = $38 ? $39 : $$04954 ; $40 = $38 << 31 >> 31 ; $$1 = ( ( $$04756 ) + ( $40 ) ) | 0 ; $41 = $38 ? $37 : 0 ; $$0 = ( ( $26 ) - ( $41 ) ) | 0 ; $42 = HEAP32 [ $$150 >> 2 ] | 0 ; $43 = ( ( $42 ) + ( $$0 ) | 0 ) ; HEAP32 [ $$150 >> 2 ] = $43 ; $44 = ( ( ( $$150 ) ) + 4 | 0 ) ; $45 = HEAP32 [ $44 >> 2 ] | 0 ; $46 = ( ( $45 ) - ( $$0 ) ) | 0 ; HEAP32 [ $44 >> 2 ] = $46 ; $47 = HEAP32 [ $13 >> 2 ] | 0 ; $48 = $$150 ; HEAP32 [ $vararg_buffer3 >> 2 ] = $47 ; $vararg_ptr6 = ( ( ( $vararg_buffer3 ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr6 >> 2 ] = $48 ; $vararg_ptr7 = ( ( ( $vararg_buffer3 ) ) + 8 | 0 ) ; HEAP32 [ $vararg_ptr7 >> 2 ] = $$1 ; $49 = ( ___syscall146 ( 146 , ( $vararg_buffer3 | 0 ) ) | 0 ) ; $50 = ( ___syscall_ret ( $49 ) | 0 ) ; $51 = ( $35 | 0 ) == ( $50 | 0 ) ; if ( $51 ) { label = 3 ; break L1 ; } else { $$04756 = $$1 ; $$04855 = $35 ; $$04954 = $$150 ; $26 = $50 ; } } $28 = ( ( ( $0 ) ) + 16 | 0 ) ; HEAP32 [ $28 >> 2 ] = 0 ; HEAP32 [ $4 >> 2 ] = 0 ; HEAP32 [ $7 >> 2 ] = 0 ; $29 = HEAP32 [ $0 >> 2 ] | 0 ; $30 = $29 | 32 ; HEAP32 [ $0 >> 2 ] = $30 ; $31 = ( $$04756 | 0 ) == ( 2 ) ; if ( $31 ) { $$051 = 0 ; } else { $32 = ( ( ( $$04954 ) ) + 4 | 0 ) ; $33 = HEAP32 [ $32 >> 2 ] | 0 ; $34 = ( ( $2 ) - ( $33 ) ) | 0 ; $$051 = $34 ; } } } while ( 0 ) ; if ( ( label | 0 ) == 3 ) { $19 = ( ( ( $0 ) ) + 44 | 0 ) ; $20 = HEAP32 [ $19 >> 2 ] | 0 ; $21 = ( ( ( $0 ) ) + 48 | 0 ) ; $22 = HEAP32 [ $21 >> 2 ] | 0 ; $23 = ( ( $20 ) + ( $22 ) | 0 ) ; $24 = ( ( ( $0 ) ) + 16 | 0 ) ; HEAP32 [ $24 >> 2 ] = $23 ; $25 = $20 ; HEAP32 [ $4 >> 2 ] = $25 ; HEAP32 [ $7 >> 2 ] = $25 ; $$051 = $2 ; } STACKTOP = sp ; return ( $$051 | 0 ) ; } function _pthread_self ( ) { var label = 0 , sp = 0 ; sp = STACKTOP ; return ( 9720 | 0 ) ; } function _strlen ( $0 ) { $0 = $0 | 0 ; var $$0 = 0 , $$015$lcssa = 0 , $$01519 = 0 , $$1$lcssa = 0 , $$pn = 0 , $$pre = 0 , $$sink = 0 , $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 ; var $21 = 0 , $22 = 0 , $23 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = $0 ; $2 = $1 & 3 ; $3 = ( $2 | 0 ) == ( 0 ) ; L1 : do { if ( $3 ) { $$015$lcssa = $0 ; label = 4 ; } else { $$01519 = $0 ; $23 = $1 ; while ( 1 ) { $4 = HEAP8 [ $$01519 >> 0 ] | 0 ; $5 = ( $4 << 24 >> 24 ) == ( 0 ) ; if ( $5 ) { $$sink = $23 ; break L1 ; } $6 = ( ( ( $$01519 ) ) + 1 | 0 ) ; $7 = $6 ; $8 = $7 & 3 ; $9 = ( $8 | 0 ) == ( 0 ) ; if ( $9 ) { $$015$lcssa = $6 ; label = 4 ; break ; } else { $$01519 = $6 ; $23 = $7 ; } } } } while ( 0 ) ; if ( ( label | 0 ) == 4 ) { $$0 = $$015$lcssa ; while ( 1 ) { $10 = HEAP32 [ $$0 >> 2 ] | 0 ; $11 = ( ( $10 ) + - 16843009 ) | 0 ; $12 = $10 & - 2139062144 ; $13 = $12 ^ - 2139062144 ; $14 = $13 & $11 ; $15 = ( $14 | 0 ) == ( 0 ) ; $16 = ( ( ( $$0 ) ) + 4 | 0 ) ; if ( $15 ) { $$0 = $16 ; } else { break ; } } $17 = $10 & 255 ; $18 = ( $17 << 24 >> 24 ) == ( 0 ) ; if ( $18 ) { $$1$lcssa = $$0 ; } else { $$pn = $$0 ; while ( 1 ) { $19 = ( ( ( $$pn ) ) + 1 | 0 ) ; $$pre = HEAP8 [ $19 >> 0 ] | 0 ; $20 = ( $$pre << 24 >> 24 ) == ( 0 ) ; if ( $20 ) { $$1$lcssa = $19 ; break ; } else { $$pn = $19 ; } } } $21 = $$1$lcssa ; $$sink = $21 ; } $22 = ( ( $$sink ) - ( $1 ) ) | 0 ; return ( $22 | 0 ) ; } function _wcrtomb ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$0 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 ; var $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 ; var $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( $0 | 0 ) == ( 0 | 0 ) ; do { if ( $3 ) { $$0 = 1 ; } else { $4 = ( $1 >>> 0 ) < ( 128 ) ; if ( $4 ) { $5 = $1 & 255 ; HEAP8 [ $0 >> 0 ] = $5 ; $$0 = 1 ; break ; } $6 = ( ___pthread_self ( ) | 0 ) ; $7 = ( ( ( $6 ) ) + 188 | 0 ) ; $8 = HEAP32 [ $7 >> 2 ] | 0 ; $9 = HEAP32 [ $8 >> 2 ] | 0 ; $10 = ( $9 | 0 ) == ( 0 | 0 ) ; if ( $10 ) { $11 = $1 & - 128 ; $12 = ( $11 | 0 ) == ( 57216 ) ; if ( $12 ) { $14 = $1 & 255 ; HEAP8 [ $0 >> 0 ] = $14 ; $$0 = 1 ; break ; } else { $13 = ( ___errno_location ( ) | 0 ) ; HEAP32 [ $13 >> 2 ] = 84 ; $$0 = - 1 ; break ; } } $15 = ( $1 >>> 0 ) < ( 2048 ) ; if ( $15 ) { $16 = $1 >>> 6 ; $17 = $16 | 192 ; $18 = $17 & 255 ; $19 = ( ( ( $0 ) ) + 1 | 0 ) ; HEAP8 [ $0 >> 0 ] = $18 ; $20 = $1 & 63 ; $21 = $20 | 128 ; $22 = $21 & 255 ; HEAP8 [ $19 >> 0 ] = $22 ; $$0 = 2 ; break ; } $23 = ( $1 >>> 0 ) < ( 55296 ) ; $24 = $1 & - 8192 ; $25 = ( $24 | 0 ) == ( 57344 ) ; $or$cond = $23 | $25 ; if ( $or$cond ) { $26 = $1 >>> 12 ; $27 = $26 | 224 ; $28 = $27 & 255 ; $29 = ( ( ( $0 ) ) + 1 | 0 ) ; HEAP8 [ $0 >> 0 ] = $28 ; $30 = $1 >>> 6 ; $31 = $30 & 63 ; $32 = $31 | 128 ; $33 = $32 & 255 ; $34 = ( ( ( $0 ) ) + 2 | 0 ) ; HEAP8 [ $29 >> 0 ] = $33 ; $35 = $1 & 63 ; $36 = $35 | 128 ; $37 = $36 & 255 ; HEAP8 [ $34 >> 0 ] = $37 ; $$0 = 3 ; break ; } $38 = ( ( $1 ) + - 65536 ) | 0 ; $39 = ( $38 >>> 0 ) < ( 1048576 ) ; if ( $39 ) { $40 = $1 >>> 18 ; $41 = $40 | 240 ; $42 = $41 & 255 ; $43 = ( ( ( $0 ) ) + 1 | 0 ) ; HEAP8 [ $0 >> 0 ] = $42 ; $44 = $1 >>> 12 ; $45 = $44 & 63 ; $46 = $45 | 128 ; $47 = $46 & 255 ; $48 = ( ( ( $0 ) ) + 2 | 0 ) ; HEAP8 [ $43 >> 0 ] = $47 ; $49 = $1 >>> 6 ; $50 = $49 & 63 ; $51 = $50 | 128 ; $52 = $51 & 255 ; $53 = ( ( ( $0 ) ) + 3 | 0 ) ; HEAP8 [ $48 >> 0 ] = $52 ; $54 = $1 & 63 ; $55 = $54 | 128 ; $56 = $55 & 255 ; HEAP8 [ $53 >> 0 ] = $56 ; $$0 = 4 ; break ; } else { $57 = ( ___errno_location ( ) | 0 ) ; HEAP32 [ $57 >> 2 ] = 84 ; $$0 = - 1 ; break ; } } } while ( 0 ) ; return ( $$0 | 0 ) ; } function ___pthread_self ( ) { var $0 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $0 = ( _pthread_self ( ) | 0 ) ; return ( $0 | 0 ) ; } function _wctomb ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$0 = 0 , $2 = 0 , $3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $2 ) { $$0 = 0 ; } else { $3 = ( _wcrtomb ( $0 , $1 , 0 ) | 0 ) ; $$0 = $3 ; } return ( $$0 | 0 ) ; } function _vsnprintf ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $$$015 = 0 , $$0 = 0 , $$014 = 0 , $$015 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 ; var $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , dest = 0 , label = 0 , sp = 0 , src = 0 , stop = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 128 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 128 | 0 ) ; $4 = sp + 124 | 0 ; $5 = sp ; dest = $5 ; src = 9964 ; stop = dest + 124 | 0 ; do { HEAP32 [ dest >> 2 ] = HEAP32 [ src >> 2 ] | 0 ; dest = dest + 4 | 0 ; src = src + 4 | 0 ; } while ( ( dest | 0 ) < ( stop | 0 ) ) ; $6 = ( ( $1 ) + - 1 ) | 0 ; $7 = ( $6 >>> 0 ) > ( 2147483646 ) ; if ( $7 ) { $8 = ( $1 | 0 ) == ( 0 ) ; if ( $8 ) { $$014 = $4 ; $$015 = 1 ; label = 4 ; } else { $9 = ( ___errno_location ( ) | 0 ) ; HEAP32 [ $9 >> 2 ] = 75 ; $$0 = - 1 ; } } else { $$014 = $0 ; $$015 = $1 ; label = 4 ; } if ( ( label | 0 ) == 4 ) { $10 = $$014 ; $11 = ( - 2 - ( $10 ) ) | 0 ; $12 = ( $$015 >>> 0 ) > ( $11 >>> 0 ) ; $$$015 = $12 ? $11 : $$015 ; $13 = ( ( ( $5 ) ) + 48 | 0 ) ; HEAP32 [ $13 >> 2 ] = $$$015 ; $14 = ( ( ( $5 ) ) + 20 | 0 ) ; HEAP32 [ $14 >> 2 ] = $$014 ; $15 = ( ( ( $5 ) ) + 44 | 0 ) ; HEAP32 [ $15 >> 2 ] = $$014 ; $16 = ( ( $$014 ) + ( $$$015 ) | 0 ) ; $17 = ( ( ( $5 ) ) + 16 | 0 ) ; HEAP32 [ $17 >> 2 ] = $16 ; $18 = ( ( ( $5 ) ) + 28 | 0 ) ; HEAP32 [ $18 >> 2 ] = $16 ; $19 = ( _vfprintf ( $5 , $2 , $3 ) | 0 ) ; $20 = ( $$$015 | 0 ) == ( 0 ) ; if ( $20 ) { $$0 = $19 ; } else { $21 = HEAP32 [ $14 >> 2 ] | 0 ; $22 = HEAP32 [ $17 >> 2 ] | 0 ; $23 = ( $21 | 0 ) == ( $22 | 0 ) ; $24 = $23 << 31 >> 31 ; $25 = ( ( $21 ) + ( $24 ) | 0 ) ; HEAP8 [ $25 >> 0 ] = 0 ; $$0 = $19 ; } } STACKTOP = sp ; return ( $$0 | 0 ) ; } function _vfprintf ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$ = 0 , $$0 = 0 , $$1 = 0 , $$1$ = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 ; var $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $5 = 0 , $6 = 0 , $7 = 0 ; var $8 = 0 , $9 = 0 , $vacopy_currentptr = 0 , dest = 0 , label = 0 , sp = 0 , stop = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 224 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 224 | 0 ) ; $3 = sp + 120 | 0 ; $4 = sp + 80 | 0 ; $5 = sp ; $6 = sp + 136 | 0 ; dest = $4 ; stop = dest + 40 | 0 ; do { HEAP32 [ dest >> 2 ] = 0 | 0 ; dest = dest + 4 | 0 ; } while ( ( dest | 0 ) < ( stop | 0 ) ) ; $vacopy_currentptr = HEAP32 [ $2 >> 2 ] | 0 ; HEAP32 [ $3 >> 2 ] = $vacopy_currentptr ; $7 = ( _printf_core ( 0 , $1 , $3 , $5 , $4 ) | 0 ) ; $8 = ( $7 | 0 ) < ( 0 ) ; if ( $8 ) { $$0 = - 1 ; } else { $9 = ( ( ( $0 ) ) + 76 | 0 ) ; $10 = HEAP32 [ $9 >> 2 ] | 0 ; $11 = ( $10 | 0 ) > ( - 1 ) ; if ( $11 ) { $12 = ( ___lockfile ( $0 ) | 0 ) ; $39 = $12 ; } else { $39 = 0 ; } $13 = HEAP32 [ $0 >> 2 ] | 0 ; $14 = $13 & 32 ; $15 = ( ( ( $0 ) ) + 74 | 0 ) ; $16 = HEAP8 [ $15 >> 0 ] | 0 ; $17 = ( $16 << 24 >> 24 ) < ( 1 ) ; if ( $17 ) { $18 = $13 & - 33 ; HEAP32 [ $0 >> 2 ] = $18 ; } $19 = ( ( ( $0 ) ) + 48 | 0 ) ; $20 = HEAP32 [ $19 >> 2 ] | 0 ; $21 = ( $20 | 0 ) == ( 0 ) ; if ( $21 ) { $23 = ( ( ( $0 ) ) + 44 | 0 ) ; $24 = HEAP32 [ $23 >> 2 ] | 0 ; HEAP32 [ $23 >> 2 ] = $6 ; $25 = ( ( ( $0 ) ) + 28 | 0 ) ; HEAP32 [ $25 >> 2 ] = $6 ; $26 = ( ( ( $0 ) ) + 20 | 0 ) ; HEAP32 [ $26 >> 2 ] = $6 ; HEAP32 [ $19 >> 2 ] = 80 ; $27 = ( ( ( $6 ) ) + 80 | 0 ) ; $28 = ( ( ( $0 ) ) + 16 | 0 ) ; HEAP32 [ $28 >> 2 ] = $27 ; $29 = ( _printf_core ( $0 , $1 , $3 , $5 , $4 ) | 0 ) ; $30 = ( $24 | 0 ) == ( 0 | 0 ) ; if ( $30 ) { $$1 = $29 ; } else { $31 = ( ( ( $0 ) ) + 36 | 0 ) ; $32 = HEAP32 [ $31 >> 2 ] | 0 ; ( FUNCTION_TABLE_iiii [ $32 & 127 ] ( $0 , 0 , 0 ) | 0 ) ; $33 = HEAP32 [ $26 >> 2 ] | 0 ; $34 = ( $33 | 0 ) == ( 0 | 0 ) ; $$ = $34 ? - 1 : $29 ; HEAP32 [ $23 >> 2 ] = $24 ; HEAP32 [ $19 >> 2 ] = 0 ; HEAP32 [ $28 >> 2 ] = 0 ; HEAP32 [ $25 >> 2 ] = 0 ; HEAP32 [ $26 >> 2 ] = 0 ; $$1 = $$ ; } } else { $22 = ( _printf_core ( $0 , $1 , $3 , $5 , $4 ) | 0 ) ; $$1 = $22 ; } $35 = HEAP32 [ $0 >> 2 ] | 0 ; $36 = $35 & 32 ; $37 = ( $36 | 0 ) == ( 0 ) ; $$1$ = $37 ? $$1 : - 1 ; $38 = $35 | $14 ; HEAP32 [ $0 >> 2 ] = $38 ; $40 = ( $39 | 0 ) == ( 0 ) ; if ( ! ( $40 ) ) { ___unlockfile ( $0 ) ; } $$0 = $$1$ ; } STACKTOP = sp ; return ( $$0 | 0 ) ; } function _printf_core ( $0 , $1 , $2 , $3 , $4 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; $4 = $4 | 0 ; var $$ = 0 , $$$ = 0 , $$$0259 = 0 , $$$0262 = 0 , $$$4266 = 0 , $$$5 = 0 , $$0 = 0 , $$0228 = 0 , $$0228$ = 0 , $$0229316 = 0 , $$0232 = 0 , $$0235 = 0 , $$0237 = 0 , $$0240$lcssa = 0 , $$0240$lcssa356 = 0 , $$0240315 = 0 , $$0243 = 0 , $$0247 = 0 , $$0249$lcssa = 0 , $$0249303 = 0 ; var $$0252 = 0 , $$0253 = 0 , $$0254 = 0 , $$0254$$0254$ = 0 , $$0259 = 0 , $$0262$lcssa = 0 , $$0262309 = 0 , $$0269 = 0 , $$0269$phi = 0 , $$1 = 0 , $$1230327 = 0 , $$1233 = 0 , $$1236 = 0 , $$1238 = 0 , $$1241326 = 0 , $$1244314 = 0 , $$1248 = 0 , $$1250 = 0 , $$1255 = 0 , $$1260 = 0 ; var $$1263 = 0 , $$1263$ = 0 , $$1270 = 0 , $$2 = 0 , $$2234 = 0 , $$2239 = 0 , $$2242$lcssa = 0 , $$2242302 = 0 , $$2245 = 0 , $$2251 = 0 , $$2256 = 0 , $$2256$ = 0 , $$2256$$$2256 = 0 , $$2261 = 0 , $$2271 = 0 , $$279$ = 0 , $$286 = 0 , $$287 = 0 , $$3257 = 0 , $$3265 = 0 ; var $$3272 = 0 , $$3300 = 0 , $$4258354 = 0 , $$4266 = 0 , $$5 = 0 , $$6268 = 0 , $$lcssa291 = 0 , $$lcssa292 = 0 , $$pre = 0 , $$pre342 = 0 , $$pre344 = 0 , $$pre345 = 0 , $$pre345$pre = 0 , $$pre346 = 0 , $$pre348 = 0 , $$sink = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 ; var $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 ; var $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 ; var $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 ; var $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 , $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 ; var $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 , $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 ; var $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 , $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 ; var $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 , $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 ; var $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 , $244 = 0 , $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 ; var $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 , $258 = 0 , $259 = 0 , $26 = 0 , $260 = 0 , $261 = 0 , $262 = 0 , $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 ; var $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 , $270 = 0 , $271 = 0 , $272 = 0 , $273 = 0 , $274 = 0 , $275 = 0 , $276 = 0 , $277 = 0 , $278 = 0 , $279 = 0 , $28 = 0 , $280 = 0 , $281 = 0 , $282 = 0 , $283 = 0 , $284 = 0 ; var $285 = 0 , $286 = 0 , $287 = 0 , $288 = 0 , $289 = 0 , $29 = 0 , $290 = 0 , $291 = 0 , $292 = 0 , $293 = 0 , $294 = 0 , $295 = 0 , $296 = 0 , $297 = 0 , $298 = 0 , $299 = 0 , $30 = 0 , $300 = 0 , $301 = 0 , $302 = 0 ; var $303 = 0 , $304 = 0 , $305 = 0 , $306 = 0 , $307 = 0 , $308 = 0 , $309 = 0 , $31 = 0 , $310 = 0 , $311 = 0 , $312 = 0 , $313 = 0 , $314 = 0 , $315 = 0 , $316 = 0 , $317 = 0 , $318 = 0 , $319 = 0 , $32 = 0 , $320 = 0 ; var $321 = 0 , $322 = 0 , $323 = 0 , $324 = 0 , $325 = 0 , $326 = 0 , $327 = 0 , $328 = 0 , $329 = 0 , $33 = 0 , $330 = 0 , $331 = 0 , $332 = 0 , $333 = 0 , $334 = 0 , $335 = 0 , $336 = 0 , $337 = 0 , $338 = 0 , $339 = 0.0 ; var $34 = 0 , $340 = 0 , $341 = 0 , $342 = 0 , $343 = 0 , $344 = 0 , $345 = 0 , $346 = 0 , $347 = 0 , $348 = 0 , $349 = 0 , $35 = 0 , $350 = 0 , $351 = 0 , $352 = 0 , $353 = 0 , $354 = 0 , $355 = 0 , $356 = 0 , $357 = 0 ; var $358 = 0 , $359 = 0 , $36 = 0 , $360 = 0 , $361 = 0 , $362 = 0 , $363 = 0 , $364 = 0 , $365 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 ; var $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 ; var $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 ; var $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $arglist_current = 0 , $arglist_current2 = 0 , $arglist_next = 0 ; var $arglist_next3 = 0 , $brmerge = 0 , $brmerge308 = 0 , $expanded = 0 , $expanded10 = 0 , $expanded11 = 0 , $expanded13 = 0 , $expanded14 = 0 , $expanded15 = 0 , $expanded4 = 0 , $expanded6 = 0 , $expanded7 = 0 , $expanded8 = 0 , $or$cond = 0 , $or$cond276 = 0 , $or$cond278 = 0 , $or$cond281 = 0 , $storemerge274 = 0 , $trunc = 0 , label = 0 ; var sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 64 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 64 | 0 ) ; $5 = sp + 16 | 0 ; $6 = sp ; $7 = sp + 24 | 0 ; $8 = sp + 8 | 0 ; $9 = sp + 20 | 0 ; HEAP32 [ $5 >> 2 ] = $1 ; $10 = ( $0 | 0 ) != ( 0 | 0 ) ; $11 = ( ( ( $7 ) ) + 40 | 0 ) ; $12 = $11 ; $13 = ( ( ( $7 ) ) + 39 | 0 ) ; $14 = ( ( ( $8 ) ) + 4 | 0 ) ; $$0243 = 0 ; $$0247 = 0 ; $$0269 = 0 ; L1 : while ( 1 ) { $15 = ( $$0247 | 0 ) > ( - 1 ) ; do { if ( $15 ) { $16 = ( 2147483647 - ( $$0247 ) ) | 0 ; $17 = ( $$0243 | 0 ) > ( $16 | 0 ) ; if ( $17 ) { $18 = ( ___errno_location ( ) | 0 ) ; HEAP32 [ $18 >> 2 ] = 75 ; $$1248 = - 1 ; break ; } else { $19 = ( ( $$0243 ) + ( $$0247 ) ) | 0 ; $$1248 = $19 ; break ; } } else { $$1248 = $$0247 ; } } while ( 0 ) ; $20 = HEAP32 [ $5 >> 2 ] | 0 ; $21 = HEAP8 [ $20 >> 0 ] | 0 ; $22 = ( $21 << 24 >> 24 ) == ( 0 ) ; if ( $22 ) { label = 88 ; break ; } else { $23 = $21 ; $25 = $20 ; } L9 : while ( 1 ) { switch ( $23 << 24 >> 24 ) { case 37 : { $$0249303 = $25 ; $27 = $25 ; label = 9 ; break L9 ; break ; } case 0 : { $$0249$lcssa = $25 ; break L9 ; break ; } default : { } } $24 = ( ( ( $25 ) ) + 1 | 0 ) ; HEAP32 [ $5 >> 2 ] = $24 ; $$pre = HEAP8 [ $24 >> 0 ] | 0 ; $23 = $$pre ; $25 = $24 ; } L12 : do { if ( ( label | 0 ) == 9 ) { while ( 1 ) { label = 0 ; $26 = ( ( ( $27 ) ) + 1 | 0 ) ; $28 = HEAP8 [ $26 >> 0 ] | 0 ; $29 = ( $28 << 24 >> 24 ) == ( 37 ) ; if ( ! ( $29 ) ) { $$0249$lcssa = $$0249303 ; break L12 ; } $30 = ( ( ( $$0249303 ) ) + 1 | 0 ) ; $31 = ( ( ( $27 ) ) + 2 | 0 ) ; HEAP32 [ $5 >> 2 ] = $31 ; $32 = HEAP8 [ $31 >> 0 ] | 0 ; $33 = ( $32 << 24 >> 24 ) == ( 37 ) ; if ( $33 ) { $$0249303 = $30 ; $27 = $31 ; label = 9 ; } else { $$0249$lcssa = $30 ; break ; } } } } while ( 0 ) ; $34 = $$0249$lcssa ; $35 = $20 ; $36 = ( ( $34 ) - ( $35 ) ) | 0 ; if ( $10 ) { _out ( $0 , $20 , $36 ) ; } $37 = ( $36 | 0 ) == ( 0 ) ; if ( ! ( $37 ) ) { $$0269$phi = $$0269 ; $$0243 = $36 ; $$0247 = $$1248 ; $$0269 = $$0269$phi ; continue ; } $38 = HEAP32 [ $5 >> 2 ] | 0 ; $39 = ( ( ( $38 ) ) + 1 | 0 ) ; $40 = HEAP8 [ $39 >> 0 ] | 0 ; $41 = $40 << 24 >> 24 ; $42 = ( _isdigit ( $41 ) | 0 ) ; $43 = ( $42 | 0 ) == ( 0 ) ; $$pre342 = HEAP32 [ $5 >> 2 ] | 0 ; if ( $43 ) { $$0253 = - 1 ; $$1270 = $$0269 ; $$sink = 1 ; } else { $44 = ( ( ( $$pre342 ) ) + 2 | 0 ) ; $45 = HEAP8 [ $44 >> 0 ] | 0 ; $46 = ( $45 << 24 >> 24 ) == ( 36 ) ; if ( $46 ) { $47 = ( ( ( $$pre342 ) ) + 1 | 0 ) ; $48 = HEAP8 [ $47 >> 0 ] | 0 ; $49 = $48 << 24 >> 24 ; $50 = ( ( $49 ) + - 48 ) | 0 ; $$0253 = $50 ; $$1270 = 1 ; $$sink = 3 ; } else { $$0253 = - 1 ; $$1270 = $$0269 ; $$sink = 1 ; } } $51 = ( ( $$pre342 ) + ( $$sink ) | 0 ) ; HEAP32 [ $5 >> 2 ] = $51 ; $52 = HEAP8 [ $51 >> 0 ] | 0 ; $53 = $52 << 24 >> 24 ; $54 = ( ( $53 ) + - 32 ) | 0 ; $55 = ( $54 >>> 0 ) > ( 31 ) ; $56 = 1 << $54 ; $57 = $56 & 75913 ; $58 = ( $57 | 0 ) == ( 0 ) ; $brmerge308 = $55 | $58 ; if ( $brmerge308 ) { $$0262$lcssa = 0 ; $$lcssa291 = $52 ; $$lcssa292 = $51 ; } else { $$0262309 = 0 ; $60 = $52 ; $65 = $51 ; while ( 1 ) { $59 = $60 << 24 >> 24 ; $61 = ( ( $59 ) + - 32 ) | 0 ; $62 = 1 << $61 ; $63 = $62 | $$0262309 ; $64 = ( ( ( $65 ) ) + 1 | 0 ) ; HEAP32 [ $5 >> 2 ] = $64 ; $66 = HEAP8 [ $64 >> 0 ] | 0 ; $67 = $66 << 24 >> 24 ; $68 = ( ( $67 ) + - 32 ) | 0 ; $69 = ( $68 >>> 0 ) > ( 31 ) ; $70 = 1 << $68 ; $71 = $70 & 75913 ; $72 = ( $71 | 0 ) == ( 0 ) ; $brmerge = $69 | $72 ; if ( $brmerge ) { $$0262$lcssa = $63 ; $$lcssa291 = $66 ; $$lcssa292 = $64 ; break ; } else { $$0262309 = $63 ; $60 = $66 ; $65 = $64 ; } } } $73 = ( $$lcssa291 << 24 >> 24 ) == ( 42 ) ; if ( $73 ) { $74 = ( ( ( $$lcssa292 ) ) + 1 | 0 ) ; $75 = HEAP8 [ $74 >> 0 ] | 0 ; $76 = $75 << 24 >> 24 ; $77 = ( _isdigit ( $76 ) | 0 ) ; $78 = ( $77 | 0 ) == ( 0 ) ; if ( $78 ) { label = 23 ; } else { $79 = HEAP32 [ $5 >> 2 ] | 0 ; $80 = ( ( ( $79 ) ) + 2 | 0 ) ; $81 = HEAP8 [ $80 >> 0 ] | 0 ; $82 = ( $81 << 24 >> 24 ) == ( 36 ) ; if ( $82 ) { $83 = ( ( ( $79 ) ) + 1 | 0 ) ; $84 = HEAP8 [ $83 >> 0 ] | 0 ; $85 = $84 << 24 >> 24 ; $86 = ( ( $85 ) + - 48 ) | 0 ; $87 = ( ( $4 ) + ( $86 << 2 ) | 0 ) ; HEAP32 [ $87 >> 2 ] = 10 ; $88 = HEAP8 [ $83 >> 0 ] | 0 ; $89 = $88 << 24 >> 24 ; $90 = ( ( $89 ) + - 48 ) | 0 ; $91 = ( ( $3 ) + ( $90 << 3 ) | 0 ) ; $92 = $91 ; $93 = $92 ; $94 = HEAP32 [ $93 >> 2 ] | 0 ; $95 = ( ( $92 ) + 4 ) | 0 ; $96 = $95 ; $97 = HEAP32 [ $96 >> 2 ] | 0 ; $98 = ( ( ( $79 ) ) + 3 | 0 ) ; $$0259 = $94 ; $$2271 = 1 ; $storemerge274 = $98 ; } else { label = 23 ; } } if ( ( label | 0 ) == 23 ) { label = 0 ; $99 = ( $$1270 | 0 ) == ( 0 ) ; if ( ! ( $99 ) ) { $$0 = - 1 ; break ; } if ( $10 ) { $arglist_current = HEAP32 [ $2 >> 2 ] | 0 ; $100 = $arglist_current ; $101 = ( ( 0 ) + 4 | 0 ) ; $expanded4 = $101 ; $expanded = ( ( $expanded4 ) - 1 ) | 0 ; $102 = ( ( $100 ) + ( $expanded ) ) | 0 ; $103 = ( ( 0 ) + 4 | 0 ) ; $expanded8 = $103 ; $expanded7 = ( ( $expanded8 ) - 1 ) | 0 ; $expanded6 = $expanded7 ^ - 1 ; $104 = $102 & $expanded6 ; $105 = $104 ; $106 = HEAP32 [ $105 >> 2 ] | 0 ; $arglist_next = ( ( ( $105 ) ) + 4 | 0 ) ; HEAP32 [ $2 >> 2 ] = $arglist_next ; $363 = $106 ; } else { $363 = 0 ; } $107 = HEAP32 [ $5 >> 2 ] | 0 ; $108 = ( ( ( $107 ) ) + 1 | 0 ) ; $$0259 = $363 ; $$2271 = 0 ; $storemerge274 = $108 ; } HEAP32 [ $5 >> 2 ] = $storemerge274 ; $109 = ( $$0259 | 0 ) < ( 0 ) ; $110 = $$0262$lcssa | 8192 ; $111 = ( 0 - ( $$0259 ) ) | 0 ; $$$0262 = $109 ? $110 : $$0262$lcssa ; $$$0259 = $109 ? $111 : $$0259 ; $$1260 = $$$0259 ; $$1263 = $$$0262 ; $$3272 = $$2271 ; $115 = $storemerge274 ; } else { $112 = ( _getint ( $5 ) | 0 ) ; $113 = ( $112 | 0 ) < ( 0 ) ; if ( $113 ) { $$0 = - 1 ; break ; } $$pre344 = HEAP32 [ $5 >> 2 ] | 0 ; $$1260 = $112 ; $$1263 = $$0262$lcssa ; $$3272 = $$1270 ; $115 = $$pre344 ; } $114 = HEAP8 [ $115 >> 0 ] | 0 ; $116 = ( $114 << 24 >> 24 ) == ( 46 ) ; do { if ( $116 ) { $117 = ( ( ( $115 ) ) + 1 | 0 ) ; $118 = HEAP8 [ $117 >> 0 ] | 0 ; $119 = ( $118 << 24 >> 24 ) == ( 42 ) ; if ( ! ( $119 ) ) { $155 = ( ( ( $115 ) ) + 1 | 0 ) ; HEAP32 [ $5 >> 2 ] = $155 ; $156 = ( _getint ( $5 ) | 0 ) ; $$pre345$pre = HEAP32 [ $5 >> 2 ] | 0 ; $$0254 = $156 ; $$pre345 = $$pre345$pre ; break ; } $120 = ( ( ( $115 ) ) + 2 | 0 ) ; $121 = HEAP8 [ $120 >> 0 ] | 0 ; $122 = $121 << 24 >> 24 ; $123 = ( _isdigit ( $122 ) | 0 ) ; $124 = ( $123 | 0 ) == ( 0 ) ; if ( ! ( $124 ) ) { $125 = HEAP32 [ $5 >> 2 ] | 0 ; $126 = ( ( ( $125 ) ) + 3 | 0 ) ; $127 = HEAP8 [ $126 >> 0 ] | 0 ; $128 = ( $127 << 24 >> 24 ) == ( 36 ) ; if ( $128 ) { $129 = ( ( ( $125 ) ) + 2 | 0 ) ; $130 = HEAP8 [ $129 >> 0 ] | 0 ; $131 = $130 << 24 >> 24 ; $132 = ( ( $131 ) + - 48 ) | 0 ; $133 = ( ( $4 ) + ( $132 << 2 ) | 0 ) ; HEAP32 [ $133 >> 2 ] = 10 ; $134 = HEAP8 [ $129 >> 0 ] | 0 ; $135 = $134 << 24 >> 24 ; $136 = ( ( $135 ) + - 48 ) | 0 ; $137 = ( ( $3 ) + ( $136 << 3 ) | 0 ) ; $138 = $137 ; $139 = $138 ; $140 = HEAP32 [ $139 >> 2 ] | 0 ; $141 = ( ( $138 ) + 4 ) | 0 ; $142 = $141 ; $143 = HEAP32 [ $142 >> 2 ] | 0 ; $144 = ( ( ( $125 ) ) + 4 | 0 ) ; HEAP32 [ $5 >> 2 ] = $144 ; $$0254 = $140 ; $$pre345 = $144 ; break ; } } $145 = ( $$3272 | 0 ) == ( 0 ) ; if ( ! ( $145 ) ) { $$0 = - 1 ; break L1 ; } if ( $10 ) { $arglist_current2 = HEAP32 [ $2 >> 2 ] | 0 ; $146 = $arglist_current2 ; $147 = ( ( 0 ) + 4 | 0 ) ; $expanded11 = $147 ; $expanded10 = ( ( $expanded11 ) - 1 ) | 0 ; $148 = ( ( $146 ) + ( $expanded10 ) ) | 0 ; $149 = ( ( 0 ) + 4 | 0 ) ; $expanded15 = $149 ; $expanded14 = ( ( $expanded15 ) - 1 ) | 0 ; $expanded13 = $expanded14 ^ - 1 ; $150 = $148 & $expanded13 ; $151 = $150 ; $152 = HEAP32 [ $151 >> 2 ] | 0 ; $arglist_next3 = ( ( ( $151 ) ) + 4 | 0 ) ; HEAP32 [ $2 >> 2 ] = $arglist_next3 ; $364 = $152 ; } else { $364 = 0 ; } $153 = HEAP32 [ $5 >> 2 ] | 0 ; $154 = ( ( ( $153 ) ) + 2 | 0 ) ; HEAP32 [ $5 >> 2 ] = $154 ; $$0254 = $364 ; $$pre345 = $154 ; } else { $$0254 = - 1 ; $$pre345 = $115 ; } } while ( 0 ) ; $$0252 = 0 ; $158 = $$pre345 ; while ( 1 ) { $157 = HEAP8 [ $158 >> 0 ] | 0 ; $159 = $157 << 24 >> 24 ; $160 = ( ( $159 ) + - 65 ) | 0 ; $161 = ( $160 >>> 0 ) > ( 57 ) ; if ( $161 ) { $$0 = - 1 ; break L1 ; } $162 = ( ( ( $158 ) ) + 1 | 0 ) ; HEAP32 [ $5 >> 2 ] = $162 ; $163 = HEAP8 [ $158 >> 0 ] | 0 ; $164 = $163 << 24 >> 24 ; $165 = ( ( $164 ) + - 65 ) | 0 ; $166 = ( ( 30821 + ( ( $$0252 * 58 ) | 0 ) | 0 ) + ( $165 ) | 0 ) ; $167 = HEAP8 [ $166 >> 0 ] | 0 ; $168 = $167 & 255 ; $169 = ( ( $168 ) + - 1 ) | 0 ; $170 = ( $169 >>> 0 ) < ( 8 ) ; if ( $170 ) { $$0252 = $168 ; $158 = $162 ; } else { break ; } } $171 = ( $167 << 24 >> 24 ) == ( 0 ) ; if ( $171 ) { $$0 = - 1 ; break ; } $172 = ( $167 << 24 >> 24 ) == ( 19 ) ; $173 = ( $$0253 | 0 ) > ( - 1 ) ; do { if ( $172 ) { if ( $173 ) { $$0 = - 1 ; break L1 ; } else { label = 50 ; } } else { if ( $173 ) { $174 = ( ( $4 ) + ( $$0253 << 2 ) | 0 ) ; HEAP32 [ $174 >> 2 ] = $168 ; $175 = ( ( $3 ) + ( $$0253 << 3 ) | 0 ) ; $176 = $175 ; $177 = $176 ; $178 = HEAP32 [ $177 >> 2 ] | 0 ; $179 = ( ( $176 ) + 4 ) | 0 ; $180 = $179 ; $181 = HEAP32 [ $180 >> 2 ] | 0 ; $182 = $6 ; $183 = $182 ; HEAP32 [ $183 >> 2 ] = $178 ; $184 = ( ( $182 ) + 4 ) | 0 ; $185 = $184 ; HEAP32 [ $185 >> 2 ] = $181 ; label = 50 ; break ; } if ( ! ( $10 ) ) { $$0 = 0 ; break L1 ; } _pop_arg ( $6 , $168 , $2 ) ; $$pre346 = HEAP32 [ $5 >> 2 ] | 0 ; $187 = $$pre346 ; } } while ( 0 ) ; if ( ( label | 0 ) == 50 ) { label = 0 ; if ( $10 ) { $187 = $162 ; } else { $$0243 = 0 ; $$0247 = $$1248 ; $$0269 = $$3272 ; continue ; } } $186 = ( ( ( $187 ) ) + - 1 | 0 ) ; $188 = HEAP8 [ $186 >> 0 ] | 0 ; $189 = $188 << 24 >> 24 ; $190 = ( $$0252 | 0 ) != ( 0 ) ; $191 = $189 & 15 ; $192 = ( $191 | 0 ) == ( 3 ) ; $or$cond276 = $190 & $192 ; $193 = $189 & - 33 ; $$0235 = $or$cond276 ? $193 : $189 ; $194 = $$1263 & 8192 ; $195 = ( $194 | 0 ) == ( 0 ) ; $196 = $$1263 & - 65537 ; $$1263$ = $195 ? $$1263 : $196 ; L73 : do { switch ( $$0235 | 0 ) { case 110 : { $trunc = $$0252 & 255 ; switch ( $trunc << 24 >> 24 ) { case 0 : { $203 = HEAP32 [ $6 >> 2 ] | 0 ; HEAP32 [ $203 >> 2 ] = $$1248 ; $$0243 = 0 ; $$0247 = $$1248 ; $$0269 = $$3272 ; continue L1 ; break ; } case 1 : { $204 = HEAP32 [ $6 >> 2 ] | 0 ; HEAP32 [ $204 >> 2 ] = $$1248 ; $$0243 = 0 ; $$0247 = $$1248 ; $$0269 = $$3272 ; continue L1 ; break ; } case 2 : { $205 = ( $$1248 | 0 ) < ( 0 ) ; $206 = $205 << 31 >> 31 ; $207 = HEAP32 [ $6 >> 2 ] | 0 ; $208 = $207 ; $209 = $208 ; HEAP32 [ $209 >> 2 ] = $$1248 ; $210 = ( ( $208 ) + 4 ) | 0 ; $211 = $210 ; HEAP32 [ $211 >> 2 ] = $206 ; $$0243 = 0 ; $$0247 = $$1248 ; $$0269 = $$3272 ; continue L1 ; break ; } case 3 : { $212 = $$1248 & 65535 ; $213 = HEAP32 [ $6 >> 2 ] | 0 ; HEAP16 [ $213 >> 1 ] = $212 ; $$0243 = 0 ; $$0247 = $$1248 ; $$0269 = $$3272 ; continue L1 ; break ; } case 4 : { $214 = $$1248 & 255 ; $215 = HEAP32 [ $6 >> 2 ] | 0 ; HEAP8 [ $215 >> 0 ] = $214 ; $$0243 = 0 ; $$0247 = $$1248 ; $$0269 = $$3272 ; continue L1 ; break ; } case 6 : { $216 = HEAP32 [ $6 >> 2 ] | 0 ; HEAP32 [ $216 >> 2 ] = $$1248 ; $$0243 = 0 ; $$0247 = $$1248 ; $$0269 = $$3272 ; continue L1 ; break ; } case 7 : { $217 = ( $$1248 | 0 ) < ( 0 ) ; $218 = $217 << 31 >> 31 ; $219 = HEAP32 [ $6 >> 2 ] | 0 ; $220 = $219 ; $221 = $220 ; HEAP32 [ $221 >> 2 ] = $$1248 ; $222 = ( ( $220 ) + 4 ) | 0 ; $223 = $222 ; HEAP32 [ $223 >> 2 ] = $218 ; $$0243 = 0 ; $$0247 = $$1248 ; $$0269 = $$3272 ; continue L1 ; break ; } default : { $$0243 = 0 ; $$0247 = $$1248 ; $$0269 = $$3272 ; continue L1 ; } } break ; } case 112 : { $224 = ( $$0254 >>> 0 ) > ( 8 ) ; $225 = $224 ? $$0254 : 8 ; $226 = $$1263$ | 8 ; $$1236 = 120 ; $$1255 = $225 ; $$3265 = $226 ; label = 62 ; break ; } case 88 : case 120 : { $$1236 = $$0235 ; $$1255 = $$0254 ; $$3265 = $$1263$ ; label = 62 ; break ; } case 111 : { $242 = $6 ; $243 = $242 ; $244 = HEAP32 [ $243 >> 2 ] | 0 ; $245 = ( ( $242 ) + 4 ) | 0 ; $246 = $245 ; $247 = HEAP32 [ $246 >> 2 ] | 0 ; $248 = ( _fmt_o ( $244 , $247 , $11 ) | 0 ) ; $249 = $$1263$ & 8 ; $250 = ( $249 | 0 ) == ( 0 ) ; $251 = $248 ; $252 = ( ( $12 ) - ( $251 ) ) | 0 ; $253 = ( $$0254 | 0 ) > ( $252 | 0 ) ; $254 = ( ( $252 ) + 1 ) | 0 ; $255 = $250 | $253 ; $$0254$$0254$ = $255 ? $$0254 : $254 ; $$0228 = $248 ; $$1233 = 0 ; $$1238 = 31285 ; $$2256 = $$0254$$0254$ ; $$4266 = $$1263$ ; $280 = $244 ; $282 = $247 ; label = 68 ; break ; } case 105 : case 100 : { $256 = $6 ; $257 = $256 ; $258 = HEAP32 [ $257 >> 2 ] | 0 ; $259 = ( ( $256 ) + 4 ) | 0 ; $260 = $259 ; $261 = HEAP32 [ $260 >> 2 ] | 0 ; $262 = ( $261 | 0 ) < ( 0 ) ; if ( $262 ) { $263 = ( _i64Subtract ( 0 , 0 , ( $258 | 0 ) , ( $261 | 0 ) ) | 0 ) ; $264 = tempRet0 ; $265 = $6 ; $266 = $265 ; HEAP32 [ $266 >> 2 ] = $263 ; $267 = ( ( $265 ) + 4 ) | 0 ; $268 = $267 ; HEAP32 [ $268 >> 2 ] = $264 ; $$0232 = 1 ; $$0237 = 31285 ; $275 = $263 ; $276 = $264 ; label = 67 ; break L73 ; } else { $269 = $$1263$ & 2048 ; $270 = ( $269 | 0 ) == ( 0 ) ; $271 = $$1263$ & 1 ; $272 = ( $271 | 0 ) == ( 0 ) ; $$ = $272 ? 31285 : ( 31287 ) ; $$$ = $270 ? $$ : ( 31286 ) ; $273 = $$1263$ & 2049 ; $274 = ( $273 | 0 ) != ( 0 ) ; $$279$ = $274 & 1 ; $$0232 = $$279$ ; $$0237 = $$$ ; $275 = $258 ; $276 = $261 ; label = 67 ; break L73 ; } break ; } case 117 : { $197 = $6 ; $198 = $197 ; $199 = HEAP32 [ $198 >> 2 ] | 0 ; $200 = ( ( $197 ) + 4 ) | 0 ; $201 = $200 ; $202 = HEAP32 [ $201 >> 2 ] | 0 ; $$0232 = 0 ; $$0237 = 31285 ; $275 = $199 ; $276 = $202 ; label = 67 ; break ; } case 99 : { $292 = $6 ; $293 = $292 ; $294 = HEAP32 [ $293 >> 2 ] | 0 ; $295 = ( ( $292 ) + 4 ) | 0 ; $296 = $295 ; $297 = HEAP32 [ $296 >> 2 ] | 0 ; $298 = $294 & 255 ; HEAP8 [ $13 >> 0 ] = $298 ; $$2 = $13 ; $$2234 = 0 ; $$2239 = 31285 ; $$2251 = $11 ; $$5 = 1 ; $$6268 = $196 ; break ; } case 109 : { $299 = ( ___errno_location ( ) | 0 ) ; $300 = HEAP32 [ $299 >> 2 ] | 0 ; $301 = ( _strerror ( $300 ) | 0 ) ; $$1 = $301 ; label = 72 ; break ; } case 115 : { $302 = HEAP32 [ $6 >> 2 ] | 0 ; $303 = ( $302 | 0 ) != ( 0 | 0 ) ; $304 = $303 ? $302 : 31295 ; $$1 = $304 ; label = 72 ; break ; } case 67 : { $311 = $6 ; $312 = $311 ; $313 = HEAP32 [ $312 >> 2 ] | 0 ; $314 = ( ( $311 ) + 4 ) | 0 ; $315 = $314 ; $316 = HEAP32 [ $315 >> 2 ] | 0 ; HEAP32 [ $8 >> 2 ] = $313 ; HEAP32 [ $14 >> 2 ] = 0 ; HEAP32 [ $6 >> 2 ] = $8 ; $$4258354 = - 1 ; $365 = $8 ; label = 76 ; break ; } case 83 : { $$pre348 = HEAP32 [ $6 >> 2 ] | 0 ; $317 = ( $$0254 | 0 ) == ( 0 ) ; if ( $317 ) { _pad ( $0 , 32 , $$1260 , 0 , $$1263$ ) ; $$0240$lcssa356 = 0 ; label = 85 ; } else { $$4258354 = $$0254 ; $365 = $$pre348 ; label = 76 ; } break ; } case 65 : case 71 : case 70 : case 69 : case 97 : case 103 : case 102 : case 101 : { $339 = + HEAPF64 [ $6 >> 3 ] ; $340 = ( _fmt_fp ( $0 , $339 , $$1260 , $$0254 , $$1263$ , $$0235 ) | 0 ) ; $$0243 = $340 ; $$0247 = $$1248 ; $$0269 = $$3272 ; continue L1 ; break ; } default : { $$2 = $20 ; $$2234 = 0 ; $$2239 = 31285 ; $$2251 = $11 ; $$5 = $$0254 ; $$6268 = $$1263$ ; } } } while ( 0 ) ; L97 : do { if ( ( label | 0 ) == 62 ) { label = 0 ; $227 = $6 ; $228 = $227 ; $229 = HEAP32 [ $228 >> 2 ] | 0 ; $230 = ( ( $227 ) + 4 ) | 0 ; $231 = $230 ; $232 = HEAP32 [ $231 >> 2 ] | 0 ; $233 = $$1236 & 32 ; $234 = ( _fmt_x ( $229 , $232 , $11 , $233 ) | 0 ) ; $235 = ( $229 | 0 ) == ( 0 ) ; $236 = ( $232 | 0 ) == ( 0 ) ; $237 = $235 & $236 ; $238 = $$3265 & 8 ; $239 = ( $238 | 0 ) == ( 0 ) ; $or$cond278 = $239 | $237 ; $240 = $$1236 >> 4 ; $241 = ( 31285 + ( $240 ) | 0 ) ; $$286 = $or$cond278 ? 31285 : $241 ; $$287 = $or$cond278 ? 0 : 2 ; $$0228 = $234 ; $$1233 = $$287 ; $$1238 = $$286 ; $$2256 = $$1255 ; $$4266 = $$3265 ; $280 = $229 ; $282 = $232 ; label = 68 ; } else if ( ( label | 0 ) == 67 ) { label = 0 ; $277 = ( _fmt_u ( $275 , $276 , $11 ) | 0 ) ; $$0228 = $277 ; $$1233 = $$0232 ; $$1238 = $$0237 ; $$2256 = $$0254 ; $$4266 = $$1263$ ; $280 = $275 ; $282 = $276 ; label = 68 ; } else if ( ( label | 0 ) == 72 ) { label = 0 ; $305 = ( _memchr ( $$1 , 0 , $$0254 ) | 0 ) ; $306 = ( $305 | 0 ) == ( 0 | 0 ) ; $307 = $305 ; $308 = $$1 ; $309 = ( ( $307 ) - ( $308 ) ) | 0 ; $310 = ( ( $$1 ) + ( $$0254 ) | 0 ) ; $$3257 = $306 ? $$0254 : $309 ; $$1250 = $306 ? $310 : $305 ; $$2 = $$1 ; $$2234 = 0 ; $$2239 = 31285 ; $$2251 = $$1250 ; $$5 = $$3257 ; $$6268 = $196 ; } else if ( ( label | 0 ) == 76 ) { label = 0 ; $$0229316 = $365 ; $$0240315 = 0 ; $$1244314 = 0 ; while ( 1 ) { $318 = HEAP32 [ $$0229316 >> 2 ] | 0 ; $319 = ( $318 | 0 ) == ( 0 ) ; if ( $319 ) { $$0240$lcssa = $$0240315 ; $$2245 = $$1244314 ; break ; } $320 = ( _wctomb ( $9 , $318 ) | 0 ) ; $321 = ( $320 | 0 ) < ( 0 ) ; $322 = ( ( $$4258354 ) - ( $$0240315 ) ) | 0 ; $323 = ( $320 >>> 0 ) > ( $322 >>> 0 ) ; $or$cond281 = $321 | $323 ; if ( $or$cond281 ) { $$0240$lcssa = $$0240315 ; $$2245 = $320 ; break ; } $324 = ( ( ( $$0229316 ) ) + 4 | 0 ) ; $325 = ( ( $320 ) + ( $$0240315 ) ) | 0 ; $326 = ( $$4258354 >>> 0 ) > ( $325 >>> 0 ) ; if ( $326 ) { $$0229316 = $324 ; $$0240315 = $325 ; $$1244314 = $320 ; } else { $$0240$lcssa = $325 ; $$2245 = $320 ; break ; } } $327 = ( $$2245 | 0 ) < ( 0 ) ; if ( $327 ) { $$0 = - 1 ; break L1 ; } _pad ( $0 , 32 , $$1260 , $$0240$lcssa , $$1263$ ) ; $328 = ( $$0240$lcssa | 0 ) == ( 0 ) ; if ( $328 ) { $$0240$lcssa356 = 0 ; label = 85 ; } else { $$1230327 = $365 ; $$1241326 = 0 ; while ( 1 ) { $329 = HEAP32 [ $$1230327 >> 2 ] | 0 ; $330 = ( $329 | 0 ) == ( 0 ) ; if ( $330 ) { $$0240$lcssa356 = $$0240$lcssa ; label = 85 ; break L97 ; } $331 = ( _wctomb ( $9 , $329 ) | 0 ) ; $332 = ( ( $331 ) + ( $$1241326 ) ) | 0 ; $333 = ( $332 | 0 ) > ( $$0240$lcssa | 0 ) ; if ( $333 ) { $$0240$lcssa356 = $$0240$lcssa ; label = 85 ; break L97 ; } $334 = ( ( ( $$1230327 ) ) + 4 | 0 ) ; _out ( $0 , $9 , $331 ) ; $335 = ( $332 >>> 0 ) < ( $$0240$lcssa >>> 0 ) ; if ( $335 ) { $$1230327 = $334 ; $$1241326 = $332 ; } else { $$0240$lcssa356 = $$0240$lcssa ; label = 85 ; break ; } } } } } while ( 0 ) ; if ( ( label | 0 ) == 68 ) { label = 0 ; $278 = ( $$2256 | 0 ) > ( - 1 ) ; $279 = $$4266 & - 65537 ; $$$4266 = $278 ? $279 : $$4266 ; $281 = ( $280 | 0 ) != ( 0 ) ; $283 = ( $282 | 0 ) != ( 0 ) ; $284 = $281 | $283 ; $285 = ( $$2256 | 0 ) != ( 0 ) ; $or$cond = $285 | $284 ; $286 = $$0228 ; $287 = ( ( $12 ) - ( $286 ) ) | 0 ; $288 = $284 ^ 1 ; $289 = $288 & 1 ; $290 = ( ( $287 ) + ( $289 ) ) | 0 ; $291 = ( $$2256 | 0 ) > ( $290 | 0 ) ; $$2256$ = $291 ? $$2256 : $290 ; $$2256$$$2256 = $or$cond ? $$2256$ : $$2256 ; $$0228$ = $or$cond ? $$0228 : $11 ; $$2 = $$0228$ ; $$2234 = $$1233 ; $$2239 = $$1238 ; $$2251 = $11 ; $$5 = $$2256$$$2256 ; $$6268 = $$$4266 ; } else if ( ( label | 0 ) == 85 ) { label = 0 ; $336 = $$1263$ ^ 8192 ; _pad ( $0 , 32 , $$1260 , $$0240$lcssa356 , $336 ) ; $337 = ( $$1260 | 0 ) > ( $$0240$lcssa356 | 0 ) ; $338 = $337 ? $$1260 : $$0240$lcssa356 ; $$0243 = $338 ; $$0247 = $$1248 ; $$0269 = $$3272 ; continue ; } $341 = $$2251 ; $342 = $$2 ; $343 = ( ( $341 ) - ( $342 ) ) | 0 ; $344 = ( $$5 | 0 ) < ( $343 | 0 ) ; $$$5 = $344 ? $343 : $$5 ; $345 = ( ( $$$5 ) + ( $$2234 ) ) | 0 ; $346 = ( $$1260 | 0 ) < ( $345 | 0 ) ; $$2261 = $346 ? $345 : $$1260 ; _pad ( $0 , 32 , $$2261 , $345 , $$6268 ) ; _out ( $0 , $$2239 , $$2234 ) ; $347 = $$6268 ^ 65536 ; _pad ( $0 , 48 , $$2261 , $345 , $347 ) ; _pad ( $0 , 48 , $$$5 , $343 , 0 ) ; _out ( $0 , $$2 , $343 ) ; $348 = $$6268 ^ 8192 ; _pad ( $0 , 32 , $$2261 , $345 , $348 ) ; $$0243 = $$2261 ; $$0247 = $$1248 ; $$0269 = $$3272 ; } L116 : do { if ( ( label | 0 ) == 88 ) { $349 = ( $0 | 0 ) == ( 0 | 0 ) ; if ( $349 ) { $350 = ( $$0269 | 0 ) == ( 0 ) ; if ( $350 ) { $$0 = 0 ; } else { $$2242302 = 1 ; while ( 1 ) { $351 = ( ( $4 ) + ( $$2242302 << 2 ) | 0 ) ; $352 = HEAP32 [ $351 >> 2 ] | 0 ; $353 = ( $352 | 0 ) == ( 0 ) ; if ( $353 ) { $$2242$lcssa = $$2242302 ; break ; } $355 = ( ( $3 ) + ( $$2242302 << 3 ) | 0 ) ; _pop_arg ( $355 , $352 , $2 ) ; $356 = ( ( $$2242302 ) + 1 ) | 0 ; $357 = ( $$2242302 | 0 ) < ( 9 ) ; if ( $357 ) { $$2242302 = $356 ; } else { $$2242$lcssa = $356 ; break ; } } $354 = ( $$2242$lcssa | 0 ) < ( 10 ) ; if ( $354 ) { $$3300 = $$2242$lcssa ; while ( 1 ) { $360 = ( ( $4 ) + ( $$3300 << 2 ) | 0 ) ; $361 = HEAP32 [ $360 >> 2 ] | 0 ; $362 = ( $361 | 0 ) == ( 0 ) ; if ( ! ( $362 ) ) { $$0 = - 1 ; break L116 ; } $358 = ( ( $$3300 ) + 1 ) | 0 ; $359 = ( $$3300 | 0 ) < ( 9 ) ; if ( $359 ) { $$3300 = $358 ; } else { $$0 = 1 ; break ; } } } else { $$0 = 1 ; } } } else { $$0 = $$1248 ; } } } while ( 0 ) ; STACKTOP = sp ; return ( $$0 | 0 ) ; } function ___lockfile ( $0 ) { $0 = $0 | 0 ; var label = 0 , sp = 0 ; sp = STACKTOP ; return 0 ; } function ___unlockfile ( $0 ) { $0 = $0 | 0 ; var label = 0 , sp = 0 ; sp = STACKTOP ; return ; } function _out ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $3 = 0 , $4 = 0 , $5 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = HEAP32 [ $0 >> 2 ] | 0 ; $4 = $3 & 32 ; $5 = ( $4 | 0 ) == ( 0 ) ; if ( $5 ) { ( ___fwritex ( $1 , $2 , $0 ) | 0 ) ; } return ; } function _isdigit ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( ( $0 ) + - 48 ) | 0 ; $2 = ( $1 >>> 0 ) < ( 10 ) ; $3 = $2 & 1 ; return ( $3 | 0 ) ; } function _getint ( $0 ) { $0 = $0 | 0 ; var $$0$lcssa = 0 , $$04 = 0 , $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = HEAP32 [ $0 >> 2 ] | 0 ; $2 = HEAP8 [ $1 >> 0 ] | 0 ; $3 = $2 << 24 >> 24 ; $4 = ( _isdigit ( $3 ) | 0 ) ; $5 = ( $4 | 0 ) == ( 0 ) ; if ( $5 ) { $$0$lcssa = 0 ; } else { $$04 = 0 ; while ( 1 ) { $6 = ( $$04 * 10 ) | 0 ; $7 = HEAP32 [ $0 >> 2 ] | 0 ; $8 = HEAP8 [ $7 >> 0 ] | 0 ; $9 = $8 << 24 >> 24 ; $10 = ( ( $6 ) + - 48 ) | 0 ; $11 = ( ( $10 ) + ( $9 ) ) | 0 ; $12 = ( ( ( $7 ) ) + 1 | 0 ) ; HEAP32 [ $0 >> 2 ] = $12 ; $13 = HEAP8 [ $12 >> 0 ] | 0 ; $14 = $13 << 24 >> 24 ; $15 = ( _isdigit ( $14 ) | 0 ) ; $16 = ( $15 | 0 ) == ( 0 ) ; if ( $16 ) { $$0$lcssa = $11 ; break ; } else { $$04 = $11 ; } } } return ( $$0$lcssa | 0 ) ; } function _pop_arg ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$mask = 0 , $$mask31 = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0.0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 ; var $116 = 0.0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 ; var $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 ; var $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 ; var $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 ; var $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $arglist_current = 0 , $arglist_current11 = 0 , $arglist_current14 = 0 , $arglist_current17 = 0 ; var $arglist_current2 = 0 , $arglist_current20 = 0 , $arglist_current23 = 0 , $arglist_current26 = 0 , $arglist_current5 = 0 , $arglist_current8 = 0 , $arglist_next = 0 , $arglist_next12 = 0 , $arglist_next15 = 0 , $arglist_next18 = 0 , $arglist_next21 = 0 , $arglist_next24 = 0 , $arglist_next27 = 0 , $arglist_next3 = 0 , $arglist_next6 = 0 , $arglist_next9 = 0 , $expanded = 0 , $expanded28 = 0 , $expanded30 = 0 , $expanded31 = 0 ; var $expanded32 = 0 , $expanded34 = 0 , $expanded35 = 0 , $expanded37 = 0 , $expanded38 = 0 , $expanded39 = 0 , $expanded41 = 0 , $expanded42 = 0 , $expanded44 = 0 , $expanded45 = 0 , $expanded46 = 0 , $expanded48 = 0 , $expanded49 = 0 , $expanded51 = 0 , $expanded52 = 0 , $expanded53 = 0 , $expanded55 = 0 , $expanded56 = 0 , $expanded58 = 0 , $expanded59 = 0 ; var $expanded60 = 0 , $expanded62 = 0 , $expanded63 = 0 , $expanded65 = 0 , $expanded66 = 0 , $expanded67 = 0 , $expanded69 = 0 , $expanded70 = 0 , $expanded72 = 0 , $expanded73 = 0 , $expanded74 = 0 , $expanded76 = 0 , $expanded77 = 0 , $expanded79 = 0 , $expanded80 = 0 , $expanded81 = 0 , $expanded83 = 0 , $expanded84 = 0 , $expanded86 = 0 , $expanded87 = 0 ; var $expanded88 = 0 , $expanded90 = 0 , $expanded91 = 0 , $expanded93 = 0 , $expanded94 = 0 , $expanded95 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( $1 >>> 0 ) > ( 20 ) ; L1 : do { if ( ! ( $3 ) ) { do { switch ( $1 | 0 ) { case 9 : { $arglist_current = HEAP32 [ $2 >> 2 ] | 0 ; $4 = $arglist_current ; $5 = ( ( 0 ) + 4 | 0 ) ; $expanded28 = $5 ; $expanded = ( ( $expanded28 ) - 1 ) | 0 ; $6 = ( ( $4 ) + ( $expanded ) ) | 0 ; $7 = ( ( 0 ) + 4 | 0 ) ; $expanded32 = $7 ; $expanded31 = ( ( $expanded32 ) - 1 ) | 0 ; $expanded30 = $expanded31 ^ - 1 ; $8 = $6 & $expanded30 ; $9 = $8 ; $10 = HEAP32 [ $9 >> 2 ] | 0 ; $arglist_next = ( ( ( $9 ) ) + 4 | 0 ) ; HEAP32 [ $2 >> 2 ] = $arglist_next ; HEAP32 [ $0 >> 2 ] = $10 ; break L1 ; break ; } case 10 : { $arglist_current2 = HEAP32 [ $2 >> 2 ] | 0 ; $11 = $arglist_current2 ; $12 = ( ( 0 ) + 4 | 0 ) ; $expanded35 = $12 ; $expanded34 = ( ( $expanded35 ) - 1 ) | 0 ; $13 = ( ( $11 ) + ( $expanded34 ) ) | 0 ; $14 = ( ( 0 ) + 4 | 0 ) ; $expanded39 = $14 ; $expanded38 = ( ( $expanded39 ) - 1 ) | 0 ; $expanded37 = $expanded38 ^ - 1 ; $15 = $13 & $expanded37 ; $16 = $15 ; $17 = HEAP32 [ $16 >> 2 ] | 0 ; $arglist_next3 = ( ( ( $16 ) ) + 4 | 0 ) ; HEAP32 [ $2 >> 2 ] = $arglist_next3 ; $18 = ( $17 | 0 ) < ( 0 ) ; $19 = $18 << 31 >> 31 ; $20 = $0 ; $21 = $20 ; HEAP32 [ $21 >> 2 ] = $17 ; $22 = ( ( $20 ) + 4 ) | 0 ; $23 = $22 ; HEAP32 [ $23 >> 2 ] = $19 ; break L1 ; break ; } case 11 : { $arglist_current5 = HEAP32 [ $2 >> 2 ] | 0 ; $24 = $arglist_current5 ; $25 = ( ( 0 ) + 4 | 0 ) ; $expanded42 = $25 ; $expanded41 = ( ( $expanded42 ) - 1 ) | 0 ; $26 = ( ( $24 ) + ( $expanded41 ) ) | 0 ; $27 = ( ( 0 ) + 4 | 0 ) ; $expanded46 = $27 ; $expanded45 = ( ( $expanded46 ) - 1 ) | 0 ; $expanded44 = $expanded45 ^ - 1 ; $28 = $26 & $expanded44 ; $29 = $28 ; $30 = HEAP32 [ $29 >> 2 ] | 0 ; $arglist_next6 = ( ( ( $29 ) ) + 4 | 0 ) ; HEAP32 [ $2 >> 2 ] = $arglist_next6 ; $31 = $0 ; $32 = $31 ; HEAP32 [ $32 >> 2 ] = $30 ; $33 = ( ( $31 ) + 4 ) | 0 ; $34 = $33 ; HEAP32 [ $34 >> 2 ] = 0 ; break L1 ; break ; } case 12 : { $arglist_current8 = HEAP32 [ $2 >> 2 ] | 0 ; $35 = $arglist_current8 ; $36 = ( ( 0 ) + 8 | 0 ) ; $expanded49 = $36 ; $expanded48 = ( ( $expanded49 ) - 1 ) | 0 ; $37 = ( ( $35 ) + ( $expanded48 ) ) | 0 ; $38 = ( ( 0 ) + 8 | 0 ) ; $expanded53 = $38 ; $expanded52 = ( ( $expanded53 ) - 1 ) | 0 ; $expanded51 = $expanded52 ^ - 1 ; $39 = $37 & $expanded51 ; $40 = $39 ; $41 = $40 ; $42 = $41 ; $43 = HEAP32 [ $42 >> 2 ] | 0 ; $44 = ( ( $41 ) + 4 ) | 0 ; $45 = $44 ; $46 = HEAP32 [ $45 >> 2 ] | 0 ; $arglist_next9 = ( ( ( $40 ) ) + 8 | 0 ) ; HEAP32 [ $2 >> 2 ] = $arglist_next9 ; $47 = $0 ; $48 = $47 ; HEAP32 [ $48 >> 2 ] = $43 ; $49 = ( ( $47 ) + 4 ) | 0 ; $50 = $49 ; HEAP32 [ $50 >> 2 ] = $46 ; break L1 ; break ; } case 13 : { $arglist_current11 = HEAP32 [ $2 >> 2 ] | 0 ; $51 = $arglist_current11 ; $52 = ( ( 0 ) + 4 | 0 ) ; $expanded56 = $52 ; $expanded55 = ( ( $expanded56 ) - 1 ) | 0 ; $53 = ( ( $51 ) + ( $expanded55 ) ) | 0 ; $54 = ( ( 0 ) + 4 | 0 ) ; $expanded60 = $54 ; $expanded59 = ( ( $expanded60 ) - 1 ) | 0 ; $expanded58 = $expanded59 ^ - 1 ; $55 = $53 & $expanded58 ; $56 = $55 ; $57 = HEAP32 [ $56 >> 2 ] | 0 ; $arglist_next12 = ( ( ( $56 ) ) + 4 | 0 ) ; HEAP32 [ $2 >> 2 ] = $arglist_next12 ; $58 = $57 & 65535 ; $59 = $58 << 16 >> 16 ; $60 = ( $59 | 0 ) < ( 0 ) ; $61 = $60 << 31 >> 31 ; $62 = $0 ; $63 = $62 ; HEAP32 [ $63 >> 2 ] = $59 ; $64 = ( ( $62 ) + 4 ) | 0 ; $65 = $64 ; HEAP32 [ $65 >> 2 ] = $61 ; break L1 ; break ; } case 14 : { $arglist_current14 = HEAP32 [ $2 >> 2 ] | 0 ; $66 = $arglist_current14 ; $67 = ( ( 0 ) + 4 | 0 ) ; $expanded63 = $67 ; $expanded62 = ( ( $expanded63 ) - 1 ) | 0 ; $68 = ( ( $66 ) + ( $expanded62 ) ) | 0 ; $69 = ( ( 0 ) + 4 | 0 ) ; $expanded67 = $69 ; $expanded66 = ( ( $expanded67 ) - 1 ) | 0 ; $expanded65 = $expanded66 ^ - 1 ; $70 = $68 & $expanded65 ; $71 = $70 ; $72 = HEAP32 [ $71 >> 2 ] | 0 ; $arglist_next15 = ( ( ( $71 ) ) + 4 | 0 ) ; HEAP32 [ $2 >> 2 ] = $arglist_next15 ; $$mask31 = $72 & 65535 ; $73 = $0 ; $74 = $73 ; HEAP32 [ $74 >> 2 ] = $$mask31 ; $75 = ( ( $73 ) + 4 ) | 0 ; $76 = $75 ; HEAP32 [ $76 >> 2 ] = 0 ; break L1 ; break ; } case 15 : { $arglist_current17 = HEAP32 [ $2 >> 2 ] | 0 ; $77 = $arglist_current17 ; $78 = ( ( 0 ) + 4 | 0 ) ; $expanded70 = $78 ; $expanded69 = ( ( $expanded70 ) - 1 ) | 0 ; $79 = ( ( $77 ) + ( $expanded69 ) ) | 0 ; $80 = ( ( 0 ) + 4 | 0 ) ; $expanded74 = $80 ; $expanded73 = ( ( $expanded74 ) - 1 ) | 0 ; $expanded72 = $expanded73 ^ - 1 ; $81 = $79 & $expanded72 ; $82 = $81 ; $83 = HEAP32 [ $82 >> 2 ] | 0 ; $arglist_next18 = ( ( ( $82 ) ) + 4 | 0 ) ; HEAP32 [ $2 >> 2 ] = $arglist_next18 ; $84 = $83 & 255 ; $85 = $84 << 24 >> 24 ; $86 = ( $85 | 0 ) < ( 0 ) ; $87 = $86 << 31 >> 31 ; $88 = $0 ; $89 = $88 ; HEAP32 [ $89 >> 2 ] = $85 ; $90 = ( ( $88 ) + 4 ) | 0 ; $91 = $90 ; HEAP32 [ $91 >> 2 ] = $87 ; break L1 ; break ; } case 16 : { $arglist_current20 = HEAP32 [ $2 >> 2 ] | 0 ; $92 = $arglist_current20 ; $93 = ( ( 0 ) + 4 | 0 ) ; $expanded77 = $93 ; $expanded76 = ( ( $expanded77 ) - 1 ) | 0 ; $94 = ( ( $92 ) + ( $expanded76 ) ) | 0 ; $95 = ( ( 0 ) + 4 | 0 ) ; $expanded81 = $95 ; $expanded80 = ( ( $expanded81 ) - 1 ) | 0 ; $expanded79 = $expanded80 ^ - 1 ; $96 = $94 & $expanded79 ; $97 = $96 ; $98 = HEAP32 [ $97 >> 2 ] | 0 ; $arglist_next21 = ( ( ( $97 ) ) + 4 | 0 ) ; HEAP32 [ $2 >> 2 ] = $arglist_next21 ; $$mask = $98 & 255 ; $99 = $0 ; $100 = $99 ; HEAP32 [ $100 >> 2 ] = $$mask ; $101 = ( ( $99 ) + 4 ) | 0 ; $102 = $101 ; HEAP32 [ $102 >> 2 ] = 0 ; break L1 ; break ; } case 17 : { $arglist_current23 = HEAP32 [ $2 >> 2 ] | 0 ; $103 = $arglist_current23 ; $104 = ( ( 0 ) + 8 | 0 ) ; $expanded84 = $104 ; $expanded83 = ( ( $expanded84 ) - 1 ) | 0 ; $105 = ( ( $103 ) + ( $expanded83 ) ) | 0 ; $106 = ( ( 0 ) + 8 | 0 ) ; $expanded88 = $106 ; $expanded87 = ( ( $expanded88 ) - 1 ) | 0 ; $expanded86 = $expanded87 ^ - 1 ; $107 = $105 & $expanded86 ; $108 = $107 ; $109 = + HEAPF64 [ $108 >> 3 ] ; $arglist_next24 = ( ( ( $108 ) ) + 8 | 0 ) ; HEAP32 [ $2 >> 2 ] = $arglist_next24 ; HEAPF64 [ $0 >> 3 ] = $109 ; break L1 ; break ; } case 18 : { $arglist_current26 = HEAP32 [ $2 >> 2 ] | 0 ; $110 = $arglist_current26 ; $111 = ( ( 0 ) + 8 | 0 ) ; $expanded91 = $111 ; $expanded90 = ( ( $expanded91 ) - 1 ) | 0 ; $112 = ( ( $110 ) + ( $expanded90 ) ) | 0 ; $113 = ( ( 0 ) + 8 | 0 ) ; $expanded95 = $113 ; $expanded94 = ( ( $expanded95 ) - 1 ) | 0 ; $expanded93 = $expanded94 ^ - 1 ; $114 = $112 & $expanded93 ; $115 = $114 ; $116 = + HEAPF64 [ $115 >> 3 ] ; $arglist_next27 = ( ( ( $115 ) ) + 8 | 0 ) ; HEAP32 [ $2 >> 2 ] = $arglist_next27 ; HEAPF64 [ $0 >> 3 ] = $116 ; break L1 ; break ; } default : { break L1 ; } } } while ( 0 ) ; } } while ( 0 ) ; return ; } function _fmt_x ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $$05$lcssa = 0 , $$056 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 ; var sp = 0 ; sp = STACKTOP ; $4 = ( $0 | 0 ) == ( 0 ) ; $5 = ( $1 | 0 ) == ( 0 ) ; $6 = $4 & $5 ; if ( $6 ) { $$05$lcssa = $2 ; } else { $$056 = $2 ; $15 = $1 ; $8 = $0 ; while ( 1 ) { $7 = $8 & 15 ; $9 = ( 31337 + ( $7 ) | 0 ) ; $10 = HEAP8 [ $9 >> 0 ] | 0 ; $11 = $10 & 255 ; $12 = $11 | $3 ; $13 = $12 & 255 ; $14 = ( ( ( $$056 ) ) + - 1 | 0 ) ; HEAP8 [ $14 >> 0 ] = $13 ; $16 = ( _bitshift64Lshr ( ( $8 | 0 ) , ( $15 | 0 ) , 4 ) | 0 ) ; $17 = tempRet0 ; $18 = ( $16 | 0 ) == ( 0 ) ; $19 = ( $17 | 0 ) == ( 0 ) ; $20 = $18 & $19 ; if ( $20 ) { $$05$lcssa = $14 ; break ; } else { $$056 = $14 ; $15 = $17 ; $8 = $16 ; } } } return ( $$05$lcssa | 0 ) ; } function _fmt_o ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$0$lcssa = 0 , $$06 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( $0 | 0 ) == ( 0 ) ; $4 = ( $1 | 0 ) == ( 0 ) ; $5 = $3 & $4 ; if ( $5 ) { $$0$lcssa = $2 ; } else { $$06 = $2 ; $11 = $1 ; $7 = $0 ; while ( 1 ) { $6 = $7 & 255 ; $8 = $6 & 7 ; $9 = $8 | 48 ; $10 = ( ( ( $$06 ) ) + - 1 | 0 ) ; HEAP8 [ $10 >> 0 ] = $9 ; $12 = ( _bitshift64Lshr ( ( $7 | 0 ) , ( $11 | 0 ) , 3 ) | 0 ) ; $13 = tempRet0 ; $14 = ( $12 | 0 ) == ( 0 ) ; $15 = ( $13 | 0 ) == ( 0 ) ; $16 = $14 & $15 ; if ( $16 ) { $$0$lcssa = $10 ; break ; } else { $$06 = $10 ; $11 = $13 ; $7 = $12 ; } } } return ( $$0$lcssa | 0 ) ; } function _fmt_u ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$010$lcssa$off0 = 0 , $$012 = 0 , $$09$lcssa = 0 , $$0914 = 0 , $$1$lcssa = 0 , $$111 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 ; var $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( $1 >>> 0 ) > ( 0 ) ; $4 = ( $0 >>> 0 ) > ( 4294967295 ) ; $5 = ( $1 | 0 ) == ( 0 ) ; $6 = $5 & $4 ; $7 = $3 | $6 ; if ( $7 ) { $$0914 = $2 ; $8 = $0 ; $9 = $1 ; while ( 1 ) { $10 = ( ___uremdi3 ( ( $8 | 0 ) , ( $9 | 0 ) , 10 , 0 ) | 0 ) ; $11 = tempRet0 ; $12 = $10 & 255 ; $13 = $12 | 48 ; $14 = ( ( ( $$0914 ) ) + - 1 | 0 ) ; HEAP8 [ $14 >> 0 ] = $13 ; $15 = ( ___udivdi3 ( ( $8 | 0 ) , ( $9 | 0 ) , 10 , 0 ) | 0 ) ; $16 = tempRet0 ; $17 = ( $9 >>> 0 ) > ( 9 ) ; $18 = ( $8 >>> 0 ) > ( 4294967295 ) ; $19 = ( $9 | 0 ) == ( 9 ) ; $20 = $19 & $18 ; $21 = $17 | $20 ; if ( $21 ) { $$0914 = $14 ; $8 = $15 ; $9 = $16 ; } else { break ; } } $$010$lcssa$off0 = $15 ; $$09$lcssa = $14 ; } else { $$010$lcssa$off0 = $0 ; $$09$lcssa = $2 ; } $22 = ( $$010$lcssa$off0 | 0 ) == ( 0 ) ; if ( $22 ) { $$1$lcssa = $$09$lcssa ; } else { $$012 = $$010$lcssa$off0 ; $$111 = $$09$lcssa ; while ( 1 ) { $23 = ( ( $$012 >>> 0 ) % 10 ) & - 1 ; $24 = $23 | 48 ; $25 = $24 & 255 ; $26 = ( ( ( $$111 ) ) + - 1 | 0 ) ; HEAP8 [ $26 >> 0 ] = $25 ; $27 = ( ( $$012 >>> 0 ) / 10 ) & - 1 ; $28 = ( $$012 >>> 0 ) < ( 10 ) ; if ( $28 ) { $$1$lcssa = $26 ; break ; } else { $$012 = $27 ; $$111 = $26 ; } } } return ( $$1$lcssa | 0 ) ; } function _strerror ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( ___pthread_self_206 ( ) | 0 ) ; $2 = ( ( ( $1 ) ) + 188 | 0 ) ; $3 = HEAP32 [ $2 >> 2 ] | 0 ; $4 = ( ___strerror_l ( $0 , $3 ) | 0 ) ; return ( $4 | 0 ) ; } function _memchr ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$0$lcssa = 0 , $$035$lcssa = 0 , $$035$lcssa65 = 0 , $$03555 = 0 , $$036$lcssa = 0 , $$036$lcssa64 = 0 , $$03654 = 0 , $$046 = 0 , $$137$lcssa = 0 , $$13745 = 0 , $$140 = 0 , $$2 = 0 , $$23839 = 0 , $$3 = 0 , $$lcssa = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 ; var $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 ; var $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , $or$cond53 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = $1 & 255 ; $4 = $0 ; $5 = $4 & 3 ; $6 = ( $5 | 0 ) != ( 0 ) ; $7 = ( $2 | 0 ) != ( 0 ) ; $or$cond53 = $7 & $6 ; L1 : do { if ( $or$cond53 ) { $8 = $1 & 255 ; $$03555 = $0 ; $$03654 = $2 ; while ( 1 ) { $9 = HEAP8 [ $$03555 >> 0 ] | 0 ; $10 = ( $9 << 24 >> 24 ) == ( $8 << 24 >> 24 ) ; if ( $10 ) { $$035$lcssa65 = $$03555 ; $$036$lcssa64 = $$03654 ; label = 6 ; break L1 ; } $11 = ( ( ( $$03555 ) ) + 1 | 0 ) ; $12 = ( ( $$03654 ) + - 1 ) | 0 ; $13 = $11 ; $14 = $13 & 3 ; $15 = ( $14 | 0 ) != ( 0 ) ; $16 = ( $12 | 0 ) != ( 0 ) ; $or$cond = $16 & $15 ; if ( $or$cond ) { $$03555 = $11 ; $$03654 = $12 ; } else { $$035$lcssa = $11 ; $$036$lcssa = $12 ; $$lcssa = $16 ; label = 5 ; break ; } } } else { $$035$lcssa = $0 ; $$036$lcssa = $2 ; $$lcssa = $7 ; label = 5 ; } } while ( 0 ) ; if ( ( label | 0 ) == 5 ) { if ( $$lcssa ) { $$035$lcssa65 = $$035$lcssa ; $$036$lcssa64 = $$036$lcssa ; label = 6 ; } else { $$2 = $$035$lcssa ; $$3 = 0 ; } } L8 : do { if ( ( label | 0 ) == 6 ) { $17 = HEAP8 [ $$035$lcssa65 >> 0 ] | 0 ; $18 = $1 & 255 ; $19 = ( $17 << 24 >> 24 ) == ( $18 << 24 >> 24 ) ; if ( $19 ) { $$2 = $$035$lcssa65 ; $$3 = $$036$lcssa64 ; } else { $20 = Math_imul ( $3 , 16843009 ) | 0 ; $21 = ( $$036$lcssa64 >>> 0 ) > ( 3 ) ; L11 : do { if ( $21 ) { $$046 = $$035$lcssa65 ; $$13745 = $$036$lcssa64 ; while ( 1 ) { $22 = HEAP32 [ $$046 >> 2 ] | 0 ; $23 = $22 ^ $20 ; $24 = ( ( $23 ) + - 16843009 ) | 0 ; $25 = $23 & - 2139062144 ; $26 = $25 ^ - 2139062144 ; $27 = $26 & $24 ; $28 = ( $27 | 0 ) == ( 0 ) ; if ( ! ( $28 ) ) { break ; } $29 = ( ( ( $$046 ) ) + 4 | 0 ) ; $30 = ( ( $$13745 ) + - 4 ) | 0 ; $31 = ( $30 >>> 0 ) > ( 3 ) ; if ( $31 ) { $$046 = $29 ; $$13745 = $30 ; } else { $$0$lcssa = $29 ; $$137$lcssa = $30 ; label = 11 ; break L11 ; } } $$140 = $$046 ; $$23839 = $$13745 ; } else { $$0$lcssa = $$035$lcssa65 ; $$137$lcssa = $$036$lcssa64 ; label = 11 ; } } while ( 0 ) ; if ( ( label | 0 ) == 11 ) { $32 = ( $$137$lcssa | 0 ) == ( 0 ) ; if ( $32 ) { $$2 = $$0$lcssa ; $$3 = 0 ; break ; } else { $$140 = $$0$lcssa ; $$23839 = $$137$lcssa ; } } while ( 1 ) { $33 = HEAP8 [ $$140 >> 0 ] | 0 ; $34 = ( $33 << 24 >> 24 ) == ( $18 << 24 >> 24 ) ; if ( $34 ) { $$2 = $$140 ; $$3 = $$23839 ; break L8 ; } $35 = ( ( ( $$140 ) ) + 1 | 0 ) ; $36 = ( ( $$23839 ) + - 1 ) | 0 ; $37 = ( $36 | 0 ) == ( 0 ) ; if ( $37 ) { $$2 = $35 ; $$3 = 0 ; break ; } else { $$140 = $35 ; $$23839 = $36 ; } } } } } while ( 0 ) ; $38 = ( $$3 | 0 ) != ( 0 ) ; $39 = $38 ? $$2 : 0 ; return ( $39 | 0 ) ; } function _pad ( $0 , $1 , $2 , $3 , $4 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; $4 = $4 | 0 ; var $$0$lcssa = 0 , $$011 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 256 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 256 | 0 ) ; $5 = sp ; $6 = $4 & 73728 ; $7 = ( $6 | 0 ) == ( 0 ) ; $8 = ( $2 | 0 ) > ( $3 | 0 ) ; $or$cond = $8 & $7 ; if ( $or$cond ) { $9 = ( ( $2 ) - ( $3 ) ) | 0 ; $10 = $1 << 24 >> 24 ; $11 = ( $9 >>> 0 ) < ( 256 ) ; $12 = $11 ? $9 : 256 ; ( _memset ( ( $5 | 0 ) , ( $10 | 0 ) , ( $12 | 0 ) ) | 0 ) ; $13 = ( $9 >>> 0 ) > ( 255 ) ; if ( $13 ) { $14 = ( ( $2 ) - ( $3 ) ) | 0 ; $$011 = $9 ; while ( 1 ) { _out ( $0 , $5 , 256 ) ; $15 = ( ( $$011 ) + - 256 ) | 0 ; $16 = ( $15 >>> 0 ) > ( 255 ) ; if ( $16 ) { $$011 = $15 ; } else { break ; } } $17 = $14 & 255 ; $$0$lcssa = $17 ; } else { $$0$lcssa = $9 ; } _out ( $0 , $5 , $$0$lcssa ) ; } STACKTOP = sp ; return ; } function _fmt_fp ( $0 , $1 , $2 , $3 , $4 , $5 ) { $0 = $0 | 0 ; $1 = + $1 ; $2 = $2 | 0 ; $3 = $3 | 0 ; $4 = $4 | 0 ; $5 = $5 | 0 ; var $$ = 0 , $$$ = 0 , $$$$564 = 0.0 , $$$3484 = 0 , $$$3484699 = 0 , $$$3484700 = 0 , $$$3501 = 0 , $$$4502 = 0 , $$$543 = 0.0 , $$$564 = 0.0 , $$0 = 0 , $$0463$lcssa = 0 , $$0463587 = 0 , $$0464597 = 0 , $$0471 = 0.0 , $$0479 = 0 , $$0487644 = 0 , $$0488 = 0 , $$0488655 = 0 , $$0488657 = 0 ; var $$0496$$9 = 0 , $$0497656 = 0 , $$0498 = 0 , $$0509585 = 0.0 , $$0510 = 0 , $$0511 = 0 , $$0514639 = 0 , $$0520 = 0 , $$0521 = 0 , $$0521$ = 0 , $$0523 = 0 , $$0527 = 0 , $$0527$in633 = 0 , $$0530638 = 0 , $$1465 = 0 , $$1467 = 0.0 , $$1469 = 0.0 , $$1472 = 0.0 , $$1480 = 0 , $$1482$lcssa = 0 ; var $$1482663 = 0 , $$1489643 = 0 , $$1499$lcssa = 0 , $$1499662 = 0 , $$1508586 = 0 , $$1512$lcssa = 0 , $$1512610 = 0 , $$1515 = 0 , $$1524 = 0 , $$1526 = 0 , $$1528617 = 0 , $$1531$lcssa = 0 , $$1531632 = 0 , $$1601 = 0 , $$2 = 0 , $$2473 = 0.0 , $$2476 = 0 , $$2476$$549 = 0 , $$2476$$551 = 0 , $$2483$ph = 0 ; var $$2500 = 0 , $$2513 = 0 , $$2516621 = 0 , $$2529 = 0 , $$2532620 = 0 , $$3 = 0.0 , $$3477 = 0 , $$3484$lcssa = 0 , $$3484650 = 0 , $$3501$lcssa = 0 , $$3501649 = 0 , $$3533616 = 0 , $$4 = 0.0 , $$4478$lcssa = 0 , $$4478593 = 0 , $$4492 = 0 , $$4502 = 0 , $$4518 = 0 , $$5$lcssa = 0 , $$534$ = 0 ; var $$540 = 0 , $$540$ = 0 , $$543 = 0.0 , $$548 = 0 , $$5486$lcssa = 0 , $$5486626 = 0 , $$5493600 = 0 , $$550 = 0 , $$5519$ph = 0 , $$557 = 0 , $$5605 = 0 , $$561 = 0 , $$564 = 0.0 , $$6 = 0 , $$6494592 = 0 , $$7495604 = 0 , $$7505 = 0 , $$7505$ = 0 , $$7505$ph = 0 , $$8 = 0 ; var $$9$ph = 0 , $$lcssa675 = 0 , $$neg = 0 , $$neg568 = 0 , $$pn = 0 , $$pr = 0 , $$pr566 = 0 , $$pre = 0 , $$pre$phi691Z2D = 0 , $$pre$phi698Z2D = 0 , $$pre690 = 0 , $$pre693 = 0 , $$pre697 = 0 , $$sink = 0 , $$sink547$lcssa = 0 , $$sink547625 = 0 , $$sink560 = 0 , $10 = 0 , $100 = 0 , $101 = 0 ; var $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0.0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 , $118 = 0.0 , $119 = 0.0 , $12 = 0 ; var $120 = 0.0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 ; var $139 = 0 , $14 = 0.0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 , $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 ; var $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 , $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 , $172 = 0 , $173 = 0 , $174 = 0 ; var $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 , $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 , $190 = 0 , $191 = 0 , $192 = 0 ; var $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 , $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 , $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 ; var $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 , $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 , $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 ; var $23 = 0 , $230 = 0 , $231 = 0.0 , $232 = 0.0 , $233 = 0 , $234 = 0.0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 , $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 , $244 = 0 , $245 = 0 , $246 = 0 , $247 = 0 ; var $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 , $258 = 0 , $259 = 0 , $26 = 0 , $260 = 0 , $261 = 0 , $262 = 0 , $263 = 0 , $264 = 0 , $265 = 0 ; var $266 = 0 , $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 , $270 = 0 , $271 = 0 , $272 = 0 , $273 = 0 , $274 = 0 , $275 = 0 , $276 = 0 , $277 = 0 , $278 = 0 , $279 = 0 , $28 = 0 , $280 = 0 , $281 = 0 , $282 = 0 , $283 = 0 ; var $284 = 0 , $285 = 0 , $286 = 0 , $287 = 0 , $288 = 0 , $289 = 0 , $29 = 0 , $290 = 0 , $291 = 0 , $292 = 0 , $293 = 0 , $294 = 0 , $295 = 0 , $296 = 0 , $297 = 0 , $298 = 0 , $299 = 0 , $30 = 0 , $300 = 0 , $301 = 0 ; var $302 = 0 , $303 = 0 , $304 = 0 , $305 = 0 , $306 = 0 , $307 = 0 , $308 = 0 , $309 = 0 , $31 = 0 , $310 = 0 , $311 = 0 , $312 = 0 , $313 = 0 , $314 = 0 , $315 = 0 , $316 = 0 , $317 = 0 , $318 = 0 , $319 = 0 , $32 = 0 ; var $320 = 0 , $321 = 0 , $322 = 0 , $323 = 0 , $324 = 0 , $325 = 0 , $326 = 0 , $327 = 0 , $328 = 0 , $329 = 0 , $33 = 0 , $330 = 0 , $331 = 0 , $332 = 0 , $333 = 0 , $334 = 0 , $335 = 0 , $336 = 0 , $337 = 0 , $338 = 0 ; var $339 = 0 , $34 = 0.0 , $340 = 0 , $341 = 0 , $342 = 0 , $343 = 0 , $344 = 0 , $345 = 0 , $346 = 0 , $347 = 0 , $348 = 0 , $349 = 0 , $35 = 0.0 , $350 = 0 , $351 = 0 , $352 = 0 , $353 = 0 , $354 = 0 , $355 = 0 , $356 = 0 ; var $357 = 0 , $358 = 0 , $359 = 0 , $36 = 0 , $360 = 0 , $361 = 0 , $362 = 0 , $363 = 0 , $364 = 0 , $365 = 0 , $366 = 0 , $367 = 0 , $368 = 0 , $369 = 0 , $37 = 0 , $370 = 0 , $371 = 0 , $372 = 0 , $373 = 0 , $374 = 0 ; var $375 = 0 , $376 = 0 , $377 = 0 , $378 = 0 , $379 = 0 , $38 = 0 , $380 = 0 , $381 = 0 , $382 = 0 , $383 = 0 , $384 = 0 , $385 = 0 , $386 = 0 , $387 = 0 , $388 = 0 , $389 = 0 , $39 = 0 , $390 = 0 , $391 = 0 , $40 = 0 ; var $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $50 = 0.0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0.0 , $55 = 0.0 , $56 = 0.0 , $57 = 0.0 , $58 = 0.0 , $59 = 0.0 , $6 = 0 ; var $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 ; var $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0.0 , $88 = 0.0 , $89 = 0.0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 ; var $97 = 0 , $98 = 0 , $99 = 0 , $not$ = 0 , $or$cond = 0 , $or$cond3$not = 0 , $or$cond542 = 0 , $or$cond545 = 0 , $or$cond556 = 0 , $or$cond6 = 0 , $scevgep686 = 0 , $scevgep686687 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 560 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 560 | 0 ) ; $6 = sp + 8 | 0 ; $7 = sp ; $8 = sp + 524 | 0 ; $9 = $8 ; $10 = sp + 512 | 0 ; HEAP32 [ $7 >> 2 ] = 0 ; $11 = ( ( ( $10 ) ) + 12 | 0 ) ; ( ___DOUBLE_BITS_419 ( $1 ) | 0 ) ; $12 = tempRet0 ; $13 = ( $12 | 0 ) < ( 0 ) ; if ( $13 ) { $14 = - $1 ; $$0471 = $14 ; $$0520 = 1 ; $$0521 = 31302 ; } else { $15 = $4 & 2048 ; $16 = ( $15 | 0 ) == ( 0 ) ; $17 = $4 & 1 ; $18 = ( $17 | 0 ) == ( 0 ) ; $$ = $18 ? ( 31303 ) : ( 31308 ) ; $$$ = $16 ? $$ : ( 31305 ) ; $19 = $4 & 2049 ; $20 = ( $19 | 0 ) != ( 0 ) ; $$534$ = $20 & 1 ; $$0471 = $1 ; $$0520 = $$534$ ; $$0521 = $$$ ; } ( ___DOUBLE_BITS_419 ( $$0471 ) | 0 ) ; $21 = tempRet0 ; $22 = $21 & 2146435072 ; $23 = ( 0 ) == ( 0 ) ; $24 = ( $22 | 0 ) == ( 2146435072 ) ; $25 = $23 & $24 ; do { if ( $25 ) { $26 = $5 & 32 ; $27 = ( $26 | 0 ) != ( 0 ) ; $28 = $27 ? 31321 : 31325 ; $29 = ( $$0471 != $$0471 ) | ( 0.0 != 0.0 ) ; $30 = $27 ? 31329 : 31333 ; $$0510 = $29 ? $30 : $28 ; $31 = ( ( $$0520 ) + 3 ) | 0 ; $32 = $4 & - 65537 ; _pad ( $0 , 32 , $2 , $31 , $32 ) ; _out ( $0 , $$0521 , $$0520 ) ; _out ( $0 , $$0510 , 3 ) ; $33 = $4 ^ 8192 ; _pad ( $0 , 32 , $2 , $31 , $33 ) ; $$sink560 = $31 ; } else { $34 = ( + _frexpl ( $$0471 , $7 ) ) ; $35 = $34 * 2.0 ; $36 = $35 != 0.0 ; if ( $36 ) { $37 = HEAP32 [ $7 >> 2 ] | 0 ; $38 = ( ( $37 ) + - 1 ) | 0 ; HEAP32 [ $7 >> 2 ] = $38 ; } $39 = $5 | 32 ; $40 = ( $39 | 0 ) == ( 97 ) ; if ( $40 ) { $41 = $5 & 32 ; $42 = ( $41 | 0 ) == ( 0 ) ; $43 = ( ( ( $$0521 ) ) + 9 | 0 ) ; $$0521$ = $42 ? $$0521 : $43 ; $44 = $$0520 | 2 ; $45 = ( $3 >>> 0 ) > ( 11 ) ; $46 = ( 12 - ( $3 ) ) | 0 ; $47 = ( $46 | 0 ) == ( 0 ) ; $48 = $45 | $47 ; do { if ( $48 ) { $$1472 = $35 ; } else { $$0509585 = 8.0 ; $$1508586 = $46 ; while ( 1 ) { $49 = ( ( $$1508586 ) + - 1 ) | 0 ; $50 = $$0509585 * 16.0 ; $51 = ( $49 | 0 ) == ( 0 ) ; if ( $51 ) { break ; } else { $$0509585 = $50 ; $$1508586 = $49 ; } } $52 = HEAP8 [ $$0521$ >> 0 ] | 0 ; $53 = ( $52 << 24 >> 24 ) == ( 45 ) ; if ( $53 ) { $54 = - $35 ; $55 = $54 - $50 ; $56 = $50 + $55 ; $57 = - $56 ; $$1472 = $57 ; break ; } else { $58 = $35 + $50 ; $59 = $58 - $50 ; $$1472 = $59 ; break ; } } } while ( 0 ) ; $60 = HEAP32 [ $7 >> 2 ] | 0 ; $61 = ( $60 | 0 ) < ( 0 ) ; $62 = ( 0 - ( $60 ) ) | 0 ; $63 = $61 ? $62 : $60 ; $64 = ( $63 | 0 ) < ( 0 ) ; $65 = $64 << 31 >> 31 ; $66 = ( _fmt_u ( $63 , $65 , $11 ) | 0 ) ; $67 = ( $66 | 0 ) == ( $11 | 0 ) ; if ( $67 ) { $68 = ( ( ( $10 ) ) + 11 | 0 ) ; HEAP8 [ $68 >> 0 ] = 48 ; $$0511 = $68 ; } else { $$0511 = $66 ; } $69 = $60 >> 31 ; $70 = $69 & 2 ; $71 = ( ( $70 ) + 43 ) | 0 ; $72 = $71 & 255 ; $73 = ( ( ( $$0511 ) ) + - 1 | 0 ) ; HEAP8 [ $73 >> 0 ] = $72 ; $74 = ( ( $5 ) + 15 ) | 0 ; $75 = $74 & 255 ; $76 = ( ( ( $$0511 ) ) + - 2 | 0 ) ; HEAP8 [ $76 >> 0 ] = $75 ; $77 = ( $3 | 0 ) < ( 1 ) ; $78 = $4 & 8 ; $79 = ( $78 | 0 ) == ( 0 ) ; $$0523 = $8 ; $$2473 = $$1472 ; while ( 1 ) { $80 = ( ~ ~ ( ( $$2473 ) ) ) ; $81 = ( 31337 + ( $80 ) | 0 ) ; $82 = HEAP8 [ $81 >> 0 ] | 0 ; $83 = $82 & 255 ; $84 = $41 | $83 ; $85 = $84 & 255 ; $86 = ( ( ( $$0523 ) ) + 1 | 0 ) ; HEAP8 [ $$0523 >> 0 ] = $85 ; $87 = ( + ( $80 | 0 ) ) ; $88 = $$2473 - $87 ; $89 = $88 * 16.0 ; $90 = $86 ; $91 = ( ( $90 ) - ( $9 ) ) | 0 ; $92 = ( $91 | 0 ) == ( 1 ) ; if ( $92 ) { $93 = $89 == 0.0 ; $or$cond3$not = $77 & $93 ; $or$cond = $79 & $or$cond3$not ; if ( $or$cond ) { $$1524 = $86 ; } else { $94 = ( ( ( $$0523 ) ) + 2 | 0 ) ; HEAP8 [ $86 >> 0 ] = 46 ; $$1524 = $94 ; } } else { $$1524 = $86 ; } $95 = $89 != 0.0 ; if ( $95 ) { $$0523 = $$1524 ; $$2473 = $89 ; } else { break ; } } $96 = ( $3 | 0 ) == ( 0 ) ; $$pre693 = $$1524 ; if ( $96 ) { label = 24 ; } else { $97 = ( - 2 - ( $9 ) ) | 0 ; $98 = ( ( $97 ) + ( $$pre693 ) ) | 0 ; $99 = ( $98 | 0 ) < ( $3 | 0 ) ; if ( $99 ) { $100 = ( ( $3 ) + 2 ) | 0 ; $$pre690 = ( ( $$pre693 ) - ( $9 ) ) | 0 ; $$pre$phi691Z2D = $$pre690 ; $$sink = $100 ; } else { label = 24 ; } } if ( ( label | 0 ) == 24 ) { $101 = ( ( $$pre693 ) - ( $9 ) ) | 0 ; $$pre$phi691Z2D = $101 ; $$sink = $101 ; } $102 = $11 ; $103 = $76 ; $104 = ( ( $102 ) - ( $103 ) ) | 0 ; $105 = ( ( $104 ) + ( $44 ) ) | 0 ; $106 = ( ( $105 ) + ( $$sink ) ) | 0 ; _pad ( $0 , 32 , $2 , $106 , $4 ) ; _out ( $0 , $$0521$ , $44 ) ; $107 = $4 ^ 65536 ; _pad ( $0 , 48 , $2 , $106 , $107 ) ; _out ( $0 , $8 , $$pre$phi691Z2D ) ; $108 = ( ( $$sink ) - ( $$pre$phi691Z2D ) ) | 0 ; _pad ( $0 , 48 , $108 , 0 , 0 ) ; _out ( $0 , $76 , $104 ) ; $109 = $4 ^ 8192 ; _pad ( $0 , 32 , $2 , $106 , $109 ) ; $$sink560 = $106 ; break ; } $110 = ( $3 | 0 ) < ( 0 ) ; $$540 = $110 ? 6 : $3 ; if ( $36 ) { $111 = $35 * 268435456.0 ; $112 = HEAP32 [ $7 >> 2 ] | 0 ; $113 = ( ( $112 ) + - 28 ) | 0 ; HEAP32 [ $7 >> 2 ] = $113 ; $$3 = $111 ; $$pr = $113 ; } else { $$pre = HEAP32 [ $7 >> 2 ] | 0 ; $$3 = $35 ; $$pr = $$pre ; } $114 = ( $$pr | 0 ) < ( 0 ) ; $115 = ( ( ( $6 ) ) + 288 | 0 ) ; $$561 = $114 ? $6 : $115 ; $$0498 = $$561 ; $$4 = $$3 ; while ( 1 ) { $116 = ( ~ ~ ( ( $$4 ) ) >>> 0 ) ; HEAP32 [ $$0498 >> 2 ] = $116 ; $117 = ( ( ( $$0498 ) ) + 4 | 0 ) ; $118 = ( + ( $116 >>> 0 ) ) ; $119 = $$4 - $118 ; $120 = $119 * 1.0E+9 ; $121 = $120 != 0.0 ; if ( $121 ) { $$0498 = $117 ; $$4 = $120 ; } else { break ; } } $122 = ( $$pr | 0 ) > ( 0 ) ; if ( $122 ) { $$1482663 = $$561 ; $$1499662 = $117 ; $123 = $$pr ; while ( 1 ) { $124 = ( $123 | 0 ) < ( 29 ) ; $125 = $124 ? $123 : 29 ; $$0488655 = ( ( ( $$1499662 ) ) + - 4 | 0 ) ; $126 = ( $$0488655 >>> 0 ) < ( $$1482663 >>> 0 ) ; if ( $126 ) { $$2483$ph = $$1482663 ; } else { $$0488657 = $$0488655 ; $$0497656 = 0 ; while ( 1 ) { $127 = HEAP32 [ $$0488657 >> 2 ] | 0 ; $128 = ( _bitshift64Shl ( ( $127 | 0 ) , 0 , ( $125 | 0 ) ) | 0 ) ; $129 = tempRet0 ; $130 = ( _i64Add ( ( $128 | 0 ) , ( $129 | 0 ) , ( $$0497656 | 0 ) , 0 ) | 0 ) ; $131 = tempRet0 ; $132 = ( ___uremdi3 ( ( $130 | 0 ) , ( $131 | 0 ) , 1000000000 , 0 ) | 0 ) ; $133 = tempRet0 ; HEAP32 [ $$0488657 >> 2 ] = $132 ; $134 = ( ___udivdi3 ( ( $130 | 0 ) , ( $131 | 0 ) , 1000000000 , 0 ) | 0 ) ; $135 = tempRet0 ; $$0488 = ( ( ( $$0488657 ) ) + - 4 | 0 ) ; $136 = ( $$0488 >>> 0 ) < ( $$1482663 >>> 0 ) ; if ( $136 ) { break ; } else { $$0488657 = $$0488 ; $$0497656 = $134 ; } } $137 = ( $134 | 0 ) == ( 0 ) ; if ( $137 ) { $$2483$ph = $$1482663 ; } else { $138 = ( ( ( $$1482663 ) ) + - 4 | 0 ) ; HEAP32 [ $138 >> 2 ] = $134 ; $$2483$ph = $138 ; } } $$2500 = $$1499662 ; while ( 1 ) { $139 = ( $$2500 >>> 0 ) > ( $$2483$ph >>> 0 ) ; if ( ! ( $139 ) ) { break ; } $140 = ( ( ( $$2500 ) ) + - 4 | 0 ) ; $141 = HEAP32 [ $140 >> 2 ] | 0 ; $142 = ( $141 | 0 ) == ( 0 ) ; if ( $142 ) { $$2500 = $140 ; } else { break ; } } $143 = HEAP32 [ $7 >> 2 ] | 0 ; $144 = ( ( $143 ) - ( $125 ) ) | 0 ; HEAP32 [ $7 >> 2 ] = $144 ; $145 = ( $144 | 0 ) > ( 0 ) ; if ( $145 ) { $$1482663 = $$2483$ph ; $$1499662 = $$2500 ; $123 = $144 ; } else { $$1482$lcssa = $$2483$ph ; $$1499$lcssa = $$2500 ; $$pr566 = $144 ; break ; } } } else { $$1482$lcssa = $$561 ; $$1499$lcssa = $117 ; $$pr566 = $$pr ; } $146 = ( $$pr566 | 0 ) < ( 0 ) ; if ( $146 ) { $147 = ( ( $$540 ) + 25 ) | 0 ; $148 = ( ( $147 | 0 ) / 9 ) & - 1 ; $149 = ( ( $148 ) + 1 ) | 0 ; $150 = ( $39 | 0 ) == ( 102 ) ; $$3484650 = $$1482$lcssa ; $$3501649 = $$1499$lcssa ; $152 = $$pr566 ; while ( 1 ) { $151 = ( 0 - ( $152 ) ) | 0 ; $153 = ( $151 | 0 ) < ( 9 ) ; $154 = $153 ? $151 : 9 ; $155 = ( $$3484650 >>> 0 ) < ( $$3501649 >>> 0 ) ; if ( $155 ) { $159 = 1 << $154 ; $160 = ( ( $159 ) + - 1 ) | 0 ; $161 = 1000000000 >>> $154 ; $$0487644 = 0 ; $$1489643 = $$3484650 ; while ( 1 ) { $162 = HEAP32 [ $$1489643 >> 2 ] | 0 ; $163 = $162 & $160 ; $164 = $162 >>> $154 ; $165 = ( ( $164 ) + ( $$0487644 ) ) | 0 ; HEAP32 [ $$1489643 >> 2 ] = $165 ; $166 = Math_imul ( $163 , $161 ) | 0 ; $167 = ( ( ( $$1489643 ) ) + 4 | 0 ) ; $168 = ( $167 >>> 0 ) < ( $$3501649 >>> 0 ) ; if ( $168 ) { $$0487644 = $166 ; $$1489643 = $167 ; } else { break ; } } $169 = HEAP32 [ $$3484650 >> 2 ] | 0 ; $170 = ( $169 | 0 ) == ( 0 ) ; $171 = ( ( ( $$3484650 ) ) + 4 | 0 ) ; $$$3484 = $170 ? $171 : $$3484650 ; $172 = ( $166 | 0 ) == ( 0 ) ; if ( $172 ) { $$$3484700 = $$$3484 ; $$4502 = $$3501649 ; } else { $173 = ( ( ( $$3501649 ) ) + 4 | 0 ) ; HEAP32 [ $$3501649 >> 2 ] = $166 ; $$$3484700 = $$$3484 ; $$4502 = $173 ; } } else { $156 = HEAP32 [ $$3484650 >> 2 ] | 0 ; $157 = ( $156 | 0 ) == ( 0 ) ; $158 = ( ( ( $$3484650 ) ) + 4 | 0 ) ; $$$3484699 = $157 ? $158 : $$3484650 ; $$$3484700 = $$$3484699 ; $$4502 = $$3501649 ; } $174 = $150 ? $$561 : $$$3484700 ; $175 = $$4502 ; $176 = $174 ; $177 = ( ( $175 ) - ( $176 ) ) | 0 ; $178 = $177 >> 2 ; $179 = ( $178 | 0 ) > ( $149 | 0 ) ; $180 = ( ( $174 ) + ( $149 << 2 ) | 0 ) ; $$$4502 = $179 ? $180 : $$4502 ; $181 = HEAP32 [ $7 >> 2 ] | 0 ; $182 = ( ( $181 ) + ( $154 ) ) | 0 ; HEAP32 [ $7 >> 2 ] = $182 ; $183 = ( $182 | 0 ) < ( 0 ) ; if ( $183 ) { $$3484650 = $$$3484700 ; $$3501649 = $$$4502 ; $152 = $182 ; } else { $$3484$lcssa = $$$3484700 ; $$3501$lcssa = $$$4502 ; break ; } } } else { $$3484$lcssa = $$1482$lcssa ; $$3501$lcssa = $$1499$lcssa ; } $184 = ( $$3484$lcssa >>> 0 ) < ( $$3501$lcssa >>> 0 ) ; $185 = $$561 ; if ( $184 ) { $186 = $$3484$lcssa ; $187 = ( ( $185 ) - ( $186 ) ) | 0 ; $188 = $187 >> 2 ; $189 = ( $188 * 9 ) | 0 ; $190 = HEAP32 [ $$3484$lcssa >> 2 ] | 0 ; $191 = ( $190 >>> 0 ) < ( 10 ) ; if ( $191 ) { $$1515 = $189 ; } else { $$0514639 = $189 ; $$0530638 = 10 ; while ( 1 ) { $192 = ( $$0530638 * 10 ) | 0 ; $193 = ( ( $$0514639 ) + 1 ) | 0 ; $194 = ( $190 >>> 0 ) < ( $192 >>> 0 ) ; if ( $194 ) { $$1515 = $193 ; break ; } else { $$0514639 = $193 ; $$0530638 = $192 ; } } } } else { $$1515 = 0 ; } $195 = ( $39 | 0 ) != ( 102 ) ; $196 = $195 ? $$1515 : 0 ; $197 = ( ( $$540 ) - ( $196 ) ) | 0 ; $198 = ( $39 | 0 ) == ( 103 ) ; $199 = ( $$540 | 0 ) != ( 0 ) ; $200 = $199 & $198 ; $$neg = $200 << 31 >> 31 ; $201 = ( ( $197 ) + ( $$neg ) ) | 0 ; $202 = $$3501$lcssa ; $203 = ( ( $202 ) - ( $185 ) ) | 0 ; $204 = $203 >> 2 ; $205 = ( $204 * 9 ) | 0 ; $206 = ( ( $205 ) + - 9 ) | 0 ; $207 = ( $201 | 0 ) < ( $206 | 0 ) ; if ( $207 ) { $208 = ( ( ( $$561 ) ) + 4 | 0 ) ; $209 = ( ( $201 ) + 9216 ) | 0 ; $210 = ( ( $209 | 0 ) / 9 ) & - 1 ; $211 = ( ( $210 ) + - 1024 ) | 0 ; $212 = ( ( $208 ) + ( $211 << 2 ) | 0 ) ; $213 = ( ( $209 | 0 ) % 9 ) & - 1 ; $214 = ( $213 | 0 ) < ( 8 ) ; if ( $214 ) { $$0527$in633 = $213 ; $$1531632 = 10 ; while ( 1 ) { $$0527 = ( ( $$0527$in633 ) + 1 ) | 0 ; $215 = ( $$1531632 * 10 ) | 0 ; $216 = ( $$0527$in633 | 0 ) < ( 7 ) ; if ( $216 ) { $$0527$in633 = $$0527 ; $$1531632 = $215 ; } else { $$1531$lcssa = $215 ; break ; } } } else { $$1531$lcssa = 10 ; } $217 = HEAP32 [ $212 >> 2 ] | 0 ; $218 = ( ( $217 >>> 0 ) % ( $$1531$lcssa >>> 0 ) ) & - 1 ; $219 = ( $218 | 0 ) == ( 0 ) ; $220 = ( ( ( $212 ) ) + 4 | 0 ) ; $221 = ( $220 | 0 ) == ( $$3501$lcssa | 0 ) ; $or$cond542 = $221 & $219 ; if ( $or$cond542 ) { $$4492 = $212 ; $$4518 = $$1515 ; $$8 = $$3484$lcssa ; } else { $222 = ( ( $217 >>> 0 ) / ( $$1531$lcssa >>> 0 ) ) & - 1 ; $223 = $222 & 1 ; $224 = ( $223 | 0 ) == ( 0 ) ; $$543 = $224 ? 9007199254740992.0 : 9007199254740994.0 ; $225 = ( ( $$1531$lcssa | 0 ) / 2 ) & - 1 ; $226 = ( $218 >>> 0 ) < ( $225 >>> 0 ) ; $227 = ( $218 | 0 ) == ( $225 | 0 ) ; $or$cond545 = $221 & $227 ; $$564 = $or$cond545 ? 1.0 : 1.5 ; $$$564 = $226 ? 0.5 : $$564 ; $228 = ( $$0520 | 0 ) == ( 0 ) ; if ( $228 ) { $$1467 = $$$564 ; $$1469 = $$543 ; } else { $229 = HEAP8 [ $$0521 >> 0 ] | 0 ; $230 = ( $229 << 24 >> 24 ) == ( 45 ) ; $231 = - $$543 ; $232 = - $$$564 ; $$$543 = $230 ? $231 : $$543 ; $$$$564 = $230 ? $232 : $$$564 ; $$1467 = $$$$564 ; $$1469 = $$$543 ; } $233 = ( ( $217 ) - ( $218 ) ) | 0 ; HEAP32 [ $212 >> 2 ] = $233 ; $234 = $$1469 + $$1467 ; $235 = $234 != $$1469 ; if ( $235 ) { $236 = ( ( $233 ) + ( $$1531$lcssa ) ) | 0 ; HEAP32 [ $212 >> 2 ] = $236 ; $237 = ( $236 >>> 0 ) > ( 999999999 ) ; if ( $237 ) { $$5486626 = $$3484$lcssa ; $$sink547625 = $212 ; while ( 1 ) { $238 = ( ( ( $$sink547625 ) ) + - 4 | 0 ) ; HEAP32 [ $$sink547625 >> 2 ] = 0 ; $239 = ( $238 >>> 0 ) < ( $$5486626 >>> 0 ) ; if ( $239 ) { $240 = ( ( ( $$5486626 ) ) + - 4 | 0 ) ; HEAP32 [ $240 >> 2 ] = 0 ; $$6 = $240 ; } else { $$6 = $$5486626 ; } $241 = HEAP32 [ $238 >> 2 ] | 0 ; $242 = ( ( $241 ) + 1 ) | 0 ; HEAP32 [ $238 >> 2 ] = $242 ; $243 = ( $242 >>> 0 ) > ( 999999999 ) ; if ( $243 ) { $$5486626 = $$6 ; $$sink547625 = $238 ; } else { $$5486$lcssa = $$6 ; $$sink547$lcssa = $238 ; break ; } } } else { $$5486$lcssa = $$3484$lcssa ; $$sink547$lcssa = $212 ; } $244 = $$5486$lcssa ; $245 = ( ( $185 ) - ( $244 ) ) | 0 ; $246 = $245 >> 2 ; $247 = ( $246 * 9 ) | 0 ; $248 = HEAP32 [ $$5486$lcssa >> 2 ] | 0 ; $249 = ( $248 >>> 0 ) < ( 10 ) ; if ( $249 ) { $$4492 = $$sink547$lcssa ; $$4518 = $247 ; $$8 = $$5486$lcssa ; } else { $$2516621 = $247 ; $$2532620 = 10 ; while ( 1 ) { $250 = ( $$2532620 * 10 ) | 0 ; $251 = ( ( $$2516621 ) + 1 ) | 0 ; $252 = ( $248 >>> 0 ) < ( $250 >>> 0 ) ; if ( $252 ) { $$4492 = $$sink547$lcssa ; $$4518 = $251 ; $$8 = $$5486$lcssa ; break ; } else { $$2516621 = $251 ; $$2532620 = $250 ; } } } } else { $$4492 = $212 ; $$4518 = $$1515 ; $$8 = $$3484$lcssa ; } } $253 = ( ( ( $$4492 ) ) + 4 | 0 ) ; $254 = ( $$3501$lcssa >>> 0 ) > ( $253 >>> 0 ) ; $$$3501 = $254 ? $253 : $$3501$lcssa ; $$5519$ph = $$4518 ; $$7505$ph = $$$3501 ; $$9$ph = $$8 ; } else { $$5519$ph = $$1515 ; $$7505$ph = $$3501$lcssa ; $$9$ph = $$3484$lcssa ; } $$7505 = $$7505$ph ; while ( 1 ) { $255 = ( $$7505 >>> 0 ) > ( $$9$ph >>> 0 ) ; if ( ! ( $255 ) ) { $$lcssa675 = 0 ; break ; } $256 = ( ( ( $$7505 ) ) + - 4 | 0 ) ; $257 = HEAP32 [ $256 >> 2 ] | 0 ; $258 = ( $257 | 0 ) == ( 0 ) ; if ( $258 ) { $$7505 = $256 ; } else { $$lcssa675 = 1 ; break ; } } $259 = ( 0 - ( $$5519$ph ) ) | 0 ; do { if ( $198 ) { $not$ = $199 ^ 1 ; $260 = $not$ & 1 ; $$540$ = ( ( $$540 ) + ( $260 ) ) | 0 ; $261 = ( $$540$ | 0 ) > ( $$5519$ph | 0 ) ; $262 = ( $$5519$ph | 0 ) > ( - 5 ) ; $or$cond6 = $261 & $262 ; if ( $or$cond6 ) { $263 = ( ( $5 ) + - 1 ) | 0 ; $$neg568 = ( ( $$540$ ) + - 1 ) | 0 ; $264 = ( ( $$neg568 ) - ( $$5519$ph ) ) | 0 ; $$0479 = $263 ; $$2476 = $264 ; } else { $265 = ( ( $5 ) + - 2 ) | 0 ; $266 = ( ( $$540$ ) + - 1 ) | 0 ; $$0479 = $265 ; $$2476 = $266 ; } $267 = $4 & 8 ; $268 = ( $267 | 0 ) == ( 0 ) ; if ( $268 ) { if ( $$lcssa675 ) { $269 = ( ( ( $$7505 ) ) + - 4 | 0 ) ; $270 = HEAP32 [ $269 >> 2 ] | 0 ; $271 = ( $270 | 0 ) == ( 0 ) ; if ( $271 ) { $$2529 = 9 ; } else { $272 = ( ( $270 >>> 0 ) % 10 ) & - 1 ; $273 = ( $272 | 0 ) == ( 0 ) ; if ( $273 ) { $$1528617 = 0 ; $$3533616 = 10 ; while ( 1 ) { $274 = ( $$3533616 * 10 ) | 0 ; $275 = ( ( $$1528617 ) + 1 ) | 0 ; $276 = ( ( $270 >>> 0 ) % ( $274 >>> 0 ) ) & - 1 ; $277 = ( $276 | 0 ) == ( 0 ) ; if ( $277 ) { $$1528617 = $275 ; $$3533616 = $274 ; } else { $$2529 = $275 ; break ; } } } else { $$2529 = 0 ; } } } else { $$2529 = 9 ; } $278 = $$0479 | 32 ; $279 = ( $278 | 0 ) == ( 102 ) ; $280 = $$7505 ; $281 = ( ( $280 ) - ( $185 ) ) | 0 ; $282 = $281 >> 2 ; $283 = ( $282 * 9 ) | 0 ; $284 = ( ( $283 ) + - 9 ) | 0 ; if ( $279 ) { $285 = ( ( $284 ) - ( $$2529 ) ) | 0 ; $286 = ( $285 | 0 ) > ( 0 ) ; $$548 = $286 ? $285 : 0 ; $287 = ( $$2476 | 0 ) < ( $$548 | 0 ) ; $$2476$$549 = $287 ? $$2476 : $$548 ; $$1480 = $$0479 ; $$3477 = $$2476$$549 ; $$pre$phi698Z2D = 0 ; break ; } else { $288 = ( ( $284 ) + ( $$5519$ph ) ) | 0 ; $289 = ( ( $288 ) - ( $$2529 ) ) | 0 ; $290 = ( $289 | 0 ) > ( 0 ) ; $$550 = $290 ? $289 : 0 ; $291 = ( $$2476 | 0 ) < ( $$550 | 0 ) ; $$2476$$551 = $291 ? $$2476 : $$550 ; $$1480 = $$0479 ; $$3477 = $$2476$$551 ; $$pre$phi698Z2D = 0 ; break ; } } else { $$1480 = $$0479 ; $$3477 = $$2476 ; $$pre$phi698Z2D = $267 ; } } else { $$pre697 = $4 & 8 ; $$1480 = $5 ; $$3477 = $$540 ; $$pre$phi698Z2D = $$pre697 ; } } while ( 0 ) ; $292 = $$3477 | $$pre$phi698Z2D ; $293 = ( $292 | 0 ) != ( 0 ) ; $294 = $293 & 1 ; $295 = $$1480 | 32 ; $296 = ( $295 | 0 ) == ( 102 ) ; if ( $296 ) { $297 = ( $$5519$ph | 0 ) > ( 0 ) ; $298 = $297 ? $$5519$ph : 0 ; $$2513 = 0 ; $$pn = $298 ; } else { $299 = ( $$5519$ph | 0 ) < ( 0 ) ; $300 = $299 ? $259 : $$5519$ph ; $301 = ( $300 | 0 ) < ( 0 ) ; $302 = $301 << 31 >> 31 ; $303 = ( _fmt_u ( $300 , $302 , $11 ) | 0 ) ; $304 = $11 ; $305 = $303 ; $306 = ( ( $304 ) - ( $305 ) ) | 0 ; $307 = ( $306 | 0 ) < ( 2 ) ; if ( $307 ) { $$1512610 = $303 ; while ( 1 ) { $308 = ( ( ( $$1512610 ) ) + - 1 | 0 ) ; HEAP8 [ $308 >> 0 ] = 48 ; $309 = $308 ; $310 = ( ( $304 ) - ( $309 ) ) | 0 ; $311 = ( $310 | 0 ) < ( 2 ) ; if ( $311 ) { $$1512610 = $308 ; } else { $$1512$lcssa = $308 ; break ; } } } else { $$1512$lcssa = $303 ; } $312 = $$5519$ph >> 31 ; $313 = $312 & 2 ; $314 = ( ( $313 ) + 43 ) | 0 ; $315 = $314 & 255 ; $316 = ( ( ( $$1512$lcssa ) ) + - 1 | 0 ) ; HEAP8 [ $316 >> 0 ] = $315 ; $317 = $$1480 & 255 ; $318 = ( ( ( $$1512$lcssa ) ) + - 2 | 0 ) ; HEAP8 [ $318 >> 0 ] = $317 ; $319 = $318 ; $320 = ( ( $304 ) - ( $319 ) ) | 0 ; $$2513 = $318 ; $$pn = $320 ; } $321 = ( ( $$0520 ) + 1 ) | 0 ; $322 = ( ( $321 ) + ( $$3477 ) ) | 0 ; $$1526 = ( ( $322 ) + ( $294 ) ) | 0 ; $323 = ( ( $$1526 ) + ( $$pn ) ) | 0 ; _pad ( $0 , 32 , $2 , $323 , $4 ) ; _out ( $0 , $$0521 , $$0520 ) ; $324 = $4 ^ 65536 ; _pad ( $0 , 48 , $2 , $323 , $324 ) ; if ( $296 ) { $325 = ( $$9$ph >>> 0 ) > ( $$561 >>> 0 ) ; $$0496$$9 = $325 ? $$561 : $$9$ph ; $326 = ( ( ( $8 ) ) + 9 | 0 ) ; $327 = $326 ; $328 = ( ( ( $8 ) ) + 8 | 0 ) ; $$5493600 = $$0496$$9 ; while ( 1 ) { $329 = HEAP32 [ $$5493600 >> 2 ] | 0 ; $330 = ( _fmt_u ( $329 , 0 , $326 ) | 0 ) ; $331 = ( $$5493600 | 0 ) == ( $$0496$$9 | 0 ) ; if ( $331 ) { $337 = ( $330 | 0 ) == ( $326 | 0 ) ; if ( $337 ) { HEAP8 [ $328 >> 0 ] = 48 ; $$1465 = $328 ; } else { $$1465 = $330 ; } } else { $332 = ( $330 >>> 0 ) > ( $8 >>> 0 ) ; if ( $332 ) { $333 = $330 ; $334 = ( ( $333 ) - ( $9 ) ) | 0 ; _memset ( ( $8 | 0 ) , 48 , ( $334 | 0 ) ) | 0 ; $$0464597 = $330 ; while ( 1 ) { $335 = ( ( ( $$0464597 ) ) + - 1 | 0 ) ; $336 = ( $335 >>> 0 ) > ( $8 >>> 0 ) ; if ( $336 ) { $$0464597 = $335 ; } else { $$1465 = $335 ; break ; } } } else { $$1465 = $330 ; } } $338 = $$1465 ; $339 = ( ( $327 ) - ( $338 ) ) | 0 ; _out ( $0 , $$1465 , $339 ) ; $340 = ( ( ( $$5493600 ) ) + 4 | 0 ) ; $341 = ( $340 >>> 0 ) > ( $$561 >>> 0 ) ; if ( $341 ) { break ; } else { $$5493600 = $340 ; } } $342 = ( $292 | 0 ) == ( 0 ) ; if ( ! ( $342 ) ) { _out ( $0 , 31353 , 1 ) ; } $343 = ( $340 >>> 0 ) < ( $$7505 >>> 0 ) ; $344 = ( $$3477 | 0 ) > ( 0 ) ; $345 = $343 & $344 ; if ( $345 ) { $$4478593 = $$3477 ; $$6494592 = $340 ; while ( 1 ) { $346 = HEAP32 [ $$6494592 >> 2 ] | 0 ; $347 = ( _fmt_u ( $346 , 0 , $326 ) | 0 ) ; $348 = ( $347 >>> 0 ) > ( $8 >>> 0 ) ; if ( $348 ) { $349 = $347 ; $350 = ( ( $349 ) - ( $9 ) ) | 0 ; _memset ( ( $8 | 0 ) , 48 , ( $350 | 0 ) ) | 0 ; $$0463587 = $347 ; while ( 1 ) { $351 = ( ( ( $$0463587 ) ) + - 1 | 0 ) ; $352 = ( $351 >>> 0 ) > ( $8 >>> 0 ) ; if ( $352 ) { $$0463587 = $351 ; } else { $$0463$lcssa = $351 ; break ; } } } else { $$0463$lcssa = $347 ; } $353 = ( $$4478593 | 0 ) < ( 9 ) ; $354 = $353 ? $$4478593 : 9 ; _out ( $0 , $$0463$lcssa , $354 ) ; $355 = ( ( ( $$6494592 ) ) + 4 | 0 ) ; $356 = ( ( $$4478593 ) + - 9 ) | 0 ; $357 = ( $355 >>> 0 ) < ( $$7505 >>> 0 ) ; $358 = ( $$4478593 | 0 ) > ( 9 ) ; $359 = $357 & $358 ; if ( $359 ) { $$4478593 = $356 ; $$6494592 = $355 ; } else { $$4478$lcssa = $356 ; break ; } } } else { $$4478$lcssa = $$3477 ; } $360 = ( ( $$4478$lcssa ) + 9 ) | 0 ; _pad ( $0 , 48 , $360 , 9 , 0 ) ; } else { $361 = ( ( ( $$9$ph ) ) + 4 | 0 ) ; $$7505$ = $$lcssa675 ? $$7505 : $361 ; $362 = ( $$3477 | 0 ) > ( - 1 ) ; if ( $362 ) { $363 = ( ( ( $8 ) ) + 9 | 0 ) ; $364 = ( $$pre$phi698Z2D | 0 ) == ( 0 ) ; $365 = $363 ; $366 = ( 0 - ( $9 ) ) | 0 ; $367 = ( ( ( $8 ) ) + 8 | 0 ) ; $$5605 = $$3477 ; $$7495604 = $$9$ph ; while ( 1 ) { $368 = HEAP32 [ $$7495604 >> 2 ] | 0 ; $369 = ( _fmt_u ( $368 , 0 , $363 ) | 0 ) ; $370 = ( $369 | 0 ) == ( $363 | 0 ) ; if ( $370 ) { HEAP8 [ $367 >> 0 ] = 48 ; $$0 = $367 ; } else { $$0 = $369 ; } $371 = ( $$7495604 | 0 ) == ( $$9$ph | 0 ) ; do { if ( $371 ) { $375 = ( ( ( $$0 ) ) + 1 | 0 ) ; _out ( $0 , $$0 , 1 ) ; $376 = ( $$5605 | 0 ) < ( 1 ) ; $or$cond556 = $364 & $376 ; if ( $or$cond556 ) { $$2 = $375 ; break ; } _out ( $0 , 31353 , 1 ) ; $$2 = $375 ; } else { $372 = ( $$0 >>> 0 ) > ( $8 >>> 0 ) ; if ( ! ( $372 ) ) { $$2 = $$0 ; break ; } $scevgep686 = ( ( $$0 ) + ( $366 ) | 0 ) ; $scevgep686687 = $scevgep686 ; _memset ( ( $8 | 0 ) , 48 , ( $scevgep686687 | 0 ) ) | 0 ; $$1601 = $$0 ; while ( 1 ) { $373 = ( ( ( $$1601 ) ) + - 1 | 0 ) ; $374 = ( $373 >>> 0 ) > ( $8 >>> 0 ) ; if ( $374 ) { $$1601 = $373 ; } else { $$2 = $373 ; break ; } } } } while ( 0 ) ; $377 = $$2 ; $378 = ( ( $365 ) - ( $377 ) ) | 0 ; $379 = ( $$5605 | 0 ) > ( $378 | 0 ) ; $380 = $379 ? $378 : $$5605 ; _out ( $0 , $$2 , $380 ) ; $381 = ( ( $$5605 ) - ( $378 ) ) | 0 ; $382 = ( ( ( $$7495604 ) ) + 4 | 0 ) ; $383 = ( $382 >>> 0 ) < ( $$7505$ >>> 0 ) ; $384 = ( $381 | 0 ) > ( - 1 ) ; $385 = $383 & $384 ; if ( $385 ) { $$5605 = $381 ; $$7495604 = $382 ; } else { $$5$lcssa = $381 ; break ; } } } else { $$5$lcssa = $$3477 ; } $386 = ( ( $$5$lcssa ) + 18 ) | 0 ; _pad ( $0 , 48 , $386 , 18 , 0 ) ; $387 = $11 ; $388 = $$2513 ; $389 = ( ( $387 ) - ( $388 ) ) | 0 ; _out ( $0 , $$2513 , $389 ) ; } $390 = $4 ^ 8192 ; _pad ( $0 , 32 , $2 , $323 , $390 ) ; $$sink560 = $323 ; } } while ( 0 ) ; $391 = ( $$sink560 | 0 ) < ( $2 | 0 ) ; $$557 = $391 ? $2 : $$sink560 ; STACKTOP = sp ; return ( $$557 | 0 ) ; } function ___DOUBLE_BITS_419 ( $0 ) { $0 = + $0 ; var $1 = 0 , $2 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; HEAPF64 [ tempDoublePtr >> 3 ] = $0 ; $1 = HEAP32 [ tempDoublePtr >> 2 ] | 0 ; $2 = HEAP32 [ tempDoublePtr + 4 >> 2 ] | 0 ; tempRet0 = ( $2 ) ; return ( $1 | 0 ) ; } function _frexpl ( $0 , $1 ) { $0 = + $0 ; $1 = $1 | 0 ; var $2 = 0.0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( + _frexp ( $0 , $1 ) ) ; return ( + $2 ) ; } function _frexp ( $0 , $1 ) { $0 = + $0 ; $1 = $1 | 0 ; var $$0 = 0.0 , $$016 = 0.0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0.0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0.0 , $9 = 0.0 , $storemerge = 0 , $trunc$clear = 0 , label = 0 ; var sp = 0 ; sp = STACKTOP ; HEAPF64 [ tempDoublePtr >> 3 ] = $0 ; $2 = HEAP32 [ tempDoublePtr >> 2 ] | 0 ; $3 = HEAP32 [ tempDoublePtr + 4 >> 2 ] | 0 ; $4 = ( _bitshift64Lshr ( ( $2 | 0 ) , ( $3 | 0 ) , 52 ) | 0 ) ; $5 = tempRet0 ; $6 = $4 & 65535 ; $trunc$clear = $6 & 2047 ; switch ( $trunc$clear << 16 >> 16 ) { case 0 : { $7 = $0 != 0.0 ; if ( $7 ) { $8 = $0 * 1.8446744073709552E+19 ; $9 = ( + _frexp ( $8 , $1 ) ) ; $10 = HEAP32 [ $1 >> 2 ] | 0 ; $11 = ( ( $10 ) + - 64 ) | 0 ; $$016 = $9 ; $storemerge = $11 ; } else { $$016 = $0 ; $storemerge = 0 ; } HEAP32 [ $1 >> 2 ] = $storemerge ; $$0 = $$016 ; break ; } case 2047 : { $$0 = $0 ; break ; } default : { $12 = $4 & 2047 ; $13 = ( ( $12 ) + - 1022 ) | 0 ; HEAP32 [ $1 >> 2 ] = $13 ; $14 = $3 & - 2146435073 ; $15 = $14 | 1071644672 ; HEAP32 [ tempDoublePtr >> 2 ] = $2 ; HEAP32 [ tempDoublePtr + 4 >> 2 ] = $15 ; $16 = + HEAPF64 [ tempDoublePtr >> 3 ] ; $$0 = $16 ; } } return ( + $$0 ) ; } function ___pthread_self_206 ( ) { var $0 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $0 = ( _pthread_self ( ) | 0 ) ; return ( $0 | 0 ) ; } function ___strerror_l ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$012$lcssa = 0 , $$01214 = 0 , $$016 = 0 , $$113 = 0 , $$115 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 ; var label = 0 , sp = 0 ; sp = STACKTOP ; $$016 = 0 ; while ( 1 ) { $3 = ( 31355 + ( $$016 ) | 0 ) ; $4 = HEAP8 [ $3 >> 0 ] | 0 ; $5 = $4 & 255 ; $6 = ( $5 | 0 ) == ( $0 | 0 ) ; if ( $6 ) { label = 2 ; break ; } $7 = ( ( $$016 ) + 1 ) | 0 ; $8 = ( $7 | 0 ) == ( 87 ) ; if ( $8 ) { $$01214 = 31443 ; $$115 = 87 ; label = 5 ; break ; } else { $$016 = $7 ; } } if ( ( label | 0 ) == 2 ) { $2 = ( $$016 | 0 ) == ( 0 ) ; if ( $2 ) { $$012$lcssa = 31443 ; } else { $$01214 = 31443 ; $$115 = $$016 ; label = 5 ; } } if ( ( label | 0 ) == 5 ) { while ( 1 ) { label = 0 ; $$113 = $$01214 ; while ( 1 ) { $9 = HEAP8 [ $$113 >> 0 ] | 0 ; $10 = ( $9 << 24 >> 24 ) == ( 0 ) ; $11 = ( ( ( $$113 ) ) + 1 | 0 ) ; if ( $10 ) { break ; } else { $$113 = $11 ; } } $12 = ( ( $$115 ) + - 1 ) | 0 ; $13 = ( $12 | 0 ) == ( 0 ) ; if ( $13 ) { $$012$lcssa = $11 ; break ; } else { $$01214 = $11 ; $$115 = $12 ; label = 5 ; } } } $14 = ( ( ( $1 ) ) + 20 | 0 ) ; $15 = HEAP32 [ $14 >> 2 ] | 0 ; $16 = ( ___lctrans ( $$012$lcssa , $15 ) | 0 ) ; return ( $16 | 0 ) ; } function ___lctrans ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $2 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( ___lctrans_impl ( $0 , $1 ) | 0 ) ; return ( $2 | 0 ) ; } function ___lctrans_impl ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$0 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( $1 | 0 ) == ( 0 | 0 ) ; if ( $2 ) { $$0 = 0 ; } else { $3 = HEAP32 [ $1 >> 2 ] | 0 ; $4 = ( ( ( $1 ) ) + 4 | 0 ) ; $5 = HEAP32 [ $4 >> 2 ] | 0 ; $6 = ( ___mo_lookup ( $3 , $5 , $0 ) | 0 ) ; $$0 = $6 ; } $7 = ( $$0 | 0 ) != ( 0 | 0 ) ; $8 = $7 ? $$0 : $0 ; return ( $8 | 0 ) ; } function ___mo_lookup ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$ = 0 , $$090 = 0 , $$094 = 0 , $$191 = 0 , $$195 = 0 , $$4 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 ; var $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 ; var $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 ; var $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , $or$cond102 = 0 , $or$cond104 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = HEAP32 [ $0 >> 2 ] | 0 ; $4 = ( ( $3 ) + 1794895138 ) | 0 ; $5 = ( ( ( $0 ) ) + 8 | 0 ) ; $6 = HEAP32 [ $5 >> 2 ] | 0 ; $7 = ( _swapc ( $6 , $4 ) | 0 ) ; $8 = ( ( ( $0 ) ) + 12 | 0 ) ; $9 = HEAP32 [ $8 >> 2 ] | 0 ; $10 = ( _swapc ( $9 , $4 ) | 0 ) ; $11 = ( ( ( $0 ) ) + 16 | 0 ) ; $12 = HEAP32 [ $11 >> 2 ] | 0 ; $13 = ( _swapc ( $12 , $4 ) | 0 ) ; $14 = $1 >>> 2 ; $15 = ( $7 >>> 0 ) < ( $14 >>> 0 ) ; L1 : do { if ( $15 ) { $16 = $7 << 2 ; $17 = ( ( $1 ) - ( $16 ) ) | 0 ; $18 = ( $10 >>> 0 ) < ( $17 >>> 0 ) ; $19 = ( $13 >>> 0 ) < ( $17 >>> 0 ) ; $or$cond = $18 & $19 ; if ( $or$cond ) { $20 = $13 | $10 ; $21 = $20 & 3 ; $22 = ( $21 | 0 ) == ( 0 ) ; if ( $22 ) { $23 = $10 >>> 2 ; $24 = $13 >>> 2 ; $$090 = 0 ; $$094 = $7 ; while ( 1 ) { $25 = $$094 >>> 1 ; $26 = ( ( $$090 ) + ( $25 ) ) | 0 ; $27 = $26 << 1 ; $28 = ( ( $27 ) + ( $23 ) ) | 0 ; $29 = ( ( $0 ) + ( $28 << 2 ) | 0 ) ; $30 = HEAP32 [ $29 >> 2 ] | 0 ; $31 = ( _swapc ( $30 , $4 ) | 0 ) ; $32 = ( ( $28 ) + 1 ) | 0 ; $33 = ( ( $0 ) + ( $32 << 2 ) | 0 ) ; $34 = HEAP32 [ $33 >> 2 ] | 0 ; $35 = ( _swapc ( $34 , $4 ) | 0 ) ; $36 = ( $35 >>> 0 ) < ( $1 >>> 0 ) ; $37 = ( ( $1 ) - ( $35 ) ) | 0 ; $38 = ( $31 >>> 0 ) < ( $37 >>> 0 ) ; $or$cond102 = $36 & $38 ; if ( ! ( $or$cond102 ) ) { $$4 = 0 ; break L1 ; } $39 = ( ( $35 ) + ( $31 ) ) | 0 ; $40 = ( ( $0 ) + ( $39 ) | 0 ) ; $41 = HEAP8 [ $40 >> 0 ] | 0 ; $42 = ( $41 << 24 >> 24 ) == ( 0 ) ; if ( ! ( $42 ) ) { $$4 = 0 ; break L1 ; } $43 = ( ( $0 ) + ( $35 ) | 0 ) ; $44 = ( _strcmp ( $2 , $43 ) | 0 ) ; $45 = ( $44 | 0 ) == ( 0 ) ; if ( $45 ) { break ; } $62 = ( $$094 | 0 ) == ( 1 ) ; $63 = ( $44 | 0 ) < ( 0 ) ; $64 = ( ( $$094 ) - ( $25 ) ) | 0 ; $$195 = $63 ? $25 : $64 ; $$191 = $63 ? $$090 : $26 ; if ( $62 ) { $$4 = 0 ; break L1 ; } else { $$090 = $$191 ; $$094 = $$195 ; } } $46 = ( ( $27 ) + ( $24 ) ) | 0 ; $47 = ( ( $0 ) + ( $46 << 2 ) | 0 ) ; $48 = HEAP32 [ $47 >> 2 ] | 0 ; $49 = ( _swapc ( $48 , $4 ) | 0 ) ; $50 = ( ( $46 ) + 1 ) | 0 ; $51 = ( ( $0 ) + ( $50 << 2 ) | 0 ) ; $52 = HEAP32 [ $51 >> 2 ] | 0 ; $53 = ( _swapc ( $52 , $4 ) | 0 ) ; $54 = ( $53 >>> 0 ) < ( $1 >>> 0 ) ; $55 = ( ( $1 ) - ( $53 ) ) | 0 ; $56 = ( $49 >>> 0 ) < ( $55 >>> 0 ) ; $or$cond104 = $54 & $56 ; if ( $or$cond104 ) { $57 = ( ( $0 ) + ( $53 ) | 0 ) ; $58 = ( ( $53 ) + ( $49 ) ) | 0 ; $59 = ( ( $0 ) + ( $58 ) | 0 ) ; $60 = HEAP8 [ $59 >> 0 ] | 0 ; $61 = ( $60 << 24 >> 24 ) == ( 0 ) ; $$ = $61 ? $57 : 0 ; $$4 = $$ ; } else { $$4 = 0 ; } } else { $$4 = 0 ; } } else { $$4 = 0 ; } } else { $$4 = 0 ; } } while ( 0 ) ; return ( $$4 | 0 ) ; } function _swapc ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$ = 0 , $2 = 0 , $3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( $1 | 0 ) == ( 0 ) ; $3 = ( _llvm_bswap_i32 ( ( $0 | 0 ) ) | 0 ) ; $$ = $2 ? $0 : $3 ; return ( $$ | 0 ) ; } function _strcmp ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$011 = 0 , $$0710 = 0 , $$lcssa = 0 , $$lcssa8 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , $or$cond9 = 0 , label = 0 ; var sp = 0 ; sp = STACKTOP ; $2 = HEAP8 [ $0 >> 0 ] | 0 ; $3 = HEAP8 [ $1 >> 0 ] | 0 ; $4 = ( $2 << 24 >> 24 ) != ( $3 << 24 >> 24 ) ; $5 = ( $2 << 24 >> 24 ) == ( 0 ) ; $or$cond9 = $5 | $4 ; if ( $or$cond9 ) { $$lcssa = $3 ; $$lcssa8 = $2 ; } else { $$011 = $1 ; $$0710 = $0 ; while ( 1 ) { $6 = ( ( ( $$0710 ) ) + 1 | 0 ) ; $7 = ( ( ( $$011 ) ) + 1 | 0 ) ; $8 = HEAP8 [ $6 >> 0 ] | 0 ; $9 = HEAP8 [ $7 >> 0 ] | 0 ; $10 = ( $8 << 24 >> 24 ) != ( $9 << 24 >> 24 ) ; $11 = ( $8 << 24 >> 24 ) == ( 0 ) ; $or$cond = $11 | $10 ; if ( $or$cond ) { $$lcssa = $9 ; $$lcssa8 = $8 ; break ; } else { $$011 = $7 ; $$0710 = $6 ; } } } $12 = $$lcssa8 & 255 ; $13 = $$lcssa & 255 ; $14 = ( ( $12 ) - ( $13 ) ) | 0 ; return ( $14 | 0 ) ; } function ___fwritex ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$038 = 0 , $$042 = 0 , $$1 = 0 , $$139 = 0 , $$141 = 0 , $$143 = 0 , $$pre = 0 , $$pre47 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 ; var $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 ; var label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( ( ( $2 ) ) + 16 | 0 ) ; $4 = HEAP32 [ $3 >> 2 ] | 0 ; $5 = ( $4 | 0 ) == ( 0 | 0 ) ; if ( $5 ) { $7 = ( ___towrite ( $2 ) | 0 ) ; $8 = ( $7 | 0 ) == ( 0 ) ; if ( $8 ) { $$pre = HEAP32 [ $3 >> 2 ] | 0 ; $12 = $$pre ; label = 5 ; } else { $$1 = 0 ; } } else { $6 = $4 ; $12 = $6 ; label = 5 ; } L5 : do { if ( ( label | 0 ) == 5 ) { $9 = ( ( ( $2 ) ) + 20 | 0 ) ; $10 = HEAP32 [ $9 >> 2 ] | 0 ; $11 = ( ( $12 ) - ( $10 ) ) | 0 ; $13 = ( $11 >>> 0 ) < ( $1 >>> 0 ) ; $14 = $10 ; if ( $13 ) { $15 = ( ( ( $2 ) ) + 36 | 0 ) ; $16 = HEAP32 [ $15 >> 2 ] | 0 ; $17 = ( FUNCTION_TABLE_iiii [ $16 & 127 ] ( $2 , $0 , $1 ) | 0 ) ; $$1 = $17 ; break ; } $18 = ( ( ( $2 ) ) + 75 | 0 ) ; $19 = HEAP8 [ $18 >> 0 ] | 0 ; $20 = ( $19 << 24 >> 24 ) > ( - 1 ) ; L10 : do { if ( $20 ) { $$038 = $1 ; while ( 1 ) { $21 = ( $$038 | 0 ) == ( 0 ) ; if ( $21 ) { $$139 = 0 ; $$141 = $0 ; $$143 = $1 ; $31 = $14 ; break L10 ; } $22 = ( ( $$038 ) + - 1 ) | 0 ; $23 = ( ( $0 ) + ( $22 ) | 0 ) ; $24 = HEAP8 [ $23 >> 0 ] | 0 ; $25 = ( $24 << 24 >> 24 ) == ( 10 ) ; if ( $25 ) { break ; } else { $$038 = $22 ; } } $26 = ( ( ( $2 ) ) + 36 | 0 ) ; $27 = HEAP32 [ $26 >> 2 ] | 0 ; $28 = ( FUNCTION_TABLE_iiii [ $27 & 127 ] ( $2 , $0 , $$038 ) | 0 ) ; $29 = ( $28 >>> 0 ) < ( $$038 >>> 0 ) ; if ( $29 ) { $$1 = $28 ; break L5 ; } $30 = ( ( $0 ) + ( $$038 ) | 0 ) ; $$042 = ( ( $1 ) - ( $$038 ) ) | 0 ; $$pre47 = HEAP32 [ $9 >> 2 ] | 0 ; $$139 = $$038 ; $$141 = $30 ; $$143 = $$042 ; $31 = $$pre47 ; } else { $$139 = 0 ; $$141 = $0 ; $$143 = $1 ; $31 = $14 ; } } while ( 0 ) ; ( _memcpy ( ( $31 | 0 ) , ( $$141 | 0 ) , ( $$143 | 0 ) ) | 0 ) ; $32 = HEAP32 [ $9 >> 2 ] | 0 ; $33 = ( ( $32 ) + ( $$143 ) | 0 ) ; HEAP32 [ $9 >> 2 ] = $33 ; $34 = ( ( $$139 ) + ( $$143 ) ) | 0 ; $$1 = $34 ; } } while ( 0 ) ; return ( $$1 | 0 ) ; } function ___towrite ( $0 ) { $0 = $0 | 0 ; var $$0 = 0 , $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 ; var $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( ( ( $0 ) ) + 74 | 0 ) ; $2 = HEAP8 [ $1 >> 0 ] | 0 ; $3 = $2 << 24 >> 24 ; $4 = ( ( $3 ) + 255 ) | 0 ; $5 = $4 | $3 ; $6 = $5 & 255 ; HEAP8 [ $1 >> 0 ] = $6 ; $7 = HEAP32 [ $0 >> 2 ] | 0 ; $8 = $7 & 8 ; $9 = ( $8 | 0 ) == ( 0 ) ; if ( $9 ) { $11 = ( ( ( $0 ) ) + 8 | 0 ) ; HEAP32 [ $11 >> 2 ] = 0 ; $12 = ( ( ( $0 ) ) + 4 | 0 ) ; HEAP32 [ $12 >> 2 ] = 0 ; $13 = ( ( ( $0 ) ) + 44 | 0 ) ; $14 = HEAP32 [ $13 >> 2 ] | 0 ; $15 = ( ( ( $0 ) ) + 28 | 0 ) ; HEAP32 [ $15 >> 2 ] = $14 ; $16 = ( ( ( $0 ) ) + 20 | 0 ) ; HEAP32 [ $16 >> 2 ] = $14 ; $17 = $14 ; $18 = ( ( ( $0 ) ) + 48 | 0 ) ; $19 = HEAP32 [ $18 >> 2 ] | 0 ; $20 = ( ( $17 ) + ( $19 ) | 0 ) ; $21 = ( ( ( $0 ) ) + 16 | 0 ) ; HEAP32 [ $21 >> 2 ] = $20 ; $$0 = 0 ; } else { $10 = $7 | 32 ; HEAP32 [ $0 >> 2 ] = $10 ; $$0 = - 1 ; } return ( $$0 | 0 ) ; } function _sn_write ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$ = 0 , $$cast = 0 , $10 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( ( ( $0 ) ) + 16 | 0 ) ; $4 = HEAP32 [ $3 >> 2 ] | 0 ; $5 = ( ( ( $0 ) ) + 20 | 0 ) ; $6 = HEAP32 [ $5 >> 2 ] | 0 ; $7 = ( ( $4 ) - ( $6 ) ) | 0 ; $8 = ( $7 >>> 0 ) > ( $2 >>> 0 ) ; $$ = $8 ? $2 : $7 ; $$cast = $6 ; ( _memcpy ( ( $$cast | 0 ) , ( $1 | 0 ) , ( $$ | 0 ) ) | 0 ) ; $9 = HEAP32 [ $5 >> 2 ] | 0 ; $10 = ( ( $9 ) + ( $$ ) | 0 ) ; HEAP32 [ $5 >> 2 ] = $10 ; return ( $2 | 0 ) ; } function ___shlim ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$sink = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( ( ( $0 ) ) + 104 | 0 ) ; HEAP32 [ $2 >> 2 ] = $1 ; $3 = ( ( ( $0 ) ) + 8 | 0 ) ; $4 = HEAP32 [ $3 >> 2 ] | 0 ; $5 = ( ( ( $0 ) ) + 4 | 0 ) ; $6 = HEAP32 [ $5 >> 2 ] | 0 ; $7 = ( ( $4 ) - ( $6 ) ) | 0 ; $8 = ( ( ( $0 ) ) + 108 | 0 ) ; HEAP32 [ $8 >> 2 ] = $7 ; $9 = ( $1 | 0 ) != ( 0 ) ; $10 = ( $7 | 0 ) > ( $1 | 0 ) ; $or$cond = $9 & $10 ; $11 = $4 ; $12 = $6 ; $13 = ( ( $12 ) + ( $1 ) | 0 ) ; $$sink = $or$cond ? $13 : $11 ; $14 = ( ( ( $0 ) ) + 100 | 0 ) ; HEAP32 [ $14 >> 2 ] = $$sink ; return ; } function ___intscan ( $0 , $1 , $2 , $3 , $4 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; $4 = $4 | 0 ; var $$0154222 = 0 , $$0157 = 0 , $$0157$ = 0 , $$0159 = 0 , $$1155192 = 0 , $$1158 = 0 , $$1160 = 0 , $$1160169 = 0 , $$1165 = 0 , $$1165167 = 0 , $$1165168 = 0 , $$166 = 0 , $$2156210 = 0 , $$2161$be = 0 , $$2161$lcssa = 0 , $$3162$be = 0 , $$3162215 = 0 , $$4163$be = 0 , $$4163$lcssa = 0 , $$5$be = 0 ; var $$6$be = 0 , $$6$lcssa = 0 , $$7$be = 0 , $$7198 = 0 , $$8 = 0 , $$9$be = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 , $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 ; var $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 , $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 ; var $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 , $136 = 0 , $137 = 0 , $138 = 0 , $139 = 0 , $14 = 0 , $140 = 0 , $141 = 0 , $142 = 0 , $143 = 0 , $144 = 0 , $145 = 0 , $146 = 0 , $147 = 0 , $148 = 0 ; var $149 = 0 , $15 = 0 , $150 = 0 , $151 = 0 , $152 = 0 , $153 = 0 , $154 = 0 , $155 = 0 , $156 = 0 , $157 = 0 , $158 = 0 , $159 = 0 , $16 = 0 , $160 = 0 , $161 = 0 , $162 = 0 , $163 = 0 , $164 = 0 , $165 = 0 , $166 = 0 ; var $167 = 0 , $168 = 0 , $169 = 0 , $17 = 0 , $170 = 0 , $171 = 0 , $172 = 0 , $173 = 0 , $174 = 0 , $175 = 0 , $176 = 0 , $177 = 0 , $178 = 0 , $179 = 0 , $18 = 0 , $180 = 0 , $181 = 0 , $182 = 0 , $183 = 0 , $184 = 0 ; var $185 = 0 , $186 = 0 , $187 = 0 , $188 = 0 , $189 = 0 , $19 = 0 , $190 = 0 , $191 = 0 , $192 = 0 , $193 = 0 , $194 = 0 , $195 = 0 , $196 = 0 , $197 = 0 , $198 = 0 , $199 = 0 , $20 = 0 , $200 = 0 , $201 = 0 , $202 = 0 ; var $203 = 0 , $204 = 0 , $205 = 0 , $206 = 0 , $207 = 0 , $208 = 0 , $209 = 0 , $21 = 0 , $210 = 0 , $211 = 0 , $212 = 0 , $213 = 0 , $214 = 0 , $215 = 0 , $216 = 0 , $217 = 0 , $218 = 0 , $219 = 0 , $22 = 0 , $220 = 0 ; var $221 = 0 , $222 = 0 , $223 = 0 , $224 = 0 , $225 = 0 , $226 = 0 , $227 = 0 , $228 = 0 , $229 = 0 , $23 = 0 , $230 = 0 , $231 = 0 , $232 = 0 , $233 = 0 , $234 = 0 , $235 = 0 , $236 = 0 , $237 = 0 , $238 = 0 , $239 = 0 ; var $24 = 0 , $240 = 0 , $241 = 0 , $242 = 0 , $243 = 0 , $244 = 0 , $245 = 0 , $246 = 0 , $247 = 0 , $248 = 0 , $249 = 0 , $25 = 0 , $250 = 0 , $251 = 0 , $252 = 0 , $253 = 0 , $254 = 0 , $255 = 0 , $256 = 0 , $257 = 0 ; var $258 = 0 , $259 = 0 , $26 = 0 , $260 = 0 , $261 = 0 , $262 = 0 , $263 = 0 , $264 = 0 , $265 = 0 , $266 = 0 , $267 = 0 , $268 = 0 , $269 = 0 , $27 = 0 , $270 = 0 , $271 = 0 , $272 = 0 , $273 = 0 , $274 = 0 , $275 = 0 ; var $276 = 0 , $277 = 0 , $278 = 0 , $279 = 0 , $28 = 0 , $280 = 0 , $281 = 0 , $282 = 0 , $283 = 0 , $284 = 0 , $285 = 0 , $286 = 0 , $287 = 0 , $288 = 0 , $289 = 0 , $29 = 0 , $290 = 0 , $291 = 0 , $292 = 0 , $293 = 0 ; var $294 = 0 , $295 = 0 , $296 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 ; var $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 , $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 ; var $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 , $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 ; var $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 , $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $or$cond = 0 , $or$cond12 = 0 ; var $or$cond187 = 0 , $or$cond5 = 0 , $or$cond7 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $5 = ( $1 >>> 0 ) > ( 36 ) ; L1 : do { if ( $5 ) { $8 = ( ___errno_location ( ) | 0 ) ; HEAP32 [ $8 >> 2 ] = 22 ; $289 = 0 ; $290 = 0 ; } else { $6 = ( ( ( $0 ) ) + 4 | 0 ) ; $7 = ( ( ( $0 ) ) + 100 | 0 ) ; while ( 1 ) { $9 = HEAP32 [ $6 >> 2 ] | 0 ; $10 = HEAP32 [ $7 >> 2 ] | 0 ; $11 = ( $9 >>> 0 ) < ( $10 >>> 0 ) ; if ( $11 ) { $12 = ( ( ( $9 ) ) + 1 | 0 ) ; HEAP32 [ $6 >> 2 ] = $12 ; $13 = HEAP8 [ $9 >> 0 ] | 0 ; $14 = $13 & 255 ; $16 = $14 ; } else { $15 = ( ___shgetc ( $0 ) | 0 ) ; $16 = $15 ; } $17 = ( _isspace ( $16 ) | 0 ) ; $18 = ( $17 | 0 ) == ( 0 ) ; if ( $18 ) { break ; } } L11 : do { switch ( $16 | 0 ) { case 43 : case 45 : { $19 = ( $16 | 0 ) == ( 45 ) ; $20 = $19 << 31 >> 31 ; $21 = HEAP32 [ $6 >> 2 ] | 0 ; $22 = HEAP32 [ $7 >> 2 ] | 0 ; $23 = ( $21 >>> 0 ) < ( $22 >>> 0 ) ; if ( $23 ) { $24 = ( ( ( $21 ) ) + 1 | 0 ) ; HEAP32 [ $6 >> 2 ] = $24 ; $25 = HEAP8 [ $21 >> 0 ] | 0 ; $26 = $25 & 255 ; $$0157 = $20 ; $$0159 = $26 ; break L11 ; } else { $27 = ( ___shgetc ( $0 ) | 0 ) ; $$0157 = $20 ; $$0159 = $27 ; break L11 ; } break ; } default : { $$0157 = 0 ; $$0159 = $16 ; } } } while ( 0 ) ; $28 = ( $1 | 0 ) == ( 0 ) ; $29 = $1 | 16 ; $30 = ( $29 | 0 ) == ( 16 ) ; $31 = ( $$0159 | 0 ) == ( 48 ) ; $or$cond5 = $30 & $31 ; do { if ( $or$cond5 ) { $32 = HEAP32 [ $6 >> 2 ] | 0 ; $33 = HEAP32 [ $7 >> 2 ] | 0 ; $34 = ( $32 >>> 0 ) < ( $33 >>> 0 ) ; if ( $34 ) { $35 = ( ( ( $32 ) ) + 1 | 0 ) ; HEAP32 [ $6 >> 2 ] = $35 ; $36 = HEAP8 [ $32 >> 0 ] | 0 ; $37 = $36 & 255 ; $40 = $37 ; } else { $38 = ( ___shgetc ( $0 ) | 0 ) ; $40 = $38 ; } $39 = $40 | 32 ; $41 = ( $39 | 0 ) == ( 120 ) ; if ( ! ( $41 ) ) { if ( $28 ) { $$1160169 = $40 ; $$1165167 = 8 ; label = 46 ; break ; } else { $$1160 = $40 ; $$1165 = $1 ; label = 32 ; break ; } } $42 = HEAP32 [ $6 >> 2 ] | 0 ; $43 = HEAP32 [ $7 >> 2 ] | 0 ; $44 = ( $42 >>> 0 ) < ( $43 >>> 0 ) ; if ( $44 ) { $45 = ( ( ( $42 ) ) + 1 | 0 ) ; HEAP32 [ $6 >> 2 ] = $45 ; $46 = HEAP8 [ $42 >> 0 ] | 0 ; $47 = $46 & 255 ; $50 = $47 ; } else { $48 = ( ___shgetc ( $0 ) | 0 ) ; $50 = $48 ; } $49 = ( ( 33248 ) + ( $50 ) | 0 ) ; $51 = HEAP8 [ $49 >> 0 ] | 0 ; $52 = ( $51 & 255 ) > ( 15 ) ; if ( $52 ) { $53 = HEAP32 [ $7 >> 2 ] | 0 ; $54 = ( $53 | 0 ) == ( 0 | 0 ) ; if ( ! ( $54 ) ) { $55 = HEAP32 [ $6 >> 2 ] | 0 ; $56 = ( ( ( $55 ) ) + - 1 | 0 ) ; HEAP32 [ $6 >> 2 ] = $56 ; } $57 = ( $2 | 0 ) == ( 0 ) ; if ( $57 ) { ___shlim ( $0 , 0 ) ; $289 = 0 ; $290 = 0 ; break L1 ; } if ( $54 ) { $289 = 0 ; $290 = 0 ; break L1 ; } $58 = HEAP32 [ $6 >> 2 ] | 0 ; $59 = ( ( ( $58 ) ) + - 1 | 0 ) ; HEAP32 [ $6 >> 2 ] = $59 ; $289 = 0 ; $290 = 0 ; break L1 ; } else { $$1160169 = $50 ; $$1165167 = 16 ; label = 46 ; } } else { $$166 = $28 ? 10 : $1 ; $60 = ( ( 33248 ) + ( $$0159 ) | 0 ) ; $61 = HEAP8 [ $60 >> 0 ] | 0 ; $62 = $61 & 255 ; $63 = ( $$166 >>> 0 ) > ( $62 >>> 0 ) ; if ( $63 ) { $$1160 = $$0159 ; $$1165 = $$166 ; label = 32 ; } else { $64 = HEAP32 [ $7 >> 2 ] | 0 ; $65 = ( $64 | 0 ) == ( 0 | 0 ) ; if ( ! ( $65 ) ) { $66 = HEAP32 [ $6 >> 2 ] | 0 ; $67 = ( ( ( $66 ) ) + - 1 | 0 ) ; HEAP32 [ $6 >> 2 ] = $67 ; } ___shlim ( $0 , 0 ) ; $68 = ( ___errno_location ( ) | 0 ) ; HEAP32 [ $68 >> 2 ] = 22 ; $289 = 0 ; $290 = 0 ; break L1 ; } } } while ( 0 ) ; L43 : do { if ( ( label | 0 ) == 32 ) { $69 = ( $$1165 | 0 ) == ( 10 ) ; if ( $69 ) { $70 = ( ( $$1160 ) + - 48 ) | 0 ; $71 = ( $70 >>> 0 ) < ( 10 ) ; if ( $71 ) { $$0154222 = 0 ; $74 = $70 ; while ( 1 ) { $72 = ( $$0154222 * 10 ) | 0 ; $73 = ( ( $72 ) + ( $74 ) ) | 0 ; $75 = HEAP32 [ $6 >> 2 ] | 0 ; $76 = HEAP32 [ $7 >> 2 ] | 0 ; $77 = ( $75 >>> 0 ) < ( $76 >>> 0 ) ; if ( $77 ) { $78 = ( ( ( $75 ) ) + 1 | 0 ) ; HEAP32 [ $6 >> 2 ] = $78 ; $79 = HEAP8 [ $75 >> 0 ] | 0 ; $80 = $79 & 255 ; $$2161$be = $80 ; } else { $81 = ( ___shgetc ( $0 ) | 0 ) ; $$2161$be = $81 ; } $82 = ( ( $$2161$be ) + - 48 ) | 0 ; $83 = ( $82 >>> 0 ) < ( 10 ) ; $84 = ( $73 >>> 0 ) < ( 429496729 ) ; $85 = $83 & $84 ; if ( $85 ) { $$0154222 = $73 ; $74 = $82 ; } else { break ; } } $$2161$lcssa = $$2161$be ; $291 = $73 ; $292 = 0 ; } else { $$2161$lcssa = $$1160 ; $291 = 0 ; $292 = 0 ; } $86 = ( ( $$2161$lcssa ) + - 48 ) | 0 ; $87 = ( $86 >>> 0 ) < ( 10 ) ; if ( $87 ) { $$3162215 = $$2161$lcssa ; $88 = $291 ; $89 = $292 ; $92 = $86 ; while ( 1 ) { $90 = ( ___muldi3 ( ( $88 | 0 ) , ( $89 | 0 ) , 10 , 0 ) | 0 ) ; $91 = tempRet0 ; $93 = ( $92 | 0 ) < ( 0 ) ; $94 = $93 << 31 >> 31 ; $95 = $92 ^ - 1 ; $96 = $94 ^ - 1 ; $97 = ( $91 >>> 0 ) > ( $96 >>> 0 ) ; $98 = ( $90 >>> 0 ) > ( $95 >>> 0 ) ; $99 = ( $91 | 0 ) == ( $96 | 0 ) ; $100 = $99 & $98 ; $101 = $97 | $100 ; if ( $101 ) { $$1165168 = 10 ; $$8 = $$3162215 ; $293 = $88 ; $294 = $89 ; label = 72 ; break L43 ; } $102 = ( _i64Add ( ( $90 | 0 ) , ( $91 | 0 ) , ( $92 | 0 ) , ( $94 | 0 ) ) | 0 ) ; $103 = tempRet0 ; $104 = HEAP32 [ $6 >> 2 ] | 0 ; $105 = HEAP32 [ $7 >> 2 ] | 0 ; $106 = ( $104 >>> 0 ) < ( $105 >>> 0 ) ; if ( $106 ) { $107 = ( ( ( $104 ) ) + 1 | 0 ) ; HEAP32 [ $6 >> 2 ] = $107 ; $108 = HEAP8 [ $104 >> 0 ] | 0 ; $109 = $108 & 255 ; $$3162$be = $109 ; } else { $110 = ( ___shgetc ( $0 ) | 0 ) ; $$3162$be = $110 ; } $111 = ( ( $$3162$be ) + - 48 ) | 0 ; $112 = ( $111 >>> 0 ) < ( 10 ) ; $113 = ( $103 >>> 0 ) < ( 429496729 ) ; $114 = ( $102 >>> 0 ) < ( 2576980378 ) ; $115 = ( $103 | 0 ) == ( 429496729 ) ; $116 = $115 & $114 ; $117 = $113 | $116 ; $or$cond7 = $112 & $117 ; if ( $or$cond7 ) { $$3162215 = $$3162$be ; $88 = $102 ; $89 = $103 ; $92 = $111 ; } else { break ; } } $118 = ( $111 >>> 0 ) > ( 9 ) ; if ( $118 ) { $$1158 = $$0157 ; $262 = $103 ; $264 = $102 ; } else { $$1165168 = 10 ; $$8 = $$3162$be ; $293 = $102 ; $294 = $103 ; label = 72 ; } } else { $$1158 = $$0157 ; $262 = $292 ; $264 = $291 ; } } else { $$1160169 = $$1160 ; $$1165167 = $$1165 ; label = 46 ; } } } while ( 0 ) ; L63 : do { if ( ( label | 0 ) == 46 ) { $119 = ( ( $$1165167 ) + - 1 ) | 0 ; $120 = $119 & $$1165167 ; $121 = ( $120 | 0 ) == ( 0 ) ; if ( $121 ) { $126 = ( $$1165167 * 23 ) | 0 ; $127 = $126 >>> 5 ; $128 = $127 & 7 ; $129 = ( 33504 + ( $128 ) | 0 ) ; $130 = HEAP8 [ $129 >> 0 ] | 0 ; $131 = $130 << 24 >> 24 ; $132 = ( ( 33248 ) + ( $$1160169 ) | 0 ) ; $133 = HEAP8 [ $132 >> 0 ] | 0 ; $134 = $133 & 255 ; $135 = ( $$1165167 >>> 0 ) > ( $134 >>> 0 ) ; if ( $135 ) { $$1155192 = 0 ; $138 = $134 ; while ( 1 ) { $136 = $$1155192 << $131 ; $137 = $138 | $136 ; $139 = HEAP32 [ $6 >> 2 ] | 0 ; $140 = HEAP32 [ $7 >> 2 ] | 0 ; $141 = ( $139 >>> 0 ) < ( $140 >>> 0 ) ; if ( $141 ) { $142 = ( ( ( $139 ) ) + 1 | 0 ) ; HEAP32 [ $6 >> 2 ] = $142 ; $143 = HEAP8 [ $139 >> 0 ] | 0 ; $144 = $143 & 255 ; $$4163$be = $144 ; } else { $145 = ( ___shgetc ( $0 ) | 0 ) ; $$4163$be = $145 ; } $146 = ( ( 33248 ) + ( $$4163$be ) | 0 ) ; $147 = HEAP8 [ $146 >> 0 ] | 0 ; $148 = $147 & 255 ; $149 = ( $$1165167 >>> 0 ) > ( $148 >>> 0 ) ; $150 = ( $137 >>> 0 ) < ( 134217728 ) ; $151 = $150 & $149 ; if ( $151 ) { $$1155192 = $137 ; $138 = $148 ; } else { break ; } } $$4163$lcssa = $$4163$be ; $155 = $147 ; $158 = 0 ; $160 = $137 ; } else { $$4163$lcssa = $$1160169 ; $155 = $133 ; $158 = 0 ; $160 = 0 ; } $152 = ( _bitshift64Lshr ( - 1 , - 1 , ( $131 | 0 ) ) | 0 ) ; $153 = tempRet0 ; $154 = $155 & 255 ; $156 = ( $$1165167 >>> 0 ) <= ( $154 >>> 0 ) ; $157 = ( $153 >>> 0 ) < ( $158 >>> 0 ) ; $159 = ( $152 >>> 0 ) < ( $160 >>> 0 ) ; $161 = ( $153 | 0 ) == ( $158 | 0 ) ; $162 = $161 & $159 ; $163 = $157 | $162 ; $or$cond187 = $156 | $163 ; if ( $or$cond187 ) { $$1165168 = $$1165167 ; $$8 = $$4163$lcssa ; $293 = $160 ; $294 = $158 ; label = 72 ; break ; } else { $164 = $160 ; $165 = $158 ; $169 = $155 ; } while ( 1 ) { $166 = ( _bitshift64Shl ( ( $164 | 0 ) , ( $165 | 0 ) , ( $131 | 0 ) ) | 0 ) ; $167 = tempRet0 ; $168 = $169 & 255 ; $170 = $166 | $168 ; $171 = HEAP32 [ $6 >> 2 ] | 0 ; $172 = HEAP32 [ $7 >> 2 ] | 0 ; $173 = ( $171 >>> 0 ) < ( $172 >>> 0 ) ; if ( $173 ) { $174 = ( ( ( $171 ) ) + 1 | 0 ) ; HEAP32 [ $6 >> 2 ] = $174 ; $175 = HEAP8 [ $171 >> 0 ] | 0 ; $176 = $175 & 255 ; $$5$be = $176 ; } else { $177 = ( ___shgetc ( $0 ) | 0 ) ; $$5$be = $177 ; } $178 = ( ( 33248 ) + ( $$5$be ) | 0 ) ; $179 = HEAP8 [ $178 >> 0 ] | 0 ; $180 = $179 & 255 ; $181 = ( $$1165167 >>> 0 ) <= ( $180 >>> 0 ) ; $182 = ( $167 >>> 0 ) > ( $153 >>> 0 ) ; $183 = ( $170 >>> 0 ) > ( $152 >>> 0 ) ; $184 = ( $167 | 0 ) == ( $153 | 0 ) ; $185 = $184 & $183 ; $186 = $182 | $185 ; $or$cond = $181 | $186 ; if ( $or$cond ) { $$1165168 = $$1165167 ; $$8 = $$5$be ; $293 = $170 ; $294 = $167 ; label = 72 ; break L63 ; } else { $164 = $170 ; $165 = $167 ; $169 = $179 ; } } } $122 = ( ( 33248 ) + ( $$1160169 ) | 0 ) ; $123 = HEAP8 [ $122 >> 0 ] | 0 ; $124 = $123 & 255 ; $125 = ( $$1165167 >>> 0 ) > ( $124 >>> 0 ) ; if ( $125 ) { $$2156210 = 0 ; $189 = $124 ; while ( 1 ) { $187 = Math_imul ( $$2156210 , $$1165167 ) | 0 ; $188 = ( ( $189 ) + ( $187 ) ) | 0 ; $190 = HEAP32 [ $6 >> 2 ] | 0 ; $191 = HEAP32 [ $7 >> 2 ] | 0 ; $192 = ( $190 >>> 0 ) < ( $191 >>> 0 ) ; if ( $192 ) { $193 = ( ( ( $190 ) ) + 1 | 0 ) ; HEAP32 [ $6 >> 2 ] = $193 ; $194 = HEAP8 [ $190 >> 0 ] | 0 ; $195 = $194 & 255 ; $$6$be = $195 ; } else { $196 = ( ___shgetc ( $0 ) | 0 ) ; $$6$be = $196 ; } $197 = ( ( 33248 ) + ( $$6$be ) | 0 ) ; $198 = HEAP8 [ $197 >> 0 ] | 0 ; $199 = $198 & 255 ; $200 = ( $$1165167 >>> 0 ) > ( $199 >>> 0 ) ; $201 = ( $188 >>> 0 ) < ( 119304647 ) ; $202 = $201 & $200 ; if ( $202 ) { $$2156210 = $188 ; $189 = $199 ; } else { break ; } } $$6$lcssa = $$6$be ; $204 = $198 ; $295 = $188 ; $296 = 0 ; } else { $$6$lcssa = $$1160169 ; $204 = $123 ; $295 = 0 ; $296 = 0 ; } $203 = $204 & 255 ; $205 = ( $$1165167 >>> 0 ) > ( $203 >>> 0 ) ; if ( $205 ) { $206 = ( ___udivdi3 ( - 1 , - 1 , ( $$1165167 | 0 ) , 0 ) | 0 ) ; $207 = tempRet0 ; $$7198 = $$6$lcssa ; $208 = $296 ; $210 = $295 ; $218 = $204 ; while ( 1 ) { $209 = ( $208 >>> 0 ) > ( $207 >>> 0 ) ; $211 = ( $210 >>> 0 ) > ( $206 >>> 0 ) ; $212 = ( $208 | 0 ) == ( $207 | 0 ) ; $213 = $212 & $211 ; $214 = $209 | $213 ; if ( $214 ) { $$1165168 = $$1165167 ; $$8 = $$7198 ; $293 = $210 ; $294 = $208 ; label = 72 ; break L63 ; } $215 = ( ___muldi3 ( ( $210 | 0 ) , ( $208 | 0 ) , ( $$1165167 | 0 ) , 0 ) | 0 ) ; $216 = tempRet0 ; $217 = $218 & 255 ; $219 = $217 ^ - 1 ; $220 = ( $216 >>> 0 ) > ( 4294967295 ) ; $221 = ( $215 >>> 0 ) > ( $219 >>> 0 ) ; $222 = ( $216 | 0 ) == ( - 1 ) ; $223 = $222 & $221 ; $224 = $220 | $223 ; if ( $224 ) { $$1165168 = $$1165167 ; $$8 = $$7198 ; $293 = $210 ; $294 = $208 ; label = 72 ; break L63 ; } $225 = ( _i64Add ( ( $215 | 0 ) , ( $216 | 0 ) , ( $217 | 0 ) , 0 ) | 0 ) ; $226 = tempRet0 ; $227 = HEAP32 [ $6 >> 2 ] | 0 ; $228 = HEAP32 [ $7 >> 2 ] | 0 ; $229 = ( $227 >>> 0 ) < ( $228 >>> 0 ) ; if ( $229 ) { $230 = ( ( ( $227 ) ) + 1 | 0 ) ; HEAP32 [ $6 >> 2 ] = $230 ; $231 = HEAP8 [ $227 >> 0 ] | 0 ; $232 = $231 & 255 ; $$7$be = $232 ; } else { $233 = ( ___shgetc ( $0 ) | 0 ) ; $$7$be = $233 ; } $234 = ( ( 33248 ) + ( $$7$be ) | 0 ) ; $235 = HEAP8 [ $234 >> 0 ] | 0 ; $236 = $235 & 255 ; $237 = ( $$1165167 >>> 0 ) > ( $236 >>> 0 ) ; if ( $237 ) { $$7198 = $$7$be ; $208 = $226 ; $210 = $225 ; $218 = $235 ; } else { $$1165168 = $$1165167 ; $$8 = $$7$be ; $293 = $225 ; $294 = $226 ; label = 72 ; break ; } } } else { $$1165168 = $$1165167 ; $$8 = $$6$lcssa ; $293 = $295 ; $294 = $296 ; label = 72 ; } } } while ( 0 ) ; if ( ( label | 0 ) == 72 ) { $238 = ( ( 33248 ) + ( $$8 ) | 0 ) ; $239 = HEAP8 [ $238 >> 0 ] | 0 ; $240 = $239 & 255 ; $241 = ( $$1165168 >>> 0 ) > ( $240 >>> 0 ) ; if ( $241 ) { while ( 1 ) { $242 = HEAP32 [ $6 >> 2 ] | 0 ; $243 = HEAP32 [ $7 >> 2 ] | 0 ; $244 = ( $242 >>> 0 ) < ( $243 >>> 0 ) ; if ( $244 ) { $245 = ( ( ( $242 ) ) + 1 | 0 ) ; HEAP32 [ $6 >> 2 ] = $245 ; $246 = HEAP8 [ $242 >> 0 ] | 0 ; $247 = $246 & 255 ; $$9$be = $247 ; } else { $248 = ( ___shgetc ( $0 ) | 0 ) ; $$9$be = $248 ; } $249 = ( ( 33248 ) + ( $$9$be ) | 0 ) ; $250 = HEAP8 [ $249 >> 0 ] | 0 ; $251 = $250 & 255 ; $252 = ( $$1165168 >>> 0 ) > ( $251 >>> 0 ) ; if ( ! ( $252 ) ) { break ; } } $253 = ( ___errno_location ( ) | 0 ) ; HEAP32 [ $253 >> 2 ] = 34 ; $254 = $3 & 1 ; $255 = ( $254 | 0 ) == ( 0 ) ; $256 = ( 0 ) == ( 0 ) ; $257 = $255 & $256 ; $$0157$ = $257 ? $$0157 : 0 ; $$1158 = $$0157$ ; $262 = $4 ; $264 = $3 ; } else { $$1158 = $$0157 ; $262 = $294 ; $264 = $293 ; } } $258 = HEAP32 [ $7 >> 2 ] | 0 ; $259 = ( $258 | 0 ) == ( 0 | 0 ) ; if ( ! ( $259 ) ) { $260 = HEAP32 [ $6 >> 2 ] | 0 ; $261 = ( ( ( $260 ) ) + - 1 | 0 ) ; HEAP32 [ $6 >> 2 ] = $261 ; } $263 = ( $262 >>> 0 ) < ( $4 >>> 0 ) ; $265 = ( $264 >>> 0 ) < ( $3 >>> 0 ) ; $266 = ( $262 | 0 ) == ( $4 | 0 ) ; $267 = $266 & $265 ; $268 = $263 | $267 ; if ( ! ( $268 ) ) { $269 = $3 & 1 ; $270 = ( $269 | 0 ) != ( 0 ) ; $271 = ( 0 ) != ( 0 ) ; $272 = $270 | $271 ; $273 = ( $$1158 | 0 ) != ( 0 ) ; $or$cond12 = $272 | $273 ; if ( ! ( $or$cond12 ) ) { $274 = ( ___errno_location ( ) | 0 ) ; HEAP32 [ $274 >> 2 ] = 34 ; $275 = ( _i64Add ( ( $3 | 0 ) , ( $4 | 0 ) , - 1 , - 1 ) | 0 ) ; $276 = tempRet0 ; $289 = $276 ; $290 = $275 ; break ; } $277 = ( $262 >>> 0 ) > ( $4 >>> 0 ) ; $278 = ( $264 >>> 0 ) > ( $3 >>> 0 ) ; $279 = ( $262 | 0 ) == ( $4 | 0 ) ; $280 = $279 & $278 ; $281 = $277 | $280 ; if ( $281 ) { $282 = ( ___errno_location ( ) | 0 ) ; HEAP32 [ $282 >> 2 ] = 34 ; $289 = $4 ; $290 = $3 ; break ; } } $283 = ( $$1158 | 0 ) < ( 0 ) ; $284 = $283 << 31 >> 31 ; $285 = $264 ^ $$1158 ; $286 = $262 ^ $284 ; $287 = ( _i64Subtract ( ( $285 | 0 ) , ( $286 | 0 ) , ( $$1158 | 0 ) , ( $284 | 0 ) ) | 0 ) ; $288 = tempRet0 ; $289 = $288 ; $290 = $287 ; } } while ( 0 ) ; tempRet0 = ( $289 ) ; return ( $290 | 0 ) ; } function ___shgetc ( $0 ) { $0 = $0 | 0 ; var $$0 = 0 , $$phi$trans$insert = 0 , $$phi$trans$insert29 = 0 , $$pre = 0 , $$pre30 = 0 , $$sink = 0 , $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 ; var $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 ; var $40 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( ( ( $0 ) ) + 104 | 0 ) ; $2 = HEAP32 [ $1 >> 2 ] | 0 ; $3 = ( $2 | 0 ) == ( 0 ) ; if ( $3 ) { label = 3 ; } else { $4 = ( ( ( $0 ) ) + 108 | 0 ) ; $5 = HEAP32 [ $4 >> 2 ] | 0 ; $6 = ( $5 | 0 ) < ( $2 | 0 ) ; if ( $6 ) { label = 3 ; } else { label = 4 ; } } if ( ( label | 0 ) == 3 ) { $7 = ( ___uflow ( $0 ) | 0 ) ; $8 = ( $7 | 0 ) < ( 0 ) ; if ( $8 ) { label = 4 ; } else { $10 = HEAP32 [ $1 >> 2 ] | 0 ; $11 = ( $10 | 0 ) == ( 0 ) ; $$phi$trans$insert = ( ( ( $0 ) ) + 8 | 0 ) ; if ( $11 ) { $$pre = HEAP32 [ $$phi$trans$insert >> 2 ] | 0 ; $$sink = $$pre ; $25 = $$pre ; } else { $12 = HEAP32 [ $$phi$trans$insert >> 2 ] | 0 ; $13 = ( ( ( $0 ) ) + 4 | 0 ) ; $14 = HEAP32 [ $13 >> 2 ] | 0 ; $15 = $14 ; $16 = ( ( $12 ) - ( $15 ) ) | 0 ; $17 = ( ( ( $0 ) ) + 108 | 0 ) ; $18 = HEAP32 [ $17 >> 2 ] | 0 ; $19 = ( ( $10 ) - ( $18 ) ) | 0 ; $20 = ( $16 | 0 ) < ( $19 | 0 ) ; $21 = $12 ; if ( $20 ) { $$sink = $21 ; $25 = $21 ; } else { $22 = ( ( $19 ) + - 1 ) | 0 ; $23 = ( ( $14 ) + ( $22 ) | 0 ) ; $$sink = $23 ; $25 = $21 ; } } $24 = ( ( ( $0 ) ) + 100 | 0 ) ; HEAP32 [ $24 >> 2 ] = $$sink ; $26 = ( $25 | 0 ) == ( 0 | 0 ) ; $$phi$trans$insert29 = ( ( ( $0 ) ) + 4 | 0 ) ; if ( $26 ) { $$pre30 = HEAP32 [ $$phi$trans$insert29 >> 2 ] | 0 ; $36 = $$pre30 ; } else { $27 = HEAP32 [ $$phi$trans$insert29 >> 2 ] | 0 ; $28 = $25 ; $29 = ( ( ( $0 ) ) + 108 | 0 ) ; $30 = HEAP32 [ $29 >> 2 ] | 0 ; $31 = ( ( $28 ) + 1 ) | 0 ; $32 = ( ( $31 ) - ( $27 ) ) | 0 ; $33 = ( ( $32 ) + ( $30 ) ) | 0 ; HEAP32 [ $29 >> 2 ] = $33 ; $34 = $27 ; $36 = $34 ; } $35 = ( ( ( $36 ) ) + - 1 | 0 ) ; $37 = HEAP8 [ $35 >> 0 ] | 0 ; $38 = $37 & 255 ; $39 = ( $7 | 0 ) == ( $38 | 0 ) ; if ( $39 ) { $$0 = $7 ; } else { $40 = $7 & 255 ; HEAP8 [ $35 >> 0 ] = $40 ; $$0 = $7 ; } } } if ( ( label | 0 ) == 4 ) { $9 = ( ( ( $0 ) ) + 100 | 0 ) ; HEAP32 [ $9 >> 2 ] = 0 ; $$0 = - 1 ; } return ( $$0 | 0 ) ; } function _isspace ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $narrow = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( $0 | 0 ) == ( 32 ) ; $2 = ( ( $0 ) + - 9 ) | 0 ; $3 = ( $2 >>> 0 ) < ( 5 ) ; $narrow = $1 | $3 ; $4 = $narrow & 1 ; return ( $4 | 0 ) ; } function ___uflow ( $0 ) { $0 = $0 | 0 ; var $$0 = 0 , $1 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $1 = sp ; $2 = ( ___toread ( $0 ) | 0 ) ; $3 = ( $2 | 0 ) == ( 0 ) ; if ( $3 ) { $4 = ( ( ( $0 ) ) + 32 | 0 ) ; $5 = HEAP32 [ $4 >> 2 ] | 0 ; $6 = ( FUNCTION_TABLE_iiii [ $5 & 127 ] ( $0 , $1 , 1 ) | 0 ) ; $7 = ( $6 | 0 ) == ( 1 ) ; if ( $7 ) { $8 = HEAP8 [ $1 >> 0 ] | 0 ; $9 = $8 & 255 ; $$0 = $9 ; } else { $$0 = - 1 ; } } else { $$0 = - 1 ; } STACKTOP = sp ; return ( $$0 | 0 ) ; } function ___toread ( $0 ) { $0 = $0 | 0 ; var $$0 = 0 , $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 ; var $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $sext = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( ( ( $0 ) ) + 74 | 0 ) ; $2 = HEAP8 [ $1 >> 0 ] | 0 ; $3 = $2 << 24 >> 24 ; $4 = ( ( $3 ) + 255 ) | 0 ; $5 = $4 | $3 ; $6 = $5 & 255 ; HEAP8 [ $1 >> 0 ] = $6 ; $7 = ( ( ( $0 ) ) + 20 | 0 ) ; $8 = HEAP32 [ $7 >> 2 ] | 0 ; $9 = ( ( ( $0 ) ) + 28 | 0 ) ; $10 = HEAP32 [ $9 >> 2 ] | 0 ; $11 = ( $8 >>> 0 ) > ( $10 >>> 0 ) ; if ( $11 ) { $12 = ( ( ( $0 ) ) + 36 | 0 ) ; $13 = HEAP32 [ $12 >> 2 ] | 0 ; ( FUNCTION_TABLE_iiii [ $13 & 127 ] ( $0 , 0 , 0 ) | 0 ) ; } $14 = ( ( ( $0 ) ) + 16 | 0 ) ; HEAP32 [ $14 >> 2 ] = 0 ; HEAP32 [ $9 >> 2 ] = 0 ; HEAP32 [ $7 >> 2 ] = 0 ; $15 = HEAP32 [ $0 >> 2 ] | 0 ; $16 = $15 & 4 ; $17 = ( $16 | 0 ) == ( 0 ) ; if ( $17 ) { $19 = ( ( ( $0 ) ) + 44 | 0 ) ; $20 = HEAP32 [ $19 >> 2 ] | 0 ; $21 = ( ( ( $0 ) ) + 48 | 0 ) ; $22 = HEAP32 [ $21 >> 2 ] | 0 ; $23 = ( ( $20 ) + ( $22 ) | 0 ) ; $24 = ( ( ( $0 ) ) + 8 | 0 ) ; HEAP32 [ $24 >> 2 ] = $23 ; $25 = ( ( ( $0 ) ) + 4 | 0 ) ; HEAP32 [ $25 >> 2 ] = $23 ; $26 = $15 << 27 ; $sext = $26 >> 31 ; $$0 = $sext ; } else { $18 = $15 | 32 ; HEAP32 [ $0 >> 2 ] = $18 ; $$0 = - 1 ; } return ( $$0 | 0 ) ; } function _strcspn ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$01824 = 0 , $$019$sink = 0 , $$01922 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 ; var $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 ; var $9 = 0 , $div = 0 , $div20 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 32 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 32 | 0 ) ; $2 = sp ; $3 = HEAP8 [ $1 >> 0 ] | 0 ; $4 = ( $3 << 24 >> 24 ) == ( 0 ) ; L1 : do { if ( $4 ) { label = 3 ; } else { $5 = ( ( ( $1 ) ) + 1 | 0 ) ; $6 = HEAP8 [ $5 >> 0 ] | 0 ; $7 = ( $6 << 24 >> 24 ) == ( 0 ) ; if ( $7 ) { label = 3 ; } else { ( _memset ( ( $2 | 0 ) , 0 , 32 ) | 0 ) ; $10 = HEAP8 [ $1 >> 0 ] | 0 ; $11 = ( $10 << 24 >> 24 ) == ( 0 ) ; if ( ! ( $11 ) ) { $$01824 = $1 ; $15 = $10 ; while ( 1 ) { $14 = $15 & 31 ; $16 = $14 & 255 ; $17 = 1 << $16 ; $div20 = ( $15 & 255 ) >>> 5 ; $18 = $div20 & 255 ; $19 = ( ( $2 ) + ( $18 << 2 ) | 0 ) ; $20 = HEAP32 [ $19 >> 2 ] | 0 ; $21 = $20 | $17 ; HEAP32 [ $19 >> 2 ] = $21 ; $22 = ( ( ( $$01824 ) ) + 1 | 0 ) ; $23 = HEAP8 [ $22 >> 0 ] | 0 ; $24 = ( $23 << 24 >> 24 ) == ( 0 ) ; if ( $24 ) { break ; } else { $$01824 = $22 ; $15 = $23 ; } } } $12 = HEAP8 [ $0 >> 0 ] | 0 ; $13 = ( $12 << 24 >> 24 ) == ( 0 ) ; if ( $13 ) { $$019$sink = $0 ; } else { $$01922 = $0 ; $25 = $12 ; while ( 1 ) { $div = ( $25 & 255 ) >>> 5 ; $26 = $div & 255 ; $27 = ( ( $2 ) + ( $26 << 2 ) | 0 ) ; $28 = HEAP32 [ $27 >> 2 ] | 0 ; $29 = $25 & 31 ; $30 = $29 & 255 ; $31 = 1 << $30 ; $32 = $28 & $31 ; $33 = ( $32 | 0 ) == ( 0 ) ; if ( ! ( $33 ) ) { $$019$sink = $$01922 ; break L1 ; } $34 = ( ( ( $$01922 ) ) + 1 | 0 ) ; $35 = HEAP8 [ $34 >> 0 ] | 0 ; $36 = ( $35 << 24 >> 24 ) == ( 0 ) ; if ( $36 ) { $$019$sink = $34 ; break ; } else { $$01922 = $34 ; $25 = $35 ; } } } } } } while ( 0 ) ; if ( ( label | 0 ) == 3 ) { $8 = $3 << 24 >> 24 ; $9 = ( ___strchrnul ( $0 , $8 ) | 0 ) ; $$019$sink = $9 ; } $37 = $$019$sink ; $38 = $0 ; $39 = ( ( $37 ) - ( $38 ) ) | 0 ; STACKTOP = sp ; return ( $39 | 0 ) ; } function ___strchrnul ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$0 = 0 , $$029$lcssa = 0 , $$02936 = 0 , $$030$lcssa = 0 , $$03039 = 0 , $$1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 ; var $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 ; var $41 = 0 , $42 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , $or$cond33 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = $1 & 255 ; $3 = ( $2 | 0 ) == ( 0 ) ; L1 : do { if ( $3 ) { $8 = ( _strlen ( $0 ) | 0 ) ; $9 = ( ( $0 ) + ( $8 ) | 0 ) ; $$0 = $9 ; } else { $4 = $0 ; $5 = $4 & 3 ; $6 = ( $5 | 0 ) == ( 0 ) ; if ( $6 ) { $$030$lcssa = $0 ; } else { $7 = $1 & 255 ; $$03039 = $0 ; while ( 1 ) { $10 = HEAP8 [ $$03039 >> 0 ] | 0 ; $11 = ( $10 << 24 >> 24 ) == ( 0 ) ; $12 = ( $10 << 24 >> 24 ) == ( $7 << 24 >> 24 ) ; $or$cond = $11 | $12 ; if ( $or$cond ) { $$0 = $$03039 ; break L1 ; } $13 = ( ( ( $$03039 ) ) + 1 | 0 ) ; $14 = $13 ; $15 = $14 & 3 ; $16 = ( $15 | 0 ) == ( 0 ) ; if ( $16 ) { $$030$lcssa = $13 ; break ; } else { $$03039 = $13 ; } } } $17 = Math_imul ( $2 , 16843009 ) | 0 ; $18 = HEAP32 [ $$030$lcssa >> 2 ] | 0 ; $19 = ( ( $18 ) + - 16843009 ) | 0 ; $20 = $18 & - 2139062144 ; $21 = $20 ^ - 2139062144 ; $22 = $21 & $19 ; $23 = ( $22 | 0 ) == ( 0 ) ; L10 : do { if ( $23 ) { $$02936 = $$030$lcssa ; $25 = $18 ; while ( 1 ) { $24 = $25 ^ $17 ; $26 = ( ( $24 ) + - 16843009 ) | 0 ; $27 = $24 & - 2139062144 ; $28 = $27 ^ - 2139062144 ; $29 = $28 & $26 ; $30 = ( $29 | 0 ) == ( 0 ) ; if ( ! ( $30 ) ) { $$029$lcssa = $$02936 ; break L10 ; } $31 = ( ( ( $$02936 ) ) + 4 | 0 ) ; $32 = HEAP32 [ $31 >> 2 ] | 0 ; $33 = ( ( $32 ) + - 16843009 ) | 0 ; $34 = $32 & - 2139062144 ; $35 = $34 ^ - 2139062144 ; $36 = $35 & $33 ; $37 = ( $36 | 0 ) == ( 0 ) ; if ( $37 ) { $$02936 = $31 ; $25 = $32 ; } else { $$029$lcssa = $31 ; break ; } } } else { $$029$lcssa = $$030$lcssa ; } } while ( 0 ) ; $38 = $1 & 255 ; $$1 = $$029$lcssa ; while ( 1 ) { $39 = HEAP8 [ $$1 >> 0 ] | 0 ; $40 = ( $39 << 24 >> 24 ) == ( 0 ) ; $41 = ( $39 << 24 >> 24 ) == ( $38 << 24 >> 24 ) ; $or$cond33 = $40 | $41 ; $42 = ( ( ( $$1 ) ) + 1 | 0 ) ; if ( $or$cond33 ) { $$0 = $$1 ; break ; } else { $$1 = $42 ; } } } } while ( 0 ) ; return ( $$0 | 0 ) ; } function _strtox ( $0 , $1 , $2 , $3 , $4 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; $4 = $4 | 0 ; var $$sink = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 128 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 128 | 0 ) ; $5 = sp ; HEAP32 [ $5 >> 2 ] = 0 ; $6 = ( ( ( $5 ) ) + 4 | 0 ) ; HEAP32 [ $6 >> 2 ] = $0 ; $7 = ( ( ( $5 ) ) + 44 | 0 ) ; HEAP32 [ $7 >> 2 ] = $0 ; $8 = ( $0 | 0 ) < ( 0 | 0 ) ; $9 = ( ( ( $0 ) ) + 2147483647 | 0 ) ; $$sink = $8 ? ( - 1 ) : $9 ; $10 = ( ( ( $5 ) ) + 8 | 0 ) ; HEAP32 [ $10 >> 2 ] = $$sink ; $11 = ( ( ( $5 ) ) + 76 | 0 ) ; HEAP32 [ $11 >> 2 ] = - 1 ; ___shlim ( $5 , 0 ) ; $12 = ( ___intscan ( $5 , $2 , 1 , $3 , $4 ) | 0 ) ; $13 = tempRet0 ; $14 = ( $1 | 0 ) == ( 0 | 0 ) ; if ( ! ( $14 ) ) { $15 = ( ( ( $5 ) ) + 108 | 0 ) ; $16 = HEAP32 [ $15 >> 2 ] | 0 ; $17 = HEAP32 [ $6 >> 2 ] | 0 ; $18 = HEAP32 [ $10 >> 2 ] | 0 ; $19 = ( ( $17 ) + ( $16 ) ) | 0 ; $20 = ( ( $19 ) - ( $18 ) ) | 0 ; $21 = ( ( $0 ) + ( $20 ) | 0 ) ; HEAP32 [ $1 >> 2 ] = $21 ; } tempRet0 = ( $13 ) ; STACKTOP = sp ; return ( $12 | 0 ) ; } function _strtoul ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $3 = 0 , $4 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( _strtox ( $0 , $1 , $2 , - 1 , 0 ) | 0 ) ; $4 = tempRet0 ; return ( $3 | 0 ) ; } function _strchr ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( ___strchrnul ( $0 , $1 ) | 0 ) ; $3 = HEAP8 [ $2 >> 0 ] | 0 ; $4 = $1 & 255 ; $5 = ( $3 << 24 >> 24 ) == ( $4 << 24 >> 24 ) ; $6 = $5 ? $2 : 0 ; return ( $6 | 0 ) ; } function _strncmp ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$0$lcssa = 0 , $$01823 = 0 , $$01925 = 0 , $$01925$in = 0 , $$020 = 0 , $$024 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 ; var $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , $or$cond21 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( $2 | 0 ) == ( 0 ) ; if ( $3 ) { $$020 = 0 ; } else { $4 = HEAP8 [ $0 >> 0 ] | 0 ; $5 = ( $4 << 24 >> 24 ) == ( 0 ) ; L3 : do { if ( $5 ) { $$0$lcssa = $1 ; $16 = 0 ; } else { $$01823 = $0 ; $$01925$in = $2 ; $$024 = $1 ; $9 = $4 ; while ( 1 ) { $$01925 = ( ( $$01925$in ) + - 1 ) | 0 ; $6 = HEAP8 [ $$024 >> 0 ] | 0 ; $7 = ( $6 << 24 >> 24 ) != ( 0 ) ; $8 = ( $$01925 | 0 ) != ( 0 ) ; $or$cond = $8 & $7 ; $10 = ( $9 << 24 >> 24 ) == ( $6 << 24 >> 24 ) ; $or$cond21 = $10 & $or$cond ; if ( ! ( $or$cond21 ) ) { $$0$lcssa = $$024 ; $16 = $9 ; break L3 ; } $11 = ( ( ( $$01823 ) ) + 1 | 0 ) ; $12 = ( ( ( $$024 ) ) + 1 | 0 ) ; $13 = HEAP8 [ $11 >> 0 ] | 0 ; $14 = ( $13 << 24 >> 24 ) == ( 0 ) ; if ( $14 ) { $$0$lcssa = $12 ; $16 = 0 ; break ; } else { $$01823 = $11 ; $$01925$in = $$01925 ; $$024 = $12 ; $9 = $13 ; } } } } while ( 0 ) ; $15 = $16 & 255 ; $17 = HEAP8 [ $$0$lcssa >> 0 ] | 0 ; $18 = $17 & 255 ; $19 = ( ( $15 ) - ( $18 ) ) | 0 ; $$020 = $19 ; } return ( $$020 | 0 ) ; } function _fclose ( $0 ) { $0 = $0 | 0 ; var $$pre = 0 , $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 ; var $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( ( ( $0 ) ) + 76 | 0 ) ; $2 = HEAP32 [ $1 >> 2 ] | 0 ; $3 = ( $2 | 0 ) > ( - 1 ) ; if ( $3 ) { $4 = ( ___lockfile ( $0 ) | 0 ) ; $29 = $4 ; } else { $29 = 0 ; } ___unlist_locked_file ( $0 ) ; $5 = HEAP32 [ $0 >> 2 ] | 0 ; $6 = $5 & 1 ; $7 = ( $6 | 0 ) != ( 0 ) ; if ( ! ( $7 ) ) { $8 = ( ___ofl_lock ( ) | 0 ) ; $9 = ( ( ( $0 ) ) + 52 | 0 ) ; $10 = HEAP32 [ $9 >> 2 ] | 0 ; $11 = ( $10 | 0 ) == ( 0 | 0 ) ; $12 = $10 ; $$pre = ( ( ( $0 ) ) + 56 | 0 ) ; if ( ! ( $11 ) ) { $13 = HEAP32 [ $$pre >> 2 ] | 0 ; $14 = ( ( ( $10 ) ) + 56 | 0 ) ; HEAP32 [ $14 >> 2 ] = $13 ; } $15 = HEAP32 [ $$pre >> 2 ] | 0 ; $16 = ( $15 | 0 ) == ( 0 | 0 ) ; $17 = $15 ; if ( ! ( $16 ) ) { $18 = ( ( ( $15 ) ) + 52 | 0 ) ; HEAP32 [ $18 >> 2 ] = $12 ; } $19 = HEAP32 [ $8 >> 2 ] | 0 ; $20 = ( $19 | 0 ) == ( $0 | 0 ) ; if ( $20 ) { HEAP32 [ $8 >> 2 ] = $17 ; } ___ofl_unlock ( ) ; } $21 = ( _fflush ( $0 ) | 0 ) ; $22 = ( ( ( $0 ) ) + 12 | 0 ) ; $23 = HEAP32 [ $22 >> 2 ] | 0 ; $24 = ( FUNCTION_TABLE_ii [ $23 & 127 ] ( $0 ) | 0 ) ; $25 = $24 | $21 ; $26 = ( ( ( $0 ) ) + 92 | 0 ) ; $27 = HEAP32 [ $26 >> 2 ] | 0 ; $28 = ( $27 | 0 ) == ( 0 | 0 ) ; if ( ! ( $28 ) ) { _free ( $27 ) ; } if ( $7 ) { $30 = ( $29 | 0 ) == ( 0 ) ; if ( ! ( $30 ) ) { ___unlockfile ( $0 ) ; } } else { _free ( $0 ) ; } return ( $25 | 0 ) ; } function ___unlist_locked_file ( $0 ) { $0 = $0 | 0 ; var $$pre = 0 , $$sink = 0 , $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( ( ( $0 ) ) + 68 | 0 ) ; $2 = HEAP32 [ $1 >> 2 ] | 0 ; $3 = ( $2 | 0 ) == ( 0 ) ; if ( ! ( $3 ) ) { $4 = ( ( ( $0 ) ) + 116 | 0 ) ; $5 = HEAP32 [ $4 >> 2 ] | 0 ; $6 = ( $5 | 0 ) == ( 0 | 0 ) ; $7 = $5 ; $$pre = ( ( ( $0 ) ) + 112 | 0 ) ; if ( ! ( $6 ) ) { $8 = HEAP32 [ $$pre >> 2 ] | 0 ; $9 = ( ( ( $5 ) ) + 112 | 0 ) ; HEAP32 [ $9 >> 2 ] = $8 ; } $10 = HEAP32 [ $$pre >> 2 ] | 0 ; $11 = ( $10 | 0 ) == ( 0 | 0 ) ; if ( $11 ) { $13 = ( ___pthread_self_494 ( ) | 0 ) ; $14 = ( ( ( $13 ) ) + 232 | 0 ) ; $$sink = $14 ; } else { $12 = ( ( ( $10 ) ) + 116 | 0 ) ; $$sink = $12 ; } HEAP32 [ $$sink >> 2 ] = $7 ; } return ; } function ___ofl_lock ( ) { var label = 0 , sp = 0 ; sp = STACKTOP ; ___lock ( ( 67504 | 0 ) ) ; return ( 67512 | 0 ) ; } function ___ofl_unlock ( ) { var label = 0 , sp = 0 ; sp = STACKTOP ; ___unlock ( ( 67504 | 0 ) ) ; return ; } function _fflush ( $0 ) { $0 = $0 | 0 ; var $$0 = 0 , $$023 = 0 , $$02325 = 0 , $$02327 = 0 , $$024$lcssa = 0 , $$02426 = 0 , $$1 = 0 , $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 ; var $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $phitmp = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( $0 | 0 ) == ( 0 | 0 ) ; do { if ( $1 ) { $8 = HEAP32 [ 2397 ] | 0 ; $9 = ( $8 | 0 ) == ( 0 | 0 ) ; if ( $9 ) { $29 = 0 ; } else { $10 = HEAP32 [ 2397 ] | 0 ; $11 = ( _fflush ( $10 ) | 0 ) ; $29 = $11 ; } $12 = ( ___ofl_lock ( ) | 0 ) ; $$02325 = HEAP32 [ $12 >> 2 ] | 0 ; $13 = ( $$02325 | 0 ) == ( 0 | 0 ) ; if ( $13 ) { $$024$lcssa = $29 ; } else { $$02327 = $$02325 ; $$02426 = $29 ; while ( 1 ) { $14 = ( ( ( $$02327 ) ) + 76 | 0 ) ; $15 = HEAP32 [ $14 >> 2 ] | 0 ; $16 = ( $15 | 0 ) > ( - 1 ) ; if ( $16 ) { $17 = ( ___lockfile ( $$02327 ) | 0 ) ; $25 = $17 ; } else { $25 = 0 ; } $18 = ( ( ( $$02327 ) ) + 20 | 0 ) ; $19 = HEAP32 [ $18 >> 2 ] | 0 ; $20 = ( ( ( $$02327 ) ) + 28 | 0 ) ; $21 = HEAP32 [ $20 >> 2 ] | 0 ; $22 = ( $19 >>> 0 ) > ( $21 >>> 0 ) ; if ( $22 ) { $23 = ( ___fflush_unlocked ( $$02327 ) | 0 ) ; $24 = $23 | $$02426 ; $$1 = $24 ; } else { $$1 = $$02426 ; } $26 = ( $25 | 0 ) == ( 0 ) ; if ( ! ( $26 ) ) { ___unlockfile ( $$02327 ) ; } $27 = ( ( ( $$02327 ) ) + 56 | 0 ) ; $$023 = HEAP32 [ $27 >> 2 ] | 0 ; $28 = ( $$023 | 0 ) == ( 0 | 0 ) ; if ( $28 ) { $$024$lcssa = $$1 ; break ; } else { $$02327 = $$023 ; $$02426 = $$1 ; } } } ___ofl_unlock ( ) ; $$0 = $$024$lcssa ; } else { $2 = ( ( ( $0 ) ) + 76 | 0 ) ; $3 = HEAP32 [ $2 >> 2 ] | 0 ; $4 = ( $3 | 0 ) > ( - 1 ) ; if ( ! ( $4 ) ) { $5 = ( ___fflush_unlocked ( $0 ) | 0 ) ; $$0 = $5 ; break ; } $6 = ( ___lockfile ( $0 ) | 0 ) ; $phitmp = ( $6 | 0 ) == ( 0 ) ; $7 = ( ___fflush_unlocked ( $0 ) | 0 ) ; if ( $phitmp ) { $$0 = $7 ; } else { ___unlockfile ( $0 ) ; $$0 = $7 ; } } } while ( 0 ) ; return ( $$0 | 0 ) ; } function ___fflush_unlocked ( $0 ) { $0 = $0 | 0 ; var $$0 = 0 , $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 ; var $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( ( ( $0 ) ) + 20 | 0 ) ; $2 = HEAP32 [ $1 >> 2 ] | 0 ; $3 = ( ( ( $0 ) ) + 28 | 0 ) ; $4 = HEAP32 [ $3 >> 2 ] | 0 ; $5 = ( $2 >>> 0 ) > ( $4 >>> 0 ) ; if ( $5 ) { $6 = ( ( ( $0 ) ) + 36 | 0 ) ; $7 = HEAP32 [ $6 >> 2 ] | 0 ; ( FUNCTION_TABLE_iiii [ $7 & 127 ] ( $0 , 0 , 0 ) | 0 ) ; $8 = HEAP32 [ $1 >> 2 ] | 0 ; $9 = ( $8 | 0 ) == ( 0 | 0 ) ; if ( $9 ) { $$0 = - 1 ; } else { label = 3 ; } } else { label = 3 ; } if ( ( label | 0 ) == 3 ) { $10 = ( ( ( $0 ) ) + 4 | 0 ) ; $11 = HEAP32 [ $10 >> 2 ] | 0 ; $12 = ( ( ( $0 ) ) + 8 | 0 ) ; $13 = HEAP32 [ $12 >> 2 ] | 0 ; $14 = ( $11 >>> 0 ) < ( $13 >>> 0 ) ; if ( $14 ) { $15 = $11 ; $16 = $13 ; $17 = ( ( $15 ) - ( $16 ) ) | 0 ; $18 = ( ( ( $0 ) ) + 40 | 0 ) ; $19 = HEAP32 [ $18 >> 2 ] | 0 ; ( FUNCTION_TABLE_iiii [ $19 & 127 ] ( $0 , $17 , 1 ) | 0 ) ; } $20 = ( ( ( $0 ) ) + 16 | 0 ) ; HEAP32 [ $20 >> 2 ] = 0 ; HEAP32 [ $3 >> 2 ] = 0 ; HEAP32 [ $1 >> 2 ] = 0 ; HEAP32 [ $12 >> 2 ] = 0 ; HEAP32 [ $10 >> 2 ] = 0 ; $$0 = 0 ; } return ( $$0 | 0 ) ; } function ___pthread_self_494 ( ) { var $0 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $0 = ( _pthread_self ( ) | 0 ) ; return ( $0 | 0 ) ; } function ___fdopen ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$0 = 0 , $$pre = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 ; var $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $5 = 0 ; var $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $vararg_buffer = 0 , $vararg_buffer12 = 0 , $vararg_buffer3 = 0 , $vararg_buffer7 = 0 , $vararg_ptr1 = 0 , $vararg_ptr10 = 0 , $vararg_ptr11 = 0 , $vararg_ptr15 = 0 , $vararg_ptr16 = 0 , $vararg_ptr2 = 0 , $vararg_ptr6 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 64 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 64 | 0 ) ; $vararg_buffer12 = sp + 40 | 0 ; $vararg_buffer7 = sp + 24 | 0 ; $vararg_buffer3 = sp + 16 | 0 ; $vararg_buffer = sp ; $2 = sp + 56 | 0 ; $3 = HEAP8 [ $1 >> 0 ] | 0 ; $4 = $3 << 24 >> 24 ; $5 = ( _strchr ( 33528 , $4 ) | 0 ) ; $6 = ( $5 | 0 ) == ( 0 | 0 ) ; if ( $6 ) { $7 = ( ___errno_location ( ) | 0 ) ; HEAP32 [ $7 >> 2 ] = 22 ; $$0 = 0 ; } else { $8 = ( _malloc ( 1156 ) | 0 ) ; $9 = ( $8 | 0 ) == ( 0 | 0 ) ; if ( $9 ) { $$0 = 0 ; } else { ( _memset ( ( $8 | 0 ) , 0 , 124 ) | 0 ) ; $10 = ( _strchr ( $1 , 43 ) | 0 ) ; $11 = ( $10 | 0 ) == ( 0 | 0 ) ; if ( $11 ) { $12 = HEAP8 [ $1 >> 0 ] | 0 ; $13 = ( $12 << 24 >> 24 ) == ( 114 ) ; $14 = $13 ? 8 : 4 ; HEAP32 [ $8 >> 2 ] = $14 ; } $15 = ( _strchr ( $1 , 101 ) | 0 ) ; $16 = ( $15 | 0 ) == ( 0 | 0 ) ; if ( ! ( $16 ) ) { HEAP32 [ $vararg_buffer >> 2 ] = $0 ; $vararg_ptr1 = ( ( ( $vararg_buffer ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr1 >> 2 ] = 2 ; $vararg_ptr2 = ( ( ( $vararg_buffer ) ) + 8 | 0 ) ; HEAP32 [ $vararg_ptr2 >> 2 ] = 1 ; ( ___syscall221 ( 221 , ( $vararg_buffer | 0 ) ) | 0 ) ; } $17 = HEAP8 [ $1 >> 0 ] | 0 ; $18 = ( $17 << 24 >> 24 ) == ( 97 ) ; if ( $18 ) { HEAP32 [ $vararg_buffer3 >> 2 ] = $0 ; $vararg_ptr6 = ( ( ( $vararg_buffer3 ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr6 >> 2 ] = 3 ; $19 = ( ___syscall221 ( 221 , ( $vararg_buffer3 | 0 ) ) | 0 ) ; $20 = $19 & 1024 ; $21 = ( $20 | 0 ) == ( 0 ) ; if ( $21 ) { $22 = $19 | 1024 ; HEAP32 [ $vararg_buffer7 >> 2 ] = $0 ; $vararg_ptr10 = ( ( ( $vararg_buffer7 ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr10 >> 2 ] = 4 ; $vararg_ptr11 = ( ( ( $vararg_buffer7 ) ) + 8 | 0 ) ; HEAP32 [ $vararg_ptr11 >> 2 ] = $22 ; ( ___syscall221 ( 221 , ( $vararg_buffer7 | 0 ) ) | 0 ) ; } $23 = HEAP32 [ $8 >> 2 ] | 0 ; $24 = $23 | 128 ; HEAP32 [ $8 >> 2 ] = $24 ; $31 = $24 ; } else { $$pre = HEAP32 [ $8 >> 2 ] | 0 ; $31 = $$pre ; } $25 = ( ( ( $8 ) ) + 60 | 0 ) ; HEAP32 [ $25 >> 2 ] = $0 ; $26 = ( ( ( $8 ) ) + 132 | 0 ) ; $27 = ( ( ( $8 ) ) + 44 | 0 ) ; HEAP32 [ $27 >> 2 ] = $26 ; $28 = ( ( ( $8 ) ) + 48 | 0 ) ; HEAP32 [ $28 >> 2 ] = 1024 ; $29 = ( ( ( $8 ) ) + 75 | 0 ) ; HEAP8 [ $29 >> 0 ] = - 1 ; $30 = $31 & 8 ; $32 = ( $30 | 0 ) == ( 0 ) ; if ( $32 ) { $33 = $2 ; HEAP32 [ $vararg_buffer12 >> 2 ] = $0 ; $vararg_ptr15 = ( ( ( $vararg_buffer12 ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr15 >> 2 ] = 21523 ; $vararg_ptr16 = ( ( ( $vararg_buffer12 ) ) + 8 | 0 ) ; HEAP32 [ $vararg_ptr16 >> 2 ] = $33 ; $34 = ( ___syscall54 ( 54 , ( $vararg_buffer12 | 0 ) ) | 0 ) ; $35 = ( $34 | 0 ) == ( 0 ) ; if ( $35 ) { HEAP8 [ $29 >> 0 ] = 10 ; } } $36 = ( ( ( $8 ) ) + 32 | 0 ) ; HEAP32 [ $36 >> 2 ] = 108 ; $37 = ( ( ( $8 ) ) + 36 | 0 ) ; HEAP32 [ $37 >> 2 ] = 9 ; $38 = ( ( ( $8 ) ) + 40 | 0 ) ; HEAP32 [ $38 >> 2 ] = 8 ; $39 = ( ( ( $8 ) ) + 12 | 0 ) ; HEAP32 [ $39 >> 2 ] = 6 ; $40 = HEAP32 [ ( 67440 ) >> 2 ] | 0 ; $41 = ( $40 | 0 ) == ( 0 ) ; if ( $41 ) { $42 = ( ( ( $8 ) ) + 76 | 0 ) ; HEAP32 [ $42 >> 2 ] = - 1 ; } $43 = ( ___ofl_add ( $8 ) | 0 ) ; $$0 = $8 ; } } STACKTOP = sp ; return ( $$0 | 0 ) ; } function ___ofl_add ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( ___ofl_lock ( ) | 0 ) ; $2 = HEAP32 [ $1 >> 2 ] | 0 ; $3 = ( ( ( $0 ) ) + 56 | 0 ) ; HEAP32 [ $3 >> 2 ] = $2 ; $4 = HEAP32 [ $1 >> 2 ] | 0 ; $5 = ( $4 | 0 ) == ( 0 | 0 ) ; if ( ! ( $5 ) ) { $6 = ( ( ( $4 ) ) + 52 | 0 ) ; HEAP32 [ $6 >> 2 ] = $0 ; } HEAP32 [ $1 >> 2 ] = $0 ; ___ofl_unlock ( ) ; return ( $0 | 0 ) ; } function _strcpy ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var label = 0 , sp = 0 ; sp = STACKTOP ; ( ___stpcpy ( $0 , $1 ) | 0 ) ; return ( $0 | 0 ) ; } function ___stpcpy ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$0$lcssa = 0 , $$025$lcssa = 0 , $$02536 = 0 , $$026$lcssa = 0 , $$02642 = 0 , $$027$lcssa = 0 , $$02741 = 0 , $$029 = 0 , $$037 = 0 , $$1$ph = 0 , $$128$ph = 0 , $$12834 = 0 , $$135 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 ; var $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 ; var $35 = 0 , $36 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = $1 ; $3 = $0 ; $4 = $2 ^ $3 ; $5 = $4 & 3 ; $6 = ( $5 | 0 ) == ( 0 ) ; L1 : do { if ( $6 ) { $7 = $2 & 3 ; $8 = ( $7 | 0 ) == ( 0 ) ; if ( $8 ) { $$026$lcssa = $1 ; $$027$lcssa = $0 ; } else { $$02642 = $1 ; $$02741 = $0 ; while ( 1 ) { $9 = HEAP8 [ $$02642 >> 0 ] | 0 ; HEAP8 [ $$02741 >> 0 ] = $9 ; $10 = ( $9 << 24 >> 24 ) == ( 0 ) ; if ( $10 ) { $$029 = $$02741 ; break L1 ; } $11 = ( ( ( $$02642 ) ) + 1 | 0 ) ; $12 = ( ( ( $$02741 ) ) + 1 | 0 ) ; $13 = $11 ; $14 = $13 & 3 ; $15 = ( $14 | 0 ) == ( 0 ) ; if ( $15 ) { $$026$lcssa = $11 ; $$027$lcssa = $12 ; break ; } else { $$02642 = $11 ; $$02741 = $12 ; } } } $16 = HEAP32 [ $$026$lcssa >> 2 ] | 0 ; $17 = ( ( $16 ) + - 16843009 ) | 0 ; $18 = $16 & - 2139062144 ; $19 = $18 ^ - 2139062144 ; $20 = $19 & $17 ; $21 = ( $20 | 0 ) == ( 0 ) ; if ( $21 ) { $$02536 = $$027$lcssa ; $$037 = $$026$lcssa ; $24 = $16 ; while ( 1 ) { $22 = ( ( ( $$037 ) ) + 4 | 0 ) ; $23 = ( ( ( $$02536 ) ) + 4 | 0 ) ; HEAP32 [ $$02536 >> 2 ] = $24 ; $25 = HEAP32 [ $22 >> 2 ] | 0 ; $26 = ( ( $25 ) + - 16843009 ) | 0 ; $27 = $25 & - 2139062144 ; $28 = $27 ^ - 2139062144 ; $29 = $28 & $26 ; $30 = ( $29 | 0 ) == ( 0 ) ; if ( $30 ) { $$02536 = $23 ; $$037 = $22 ; $24 = $25 ; } else { $$0$lcssa = $22 ; $$025$lcssa = $23 ; break ; } } } else { $$0$lcssa = $$026$lcssa ; $$025$lcssa = $$027$lcssa ; } $$1$ph = $$0$lcssa ; $$128$ph = $$025$lcssa ; label = 8 ; } else { $$1$ph = $1 ; $$128$ph = $0 ; label = 8 ; } } while ( 0 ) ; if ( ( label | 0 ) == 8 ) { $31 = HEAP8 [ $$1$ph >> 0 ] | 0 ; HEAP8 [ $$128$ph >> 0 ] = $31 ; $32 = ( $31 << 24 >> 24 ) == ( 0 ) ; if ( $32 ) { $$029 = $$128$ph ; } else { $$12834 = $$128$ph ; $$135 = $$1$ph ; while ( 1 ) { $33 = ( ( ( $$135 ) ) + 1 | 0 ) ; $34 = ( ( ( $$12834 ) ) + 1 | 0 ) ; $35 = HEAP8 [ $33 >> 0 ] | 0 ; HEAP8 [ $34 >> 0 ] = $35 ; $36 = ( $35 << 24 >> 24 ) == ( 0 ) ; if ( $36 ) { $$029 = $34 ; break ; } else { $$12834 = $34 ; $$135 = $33 ; } } } } return ( $$029 | 0 ) ; } function ___procfdname ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$02324 = 0 , $$027 = 0 , $$126 = 0 , $$225 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $scevgep = 0 , dest = 0 , label = 0 ; var sp = 0 , src = 0 , stop = 0 ; sp = STACKTOP ; dest = $0 ; src = 33513 ; stop = dest + 15 | 0 ; do { HEAP8 [ dest >> 0 ] = HEAP8 [ src >> 0 ] | 0 ; dest = dest + 1 | 0 ; src = src + 1 | 0 ; } while ( ( dest | 0 ) < ( stop | 0 ) ) ; $2 = ( $1 | 0 ) == ( 0 ) ; if ( $2 ) { $scevgep = ( ( ( $0 ) ) + 14 | 0 ) ; HEAP8 [ $scevgep >> 0 ] = 48 ; $3 = ( ( ( $0 ) ) + 15 | 0 ) ; HEAP8 [ $3 >> 0 ] = 0 ; } else { $$027 = $1 ; $$126 = 14 ; while ( 1 ) { $4 = ( ( $$027 >>> 0 ) / 10 ) & - 1 ; $5 = ( ( $$126 ) + 1 ) | 0 ; $6 = ( $$027 >>> 0 ) < ( 10 ) ; if ( $6 ) { break ; } else { $$027 = $4 ; $$126 = $5 ; } } $7 = ( ( $0 ) + ( $5 ) | 0 ) ; HEAP8 [ $7 >> 0 ] = 0 ; $$02324 = $1 ; $$225 = $5 ; while ( 1 ) { $8 = ( ( $$02324 >>> 0 ) % 10 ) & - 1 ; $9 = $8 | 48 ; $10 = $9 & 255 ; $11 = ( ( $$225 ) + - 1 ) | 0 ; $12 = ( ( $0 ) + ( $11 ) | 0 ) ; HEAP8 [ $12 >> 0 ] = $10 ; $13 = ( ( $$02324 >>> 0 ) / 10 ) & - 1 ; $14 = ( $$02324 >>> 0 ) < ( 10 ) ; if ( $14 ) { break ; } else { $$02324 = $13 ; $$225 = $11 ; } } } return ; } function _fstat ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$0 = 0 , $10 = 0 , $11 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $vararg_buffer = 0 , $vararg_buffer2 = 0 , $vararg_buffer6 = 0 , $vararg_ptr1 = 0 , $vararg_ptr5 = 0 , $vararg_ptr9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 64 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 64 | 0 ) ; $vararg_buffer6 = sp + 16 | 0 ; $vararg_buffer2 = sp + 8 | 0 ; $vararg_buffer = sp ; $2 = sp + 24 | 0 ; $3 = $1 ; HEAP32 [ $vararg_buffer >> 2 ] = $0 ; $vararg_ptr1 = ( ( ( $vararg_buffer ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr1 >> 2 ] = $3 ; $4 = ( ___syscall197 ( 197 , ( $vararg_buffer | 0 ) ) | 0 ) ; $5 = ( $4 | 0 ) == ( - 9 ) ; if ( $5 ) { HEAP32 [ $vararg_buffer2 >> 2 ] = $0 ; $vararg_ptr5 = ( ( ( $vararg_buffer2 ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr5 >> 2 ] = 1 ; $6 = ( ___syscall221 ( 221 , ( $vararg_buffer2 | 0 ) ) | 0 ) ; $7 = ( $6 | 0 ) < ( 0 ) ; if ( $7 ) { label = 3 ; } else { ___procfdname ( $2 , $0 ) ; $9 = $2 ; HEAP32 [ $vararg_buffer6 >> 2 ] = $9 ; $vararg_ptr9 = ( ( ( $vararg_buffer6 ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr9 >> 2 ] = $3 ; $10 = ( ___syscall195 ( 195 , ( $vararg_buffer6 | 0 ) ) | 0 ) ; $11 = ( ___syscall_ret ( $10 ) | 0 ) ; $$0 = $11 ; } } else { label = 3 ; } if ( ( label | 0 ) == 3 ) { $8 = ( ___syscall_ret ( $4 ) | 0 ) ; $$0 = $8 ; } STACKTOP = sp ; return ( $$0 | 0 ) ; } function _stat ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $vararg_buffer = 0 , $vararg_ptr1 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $vararg_buffer = sp ; $2 = $0 ; $3 = $1 ; HEAP32 [ $vararg_buffer >> 2 ] = $2 ; $vararg_ptr1 = ( ( ( $vararg_buffer ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr1 >> 2 ] = $3 ; $4 = ( ___syscall195 ( 195 , ( $vararg_buffer | 0 ) ) | 0 ) ; $5 = ( ___syscall_ret ( $4 ) | 0 ) ; STACKTOP = sp ; return ( $5 | 0 ) ; } function _fopen ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$0 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $vararg_buffer = 0 , $vararg_buffer3 = 0 , $vararg_buffer8 = 0 , $vararg_ptr1 = 0 ; var $vararg_ptr2 = 0 , $vararg_ptr6 = 0 , $vararg_ptr7 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 48 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 48 | 0 ) ; $vararg_buffer8 = sp + 32 | 0 ; $vararg_buffer3 = sp + 16 | 0 ; $vararg_buffer = sp ; $2 = HEAP8 [ $1 >> 0 ] | 0 ; $3 = $2 << 24 >> 24 ; $4 = ( _strchr ( 33528 , $3 ) | 0 ) ; $5 = ( $4 | 0 ) == ( 0 | 0 ) ; if ( $5 ) { $6 = ( ___errno_location ( ) | 0 ) ; HEAP32 [ $6 >> 2 ] = 22 ; $$0 = 0 ; } else { $7 = ( ___fmodeflags ( $1 ) | 0 ) ; $8 = $0 ; $9 = $7 | 32768 ; HEAP32 [ $vararg_buffer >> 2 ] = $8 ; $vararg_ptr1 = ( ( ( $vararg_buffer ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr1 >> 2 ] = $9 ; $vararg_ptr2 = ( ( ( $vararg_buffer ) ) + 8 | 0 ) ; HEAP32 [ $vararg_ptr2 >> 2 ] = 438 ; $10 = ( ___syscall5 ( 5 , ( $vararg_buffer | 0 ) ) | 0 ) ; $11 = ( ___syscall_ret ( $10 ) | 0 ) ; $12 = ( $11 | 0 ) < ( 0 ) ; if ( $12 ) { $$0 = 0 ; } else { $13 = $7 & 524288 ; $14 = ( $13 | 0 ) == ( 0 ) ; if ( ! ( $14 ) ) { HEAP32 [ $vararg_buffer3 >> 2 ] = $11 ; $vararg_ptr6 = ( ( ( $vararg_buffer3 ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr6 >> 2 ] = 2 ; $vararg_ptr7 = ( ( ( $vararg_buffer3 ) ) + 8 | 0 ) ; HEAP32 [ $vararg_ptr7 >> 2 ] = 1 ; ( ___syscall221 ( 221 , ( $vararg_buffer3 | 0 ) ) | 0 ) ; } $15 = ( ___fdopen ( $11 , $1 ) | 0 ) ; $16 = ( $15 | 0 ) == ( 0 | 0 ) ; if ( $16 ) { HEAP32 [ $vararg_buffer8 >> 2 ] = $11 ; ( ___syscall6 ( 6 , ( $vararg_buffer8 | 0 ) ) | 0 ) ; $$0 = 0 ; } else { $$0 = $15 ; } } } STACKTOP = sp ; return ( $$0 | 0 ) ; } function ___fmodeflags ( $0 ) { $0 = $0 | 0 ; var $$ = 0 , $$$4 = 0 , $$0 = 0 , $$0$ = 0 , $$2 = 0 , $$2$ = 0 , $$4 = 0 , $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 ; var $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( _strchr ( $0 , 43 ) | 0 ) ; $2 = ( $1 | 0 ) == ( 0 | 0 ) ; $3 = HEAP8 [ $0 >> 0 ] | 0 ; $4 = ( $3 << 24 >> 24 ) != ( 114 ) ; $$ = $4 & 1 ; $$0 = $2 ? $$ : 2 ; $5 = ( _strchr ( $0 , 120 ) | 0 ) ; $6 = ( $5 | 0 ) == ( 0 | 0 ) ; $7 = $$0 | 128 ; $$0$ = $6 ? $$0 : $7 ; $8 = ( _strchr ( $0 , 101 ) | 0 ) ; $9 = ( $8 | 0 ) == ( 0 | 0 ) ; $10 = $$0$ | 524288 ; $$2 = $9 ? $$0$ : $10 ; $11 = ( $3 << 24 >> 24 ) == ( 114 ) ; $12 = $$2 | 64 ; $$2$ = $11 ? $$2 : $12 ; $13 = ( $3 << 24 >> 24 ) == ( 119 ) ; $14 = $$2$ | 512 ; $$4 = $13 ? $14 : $$2$ ; $15 = ( $3 << 24 >> 24 ) == ( 97 ) ; $16 = $$4 | 1024 ; $$$4 = $15 ? $16 : $$4 ; return ( $$$4 | 0 ) ; } function _ferror ( $0 ) { $0 = $0 | 0 ; var $$lobit = 0 , $$lobit8 = 0 , $$lobit9 = 0 , $1 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $phitmp = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( ( ( $0 ) ) + 76 | 0 ) ; $2 = HEAP32 [ $1 >> 2 ] | 0 ; $3 = ( $2 | 0 ) > ( - 1 ) ; if ( $3 ) { $6 = ( ___lockfile ( $0 ) | 0 ) ; $phitmp = ( $6 | 0 ) == ( 0 ) ; $7 = HEAP32 [ $0 >> 2 ] | 0 ; $8 = $7 >>> 5 ; $$lobit = $8 & 1 ; if ( $phitmp ) { $$lobit9 = $$lobit ; } else { $$lobit9 = $$lobit ; } } else { $4 = HEAP32 [ $0 >> 2 ] | 0 ; $5 = $4 >>> 5 ; $$lobit8 = $5 & 1 ; $$lobit9 = $$lobit8 ; } return ( $$lobit9 | 0 ) ; } function _fseek ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( ___fseeko ( $0 , $1 , $2 ) | 0 ) ; return ( $3 | 0 ) ; } function _fprintf ( $0 , $1 , $varargs ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $varargs = $varargs | 0 ; var $2 = 0 , $3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = sp ; HEAP32 [ $2 >> 2 ] = $varargs ; $3 = ( _vfprintf ( $0 , $1 , $2 ) | 0 ) ; STACKTOP = sp ; return ( $3 | 0 ) ; } function ___fseeko ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $phitmp = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( ( ( $0 ) ) + 76 | 0 ) ; $4 = HEAP32 [ $3 >> 2 ] | 0 ; $5 = ( $4 | 0 ) > ( - 1 ) ; if ( $5 ) { $7 = ( ___lockfile ( $0 ) | 0 ) ; $phitmp = ( $7 | 0 ) == ( 0 ) ; $8 = ( ___fseeko_unlocked ( $0 , $1 , $2 ) | 0 ) ; if ( $phitmp ) { $9 = $8 ; } else { ___unlockfile ( $0 ) ; $9 = $8 ; } } else { $6 = ( ___fseeko_unlocked ( $0 , $1 , $2 ) | 0 ) ; $9 = $6 ; } return ( $9 | 0 ) ; } function ___fseeko_unlocked ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$0 = 0 , $$019 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 ; var $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( $2 | 0 ) == ( 1 ) ; if ( $3 ) { $4 = ( ( ( $0 ) ) + 8 | 0 ) ; $5 = HEAP32 [ $4 >> 2 ] | 0 ; $6 = ( ( ( $0 ) ) + 4 | 0 ) ; $7 = HEAP32 [ $6 >> 2 ] | 0 ; $8 = ( ( $1 ) - ( $5 ) ) | 0 ; $9 = ( ( $8 ) + ( $7 ) ) | 0 ; $$019 = $9 ; } else { $$019 = $1 ; } $10 = ( ( ( $0 ) ) + 20 | 0 ) ; $11 = HEAP32 [ $10 >> 2 ] | 0 ; $12 = ( ( ( $0 ) ) + 28 | 0 ) ; $13 = HEAP32 [ $12 >> 2 ] | 0 ; $14 = ( $11 >>> 0 ) > ( $13 >>> 0 ) ; if ( $14 ) { $15 = ( ( ( $0 ) ) + 36 | 0 ) ; $16 = HEAP32 [ $15 >> 2 ] | 0 ; ( FUNCTION_TABLE_iiii [ $16 & 127 ] ( $0 , 0 , 0 ) | 0 ) ; $17 = HEAP32 [ $10 >> 2 ] | 0 ; $18 = ( $17 | 0 ) == ( 0 | 0 ) ; if ( $18 ) { $$0 = - 1 ; } else { label = 5 ; } } else { label = 5 ; } if ( ( label | 0 ) == 5 ) { $19 = ( ( ( $0 ) ) + 16 | 0 ) ; HEAP32 [ $19 >> 2 ] = 0 ; HEAP32 [ $12 >> 2 ] = 0 ; HEAP32 [ $10 >> 2 ] = 0 ; $20 = ( ( ( $0 ) ) + 40 | 0 ) ; $21 = HEAP32 [ $20 >> 2 ] | 0 ; $22 = ( FUNCTION_TABLE_iiii [ $21 & 127 ] ( $0 , $$019 , $2 ) | 0 ) ; $23 = ( $22 | 0 ) < ( 0 ) ; if ( $23 ) { $$0 = - 1 ; } else { $24 = ( ( ( $0 ) ) + 8 | 0 ) ; HEAP32 [ $24 >> 2 ] = 0 ; $25 = ( ( ( $0 ) ) + 4 | 0 ) ; HEAP32 [ $25 >> 2 ] = 0 ; $26 = HEAP32 [ $0 >> 2 ] | 0 ; $27 = $26 & - 17 ; HEAP32 [ $0 >> 2 ] = $27 ; $$0 = 0 ; } } return ( $$0 | 0 ) ; } function _strstr ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$0 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 ; var $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = HEAP8 [ $1 >> 0 ] | 0 ; $3 = ( $2 << 24 >> 24 ) == ( 0 ) ; do { if ( $3 ) { $$0 = $0 ; } else { $4 = $2 << 24 >> 24 ; $5 = ( _strchr ( $0 , $4 ) | 0 ) ; $6 = ( $5 | 0 ) == ( 0 | 0 ) ; if ( $6 ) { $$0 = 0 ; } else { $7 = ( ( ( $1 ) ) + 1 | 0 ) ; $8 = HEAP8 [ $7 >> 0 ] | 0 ; $9 = ( $8 << 24 >> 24 ) == ( 0 ) ; if ( $9 ) { $$0 = $5 ; } else { $10 = ( ( ( $5 ) ) + 1 | 0 ) ; $11 = HEAP8 [ $10 >> 0 ] | 0 ; $12 = ( $11 << 24 >> 24 ) == ( 0 ) ; if ( $12 ) { $$0 = 0 ; } else { $13 = ( ( ( $1 ) ) + 2 | 0 ) ; $14 = HEAP8 [ $13 >> 0 ] | 0 ; $15 = ( $14 << 24 >> 24 ) == ( 0 ) ; if ( $15 ) { $16 = ( _twobyte_strstr ( $5 , $1 ) | 0 ) ; $$0 = $16 ; break ; } $17 = ( ( ( $5 ) ) + 2 | 0 ) ; $18 = HEAP8 [ $17 >> 0 ] | 0 ; $19 = ( $18 << 24 >> 24 ) == ( 0 ) ; if ( $19 ) { $$0 = 0 ; } else { $20 = ( ( ( $1 ) ) + 3 | 0 ) ; $21 = HEAP8 [ $20 >> 0 ] | 0 ; $22 = ( $21 << 24 >> 24 ) == ( 0 ) ; if ( $22 ) { $23 = ( _threebyte_strstr ( $5 , $1 ) | 0 ) ; $$0 = $23 ; break ; } $24 = ( ( ( $5 ) ) + 3 | 0 ) ; $25 = HEAP8 [ $24 >> 0 ] | 0 ; $26 = ( $25 << 24 >> 24 ) == ( 0 ) ; if ( $26 ) { $$0 = 0 ; } else { $27 = ( ( ( $1 ) ) + 4 | 0 ) ; $28 = HEAP8 [ $27 >> 0 ] | 0 ; $29 = ( $28 << 24 >> 24 ) == ( 0 ) ; if ( $29 ) { $30 = ( _fourbyte_strstr ( $5 , $1 ) | 0 ) ; $$0 = $30 ; break ; } else { $31 = ( _twoway_strstr ( $5 , $1 ) | 0 ) ; $$0 = $31 ; break ; } } } } } } } } while ( 0 ) ; return ( $$0 | 0 ) ; } function _twobyte_strstr ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$sink = 0 , $$sink$in = 0 , $$sink$masked = 0 , $$sink17$sink = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 ; var $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = HEAP8 [ $1 >> 0 ] | 0 ; $3 = $2 & 255 ; $4 = $3 << 8 ; $5 = ( ( ( $1 ) ) + 1 | 0 ) ; $6 = HEAP8 [ $5 >> 0 ] | 0 ; $7 = $6 & 255 ; $8 = $4 | $7 ; $9 = HEAP8 [ $0 >> 0 ] | 0 ; $10 = $9 & 255 ; $$sink$in = $10 ; $$sink17$sink = $0 ; while ( 1 ) { $11 = ( ( ( $$sink17$sink ) ) + 1 | 0 ) ; $12 = HEAP8 [ $11 >> 0 ] | 0 ; $13 = ( $12 << 24 >> 24 ) == ( 0 ) ; if ( $13 ) { break ; } $$sink = $$sink$in << 8 ; $14 = $12 & 255 ; $$sink$masked = $$sink & 65280 ; $15 = $$sink$masked | $14 ; $16 = ( $15 | 0 ) == ( $8 | 0 ) ; if ( $16 ) { break ; } else { $$sink$in = $15 ; $$sink17$sink = $11 ; } } $17 = ( $12 << 24 >> 24 ) != ( 0 ) ; $18 = $17 ? $$sink17$sink : 0 ; return ( $18 | 0 ) ; } function _threebyte_strstr ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$016$lcssa = 0 , $$01618 = 0 , $$019 = 0 , $$lcssa = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 ; var $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 ; var $8 = 0 , $9 = 0 , $or$cond = 0 , $or$cond17 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = HEAP8 [ $1 >> 0 ] | 0 ; $3 = $2 & 255 ; $4 = $3 << 24 ; $5 = ( ( ( $1 ) ) + 1 | 0 ) ; $6 = HEAP8 [ $5 >> 0 ] | 0 ; $7 = $6 & 255 ; $8 = $7 << 16 ; $9 = $8 | $4 ; $10 = ( ( ( $1 ) ) + 2 | 0 ) ; $11 = HEAP8 [ $10 >> 0 ] | 0 ; $12 = $11 & 255 ; $13 = $12 << 8 ; $14 = $9 | $13 ; $15 = HEAP8 [ $0 >> 0 ] | 0 ; $16 = $15 & 255 ; $17 = $16 << 24 ; $18 = ( ( ( $0 ) ) + 1 | 0 ) ; $19 = HEAP8 [ $18 >> 0 ] | 0 ; $20 = $19 & 255 ; $21 = $20 << 16 ; $22 = $21 | $17 ; $23 = ( ( ( $0 ) ) + 2 | 0 ) ; $24 = HEAP8 [ $23 >> 0 ] | 0 ; $25 = $24 & 255 ; $26 = $25 << 8 ; $27 = $22 | $26 ; $28 = ( $24 << 24 >> 24 ) == ( 0 ) ; $29 = ( $27 | 0 ) == ( $14 | 0 ) ; $or$cond17 = $29 | $28 ; if ( $or$cond17 ) { $$016$lcssa = $23 ; $$lcssa = $24 ; } else { $$01618 = $23 ; $$019 = $27 ; while ( 1 ) { $30 = ( ( ( $$01618 ) ) + 1 | 0 ) ; $31 = HEAP8 [ $30 >> 0 ] | 0 ; $32 = $31 & 255 ; $33 = $$019 | $32 ; $34 = $33 << 8 ; $35 = ( $31 << 24 >> 24 ) == ( 0 ) ; $36 = ( $34 | 0 ) == ( $14 | 0 ) ; $or$cond = $36 | $35 ; if ( $or$cond ) { $$016$lcssa = $30 ; $$lcssa = $31 ; break ; } else { $$01618 = $30 ; $$019 = $34 ; } } } $37 = ( $$lcssa << 24 >> 24 ) != ( 0 ) ; $38 = ( ( ( $$016$lcssa ) ) + - 2 | 0 ) ; $39 = $37 ? $38 : 0 ; return ( $39 | 0 ) ; } function _fourbyte_strstr ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$lcssa = 0 , $$sink21$lcssa = 0 , $$sink2123 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 ; var $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 ; var $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $or$cond = 0 , $or$cond22 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = HEAP8 [ $1 >> 0 ] | 0 ; $3 = $2 & 255 ; $4 = $3 << 24 ; $5 = ( ( ( $1 ) ) + 1 | 0 ) ; $6 = HEAP8 [ $5 >> 0 ] | 0 ; $7 = $6 & 255 ; $8 = $7 << 16 ; $9 = $8 | $4 ; $10 = ( ( ( $1 ) ) + 2 | 0 ) ; $11 = HEAP8 [ $10 >> 0 ] | 0 ; $12 = $11 & 255 ; $13 = $12 << 8 ; $14 = $9 | $13 ; $15 = ( ( ( $1 ) ) + 3 | 0 ) ; $16 = HEAP8 [ $15 >> 0 ] | 0 ; $17 = $16 & 255 ; $18 = $14 | $17 ; $19 = HEAP8 [ $0 >> 0 ] | 0 ; $20 = $19 & 255 ; $21 = $20 << 24 ; $22 = ( ( ( $0 ) ) + 1 | 0 ) ; $23 = HEAP8 [ $22 >> 0 ] | 0 ; $24 = $23 & 255 ; $25 = $24 << 16 ; $26 = $25 | $21 ; $27 = ( ( ( $0 ) ) + 2 | 0 ) ; $28 = HEAP8 [ $27 >> 0 ] | 0 ; $29 = $28 & 255 ; $30 = $29 << 8 ; $31 = $26 | $30 ; $32 = ( ( ( $0 ) ) + 3 | 0 ) ; $33 = HEAP8 [ $32 >> 0 ] | 0 ; $34 = $33 & 255 ; $35 = $31 | $34 ; $36 = ( $33 << 24 >> 24 ) == ( 0 ) ; $37 = ( $35 | 0 ) == ( $18 | 0 ) ; $or$cond22 = $36 | $37 ; if ( $or$cond22 ) { $$lcssa = $33 ; $$sink21$lcssa = $32 ; } else { $$sink2123 = $32 ; $39 = $35 ; while ( 1 ) { $38 = $39 << 8 ; $40 = ( ( ( $$sink2123 ) ) + 1 | 0 ) ; $41 = HEAP8 [ $40 >> 0 ] | 0 ; $42 = $41 & 255 ; $43 = $38 | $42 ; $44 = ( $41 << 24 >> 24 ) == ( 0 ) ; $45 = ( $43 | 0 ) == ( $18 | 0 ) ; $or$cond = $44 | $45 ; if ( $or$cond ) { $$lcssa = $41 ; $$sink21$lcssa = $40 ; break ; } else { $$sink2123 = $40 ; $39 = $43 ; } } } $46 = ( $$lcssa << 24 >> 24 ) != ( 0 ) ; $47 = ( ( ( $$sink21$lcssa ) ) + - 3 | 0 ) ; $48 = $46 ? $47 : 0 ; return ( $48 | 0 ) ; } function _twoway_strstr ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$0166 = 0 , $$0168 = 0 , $$0169 = 0 , $$0169$be = 0 , $$0170 = 0 , $$0175$ph$ph$lcssa216 = 0 , $$0175$ph$ph$lcssa216328 = 0 , $$0175$ph$ph254 = 0 , $$0179242 = 0 , $$0183$ph197$ph253 = 0 , $$0183$ph197248 = 0 , $$0183$ph260 = 0 , $$0185$ph$lcssa = 0 , $$0185$ph$lcssa327 = 0 , $$0185$ph259 = 0 , $$0187219$ph325326 = 0 , $$0187263 = 0 , $$1176$$0175 = 0 , $$1176$ph$ph$lcssa208 = 0 , $$1176$ph$ph233 = 0 ; var $$1180222 = 0 , $$1184$ph193$ph232 = 0 , $$1184$ph193227 = 0 , $$1184$ph239 = 0 , $$1186$$0185 = 0 , $$1186$$0185$ = 0 , $$1186$ph$lcssa = 0 , $$1186$ph238 = 0 , $$2181 = 0 , $$2181$sink = 0 , $$3 = 0 , $$3173 = 0 , $$3178 = 0 , $$3182221 = 0 , $$4 = 0 , $$pr = 0 , $10 = 0 , $100 = 0 , $101 = 0 , $102 = 0 ; var $103 = 0 , $104 = 0 , $105 = 0 , $106 = 0 , $107 = 0 , $108 = 0 , $109 = 0 , $11 = 0 , $110 = 0 , $111 = 0 , $112 = 0 , $113 = 0 , $114 = 0 , $115 = 0 , $116 = 0 , $117 = 0 , $118 = 0 , $119 = 0 , $12 = 0 , $120 = 0 ; var $121 = 0 , $122 = 0 , $123 = 0 , $124 = 0 , $125 = 0 , $126 = 0 , $127 = 0 , $128 = 0 , $129 = 0 , $13 = 0 , $130 = 0 , $131 = 0 , $132 = 0 , $133 = 0 , $134 = 0 , $135 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 ; var $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 ; var $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 , $42 = 0 , $43 = 0 , $44 = 0 , $45 = 0 , $46 = 0 , $47 = 0 , $48 = 0 , $49 = 0 , $5 = 0 , $50 = 0 , $51 = 0 , $52 = 0 , $53 = 0 ; var $54 = 0 , $55 = 0 , $56 = 0 , $57 = 0 , $58 = 0 , $59 = 0 , $6 = 0 , $60 = 0 , $61 = 0 , $62 = 0 , $63 = 0 , $64 = 0 , $65 = 0 , $66 = 0 , $67 = 0 , $68 = 0 , $69 = 0 , $7 = 0 , $70 = 0 , $71 = 0 ; var $72 = 0 , $73 = 0 , $74 = 0 , $75 = 0 , $76 = 0 , $77 = 0 , $78 = 0 , $79 = 0 , $8 = 0 , $80 = 0 , $81 = 0 , $82 = 0 , $83 = 0 , $84 = 0 , $85 = 0 , $86 = 0 , $87 = 0 , $88 = 0 , $89 = 0 , $9 = 0 ; var $90 = 0 , $91 = 0 , $92 = 0 , $93 = 0 , $94 = 0 , $95 = 0 , $96 = 0 , $97 = 0 , $98 = 0 , $99 = 0 , $div = 0 , $div188 = 0 , $or$cond = 0 , $or$cond189 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 1056 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 1056 | 0 ) ; $2 = sp + 1024 | 0 ; $3 = sp ; ; HEAP32 [ $2 >> 2 ] = 0 | 0 ; HEAP32 [ $2 + 4 >> 2 ] = 0 | 0 ; HEAP32 [ $2 + 8 >> 2 ] = 0 | 0 ; HEAP32 [ $2 + 12 >> 2 ] = 0 | 0 ; HEAP32 [ $2 + 16 >> 2 ] = 0 | 0 ; HEAP32 [ $2 + 20 >> 2 ] = 0 | 0 ; HEAP32 [ $2 + 24 >> 2 ] = 0 | 0 ; HEAP32 [ $2 + 28 >> 2 ] = 0 | 0 ; $4 = HEAP8 [ $1 >> 0 ] | 0 ; $5 = ( $4 << 24 >> 24 ) == ( 0 ) ; L1 : do { if ( $5 ) { $$0175$ph$ph$lcssa216328 = 1 ; $$0185$ph$lcssa327 = - 1 ; $$0187219$ph325326 = 0 ; $$1176$ph$ph$lcssa208 = 1 ; $$1186$ph$lcssa = - 1 ; label = 26 ; } else { $$0187263 = 0 ; $10 = $4 ; while ( 1 ) { $6 = ( ( $0 ) + ( $$0187263 ) | 0 ) ; $7 = HEAP8 [ $6 >> 0 ] | 0 ; $8 = ( $7 << 24 >> 24 ) == ( 0 ) ; if ( $8 ) { $$3 = 0 ; break L1 ; } $9 = $10 & 31 ; $11 = $9 & 255 ; $12 = 1 << $11 ; $div188 = ( $10 & 255 ) >>> 5 ; $13 = $div188 & 255 ; $14 = ( ( $2 ) + ( $13 << 2 ) | 0 ) ; $15 = HEAP32 [ $14 >> 2 ] | 0 ; $16 = $15 | $12 ; HEAP32 [ $14 >> 2 ] = $16 ; $17 = ( ( $$0187263 ) + 1 ) | 0 ; $18 = $10 & 255 ; $19 = ( ( $3 ) + ( $18 << 2 ) | 0 ) ; HEAP32 [ $19 >> 2 ] = $17 ; $20 = ( ( $1 ) + ( $17 ) | 0 ) ; $21 = HEAP8 [ $20 >> 0 ] | 0 ; $22 = ( $21 << 24 >> 24 ) == ( 0 ) ; if ( $22 ) { break ; } else { $$0187263 = $17 ; $10 = $21 ; } } $23 = ( $17 >>> 0 ) > ( 1 ) ; if ( $23 ) { $$0183$ph260 = 0 ; $$0185$ph259 = - 1 ; $130 = 1 ; L6 : while ( 1 ) { $$0175$ph$ph254 = 1 ; $$0183$ph197$ph253 = $$0183$ph260 ; $131 = $130 ; while ( 1 ) { $$0183$ph197248 = $$0183$ph197$ph253 ; $132 = $131 ; L10 : while ( 1 ) { $$0179242 = 1 ; $25 = $132 ; while ( 1 ) { $30 = ( ( $$0179242 ) + ( $$0185$ph259 ) ) | 0 ; $31 = ( ( $1 ) + ( $30 ) | 0 ) ; $32 = HEAP8 [ $31 >> 0 ] | 0 ; $33 = ( ( $1 ) + ( $25 ) | 0 ) ; $34 = HEAP8 [ $33 >> 0 ] | 0 ; $35 = ( $32 << 24 >> 24 ) == ( $34 << 24 >> 24 ) ; if ( ! ( $35 ) ) { break L10 ; } $36 = ( $$0179242 | 0 ) == ( $$0175$ph$ph254 | 0 ) ; $28 = ( ( $$0179242 ) + 1 ) | 0 ; if ( $36 ) { break ; } $27 = ( ( $28 ) + ( $$0183$ph197248 ) ) | 0 ; $29 = ( $27 >>> 0 ) < ( $17 >>> 0 ) ; if ( $29 ) { $$0179242 = $28 ; $25 = $27 ; } else { $$0175$ph$ph$lcssa216 = $$0175$ph$ph254 ; $$0185$ph$lcssa = $$0185$ph259 ; break L6 ; } } $37 = ( ( $$0175$ph$ph254 ) + ( $$0183$ph197248 ) ) | 0 ; $38 = ( ( $37 ) + 1 ) | 0 ; $39 = ( $38 >>> 0 ) < ( $17 >>> 0 ) ; if ( $39 ) { $$0183$ph197248 = $37 ; $132 = $38 ; } else { $$0175$ph$ph$lcssa216 = $$0175$ph$ph254 ; $$0185$ph$lcssa = $$0185$ph259 ; break L6 ; } } $40 = ( $32 & 255 ) > ( $34 & 255 ) ; $41 = ( ( $25 ) - ( $$0185$ph259 ) ) | 0 ; if ( ! ( $40 ) ) { break ; } $24 = ( ( $25 ) + 1 ) | 0 ; $26 = ( $24 >>> 0 ) < ( $17 >>> 0 ) ; if ( $26 ) { $$0175$ph$ph254 = $41 ; $$0183$ph197$ph253 = $25 ; $131 = $24 ; } else { $$0175$ph$ph$lcssa216 = $41 ; $$0185$ph$lcssa = $$0185$ph259 ; break L6 ; } } $42 = ( ( $$0183$ph197248 ) + 1 ) | 0 ; $43 = ( ( $$0183$ph197248 ) + 2 ) | 0 ; $44 = ( $43 >>> 0 ) < ( $17 >>> 0 ) ; if ( $44 ) { $$0183$ph260 = $42 ; $$0185$ph259 = $$0183$ph197248 ; $130 = $43 ; } else { $$0175$ph$ph$lcssa216 = 1 ; $$0185$ph$lcssa = $$0183$ph197248 ; break ; } } if ( $23 ) { $$1184$ph239 = 0 ; $$1186$ph238 = - 1 ; $133 = 1 ; while ( 1 ) { $$1176$ph$ph233 = 1 ; $$1184$ph193$ph232 = $$1184$ph239 ; $135 = $133 ; while ( 1 ) { $$1184$ph193227 = $$1184$ph193$ph232 ; $134 = $135 ; L25 : while ( 1 ) { $$1180222 = 1 ; $52 = $134 ; while ( 1 ) { $48 = ( ( $$1180222 ) + ( $$1186$ph238 ) ) | 0 ; $49 = ( ( $1 ) + ( $48 ) | 0 ) ; $50 = HEAP8 [ $49 >> 0 ] | 0 ; $51 = ( ( $1 ) + ( $52 ) | 0 ) ; $53 = HEAP8 [ $51 >> 0 ] | 0 ; $54 = ( $50 << 24 >> 24 ) == ( $53 << 24 >> 24 ) ; if ( ! ( $54 ) ) { break L25 ; } $55 = ( $$1180222 | 0 ) == ( $$1176$ph$ph233 | 0 ) ; $46 = ( ( $$1180222 ) + 1 ) | 0 ; if ( $55 ) { break ; } $45 = ( ( $46 ) + ( $$1184$ph193227 ) ) | 0 ; $47 = ( $45 >>> 0 ) < ( $17 >>> 0 ) ; if ( $47 ) { $$1180222 = $46 ; $52 = $45 ; } else { $$0175$ph$ph$lcssa216328 = $$0175$ph$ph$lcssa216 ; $$0185$ph$lcssa327 = $$0185$ph$lcssa ; $$0187219$ph325326 = $17 ; $$1176$ph$ph$lcssa208 = $$1176$ph$ph233 ; $$1186$ph$lcssa = $$1186$ph238 ; label = 26 ; break L1 ; } } $56 = ( ( $$1176$ph$ph233 ) + ( $$1184$ph193227 ) ) | 0 ; $57 = ( ( $56 ) + 1 ) | 0 ; $58 = ( $57 >>> 0 ) < ( $17 >>> 0 ) ; if ( $58 ) { $$1184$ph193227 = $56 ; $134 = $57 ; } else { $$0175$ph$ph$lcssa216328 = $$0175$ph$ph$lcssa216 ; $$0185$ph$lcssa327 = $$0185$ph$lcssa ; $$0187219$ph325326 = $17 ; $$1176$ph$ph$lcssa208 = $$1176$ph$ph233 ; $$1186$ph$lcssa = $$1186$ph238 ; label = 26 ; break L1 ; } } $59 = ( $50 & 255 ) < ( $53 & 255 ) ; $60 = ( ( $52 ) - ( $$1186$ph238 ) ) | 0 ; if ( ! ( $59 ) ) { break ; } $64 = ( ( $52 ) + 1 ) | 0 ; $65 = ( $64 >>> 0 ) < ( $17 >>> 0 ) ; if ( $65 ) { $$1176$ph$ph233 = $60 ; $$1184$ph193$ph232 = $52 ; $135 = $64 ; } else { $$0175$ph$ph$lcssa216328 = $$0175$ph$ph$lcssa216 ; $$0185$ph$lcssa327 = $$0185$ph$lcssa ; $$0187219$ph325326 = $17 ; $$1176$ph$ph$lcssa208 = $60 ; $$1186$ph$lcssa = $$1186$ph238 ; label = 26 ; break L1 ; } } $61 = ( ( $$1184$ph193227 ) + 1 ) | 0 ; $62 = ( ( $$1184$ph193227 ) + 2 ) | 0 ; $63 = ( $62 >>> 0 ) < ( $17 >>> 0 ) ; if ( $63 ) { $$1184$ph239 = $61 ; $$1186$ph238 = $$1184$ph193227 ; $133 = $62 ; } else { $$0175$ph$ph$lcssa216328 = $$0175$ph$ph$lcssa216 ; $$0185$ph$lcssa327 = $$0185$ph$lcssa ; $$0187219$ph325326 = $17 ; $$1176$ph$ph$lcssa208 = 1 ; $$1186$ph$lcssa = $$1184$ph193227 ; label = 26 ; break ; } } } else { $$0175$ph$ph$lcssa216328 = $$0175$ph$ph$lcssa216 ; $$0185$ph$lcssa327 = $$0185$ph$lcssa ; $$0187219$ph325326 = $17 ; $$1176$ph$ph$lcssa208 = 1 ; $$1186$ph$lcssa = - 1 ; label = 26 ; } } else { $$0175$ph$ph$lcssa216328 = 1 ; $$0185$ph$lcssa327 = - 1 ; $$0187219$ph325326 = $17 ; $$1176$ph$ph$lcssa208 = 1 ; $$1186$ph$lcssa = - 1 ; label = 26 ; } } } while ( 0 ) ; L35 : do { if ( ( label | 0 ) == 26 ) { $66 = ( ( $$1186$ph$lcssa ) + 1 ) | 0 ; $67 = ( ( $$0185$ph$lcssa327 ) + 1 ) | 0 ; $68 = ( $66 >>> 0 ) > ( $67 >>> 0 ) ; $$1176$$0175 = $68 ? $$1176$ph$ph$lcssa208 : $$0175$ph$ph$lcssa216328 ; $$1186$$0185 = $68 ? $$1186$ph$lcssa : $$0185$ph$lcssa327 ; $69 = ( ( $1 ) + ( $$1176$$0175 ) | 0 ) ; $70 = ( ( $$1186$$0185 ) + 1 ) | 0 ; $71 = ( _memcmp ( $1 , $69 , $70 ) | 0 ) ; $72 = ( $71 | 0 ) == ( 0 ) ; if ( $72 ) { $77 = ( ( $$0187219$ph325326 ) - ( $$1176$$0175 ) ) | 0 ; $$0168 = $77 ; $$3178 = $$1176$$0175 ; } else { $73 = ( ( $$0187219$ph325326 ) - ( $$1186$$0185 ) ) | 0 ; $74 = ( ( $73 ) + - 1 ) | 0 ; $75 = ( $$1186$$0185 >>> 0 ) > ( $74 >>> 0 ) ; $$1186$$0185$ = $75 ? $$1186$$0185 : $74 ; $76 = ( ( $$1186$$0185$ ) + 1 ) | 0 ; $$0168 = 0 ; $$3178 = $76 ; } $78 = $$0187219$ph325326 | 63 ; $79 = ( ( $$0187219$ph325326 ) + - 1 ) | 0 ; $80 = ( $$0168 | 0 ) != ( 0 ) ; $81 = ( ( $$0187219$ph325326 ) - ( $$3178 ) ) | 0 ; $$0166 = $0 ; $$0169 = 0 ; $$0170 = $0 ; while ( 1 ) { $82 = $$0170 ; $83 = $$0166 ; $84 = ( ( $82 ) - ( $83 ) ) | 0 ; $85 = ( $84 >>> 0 ) < ( $$0187219$ph325326 >>> 0 ) ; do { if ( $85 ) { $86 = ( _memchr ( $$0170 , 0 , $78 ) | 0 ) ; $87 = ( $86 | 0 ) == ( 0 | 0 ) ; if ( $87 ) { $91 = ( ( $$0170 ) + ( $78 ) | 0 ) ; $$3173 = $91 ; break ; } else { $88 = $86 ; $89 = ( ( $88 ) - ( $83 ) ) | 0 ; $90 = ( $89 >>> 0 ) < ( $$0187219$ph325326 >>> 0 ) ; if ( $90 ) { $$3 = 0 ; break L35 ; } else { $$3173 = $86 ; break ; } } } else { $$3173 = $$0170 ; } } while ( 0 ) ; $92 = ( ( $$0166 ) + ( $79 ) | 0 ) ; $93 = HEAP8 [ $92 >> 0 ] | 0 ; $div = ( $93 & 255 ) >>> 5 ; $94 = $div & 255 ; $95 = ( ( $2 ) + ( $94 << 2 ) | 0 ) ; $96 = HEAP32 [ $95 >> 2 ] | 0 ; $97 = $93 & 31 ; $98 = $97 & 255 ; $99 = 1 << $98 ; $100 = $99 & $96 ; $101 = ( $100 | 0 ) == ( 0 ) ; L49 : do { if ( $101 ) { $$0169$be = 0 ; $$2181$sink = $$0187219$ph325326 ; } else { $102 = $93 & 255 ; $103 = ( ( $3 ) + ( $102 << 2 ) | 0 ) ; $104 = HEAP32 [ $103 >> 2 ] | 0 ; $105 = ( ( $$0187219$ph325326 ) - ( $104 ) ) | 0 ; $106 = ( $105 | 0 ) == ( 0 ) ; if ( ! ( $106 ) ) { $107 = ( $$0169 | 0 ) != ( 0 ) ; $or$cond = $80 & $107 ; $108 = ( $105 >>> 0 ) < ( $$3178 >>> 0 ) ; $or$cond189 = $or$cond & $108 ; $$2181 = $or$cond189 ? $81 : $105 ; $$0169$be = 0 ; $$2181$sink = $$2181 ; break ; } $110 = ( $70 >>> 0 ) > ( $$0169 >>> 0 ) ; $111 = $110 ? $70 : $$0169 ; $112 = ( ( $1 ) + ( $111 ) | 0 ) ; $113 = HEAP8 [ $112 >> 0 ] | 0 ; $114 = ( $113 << 24 >> 24 ) == ( 0 ) ; L54 : do { if ( $114 ) { $$4 = $70 ; } else { $$3182221 = $111 ; $$pr = $113 ; while ( 1 ) { $115 = ( ( $$0166 ) + ( $$3182221 ) | 0 ) ; $116 = HEAP8 [ $115 >> 0 ] | 0 ; $117 = ( $$pr << 24 >> 24 ) == ( $116 << 24 >> 24 ) ; if ( ! ( $117 ) ) { break ; } $118 = ( ( $$3182221 ) + 1 ) | 0 ; $119 = ( ( $1 ) + ( $118 ) | 0 ) ; $120 = HEAP8 [ $119 >> 0 ] | 0 ; $121 = ( $120 << 24 >> 24 ) == ( 0 ) ; if ( $121 ) { $$4 = $70 ; break L54 ; } else { $$3182221 = $118 ; $$pr = $120 ; } } $122 = ( ( $$3182221 ) - ( $$1186$$0185 ) ) | 0 ; $$0169$be = 0 ; $$2181$sink = $122 ; break L49 ; } } while ( 0 ) ; while ( 1 ) { $123 = ( $$4 >>> 0 ) > ( $$0169 >>> 0 ) ; if ( ! ( $123 ) ) { $$3 = $$0166 ; break L35 ; } $124 = ( ( $$4 ) + - 1 ) | 0 ; $125 = ( ( $1 ) + ( $124 ) | 0 ) ; $126 = HEAP8 [ $125 >> 0 ] | 0 ; $127 = ( ( $$0166 ) + ( $124 ) | 0 ) ; $128 = HEAP8 [ $127 >> 0 ] | 0 ; $129 = ( $126 << 24 >> 24 ) == ( $128 << 24 >> 24 ) ; if ( $129 ) { $$4 = $124 ; } else { $$0169$be = $$0168 ; $$2181$sink = $$3178 ; break ; } } } } while ( 0 ) ; $109 = ( ( $$0166 ) + ( $$2181$sink ) | 0 ) ; $$0166 = $109 ; $$0169 = $$0169$be ; $$0170 = $$3173 ; } } } while ( 0 ) ; STACKTOP = sp ; return ( $$3 | 0 ) ; } function _memcmp ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $$01318 = 0 , $$01417 = 0 , $$019 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $3 = ( $2 | 0 ) == ( 0 ) ; L1 : do { if ( $3 ) { $14 = 0 ; } else { $$01318 = $0 ; $$01417 = $2 ; $$019 = $1 ; while ( 1 ) { $4 = HEAP8 [ $$01318 >> 0 ] | 0 ; $5 = HEAP8 [ $$019 >> 0 ] | 0 ; $6 = ( $4 << 24 >> 24 ) == ( $5 << 24 >> 24 ) ; if ( ! ( $6 ) ) { break ; } $7 = ( ( $$01417 ) + - 1 ) | 0 ; $8 = ( ( ( $$01318 ) ) + 1 | 0 ) ; $9 = ( ( ( $$019 ) ) + 1 | 0 ) ; $10 = ( $7 | 0 ) == ( 0 ) ; if ( $10 ) { $14 = 0 ; break L1 ; } else { $$01318 = $8 ; $$01417 = $7 ; $$019 = $9 ; } } $11 = $4 & 255 ; $12 = $5 & 255 ; $13 = ( ( $11 ) - ( $12 ) ) | 0 ; $14 = $13 ; } } while ( 0 ) ; return ( $14 | 0 ) ; } function _access ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $2 = 0 , $3 = 0 , $4 = 0 , $vararg_buffer = 0 , $vararg_ptr1 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $vararg_buffer = sp ; $2 = $0 ; HEAP32 [ $vararg_buffer >> 2 ] = $2 ; $vararg_ptr1 = ( ( ( $vararg_buffer ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr1 >> 2 ] = $1 ; $3 = ( ___syscall33 ( 33 , ( $vararg_buffer | 0 ) ) | 0 ) ; $4 = ( ___syscall_ret ( $3 ) | 0 ) ; STACKTOP = sp ; return ( $4 | 0 ) ; } function _fputs ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( _strlen ( $0 ) | 0 ) ; $3 = ( _fwrite ( $0 , 1 , $2 , $1 ) | 0 ) ; $4 = ( $3 | 0 ) != ( $2 | 0 ) ; $5 = $4 << 31 >> 31 ; return ( $5 | 0 ) ; } function _fwrite ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $$ = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $phitmp = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $4 = Math_imul ( $2 , $1 ) | 0 ; $5 = ( $1 | 0 ) == ( 0 ) ; $$ = $5 ? 0 : $2 ; $6 = ( ( ( $3 ) ) + 76 | 0 ) ; $7 = HEAP32 [ $6 >> 2 ] | 0 ; $8 = ( $7 | 0 ) > ( - 1 ) ; if ( $8 ) { $10 = ( ___lockfile ( $3 ) | 0 ) ; $phitmp = ( $10 | 0 ) == ( 0 ) ; $11 = ( ___fwritex ( $0 , $4 , $3 ) | 0 ) ; if ( $phitmp ) { $12 = $11 ; } else { ___unlockfile ( $3 ) ; $12 = $11 ; } } else { $9 = ( ___fwritex ( $0 , $4 , $3 ) | 0 ) ; $12 = $9 ; } $13 = ( $12 | 0 ) == ( $4 | 0 ) ; if ( $13 ) { $15 = $$ ; } else { $14 = ( ( $12 >>> 0 ) / ( $1 >>> 0 ) ) & - 1 ; $15 = $14 ; } return ( $15 | 0 ) ; } function ___overflow ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$0 = 0 , $$pre = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $3 = 0 , $4 = 0 ; var $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $2 = sp ; $3 = $1 & 255 ; HEAP8 [ $2 >> 0 ] = $3 ; $4 = ( ( ( $0 ) ) + 16 | 0 ) ; $5 = HEAP32 [ $4 >> 2 ] | 0 ; $6 = ( $5 | 0 ) == ( 0 | 0 ) ; if ( $6 ) { $7 = ( ___towrite ( $0 ) | 0 ) ; $8 = ( $7 | 0 ) == ( 0 ) ; if ( $8 ) { $$pre = HEAP32 [ $4 >> 2 ] | 0 ; $12 = $$pre ; label = 4 ; } else { $$0 = - 1 ; } } else { $12 = $5 ; label = 4 ; } do { if ( ( label | 0 ) == 4 ) { $9 = ( ( ( $0 ) ) + 20 | 0 ) ; $10 = HEAP32 [ $9 >> 2 ] | 0 ; $11 = ( $10 >>> 0 ) < ( $12 >>> 0 ) ; if ( $11 ) { $13 = $1 & 255 ; $14 = ( ( ( $0 ) ) + 75 | 0 ) ; $15 = HEAP8 [ $14 >> 0 ] | 0 ; $16 = $15 << 24 >> 24 ; $17 = ( $13 | 0 ) == ( $16 | 0 ) ; if ( ! ( $17 ) ) { $18 = ( ( ( $10 ) ) + 1 | 0 ) ; HEAP32 [ $9 >> 2 ] = $18 ; HEAP8 [ $10 >> 0 ] = $3 ; $$0 = $13 ; break ; } } $19 = ( ( ( $0 ) ) + 36 | 0 ) ; $20 = HEAP32 [ $19 >> 2 ] | 0 ; $21 = ( FUNCTION_TABLE_iiii [ $20 & 127 ] ( $0 , $2 , 1 ) | 0 ) ; $22 = ( $21 | 0 ) == ( 1 ) ; if ( $22 ) { $23 = HEAP8 [ $2 >> 0 ] | 0 ; $24 = $23 & 255 ; $$0 = $24 ; } else { $$0 = - 1 ; } } } while ( 0 ) ; STACKTOP = sp ; return ( $$0 | 0 ) ; } function _tolower ( $0 ) { $0 = $0 | 0 ; var $$0 = 0 , $1 = 0 , $2 = 0 , $3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( _isupper ( $0 ) | 0 ) ; $2 = ( $1 | 0 ) == ( 0 ) ; $3 = $0 | 32 ; $$0 = $2 ? $0 : $3 ; return ( $$0 | 0 ) ; } function _isupper ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( ( $0 ) + - 65 ) | 0 ; $2 = ( $1 >>> 0 ) < ( 26 ) ; $3 = $2 & 1 ; return ( $3 | 0 ) ; } function _strcat ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $2 = 0 , $3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( _strlen ( $0 ) | 0 ) ; $3 = ( ( $0 ) + ( $2 ) | 0 ) ; ( _strcpy ( $3 , $1 ) | 0 ) ; return ( $0 | 0 ) ; } function _strpbrk ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( _strcspn ( $0 , $1 ) | 0 ) ; $3 = ( ( $0 ) + ( $2 ) | 0 ) ; $4 = HEAP8 [ $3 >> 0 ] | 0 ; $5 = ( $4 << 24 >> 24 ) != ( 0 ) ; $6 = $5 ? $3 : 0 ; return ( $6 | 0 ) ; } function _mkdir ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $2 = 0 , $3 = 0 , $4 = 0 , $vararg_buffer = 0 , $vararg_ptr1 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $vararg_buffer = sp ; $2 = $0 ; HEAP32 [ $vararg_buffer >> 2 ] = $2 ; $vararg_ptr1 = ( ( ( $vararg_buffer ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr1 >> 2 ] = $1 ; $3 = ( ___syscall39 ( 39 , ( $vararg_buffer | 0 ) ) | 0 ) ; $4 = ( ___syscall_ret ( $3 ) | 0 ) ; STACKTOP = sp ; return ( $4 | 0 ) ; } function _isalpha ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = $0 | 32 ; $2 = ( ( $1 ) + - 97 ) | 0 ; $3 = ( $2 >>> 0 ) < ( 26 ) ; $4 = $3 & 1 ; return ( $4 | 0 ) ; } function _getc ( $0 ) { $0 = $0 | 0 ; var $$0 = 0 , $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $3 = 0 , $4 = 0 ; var $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( ( ( $0 ) ) + 76 | 0 ) ; $2 = HEAP32 [ $1 >> 2 ] | 0 ; $3 = ( $2 | 0 ) < ( 0 ) ; if ( $3 ) { label = 3 ; } else { $4 = ( ___lockfile ( $0 ) | 0 ) ; $5 = ( $4 | 0 ) == ( 0 ) ; if ( $5 ) { label = 3 ; } else { $15 = ( ( ( $0 ) ) + 4 | 0 ) ; $16 = HEAP32 [ $15 >> 2 ] | 0 ; $17 = ( ( ( $0 ) ) + 8 | 0 ) ; $18 = HEAP32 [ $17 >> 2 ] | 0 ; $19 = ( $16 >>> 0 ) < ( $18 >>> 0 ) ; if ( $19 ) { $20 = ( ( ( $16 ) ) + 1 | 0 ) ; HEAP32 [ $15 >> 2 ] = $20 ; $21 = HEAP8 [ $16 >> 0 ] | 0 ; $22 = $21 & 255 ; $24 = $22 ; } else { $23 = ( ___uflow ( $0 ) | 0 ) ; $24 = $23 ; } $$0 = $24 ; } } do { if ( ( label | 0 ) == 3 ) { $6 = ( ( ( $0 ) ) + 4 | 0 ) ; $7 = HEAP32 [ $6 >> 2 ] | 0 ; $8 = ( ( ( $0 ) ) + 8 | 0 ) ; $9 = HEAP32 [ $8 >> 2 ] | 0 ; $10 = ( $7 >>> 0 ) < ( $9 >>> 0 ) ; if ( $10 ) { $11 = ( ( ( $7 ) ) + 1 | 0 ) ; HEAP32 [ $6 >> 2 ] = $11 ; $12 = HEAP8 [ $7 >> 0 ] | 0 ; $13 = $12 & 255 ; $$0 = $13 ; break ; } else { $14 = ( ___uflow ( $0 ) | 0 ) ; $$0 = $14 ; break ; } } } while ( 0 ) ; return ( $$0 | 0 ) ; } function _unlink ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , $vararg_buffer = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $vararg_buffer = sp ; $1 = $0 ; HEAP32 [ $vararg_buffer >> 2 ] = $1 ; $2 = ( ___syscall10 ( 10 , ( $vararg_buffer | 0 ) ) | 0 ) ; $3 = ( ___syscall_ret ( $2 ) | 0 ) ; STACKTOP = sp ; return ( $3 | 0 ) ; } function _chown ( $0 , $1 , $2 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; var $3 = 0 , $4 = 0 , $5 = 0 , $vararg_buffer = 0 , $vararg_ptr1 = 0 , $vararg_ptr2 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $vararg_buffer = sp ; $3 = $0 ; HEAP32 [ $vararg_buffer >> 2 ] = $3 ; $vararg_ptr1 = ( ( ( $vararg_buffer ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr1 >> 2 ] = $1 ; $vararg_ptr2 = ( ( ( $vararg_buffer ) ) + 8 | 0 ) ; HEAP32 [ $vararg_ptr2 >> 2 ] = $2 ; $4 = ( ___syscall212 ( 212 , ( $vararg_buffer | 0 ) ) | 0 ) ; $5 = ( ___syscall_ret ( $4 ) | 0 ) ; STACKTOP = sp ; return ( $5 | 0 ) ; } function _setvbuf ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $4 = ( ( ( $0 ) ) + 75 | 0 ) ; HEAP8 [ $4 >> 0 ] = - 1 ; switch ( $2 | 0 ) { case 2 : { $5 = ( ( ( $0 ) ) + 48 | 0 ) ; HEAP32 [ $5 >> 2 ] = 0 ; break ; } case 1 : { HEAP8 [ $4 >> 0 ] = 10 ; break ; } default : { } } $6 = HEAP32 [ $0 >> 2 ] | 0 ; $7 = $6 | 64 ; HEAP32 [ $0 >> 2 ] = $7 ; return 0 ; } function _fread ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $$ = 0 , $$0 = 0 , $$054$ph = 0 , $$05460 = 0 , $$056$ph = 0 , $$05659 = 0 , $$57 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $20 = 0 , $21 = 0 , $22 = 0 ; var $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 , $28 = 0 , $29 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $34 = 0 , $35 = 0 , $36 = 0 , $37 = 0 , $38 = 0 , $39 = 0 , $4 = 0 , $40 = 0 , $41 = 0 ; var $42 = 0 , $43 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $4 = Math_imul ( $2 , $1 ) | 0 ; $5 = ( $1 | 0 ) == ( 0 ) ; $$ = $5 ? 0 : $2 ; $6 = ( ( ( $3 ) ) + 76 | 0 ) ; $7 = HEAP32 [ $6 >> 2 ] | 0 ; $8 = ( $7 | 0 ) > ( - 1 ) ; if ( $8 ) { $9 = ( ___lockfile ( $3 ) | 0 ) ; $36 = $9 ; } else { $36 = 0 ; } $10 = ( ( ( $3 ) ) + 74 | 0 ) ; $11 = HEAP8 [ $10 >> 0 ] | 0 ; $12 = $11 << 24 >> 24 ; $13 = ( ( $12 ) + 255 ) | 0 ; $14 = $13 | $12 ; $15 = $14 & 255 ; HEAP8 [ $10 >> 0 ] = $15 ; $16 = ( ( ( $3 ) ) + 8 | 0 ) ; $17 = HEAP32 [ $16 >> 2 ] | 0 ; $18 = ( ( ( $3 ) ) + 4 | 0 ) ; $19 = HEAP32 [ $18 >> 2 ] | 0 ; $20 = ( ( $17 ) - ( $19 ) ) | 0 ; $21 = ( $20 | 0 ) > ( 0 ) ; if ( $21 ) { $22 = $19 ; $23 = ( $20 >>> 0 ) < ( $4 >>> 0 ) ; $$57 = $23 ? $20 : $4 ; ( _memcpy ( ( $0 | 0 ) , ( $22 | 0 ) , ( $$57 | 0 ) ) | 0 ) ; $24 = HEAP32 [ $18 >> 2 ] | 0 ; $25 = ( ( $24 ) + ( $$57 ) | 0 ) ; HEAP32 [ $18 >> 2 ] = $25 ; $26 = ( ( $0 ) + ( $$57 ) | 0 ) ; $27 = ( ( $4 ) - ( $$57 ) ) | 0 ; $$054$ph = $27 ; $$056$ph = $26 ; } else { $$054$ph = $4 ; $$056$ph = $0 ; } $28 = ( $$054$ph | 0 ) == ( 0 ) ; L7 : do { if ( $28 ) { label = 13 ; } else { $29 = ( ( ( $3 ) ) + 32 | 0 ) ; $$05460 = $$054$ph ; $$05659 = $$056$ph ; while ( 1 ) { $30 = ( ___toread ( $3 ) | 0 ) ; $31 = ( $30 | 0 ) == ( 0 ) ; if ( ! ( $31 ) ) { break ; } $32 = HEAP32 [ $29 >> 2 ] | 0 ; $33 = ( FUNCTION_TABLE_iiii [ $32 & 127 ] ( $3 , $$05659 , $$05460 ) | 0 ) ; $34 = ( ( $33 ) + 1 ) | 0 ; $35 = ( $34 >>> 0 ) < ( 2 ) ; if ( $35 ) { break ; } $40 = ( ( $$05460 ) - ( $33 ) ) | 0 ; $41 = ( ( $$05659 ) + ( $33 ) | 0 ) ; $42 = ( $40 | 0 ) == ( 0 ) ; if ( $42 ) { label = 13 ; break L7 ; } else { $$05460 = $40 ; $$05659 = $41 ; } } $37 = ( $36 | 0 ) == ( 0 ) ; if ( ! ( $37 ) ) { ___unlockfile ( $3 ) ; } $38 = ( ( $4 ) - ( $$05460 ) ) | 0 ; $39 = ( ( $38 >>> 0 ) / ( $1 >>> 0 ) ) & - 1 ; $$0 = $39 ; } } while ( 0 ) ; if ( ( label | 0 ) == 13 ) { $43 = ( $36 | 0 ) == ( 0 ) ; if ( $43 ) { $$0 = $$ ; } else { ___unlockfile ( $3 ) ; $$0 = $$ ; } } return ( $$0 | 0 ) ; } function _ungetc ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$1 = 0 , $$pr = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 ; var $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( $0 | 0 ) == ( - 1 ) ; do { if ( $2 ) { $$1 = - 1 ; } else { $3 = ( ( ( $1 ) ) + 76 | 0 ) ; $4 = HEAP32 [ $3 >> 2 ] | 0 ; $5 = ( $4 | 0 ) > ( - 1 ) ; if ( $5 ) { $6 = ( ___lockfile ( $1 ) | 0 ) ; $16 = $6 ; } else { $16 = 0 ; } $7 = ( ( ( $1 ) ) + 4 | 0 ) ; $8 = HEAP32 [ $7 >> 2 ] | 0 ; $9 = ( $8 | 0 ) == ( 0 | 0 ) ; if ( $9 ) { ( ___toread ( $1 ) | 0 ) ; $$pr = HEAP32 [ $7 >> 2 ] | 0 ; $10 = ( $$pr | 0 ) == ( 0 | 0 ) ; if ( ! ( $10 ) ) { $14 = $$pr ; label = 6 ; } } else { $14 = $8 ; label = 6 ; } if ( ( label | 0 ) == 6 ) { $11 = ( ( ( $1 ) ) + 44 | 0 ) ; $12 = HEAP32 [ $11 >> 2 ] | 0 ; $13 = ( ( ( $12 ) ) + - 8 | 0 ) ; $15 = ( $14 >>> 0 ) > ( $13 >>> 0 ) ; if ( $15 ) { $18 = $0 & 255 ; $19 = ( ( ( $14 ) ) + - 1 | 0 ) ; HEAP32 [ $7 >> 2 ] = $19 ; HEAP8 [ $19 >> 0 ] = $18 ; $20 = HEAP32 [ $1 >> 2 ] | 0 ; $21 = $20 & - 17 ; HEAP32 [ $1 >> 2 ] = $21 ; $22 = ( $16 | 0 ) == ( 0 ) ; if ( $22 ) { $$1 = $0 ; break ; } ___unlockfile ( $1 ) ; $$1 = $0 ; break ; } } $17 = ( $16 | 0 ) == ( 0 ) ; if ( $17 ) { $$1 = - 1 ; } else { ___unlockfile ( $1 ) ; $$1 = - 1 ; } } } while ( 0 ) ; return ( $$1 | 0 ) ; } function _fputc ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$0 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $26 = 0 , $27 = 0 ; var $28 = 0 , $29 = 0 , $3 = 0 , $30 = 0 , $31 = 0 , $32 = 0 , $33 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( ( ( $1 ) ) + 76 | 0 ) ; $3 = HEAP32 [ $2 >> 2 ] | 0 ; $4 = ( $3 | 0 ) < ( 0 ) ; if ( $4 ) { label = 3 ; } else { $5 = ( ___lockfile ( $1 ) | 0 ) ; $6 = ( $5 | 0 ) == ( 0 ) ; if ( $6 ) { label = 3 ; } else { $20 = $0 & 255 ; $21 = $0 & 255 ; $22 = ( ( ( $1 ) ) + 75 | 0 ) ; $23 = HEAP8 [ $22 >> 0 ] | 0 ; $24 = $23 << 24 >> 24 ; $25 = ( $21 | 0 ) == ( $24 | 0 ) ; if ( $25 ) { label = 10 ; } else { $26 = ( ( ( $1 ) ) + 20 | 0 ) ; $27 = HEAP32 [ $26 >> 2 ] | 0 ; $28 = ( ( ( $1 ) ) + 16 | 0 ) ; $29 = HEAP32 [ $28 >> 2 ] | 0 ; $30 = ( $27 >>> 0 ) < ( $29 >>> 0 ) ; if ( $30 ) { $31 = ( ( ( $27 ) ) + 1 | 0 ) ; HEAP32 [ $26 >> 2 ] = $31 ; HEAP8 [ $27 >> 0 ] = $20 ; $33 = $21 ; } else { label = 10 ; } } if ( ( label | 0 ) == 10 ) { $32 = ( ___overflow ( $1 , $0 ) | 0 ) ; $33 = $32 ; } ___unlockfile ( $1 ) ; $$0 = $33 ; } } do { if ( ( label | 0 ) == 3 ) { $7 = $0 & 255 ; $8 = $0 & 255 ; $9 = ( ( ( $1 ) ) + 75 | 0 ) ; $10 = HEAP8 [ $9 >> 0 ] | 0 ; $11 = $10 << 24 >> 24 ; $12 = ( $8 | 0 ) == ( $11 | 0 ) ; if ( ! ( $12 ) ) { $13 = ( ( ( $1 ) ) + 20 | 0 ) ; $14 = HEAP32 [ $13 >> 2 ] | 0 ; $15 = ( ( ( $1 ) ) + 16 | 0 ) ; $16 = HEAP32 [ $15 >> 2 ] | 0 ; $17 = ( $14 >>> 0 ) < ( $16 >>> 0 ) ; if ( $17 ) { $18 = ( ( ( $14 ) ) + 1 | 0 ) ; HEAP32 [ $13 >> 2 ] = $18 ; HEAP8 [ $14 >> 0 ] = $7 ; $$0 = $8 ; break ; } } $19 = ( ___overflow ( $1 , $0 ) | 0 ) ; $$0 = $19 ; } } while ( 0 ) ; return ( $$0 | 0 ) ; } function _rename ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $vararg_buffer = 0 , $vararg_ptr1 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $vararg_buffer = sp ; $2 = $0 ; $3 = $1 ; HEAP32 [ $vararg_buffer >> 2 ] = $2 ; $vararg_ptr1 = ( ( ( $vararg_buffer ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr1 >> 2 ] = $3 ; $4 = ( ___syscall38 ( 38 , ( $vararg_buffer | 0 ) ) | 0 ) ; $5 = ( ___syscall_ret ( $4 ) | 0 ) ; STACKTOP = sp ; return ( $5 | 0 ) ; } function _fsetpos ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $2 = 0 , $3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = HEAP32 [ $1 >> 2 ] | 0 ; $3 = ( ___fseeko ( $0 , $2 , 0 ) | 0 ) ; return ( $3 | 0 ) ; } function ___ftello_unlocked ( $0 ) { $0 = $0 | 0 ; var $$0 = 0 , $1 = 0 , $10 = 0 , $11 = 0 , $12 = 0 , $13 = 0 , $14 = 0 , $15 = 0 , $16 = 0 , $17 = 0 , $18 = 0 , $19 = 0 , $2 = 0 , $20 = 0 , $21 = 0 , $22 = 0 , $23 = 0 , $24 = 0 , $25 = 0 , $3 = 0 ; var $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $8 = 0 , $9 = 0 , $phitmp = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( ( ( $0 ) ) + 40 | 0 ) ; $2 = HEAP32 [ $1 >> 2 ] | 0 ; $3 = HEAP32 [ $0 >> 2 ] | 0 ; $4 = $3 & 128 ; $5 = ( $4 | 0 ) == ( 0 ) ; if ( $5 ) { $11 = 1 ; } else { $6 = ( ( ( $0 ) ) + 20 | 0 ) ; $7 = HEAP32 [ $6 >> 2 ] | 0 ; $8 = ( ( ( $0 ) ) + 28 | 0 ) ; $9 = HEAP32 [ $8 >> 2 ] | 0 ; $10 = ( $7 >>> 0 ) > ( $9 >>> 0 ) ; $phitmp = $10 ? 2 : 1 ; $11 = $phitmp ; } $12 = ( FUNCTION_TABLE_iiii [ $2 & 127 ] ( $0 , 0 , $11 ) | 0 ) ; $13 = ( $12 | 0 ) < ( 0 ) ; if ( $13 ) { $$0 = $12 ; } else { $14 = ( ( ( $0 ) ) + 8 | 0 ) ; $15 = HEAP32 [ $14 >> 2 ] | 0 ; $16 = ( ( ( $0 ) ) + 4 | 0 ) ; $17 = HEAP32 [ $16 >> 2 ] | 0 ; $18 = ( ( ( $0 ) ) + 20 | 0 ) ; $19 = HEAP32 [ $18 >> 2 ] | 0 ; $20 = ( ( ( $0 ) ) + 28 | 0 ) ; $21 = HEAP32 [ $20 >> 2 ] | 0 ; $22 = ( ( $12 ) - ( $15 ) ) | 0 ; $23 = ( ( $22 ) + ( $17 ) ) | 0 ; $24 = ( ( $23 ) + ( $19 ) ) | 0 ; $25 = ( ( $24 ) - ( $21 ) ) | 0 ; $$0 = $25 ; } return ( $$0 | 0 ) ; } function ___ftello ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $phitmp = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( ( ( $0 ) ) + 76 | 0 ) ; $2 = HEAP32 [ $1 >> 2 ] | 0 ; $3 = ( $2 | 0 ) > ( - 1 ) ; if ( $3 ) { $5 = ( ___lockfile ( $0 ) | 0 ) ; $phitmp = ( $5 | 0 ) == ( 0 ) ; $6 = ( ___ftello_unlocked ( $0 ) | 0 ) ; if ( $phitmp ) { $7 = $6 ; } else { $7 = $6 ; } } else { $4 = ( ___ftello_unlocked ( $0 ) | 0 ) ; $7 = $4 ; } return ( $7 | 0 ) ; } function _ftell ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( ___ftello ( $0 ) | 0 ) ; return ( $1 | 0 ) ; } function _fgetpos ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $$0 = 0 , $2 = 0 , $3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $2 = ( ___ftello ( $0 ) | 0 ) ; $3 = ( $2 | 0 ) < ( 0 ) ; if ( $3 ) { $$0 = - 1 ; } else { HEAP32 [ $1 >> 2 ] = $2 ; $$0 = 0 ; } return ( $$0 | 0 ) ; } function _fileno ( $0 ) { $0 = $0 | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , $4 = 0 , $5 = 0 , $6 = 0 , $phitmp = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; $1 = ( ( ( $0 ) ) + 76 | 0 ) ; $2 = HEAP32 [ $1 >> 2 ] | 0 ; $3 = ( $2 | 0 ) > ( - 1 ) ; if ( $3 ) { $4 = ( ___lockfile ( $0 ) | 0 ) ; $phitmp = ( $4 | 0 ) == ( 0 ) ; if ( ! ( $phitmp ) ) { } } $5 = ( ( ( $0 ) ) + 60 | 0 ) ; $6 = HEAP32 [ $5 >> 2 ] | 0 ; return ( $6 | 0 ) ; } function _utimensat ( $0 , $1 , $2 , $3 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; $2 = $2 | 0 ; $3 = $3 | 0 ; var $4 = 0 , $5 = 0 , $6 = 0 , $7 = 0 , $vararg_buffer = 0 , $vararg_ptr1 = 0 , $vararg_ptr2 = 0 , $vararg_ptr3 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $vararg_buffer = sp ; $4 = $1 ; $5 = $2 ; HEAP32 [ $vararg_buffer >> 2 ] = $0 ; $vararg_ptr1 = ( ( ( $vararg_buffer ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr1 >> 2 ] = $4 ; $vararg_ptr2 = ( ( ( $vararg_buffer ) ) + 8 | 0 ) ; HEAP32 [ $vararg_ptr2 >> 2 ] = $5 ; $vararg_ptr3 = ( ( ( $vararg_buffer ) ) + 12 | 0 ) ; HEAP32 [ $vararg_ptr3 >> 2 ] = $3 ; $6 = ( ___syscall320 ( 320 , ( $vararg_buffer | 0 ) ) | 0 ) ; $7 = ( ___syscall_ret ( $6 ) | 0 ) ; STACKTOP = sp ; return ( $7 | 0 ) ; } function _chmod ( $0 , $1 ) { $0 = $0 | 0 ; $1 = $1 | 0 ; var $2 = 0 , $3 = 0 , $4 = 0 , $vararg_buffer = 0 , $vararg_ptr1 = 0 , label = 0 , sp = 0 ; sp = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abortStackOverflow ( 16 | 0 ) ; $vararg_buffer = sp ; $2 = $0 ; HEAP32 [ $vararg_buffer >> 2 ] = $2 ; $vararg_ptr1 = ( ( ( $vararg_buffer ) ) + 4 | 0 ) ; HEAP32 [ $vararg_ptr1 >> 2 ] = $1 ; $3 = ( ___syscall15 ( 15 , ( $vararg_buffer | 0 ) ) | 0 ) ; $4 = ( ___syscall_ret ( $3 ) | 0 ) ; STACKTOP = sp ; return ( $4 | 0 ) ; } function runPostSets ( ) { } function ___muldsi3 ( $a , $b ) { $a = $a | 0 ; $b = $b | 0 ; var $1 = 0 , $2 = 0 , $3 = 0 , $6 = 0 , $8 = 0 , $11 = 0 , $12 = 0 ; $1 = $a & 65535 ; $2 = $b & 65535 ; $3 = Math_imul ( $2 , $1 ) | 0 ; $6 = $a >>> 16 ; $8 = ( $3 >>> 16 ) + ( Math_imul ( $2 , $6 ) | 0 ) | 0 ; $11 = $b >>> 16 ; $12 = Math_imul ( $11 , $1 ) | 0 ; return ( tempRet0 = ( ( $8 >>> 16 ) + ( Math_imul ( $11 , $6 ) | 0 ) | 0 ) + ( ( ( $8 & 65535 ) + $12 | 0 ) >>> 16 ) | 0 , 0 | ( $8 + $12 << 16 | $3 & 65535 ) ) | 0 ; } function ___muldi3 ( $a$0 , $a$1 , $b$0 , $b$1 ) { $a$0 = $a$0 | 0 ; $a$1 = $a$1 | 0 ; $b$0 = $b$0 | 0 ; $b$1 = $b$1 | 0 ; var $x_sroa_0_0_extract_trunc = 0 , $y_sroa_0_0_extract_trunc = 0 , $1$0 = 0 , $1$1 = 0 , $2 = 0 ; $x_sroa_0_0_extract_trunc = $a$0 ; $y_sroa_0_0_extract_trunc = $b$0 ; $1$0 = ___muldsi3 ( $x_sroa_0_0_extract_trunc , $y_sroa_0_0_extract_trunc ) | 0 ; $1$1 = tempRet0 ; $2 = Math_imul ( $a$1 , $y_sroa_0_0_extract_trunc ) | 0 ; return ( tempRet0 = ( ( Math_imul ( $b$1 , $x_sroa_0_0_extract_trunc ) | 0 ) + $2 | 0 ) + $1$1 | $1$1 & 0 , 0 | $1$0 & - 1 ) | 0 ; } function _i64Add ( a , b , c , d ) { /*       x = a + b*2^32       y = c + d*2^32       result = l + h*2^32     */ a = a | 0 ; b = b | 0 ; c = c | 0 ; d = d | 0 ; var l = 0 , h = 0 ; l = ( a + c ) >>> 0 ; h = ( b + d + ( ( ( l >>> 0 ) < ( a >>> 0 ) ) | 0 ) ) >>> 0 ; // Add carry from low word to high word on overflow. return ( ( tempRet0 = h , l | 0 ) | 0 ) ; } function _i64Subtract ( a , b , c , d ) { a = a | 0 ; b = b | 0 ; c = c | 0 ; d = d | 0 ; var l = 0 , h = 0 ; l = ( a - c ) >>> 0 ; h = ( b - d ) >>> 0 ; h = ( b - d - ( ( ( c >>> 0 ) > ( a >>> 0 ) ) | 0 ) ) >>> 0 ; // Borrow one from high word to low word on underflow. return ( ( tempRet0 = h , l | 0 ) | 0 ) ; } function _llvm_cttz_i32 ( x ) { x = x | 0 ; var ret = 0 ; ret = ( ( HEAP8 [ ( ( ( cttz_i8 ) + ( x & 0xff ) ) >> 0 ) ] ) | 0 ) ; if ( ( ret | 0 ) < 8 ) return ret | 0 ; ret = ( ( HEAP8 [ ( ( ( cttz_i8 ) + ( ( x >> 8 ) & 0xff ) ) >> 0 ) ] ) | 0 ) ; if ( ( ret | 0 ) < 8 ) return ( ret + 8 ) | 0 ; ret = ( ( HEAP8 [ ( ( ( cttz_i8 ) + ( ( x >> 16 ) & 0xff ) ) >> 0 ) ] ) | 0 ) ; if ( ( ret | 0 ) < 8 ) return ( ret + 16 ) | 0 ; return ( ( ( HEAP8 [ ( ( ( cttz_i8 ) + ( x >>> 24 ) ) >> 0 ) ] ) | 0 ) + 24 ) | 0 ; } function ___udivmoddi4 ( $a$0 , $a$1 , $b$0 , $b$1 , $rem ) { $a$0 = $a$0 | 0 ; $a$1 = $a$1 | 0 ; $b$0 = $b$0 | 0 ; $b$1 = $b$1 | 0 ; $rem = $rem | 0 ; var $n_sroa_0_0_extract_trunc = 0 , $n_sroa_1_4_extract_shift$0 = 0 , $n_sroa_1_4_extract_trunc = 0 , $d_sroa_0_0_extract_trunc = 0 , $d_sroa_1_4_extract_shift$0 = 0 , $d_sroa_1_4_extract_trunc = 0 , $4 = 0 , $17 = 0 , $37 = 0 , $49 = 0 , $51 = 0 , $57 = 0 , $58 = 0 , $66 = 0 , $78 = 0 , $86 = 0 , $88 = 0 , $89 = 0 , $91 = 0 , $92 = 0 , $95 = 0 , $105 = 0 , $117 = 0 , $119 = 0 , $125 = 0 , $126 = 0 , $130 = 0 , $q_sroa_1_1_ph = 0 , $q_sroa_0_1_ph = 0 , $r_sroa_1_1_ph = 0 , $r_sroa_0_1_ph = 0 , $sr_1_ph = 0 , $d_sroa_0_0_insert_insert99$0 = 0 , $d_sroa_0_0_insert_insert99$1 = 0 , $137$0 = 0 , $137$1 = 0 , $carry_0203 = 0 , $sr_1202 = 0 , $r_sroa_0_1201 = 0 , $r_sroa_1_1200 = 0 , $q_sroa_0_1199 = 0 , $q_sroa_1_1198 = 0 , $147 = 0 , $149 = 0 , $r_sroa_0_0_insert_insert42$0 = 0 , $r_sroa_0_0_insert_insert42$1 = 0 , $150$1 = 0 , $151$0 = 0 , $152 = 0 , $154$0 = 0 , $r_sroa_0_0_extract_trunc = 0 , $r_sroa_1_4_extract_trunc = 0 , $155 = 0 , $carry_0_lcssa$0 = 0 , $carry_0_lcssa$1 = 0 , $r_sroa_0_1_lcssa = 0 , $r_sroa_1_1_lcssa = 0 , $q_sroa_0_1_lcssa = 0 , $q_sroa_1_1_lcssa = 0 , $q_sroa_0_0_insert_ext75$0 = 0 , $q_sroa_0_0_insert_ext75$1 = 0 , $q_sroa_0_0_insert_insert77$1 = 0 , $_0$0 = 0 , $_0$1 = 0 ; $n_sroa_0_0_extract_trunc = $a$0 ; $n_sroa_1_4_extract_shift$0 = $a$1 ; $n_sroa_1_4_extract_trunc = $n_sroa_1_4_extract_shift$0 ; $d_sroa_0_0_extract_trunc = $b$0 ; $d_sroa_1_4_extract_shift$0 = $b$1 ; $d_sroa_1_4_extract_trunc = $d_sroa_1_4_extract_shift$0 ; if ( ( $n_sroa_1_4_extract_trunc | 0 ) == 0 ) { $4 = ( $rem | 0 ) != 0 ; if ( ( $d_sroa_1_4_extract_trunc | 0 ) == 0 ) { if ( $4 ) { HEAP32 [ $rem >> 2 ] = ( $n_sroa_0_0_extract_trunc >>> 0 ) % ( $d_sroa_0_0_extract_trunc >>> 0 ) ; HEAP32 [ $rem + 4 >> 2 ] = 0 ; } $_0$1 = 0 ; $_0$0 = ( $n_sroa_0_0_extract_trunc >>> 0 ) / ( $d_sroa_0_0_extract_trunc >>> 0 ) >>> 0 ; return ( tempRet0 = $_0$1 , $_0$0 ) | 0 ; } else { if ( ! $4 ) { $_0$1 = 0 ; $_0$0 = 0 ; return ( tempRet0 = $_0$1 , $_0$0 ) | 0 ; } HEAP32 [ $rem >> 2 ] = $a$0 & - 1 ; HEAP32 [ $rem + 4 >> 2 ] = $a$1 & 0 ; $_0$1 = 0 ; $_0$0 = 0 ; return ( tempRet0 = $_0$1 , $_0$0 ) | 0 ; } } $17 = ( $d_sroa_1_4_extract_trunc | 0 ) == 0 ; do { if ( ( $d_sroa_0_0_extract_trunc | 0 ) == 0 ) { if ( $17 ) { if ( ( $rem | 0 ) != 0 ) { HEAP32 [ $rem >> 2 ] = ( $n_sroa_1_4_extract_trunc >>> 0 ) % ( $d_sroa_0_0_extract_trunc >>> 0 ) ; HEAP32 [ $rem + 4 >> 2 ] = 0 ; } $_0$1 = 0 ; $_0$0 = ( $n_sroa_1_4_extract_trunc >>> 0 ) / ( $d_sroa_0_0_extract_trunc >>> 0 ) >>> 0 ; return ( tempRet0 = $_0$1 , $_0$0 ) | 0 ; } if ( ( $n_sroa_0_0_extract_trunc | 0 ) == 0 ) { if ( ( $rem | 0 ) != 0 ) { HEAP32 [ $rem >> 2 ] = 0 ; HEAP32 [ $rem + 4 >> 2 ] = ( $n_sroa_1_4_extract_trunc >>> 0 ) % ( $d_sroa_1_4_extract_trunc >>> 0 ) ; } $_0$1 = 0 ; $_0$0 = ( $n_sroa_1_4_extract_trunc >>> 0 ) / ( $d_sroa_1_4_extract_trunc >>> 0 ) >>> 0 ; return ( tempRet0 = $_0$1 , $_0$0 ) | 0 ; } $37 = $d_sroa_1_4_extract_trunc - 1 | 0 ; if ( ( $37 & $d_sroa_1_4_extract_trunc | 0 ) == 0 ) { if ( ( $rem | 0 ) != 0 ) { HEAP32 [ $rem >> 2 ] = 0 | $a$0 & - 1 ; HEAP32 [ $rem + 4 >> 2 ] = $37 & $n_sroa_1_4_extract_trunc | $a$1 & 0 ; } $_0$1 = 0 ; $_0$0 = $n_sroa_1_4_extract_trunc >>> ( ( _llvm_cttz_i32 ( $d_sroa_1_4_extract_trunc | 0 ) | 0 ) >>> 0 ) ; return ( tempRet0 = $_0$1 , $_0$0 ) | 0 ; } $49 = Math_clz32 ( $d_sroa_1_4_extract_trunc | 0 ) | 0 ; $51 = $49 - ( Math_clz32 ( $n_sroa_1_4_extract_trunc | 0 ) | 0 ) | 0 ; if ( $51 >>> 0 <= 30 ) { $57 = $51 + 1 | 0 ; $58 = 31 - $51 | 0 ; $sr_1_ph = $57 ; $r_sroa_0_1_ph = $n_sroa_1_4_extract_trunc << $58 | $n_sroa_0_0_extract_trunc >>> ( $57 >>> 0 ) ; $r_sroa_1_1_ph = $n_sroa_1_4_extract_trunc >>> ( $57 >>> 0 ) ; $q_sroa_0_1_ph = 0 ; $q_sroa_1_1_ph = $n_sroa_0_0_extract_trunc << $58 ; break ; } if ( ( $rem | 0 ) == 0 ) { $_0$1 = 0 ; $_0$0 = 0 ; return ( tempRet0 = $_0$1 , $_0$0 ) | 0 ; } HEAP32 [ $rem >> 2 ] = 0 | $a$0 & - 1 ; HEAP32 [ $rem + 4 >> 2 ] = $n_sroa_1_4_extract_shift$0 | $a$1 & 0 ; $_0$1 = 0 ; $_0$0 = 0 ; return ( tempRet0 = $_0$1 , $_0$0 ) | 0 ; } else { if ( ! $17 ) { $117 = Math_clz32 ( $d_sroa_1_4_extract_trunc | 0 ) | 0 ; $119 = $117 - ( Math_clz32 ( $n_sroa_1_4_extract_trunc | 0 ) | 0 ) | 0 ; if ( $119 >>> 0 <= 31 ) { $125 = $119 + 1 | 0 ; $126 = 31 - $119 | 0 ; $130 = $119 - 31 >> 31 ; $sr_1_ph = $125 ; $r_sroa_0_1_ph = $n_sroa_0_0_extract_trunc >>> ( $125 >>> 0 ) & $130 | $n_sroa_1_4_extract_trunc << $126 ; $r_sroa_1_1_ph = $n_sroa_1_4_extract_trunc >>> ( $125 >>> 0 ) & $130 ; $q_sroa_0_1_ph = 0 ; $q_sroa_1_1_ph = $n_sroa_0_0_extract_trunc << $126 ; break ; } if ( ( $rem | 0 ) == 0 ) { $_0$1 = 0 ; $_0$0 = 0 ; return ( tempRet0 = $_0$1 , $_0$0 ) | 0 ; } HEAP32 [ $rem >> 2 ] = 0 | $a$0 & - 1 ; HEAP32 [ $rem + 4 >> 2 ] = $n_sroa_1_4_extract_shift$0 | $a$1 & 0 ; $_0$1 = 0 ; $_0$0 = 0 ; return ( tempRet0 = $_0$1 , $_0$0 ) | 0 ; } $66 = $d_sroa_0_0_extract_trunc - 1 | 0 ; if ( ( $66 & $d_sroa_0_0_extract_trunc | 0 ) != 0 ) { $86 = ( Math_clz32 ( $d_sroa_0_0_extract_trunc | 0 ) | 0 ) + 33 | 0 ; $88 = $86 - ( Math_clz32 ( $n_sroa_1_4_extract_trunc | 0 ) | 0 ) | 0 ; $89 = 64 - $88 | 0 ; $91 = 32 - $88 | 0 ; $92 = $91 >> 31 ; $95 = $88 - 32 | 0 ; $105 = $95 >> 31 ; $sr_1_ph = $88 ; $r_sroa_0_1_ph = $91 - 1 >> 31 & $n_sroa_1_4_extract_trunc >>> ( $95 >>> 0 ) | ( $n_sroa_1_4_extract_trunc << $91 | $n_sroa_0_0_extract_trunc >>> ( $88 >>> 0 ) ) & $105 ; $r_sroa_1_1_ph = $105 & $n_sroa_1_4_extract_trunc >>> ( $88 >>> 0 ) ; $q_sroa_0_1_ph = $n_sroa_0_0_extract_trunc << $89 & $92 ; $q_sroa_1_1_ph = ( $n_sroa_1_4_extract_trunc << $89 | $n_sroa_0_0_extract_trunc >>> ( $95 >>> 0 ) ) & $92 | $n_sroa_0_0_extract_trunc << $91 & $88 - 33 >> 31 ; break ; } if ( ( $rem | 0 ) != 0 ) { HEAP32 [ $rem >> 2 ] = $66 & $n_sroa_0_0_extract_trunc ; HEAP32 [ $rem + 4 >> 2 ] = 0 ; } if ( ( $d_sroa_0_0_extract_trunc | 0 ) == 1 ) { $_0$1 = $n_sroa_1_4_extract_shift$0 | $a$1 & 0 ; $_0$0 = 0 | $a$0 & - 1 ; return ( tempRet0 = $_0$1 , $_0$0 ) | 0 ; } else { $78 = _llvm_cttz_i32 ( $d_sroa_0_0_extract_trunc | 0 ) | 0 ; $_0$1 = 0 | $n_sroa_1_4_extract_trunc >>> ( $78 >>> 0 ) ; $_0$0 = $n_sroa_1_4_extract_trunc << 32 - $78 | $n_sroa_0_0_extract_trunc >>> ( $78 >>> 0 ) | 0 ; return ( tempRet0 = $_0$1 , $_0$0 ) | 0 ; } } } while ( 0 ) ; if ( ( $sr_1_ph | 0 ) == 0 ) { $q_sroa_1_1_lcssa = $q_sroa_1_1_ph ; $q_sroa_0_1_lcssa = $q_sroa_0_1_ph ; $r_sroa_1_1_lcssa = $r_sroa_1_1_ph ; $r_sroa_0_1_lcssa = $r_sroa_0_1_ph ; $carry_0_lcssa$1 = 0 ; $carry_0_lcssa$0 = 0 ; } else { $d_sroa_0_0_insert_insert99$0 = 0 | $b$0 & - 1 ; $d_sroa_0_0_insert_insert99$1 = $d_sroa_1_4_extract_shift$0 | $b$1 & 0 ; $137$0 = _i64Add ( $d_sroa_0_0_insert_insert99$0 | 0 , $d_sroa_0_0_insert_insert99$1 | 0 , - 1 , - 1 ) | 0 ; $137$1 = tempRet0 ; $q_sroa_1_1198 = $q_sroa_1_1_ph ; $q_sroa_0_1199 = $q_sroa_0_1_ph ; $r_sroa_1_1200 = $r_sroa_1_1_ph ; $r_sroa_0_1201 = $r_sroa_0_1_ph ; $sr_1202 = $sr_1_ph ; $carry_0203 = 0 ; while ( 1 ) { $147 = $q_sroa_0_1199 >>> 31 | $q_sroa_1_1198 << 1 ; $149 = $carry_0203 | $q_sroa_0_1199 << 1 ; $r_sroa_0_0_insert_insert42$0 = 0 | ( $r_sroa_0_1201 << 1 | $q_sroa_1_1198 >>> 31 ) ; $r_sroa_0_0_insert_insert42$1 = $r_sroa_0_1201 >>> 31 | $r_sroa_1_1200 << 1 | 0 ; _i64Subtract ( $137$0 | 0 , $137$1 | 0 , $r_sroa_0_0_insert_insert42$0 | 0 , $r_sroa_0_0_insert_insert42$1 | 0 ) | 0 ; $150$1 = tempRet0 ; $151$0 = $150$1 >> 31 | ( ( $150$1 | 0 ) < 0 ? - 1 : 0 ) << 1 ; $152 = $151$0 & 1 ; $154$0 = _i64Subtract ( $r_sroa_0_0_insert_insert42$0 | 0 , $r_sroa_0_0_insert_insert42$1 | 0 , $151$0 & $d_sroa_0_0_insert_insert99$0 | 0 , ( ( ( $150$1 | 0 ) < 0 ? - 1 : 0 ) >> 31 | ( ( $150$1 | 0 ) < 0 ? - 1 : 0 ) << 1 ) & $d_sroa_0_0_insert_insert99$1 | 0 ) | 0 ; $r_sroa_0_0_extract_trunc = $154$0 ; $r_sroa_1_4_extract_trunc = tempRet0 ; $155 = $sr_1202 - 1 | 0 ; if ( ( $155 | 0 ) == 0 ) { break ; } else { $q_sroa_1_1198 = $147 ; $q_sroa_0_1199 = $149 ; $r_sroa_1_1200 = $r_sroa_1_4_extract_trunc ; $r_sroa_0_1201 = $r_sroa_0_0_extract_trunc ; $sr_1202 = $155 ; $carry_0203 = $152 ; } } $q_sroa_1_1_lcssa = $147 ; $q_sroa_0_1_lcssa = $149 ; $r_sroa_1_1_lcssa = $r_sroa_1_4_extract_trunc ; $r_sroa_0_1_lcssa = $r_sroa_0_0_extract_trunc ; $carry_0_lcssa$1 = 0 ; $carry_0_lcssa$0 = $152 ; } $q_sroa_0_0_insert_ext75$0 = $q_sroa_0_1_lcssa ; $q_sroa_0_0_insert_ext75$1 = 0 ; $q_sroa_0_0_insert_insert77$1 = $q_sroa_1_1_lcssa | $q_sroa_0_0_insert_ext75$1 ; if ( ( $rem | 0 ) != 0 ) { HEAP32 [ $rem >> 2 ] = 0 | $r_sroa_0_1_lcssa ; HEAP32 [ $rem + 4 >> 2 ] = $r_sroa_1_1_lcssa | 0 ; } $_0$1 = ( 0 | $q_sroa_0_0_insert_ext75$0 ) >>> 31 | $q_sroa_0_0_insert_insert77$1 << 1 | ( $q_sroa_0_0_insert_ext75$1 << 1 | $q_sroa_0_0_insert_ext75$0 >>> 31 ) & 0 | $carry_0_lcssa$1 ; $_0$0 = ( $q_sroa_0_0_insert_ext75$0 << 1 | 0 >>> 31 ) & - 2 | $carry_0_lcssa$0 ; return ( tempRet0 = $_0$1 , $_0$0 ) | 0 ; } function ___udivdi3 ( $a$0 , $a$1 , $b$0 , $b$1 ) { $a$0 = $a$0 | 0 ; $a$1 = $a$1 | 0 ; $b$0 = $b$0 | 0 ; $b$1 = $b$1 | 0 ; var $1$0 = 0 ; $1$0 = ___udivmoddi4 ( $a$0 , $a$1 , $b$0 , $b$1 , 0 ) | 0 ; return $1$0 | 0 ; } function ___uremdi3 ( $a$0 , $a$1 , $b$0 , $b$1 ) { $a$0 = $a$0 | 0 ; $a$1 = $a$1 | 0 ; $b$0 = $b$0 | 0 ; $b$1 = $b$1 | 0 ; var $rem = 0 , __stackBase__ = 0 ; __stackBase__ = STACKTOP ; STACKTOP = STACKTOP + 16 | 0 ; $rem = __stackBase__ | 0 ; ___udivmoddi4 ( $a$0 , $a$1 , $b$0 , $b$1 , $rem ) | 0 ; STACKTOP = __stackBase__ ; return ( tempRet0 = HEAP32 [ $rem + 4 >> 2 ] | 0 , HEAP32 [ $rem >> 2 ] | 0 ) | 0 ; } function _bitshift64Lshr ( low , high , bits ) { low = low | 0 ; high = high | 0 ; bits = bits | 0 ; var ander = 0 ; if ( ( bits | 0 ) < 32 ) { ander = ( ( 1 << bits ) - 1 ) | 0 ; tempRet0 = high >>> bits ; return ( low >>> bits ) | ( ( high & ander ) << ( 32 - bits ) ) ; } tempRet0 = 0 ; return ( high >>> ( bits - 32 ) ) | 0 ; } function _bitshift64Shl ( low , high , bits ) { low = low | 0 ; high = high | 0 ; bits = bits | 0 ; var ander = 0 ; if ( ( bits | 0 ) < 32 ) { ander = ( ( 1 << bits ) - 1 ) | 0 ; tempRet0 = ( high << bits ) | ( ( low & ( ander << ( 32 - bits ) ) ) >>> ( 32 - bits ) ) ; return low << bits ; } tempRet0 = low << ( bits - 32 ) ; return 0 ; } function _saveSetjmp ( env , label , table , size ) { // Not particularly fast: slow table lookup of setjmpId to label. But setjmp // prevents relooping anyhow, so slowness is to be expected. And typical case // is 1 setjmp per invocation, or less. env = env | 0 ; label = label | 0 ; table = table | 0 ; size = size | 0 ; var i = 0 ; setjmpId = ( setjmpId + 1 ) | 0 ; HEAP32 [ ( ( env ) >> 2 ) ] = setjmpId ; while ( ( i | 0 ) < ( size | 0 ) ) { if ( ( ( HEAP32 [ ( ( ( table ) + ( ( i << 3 ) ) ) >> 2 ) ] ) | 0 ) == 0 ) { HEAP32 [ ( ( ( table ) + ( ( i << 3 ) ) ) >> 2 ) ] = setjmpId ; HEAP32 [ ( ( ( table ) + ( ( i << 3 ) + 4 ) ) >> 2 ) ] = label ; // prepare next slot HEAP32 [ ( ( ( table ) + ( ( i << 3 ) + 8 ) ) >> 2 ) ] = 0 ; tempRet0 = size ; return table | 0 ; } i = i + 1 | 0 ; } // grow the table size = ( size * 2 ) | 0 ; table = _realloc ( table | 0 , 8 * ( size + 1 | 0 ) | 0 ) | 0 ; table = _saveSetjmp ( env | 0 , label | 0 , table | 0 , size | 0 ) | 0 ; tempRet0 = size ; return table | 0 ; } function _testSetjmp ( id , table , size ) { id = id | 0 ; table = table | 0 ; size = size | 0 ; var i = 0 , curr = 0 ; while ( ( i | 0 ) < ( size | 0 ) ) { curr = ( ( HEAP32 [ ( ( ( table ) + ( ( i << 3 ) ) ) >> 2 ) ] ) | 0 ) ; if ( ( curr | 0 ) == 0 ) break ; if ( ( curr | 0 ) == ( id | 0 ) ) { return ( ( HEAP32 [ ( ( ( table ) + ( ( i << 3 ) + 4 ) ) >> 2 ) ] ) | 0 ) ; } i = i + 1 | 0 ; } return 0 ; } function _llvm_bswap_i32 ( x ) { x = x | 0 ; return ( ( ( x & 0xff ) << 24 ) | ( ( ( x >> 8 ) & 0xff ) << 16 ) | ( ( ( x >> 16 ) & 0xff ) << 8 ) | ( x >>> 24 ) ) | 0 ; } function _memcpy ( dest , src , num ) { dest = dest | 0 ; src = src | 0 ; num = num | 0 ; var ret = 0 ; var aligned_dest_end = 0 ; var block_aligned_dest_end = 0 ; var dest_end = 0 ; // Test against a benchmarked cutoff limit for when HEAPU8.set() becomes faster to use. if ( ( num | 0 ) >= 8192 ) { return _emscripten_memcpy_big ( dest | 0 , src | 0 , num | 0 ) | 0 ; } ret = dest | 0 ; dest_end = ( dest + num ) | 0 ; if ( ( dest & 3 ) == ( src & 3 ) ) { // The initial unaligned < 4-byte front. while ( dest & 3 ) { if ( ( num | 0 ) == 0 ) return ret | 0 ; HEAP8 [ ( ( dest ) >> 0 ) ] = ( ( HEAP8 [ ( ( src ) >> 0 ) ] ) | 0 ) ; dest = ( dest + 1 ) | 0 ; src = ( src + 1 ) | 0 ; num = ( num - 1 ) | 0 ; } aligned_dest_end = ( dest_end & - 4 ) | 0 ; block_aligned_dest_end = ( aligned_dest_end - 64 ) | 0 ; while ( ( dest | 0 ) <= ( block_aligned_dest_end | 0 ) ) { HEAP32 [ ( ( dest ) >> 2 ) ] = ( ( HEAP32 [ ( ( src ) >> 2 ) ] ) | 0 ) ; HEAP32 [ ( ( ( dest ) + ( 4 ) ) >> 2 ) ] = ( ( HEAP32 [ ( ( ( src ) + ( 4 ) ) >> 2 ) ] ) | 0 ) ; HEAP32 [ ( ( ( dest ) + ( 8 ) ) >> 2 ) ] = ( ( HEAP32 [ ( ( ( src ) + ( 8 ) ) >> 2 ) ] ) | 0 ) ; HEAP32 [ ( ( ( dest ) + ( 12 ) ) >> 2 ) ] = ( ( HEAP32 [ ( ( ( src ) + ( 12 ) ) >> 2 ) ] ) | 0 ) ; HEAP32 [ ( ( ( dest ) + ( 16 ) ) >> 2 ) ] = ( ( HEAP32 [ ( ( ( src ) + ( 16 ) ) >> 2 ) ] ) | 0 ) ; HEAP32 [ ( ( ( dest ) + ( 20 ) ) >> 2 ) ] = ( ( HEAP32 [ ( ( ( src ) + ( 20 ) ) >> 2 ) ] ) | 0 ) ; HEAP32 [ ( ( ( dest ) + ( 24 ) ) >> 2 ) ] = ( ( HEAP32 [ ( ( ( src ) + ( 24 ) ) >> 2 ) ] ) | 0 ) ; HEAP32 [ ( ( ( dest ) + ( 28 ) ) >> 2 ) ] = ( ( HEAP32 [ ( ( ( src ) + ( 28 ) ) >> 2 ) ] ) | 0 ) ; HEAP32 [ ( ( ( dest ) + ( 32 ) ) >> 2 ) ] = ( ( HEAP32 [ ( ( ( src ) + ( 32 ) ) >> 2 ) ] ) | 0 ) ; HEAP32 [ ( ( ( dest ) + ( 36 ) ) >> 2 ) ] = ( ( HEAP32 [ ( ( ( src ) + ( 36 ) ) >> 2 ) ] ) | 0 ) ; HEAP32 [ ( ( ( dest ) + ( 40 ) ) >> 2 ) ] = ( ( HEAP32 [ ( ( ( src ) + ( 40 ) ) >> 2 ) ] ) | 0 ) ; HEAP32 [ ( ( ( dest ) + ( 44 ) ) >> 2 ) ] = ( ( HEAP32 [ ( ( ( src ) + ( 44 ) ) >> 2 ) ] ) | 0 ) ; HEAP32 [ ( ( ( dest ) + ( 48 ) ) >> 2 ) ] = ( ( HEAP32 [ ( ( ( src ) + ( 48 ) ) >> 2 ) ] ) | 0 ) ; HEAP32 [ ( ( ( dest ) + ( 52 ) ) >> 2 ) ] = ( ( HEAP32 [ ( ( ( src ) + ( 52 ) ) >> 2 ) ] ) | 0 ) ; HEAP32 [ ( ( ( dest ) + ( 56 ) ) >> 2 ) ] = ( ( HEAP32 [ ( ( ( src ) + ( 56 ) ) >> 2 ) ] ) | 0 ) ; HEAP32 [ ( ( ( dest ) + ( 60 ) ) >> 2 ) ] = ( ( HEAP32 [ ( ( ( src ) + ( 60 ) ) >> 2 ) ] ) | 0 ) ; dest = ( dest + 64 ) | 0 ; src = ( src + 64 ) | 0 ; } while ( ( dest | 0 ) < ( aligned_dest_end | 0 ) ) { HEAP32 [ ( ( dest ) >> 2 ) ] = ( ( HEAP32 [ ( ( src ) >> 2 ) ] ) | 0 ) ; dest = ( dest + 4 ) | 0 ; src = ( src + 4 ) | 0 ; } } else { // In the unaligned copy case, unroll a bit as well. aligned_dest_end = ( dest_end - 4 ) | 0 ; while ( ( dest | 0 ) < ( aligned_dest_end | 0 ) ) { HEAP8 [ ( ( dest ) >> 0 ) ] = ( ( HEAP8 [ ( ( src ) >> 0 ) ] ) | 0 ) ; HEAP8 [ ( ( ( dest ) + ( 1 ) ) >> 0 ) ] = ( ( HEAP8 [ ( ( ( src ) + ( 1 ) ) >> 0 ) ] ) | 0 ) ; HEAP8 [ ( ( ( dest ) + ( 2 ) ) >> 0 ) ] = ( ( HEAP8 [ ( ( ( src ) + ( 2 ) ) >> 0 ) ] ) | 0 ) ; HEAP8 [ ( ( ( dest ) + ( 3 ) ) >> 0 ) ] = ( ( HEAP8 [ ( ( ( src ) + ( 3 ) ) >> 0 ) ] ) | 0 ) ; dest = ( dest + 4 ) | 0 ; src = ( src + 4 ) | 0 ; } } // The remaining unaligned < 4 byte tail. while ( ( dest | 0 ) < ( dest_end | 0 ) ) { HEAP8 [ ( ( dest ) >> 0 ) ] = ( ( HEAP8 [ ( ( src ) >> 0 ) ] ) | 0 ) ; dest = ( dest + 1 ) | 0 ; src = ( src + 1 ) | 0 ; } return ret | 0 ; } function _memset ( ptr , value , num ) { ptr = ptr | 0 ; value = value | 0 ; num = num | 0 ; var end = 0 , aligned_end = 0 , block_aligned_end = 0 , value4 = 0 ; end = ( ptr + num ) | 0 ; value = value & 0xff ; if ( ( num | 0 ) >= 67 /* 64 bytes for an unrolled loop + 3 bytes for unaligned head*/ ) { while ( ( ptr & 3 ) != 0 ) { HEAP8 [ ( ( ptr ) >> 0 ) ] = value ; ptr = ( ptr + 1 ) | 0 ; } aligned_end = ( end & - 4 ) | 0 ; block_aligned_end = ( aligned_end - 64 ) | 0 ; value4 = value | ( value << 8 ) | ( value << 16 ) | ( value << 24 ) ; while ( ( ptr | 0 ) <= ( block_aligned_end | 0 ) ) { HEAP32 [ ( ( ptr ) >> 2 ) ] = value4 ; HEAP32 [ ( ( ( ptr ) + ( 4 ) ) >> 2 ) ] = value4 ; HEAP32 [ ( ( ( ptr ) + ( 8 ) ) >> 2 ) ] = value4 ; HEAP32 [ ( ( ( ptr ) + ( 12 ) ) >> 2 ) ] = value4 ; HEAP32 [ ( ( ( ptr ) + ( 16 ) ) >> 2 ) ] = value4 ; HEAP32 [ ( ( ( ptr ) + ( 20 ) ) >> 2 ) ] = value4 ; HEAP32 [ ( ( ( ptr ) + ( 24 ) ) >> 2 ) ] = value4 ; HEAP32 [ ( ( ( ptr ) + ( 28 ) ) >> 2 ) ] = value4 ; HEAP32 [ ( ( ( ptr ) + ( 32 ) ) >> 2 ) ] = value4 ; HEAP32 [ ( ( ( ptr ) + ( 36 ) ) >> 2 ) ] = value4 ; HEAP32 [ ( ( ( ptr ) + ( 40 ) ) >> 2 ) ] = value4 ; HEAP32 [ ( ( ( ptr ) + ( 44 ) ) >> 2 ) ] = value4 ; HEAP32 [ ( ( ( ptr ) + ( 48 ) ) >> 2 ) ] = value4 ; HEAP32 [ ( ( ( ptr ) + ( 52 ) ) >> 2 ) ] = value4 ; HEAP32 [ ( ( ( ptr ) + ( 56 ) ) >> 2 ) ] = value4 ; HEAP32 [ ( ( ( ptr ) + ( 60 ) ) >> 2 ) ] = value4 ; ptr = ( ptr + 64 ) | 0 ; } while ( ( ptr | 0 ) < ( aligned_end | 0 ) ) { HEAP32 [ ( ( ptr ) >> 2 ) ] = value4 ; ptr = ( ptr + 4 ) | 0 ; } } // The remaining bytes. while ( ( ptr | 0 ) < ( end | 0 ) ) { HEAP8 [ ( ( ptr ) >> 0 ) ] = value ; ptr = ( ptr + 1 ) | 0 ; } return ( end - num ) | 0 ; } function _sbrk ( increment ) { increment = increment | 0 ; var oldDynamicTop = 0 ; var oldDynamicTopOnChange = 0 ; var newDynamicTop = 0 ; var totalMemory = 0 ; oldDynamicTop = HEAP32 [ DYNAMICTOP_PTR >> 2 ] | 0 ; newDynamicTop = oldDynamicTop + increment | 0 ; if ( ( ( increment | 0 ) > 0 & ( newDynamicTop | 0 ) < ( oldDynamicTop | 0 ) ) // Detect and fail if we would wrap around signed 32-bit int. | ( newDynamicTop | 0 ) < 0 ) { // Also underflow, sbrk() should be able to be used to subtract. abortOnCannotGrowMemory ( ) | 0 ; ___setErrNo ( 12 ) ; return - 1 ; } HEAP32 [ DYNAMICTOP_PTR >> 2 ] = newDynamicTop ; totalMemory = getTotalMemory ( ) | 0 ; if ( ( newDynamicTop | 0 ) > ( totalMemory | 0 ) ) { if ( ( enlargeMemory ( ) | 0 ) == 0 ) { HEAP32 [ DYNAMICTOP_PTR >> 2 ] = oldDynamicTop ; ___setErrNo ( 12 ) ; return - 1 ; } } return oldDynamicTop | 0 ; } function dynCall_ii ( index , a1 ) { index = index | 0 ; a1 = a1 | 0 ; return FUNCTION_TABLE_ii [ index & 127 ] ( a1 | 0 ) | 0 ; } function dynCall_iii ( index , a1 , a2 ) { index = index | 0 ; a1 = a1 | 0 ; a2 = a2 | 0 ; return FUNCTION_TABLE_iii [ index & 127 ] ( a1 | 0 , a2 | 0 ) | 0 ; } function dynCall_iiii ( index , a1 , a2 , a3 ) { index = index | 0 ; a1 = a1 | 0 ; a2 = a2 | 0 ; a3 = a3 | 0 ; return FUNCTION_TABLE_iiii [ index & 127 ] ( a1 | 0 , a2 | 0 , a3 | 0 ) | 0 ; } function dynCall_iiiii ( index , a1 , a2 , a3 , a4 ) { index = index | 0 ; a1 = a1 | 0 ; a2 = a2 | 0 ; a3 = a3 | 0 ; a4 = a4 | 0 ; return FUNCTION_TABLE_iiiii [ index & 127 ] ( a1 | 0 , a2 | 0 , a3 | 0 , a4 | 0 ) | 0 ; } function dynCall_v ( index ) { index = index | 0 ; FUNCTION_TABLE_v [ index & 127 ] ( ) ; } function dynCall_vi ( index , a1 ) { index = index | 0 ; a1 = a1 | 0 ; FUNCTION_TABLE_vi [ index & 127 ] ( a1 | 0 ) ; } function dynCall_vii ( index , a1 , a2 ) { index = index | 0 ; a1 = a1 | 0 ; a2 = a2 | 0 ; FUNCTION_TABLE_vii [ index & 127 ] ( a1 | 0 , a2 | 0 ) ; } function dynCall_viii ( index , a1 , a2 , a3 ) { index = index | 0 ; a1 = a1 | 0 ; a2 = a2 | 0 ; a3 = a3 | 0 ; FUNCTION_TABLE_viii [ index & 127 ] ( a1 | 0 , a2 | 0 , a3 | 0 ) ; } function dynCall_viiii ( index , a1 , a2 , a3 , a4 ) { index = index | 0 ; a1 = a1 | 0 ; a2 = a2 | 0 ; a3 = a3 | 0 ; a4 = a4 | 0 ; FUNCTION_TABLE_viiii [ index & 127 ] ( a1 | 0 , a2 | 0 , a3 | 0 , a4 | 0 ) ; } function dynCall_viiiii ( index , a1 , a2 , a3 , a4 , a5 ) { index = index | 0 ; a1 = a1 | 0 ; a2 = a2 | 0 ; a3 = a3 | 0 ; a4 = a4 | 0 ; a5 = a5 | 0 ; FUNCTION_TABLE_viiiii [ index & 63 ] ( a1 | 0 , a2 | 0 , a3 | 0 , a4 | 0 , a5 | 0 ) ; } function b0 ( p0 ) { p0 = p0 | 0 ; nullFunc_ii ( 0 ) ; return 0 ; } function b1 ( p0 , p1 ) { p0 = p0 | 0 ; p1 = p1 | 0 ; nullFunc_iii ( 1 ) ; return 0 ; } function b2 ( p0 , p1 , p2 ) { p0 = p0 | 0 ; p1 = p1 | 0 ; p2 = p2 | 0 ; nullFunc_iiii ( 2 ) ; return 0 ; } function b3 ( p0 , p1 , p2 , p3 ) { p0 = p0 | 0 ; p1 = p1 | 0 ; p2 = p2 | 0 ; p3 = p3 | 0 ; nullFunc_iiiii ( 3 ) ; return 0 ; } function b4 ( ) { ; nullFunc_v ( 4 ) ; } function b5 ( p0 ) { p0 = p0 | 0 ; nullFunc_vi ( 5 ) ; } function b6 ( p0 , p1 ) { p0 = p0 | 0 ; p1 = p1 | 0 ; nullFunc_vii ( 6 ) ; } function _emscripten_longjmp__wrapper ( p0 , p1 ) { p0 = p0 | 0 ; p1 = p1 | 0 ; _emscripten_longjmp ( p0 | 0 , p1 | 0 ) ; } function b7 ( p0 , p1 , p2 ) { p0 = p0 | 0 ; p1 = p1 | 0 ; p2 = p2 | 0 ; nullFunc_viii ( 7 ) ; } function b8 ( p0 , p1 , p2 , p3 ) { p0 = p0 | 0 ; p1 = p1 | 0 ; p2 = p2 | 0 ; p3 = p3 | 0 ; nullFunc_viiii ( 8 ) ; } function b9 ( p0 , p1 , p2 , p3 , p4 ) { p0 = p0 | 0 ; p1 = p1 | 0 ; p2 = p2 | 0 ; p3 = p3 | 0 ; p4 = p4 | 0 ; nullFunc_viiiii ( 9 ) ; } // EMSCRIPTEN_END_FUNCS var FUNCTION_TABLE_ii = [ b0 , b0 , b0 , b0 , b0 , b0 , ___stdio_close , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , _fclose , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , _opng_os_create_dir , b0 , b0 , b0 , b0 , b0 , _opng_os_unlink , b0 , b0 , b0 , b0 , b0 , _png_create_info_struct , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , _get_ushort_m , _get_ulong_m , _get_ushort_i , _get_ulong_i , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 , b0 ] ; var FUNCTION_TABLE_iii = [ b1 , _deflate_stored , _deflate_fast , _deflate_slow , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , _fopen , b1 , b1 , b1 , b1 , _strcpy , b1 , _opng_os_test_eq , _strcmp , b1 , _opng_os_test , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , _opng_os_copy_attr , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , _opng_fgetsize , _opng_validate_image , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , _png_malloc , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 , b1 ] ; var FUNCTION_TABLE_iiii = [ b2 , b2 , b2 , b2 , b2 , b2 , b2 , ___stdout_write , ___stdio_seek , ___stdio_write , _sn_write , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , _opng_path_make_backup , b2 , b2 , b2 , b2 , b2 , b2 , _opng_os_rename , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , _opng_reduce_image , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , _memcmp , _pngx_read_bmp , _pngx_read_gif , _pngx_read_jpeg , _pngx_read_pnm , _pngx_read_tiff , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , _png_zalloc , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , _zcalloc , b2 , b2 , b2 , b2 , b2 , ___stdio_read , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 , b2 ] ; var FUNCTION_TABLE_iiiii = [ b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , _opng_path_replace_ext , b3 , _opng_path_replace_dir , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , _opng_fseeko , b3 , b3 , b3 , b3 , b3 , _png_create_read_struct , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , _pngx_read_image , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , _png_create_write_struct , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , _fread , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , _bmp_fread_halfbytes , b3 , _bmp_fread_bytes , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 , b3 ] ; var FUNCTION_TABLE_v = [ b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , _opng_clear_image_info , b4 , b4 , _opng_destroy_image_info , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , _opng_init_iterations , _opng_iterate , _opng_finish_iterations , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , _opng_init_read_data , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , _opng_init_write_data , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 , b4 ] ; var FUNCTION_TABLE_vi = [ b5 , b5 , b5 , b5 , _DefaultError , _DefaultWarning , b5 , b5 , b5 , b5 , b5 , b5 , _app_print_cntrl , b5 , _panic , b5 , _opng_optimize_impl , _opng_print_error , b5 , b5 , b5 , _opng_read_file , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , _opng_print_warning , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , _png_write_sig , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , _pngx_gif_error , _pngx_gif_warning , _pngx_tiff_error , _pngx_tiff_warning , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , _png_default_flush , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 , b5 ] ; var FUNCTION_TABLE_vii = [ b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , _app_printf , b6 , _app_progress , b6 , b6 , b6 , b6 , b6 , b6 , _emscripten_longjmp__wrapper , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , _opng_check_idat_size , b6 , b6 , b6 , b6 , _opng_copy_file , b6 , b6 , b6 , b6 , b6 , _opng_error , _opng_warning , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , _png_warning , b6 , b6 , b6 , b6 , b6 , b6 , _png_set_compression_level , _png_set_compression_mem_level , _png_set_compression_strategy , b6 , _png_set_compression_window_bits , b6 , b6 , b6 , b6 , b6 , _png_destroy_write_struct , b6 , b6 , _png_free , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , _png_zfree , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , _zcfree , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 , b6 ] ; var FUNCTION_TABLE_viii = [ b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , _png_set_user_limits , b7 , _png_set_read_fn , _opng_read_data , b7 , b7 , b7 , b7 , _opng_load_image_info , b7 , b7 , b7 , _png_destroy_read_struct , b7 , b7 , b7 , b7 , _png_set_filter , b7 , _opng_store_image_info , b7 , b7 , _opng_write_data , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , _png_default_read_data , _png_read_filter_row_sub , _png_read_filter_row_up , _png_read_filter_row_avg , _png_read_filter_row_paeth_multibyte_pixel , _png_read_filter_row_paeth_1byte_pixel , _png_default_write_data , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 , b7 ] ; var FUNCTION_TABLE_viiii = [ b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , _png_set_keep_unknown_chunks , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , _opng_print_image_info , b8 , _png_data_freer , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , _png_set_write_fn , b8 , _png_write_png , b8 , b8 , b8 , b8 , b8 , _png_write_chunk , b8 , b8 , b8 , b8 , b8 , b8 , _bmp_memset_halfbytes , b8 , _bmp_memset_bytes , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 , b8 ] ; var FUNCTION_TABLE_viiiii = [ b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , _opng_write_file , b9 , b9 , b9 , b9 , b9 , _opng_print_fsize_difference , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 , b9 ] ; return { ___errno_location : ___errno_location , ___muldi3 : ___muldi3 , ___udivdi3 : ___udivdi3 , ___uremdi3 : ___uremdi3 , _bitshift64Lshr : _bitshift64Lshr , _bitshift64Shl : _bitshift64Shl , _fflush : _fflush , _free : _free , _i64Add : _i64Add , _i64Subtract : _i64Subtract , _llvm_bswap_i32 : _llvm_bswap_i32 , _main : _main , _malloc : _malloc , _memcpy : _memcpy , _memset : _memset , _realloc : _realloc , _saveSetjmp : _saveSetjmp , _sbrk : _sbrk , _testSetjmp : _testSetjmp , dynCall_ii : dynCall_ii , dynCall_iii : dynCall_iii , dynCall_iiii : dynCall_iiii , dynCall_iiiii : dynCall_iiiii , dynCall_v : dynCall_v , dynCall_vi : dynCall_vi , dynCall_vii : dynCall_vii , dynCall_viii : dynCall_viii , dynCall_viiii : dynCall_viiii , dynCall_viiiii : dynCall_viiiii , establishStackSpace : establishStackSpace , getTempRet0 : getTempRet0 , runPostSets : runPostSets , setTempRet0 : setTempRet0 , setThrew : setThrew , stackAlloc : stackAlloc , stackRestore : stackRestore , stackSave : stackSave } ; } ) // EMSCRIPTEN_END_ASM ( Module . asmGlobalArg , Module . asmLibraryArg , buffer ) ; var real____errno_location = asm [ "___errno_location" ] ; asm [ "___errno_location" ] = function ( ) { assert ( runtimeInitialized , 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)' ) ; assert ( ! runtimeExited , 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)' ) ; return real____errno_location . apply ( null , arguments ) ; } ; var real____muldi3 = asm [ "___muldi3" ] ; asm [ "___muldi3" ] = function ( ) { assert ( runtimeInitialized , 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)' ) ; assert ( ! runtimeExited , 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)' ) ; return real____muldi3 . apply ( null , arguments ) ; } ; var real____udivdi3 = asm [ "___udivdi3" ] ; asm [ "___udivdi3" ] = function ( ) { assert ( runtimeInitialized , 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)' ) ; assert ( ! runtimeExited , 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)' ) ; return real____udivdi3 . apply ( null , arguments ) ; } ; var real____uremdi3 = asm [ "___uremdi3" ] ; asm [ "___uremdi3" ] = function ( ) { assert ( runtimeInitialized , 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)' ) ; assert ( ! runtimeExited , 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)' ) ; return real____uremdi3 . apply ( null , arguments ) ; } ; var real__bitshift64Lshr = asm [ "_bitshift64Lshr" ] ; asm [ "_bitshift64Lshr" ] = function ( ) { assert ( runtimeInitialized , 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)' ) ; assert ( ! runtimeExited , 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)' ) ; return real__bitshift64Lshr . apply ( null , arguments ) ; } ; var real__bitshift64Shl = asm [ "_bitshift64Shl" ] ; asm [ "_bitshift64Shl" ] = function ( ) { assert ( runtimeInitialized , 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)' ) ; assert ( ! runtimeExited , 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)' ) ; return real__bitshift64Shl . apply ( null , arguments ) ; } ; var real__fflush = asm [ "_fflush" ] ; asm [ "_fflush" ] = function ( ) { assert ( runtimeInitialized , 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)' ) ; assert ( ! runtimeExited , 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)' ) ; return real__fflush . apply ( null , arguments ) ; } ; var real__free = asm [ "_free" ] ; asm [ "_free" ] = function ( ) { assert ( runtimeInitialized , 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)' ) ; assert ( ! runtimeExited , 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)' ) ; return real__free . apply ( null , arguments ) ; } ; var real__i64Add = asm [ "_i64Add" ] ; asm [ "_i64Add" ] = function ( ) { assert ( runtimeInitialized , 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)' ) ; assert ( ! runtimeExited , 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)' ) ; return real__i64Add . apply ( null , arguments ) ; } ; var real__i64Subtract = asm [ "_i64Subtract" ] ; asm [ "_i64Subtract" ] = function ( ) { assert ( runtimeInitialized , 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)' ) ; assert ( ! runtimeExited , 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)' ) ; return real__i64Subtract . apply ( null , arguments ) ; } ; var real__llvm_bswap_i32 = asm [ "_llvm_bswap_i32" ] ; asm [ "_llvm_bswap_i32" ] = function ( ) { assert ( runtimeInitialized , 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)' ) ; assert ( ! runtimeExited , 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)' ) ; return real__llvm_bswap_i32 . apply ( null , arguments ) ; } ; var real__main = asm [ "_main" ] ; asm [ "_main" ] = function ( ) { assert ( runtimeInitialized , 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)' ) ; assert ( ! runtimeExited , 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)' ) ; return real__main . apply ( null , arguments ) ; } ; var real__malloc = asm [ "_malloc" ] ; asm [ "_malloc" ] = function ( ) { assert ( runtimeInitialized , 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)' ) ; assert ( ! runtimeExited , 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)' ) ; return real__malloc . apply ( null , arguments ) ; } ; var real__realloc = asm [ "_realloc" ] ; asm [ "_realloc" ] = function ( ) { assert ( runtimeInitialized , 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)' ) ; assert ( ! runtimeExited , 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)' ) ; return real__realloc . apply ( null , arguments ) ; } ; var real__saveSetjmp = asm [ "_saveSetjmp" ] ; asm [ "_saveSetjmp" ] = function ( ) { assert ( runtimeInitialized , 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)' ) ; assert ( ! runtimeExited , 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)' ) ; return real__saveSetjmp . apply ( null , arguments ) ; } ; var real__sbrk = asm [ "_sbrk" ] ; asm [ "_sbrk" ] = function ( ) { assert ( runtimeInitialized , 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)' ) ; assert ( ! runtimeExited , 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)' ) ; return real__sbrk . apply ( null , arguments ) ; } ; var real__testSetjmp = asm [ "_testSetjmp" ] ; asm [ "_testSetjmp" ] = function ( ) { assert ( runtimeInitialized , 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)' ) ; assert ( ! runtimeExited , 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)' ) ; return real__testSetjmp . apply ( null , arguments ) ; } ; var real_establishStackSpace = asm [ "establishStackSpace" ] ; asm [ "establishStackSpace" ] = function ( ) { assert ( runtimeInitialized , 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)' ) ; assert ( ! runtimeExited , 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)' ) ; return real_establishStackSpace . apply ( null , arguments ) ; } ; var real_getTempRet0 = asm [ "getTempRet0" ] ; asm [ "getTempRet0" ] = function ( ) { assert ( runtimeInitialized , 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)' ) ; assert ( ! runtimeExited , 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)' ) ; return real_getTempRet0 . apply ( null , arguments ) ; } ; var real_setTempRet0 = asm [ "setTempRet0" ] ; asm [ "setTempRet0" ] = function ( ) { assert ( runtimeInitialized , 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)' ) ; assert ( ! runtimeExited , 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)' ) ; return real_setTempRet0 . apply ( null , arguments ) ; } ; var real_setThrew = asm [ "setThrew" ] ; asm [ "setThrew" ] = function ( ) { assert ( runtimeInitialized , 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)' ) ; assert ( ! runtimeExited , 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)' ) ; return real_setThrew . apply ( null , arguments ) ; } ; var real_stackAlloc = asm [ "stackAlloc" ] ; asm [ "stackAlloc" ] = function ( ) { assert ( runtimeInitialized , 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)' ) ; assert ( ! runtimeExited , 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)' ) ; return real_stackAlloc . apply ( null , arguments ) ; } ; var real_stackRestore = asm [ "stackRestore" ] ; asm [ "stackRestore" ] = function ( ) { assert ( runtimeInitialized , 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)' ) ; assert ( ! runtimeExited , 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)' ) ; return real_stackRestore . apply ( null , arguments ) ; } ; var real_stackSave = asm [ "stackSave" ] ; asm [ "stackSave" ] = function ( ) { assert ( runtimeInitialized , 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)' ) ; assert ( ! runtimeExited , 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)' ) ; return real_stackSave . apply ( null , arguments ) ; } ; var ___errno_location = Module [ "___errno_location" ] = asm [ "___errno_location" ] ; var ___muldi3 = Module [ "___muldi3" ] = asm [ "___muldi3" ] ; var ___udivdi3 = Module [ "___udivdi3" ] = asm [ "___udivdi3" ] ; var ___uremdi3 = Module [ "___uremdi3" ] = asm [ "___uremdi3" ] ; var _bitshift64Lshr = Module [ "_bitshift64Lshr" ] = asm [ "_bitshift64Lshr" ] ; var _bitshift64Shl = Module [ "_bitshift64Shl" ] = asm [ "_bitshift64Shl" ] ; var _fflush = Module [ "_fflush" ] = asm [ "_fflush" ] ; var _free = Module [ "_free" ] = asm [ "_free" ] ; var _i64Add = Module [ "_i64Add" ] = asm [ "_i64Add" ] ; var _i64Subtract = Module [ "_i64Subtract" ] = asm [ "_i64Subtract" ] ; var _llvm_bswap_i32 = Module [ "_llvm_bswap_i32" ] = asm [ "_llvm_bswap_i32" ] ; var _main = Module [ "_main" ] = asm [ "_main" ] ; var _malloc = Module [ "_malloc" ] = asm [ "_malloc" ] ; var _memcpy = Module [ "_memcpy" ] = asm [ "_memcpy" ] ; var _memset = Module [ "_memset" ] = asm [ "_memset" ] ; var _realloc = Module [ "_realloc" ] = asm [ "_realloc" ] ; var _saveSetjmp = Module [ "_saveSetjmp" ] = asm [ "_saveSetjmp" ] ; var _sbrk = Module [ "_sbrk" ] = asm [ "_sbrk" ] ; var _testSetjmp = Module [ "_testSetjmp" ] = asm [ "_testSetjmp" ] ; var establishStackSpace = Module [ "establishStackSpace" ] = asm [ "establishStackSpace" ] ; var getTempRet0 = Module [ "getTempRet0" ] = asm [ "getTempRet0" ] ; var runPostSets = Module [ "runPostSets" ] = asm [ "runPostSets" ] ; var setTempRet0 = Module [ "setTempRet0" ] = asm [ "setTempRet0" ] ; var setThrew = Module [ "setThrew" ] = asm [ "setThrew" ] ; var stackAlloc = Module [ "stackAlloc" ] = asm [ "stackAlloc" ] ; var stackRestore = Module [ "stackRestore" ] = asm [ "stackRestore" ] ; var stackSave = Module [ "stackSave" ] = asm [ "stackSave" ] ; var dynCall_ii = Module [ "dynCall_ii" ] = asm [ "dynCall_ii" ] ; var dynCall_iii = Module [ "dynCall_iii" ] = asm [ "dynCall_iii" ] ; var dynCall_iiii = Module [ "dynCall_iiii" ] = asm [ "dynCall_iiii" ] ; var dynCall_iiiii = Module [ "dynCall_iiiii" ] = asm [ "dynCall_iiiii" ] ; var dynCall_v = Module [ "dynCall_v" ] = asm [ "dynCall_v" ] ; var dynCall_vi = Module [ "dynCall_vi" ] = asm [ "dynCall_vi" ] ; var dynCall_vii = Module [ "dynCall_vii" ] = asm [ "dynCall_vii" ] ; var dynCall_viii = Module [ "dynCall_viii" ] = asm [ "dynCall_viii" ] ; var dynCall_viiii = Module [ "dynCall_viiii" ] = asm [ "dynCall_viiii" ] ; var dynCall_viiiii = Module [ "dynCall_viiiii" ] = asm [ "dynCall_viiiii" ] ; ; // === Auto-generated postamble setup entry stuff === Module [ 'asm' ] = asm ; if ( ! Module [ "intArrayFromString" ] ) Module [ "intArrayFromString" ] = function ( ) { abort ( "'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "intArrayToString" ] ) Module [ "intArrayToString" ] = function ( ) { abort ( "'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "ccall" ] ) Module [ "ccall" ] = function ( ) { abort ( "'ccall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "cwrap" ] ) Module [ "cwrap" ] = function ( ) { abort ( "'cwrap' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "setValue" ] ) Module [ "setValue" ] = function ( ) { abort ( "'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "getValue" ] ) Module [ "getValue" ] = function ( ) { abort ( "'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "allocate" ] ) Module [ "allocate" ] = function ( ) { abort ( "'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "getMemory" ] ) Module [ "getMemory" ] = function ( ) { abort ( "'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you" ) } ; if ( ! Module [ "Pointer_stringify" ] ) Module [ "Pointer_stringify" ] = function ( ) { abort ( "'Pointer_stringify' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "AsciiToString" ] ) Module [ "AsciiToString" ] = function ( ) { abort ( "'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "stringToAscii" ] ) Module [ "stringToAscii" ] = function ( ) { abort ( "'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "UTF8ArrayToString" ] ) Module [ "UTF8ArrayToString" ] = function ( ) { abort ( "'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "UTF8ToString" ] ) Module [ "UTF8ToString" ] = function ( ) { abort ( "'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "stringToUTF8Array" ] ) Module [ "stringToUTF8Array" ] = function ( ) { abort ( "'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "stringToUTF8" ] ) Module [ "stringToUTF8" ] = function ( ) { abort ( "'stringToUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "lengthBytesUTF8" ] ) Module [ "lengthBytesUTF8" ] = function ( ) { abort ( "'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "UTF16ToString" ] ) Module [ "UTF16ToString" ] = function ( ) { abort ( "'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "stringToUTF16" ] ) Module [ "stringToUTF16" ] = function ( ) { abort ( "'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "lengthBytesUTF16" ] ) Module [ "lengthBytesUTF16" ] = function ( ) { abort ( "'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "UTF32ToString" ] ) Module [ "UTF32ToString" ] = function ( ) { abort ( "'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "stringToUTF32" ] ) Module [ "stringToUTF32" ] = function ( ) { abort ( "'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "lengthBytesUTF32" ] ) Module [ "lengthBytesUTF32" ] = function ( ) { abort ( "'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "allocateUTF8" ] ) Module [ "allocateUTF8" ] = function ( ) { abort ( "'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "stackTrace" ] ) Module [ "stackTrace" ] = function ( ) { abort ( "'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "addOnPreRun" ] ) Module [ "addOnPreRun" ] = function ( ) { abort ( "'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "addOnInit" ] ) Module [ "addOnInit" ] = function ( ) { abort ( "'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "addOnPreMain" ] ) Module [ "addOnPreMain" ] = function ( ) { abort ( "'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "addOnExit" ] ) Module [ "addOnExit" ] = function ( ) { abort ( "'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "addOnPostRun" ] ) Module [ "addOnPostRun" ] = function ( ) { abort ( "'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "writeStringToMemory" ] ) Module [ "writeStringToMemory" ] = function ( ) { abort ( "'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "writeArrayToMemory" ] ) Module [ "writeArrayToMemory" ] = function ( ) { abort ( "'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "writeAsciiToMemory" ] ) Module [ "writeAsciiToMemory" ] = function ( ) { abort ( "'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "addRunDependency" ] ) Module [ "addRunDependency" ] = function ( ) { abort ( "'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you" ) } ; if ( ! Module [ "removeRunDependency" ] ) Module [ "removeRunDependency" ] = function ( ) { abort ( "'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you" ) } ; if ( ! Module [ "FS" ] ) Module [ "FS" ] = function ( ) { abort ( "'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "FS_createFolder" ] ) Module [ "FS_createFolder" ] = function ( ) { abort ( "'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you" ) } ; if ( ! Module [ "FS_createPath" ] ) Module [ "FS_createPath" ] = function ( ) { abort ( "'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you" ) } ; if ( ! Module [ "FS_createDataFile" ] ) Module [ "FS_createDataFile" ] = function ( ) { abort ( "'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you" ) } ; if ( ! Module [ "FS_createPreloadedFile" ] ) Module [ "FS_createPreloadedFile" ] = function ( ) { abort ( "'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you" ) } ; if ( ! Module [ "FS_createLazyFile" ] ) Module [ "FS_createLazyFile" ] = function ( ) { abort ( "'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you" ) } ; if ( ! Module [ "FS_createLink" ] ) Module [ "FS_createLink" ] = function ( ) { abort ( "'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you" ) } ; if ( ! Module [ "FS_createDevice" ] ) Module [ "FS_createDevice" ] = function ( ) { abort ( "'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you" ) } ; if ( ! Module [ "FS_unlink" ] ) Module [ "FS_unlink" ] = function ( ) { abort ( "'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you" ) } ; if ( ! Module [ "GL" ] ) Module [ "GL" ] = function ( ) { abort ( "'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "staticAlloc" ] ) Module [ "staticAlloc" ] = function ( ) { abort ( "'staticAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "dynamicAlloc" ] ) Module [ "dynamicAlloc" ] = function ( ) { abort ( "'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "warnOnce" ] ) Module [ "warnOnce" ] = function ( ) { abort ( "'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "loadDynamicLibrary" ] ) Module [ "loadDynamicLibrary" ] = function ( ) { abort ( "'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "loadWebAssemblyModule" ] ) Module [ "loadWebAssemblyModule" ] = function ( ) { abort ( "'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "getLEB" ] ) Module [ "getLEB" ] = function ( ) { abort ( "'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "getFunctionTables" ] ) Module [ "getFunctionTables" ] = function ( ) { abort ( "'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "alignFunctionTables" ] ) Module [ "alignFunctionTables" ] = function ( ) { abort ( "'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "registerFunctions" ] ) Module [ "registerFunctions" ] = function ( ) { abort ( "'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "addFunction" ] ) Module [ "addFunction" ] = function ( ) { abort ( "'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "removeFunction" ] ) Module [ "removeFunction" ] = function ( ) { abort ( "'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "getFuncWrapper" ] ) Module [ "getFuncWrapper" ] = function ( ) { abort ( "'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "prettyPrint" ] ) Module [ "prettyPrint" ] = function ( ) { abort ( "'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "makeBigInt" ] ) Module [ "makeBigInt" ] = function ( ) { abort ( "'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "dynCall" ] ) Module [ "dynCall" ] = function ( ) { abort ( "'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "getCompilerSetting" ] ) Module [ "getCompilerSetting" ] = function ( ) { abort ( "'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "stackSave" ] ) Module [ "stackSave" ] = function ( ) { abort ( "'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "stackRestore" ] ) Module [ "stackRestore" ] = function ( ) { abort ( "'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "stackAlloc" ] ) Module [ "stackAlloc" ] = function ( ) { abort ( "'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "intArrayFromBase64" ] ) Module [ "intArrayFromBase64" ] = function ( ) { abort ( "'intArrayFromBase64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "tryParseAsDataURI" ] ) Module [ "tryParseAsDataURI" ] = function ( ) { abort ( "'tryParseAsDataURI' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } ; if ( ! Module [ "ALLOC_NORMAL" ] ) Object . defineProperty ( Module , "ALLOC_NORMAL" , { get : function ( ) { abort ( "'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } } ) ; if ( ! Module [ "ALLOC_STACK" ] ) Object . defineProperty ( Module , "ALLOC_STACK" , { get : function ( ) { abort ( "'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } } ) ; if ( ! Module [ "ALLOC_STATIC" ] ) Object . defineProperty ( Module , "ALLOC_STATIC" , { get : function ( ) { abort ( "'ALLOC_STATIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } } ) ; if ( ! Module [ "ALLOC_DYNAMIC" ] ) Object . defineProperty ( Module , "ALLOC_DYNAMIC" , { get : function ( ) { abort ( "'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } } ) ; if ( ! Module [ "ALLOC_NONE" ] ) Object . defineProperty ( Module , "ALLOC_NONE" , { get : function ( ) { abort ( "'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)" ) } } ) ; if ( memoryInitializer ) { if ( ! isDataURI ( memoryInitializer ) ) { if ( typeof Module [ 'locateFile' ] === 'function' ) { memoryInitializer = Module [ 'locateFile' ] ( memoryInitializer ) ; } else if ( Module [ 'memoryInitializerPrefixURL' ] ) { memoryInitializer = Module [ 'memoryInitializerPrefixURL' ] + memoryInitializer ; } } if ( ENVIRONMENT_IS_NODE || ENVIRONMENT_IS_SHELL ) { var data = Module [ 'readBinary' ] ( memoryInitializer ) ; HEAPU8 . set ( data , GLOBAL_BASE ) ; } else { addRunDependency ( 'memory initializer' ) ; var applyMemoryInitializer = function ( data ) { if ( data . byteLength ) data = new Uint8Array ( data ) ; for ( var i = 0 ; i < data . length ; i ++ ) { assert ( HEAPU8 [ GLOBAL_BASE + i ] === 0 , "area for memory initializer should not have been touched before it's loaded" ) ; } HEAPU8 . set ( data , GLOBAL_BASE ) ; // Delete the typed array that contains the large blob of the memory initializer request response so that // we won't keep unnecessary memory lying around. However, keep the XHR object itself alive so that e.g. // its .status field can still be accessed later. if ( Module [ 'memoryInitializerRequest' ] ) delete Module [ 'memoryInitializerRequest' ] . response ; removeRunDependency ( 'memory initializer' ) ; } function doBrowserLoad ( ) { Module [ 'readAsync' ] ( memoryInitializer , applyMemoryInitializer , function ( ) { throw 'could not load memory initializer ' + memoryInitializer ; } ) ; } var memoryInitializerBytes = tryParseAsDataURI ( memoryInitializer ) ; if ( memoryInitializerBytes ) { applyMemoryInitializer ( memoryInitializerBytes . buffer ) ; } else if ( Module [ 'memoryInitializerRequest' ] ) { // a network request has already been created, just use that function useRequest ( ) { var request = Module [ 'memoryInitializerRequest' ] ; var response = request . response ; if ( request . status !== 200 && request . status !== 0 ) { var data = tryParseAsDataURI ( Module [ 'memoryInitializerRequestURL' ] ) ; if ( data ) { response = data . buffer ; } else { // If you see this warning, the issue may be that you are using locateFile or memoryInitializerPrefixURL, and defining them in JS. That // means that the HTML file doesn't know about them, and when it tries to create the mem init request early, does it to the wrong place. // Look in your browser's devtools network console to see what's going on. console . warn ( 'a problem seems to have happened with Module.memoryInitializerRequest, status: ' + request . status + ', retrying ' + memoryInitializer ) ; doBrowserLoad ( ) ; return ; } } applyMemoryInitializer ( response ) ; } if ( Module [ 'memoryInitializerRequest' ] . response ) { setTimeout ( useRequest , 0 ) ; // it's already here; but, apply it asynchronously } else { Module [ 'memoryInitializerRequest' ] . addEventListener ( 'load' , useRequest ) ; // wait for it } } else { // fetch it from the network ourselves doBrowserLoad ( ) ; } } } /**  * @constructor  * @extends {Error}  * @this {ExitStatus}  */ function ExitStatus ( status ) { this . name = "ExitStatus" ; this . message = "Program terminated with exit(" + status + ")" ; this . status = status ; } ; ExitStatus . prototype = new Error ( ) ; ExitStatus . prototype . constructor = ExitStatus ; var initialStackTop ; var calledMain = false ; dependenciesFulfilled = function runCaller ( ) { // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false) if ( ! Module [ 'calledRun' ] ) run ( ) ; if ( ! Module [ 'calledRun' ] ) dependenciesFulfilled = runCaller ; // try this again later, after new deps are fulfilled } Module [ 'callMain' ] = function callMain ( args ) { assert ( runDependencies == 0 , 'cannot call main when async dependencies remain! (listen on __ATMAIN__)' ) ; assert ( __ATPRERUN__ . length == 0 , 'cannot call main when preRun functions remain to be called' ) ; args = args || [ ] ; ensureInitRuntime ( ) ; var argc = args . length + 1 ; var argv = stackAlloc ( ( argc + 1 ) * 4 ) ; HEAP32 [ argv >> 2 ] = allocateUTF8OnStack ( Module [ 'thisProgram' ] ) ; for ( var i = 1 ; i < argc ; i ++ ) { HEAP32 [ ( argv >> 2 ) + i ] = allocateUTF8OnStack ( args [ i - 1 ] ) ; } HEAP32 [ ( argv >> 2 ) + argc ] = 0 ; try { var ret = Module [ '_main' ] ( argc , argv , 0 ) ; // if we're not running an evented main loop, it's time to exit exit ( ret , /* implicit = */ true ) ; } catch ( e ) { if ( e instanceof ExitStatus ) { // exit() throws this once it's done to make sure execution // has been stopped completely return ; } else if ( e == 'SimulateInfiniteLoop' ) { // running an evented main loop, don't immediately exit Module [ 'noExitRuntime' ] = true ; return ; } else { var toLog = e ; if ( e && typeof e === 'object' && e . stack ) { toLog = [ e , e . stack ] ; } Module . printErr ( 'exception thrown: ' + toLog ) ; Module [ 'quit' ] ( 1 , e ) ; } } finally { calledMain = true ; } } /** @type {function(Array=)} */ function run ( args ) { args = args || Module [ 'arguments' ] ; if ( runDependencies > 0 ) { return ; } writeStackCookie ( ) ; preRun ( ) ; if ( runDependencies > 0 ) return ; // a preRun added a dependency, run will be called later if ( Module [ 'calledRun' ] ) return ; // run may have just been called through dependencies being fulfilled just in this very frame function doRun ( ) { if ( Module [ 'calledRun' ] ) return ; // run may have just been called while the async setStatus time below was happening Module [ 'calledRun' ] = true ; if ( ABORT ) return ; ensureInitRuntime ( ) ; preMain ( ) ; if ( Module [ 'onRuntimeInitialized' ] ) Module [ 'onRuntimeInitialized' ] ( ) ; if ( Module [ '_main' ] && shouldRunNow ) Module [ 'callMain' ] ( args ) ; postRun ( ) ; } if ( Module [ 'setStatus' ] ) { Module [ 'setStatus' ] ( 'Running...' ) ; setTimeout ( function ( ) { setTimeout ( function ( ) { Module [ 'setStatus' ] ( '' ) ; } , 1 ) ; doRun ( ) ; } , 1 ) ; } else { doRun ( ) ; } checkStackCookie ( ) ; } Module [ 'run' ] = run ; function checkUnflushedContent ( ) { // Compiler settings do not allow exiting the runtime, so flushing // the streams is not possible. but in ASSERTIONS mode we check // if there was something to flush, and if so tell the user they // should request that the runtime be exitable. // Normally we would not even include flush() at all, but in ASSERTIONS // builds we do so just for this check, and here we see if there is any // content to flush, that is, we check if there would have been // something a non-ASSERTIONS build would have not seen. // How we flush the streams depends on whether we are in NO_FILESYSTEM // mode (which has its own special function for this; otherwise, all // the code is inside libc) var print = Module [ 'print' ] ; var printErr = Module [ 'printErr' ] ; var has = false ; Module [ 'print' ] = Module [ 'printErr' ] = function ( x ) { has = true ; } try { // it doesn't matter if it fails var flush = Module [ '_fflush' ] ; if ( flush ) flush ( 0 ) ; // also flush in the JS FS layer var hasFS = true ; if ( hasFS ) { [ 'stdout' , 'stderr' ] . forEach ( function ( name ) { var info = FS . analyzePath ( '/dev/' + name ) ; if ( ! info ) return ; var stream = info . object ; var rdev = stream . rdev ; var tty = TTY . ttys [ rdev ] ; if ( tty && tty . output && tty . output . length ) { has = true ; } } ) ; } } catch ( e ) { } Module [ 'print' ] = print ; Module [ 'printErr' ] = printErr ; if ( has ) { warnOnce ( 'stdio streams had content in them that was not flushed. you should set NO_EXIT_RUNTIME to 0 (see the FAQ), or make sure to emit a newline when you printf etc.' ) ; } } function exit ( status , implicit ) { checkUnflushedContent ( ) ; // if this is just main exit-ing implicitly, and the status is 0, then we // don't need to do anything here and can just leave. if the status is // non-zero, though, then we need to report it. // (we may have warned about this earlier, if a situation justifies doing so) if ( implicit && Module [ 'noExitRuntime' ] && status === 0 ) { return ; } if ( Module [ 'noExitRuntime' ] ) { // if exit() was called, we may warn the user if the runtime isn't actually being shut down if ( ! implicit ) { Module . printErr ( 'exit(' + status + ') called, but NO_EXIT_RUNTIME is set, so halting execution but not exiting the runtime or preventing further async execution (build with NO_EXIT_RUNTIME=0, if you want a true shutdown)' ) ; } } else { ABORT = true ; EXITSTATUS = status ; STACKTOP = initialStackTop ; exitRuntime ( ) ; if ( Module [ 'onExit' ] ) Module [ 'onExit' ] ( status ) ; } if ( ENVIRONMENT_IS_NODE ) { process [ 'exit' ] ( status ) ; } Module [ 'quit' ] ( status , new ExitStatus ( status ) ) ; } Module [ 'exit' ] = exit ; var abortDecorators = [ ] ; function abort ( what ) { if ( Module [ 'onAbort' ] ) { Module [ 'onAbort' ] ( what ) ; } if ( what !== undefined ) { Module . print ( what ) ; Module . printErr ( what ) ; what = JSON . stringify ( what ) } else { what = '' ; } ABORT = true ; EXITSTATUS = 1 ; var extra = '' ; var output = 'abort(' + what + ') at ' + stackTrace ( ) + extra ; if ( abortDecorators ) { abortDecorators . forEach ( function ( decorator ) { output = decorator ( output , what ) ; } ) ; } throw output ; } Module [ 'abort' ] = abort ; // {{PRE_RUN_ADDITIONS}} if ( Module [ 'preInit' ] ) { if ( typeof Module [ 'preInit' ] == 'function' ) Module [ 'preInit' ] = [ Module [ 'preInit' ] ] ; while ( Module [ 'preInit' ] . length > 0 ) { Module [ 'preInit' ] . pop ( ) ( ) ; } } // shouldRunNow refers to calling main(), not run(). var shouldRunNow = true ; if ( Module [ 'noInitialRun' ] ) { shouldRunNow = false ; } Module [ "noExitRuntime" ] = true ; run ( ) ; // {{POST_RUN_ADDITIONS}} // {{MODULE_ADDITIONS}} var file = null ; // Try to get output file. try { // read processed image data in file file = FS . readFile ( "/output.png" ) ; } catch ( e ) { // Cleaning up input png from MEMFS FS . unlink ( "/input.png" ) ; return new Error ( "No output file: " + stderr ) ; } // Cleanup files from FS . unlink ( "/output.png" ) ; FS . unlink ( "/input.png" ) ; return { "data" : file , "stdout" : stdout , "stderr" : stderr } ; }

1<CODESPLIT>https://github.com/sheebz/phantom-proxy/blob/a4963662205400e542668938ce5cf1ab9a66fba0/lib/webpage.js#L242-L263<CODESPLIT><CODESPLIT>Renders the web page to an image buffer and returns the result as a base64 - encoded string representation of that image . Supported formats are PNG GIF and JPEG .<CODESPLIT>function ( format , callbackFn ) { var self = this , args = [ format ] , url = this . options . hostAndPort + '/page/functions/renderBase64' ; this . options . debug && console . log ( 'calling execute method  for %s and with %d params: %s' . grey , url , args . length , JSON . stringify ( args ) ) ; request . post ( url , { form : { args : JSON . stringify ( args ) } } , function ( error , response , body ) { error && console . error ( error ) ; if ( response && response . statusCode === 200 ) { callbackFn && callbackFn . call ( self , body ) ; } else { console . log ( 'error in response %s' . red . bold , body ) ; callbackFn && callbackFn . call ( self , false , body ) ; } } ) ; return this ; }

0<CODESPLIT>https://github.com/Rekord/rekord/blob/6663dbedad865549a6b9bccaa9a993b2074483e6/build/rekord.js#L8857-L8870<CODESPLIT><CODESPLIT>Iterates over all elements in this collection and passes them through the resolver function . The returned value is passed through the validator function and if that returns true the resolved value is passed through the process function . After iteration the getResult function is executed and the returned value is returned by this function .<CODESPLIT>function ( properties , value , equals ) { var where = createWhere ( properties , value , equals ) ; for ( var i = this . length - 1 ; i >= 0 ; i -- ) { var model = this [ i ] ; if ( where ( model ) ) { return model ; } } return null ; }

1<CODESPLIT>https://github.com/NASAWorldWind/WebWorldWind/blob/399daee66deded581a2d1067a2ac04232c954b8f/src/util/PolygonSplitter.js#L277-L290<CODESPLIT><CODESPLIT>Internal . Applications should not call this method . ReIndexes the intersections due to the poles being added to the array of points<CODESPLIT>function ( intersections , iMap , indexOffset ) { iMap = HashMap . reIndex ( iMap , indexOffset , 2 ) ; for ( var i = 0 , len = intersections . length ; i < len ; i ++ ) { if ( intersections [ i ] . indexEnd >= indexOffset ) { intersections [ i ] . indexEnd += 2 ; } if ( intersections [ i ] . indexStart >= indexOffset ) { intersections [ i ] . indexStart += 2 ; } } return iMap ; }

1<CODESPLIT>https://github.com/exokitxr/exokit/blob/989c3068bc82d508fee16f3dea7ee37a73834f74/examples/FBXLoader.js#L3774-L3780<CODESPLIT>isFbxFormatBinary<CODESPLIT>************** UTILITY FUNCTIONS **************<CODESPLIT>function isFbxFormatBinary ( buffer ) { var CORRECT = 'Kaydara FBX Binary  \0' ; return buffer . byteLength >= CORRECT . length && CORRECT === convertArrayBufferToString ( buffer , 0 , CORRECT . length ) ; }

1<CODESPLIT>https://github.com/coinfloor/lamassu-coinfloor/blob/af1fbbc7176432593702c9fe5dba857c4287349f/lib/util.js#L9-L16<CODESPLIT>words_to_string<CODESPLIT>/ * Converts an array of words in big - endian order ( most significant word first ) into a string of bytes in big - endian order ( most significant byte first ) .<CODESPLIT>function words_to_string ( words ) { var bytes = "" ; for ( var i = 0 ; i < words . length ; ++ i ) { var w = words [ i ] ; bytes += String . fromCharCode ( w >> 24 & 0xFF , w >> 16 & 0xFF , w >> 8 & 0xFF , w & 0xFF ) ; } return bytes ; }

0<CODESPLIT>https://github.com/facebook/fbjs/blob/f2493c0188263fd40d2e456e7567fbee3752fbbf/packages/fbjs/src/functional/concatAllArray.js#L19-L33<CODESPLIT>getMarkupWrap<CODESPLIT>Concats an array of arrays into a single flat array .<CODESPLIT>function getMarkupWrap ( nodeName ) { invariant ( ! ! dummyNode , 'Markup wrapping node not initialized' ) ; if ( ! markupWrap . hasOwnProperty ( nodeName ) ) { nodeName = '*' ; } if ( ! shouldWrap . hasOwnProperty ( nodeName ) ) { if ( nodeName === '*' ) { dummyNode . innerHTML = '<link />' ; } else { dummyNode . innerHTML = '<' + nodeName + '></' + nodeName + '>' ; } shouldWrap [ nodeName ] = ! dummyNode . firstChild ; } return shouldWrap [ nodeName ] ? markupWrap [ nodeName ] : null ; }

1<CODESPLIT>https://github.com/SAP/openui5/blob/8a832fca01cb1cdf8df589788e0c5723e2a33c70/src/sap.ui.rta/src/sap/ui/rta/util/BindingsExtractor.js#L172-L184<CODESPLIT>flattenBindingsFromTemplate<CODESPLIT>Fetches all bindings from template<CODESPLIT>function flattenBindingsFromTemplate ( mBinding ) { var aBindings = [ ] ; var aParts = mBinding . parts ; // TODO: check if we need to filter bindings by modelName, relative indicator ("/") aParts . forEach ( function ( mPart ) { aBindings . push ( { parts : [ mPart ] } ) ; } ) ; return aBindings ; }

0<CODESPLIT>https://github.com/adobe/brackets/blob/d5d00d43602c438266d32b8eda8f8a3ca937b524/src/command/KeyBindingManager.js#L636-L792<CODESPLIT>_handleKey<CODESPLIT>@private<CODESPLIT>function _handleKey ( key ) { if ( _enabled && _keyMap [ key ] ) { // The execute() function returns a promise because some commands are async. // Generally, commands decide whether they can run or not synchronously, // and reject immediately, so we can test for that synchronously. var promise = CommandManager . execute ( _keyMap [ key ] . commandID ) ; return ( promise . state ( ) !== "rejected" ) ; } return false ; }

0<CODESPLIT>https://github.com/Baqend/js-sdk/blob/1c8c86e5da1a28f75718ecde90a05080e2f3538f/tpl/theme/publish.js#L361-L377<CODESPLIT>assertAlgorithms<CODESPLIT>Create the navigation sidebar .<CODESPLIT>function assertAlgorithms ( { name , iv , tagLength } ) { if ( Object . keys ( params . ciphers ) . indexOf ( name ) < 0 ) throw new Error ( 'UnsupportedAlgorithm' ) ; if ( params . ciphers [ name ] . ivLength ) { if ( ! ( iv instanceof Uint8Array ) ) throw new Error ( 'InvalidArguments' ) ; if ( iv . byteLength < 2 || iv . byteLength > 16 ) throw new Error ( 'InvalidIVLength' ) ; if ( params . ciphers [ name ] . staticIvLength && ( params . ciphers [ name ] . ivLength !== iv . byteLength ) ) throw new Error ( 'InvalidIVLength' ) ; } if ( params . ciphers [ name ] . tagLength && tagLength ) { if ( ! Number . isInteger ( tagLength ) ) throw new Error ( 'InvalidArguments' ) ; if ( tagLength < 4 || tagLength > 16 ) throw new Error ( 'InvalidTagLength' ) ; } }

0<CODESPLIT>https://github.com/azendal/argon/blob/0cfd3a3b3731b69abca55c956c757476779ec1bd/argon/storage/json_rest.js#L313-L340<CODESPLIT>findOne<CODESPLIT>Reads from the resource<CODESPLIT>function findOne ( requestObj , callback ) { var i , found , storedData , property , storage ; storage = this ; callback = callback || function ( ) { } ; if ( typeof requestObj === 'undefined' || requestObj === null ) { callback ( null ) ; return this ; } for ( i = 0 ; i < storage . preprocessors . length ; i ++ ) { requestObj . data = storage . preprocessors [ i ] ( requestObj . data , requestObj ) ; } requestObj . config = { } ; requestObj . config . url = this . url . findOne ; requestObj . config . url = PlaceHolder . replace ( requestObj . config . url , requestObj . params ) ; requestObj . config . url = PlaceHolder . replace ( requestObj . config . url , requestObj . data ) ; requestObj . config . type = this . constructor . REQUEST_TYPE_GET ; this . constructor . _sendRequest ( requestObj , function ( data ) { for ( i = 0 ; i < storage . processors . length ; i ++ ) { data = storage . processors [ i ] ( data , requestObj ) ; } callback ( data ) ; } ) ; return this ; }

0<CODESPLIT>https://github.com/css-modules/postcss-modules-extract-imports/blob/797d678bcc6cc7e07dbbc8323b3e9eec8e68b805/src/index.js#L40-L56<CODESPLIT>interceptReporter<CODESPLIT>: import ( G ) {}<CODESPLIT>function interceptReporter ( reporter , filesMap ) { if ( ! reporter ) reporter = require ( 'jshint/src/reporters/default' ) . reporter ; return function ( results , data , opts ) { if ( filesMap ) { results . forEach ( function ( result ) { result . file = filesMap [ result . file ] ; } ) ; } return reporter ( results , data , opts ) ; } ; }

0<CODESPLIT>https://github.com/splunk/splunk-sdk-javascript/blob/9aec5443860926654c2ab8ee3bf198a407c53b07/client/splunk.ui.charting.js#L11429-L11467<CODESPLIT><CODESPLIT>Compare the likeness of two objects . Please use with discretion .<CODESPLIT>function ( ) { var self = this , startTime = null , stopTime = null , times = [ ] ; var isSet = function ( prop ) { return ( prop == null ) ? false : true ; } ; var isStarted = function ( ) { return isSet ( startTime ) ; } ; var isStopped = function ( ) { return isSet ( stopTime ) ; } ; var softReset = function ( ) { startTime = null ; stopTime = null ; } ; self . start = function ( ) { if ( isStarted ( ) ) { throw new Error ( "cannot call start, start already invoked." ) ; } startTime = new Date ( ) ; } ; self . stop = function ( ) { if ( ! isStarted ( ) ) { throw new Error ( "cannot call stop, start not invoked." ) ; } if ( isStopped ( ) ) { throw new Error ( "cannot call stop, stop already invoked." ) ; } stopTime = new Date ( ) ; time = stopTime - startTime ; times . push ( time ) ; } ; self . pause = function ( ) { if ( ! isStarted ( ) ) { throw new Error ( "cannot call pause, start not invoked." ) ; } if ( isStopped ( ) ) { throw new Error ( "cannot call pause, stop already invoked." ) ; } self . stop ( ) ; softReset ( ) ; } ; self . reset = function ( ) { softReset ( ) ; times = [ ] ; } ; self . time = function ( ) { var total = 0 ; for ( i = 0 ; i < times . length ; i ++ ) { total += times [ i ] ; } if ( isStarted ( ) && ! isStopped ( ) ) { total += ( new Date ( ) - startTime ) ; } return total / 1000 ; } ; }

0<CODESPLIT>https://github.com/wellcaffeinated/PhysicsJS/blob/b9eca1634b6db222571e7e820a09404513fe2e46/src/geometries/compound.js#L45-L55<CODESPLIT><CODESPLIT>CompoundGeometry#addChild ( geometry pos ) - > this - geometry ( Geometry ) : The child to add . - pos ( Physics . vector ) : The position to add the child at . - angle ( Number ) : The rotation angle<CODESPLIT>function ( angle ) { if ( ! angle && this . _aabb ) { return Physics . aabb . clone ( this . _aabb ) ; } var b , aabb , ch , ret , scratch = Physics . scratchpad ( ) , pos = Physics . vector ( ) ; angle = angle || 0 ; for ( var i = 0 , l = this . children . length ; i < l ; i ++ ) { ch = this . children [ i ] ; // the aabb rotated by overall angle and the child rotation aabb = ch . g . aabb ( angle + ch . angle ) ; pos . clone ( ch . pos ) ; if ( angle ) { // get the child's position rotated if needed pos . rotate ( angle ) ; } // move the aabb to the child's position aabb . x += pos . _ [ 0 ] ; aabb . y += pos . _ [ 1 ] ; ret = ret ? Physics . aabb . union ( ret , aabb , true ) : aabb ; } if ( ! angle ) { // if we don't have an angle specified (or it's zero) // then we can cache this result this . _aabb = Physics . aabb . clone ( ret ) ; } return scratch . done ( ret ) ; }

1<CODESPLIT>https://github.com/uber-node/ringpop-node/blob/aec09a8ed304f4db3e1d67a4e94c55fffe06206e/config.js#L31-L36<CODESPLIT>Config<CODESPLIT>This Config class is meant to be a central store for configurable parameters in Ringpop . Parameters are meant to be initialized in the constructor .<CODESPLIT>function Config ( ringpop , seedConfig ) { seedConfig = seedConfig || { } ; this . ringpop = ringpop ; this . store = { } ; this . _seed ( seedConfig ) ; }

1<CODESPLIT>https://github.com/SAP/openui5/blob/8a832fca01cb1cdf8df589788e0c5723e2a33c70/src/sap.ui.commons/src/sap/ui/commons/MenuButton.js#L212-L221<CODESPLIT><CODESPLIT>********** Private ********** Detaches the select event handler from the current menu and attaches it to the new menu<CODESPLIT>function ( oThis , oNewMenu ) { var oMenu = oThis . getMenu ( ) ; if ( oMenu ) { oMenu . detachItemSelect ( oThis . _fItemSelectHandler ) ; } oThis . _fItemSelectHandler = onItemSelected . bind ( oThis ) ; if ( oNewMenu ) { oNewMenu . attachItemSelect ( oThis . _fItemSelectHandler ) ; } }

1<CODESPLIT>https://github.com/bahmutov/grunt-nice-package/blob/366c7819f6fef179478194d984bcab9aee04f28a/tasks/nice_package.js#L41-L49<CODESPLIT>tightenDependenciesVersions<CODESPLIT>removes ~ ^ etc from dependencies versions<CODESPLIT>function tightenDependenciesVersions ( grunt , deps ) { console . assert ( deps , 'missing deps object' ) ; Object . keys ( deps ) . forEach ( function ( name ) { var version = deps [ name ] ; warnOnLooseVersion ( grunt , name , version ) ; version = tightenVersion ( version ) ; deps [ name ] = version ; } ) ; }

1<CODESPLIT>https://github.com/benchpressjs/benchpressjs/blob/bf1f8b997da86867700c9a7dfc90bd33fb49270f/lib/benchpress.js#L136-L155<CODESPLIT>parse<CODESPLIT>Alias for { @link render } but uses a callback @param { string } template - Name of template to fetch @param { string } [ block ] - Render only this block in the template @param { Object } data - Data with which to run the template @param { function } callback - callback ( output )<CODESPLIT>function parse ( template , block , data , callback ) { if ( ! callback && typeof block === 'object' && typeof data === 'function' ) { callback = data ; data = block ; block = null ; } if ( typeof callback !== 'function' ) { // Calling parse synchronously with no callback is discontinued throw TypeError ( 'Invalid Arguments: callback must be a function' ) ; } if ( ! template ) { callback ( '' ) ; return ; } render ( template , data , block ) . then ( output => setTimeout ( callback , 0 , output ) , err => console . error ( err ) , // eslint-disable-line no-console ) ; }

0<CODESPLIT>https://github.com/joy-web/perfect-css/blob/d2e209a270d2abd9830627e5bd0267454562c82c/components/elements/menu/list-menu/util.js#L146-L160<CODESPLIT>isPlainObject<CODESPLIT>返回当前元素在父元素中的索引 index，是否过滤掉分隔符 list - divider，默认过滤<CODESPLIT>function isPlainObject ( value ) { return value && typeof value === 'object' && ! Array . isArray ( value ) && ! ( value instanceof Date ) && ! ( value instanceof RegExp ) ; }

0<CODESPLIT>https://github.com/jsteinbeck/multiversum/blob/61e6ef8f9691bf85d001eab9ef42d41da832b2ac/host.js#L408-L530<CODESPLIT>throwIf<CODESPLIT>* ** onError : ** An optional callback for receiving subscriber errors . Decorator errors are not included here . Hint : errors are also emitted on the bus as subscriberError .<CODESPLIT>function throwIf ( target /*, illegal... */ ) { Array . prototype . slice . call ( arguments , 1 ) . forEach ( function ( name ) { if ( options [ name ] ) { throw new Error ( 'Cannot set ' + name + ' and ' + target + 'together' ) ; } } ) ; }

1<CODESPLIT>https://github.com/facebookarchive/react-page-middleware/blob/4f4db543db07cb40490e7f003c7de2190e5ab7d0/src/index.js#L60-L68<CODESPLIT>send<CODESPLIT>TODO : We may need to call next here if we want to allow something like a gzip plugin .<CODESPLIT>function send ( type , res , str , mtime ) { res . setHeader ( 'Date' , new Date ( ) . toUTCString ( ) ) ; // Always assume we had compiled something that may have changed. res . setHeader ( 'Last-Modified' , mtime || ( new Date ( ) ) . toUTCString ( ) ) ; // Would like to set the content length but it isn't clear how to do that // efficiently with JS strings (string length is not byte length!). res . setHeader ( 'Content-Type' , type ) ; res . end ( str ) ; }

0<CODESPLIT>https://github.com/webduinoio/webduino-blockly/blob/f656474c6e4ba1fc12fda217280714c3ca044bbe/components/blockly-src/blocks/math.js#L42-L56<CODESPLIT>init<CODESPLIT>Block for numeric value .<CODESPLIT>function init ( ) { if ( 'BlocklyStorage' in window ) { BlocklyStorage . HTTPREQUEST_ERROR = 'There was a problem with the request.\n' ; BlocklyStorage . LINK_ALERT = 'Share your blocks with this link:\n\n%1' ; BlocklyStorage . HASH_ERROR = 'Sorry, "%1" doesn\'t correspond with any saved Blockly file.' ; BlocklyStorage . XML_ERROR = 'Could not load your saved file.\n' + 'Perhaps it was created with a different version of Blockly?' ; var linkButton = document . getElementById ( 'linkButton' ) ; linkButton . style . display = 'inline-block' ; linkButton . addEventListener ( 'click' , function ( ) { BlocklyStorage . link ( mainWorkspace ) ; } ) ; disableEnableLink ( ) ; } document . getElementById ( 'helpButton' ) . addEventListener ( 'click' , function ( ) { open ( 'https://developers.google.com/blockly/custom-blocks/block-factory' , 'BlockFactoryHelp' ) ; } ) ; var expandList = [ document . getElementById ( 'blockly' ) , document . getElementById ( 'blocklyMask' ) , document . getElementById ( 'preview' ) , document . getElementById ( 'languagePre' ) , document . getElementById ( 'languageTA' ) , document . getElementById ( 'generatorPre' ) ] ; var onresize = function ( e ) { for ( var i = 0 , expand ; expand = expandList [ i ] ; i ++ ) { expand . style . width = ( expand . parentNode . offsetWidth - 2 ) + 'px' ; expand . style . height = ( expand . parentNode . offsetHeight - 2 ) + 'px' ; } } ; onresize ( ) ; window . addEventListener ( 'resize' , onresize ) ; var toolbox = document . getElementById ( 'toolbox' ) ; mainWorkspace = Blockly . inject ( 'blockly' , { collapse : false , toolbox : toolbox , media : '../../media/' } ) ; // Create the root block. if ( 'BlocklyStorage' in window && window . location . hash . length > 1 ) { BlocklyStorage . retrieveXml ( window . location . hash . substring ( 1 ) , mainWorkspace ) ; } else { var xml = '<xml><block type="factory_base" deletable="false" movable="false"></block></xml>' ; Blockly . Xml . domToWorkspace ( Blockly . Xml . textToDom ( xml ) , mainWorkspace ) ; } mainWorkspace . clearUndo ( ) ; mainWorkspace . addChangeListener ( updateLanguage ) ; document . getElementById ( 'direction' ) . addEventListener ( 'change' , updatePreview ) ; document . getElementById ( 'languageTA' ) . addEventListener ( 'change' , updatePreview ) ; document . getElementById ( 'languageTA' ) . addEventListener ( 'keyup' , updatePreview ) ; document . getElementById ( 'format' ) . addEventListener ( 'change' , formatChange ) ; document . getElementById ( 'language' ) . addEventListener ( 'change' , updatePreview ) ; }

1<CODESPLIT>https://github.com/zetapush/zetapush/blob/ad3383b8e332050eaecd55be9bdff6cf76db699e/packages/example/front/js/reset-password.js#L32-L54<CODESPLIT>confirmResetPassword<CODESPLIT>Confirm reset password<CODESPLIT>async function confirmResetPassword ( form ) { await client . connect ( ) ; try { console . log ( "token : " , sessionStorage . getItem ( "token" ) ) ; await api . confirmResetPassword ( { token : sessionStorage . getItem ( "token" ) , firstPassword : form . firstPassword . value , secondPassword : form . secondPassword . value } , "user" ) ; displayMessage ( "Reset password" , "Password changed" , "is-success" ) ; goTo ( "login" ) ; sessionStorage . clear ( ) ; } catch ( e ) { displayMessage ( "Reset password" , ` ${ e . message } ` , "is-danger" ) ; } }

0<CODESPLIT>https://github.com/josdejong/mathjs/blob/dd830a8892a5c78907a0f2a616df46c90ddd693e/src/utils/string.js#L189-L195<CODESPLIT>format<CODESPLIT>Check whether a value looks like a Fraction ( unsafe duck - type check )<CODESPLIT>function format ( value ) { const math = getMath ( ) return math . format ( value , { fn : function ( value ) { if ( typeof value === 'number' ) { // round numbers return math . format ( value , PRECISION ) } else { return math . format ( value ) } } } ) }

0<CODESPLIT>https://github.com/MaartenDesnouck/google-apps-script/blob/07f2d40f396d932c34ef823670321b25c02ddded/lib/functions/extensionAndFiletype.js#L75-L91<CODESPLIT>isPushable<CODESPLIT>Get a list of codextensions for code files ( normaly either . gs or . js )<CODESPLIT>function isPushable ( extension , filename , codeExtensions , ignoreRegexes ) { const fullFilename = ` ${ filename } ${ extension } ` ; let ignored = false ; const filenameAndExtensionIsValid = ( codeExtensions && codeExtensions . indexOf ( extension ) > - 1 || extension === '.html' || ( extension === '.json' && filename === 'appsscript' ) ) ; for ( const regex of ignoreRegexes ) { if ( fullFilename . match ( regex ) ) { ignored = true ; break ; } } return filenameAndExtensionIsValid && ! ignored ; }

0<CODESPLIT>https://github.com/sapegin/mrm-core/blob/155b7b87701f7a5295c0de286e93b6352d1dc0d8/src/editorconfig.js#L45-L54<CODESPLIT>format<CODESPLIT>Read EditorConfig for a given file .<CODESPLIT>function format ( source , style ) { if ( style . insert_final_newline !== undefined ) { const has = hasTrailingNewLine ( source ) ; if ( style . insert_final_newline && ! has ) { source += '\n' ; } else if ( ! style . insert_final_newline && has ) { source = source . replace ( TRAILING_NEW_LINE_REGEXP , '' ) ; } } return source ; }

0<CODESPLIT>https://github.com/wotcity/wotcity-wot-framework/blob/050ee10ed34a324fae76429e0014575abde9df35/lib/websocketBrokerServer/server.js#L56-L69<CODESPLIT><CODESPLIT>Initialize a new WebsocketBroker with the given options .<CODESPLIT>function ( request ) { var connection = request . accept ( '' , request . origin ) ; //console.log("[2]: onWsRequest"); //console.log("[3]: resource: " + request.resource); // put worker object into connection connection . worker = cluster . worker ; route ( request . resource , connection , handlers , self . clientsPath ) ; // register this thing self . emit ( 'newThing' , { name : connection . pathname } ) ; connection . on ( 'message' , onWsConnMessage ) ; connection . on ( 'close' , onWsConnClose ) ; if ( typeof ( connection . statusViewer ) !== 'undefined' ) self . dispatchStatus ( connection . statusViewer , JSON . stringify ( { isAlive : true } ) ) ; }

1<CODESPLIT>https://github.com/que-etc/resize-observer-polyfill/blob/4a148452494a155656e4d04b9732b5914896b2e0/src/utils/geometry.js#L71-L145<CODESPLIT>getHTMLElementContentRect<CODESPLIT>Calculates content rectangle of provided HTMLElement .<CODESPLIT>function getHTMLElementContentRect ( target ) { // Client width & height properties can't be // used exclusively as they provide rounded values. const { clientWidth , clientHeight } = target ; // By this condition we can catch all non-replaced inline, hidden and // detached elements. Though elements with width & height properties less // than 0.5 will be discarded as well. // // Without it we would need to implement separate methods for each of // those cases and it's not possible to perform a precise and performance // effective test for hidden elements. E.g. even jQuery's ':visible' filter // gives wrong results for elements with width & height less than 0.5. if ( ! clientWidth && ! clientHeight ) { return emptyRect ; } const styles = getWindowOf ( target ) . getComputedStyle ( target ) ; const paddings = getPaddings ( styles ) ; const horizPad = paddings . left + paddings . right ; const vertPad = paddings . top + paddings . bottom ; // Computed styles of width & height are being used because they are the // only dimensions available to JS that contain non-rounded values. It could // be possible to utilize the getBoundingClientRect if only it's data wasn't // affected by CSS transformations let alone paddings, borders and scroll bars. let width = toFloat ( styles . width ) , height = toFloat ( styles . height ) ; // Width & height include paddings and borders when the 'border-box' box // model is applied (except for IE). if ( styles . boxSizing === 'border-box' ) { // Following conditions are required to handle Internet Explorer which // doesn't include paddings and borders to computed CSS dimensions. // // We can say that if CSS dimensions + paddings are equal to the "client" // properties then it's either IE, and thus we don't need to subtract // anything, or an element merely doesn't have paddings/borders styles. if ( Math . round ( width + horizPad ) !== clientWidth ) { width -= getBordersSize ( styles , 'left' , 'right' ) + horizPad ; } if ( Math . round ( height + vertPad ) !== clientHeight ) { height -= getBordersSize ( styles , 'top' , 'bottom' ) + vertPad ; } } // Following steps can't be applied to the document's root element as its // client[Width/Height] properties represent viewport area of the window. // Besides, it's as well not necessary as the <html> itself neither has // rendered scroll bars nor it can be clipped. if ( ! isDocumentElement ( target ) ) { // In some browsers (only in Firefox, actually) CSS width & height // include scroll bars size which can be removed at this step as scroll // bars are the only difference between rounded dimensions + paddings // and "client" properties, though that is not always true in Chrome. const vertScrollbar = Math . round ( width + horizPad ) - clientWidth ; const horizScrollbar = Math . round ( height + vertPad ) - clientHeight ; // Chrome has a rather weird rounding of "client" properties. // E.g. for an element with content width of 314.2px it sometimes gives // the client width of 315px and for the width of 314.7px it may give // 314px. And it doesn't happen all the time. So just ignore this delta // as a non-relevant. if ( Math . abs ( vertScrollbar ) !== 1 ) { width -= vertScrollbar ; } if ( Math . abs ( horizScrollbar ) !== 1 ) { height -= horizScrollbar ; } } return createRectInit ( paddings . left , paddings . top , width , height ) ; }

0<CODESPLIT>https://github.com/ragingwind/eddystone-beacon-config/blob/0ccc4ade7732f1cbe1740a591d50fb91c2cb6e2b/eddystone-characteristics.js#L204-L224<CODESPLIT>BeaconPeriodCharateristic<CODESPLIT>tx power mode characteristic<CODESPLIT>function BeaconPeriodCharateristic ( opts ) { BeaconPeriodCharateristic . super_ . call ( this , objectAssign ( { uuid : 'ee0c2088-8786-40ba-ab96-99b91ac981d8' , properties : [ 'read' , 'write' ] , sizeof : 2 } , opts ) ) ; }

0<CODESPLIT>https://github.com/RusticiSoftware/TinCanJS/blob/8733f14ddcaeea77a0579505300bc8f38921a6b1/build/tincan.js#L2375-L2418<CODESPLIT><CODESPLIT>Retrieve a statement when used from a browser sends to the endpoint using the RESTful interface .<CODESPLIT>function ( stmts , cfg ) { this . log ( "saveStatements" ) ; var requestCfg = { url : "statements" , method : "POST" , headers : { } } , versionedStatement , versionedStatements = [ ] , requestAttachments = [ ] , boundary , i , j ; cfg = cfg || { } ; if ( stmts . length === 0 ) { if ( typeof cfg . callback !== "undefined" ) { cfg . callback ( new Error ( "no statements" ) , null ) ; return ; } return { err : new Error ( "no statements" ) , xhr : null } ; } for ( i = 0 ; i < stmts . length ; i += 1 ) { try { versionedStatement = stmts [ i ] . asVersion ( this . version ) ; } catch ( ex ) { if ( this . allowFail ) { this . log ( "[warning] statement could not be serialized in version (" + this . version + "): " + ex ) ; if ( typeof cfg . callback !== "undefined" ) { cfg . callback ( null , null ) ; return ; } return { err : null , xhr : null } ; } this . log ( "[error] statement could not be serialized in version (" + this . version + "): " + ex ) ; if ( typeof cfg . callback !== "undefined" ) { cfg . callback ( ex , null ) ; return ; } return { err : ex , xhr : null } ; } if ( stmts [ i ] . hasAttachmentWithContent ( ) ) { for ( j = 0 ; j < stmts [ i ] . attachments . length ; j += 1 ) { if ( stmts [ i ] . attachments [ j ] . content !== null ) { requestAttachments . push ( stmts [ i ] . attachments [ j ] ) ; } } } versionedStatements . push ( versionedStatement ) ; } if ( requestAttachments . length !== 0 ) { boundary = this . _getBoundary ( ) ; requestCfg . headers [ "Content-Type" ] = "multipart/mixed; boundary=" + boundary ; try { requestCfg . data = this . _getMultipartRequestData ( boundary , versionedStatements , requestAttachments ) ; } catch ( ex ) { if ( this . allowFail ) { this . log ( "[warning] multipart request data could not be created (attachments probably not supported): " + ex ) ; if ( typeof cfg . callback !== "undefined" ) { cfg . callback ( null , null ) ; return ; } return { err : null , xhr : null } ; } this . log ( "[error] multipart request data could not be created (attachments probably not supported): " + ex ) ; if ( typeof cfg . callback !== "undefined" ) { cfg . callback ( ex , null ) ; return ; } return { err : ex , xhr : null } ; } } else { requestCfg . headers [ "Content-Type" ] = "application/json" ; requestCfg . data = JSON . stringify ( versionedStatements ) ; } if ( typeof cfg . callback !== "undefined" ) { requestCfg . callback = cfg . callback ; } return this . sendRequest ( requestCfg ) ; }

0<CODESPLIT>https://github.com/acodercc/jsbison/blob/27f8c3bbfc917b93ab7097b0b877acd80863cf11/src/generator.js#L320-L363<CODESPLIT><CODESPLIT>构造用于推导语法解析树的预测分析表 LL ( 1 )<CODESPLIT>function ( ) { var self = this , item0 = new DataTypes . Item ( self . productions [ 0 ] , 0 , [ self . EOF ] ) , //S' -> S #dotPos=0 itemSet0 = new DataTypes . ItemSet ( ) ; itemSet0 . push ( item0 ) ; var firstItemSet = self . _closureItemSet ( itemSet0 ) , itemSets = this . itemSets = [ ] , itemSetsHash = { } , //这个hash是为了判断项集是否已存在(在closure扩展项集之前生成key来判断) itemSet , formState , curIdx , dotSymbolHash ; //这个hash是为了基于当前项集 和 各子项的dotSymbol进行goto运算时，避免已经goto运算过的dotSymbol再次运算 //为什么是itemSet0.key() 不是firstItemSet.key() //因为要用仅包含内核项的项集做KEY，下次GOTO运算的结果项集在未CLOSURE运算前， //就能判断是否已经存在于项集族中，如果已存在，就直接拿到ID，否则进行CLOSURE运算增加到项集族中 //避免没必要的CLOSURE计算 itemSetsHash [ itemSet0 . key ( ) ] = 0 ; itemSets . push ( firstItemSet ) ; curIdx = 0 ; while ( curIdx !== itemSets . length ) { //C0  itemSet = itemSets [ curIdx ] ; curIdx ++ ; dotSymbolHash = { } ; _ . each ( itemSet . subItems , function ( item ) { if ( item . dotSymbol && ! dotSymbolHash [ item . dotSymbol ] ) { dotSymbolHash [ item . dotSymbol ] = true ; var gotoItemSet = self . _gotoItemSet ( itemSet , item . dotSymbol ) ; if ( itemSetsHash [ gotoItemSet . key ( ) ] ) { itemSet . gotos [ item . dotSymbol ] = itemSetsHash [ gotoItemSet . key ( ) ] ; self . gotoItemSetRepeatCount = self . gotoItemSetRepeatCount || 0 ; self . gotoItemSetRepeatCount += 1 ; } else { itemSetsHash [ gotoItemSet . key ( ) ] = itemSets . length ; if ( gotoItemSet . subItems . length ) { gotoItemSet = self . _closureItemSet ( gotoItemSet ) ; } //原itemSet通过该dotSymbol，转换到的新itemSet的序号 itemSet . gotos [ item . dotSymbol ] = itemSets . length ; itemSets . push ( gotoItemSet ) ; console . log ( 'generate lr state:' + itemSets . length ) ; } } } ) ; } return itemSets ; }

1<CODESPLIT>https://github.com/kekee000/fonteditor-core/blob/e6b82f9d55dcc472ec0644681c7d33dd995b9364/src/ttf/table/glyf.js#L50-L77<CODESPLIT>travels<CODESPLIT>循环解析subset相关的glyf，包括复合字形相关的字形<CODESPLIT>function travels ( subsetMap ) { var newSubsetMap = { } ; Object . keys ( subsetMap ) . forEach ( function ( i ) { var index = + i ; parsedGlyfMap [ index ] = true ; // 当前的和下一个一样，或者最后一个无轮廓 if ( loca [ index ] === loca [ index + 1 ] ) { glyphs [ index ] = { contours : [ ] } ; } else { glyphs [ index ] = parse ( reader , ttf , startOffset + loca [ index ] ) ; } if ( glyphs [ index ] . compound ) { glyphs [ index ] . glyfs . forEach ( function ( g ) { if ( ! parsedGlyfMap [ g . glyphIndex ] ) { newSubsetMap [ g . glyphIndex ] = true ; } } ) ; } } ) ; if ( ! lang . isEmptyObject ( newSubsetMap ) ) { travels ( newSubsetMap ) ; } }

0<CODESPLIT>https://github.com/kaelzhang/neuron.js/blob/3e1eed28f08ab14f289f476f886ac7f095036e66/lib/module.js#L45-L103<CODESPLIT>generate_exports<CODESPLIT>Parse an id within an environment and do range mapping resolving applying aliases . Returns { Object } parsed object<CODESPLIT>function generate_exports ( module ) { // # 85 // Before module factory being invoked, mark the module as `loaded` // so we will not execute the factory function again. // `mod.loaded` indicates that a module has already been `require()`d // When there are cyclic dependencies, neuron will not fail. module . loaded = true ; // During the execution of factory, // the reference of `module.exports` might be changed. // But we still set the `module.exports` as `{}`, // because the module might be `require()`d during the execution of factory // if cyclic dependency occurs. var exports = module . exports = { } ; // TODO: // Calculate `filename` ahead of time var __filename // = module.filename = NEURON_CONF . resolve ( module . id ) ; var __dirname = dirname ( __filename ) ; // to keep the object mod away from the executing context of factory, // use `factory` instead `mod.factory`, // preventing user from fetching runtime data by 'this' var factory = module . factory ; factory ( create_require ( module ) , exports , module , __filename , __dirname ) ; return module . exports ; }

1<CODESPLIT>https://github.com/JeffHing/extend-this/blob/e8d0ebb4a5c010b15833c47e92540e49bf551f51/src/extendThis.js#L182-L258<CODESPLIT>parseMethodArgs<CODESPLIT>/ * Parses the arguments passed into a method .<CODESPLIT>function parseMethodArgs ( methodArgs ) { var firstArg = methodArgs . shift ( ) , source ; if ( isString ( firstArg ) ) { if ( methodArgs . length !== 1 ) { errorManager . illegalArgument ( firstArg , 'Requires a single property value' ) ; } source = { } ; source [ firstArg ] = methodArgs . shift ( ) ; } else if ( isObject ( firstArg ) ) { source = firstArg ; } else { errorManager . illegalArgument ( firstArg , 'No source object found.' ) ; } var overrideKeys = { } , // src keys which can override without error sourceKeys = { } , // src keys to pass to filters filters = [ ] ; // filters to process properties. // Iterate through the arguments separating them into selected // properties and filters. while ( methodArgs . length ) { var arg = methodArgs . shift ( ) ; if ( isString ( arg ) ) { // Is a string selector if ( ! selectorsManager . executeSelector ( source , arg , null , sourceKeys , overrideKeys ) ) { sourceKeys [ arg ] = arg ; } } else if ( isRegex ( arg ) ) { // Is a regular expression selector. extendSourceKeys ( sourceKeys , source , arg ) ; } else if ( isArray ( arg ) ) { // decompose array into separate arguments for ( var j = 0 ; j < arg . length ; j ++ ) { methodArgs . push ( arg [ j ] ) ; } } else if ( isFunction ( arg ) ) { // Is a filter. filters . push ( arg ) ; } else if ( isObject ( arg ) ) { // Is a selector with rename. for ( var sourceKey in arg ) { var targetKey = arg [ sourceKey ] ; if ( ! selectorsManager . executeSelector ( source , sourceKey , targetKey , sourceKeys , overrideKeys ) ) { sourceKeys [ sourceKey ] = targetKey ; } if ( ! isString ( sourceKeys [ sourceKey ] ) ) { errorManager . illegalArgument ( targetKey , 'Target property name is not a string.' ) ; } } } } // If no properties specified, default to all properties in source. if ( isEmpty ( sourceKeys ) ) { extendSourceKeys ( sourceKeys , source ) ; } return { source : source , filters : filters , sourceKeys : sourceKeys , overrideKeys : overrideKeys } ; }

1<CODESPLIT>https://github.com/blueflag/enty/blob/b9ed31e3a8a568d16bf3e1ca17c712958558e888/packages/react-enty/src/MultiMutationHockFactory.js#L12-L20<CODESPLIT>MultiMutationHockFactory<CODESPLIT>MultiMutationHockFactory<CODESPLIT>function MultiMutationHockFactory ( sideEffectList : Array < SideEffect > , hockOptions ? : HockOptionsInput ) : Function { const actionPrefix = 'ENTITY' ; const FETCH = ` ${ actionPrefix } ` ; const RECEIVE = ` ${ actionPrefix } ` ; const ERROR = ` ${ actionPrefix } ` ; Deprecated ( 'MultiMutationHockFactory has been deprecated in favor of much improved MultiRequestHock. Check the docs for usage instructions.' ) ; return EntityMutationHockFactory ( createAllRequestAction ( FETCH , RECEIVE , ERROR , sideEffectList ) , hockOptions ) ; }

0<CODESPLIT>https://github.com/adobe/brackets/blob/d5d00d43602c438266d32b8eda8f8a3ca937b524/src/language/JSUtils.js#L147-L153<CODESPLIT><CODESPLIT>/ * { <functionName > : function () {} }<CODESPLIT>function ( node ) { if ( node . right && node . right . type === "FunctionExpression" ) { if ( node . left && node . left . type === "MemberExpression" && node . left . property ) { _addResult ( node . left . property ) ; } } }

0<CODESPLIT>https://github.com/Lucifier129/react-lite/blob/b7586ae247615f2d4c4373f206e6c284d7931f81/addons/ReactChildren.js#L92-L98<CODESPLIT><CODESPLIT>PooledClass representing the bookkeeping associated with performing a child mapping . Allows avoiding binding callbacks .<CODESPLIT>function ( component , funcReturningState ) { return function ( a , b , c , d , e , f ) { var partialState = funcReturningState . call ( component , a , b , c , d , e , f ) ; if ( partialState ) { component . setState ( partialState ) ; } } ; }

1<CODESPLIT>https://github.com/mage/mage/blob/617968b6b9ebfa5371ae7e9115a5d1e0733a0ff9/lib/archivist/migration.js#L116-L141<CODESPLIT>getAvailableMigrations<CODESPLIT>Scans the hard disk for available migration files for this vault and returns the version names .<CODESPLIT>function getAvailableMigrations ( vaultName , cb ) { var path = configuration . getMigrationsPath ( vaultName ) ; fs . readdir ( path , function ( error , files ) { if ( error ) { if ( error . code === 'ENOENT' ) { logger . warning ( 'No migration folder found for vault' , vaultName , '(skipping).' ) ; return cb ( null , [ ] ) ; } return cb ( error ) ; } var result = [ ] ; for ( var i = 0 ; i < files . length ; i ++ ) { var file = files [ i ] ; var ext = extname ( file ) ; if ( mage . isCodeFileExtension ( ext ) ) { result . push ( basename ( file , ext ) ) ; } } cb ( null , result ) ; } ) ; }

1<CODESPLIT>https://github.com/adobe/brackets/blob/d5d00d43602c438266d32b8eda8f8a3ca937b524/src/language/JSONUtils.js#L191-L295<CODESPLIT>getContextInfo<CODESPLIT>Returns context info at a given position in editor<CODESPLIT>function getContextInfo ( editor , constPos , requireParent , requireNextToken ) { var pos , ctx , ctxPrev , ctxNext , offset , keyName , valueName , parentKeyName , isArray , exclusionList , hasColon , hasComma , hasBracket , shouldReplace ; pos = $ . extend ( { } , constPos ) ; ctx = TokenUtils . getInitialContext ( editor . _codeMirror , pos ) ; offset = TokenUtils . offsetInToken ( ctx ) ; if ( ctx . token && ctx . token . type === "string property" ) { // String literals used as keys. // Disallow hints if cursor is out of the string. if ( / ^['"]$ / . test ( ctx . token . string . substr ( - 1 , 1 ) ) && ctx . token . string . length !== 1 && ctx . token . end === pos . ch ) { return null ; } keyName = stripQuotes ( ctx . token . string ) ; // Get parent key name. if ( requireParent ) { ctxPrev = $ . extend ( true , { } , ctx ) ; parentKeyName = stripQuotes ( _getParentKeyName ( ctxPrev ) ) ; } // Check if the key is followed by a colon, so we should not append colon again. ctxNext = $ . extend ( true , { } , ctx ) ; TokenUtils . moveSkippingWhitespace ( TokenUtils . moveNextToken , ctxNext ) ; if ( ctxNext . token . type === null && ctxNext . token . string === ":" ) { shouldReplace = true ; } // Get an exclusion list of properties. pos = $ . extend ( { } , constPos ) ; exclusionList = _getExclusionList ( editor , pos ) ; return _createContextInfo ( ctx . token , TOKEN_KEY , offset , keyName , valueName , parentKeyName , null , exclusionList , shouldReplace ) ; } else if ( ctx . token && ( valueTokenTypes . indexOf ( ctx . token . type ) !== - 1 || ( ctx . token . type === null && regexAllowedChars . test ( ctx . token . string ) ) ) ) { // Boolean, String, Number and variable literal values. // Disallow hints if cursor is out of the string. if ( ctx . token . type === "string" && / ^['"]$ / . test ( ctx . token . string . substr ( - 1 , 1 ) ) && ctx . token . string . length !== 1 && ctx . token . end === pos . ch ) { return null ; } valueName = ctx . token . string ; // Check the current token if ( ctx . token . type === null ) { if ( ctx . token . string === ":" ) { hasColon = true ; } else if ( ctx . token . string === "," ) { hasComma = true ; } else if ( ctx . token . string === "[" ) { hasBracket = true ; } } // move context back and find corresponding key name. ctxPrev = $ . extend ( true , { } , ctx ) ; while ( TokenUtils . moveSkippingWhitespace ( TokenUtils . movePrevToken , ctxPrev ) ) { if ( ctxPrev . token . type === "string property" ) { keyName = stripQuotes ( ctxPrev . token . string ) ; break ; } else if ( ctxPrev . token . type === null ) { if ( ctxPrev . token . string === ":" ) { hasColon = true ; } else if ( ctxPrev . token . string === "," ) { hasComma = true ; } else if ( ctxPrev . token . string === "[" ) { hasBracket = true ; } else { return null ; } } else if ( ! hasComma ) { return null ; } } // If no key name or colon found OR // If we have a comma but no opening bracket, return null. if ( ( ! keyName || ! hasColon ) || ( hasComma && ! hasBracket ) ) { return null ; } else { isArray = hasBracket ; } // Get parent key name. if ( requireParent ) { ctxPrev = $ . extend ( true , { } , ctx ) ; parentKeyName = stripQuotes ( _getParentKeyName ( ctxPrev ) ) ; } // Check if we can replace the next token of a value. ctxNext = $ . extend ( true , { } , ctx ) ; TokenUtils . moveNextToken ( ctxNext ) ; if ( requireNextToken && valueTokenTypes . indexOf ( ctxNext . token . type ) !== - 1 ) { shouldReplace = true ; } return _createContextInfo ( ( shouldReplace ) ? ctxNext . token : ctx . token , TOKEN_VALUE , offset , keyName , valueName , parentKeyName , isArray , null , shouldReplace ) ; } return null ; }

0<CODESPLIT>https://github.com/gruntjs/grunt-init/blob/cbec886f26dce52d19c828df3fed031ce9767663/tasks/init.js#L351-L358<CODESPLIT><CODESPLIT>Given some number of licenses add properly - named license files to the files object .<CODESPLIT>function ( arg1 ) { if ( arg1 == null ) { return null ; } var args = [ name , 'root' ] . concat ( grunt . util . toArray ( arguments ) ) ; return helpers . getFile . apply ( helpers , args ) ; }

0<CODESPLIT>https://github.com/claudio-silva/grunt-angular-builder/blob/0aa4232257e4ae95d0aa9258ff0a91395383d8b7/tasks/lib/types.js#L230-L258<CODESPLIT><CODESPLIT>The execution context for the middleware stack . Contains shared information available throughout the middleware stack .<CODESPLIT>function ( eventName , handler ) { if ( ! this . _events [ eventName ] ) this . _events [ eventName ] = [ ] ; this . _events [ eventName ] . push ( handler ) ; }

1<CODESPLIT>https://github.com/canjs/can-define/blob/c3ea493a6a13587b679ac51077a8124c8c67280d/list/list.js#L365-L395<CODESPLIT><CODESPLIT>Adds a method name - The method name . where - Where items in the array should be added .<CODESPLIT>function ( where , name ) { var orig = [ ] [ name ] ; DefineList . prototype [ name ] = function ( ) { // Get the items being added. var args = [ ] , // Where we are going to add items. len = where ? this . _length : 0 , i = arguments . length , res , val ; // Go through and convert anything to a `map` that needs to be converted. while ( i -- ) { val = arguments [ i ] ; args [ i ] = this . __type ( val , i ) ; } // Call the original method. runningNative = true ; res = orig . apply ( this , args ) ; runningNative = false ; if ( ! this . comparator || args . length ) { queues . batch . start ( ) ; this . _triggerChange ( "" + len , "add" , args , undefined ) ; this . dispatch ( 'length' , [ this . _length , len ] ) ; queues . batch . stop ( ) ; } return res ; } ; }

0<CODESPLIT>https://github.com/ma-ha/rest-web-ui/blob/e2db0d55bb31a4f16fd07609ecae79156cb38378/html/modules/pong-nav-embed/pong-nav-embed.js#L29-L45<CODESPLIT>pongLayoutEditorDivHTML<CODESPLIT>======= Code for loadResourcesHtml hook ================================================<CODESPLIT>function pongLayoutEditorDivHTML ( divId , resourceURL , paramObj ) { log ( "layout-editor" , "divId=" + divId + " resourceURL=" + resourceURL ) ; if ( moduleConfig [ divId ] != null ) { var cnf = moduleConfig [ divId ] . layout ; moduleConfig [ divId ] . resourceURL = resourceURL ; moduleConfig [ divId ] . page_id = - 1 ; var contentItems = [ ] ; contentItems . push ( '<div id="' + divId + 'Inner" style="width:100%;height:100%">' ) ; contentItems . push ( '</div>' ) ; contentItems . push ( '<div class="layoutEditorZoom"><form><select id="' + divId + 'ZoomSel">' ) ; contentItems . push ( '<option value="1.0">100%</option>' ) ; contentItems . push ( '<option value="0.8">80%</option>' ) ; contentItems . push ( '<option value="0.6">60%</option>' ) ; contentItems . push ( '<option value="0.5">50%</option>' ) ; contentItems . push ( '<option value="0.4" selected="selected">40%</option>' ) ; contentItems . push ( '<option value="0.3">30%</option>' ) ; contentItems . push ( '<option value="0.2">20%</option>' ) ; contentItems . push ( '</select></div>' ) ; contentItems . push ( '<script>' ) ; contentItems . push ( '$(function() { ' ) ; contentItems . push ( '    $( "#' + divId + 'ZoomSel" ).change( ' ) ; contentItems . push ( '       function( event ) { ' ) ; contentItems . push ( '           udateModuleData( "' + divId + '", ' + JSON . stringify ( paramObj ) + ' ); ' ) ; contentItems . push ( '          return false;  ' ) ; contentItems . push ( '       }' ) ; contentItems . push ( '     );  ' ) ; contentItems . push ( ' }); ' ) ; contentItems . push ( '</script>' ) ; $ ( "#" + divId ) . html ( contentItems . join ( "\n" ) ) ; pongLayoutEditorRenderHTML ( divId , resourceURL , paramObj , cnf ) ; } else { $ ( "#" + divId ) . html ( '<div id="' + divId + 'layout-editor_Div" class="layout-editor">ERROR [1]</div>' ) ; publishEvent ( 'feedback' , { 'text' : 'Error: Layout config required!' } ) } }

1<CODESPLIT>https://github.com/treshugart/ubercod/blob/772accd6957acf24b59ca56fb40253a1e1760e77/index.js#L85-L87<CODESPLIT>resolveInst<CODESPLIT>Resolves the dependency based on if it s a singleton or transient dependency . Both forms allow arguments . If it s a singleton then no arguments are allowed . If it s transient named arguments are allowed .<CODESPLIT>function resolveInst ( bind , args ) { return isTransient ? getInst ( bind , args ) : cache || ( cache = getInst ( bind ) ) ; }

0<CODESPLIT>https://github.com/easysoft/zui/blob/a5af01d76e9481d618d6abd3e873a8ee7e49c59f/dist/js/zui.js#L4908-L4934<CODESPLIT><CODESPLIT>/ * listen the touch event<CODESPLIT>function ( r , g , b , a ) { var that = this ; that . r = that . g = that . b = 0 ; that . a = 1 ; if ( isNotUndefined ( a ) ) that . a = clamp ( number ( a ) , 1 ) ; if ( isNotUndefined ( r ) && isNotUndefined ( g ) && isNotUndefined ( b ) ) { that . r = convertToRgbInt ( r ) ; that . g = convertToRgbInt ( g ) ; that . b = convertToRgbInt ( b ) ; } else if ( isNotUndefined ( r ) ) { var type = typeof ( r ) ; if ( type == STR_STRING ) { r = r . toLowerCase ( ) ; if ( r === 'transparent' ) { that . a = 0 ; } else if ( namedColors [ r ] ) { this . rgb ( hexToRgb ( namedColors [ r ] ) ) ; } else if ( r . indexOf ( 'rgb' ) === 0 ) { var rgbsArr = r . substring ( r . indexOf ( '(' ) + 1 , r . lastIndexOf ( ')' ) ) . split ( ',' , 4 ) ; that . rgb ( { r : rgbsArr [ 0 ] , g : rgbsArr [ 1 ] , b : rgbsArr [ 2 ] , a : rgbsArr [ 3 ] , } ) ; } else { that . rgb ( hexToRgb ( r ) ) ; } } else if ( type == 'number' && isUndefined ( g ) ) { that . r = that . g = that . b = convertToRgbInt ( r ) ; } else if ( type == STR_OBJECT && isNotUndefined ( r . r ) ) { that . r = convertToRgbInt ( r . r ) ; if ( isNotUndefined ( r . g ) ) that . g = convertToRgbInt ( r . g ) ; if ( isNotUndefined ( r . b ) ) that . b = convertToRgbInt ( r . b ) ; if ( isNotUndefined ( r . a ) ) that . a = clamp ( number ( r . a ) , 1 ) ; } else if ( type == STR_OBJECT && isNotUndefined ( r . h ) ) { var hsl = { h : clamp ( number ( r . h ) , N360 ) , s : 1 , l : 1 , a : 1 } ; if ( isNotUndefined ( r . s ) ) hsl . s = clamp ( number ( r . s ) , 1 ) ; if ( isNotUndefined ( r . l ) ) hsl . l = clamp ( number ( r . l ) , 1 ) ; if ( isNotUndefined ( r . a ) ) hsl . a = clamp ( number ( r . a ) , 1 ) ; that . rgb ( hslToRgb ( hsl ) ) ; } } }

0<CODESPLIT>https://github.com/YannickBochatay/JSYG.Path/blob/d5d8223fee6f6c8697e875196afbe6e013369e21/JSYG.Path.js#L58-L67<CODESPLIT>rel2absSeg<CODESPLIT>Chemins SVG<CODESPLIT>function rel2absSeg ( jPath , ind ) { var seg = jPath . getSeg ( ind ) , letter = seg . pathSegTypeAsLetter . toLowerCase ( ) , args , ref ; if ( seg . pathSegTypeAsLetter !== letter ) return ; //déjà en absolu  args = [ ind , letter . toUpperCase ( ) ] ; ref = jPath . getCurPt ( ind ) ; if ( letter === 'h' ) args . push ( ref . x + seg . x ) ; else if ( letter === 'v' ) args . push ( ref . y + seg . y ) ; else if ( letter === "m" ) args . push ( seg . x , seg . y ) ; else if ( letter !== "z" ) { args . push ( ref . x + seg . x , ref . y + seg . y ) ; switch ( letter ) { case 'c' : args . push ( ref . x + seg . x1 , ref . y + seg . y1 , ref . x + seg . x2 , ref . y + seg . y2 ) ; break ; case 'q' : args . push ( ref . x + seg . x1 , ref . y + seg . y1 ) ; break ; case 'a' : args . push ( seg . r1 , seg . r2 , seg . angle , seg . largArcFlag , seg . sweepFlag ) ; break ; case 's' : args . push ( ref . x + seg . x2 , ref . y + seg . y2 ) ; break ; } } jPath . replaceSeg . apply ( jPath , args ) ; }

0<CODESPLIT>https://github.com/zenozeng/node-yaqrcode/blob/e5e423f14dacea0c748a8414219cc52cefc8397d/qrcode.js#L1093-L1152<CODESPLIT><CODESPLIT>--------------------------------------------------------------------- qr8BitByte ---------------------------------------------------------------------<CODESPLIT>function ( ) { var _buffer = new Array ( ) ; var _length = 0 ; var _this = { } ; _this . getBuffer = function ( ) { return _buffer ; } ; _this . getAt = function ( index ) { var bufIndex = Math . floor ( index / 8 ) ; return ( ( _buffer [ bufIndex ] >>> ( 7 - index % 8 ) ) & 1 ) == 1 ; } ; _this . put = function ( num , length ) { for ( var i = 0 ; i < length ; i += 1 ) { _this . putBit ( ( ( num >>> ( length - i - 1 ) ) & 1 ) == 1 ) ; } } ; _this . getLengthInBits = function ( ) { return _length ; } ; _this . putBit = function ( bit ) { var bufIndex = Math . floor ( _length / 8 ) ; if ( _buffer . length <= bufIndex ) { _buffer . push ( 0 ) ; } if ( bit ) { _buffer [ bufIndex ] |= ( 0x80 >>> ( _length % 8 ) ) ; } _length += 1 ; } ; return _this ; }

1<CODESPLIT>https://github.com/kgryte/resolve-app-path/blob/d857f9210e91d528cc7e8385de97c1c9f9ca17d8/lib/index.js#L23-L58<CODESPLIT>resolve<CODESPLIT>RESOLVE // FUNCTION : resolve () Resolves an application s path .<CODESPLIT>function resolve ( ) { var parts , flg , len , str , i ; // CASE 1: this module is loaded from a global path... len = gpaths . length ; for ( i = 0 ; i < len ; i ++ ) { str = dir . substring ( 0 , gpaths [ i ] . length ) ; if ( str === gpaths [ i ] ) { // We are loaded from a global path. Resort to finding the nearest `package.json` walking up from the current working directory... str = pkgdir ( ) ; if ( str ) { return str ; } flg = true ; } } // CASE 2: this module is a local module dependency; in which case, split on `node_modules`... parts = dir . split ( path . sep + 'node_modules' ) ; if ( parts . length > 1 ) { // We are a nested module. Assume that the top-level node module directory is the application root... return parts [ 0 ] ; } // CASE 3: possibly a git submodule, copy and paste, or some other dependency pattern; in which case, find the nearest `package.json` walking up from the current working directory... if ( ! flg ) { str = pkgdir ( ) ; if ( str ) { return str ; } } // CASE 4: nothing worked. Just use the main module... return path . dirname ( require . main . filename ) ; }

1<CODESPLIT>https://github.com/steeplejack-js/injector/blob/b9deb9e5f36d2038b7b039525da60366348dea5b/src/index.js#L23-L31<CODESPLIT>construct<CODESPLIT>/ * Files Construct<CODESPLIT>function construct ( constructor , args ) { function Factory ( ) { return constructor . apply ( this , args ) ; } Factory . prototype = constructor . prototype ; return new Factory ( ) ; }

0<CODESPLIT>https://github.com/byron-dupreez/aws-core-utils/blob/2530155b5afc102f61658b28183a16027ecae86a/stages.js#L140-L152<CODESPLIT>buildSchema<CODESPLIT>Configures the given context with the given stage handling settings but only if stage handling is not already configured on the given context OR if forceConfiguration is true . The stage handling settings determine how { @linkcode resolveStage } { @linkcode toStageQualifiedStreamName } { @linkcode extractStageFromQualifiedStreamName } { @linkcode toStageQualifiedResourceName } { @linkcode extractStageFromQualifiedStreamName } and other internal functions will behave when invoked .<CODESPLIT>function buildSchema ( models , typeMap ) { let type ; var _models$map$reduce = models . map ( model => { type = typeMap [ model . modelName ] ; return { query : ( 0 , _buildQuery2 . default ) ( model , type ) , mutation : ( 0 , _buildMutation2 . default ) ( model , type ) } ; } ) . reduce ( ( fields , modelField ) => { fields . query = ( 0 , _assign2 . default ) ( { } , fields . query , modelField . query ) ; fields . mutation = ( 0 , _assign2 . default ) ( { } , fields . mutation , modelField . mutation ) ; return fields ; } , { query : { } , mutation : { } } ) ; const query = _models$map$reduce . query ; const mutation = _models$map$reduce . mutation ; return { query : query , mutation : mutation } ; }

0<CODESPLIT>https://github.com/neyric/webhookit/blob/13abf6f072e23d536432235da78fd3e4e5d742b6/public/javascripts/yui/calendar/calendar.js#L4087-L4100<CODESPLIT><CODESPLIT>Gets the index of a date field array [ yyyy mm dd ] in the current list of selected dates .<CODESPLIT>function ( date ) { var minDate = this . cfg . getProperty ( DEF_CFG . MINDATE . key ) , maxDate = this . cfg . getProperty ( DEF_CFG . MAXDATE . key ) , dm = DateMath ; if ( minDate ) { minDate = dm . clearTime ( minDate ) ; } if ( maxDate ) { maxDate = dm . clearTime ( maxDate ) ; } var clearedDate = new Date ( date . getTime ( ) ) ; clearedDate = dm . clearTime ( clearedDate ) ; return ( ( minDate && clearedDate . getTime ( ) < minDate . getTime ( ) ) || ( maxDate && clearedDate . getTime ( ) > maxDate . getTime ( ) ) ) ; }

1<CODESPLIT>https://github.com/basisjs/basisjs/blob/8571903014b207a09d45ad2d1bfba277bf21289b/src/basis/data/dataset/Merge.js#L315-L326<CODESPLIT><CODESPLIT>Adds new dataset .<CODESPLIT>function ( dataset ) { arrayRemove ( this . sources , dataset ) ; // remove event listeners from dataset if ( this . listen . source ) dataset . removeHandler ( this . listen . source , this ) ; // process removing dataset objects and update member map var memberMap = this . members_ ; for ( var objectId in dataset . items_ ) memberMap [ objectId ] . count -- ; }

1<CODESPLIT>https://github.com/mike-goodwin/connect-azuretables/blob/b148c19ee6abcf636fd58d8c983aed0a3d0d21b2/lib/connect-azuretables.js#L264-L275<CODESPLIT>getExpiryDate<CODESPLIT>expiry date for sessions<CODESPLIT>function getExpiryDate ( store , data ) { var offset ; if ( data . cookie . originalMaxAge ) { offset = data . cookie . originalMaxAge ; } else { offset = store . sessionTimeOut * 60000 ; } return offset ? new Date ( Date . now ( ) + offset ) : null ; }

0<CODESPLIT>https://github.com/grasshopper-cms/grasshopper-core-nodejs/blob/8fabc3bfc5b18855ead443db0644608a277d0ea0/dev/server/public/admin/vendor/svg-edit-2.7/svgtransformlist.js#L24-L50<CODESPLIT><CODESPLIT>Helper function .<CODESPLIT>function ( time ) { var t = this ; time = time ? time : ( this . factory . time . time ? this . factory . time . time : this . factory . time . getTime ( ) ) ; this . base ( time ) ; this . meridiumText = this . _isPM ( ) ? 'PM' : 'AM' ; this . meridium = $ ( [ '<ul class="flip-clock-meridium">' , '<li>' , '<a href="#">' + this . meridiumText + '</a>' , '</li>' , '</ul>' ] . join ( '' ) ) ; this . meridium . insertAfter ( this . factory . lists [ this . factory . lists . length - 1 ] . $obj ) ; }

1<CODESPLIT>https://github.com/primus/ejson/blob/249b4aced9b66d11a2cac1fa8cc9037dcf1760a0/vendor/ejson.js#L295-L310<CODESPLIT><CODESPLIT>DOES NOT RECURSE . For actually getting the fully - changed value use EJSON . fromJSONValue<CODESPLIT>function ( value ) { if ( typeof value === 'object' && value !== null ) { if ( _ . size ( value ) <= 2 && _ . all ( value , function ( v , k ) { return typeof k === 'string' && k . substr ( 0 , 1 ) === '$' ; } ) ) { for ( var i = 0 ; i < builtinConverters . length ; i ++ ) { var converter = builtinConverters [ i ] ; if ( converter . matchJSONValue ( value ) ) { return converter . fromJSONValue ( value ) ; } } } } return value ; }

1<CODESPLIT>https://github.com/reptilbud/hapi-swagger/blob/8a4a1059f060a7100270e837d2759c6a2b9c7e74/public/swaggerui/swagger-ui.js#L16348-L16355<CODESPLIT>parseModuleSpecifier<CODESPLIT>ECMA - 262 15 . 2 Modules<CODESPLIT>function parseModuleSpecifier ( ) { var node = new Node ( ) ; if ( lookahead . type !== Token . StringLiteral ) { throwError ( Messages . InvalidModuleSpecifier ) ; } return node . finishLiteral ( lex ( ) ) ; }

1<CODESPLIT>https://github.com/pissang/claygl/blob/b157bb50cf8c725fa20f90ebb55481352777f0a7/dist/claygl.es.js#L17778-L17806<CODESPLIT><CODESPLIT>Update boundingBox of Geometry<CODESPLIT>function ( ) { var bbox = this . boundingBox ; if ( ! bbox ) { bbox = this . boundingBox = new BoundingBox ( ) ; } var posArr = this . attributes . position . value ; if ( posArr && posArr . length ) { var min = bbox . min ; var max = bbox . max ; var minArr = min . array ; var maxArr = max . array ; vec3 . set ( minArr , posArr [ 0 ] , posArr [ 1 ] , posArr [ 2 ] ) ; vec3 . set ( maxArr , posArr [ 0 ] , posArr [ 1 ] , posArr [ 2 ] ) ; for ( var i = 3 ; i < posArr . length ; ) { var x = posArr [ i ++ ] ; var y = posArr [ i ++ ] ; var z = posArr [ i ++ ] ; if ( x < minArr [ 0 ] ) { minArr [ 0 ] = x ; } if ( y < minArr [ 1 ] ) { minArr [ 1 ] = y ; } if ( z < minArr [ 2 ] ) { minArr [ 2 ] = z ; } if ( x > maxArr [ 0 ] ) { maxArr [ 0 ] = x ; } if ( y > maxArr [ 1 ] ) { maxArr [ 1 ] = y ; } if ( z > maxArr [ 2 ] ) { maxArr [ 2 ] = z ; } } min . _dirty = true ; max . _dirty = true ; } }

1<CODESPLIT>https://github.com/incompl/cloak/blob/fc5c8382c4fdb8de129af4f54287aac09ce75cc8/examples/grow21/client/lib/crafty.js#L430-L449<CODESPLIT><CODESPLIT>@ # . attr @comp Crafty Core @sign public this . attr ( String property * value ) @param property - Property of the entity to modify @param value - Value to set the property to @sign public this . attr ( Object map ) @param map - Object where the key is the property to modify and the value as the property value @trigger Change - when properties change - { key : value }<CODESPLIT>function ( key , value ) { if ( arguments . length === 1 ) { //if just the key, return the value if ( typeof key === "string" ) { return this [ key ] ; } //extend if object this . extend ( key ) ; this . trigger ( "Change" , key ) ; //trigger change event return this ; } //if key value pair this [ key ] = value ; var change = { } ; change [ key ] = value ; this . trigger ( "Change" , change ) ; //trigger change event return this ; }

1<CODESPLIT>https://github.com/origin1tech/chek/blob/6bc3ab0ac36126cc7918a244a606009749897b2e/dist/modules/function.js#L46-L61<CODESPLIT>tryWrap<CODESPLIT>Try Wrap Generic helper for calling try catch on a method . If a default method is provided it will return in on error otherwise it will return null .<CODESPLIT>function tryWrap ( fn ) { var args = [ ] ; for ( var _i = 1 ; _i < arguments . length ; _i ++ ) { args [ _i - 1 ] = arguments [ _i ] ; } return function ( def ) { try { return fn . apply ( void 0 , args ) ; } catch ( ex ) { if ( is_1 . isFunction ( def ) ) return def ( ex ) ; return to_1 . toDefault ( def ) ; } } ; }

0<CODESPLIT>https://github.com/JasonEtco/actions-toolkit/blob/294ac11efd551cc382f3fed79c190e536069d6ce/bin/create-action.js#L20-L23<CODESPLIT>getActionMetadata<CODESPLIT>Reads a template file from disk .<CODESPLIT>async function getActionMetadata ( ) { return prompt ( [ { type : 'input' , name : 'name' , message : 'What is the name of your action?' , initial : 'Your action name' , validate : isNotEmpty } , { type : 'input' , name : 'description' , message : 'What is a short description of your action?' , initial : 'A description of your action' , validate : isNotEmpty } , { type : 'autocomplete' , name : 'icon' , message : 'Choose an icon for your action. Visit https://feathericons.com for a visual reference.' , choices : icons , limit : 10 } , { type : 'autocomplete' , name : 'color' , message : 'Choose a background color background color used in the visual workflow editor for your action.' , choices : colors } ] ) }

1<CODESPLIT>https://github.com/Kitware/paraviewweb/blob/ebff9dbeefee70225c349077e25280c56d39920e/src/Common/Core/CompositeClosureHelper/index.js#L53-L74<CODESPLIT>destroy<CODESPLIT>---------------------------------------------------------------------------- Add destroy function ----------------------------------------------------------------------------<CODESPLIT>function destroy ( publicAPI , model = { } ) { const previousDestroy = publicAPI . destroy ; if ( ! model . subscriptions ) { model . subscriptions = [ ] ; } publicAPI . destroy = ( ) => { if ( previousDestroy ) { previousDestroy ( ) ; } while ( model . subscriptions && model . subscriptions . length ) { model . subscriptions . pop ( ) . unsubscribe ( ) ; } Object . keys ( model ) . forEach ( ( field ) => { delete model [ field ] ; } ) ; // Flag the instance beeing deleted model . deleted = true ; } ; }

1<CODESPLIT>https://github.com/buzzin0609/tagbuildr/blob/9d6a52ad51c0fc3230de2da1e8e3f63f95a6e542/src/handleClassesAndId.js#L13-L27<CODESPLIT>handleClassesAndId<CODESPLIT>Remove the css style classes and ids then replace them with tagbuildr attribute strings to use later on<CODESPLIT>function handleClassesAndId ( str ) { return str . replace ( / (.*?)([\.|#].[^|]*)(.*) / , function ( fullStr , tag , classAndIds , end ) { if ( classAndIds [ 0 ] === '|' ) { return fullStr ; } const clsIdArr = classAndIds . split ( / (\..[^\.|#]*) / ) . filter ( Boolean ) ; const returnArr = [ ] ; let i = clsIdArr . length ; while ( i -- ) { returnArr . push ( ` ${ attrType [ clsIdArr [ i ] [ 0 ] ] } ${ clsIdArr [ i ] . substr ( 1 ) } ` ) ; } return tag + returnArr . join ( '' ) + end ; } ) ; }

0<CODESPLIT>https://github.com/kogarashisan/LiquidLava/blob/fb8618821a51fad373106b5cc9247464b0a23cf6/lib/packages/parsers.js#L2175-L2189<CODESPLIT><CODESPLIT>Parse { @link _cStaticEval } . Warning! Inner argument should depend only on static data . Bindings are allowed but not recommended cause at the moment when template is rendered - they may be dirty<CODESPLIT>function ( raw_directive ) { if ( Lava . schema . DEBUG && ! raw_directive . content ) Lava . t ( "empty attach_directives" ) ; var blocks = Lava . parsers . Common . asBlocks ( raw_directive . content ) , sugar = blocks [ 0 ] , directives = blocks . slice ( 1 ) , i , count ; if ( Lava . schema . DEBUG ) { if ( sugar . type != 'tag' || sugar . content || directives . length == 0 ) Lava . t ( "Malformed attach_directives" ) ; for ( i = 0 , count = directives . length ; i < count ; i ++ ) { if ( directives [ i ] . type != 'directive' ) Lava . t ( "Malformed attach_directives" ) ; } } sugar . content = directives ; return Lava . parsers . Common . compileAsView ( [ sugar ] ) ; }

0<CODESPLIT>https://github.com/poynt/traildb-node/blob/c174ae3e417877eeeae6e0e1af013a7182f6c65a/lib/traildb.js#L324-L359<CODESPLIT><CODESPLIT>TrailDBConstructor class Construct a new TrailDB . Initialize a new TrailDBConstructor .<CODESPLIT>function ( trail , options ) { this . trail = trail ; this . options = options || { } ; this . cursor = lib . tdb_cursor_new ( this . trail . tdb . _db ) ; /*\   |*| Filter logic   \*/ if ( typeof this . options . filter != 'undefined' ) { const err = lib . tdb_cursor_set_event_filter ( this . cursor , this . options . filter ) ; if ( err ) { throw new TrailDBError ( 'Unable to set event filter: ' + this . trail . id ) ; } } const r = lib . tdb_get_trail ( this . cursor , this . trail . id ) ; if ( r ) { throw new TrailDBError ( 'Failed to open trail cursor: ' + this . trail . id ) ; } return this ; }

0<CODESPLIT>https://github.com/osdat/jsdataframe/blob/d9f2028b33f9565c92329ccbca8c0fc1e865d97e/spec/dataframe-spec.js#L2477-L2480<CODESPLIT><CODESPLIT>Helper for subsetting joinDf by only selecting rows with _join column containing values in indicatorValues<CODESPLIT>function ( subset , key ) { return [ key . nRow ( ) , key . nCol ( ) , key . at ( 0 , 'D' ) , key . at ( 0 , 'C' ) , ] ; }

0<CODESPLIT>https://github.com/TencentWSRD/connect-cas2/blob/b01415629abc08bb4a462873c0d53577481bd52d/lib/validate.js#L151-L175<CODESPLIT>validate<CODESPLIT>Validate ticket from CAS server<CODESPLIT>function validate ( req , res , callback , options ) { // check ticket first` var ticket = req . query && req . query . ticket || null ; var session = req . session ; var lastUrl = utils . getLastUrl ( req , options ) ; var logger = utils . getLogger ( req , options ) ; logger . info ( 'Start validating ticket...' ) ; if ( ticket ) { logger . info ( 'Find ticket in query' , ticket ) ; if ( session && session . cas && session . cas . st && session . cas . st === ticket ) { logger . info ( 'Ticket in query is equal to the one in session, go last url: ' + lastUrl ) ; return callback ( function ( req , res , next ) { res . redirect ( 302 , lastUrl ) ; } ) ; } validateTicket ( req , options , function ( err , response ) { /* istanbul ignore if */ if ( err ) { return callback ( function ( req , res , next ) { res . status ( 500 ) . send ( { message : 'Receive response from cas when validating ticket, but request failed because an error happened.' , error : err . message } ) ; } ) ; } logger . info ( 'Receive from CAS server, status: ' + response . status ) ; if ( response . status === 200 ) { parseCasResponse ( response . body , logger , function ( err , info ) { if ( err ) { var resBody = { error : err } ; if ( info && info . message ) resBody . message = info . message ; return callback ( function ( req , res , next ) { res . status ( 500 ) . send ( resBody ) ; } ) ; } if ( ! info || ( info && ! info . user ) ) { return callback ( function ( req , res , next ) { res . status ( 401 ) . send ( { message : 'Receive response from CAS when validating ticket, but the validation is failed.' } ) ; } ) } var pgtIou = info . proxyGrantingTicket ; delete info . proxyGrantingTicket ; req . session . cas = info ; var ticket = req . query . ticket ; req . session . cas . st = ticket ; if ( options . slo ) { req . sessionStore . set ( ticket , { sid : req . session . id , cookie : req . session . cookie } , function ( err ) { /* istanbul ignore if */ if ( err ) { logger . info ( 'Trying to store ticket in sessionStore for ssoff failed!' ) ; logger . error ( err ) ; } } ) ; } if ( ! pgtIou ) { if ( options . paths . proxyCallback ) { logger . error ( 'pgtUrl is specific, but havn\'t find pgtIou from CAS validation response! Response status 401.' ) ; return callback ( function ( req , res , next ) { res . status ( 401 ) . send ( { message : 'pgtUrl is specific, but havn\'t find pgtIou from CAS validation response!' } ) ; } ) ; } else { logger . info ( 'None-proxy mode, validate ticket succeed, redirecting to lastUrl: ' + lastUrl ) ; req . session . save ( function ( err ) { /* istanbul ignore if */ if ( err ) { logger . error ( 'Trying to save session failed!' ) ; logger . error ( err ) ; return callback ( function ( req , res , next ) { res . status ( 500 ) . send ( { message : 'Trying to save session failed!' , error : err } ) ; } ) ; } lastUrl = getLastUrl ( req , res , options , logger , lastUrl ) ; return callback ( function ( req , res , next ) { res . redirect ( 302 , lastUrl ) ; } ) ; } ) ; } return ; } retrievePGTFromPGTIOU ( req , res , callback , pgtIou , options ) ; } ) ; } else { logger . error ( 'Receive response from cas when validating ticket, but request failed with status code: ' + response . status + '!' ) ; callback ( function ( req , res , next ) { res . status ( 401 ) . send ( { message : 'Receive response from cas when validating ticket, but request failed with status code: ' + response . status + '.' } ) ; } ) ; } } ) ; } else { lastUrl = utils . getLastUrl ( req , options ) ; logger . info ( 'Can\' find ticket in query, redirect to last url: ' + lastUrl ) ; return callback ( function ( req , res , next ) { res . redirect ( 302 , lastUrl ) ; } ) ; } }

0<CODESPLIT>https://github.com/ecomfe/zrender/blob/30321b57cba3149c30eacb0c1e18276f0f001b9f/src/mixin/Animatable.js#L141-L143<CODESPLIT>animateToShallow<CODESPLIT>Caution : this method will stop previous animation . So do not use this method to one element twice before animation starts unless you know what you are doing . @param { Object } target @param { number } [ time = 500 ] Time in ms @param { string } [ easing = linear ] @param { number } [ delay = 0 ] @param { Function } [ callback ] @param { Function } [ forceAnimate ] Prevent stop animation and callback immediently when target values are the same as current values .<CODESPLIT>function animateToShallow ( animatable , path , source , target , time , delay , reverse ) { var objShallow = { } ; var propertyCount = 0 ; for ( var name in target ) { if ( ! target . hasOwnProperty ( name ) ) { continue ; } if ( source [ name ] != null ) { if ( isObject ( target [ name ] ) && ! isArrayLike ( target [ name ] ) ) { animateToShallow ( animatable , path ? path + '.' + name : name , source [ name ] , target [ name ] , time , delay , reverse ) ; } else { if ( reverse ) { objShallow [ name ] = source [ name ] ; setAttrByPath ( animatable , path , name , target [ name ] ) ; } else { objShallow [ name ] = target [ name ] ; } propertyCount ++ ; } } else if ( target [ name ] != null && ! reverse ) { setAttrByPath ( animatable , path , name , target [ name ] ) ; } } if ( propertyCount > 0 ) { animatable . animate ( path , false ) . when ( time == null ? 500 : time , objShallow ) . delay ( delay || 0 ) ; } }

1<CODESPLIT>https://github.com/junosuarez/path-trie/blob/bd7212bb8d9ef756a0039c9743738b5add69bce9/index.js#L35-L44<CODESPLIT>del<CODESPLIT>( this : Trie path : Path ) = > void<CODESPLIT>function del ( path ) { var pos = splitPath ( path ) . reduce ( function ( t , segment ) { return t ? t [ segment ] : undefined } , this ) if ( typeof pos === 'object' ) { delete pos [ '@' ] } return this ; }

1<CODESPLIT>https://github.com/bem-archive/bem-tools/blob/c3a167e86deb7c5e178c18244f3190dfda101f90/lib/data/d3.js#L6006-L6019<CODESPLIT>revalue<CODESPLIT>Recursively re - evaluates the node value .<CODESPLIT>function revalue ( node , depth ) { var children = node . children , v = 0 ; if ( children && ( n = children . length ) ) { var i = - 1 , n , j = depth + 1 ; while ( ++ i < n ) v += revalue ( children [ i ] , j ) ; } else if ( value ) { v = + value . call ( hierarchy , d3_layout_hierarchyInline ? node : node . data , depth ) || 0 ; } if ( value ) node . value = v ; return v ; }

0<CODESPLIT>https://github.com/pissang/claygl/blob/b157bb50cf8c725fa20f90ebb55481352777f0a7/dist/claygl.es.js#L5668-L5711<CODESPLIT><CODESPLIT>Trigger event<CODESPLIT>function ( name , action , context ) { if ( ! name || ! action ) { return ; } var handlers = this . __handlers__ || ( this . __handlers__ = { } ) ; if ( ! handlers [ name ] ) { handlers [ name ] = [ ] ; } else { if ( this . has ( name , action ) ) { return ; } } var handler = new Handler ( action , context || this ) ; handlers [ name ] . push ( handler ) ; return this ; }

0<CODESPLIT>https://github.com/SAP/openui5/blob/8a832fca01cb1cdf8df589788e0c5723e2a33c70/src/sap.ui.core/src/sap/ui/events/PseudoEvents.js#L20-L22<CODESPLIT><CODESPLIT>Convenience method to check an event for a certain combination of modifier keys<CODESPLIT>function ( ) { var iLastTimeStamp = - 1 , iLastTimeoutId = - 1 , iWaitTimeout = 1000 , sCurrentKeyPrefix = "" , fnTimedKeydown = function ( iTimeStamp , iKeyCode ) { var aMatchingItems ; //the previous call was more than a second ago or this is the first call if ( iLastTimeStamp + iWaitTimeout < iTimeStamp ) { sCurrentKeyPrefix = "" ; } else { if ( iLastTimeoutId !== - 1 ) { clearTimeout ( iLastTimeoutId ) ; iLastTimeoutId = - 1 ; } } sCurrentKeyPrefix += String . fromCharCode ( iKeyCode ) . toLowerCase ( ) ; aMatchingItems = this . _getVisibleItems ( ) . filter ( function ( item ) { return item . getKey ( ) . indexOf ( sCurrentKeyPrefix ) === 0 ; //starts with the current prefix } ) ; if ( aMatchingItems . length > 1 ) { iLastTimeoutId = setTimeout ( function ( ) { this . setSelectedValue ( sCurrentKeyPrefix ) ; sCurrentKeyPrefix = "" ; iLastTimeoutId = - 1 ; } . bind ( this ) , iWaitTimeout ) ; } else if ( aMatchingItems . length === 1 ) { this . setSelectedValue ( aMatchingItems [ 0 ] . getKey ( ) ) ; sCurrentKeyPrefix = "" ; } else { sCurrentKeyPrefix = "" ; } iLastTimeStamp = iTimeStamp ; } ; return fnTimedKeydown ; }

0<CODESPLIT>https://github.com/bigeasy/magazine/blob/ad6fd7228aea22d840cca41187236608d30fbca5/magazine.js#L112-L144<CODESPLIT>captureCallback<CODESPLIT>TODO Legacy do not document use expire or iterator interface .<CODESPLIT>function captureCallback ( nodeFire , eventType , callback ) { const key = eventType + '::' + nodeFire . toString ( ) ; callback . $nodeFireCallbacks = callback . $nodeFireCallbacks || { } ; callback . $nodeFireCallbacks [ key ] = callback . $nodeFireCallbacks [ key ] || [ ] ; const nodeFireCallback = function ( snap , previousChildKey ) { // eslint-disable-next-line no-invalid-this runGenerator ( callback . call ( this , new Snapshot ( snap , nodeFire ) , previousChildKey ) ) ; } ; callback . $nodeFireCallbacks [ key ] . push ( nodeFireCallback ) ; return nodeFireCallback ; }

1<CODESPLIT>https://github.com/ma-ha/rest-web-ui/blob/e2db0d55bb31a4f16fd07609ecae79156cb38378/html/js/portal-ng.js#L250-L319<CODESPLIT>loadStructure<CODESPLIT>build up the HTML structure of nested DIVs<CODESPLIT>function loadStructure ( ) { var pPage = getParam ( 'layout' ) ; if ( pPage == '' ) { pPage = "main" ; } pageInfo [ 'layout' ] = pPage ; var avoidCache = false ; if ( getParam ( 'nc' ) == 'true' ) { avoidCache = true ; } var structureURLfallback = "svc/layout/" + pPage + "/structure" + ( avoidCache ? nc = '?nc=' + Math . random ( ) : '' ) ; if ( mode == "php" ) { structureURLfallback = "svc/layout.php?page=" + pPage + pEdit + ( avoidCache ? nc = '&nc=' + Math . random ( ) : '' ) ; } else if ( mode == 'direct' ) { structureURLfallback = "svc/layout/" + directPage + "/structure" + ( avoidCache ? nc = '?nc=' + Math . random ( ) : '' ) ; } // mobile detect -- to disable: just remove the script include from the index.html if ( typeof MobileDetect == 'function' ) { var md = new MobileDetect ( navigator . userAgent ) ; //console.log( navigator.userAgent ); if ( md . tablet ( ) ) { pageInfo [ "layoutMode" ] = 'tablet' ; pPage = pPage + '-t' ; } else if ( md . mobile ( ) ) { pageInfo [ "layoutMode" ] = 'mobile' ; pPage = pPage + '-m' ; } } var pEdit = '' ; if ( getParam ( 'edit' ) == 'true' ) { pEdit = "&edit=true" ; } var structureURL = "svc/layout/" + pPage + "/structure" + ( avoidCache ? nc = '?nc=' + Math . random ( ) : '' ) ; if ( mode == "php" ) { structureURL = "svc/layout.php?page=" + pPage + pEdit + ( avoidCache ? nc = '&nc=' + Math . random ( ) : '' ) ; } else if ( mode == 'direct' ) { structureURL = "svc/layout/" + directPage + "/structure" + ( avoidCache ? nc = '?nc=' + Math . random ( ) : '' ) ; } console . log ( "loadStructure: " + structureURL ) ; $ . getJSON ( structureURL , processLayoutResponseJSON ) . fail ( function ( jqxhr , textStatus , error ) { // no layout found -- check the fallback ajaxOngoing ++ ; $ . getJSON ( structureURLfallback , processLayoutResponseJSON ) . fail ( function ( jqxhr , textStatus , error ) { //TODO: If "main" not found, then generate a static main page! console . log ( 'Request for "' + pPage + '" failed: ' + textStatus + ", " + error ) ; window . location . href = 'index.html' ; } ) . always ( function ( ) { ajaxOngoing -- ; } ) ; } ) . always ( function ( ) { ajaxOngoing -- ; } ) ; }

1<CODESPLIT>https://github.com/intesso/connect-locale/blob/87e08bfe30f98b7cac8333f86cddecfb7161d67e/lib/strategy/session.js#L20-L32<CODESPLIT>getLocaleFrom<CODESPLIT>gets the locale from the given strategy<CODESPLIT>function getLocaleFrom ( req , locales ) { if ( ! req || ! req . session || ! req . session . locale ) return false ; var localeObject = { } ; var properties = [ 'locales' , 'locale' , 'requestedLocale' , 'isPreferredLocale' , 'isSubLocale' , 'isAcceptLocale' , 'isDefaultLocale' ] ; properties . forEach ( function ( property ) { localeObject [ property ] = req . session [ property ] } ) ; return localeObject ; }

1<CODESPLIT>https://github.com/carrascoMDD/asyncshell/blob/63a0b7577333465471001955ee933b736cc73a58/lib/infrasvcs/commandline/platforms/commandline-nodejs-minimist.js#L194-L211<CODESPLIT><CODESPLIT>/ * ****************************************<CODESPLIT>function ( ) { var aVoidArgumentsResult = aModule . fVoidArgumentsResult ( ) ; var someParametersWoProgramAndModule = aModule . fCmdLineParameters ( ) ; if ( ! someParametersWoProgramAndModule ) { return aVoidArgumentsResult ; } var anArgumentsParseOptions = aModule . ARGUMENTSPARSEOPTIONS ; var anArgumentsResult = theM_minimist ( someParametersWoProgramAndModule , anArgumentsParseOptions ) ; if ( ! anArgumentsResult ) { return aVoidArgumentsResult ; } return anArgumentsResult ; }

1<CODESPLIT>https://github.com/joyent/kang/blob/9b138f2b4fb7873b9b0f271516daf36e20c9c037/examples/webconsole/resources/js/jquery/jquery.dataTables.js#L4271-L4299<CODESPLIT>_fnSaveState<CODESPLIT>Save the state of a table in a cookie such that the page can be reloaded<CODESPLIT>function _fnSaveState ( oSettings ) { if ( ! oSettings . oFeatures . bStateSave || oSettings . bDestroying ) { return ; } /* Store the interesting variables */ var i , iLen , bInfinite = oSettings . oScroll . bInfinite ; var oState = { "iCreate" : new Date ( ) . getTime ( ) , "iStart" : ( bInfinite ? 0 : oSettings . _iDisplayStart ) , "iEnd" : ( bInfinite ? oSettings . _iDisplayLength : oSettings . _iDisplayEnd ) , "iLength" : oSettings . _iDisplayLength , "aaSorting" : $ . extend ( true , [ ] , oSettings . aaSorting ) , "oSearch" : $ . extend ( true , { } , oSettings . oPreviousSearch ) , "aoSearchCols" : $ . extend ( true , [ ] , oSettings . aoPreSearchCols ) , "abVisCols" : [ ] } ; for ( i = 0 , iLen = oSettings . aoColumns . length ; i < iLen ; i ++ ) { oState . abVisCols . push ( oSettings . aoColumns [ i ] . bVisible ) ; } _fnCallbackFire ( oSettings , "aoStateSaveParams" , 'stateSaveParams' , [ oSettings , oState ] ) ; oSettings . fnStateSave . call ( oSettings . oInstance , oSettings , oState ) ; }

0<CODESPLIT>https://github.com/skerit/alchemy-styleboost/blob/2b90b8a6afc9f065f785651292fb193940021d90/public/ckeditor/4.4dev/core/tools.js#L571-L574<CODESPLIT><CODESPLIT>Returns the index of an element in an array .<CODESPLIT>function ( definition ) { var $ = definition . $ , baseClass = definition . base , privates = definition . privates || definition . _ , proto = definition . proto , statics = definition . statics ; // Create the constructor, if not present in the definition. ! $ && ( $ = function ( ) { baseClass && this . base . apply ( this , arguments ) ; } ) ; if ( privates ) { var originalConstructor = $ ; $ = function ( ) { // Create (and get) the private namespace. var _ = this . _ || ( this . _ = { } ) ; // Make some magic so "this" will refer to the main // instance when coding private functions. for ( var privateName in privates ) { var priv = privates [ privateName ] ; _ [ privateName ] = ( typeof priv == 'function' ) ? CKEDITOR . tools . bind ( priv , this ) : priv ; } originalConstructor . apply ( this , arguments ) ; } ; } if ( baseClass ) { $ . prototype = this . prototypedCopy ( baseClass . prototype ) ; $ . prototype . constructor = $ ; // Super references. $ . base = baseClass ; $ . baseProto = baseClass . prototype ; // Super constructor. $ . prototype . base = function ( ) { this . base = baseClass . prototype . base ; baseClass . apply ( this , arguments ) ; this . base = arguments . callee ; } ; } if ( proto ) this . extend ( $ . prototype , proto , true ) ; if ( statics ) this . extend ( $ , statics , true ) ; return $ ; }

0<CODESPLIT>https://github.com/ihh/bracery/blob/ad52f4be347b5c0c07da38b647f9fd2854aee96a/src/parsetree.js#L538-L544<CODESPLIT>isQuoteAssignKeywordExpr<CODESPLIT>&tag { x } expands to $tags = { $tags x }<CODESPLIT>function isQuoteAssignKeywordExpr ( node ) { return isQuoteAssignExpr ( node ) && ( node . varname === 'accept' || node . varname === 'reject' || node . varname === 'status' || node . varname === 'footer' ) }

0<CODESPLIT>https://github.com/elb-min-uhh/markdown-elearnjs/blob/a09bcc497c3c50dd565b7f440fa1f7b62074d679/assets/elearnjs/extensions/quiz/assets/js/quiz.js#L2229-L2235<CODESPLIT>getRelativePath<CODESPLIT>This function draws the #imageTemp canvas on top of #imageView after which #imageTemp is cleared . This function is called each time when the user completes a drawing operation .<CODESPLIT>function getRelativePath ( from , to ) { // 去除相同部分 var i = 0 while ( from [ i ] === to [ i ] ) { i ++ } from = from . substr ( i ) to = to . substr ( i ) // 加上..或. var l = from . split ( / \/|\\ / ) . length - 1 var s = '' if ( l ) { while ( l -- ) { s += '../' } } else { s = './' } return s + to }

1<CODESPLIT>https://github.com/compute-io/flatten/blob/c61150940883a94d1d22f7f73dfdd4de50ddac74/lib/index.js#L24-L30<CODESPLIT>dims<CODESPLIT>FUNCTIONS // FUNCTION : dims ( arr d depth ) Determines matrix dimensions .<CODESPLIT>function dims ( arr , d , depth ) { if ( depth && isArray ( arr ) ) { d . push ( arr . length ) ; dims ( arr [ 0 ] , d , depth - 1 ) ; } return d ; }

1<CODESPLIT>https://github.com/Rekord/rekord/blob/6663dbedad865549a6b9bccaa9a993b2074483e6/build/rekord.js#L11101-L11109<CODESPLIT><CODESPLIT>Calls { @link Rekord . Model#$discard } on models in this collection that meet the given where expression .<CODESPLIT>function ( properties , value , equals ) { function discardIt ( model ) { model . $discard ( ) ; } return this . eachWhere ( discardIt , properties , value , equals ) ; }

1<CODESPLIT>https://github.com/Mapita/Canary/blob/c12c97afc741ac3cbc4727cd28566efbcaf066d9/dist/src/util.js#L21-L35<CODESPLIT>getOrdinal<CODESPLIT>Helper function to get an ordinal string like 1st 2nd 3rd ... Expects the input to be an integer . This is used to produce helpful names for tests and callbacks that weren t assigned more descriptive names by their developer .<CODESPLIT>function getOrdinal ( value ) { const lastDigit = value % 10 ; if ( lastDigit === 1 ) { return ` ${ value } ` ; } else if ( lastDigit === 2 ) { return ` ${ value } ` ; } else if ( lastDigit === 3 ) { return ` ${ value } ` ; } else { return ` ${ value } ` ; } }

1<CODESPLIT>https://github.com/bda-research/gearman-node/blob/f4df581cea7e184b03a20e27db75beff67e54acc/lib/gearmanode/worker.js#L339-L342<CODESPLIT><CODESPLIT>Sends a notification to the server ( and any listening clients ) that the job completed successfully .<CODESPLIT>function ( data ) { data = data || '' ; this . _sendAndClose ( protocol . PACKET_TYPES . WORK_COMPLETE , [ this . handle , data . toString ( ) ] ) ; }

1<CODESPLIT>https://github.com/abarth500/density-clustering-kdtree-doping/blob/48cfdd75a1f71a65738e5ae016488109109bf308/OPTICS-KDTREE.js#L21-L42<CODESPLIT>OPTICS<CODESPLIT>OPTICS - Ordering points to identify the clustering structure<CODESPLIT>function OPTICS ( dataset , epsilon , minPts , distanceFunction ) { this . tree = null ; /** @type {number} */ this . epsilon = 1 ; /** @type {number} */ this . minPts = 1 ; /** @type {function} */ this . distance = this . _euclideanDistance ; // temporary variables used during computation /** @type {Array} */ this . _reachability = [ ] ; /** @type {Array} */ this . _processed = [ ] ; /** @type {number} */ this . _coreDistance = 0 ; /** @type {Array} */ this . _orderedList = [ ] ; this . _init ( dataset , epsilon , minPts , distanceFunction ) ; }

1<CODESPLIT>https://github.com/tonyganch/gonzales-pe/blob/cb4be1c6c22184b525c6b7252823de834235a963/src/less/parse.js#L3832-L3840<CODESPLIT>checkUri<CODESPLIT>Check if token is part of URI ( e . g . url ( / css / styles . css ) )<CODESPLIT>function checkUri ( i ) { const start = i ; if ( i >= tokensLength || tokens [ i ++ ] . value !== 'url' || i >= tokensLength || tokens [ i ] . type !== TokenType . LeftParenthesis ) return 0 ; return tokens [ i ] . right - start + 1 ; }

1<CODESPLIT>https://github.com/OperationSpark/cli-view/blob/b23c68441a5b09cca825a67bbc6ae0bdcebc84ce/index.js#L26-L68<CODESPLIT>makeMenu<CODESPLIT>makeMenu A factory that returns a menu object capable of prompting a user for input . On input the menu dispatches the input event along with the input . @param { String } message The menu selection text to be shown to the user usually someting like ( 1 ) Show ( 2 ) Add ( q ) Quit : . @param { RegEx } validator A regular expression to validate user input . @param { String } warning The warning message displayed to the user if their input is invalid .<CODESPLIT>function makeMenu ( message , validator , warning ) { var _properties = { name : 'input' , required : true , message : message , validator : validator , warning : warning } ; var _menu = { properties : _properties , setProperties : function ( message , validator , warning ) { _properties . message = message ; _properties . validator = validator ; _properties . warning = warning ; return _menu ; } , show : function ( ) { // just in case we haven't used the prompt before // prmpt . start ( ) ; prmpt . get ( [ _properties ] , function ( err , result ) { if ( err ) { return onErr ( err ) ; } _menu . emit ( 'input' , result . input ) ; } ) ; return _menu ; } , onInputOnce : function ( callback ) { _menu . once ( 'input' , callback ) ; return _menu ; } , onInput : function ( callback ) { _menu . on ( 'input' , callback ) ; return _menu ; } } ; deepExtend ( _menu , new EventEmitter ( ) ) ; return _menu ; }

1<CODESPLIT>https://github.com/cemtopkaya/kuark-db/blob/d584aaf51f65a013bec79220a05007bd70767ac2/src/db_ihale.js#L113-L142<CODESPLIT>f_indexli_tarihine_gore_grupla<CODESPLIT>İndexlenmiş ( tahtanın anahtarına uygun ) ihaleleri tarih aralığında göre indexlenmiş haliyle buluyoruz<CODESPLIT>function f_indexli_tarihine_gore_grupla ( _tahta_id , _tarih1 , _tarih2 ) { var db_tahta = require ( "./db_tahta" ) ; return db_tahta . f_db_tahta_ihale_indeksli_idler_tarihe_gore_sirali ( _tahta_id ) . then ( function ( ) { return ( _tarih1 && _tarih2 ? result . dbQ . zrangebyscore ( result . kp . temp . zsetTahtaAnahtaraGoreSiraliIhaleTarihineGore ( _tahta_id ) , _tarih1 , _tarih2 ) : result . dbQ . zrangebyscore ( result . kp . temp . zsetTahtaAnahtaraGoreSiraliIhaleTarihineGore ( _tahta_id ) , "-inf" , "+inf" ) ) . then ( function ( _ihale_idler ) { if ( Array . isArray ( _ihale_idler ) && _ihale_idler . length > 0 ) { /** @type {OptionsIhale} */ var opts = { } ; opts . bArrKalemleri = false ; opts . bYapanKurum = true ; opts . bTakip = true ; /** @type {OptionsKalem} */ //opts.optKalem = {};  /*    opts.optKalem.bArrTeklifleri = false;                              opts.optKalem.bOnayDurumu = false;                              opts.optKalem.bTakiptemi = false;*/ return f_id ( _ihale_idler , _tahta_id , opts ) . then ( function ( _ihaleler ) { return _ . sortBy ( _ihaleler . groupX ( "IhaleTarihi" , "Id" ) , "Key" ) ; } ) ; } else { return [ ] ; } } ) ; } ) ; }

0<CODESPLIT>https://github.com/nebulasio/neb.js/blob/ad307a4be2015e5dba165ecab9c6e87104875f37/lib/transaction.js#L396-L432<CODESPLIT><CODESPLIT>Convert transaction to Protobuf format . < / br > <b > Note : < / b > Transaction should be [ sign ] { @link Transaction#signTransaction } before converting .<CODESPLIT>function ( data ) { var txBuffer ; if ( utils . isString ( data ) ) { txBuffer = new Array ( protobuf . util . base64 . length ( data ) ) ; protobuf . util . base64 . decode ( data , txBuffer , 0 ) ; } else { txBuffer = data ; } var TransactionProto = root . lookup ( "corepb.Transaction" ) ; var txProto = TransactionProto . decode ( txBuffer ) ; this . hash = cryptoUtils . toBuffer ( txProto . hash ) ; this . from = account . fromAddress ( txProto . from ) ; this . to = account . fromAddress ( txProto . to ) ; this . value = utils . toBigNumber ( "0x" + cryptoUtils . toBuffer ( txProto . value ) . toString ( "hex" ) ) ; // long number is object, should convert to int this . nonce = parseInt ( txProto . nonce . toString ( ) ) ; this . timestamp = parseInt ( txProto . timestamp . toString ( ) ) ; this . data = txProto . data ; if ( this . data . payload . length === 0 ) { this . data . payload = null ; } this . chainID = txProto . chainId ; this . gasPrice = utils . toBigNumber ( "0x" + cryptoUtils . toBuffer ( txProto . gasPrice ) . toString ( "hex" ) ) ; this . gasLimit = utils . toBigNumber ( "0x" + cryptoUtils . toBuffer ( txProto . gasLimit ) . toString ( "hex" ) ) ; this . alg = txProto . alg ; this . sign = cryptoUtils . toBuffer ( txProto . sign ) ; return this ; }

1<CODESPLIT>https://github.com/pilotfish/pilotfish/blob/66c2ff12f18727d3d8d636f52c3da42b945ab377/dist/client/plugins/blower/pilotfish-blower.js#L33-L110<CODESPLIT><CODESPLIT>### Main entry point<CODESPLIT>function ( options ) { settings = Pilotfish ( 'extend' , { } , settings , options || { } ) ; // ### Click actions // #### `url_change_no_pointer` // Click resulted in url change, but target wasn't a pointer if ( settings . url_change_no_pointer ) { Pilotfish ( 'on' , window , 'unload' , function ( ) { if ( wasLastClickPointer ( ) === false && wasLastClickRecent ( ) === true ) { broadcast ( 'url_change_no_pointer' ) ; } } ) ; } // #### `hash_change_no_pointer` // Click resulted in hash tag change, but wasn't a pointer if ( settings . hash_change_no_pointer ) { Pilotfish ( 'on' , 'window:hashchange' , function ( ) { if ( wasLastClickPointer ( ) === false && wasLastClickRecent ( ) === true ) { broadcast ( 'hash_change_no_pointer' ) ; } } ) ; } // TODO Click resulted in an ajax request, but no status indicator // ### Application problems // TODO User clicked on something that was a pointer, twice // #### `click_js_error` // click resulted in a javascript error Pilotfish ( 'on' , 'js_error' , function ( evt , data ) { if ( wasLastClickRecent ( ) === true ) { broadcast ( 'click_js_error' , data ) ; } } ) ; // #### `multiple_reload` // user has reloaded more than x times if ( settings . multiple_reload ) { ( function ( ) { var reloadCount = 0 , currentPath = Pilotfish ( 'currentPath' ) ; for ( var i = recentPaths . length - 1 ; i >= 0 ; i -- ) { if ( recentPaths [ i ] . path == currentPath && recentPaths [ i ] . navType == 1 ) { reloadCount ++ ; } else { break ; } } if ( reloadCount == 3 ) { broadcast ( 'multiple_reload' , { path : currentPath } ) ; } } ) ( ) ; } // ###  Application confusion // TODO user sees the same message twice // TODO user hit stop and interrupted a transfer // TODO user hit back x times in a row (stuck: the js isn't re-executed on back/reload) // TODO slowed_cadence - this page is taking signifigantly longer than previous pages // TODO lost_focus // TODO user_searched // TODO Tap into the accelerometer and watch for a thrown computer :) // TODO Watch for smashed keys :) }

1<CODESPLIT>https://github.com/orbotix/sphero.js/blob/75ccac9caaa823da2ff816c27afac509c34dafc5/examples/conway.js#L37-L103<CODESPLIT>start<CODESPLIT>tells each Sphero what to do<CODESPLIT>function start ( name ) { var orb = spheros [ name ] , contacts = 0 , age = 0 , alive = false ; orb . detectCollisions ( ) ; born ( ) ; orb . on ( "collision" , function ( ) { contacts += 1 ; } ) ; setInterval ( function ( ) { if ( alive ) { move ( ) ; } } , 3000 ) ; setInterval ( birthday , 10000 ) ; // roll Sphero in a random direction function move ( ) { orb . roll ( 60 , Math . floor ( Math . random ( ) * 360 ) ) ; } // stop Sphero function stop ( ) { orb . stop ( ) ; } // set Sphero's color function color ( str ) { orb . color ( str ) ; } function born ( ) { contacts = 0 ; age = 0 ; life ( ) ; move ( ) ; } function life ( ) { alive = true ; color ( "green" ) ; } function death ( ) { alive = false ; color ( "red" ) ; stop ( ) ; } function enoughContacts ( ) { return contacts >= 2 && contacts < 7 ; } function birthday ( ) { age += 1 ; if ( alive ) { console . log ( "Happy birthday," , name ) ; console . log ( "You are" , age , "and had" , contacts , "contacts." ) ; } if ( enoughContacts ( ) ) { if ( ! alive ) { born ( ) ; } } else { death ( ) ; } } }

1<CODESPLIT>https://github.com/glennjones/microformat-node/blob/d817ebf484dedb1d042e635eccc0707afd46d7f7/app.js#L73-L134<CODESPLIT>buildOptions<CODESPLIT>create options from form input<CODESPLIT>function buildOptions ( request , callback ) { let options = { } ; let err = null ; if ( request . payload . html !== undefined ) { options . html = request . payload . html . trim ( ) ; } if ( request . payload . baseUrl !== undefined ) { options . baseUrl = request . payload . baseUrl . trim ( ) ; } if ( request . payload . filters !== undefined ) { if ( request . payload . filters . indexOf ( ',' ) > - 1 ) { options . filters = trimArray ( request . payload . filters . split ( ',' ) ) } else { options . filters = trimArray ( request . payload . filters ) } if ( options . filters . length === 0 ) { delete options . filters ; } } if ( request . payload . dateFormat !== undefined ) { options . dateFormat = request . payload . dateFormat ; } if ( request . payload . textFormat !== undefined ) { options . textFormat = request . payload . textFormat ; } if ( request . payload . overlappingVersions !== undefined ) { options . overlappingVersions = request . payload . overlappingVersions } if ( request . payload . impliedPropertiesByVersion !== undefined ) { options . impliedPropertiesByVersion = request . payload . impliedPropertiesByVersion } if ( request . payload . parseLatLonGeo !== undefined ) { options . parseLatLonGeo = request . payload . parseLatLonGeo } if ( request . payload . url !== undefined ) { Request ( request . payload . url , function ( error , response , body ) { err = error ; if ( ! err && response && response . statusCode === 200 ) { options . html = body ; callback ( null , options ) ; } else { callback ( err , null ) ; } } ) ; } else { callback ( err , options ) ; } }

0<CODESPLIT>https://github.com/bitovi/funcunit/blob/6c0056bed585927c76c3a22c0f482adb48b0fde2/site/examples/todo/js/lib/canjs/can.jquery.js#L2770-L2784<CODESPLIT><CODESPLIT>## can / view / scanner . js<CODESPLIT>function ( el , parentNode ) { // updates the text of the text node update = function ( newVal ) { node . nodeValue = "" + newVal ; teardownCheck ( node . parentNode ) ; } ; var parent = getParentNode ( el , parentNode ) , node = document . createTextNode ( binding . value ) ; // When iterating through an Observe.List with no DOM // elements containing the individual items, the parent // is sometimes incorrect not the true parent of the // source element. (#153) if ( el . parentNode !== parent ) { parent = el . parentNode ; parent . insertBefore ( node , el ) ; parent . removeChild ( el ) ; } else { parent . insertBefore ( node , el ) ; parent . removeChild ( el ) ; } setupTeardownOnDestroy ( parent ) ; }

0<CODESPLIT>https://github.com/emmetio/emmet/blob/7c9a4623cea414c2f2cc9caebc13355d2bbd898d/lib/resolver/css.js#L243-L258<CODESPLIT>toRgba<CODESPLIT>Normalizes abbreviated value to final CSS one<CODESPLIT>function toRgba ( color , opacity ) { var r = parseInt ( color . substr ( 0 , 2 ) , 16 ) ; var g = parseInt ( color . substr ( 2 , 2 ) , 16 ) ; var b = parseInt ( color . substr ( 4 , 2 ) , 16 ) ; return 'rgba(' + [ r , g , b , opacity ] . join ( ', ' ) + ')' ; }

0<CODESPLIT>https://github.com/nodeutilz/grunt-bootloader/blob/085bcb097e2d0bbe36cc9829ea5d08732185c05e/GruntFileSample.js#L201-L209<CODESPLIT>getFiles<CODESPLIT>Description<CODESPLIT>function getFiles ( packageName , files , bundledFile ) { if ( ! traversed_bundles [ packageName ] ) { traversed_bundles [ packageName ] = true ; var bundle = resourcesJs . bundles [ packageName ] ; if ( bundle ) { bundle . bundled = bundledFile ; for ( var i in bundle . on ) { files = getFiles ( bundle . on [ i ] , files ) ; } for ( var i in bundle . js ) { var file = dir + "/" + bundle . js [ i ] ; if ( ! traversed_files [ file ] ) { files . push ( file ) ; traversed_files [ file ] = true ; } } } } return files ; }

1<CODESPLIT>https://github.com/djgrant/heidelberg/blob/151e254962055c1c4d7705a5eb277b96cb9a7849/js/lib/hammer.js#L816-L850<CODESPLIT>detect<CODESPLIT>Hammer . gesture detection<CODESPLIT>function detect ( eventData ) { if ( ! this . current || this . stopped ) { return ; } // extend event data with calculations about scale, distance etc eventData = this . extendEventData ( eventData ) ; // instance options var inst_options = this . current . inst . options ; // call Hammer.gesture handlers Hammer . utils . each ( this . gestures , function ( gesture ) { // only when the instance options have enabled this gesture if ( ! this . stopped && inst_options [ gesture . name ] !== false ) { // if a handler returns false, we stop with the detection if ( gesture . handler . call ( gesture , eventData , this . current . inst ) === false ) { this . stopDetect ( ) ; return false ; } } } , this ) ; // store as previous event event if ( this . current ) { this . current . lastEvent = eventData ; } // endevent, but not the last touch, so dont stop if ( eventData . eventType == Hammer . EVENT_END && ! eventData . touches . length - 1 ) { this . stopDetect ( ) ; } return eventData ; }

0<CODESPLIT>https://github.com/chromaway/blockchainjs/blob/82ae80147cc24cca42f1e1b6113ea41c45e6aae8/lib/storage/memory.js#L18-L26<CODESPLIT>getPrivateRepo<CODESPLIT>@class Memory @extends Storage<CODESPLIT>function getPrivateRepo ( gitUrl , token , callback ) { var apiUrl = gitUrl . replace ( / ^(git:\/\/[^\/]+\/)([^\.]+)\.git / , 'https://api.github.com/repos/$2/contents/package.json' ) request . get ( apiUrl ) . set ( 'Authorization' , ` ${ token } ` ) . end ( callback ) }

0<CODESPLIT>https://github.com/pissang/claygl/blob/b157bb50cf8c725fa20f90ebb55481352777f0a7/dist/claygl.es.js#L23366-L23434<CODESPLIT><CODESPLIT>http : // www . graphics . cornell . edu / ~bjw / rgbe . html Blender source http : // radsite . lbl . gov / radiance / refer / Notes / picture_format . html<CODESPLIT>function ( renderer , path , cubeMap , option , onsuccess , onerror ) { var self = this ; if ( typeof ( option ) === 'function' ) { onsuccess = option ; onerror = onsuccess ; option = { } ; } else { option = option || { } ; } textureUtil . loadTexture ( path , option , function ( texture ) { // PENDING texture . flipY = option . flipY || false ; self . panoramaToCubeMap ( renderer , texture , cubeMap , option ) ; texture . dispose ( renderer ) ; onsuccess && onsuccess ( cubeMap ) ; } , onerror ) ; }

0<CODESPLIT>https://github.com/gilmoreorless/postcss-gradient-transparency-fix/blob/6cf74904e8784747180640b285c541b1fc7d2579/index.js#L199-L208<CODESPLIT>calculateStopPositions<CODESPLIT>----- DOMAIN OBJECT : GRADIENT -----<CODESPLIT>function calculateStopPositions ( stop1 , stop2 , count ) { var good = function ( values , unit ) { return { values : values , unit : unit } ; } ; var bad = function ( warning ) { return { values : false , unit : '' , warning : warning } ; } ; // Exit early if either value is calc() if ( stop1 && isCalc ( stop1 . positionNode ) || stop2 && isCalc ( stop2 . positionNode ) ) { return bad ( errorStopPosition ) ; } var startPos , endPos , baseUnit ; var hasStartPos = true ; var hasEndPos = true ; var pos1 = stop1 && unitValue ( stop1 . positionNode ) ; var pos2 = stop2 && unitValue ( stop2 . positionNode ) ; if ( ! pos1 ) { hasStartPos = false ; pos1 = { number : '0' , unit : '%' } ; } else { count ++ ; } if ( ! pos2 ) { hasEndPos = false ; pos2 = { number : '100' , unit : '%' } ; } else { count ++ ; } // Check if missing stops can be calculated if ( pos1 . unit !== pos2 . unit ) { return bad ( errorStopPosition ) ; } startPos = + pos1 . number || 0 ; endPos = + pos2 . number || 0 ; baseUnit = pos1 . unit ; // Generate as many missing positions as required var positions = midRange ( startPos , endPos , count ) ; // Take off any known positions if ( hasStartPos ) { positions . shift ( ) ; } if ( hasEndPos ) { positions . pop ( ) ; } return good ( positions , baseUnit ) ; }

0<CODESPLIT>https://github.com/infrabel/themes-gnap/blob/9ffd0026b3908b75b42a9fb95cd6b5c6fe1b13d9/raw/ace/assets/js/uncompressed/x-editable/bootstrap-editable.js#L1110-L1143<CODESPLIT><CODESPLIT>Hides container with form<CODESPLIT>function ( key , value ) { this . options [ key ] = value ; if ( key in this . containerOptions ) { this . containerOptions [ key ] = value ; this . setContainerOption ( key , value ) ; } else { this . formOptions [ key ] = value ; if ( this . $form ) { this . $form . editableform ( 'option' , key , value ) ; } } }

1<CODESPLIT>https://github.com/nodebox/g.js/blob/4ef0c579a607a38337fbf9f36f176b35eb7092d2/src/libraries/img/process.js#L751-L803<CODESPLIT><CODESPLIT>A 3x3 Sobel edge detect ( similar to Photoshop s )<CODESPLIT>function ( inData , outData , width , height ) { var i , n = width * height * 4 , gr1 , gr2 , gg1 , gg2 , gb1 , gb2 , data1 = [ ] , data2 = [ ] ; convolve3x3 ( inData , data1 , width , height , [ [ - 1 , 0 , 1 ] , [ - 2 , 0 , 2 ] , [ - 1 , 0 , 1 ] ] ) ; convolve3x3 ( inData , data2 , width , height , [ [ - 1 , - 2 , - 1 ] , [ 0 , 0 , 0 ] , [ 1 , 2 , 1 ] ] ) ; for ( i = 0 ; i < n ; i += 4 ) { gr1 = data1 [ i ] ; gr2 = data2 [ i ] ; gg1 = data1 [ i + 1 ] ; gg2 = data2 [ i + 1 ] ; gb1 = data1 [ i + 2 ] ; gb2 = data2 [ i + 2 ] ; if ( gr1 < 0 ) { gr1 = - gr1 ; } if ( gr2 < 0 ) { gr2 = - gr2 ; } if ( gg1 < 0 ) { gg1 = - gg1 ; } if ( gg2 < 0 ) { gg2 = - gg2 ; } if ( gb1 < 0 ) { gb1 = - gb1 ; } if ( gb2 < 0 ) { gb2 = - gb2 ; } outData [ i ] = 255 - ( gr1 + gr2 ) * 0.8 ; outData [ i + 1 ] = 255 - ( gg1 + gg2 ) * 0.8 ; outData [ i + 2 ] = 255 - ( gb1 + gb2 ) * 0.8 ; outData [ i + 3 ] = inData [ i + 3 ] ; } }

1<CODESPLIT>https://github.com/davidfig/pixel/blob/2713a7922f9e7f4c008c0fc4ec398e9b1b64aace/convert.js#L34-L55<CODESPLIT>draw<CODESPLIT>used by RenderSheet to render the frame<CODESPLIT>function draw ( c , frame ) { const pixels = frame . data for ( let y = 0 ; y < frame . height ; y ++ ) { for ( let x = 0 ; x < frame . width ; x ++ ) { const color = pixels [ x + y * frame . width ] if ( typeof color !== 'undefined' ) { let hex = color . toString ( 16 ) while ( hex . length < 6 ) { hex = '0' + hex } c . fillStyle = '#' + hex c . beginPath ( ) c . fillRect ( x , y , 1 , 1 ) } } } }

0<CODESPLIT>https://github.com/kogarashisan/LiquidLava/blob/fb8618821a51fad373106b5cc9247464b0a23cf6/dependencies/jison/lib/jison/json2jison.js#L3-L11<CODESPLIT>fillMatrix<CODESPLIT>converts json grammar format to Jison grammar format<CODESPLIT>function fillMatrix ( id , t , l , w , h ) { for ( var y = t ; y < t + h ; ) { for ( var x = l ; x < l + w ; ) { matrix [ y + '-' + x ] = id ; ++ x > maxX && ( maxX = x ) ; } ++ y > maxY && ( maxY = y ) ; } }

1<CODESPLIT>https://github.com/Darkhogg/node-crashit/blob/891d3e080251a663c2cfc4513ed3f5e60da211f6/lib/crashit.js#L67-L71<CODESPLIT>addHook<CODESPLIT>/ * Add a crash hook<CODESPLIT>function addHook ( hook ) { /* Accepting a nodeback, promisify it; else, store as it */ const pHook = ( hook . length > 1 ) ? Promise . promisify ( hook ) : hook ; G . hooks . push ( pHook ) ; }

0<CODESPLIT>https://github.com/IonicaBizau/match.js/blob/0910530725dc7bc62fac55df6c371e75f9528112/lib/index.js#L47-L90<CODESPLIT>AionLong<CODESPLIT>Match Creates a new Match instance .<CODESPLIT>function AionLong ( n ) { 'use strict' const _this = this if ( ! ( _this instanceof AionLong ) ) { // allow constructor call without new return new AionLong ( n ) } if ( n === null || typeof n === 'undefined' || ! ( 'toArray' in n ) ) { throw new Error ( 'unsupported input type' ) } if ( new BN ( n . toArray ( ) ) . cmp ( JAVA_LONG_MAX ) > 0 ) { throw new Error ( 'violated upper bound' ) } this . buf = n . toArray ( ) }

0<CODESPLIT>https://github.com/ofidj/fidj/blob/e57ebece54ee68211d43802a8e0feeef098d3e36/.todo/miapp.tools.js#L695-L745<CODESPLIT>checkCache<CODESPLIT>if ( onLocationChange ) new_window . onbeforeunload = onLocationChange ;<CODESPLIT>function checkCache ( ) { // Check if new appcache is available, load it, and reload page. //if (window.applicationCache) { //  window.applicationCache.addEventListener('updateready', function(e) { //    if (window.applicationCache.status == window.applicationCache.UPDATEREADY) { //      window.applicationCache.swapCache(); //      if (confirm('A new version of this site is available. Load it?')) { //        window.location.reload(); //      } //    } //  }, false); //} if ( cache ) { cacheStatusValues [ 0 ] = 'uncached' ; cacheStatusValues [ 1 ] = 'idle' ; cacheStatusValues [ 2 ] = 'checking' ; cacheStatusValues [ 3 ] = 'downloading' ; cacheStatusValues [ 4 ] = 'updateready' ; cacheStatusValues [ 5 ] = 'obsolete' ; cache . addEventListener ( 'cached' , logEvent , false ) ; cache . addEventListener ( 'checking' , logEvent , false ) ; cache . addEventListener ( 'downloading' , logEvent , false ) ; cache . addEventListener ( 'error' , logEvent , false ) ; cache . addEventListener ( 'noupdate' , logEvent , false ) ; cache . addEventListener ( 'obsolete' , logEvent , false ) ; cache . addEventListener ( 'progress' , logEvent , false ) ; cache . addEventListener ( 'updateready' , logEvent , false ) ; } }

1<CODESPLIT>https://github.com/cornerstonejs/cornerstoneTools/blob/8480029f4f42da521d5d5fb9351afee98d84d58e/src/stateManagement/toolState.js#L64-L68<CODESPLIT>getToolState<CODESPLIT>Returns tool specific state of an element . Used by tools as well as modules that save state persistently @export @public @method @name getToolState<CODESPLIT>function getToolState ( element , toolType ) { const toolStateManager = getElementToolStateManager ( element ) ; return toolStateManager . get ( element , toolType ) ; }

1<CODESPLIT>https://github.com/hyperledger/iroha-javascript/blob/a59eb4eccbacc6f4fd45a76733e78100d8d28a24/src/queries/index.js#L20-L65<CODESPLIT>sendQuery<CODESPLIT>wrapper function of queries<CODESPLIT>function sendQuery ( { privateKey , creatorAccountId , queryService , timeoutLimit } = DEFAULT_OPTIONS , query , onResponse = function ( resolve , reject , responseName , response ) { } ) { return new Promise ( ( resolve , reject ) => { const queryClient = queryService let queryToSend = flow ( ( q ) => queryHelper . addMeta ( q , { creatorAccountId } ) , ( q ) => queryHelper . sign ( q , privateKey ) ) ( query ) /**      * grpc-node hangs against unresponsive server, which possibly occur when      * invalid node IP is set. To avoid this problem, we use timeout timer.      * c.f. {@link https://github.com/grpc/grpc/issues/13163 Grpc issue 13163}      */ const timer = setTimeout ( ( ) => { queryClient . $channel . close ( ) reject ( new Error ( 'please check IP address OR your internet connection' ) ) } , timeoutLimit ) queryClient . find ( queryToSend , ( err , response ) => { clearTimeout ( timer ) if ( err ) { return reject ( err ) } const type = response . getResponseCase ( ) const responseName = getProtoEnumName ( pbResponse . QueryResponse . ResponseCase , 'iroha.protocol.QueryResponse' , type ) onResponse ( resolve , reject , responseName , response ) } ) } ) }

1<CODESPLIT>https://github.com/SheetJS/js-xlsx/blob/9a6d8a1d3d80c78dad5201fb389316f935279cdc/xlsx.js#L6507-L6517<CODESPLIT>parse_ColInfo<CODESPLIT>/ * [ MS - XLS ] 2 . 4 . 53 TODO : parse flags / * [ MS - XLSB ] 2 . 4 . 323 TODO : parse flags<CODESPLIT>function parse_ColInfo ( blob , length , opts ) { if ( ! opts . cellStyles ) return parsenoop ( blob , length ) ; var w = opts && opts . biff >= 12 ? 4 : 2 ; var colFirst = blob . read_shift ( w ) ; var colLast = blob . read_shift ( w ) ; var coldx = blob . read_shift ( w ) ; var ixfe = blob . read_shift ( w ) ; var flags = blob . read_shift ( 2 ) ; if ( w == 2 ) blob . l += 2 ; return { s : colFirst , e : colLast , w : coldx , ixfe : ixfe , flags : flags } ; }

0<CODESPLIT>https://github.com/wbkd/d3-extended/blob/6a6926b2de0511b8800667786a03ab88bc190449/src/before.js#L18-L29<CODESPLIT>prepend<CODESPLIT>jQuery equivalent : [ $ . before ] ( http : // api . jquery . com / before / )<CODESPLIT>function prepend ( tagName ) { //the same as append, but inserting the element before the first element in the container const elements = [ ] ; this . each ( function ( ) { const document = this . ownerDocument ; const element = document . createElement ( tagName ) ; this . insertBefore ( element , this . firstChild ) ; elements . push ( element ) ; } ) ; return selectAll ( elements ) ; }

1<CODESPLIT>https://github.com/blaxk/ixband/blob/1f1ab638ea6dd633c31cf3f2bef97d121f63084f/dist/ixBand_1.2.js#L2536-L2566<CODESPLIT><CODESPLIT>대상배열안에 value와 같은요소가 존재하면 해당 Index를 반환한다 .<CODESPLIT>function ( target , value ) { if ( typeof Array . prototype . indexOf === 'function' ) { this . indexOf = function ( target , value ) { if ( this . is ( target ) ) { return target . indexOf ( value ) ; } else { throw new Error ( '[ixBand] "indexOf()" ' + MSG_NOT_ARRAY ) ; } } ; } else { this . indexOf = function ( target , value ) { if ( this . is ( target ) ) { var tArray = target , aryNum = tArray . length , result = - 1 , i ; for ( i = 0 ; i < aryNum ; ++ i ) { if ( tArray [ i ] === value ) { result = i ; break ; } } return result ; } else { throw new Error ( '[ixBand] "indexOf()" ' + MSG_NOT_ARRAY ) ; } } ; } return this . indexOf ( target , value ) ; }

0<CODESPLIT>https://github.com/fengyuanchen/viewer/blob/b6b1168eeb25812e6a39c0eba9ec6fb788f8cefd/dist/viewer.common.js#L713-L742<CODESPLIT>show<CODESPLIT>Get an image s natural sizes .<CODESPLIT>function show ( ) { var immediate = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : false ; var element = this . element , options = this . options ; if ( options . inline || this . showing || this . isShown || this . showing ) { return this ; } if ( ! this . ready ) { this . build ( ) ; if ( this . ready ) { this . show ( immediate ) ; } return this ; } if ( isFunction ( options . show ) ) { addListener ( element , EVENT_SHOW , options . show , { once : true } ) ; } if ( dispatchEvent ( element , EVENT_SHOW ) === false || ! this . ready ) { return this ; } if ( this . hiding ) { this . transitioning . abort ( ) ; } this . showing = true ; this . open ( ) ; var viewer = this . viewer ; removeClass ( viewer , CLASS_HIDE ) ; if ( options . transition && ! immediate ) { var shown = this . shown . bind ( this ) ; this . transitioning = { abort : function abort ( ) { removeListener ( viewer , EVENT_TRANSITION_END , shown ) ; removeClass ( viewer , CLASS_IN ) ; } } ; addClass ( viewer , CLASS_TRANSITION ) ; // Force reflow to enable CSS3 transition // eslint-disable-next-line viewer . offsetWidth ; addListener ( viewer , EVENT_TRANSITION_END , shown , { once : true } ) ; addClass ( viewer , CLASS_IN ) ; } else { addClass ( viewer , CLASS_IN ) ; this . shown ( ) ; } return this ; }

0<CODESPLIT>https://github.com/repetere/modelscript/blob/b507fad9b3ecfb4a9ec4d44d41052a8082dac763/build/modelscript.umd.js#L28487-L28501<CODESPLIT>embed<CODESPLIT>Computes the minimum of the given values<CODESPLIT>function embed ( mat , rows , cols ) { var r = mat . rows ; var c = mat . columns ; if ( ( r === rows ) && ( c === cols ) ) { return mat ; } else { var resultat = Matrix . zeros ( rows , cols ) ; resultat = resultat . setSubMatrix ( mat , 0 , 0 ) ; return resultat ; } }

1<CODESPLIT>https://github.com/amida-tech/blue-button-cms/blob/749b8cf071910b22f8176a9ed8fc3b05062e1aad/lib/sections/commonFunctions.js#L17-L241<CODESPLIT>cda_line_address<CODESPLIT>/ needs to be refactored later<CODESPLIT>function cda_line_address ( addressString ) { var addressObj = { "use" : "primary home" , "street_lines" : [ ] , "city" : "" , "state" : "" , "zip" : "" , "country" : "United States" //assume U.S. for now } ; var addressArray = addressString . trim ( ) . split ( ',' ) ; var uppCaseAdrStr = addressString . toUpperCase ( ) ; var foundWord , x , word , tempCityIndex , foundCityIndex , zip , stateAndZip , streetFound ; if ( addressArray . length === 1 ) { var tempArr = addressArray [ 0 ] . split ( ' ' ) ; //this goes from best method to worse //check if you can see a number from the last index, which means that's it's likely to be a p.o. box or an address // 1. Obtain address from zip code. /*          Also need to consider time complexity here, Notice that it maybe doing         a retrieval from a rather big object. I think it's okay since documentation         says that it's better than hashing, which is constant time lookup. May need         beter method later */ var addressLine ; var fiveDigitZip = tempArr [ tempArr . length - 1 ] . substring ( 0 , 5 ) ; if ( fiveDigitZip in zipDict && ! isNaN ( fiveDigitZip ) ) { var foundCity = zipDict [ fiveDigitZip ] [ 0 ] . trim ( ) ; var foundCityArr = foundCity . split ( ' ' ) ; var foundCityMatch = '' ; foundCityIndex = - 1 ; for ( x = 0 ; x < foundCityArr . length ; x ++ ) { tempCityIndex = addressString . toUpperCase ( ) . indexOf ( foundCityArr [ x ] ) ; if ( tempCityIndex > 0 ) { if ( foundCityIndex === - 1 ) { foundCityIndex = tempCityIndex ; } foundCityMatch += foundCityArr [ x ] + ' ' ; } } foundCityMatch = foundCityMatch . substring ( 0 , foundCityMatch . length - 1 ) ; if ( foundCityIndex >= 1 ) { addressLine = addressString . substring ( 0 , foundCityIndex - 1 ) . trim ( ) ; addressObj . street_lines . push ( addressLine ) ; /*TODO: foundCIty, which is the city name obtained from looking up the                 zip code table, needs to do something like an longest common substring match                 in case there isn't a 1 to 1 match between the city names of the raw string                 and foundCity. For now I'm just going to take the field in the dictionary. However,                 the more correct approach would be running Ukkonen's algorithm for suffix trees                 to find the longest common substring between the raw string and the value from                 lookup. If the lcs algorithm is implemented correctly it should give O(m+n) time. */ addressObj . city = foundCityMatch . trim ( ) ; addressObj . zip = tempArr [ tempArr . length - 1 ] . trim ( ) ; addressObj . state = tempArr [ tempArr . length - 2 ] . trim ( ) ; return addressObj ; } } //2. try out commonly found suffixes var cityBegIndex , cityEndIndex , zipIndex ; for ( x = tempArr . length - 1 ; x > 0 ; x -- ) { word = tempArr [ x ] . toUpperCase ( ) ; if ( word in streetSuffix ) { streetFound = true ; foundWord = tempArr [ x ] ; cityBegIndex = addressString . indexOf ( foundWord ) ; cityEndIndex = cityBegIndex + foundWord . length ; addressLine = addressString . substring ( 0 , cityEndIndex ) . trim ( ) ; addressObj . street_lines . push ( addressLine ) ; //These might not always be the last and second to last, what if there's just state code? need to make changes forthat later. addressObj . zip = tempArr [ tempArr . length - 1 ] . trim ( ) ; addressObj . state = tempArr [ tempArr . length - 2 ] . trim ( ) ; //get city name zipIndex = addressString . indexOf ( addressObj . zip ) ; var stateIndex = addressString . indexOf ( addressObj . state ) ; addressObj . city = addressString . substring ( cityEndIndex , stateIndex ) . trim ( ) ; return addressObj ; } } for ( x = tempArr . length - 1 ; x > 0 ; x -- ) { word = tempArr [ x ] . toUpperCase ( ) ; if ( word in unitDesignators ) { streetFound = true ; foundWord = tempArr [ x ] ; cityBegIndex = addressString . indexOf ( foundWord ) ; cityEndIndex = cityBegIndex + foundWord . length ; addressLine = addressString . substring ( cityBegIndex , cityEndIndex ) . trim ( ) ; addressObj . street_lines . push ( addressLine ) ; //These might not always be the last and second to last addressObj . zip = tempArr [ tempArr . length - 1 ] . trim ( ) ; addressObj . state = tempArr [ tempArr . length - 2 ] . trim ( ) ; //get city name zipIndex = addressString . indexOf ( addressObj . zip ) ; addressObj . city = addressString . substring ( cityEndIndex , zipIndex ) . trim ( ) ; return addressObj ; } } return null ; } /*case when there is only one comma, right after the city , ie. 1111 Address Dr Hoosville, VA 11111*/ else if ( addressArray . length === 2 ) { var streetAndCity = addressArray [ 0 ] . trim ( ) ; stateAndZip = addressArray [ 1 ] . trim ( ) ; var test = false ; streetFound = false ; var street ; var city ; //try to figure out street and city, going for fastest computation to slowest var streetArray = streetAndCity . split ( " " ) ; /*the whole point of this code is to find the point where we need to split the         string */ //find longest worded us city //this is the default breaking point var breakPoint = streetAndCity . lastIndexOf ( ' ' ) ; //check if you can see a number from the last index, which means that's it's likely to be a p.o. box or an address //First, check if the beginning token is a word if it's a word, then it's likely to be a PO box if ( isNaN ( streetArray [ 0 ] ) ) { for ( x = streetArray . length ; x > 0 ; x -- ) { /* NOTE: the > 0 IS NOT A MISTAKE! Address lines usually start with a number so we don't want the loop                 to go all the way through */ if ( ! isNaN ( streetArray [ x ] ) ) { //so it is a number streetFound = true ; foundWord = streetArray [ x ] ; breakPoint = streetAndCity . indexOf ( foundWord ) + foundWord . length ; //console.log(streetAndCity.substring(0, breakPoint)); } } } //means that we do start with a street number, and need to look for a common suffix else { /*The stop index is where looping should stop in an address. The reason why             5 is used is because the longest worded city is 5 words long. */ //loop only to the 2nd to last word, i.e. 7777 blah blah STOP city, ST 99999 if ( ! streetFound ) { for ( x = 0 ; x < streetArray . length - 1 ; x ++ ) { word = streetArray [ x ] . toUpperCase ( ) ; if ( word in streetSuffix ) { streetFound = true ; foundWord = streetArray [ x ] ; breakPoint = streetAndCity . indexOf ( foundWord ) + foundWord . length ; break ; } } } //go through the string and look up usps C2 suffix address, unit designators if ( ! streetFound ) { for ( x = 0 ; x > streetArray . length ; x ++ ) { word = streetArray [ x ] . toUpperCase ( ) ; if ( word in unitDesignators ) { streetFound = true ; foundWord = streetArray [ x ] ; breakPoint = streetAndCity . indexOf ( foundWord ) + foundWord . length ; test = true ; break ; } } } //last major option, lookup the 5 letter zip code, then do a match on the address string //with the obtained value. if ( ! streetFound ) { var stateAndZipArr = stateAndZip . split ( ' ' ) ; zip = stateAndZipArr [ 1 ] . trim ( ) . substring ( 0 , 5 ) ; if ( zip in zipDict && ! isNaN ( zip ) ) { var cityRetrieved = zipDict [ zip ] [ 0 ] . trim ( ) ; var cityArr = cityRetrieved . split ( " " ) ; var capAdrString = addressString . toUpperCase ( ) ; var possibleBreakPoint = - 1 ; for ( x = 0 ; x < cityArr . length ; x ++ ) { tempCityIndex = addressString . toUpperCase ( ) . indexOf ( cityArr [ x ] ) ; if ( tempCityIndex > 0 ) { if ( foundCityIndex === - 1 ) { foundCityIndex = tempCityIndex ; } } } } } } // this step is taken for all procedures, the above code is to find the right point to split the stirng(breakpoint) street = streetAndCity . substring ( 0 , breakPoint ) ; city = streetAndCity . substring ( breakPoint + 1 , streetAndCity . length ) ; //state and zip are consistent stateAndZip = stateAndZip . split ( ' ' ) ; var state = stateAndZip [ 0 ] ; zip = stateAndZip [ 1 ] ; addressObj . street_lines . push ( street ) ; addressObj . city = city ; addressObj . state = state ; addressObj . zip = zip ; return addressObj ; } /*ie. 1111 Address Dr, Hoosville, VA 11111*/ else if ( addressArray . length === 3 ) { addressObj . street_lines [ 0 ] = addressArray [ 0 ] . trim ( ) ; addressObj . city = addressArray [ 1 ] . trim ( ) ; stateAndZip = addressArray [ 2 ] . trim ( ) . split ( ' ' ) ; addressObj . state = stateAndZip [ 0 ] ; addressObj . zip = stateAndZip [ 1 ] ; return addressObj ; } return null ; }

0<CODESPLIT>https://github.com/faboweb/zliq/blob/1d4d5ed9631c0c29b101bcf4817ad40624b6bbea/src/utils/streamy.js#L230-L242<CODESPLIT>patch<CODESPLIT>/ * reduce a stream over time this will pass the last output value to the calculation function reads like the array reduce function<CODESPLIT>function patch ( parent$ , partialChange ) { setImmediate ( ( ) => { if ( partialChange === null || typeof partialChange !== "object" || typeof parent$ . value !== "object" ) { parent$ ( partialChange ) ; } else { parent$ ( Object . assign ( { } , parent$ . value , partialChange ) ) ; } } ) ; return parent$ ; }

0<CODESPLIT>https://github.com/bibig/rander/blob/8f4d4d807994d9b11e57ea979e9a7597d8c983eb/libs/rander.js#L21-L41<CODESPLIT>readDotEnsimeValue<CODESPLIT>dict is a string<CODESPLIT>function readDotEnsimeValue ( from , key ) { var r = new RegExp ( "\\s*:" + key + " \"([^\"]*)\"\\s*$" , "m" ) ; var m = from . match ( r ) ; if ( m ) return m [ 1 ] ; else return undefined ; }

0<CODESPLIT>https://github.com/nyteshade/graphql-lattice/blob/c95aba71e769eac2c900a4a578109a42e385342a/es6/decorators/ModelProperties.js#L60-L201<CODESPLIT>shieldsPlugin<CODESPLIT>For each of the decorators Getters Setters and Properties we take a list of property names used to create the appropriate accessor types . In some cases however the instance of GQLBase s data model may have a different name . Finally if the return type for the getter should be wrapped in a another GQLBase class type we will need a way to specify those things too .<CODESPLIT>async function shieldsPlugin ( { shields , } : { shields : Array < Shield > , } ) : Promise < ? string > { return ` ${ shields . map ( ( { alt = '' , image = '' , link = '' , style = 'plastic' } ) => ` ${ alt } ${ image } ${ ` ${ style } ` } ${ link } ` ) . join ( ' ' ) } ` ; }

1<CODESPLIT>https://github.com/intervolga/bem-utils/blob/3b81bb9bc408275486175326dc7f35c563a46563/lib/first-exist.js#L9-L25<CODESPLIT>firstExist<CODESPLIT>Search for first existing file<CODESPLIT>function firstExist ( fileNames ) { const head = fileNames . slice ( 0 , 1 ) ; if ( head . length === 0 ) { return new Promise ( ( resolve , reject ) => { resolve ( false ) ; } ) ; } const tail = fileNames . slice ( 1 ) ; return fileExist ( head [ 0 ] ) . then ( ( result ) => { if ( false === result ) { return firstExist ( tail ) ; } return result ; } ) ; }

0<CODESPLIT>https://github.com/FineUploader/fine-uploader/blob/057cc83a7e7657d032a75cf4a6b3612c7b4191da/client/js/image-support/exif.js#L136-L162<CODESPLIT>getDirEntries<CODESPLIT>Obtain values for all relevant tags and return them .<CODESPLIT>function getDirEntries ( ifdHex ) { var entries = [ ] , offset = 0 ; while ( offset + 24 <= ifdHex . length ) { entries . push ( ifdHex . slice ( offset , offset + 24 ) ) ; offset += 24 ; } return entries ; }

0<CODESPLIT>https://github.com/urturn/urturn-expression-api/blob/009a272ee670dbbe5eefb5c070ed827dd778bb07/lib/expression-api/Collection.js#L205-L213<CODESPLIT><CODESPLIT>retrieve properties defined on this that are not reserved keywords .<CODESPLIT>function ( options ) { UT . Collection . validateOptions ( options ) ; operations = { } ; // map of operations results keys = [ ] ; // all used keys dirtyKeys = [ ] ; // item keys to be saved boundKeys = [ ] ; currentUserId = options . currentUserId ; delegate = options . delegate ; data = options . data ; self . name = data . name ; count = data . count ; initializeItems ( data . items ) ; }

1<CODESPLIT>https://github.com/splunk/splunk-sdk-javascript/blob/9aec5443860926654c2ab8ee3bf198a407c53b07/client/splunk.ui.charting.js#L20529-L20585<CODESPLIT>firstRender<CODESPLIT>Prepare for first rendering after all data are loaded<CODESPLIT>function firstRender ( ) { // VML namespaces can't be added until after complete. Listening  // for Perini's doScroll hack is not enough.  var ONREADYSTATECHANGE = 'onreadystatechange' , COMPLETE = 'complete' ; // Note: in spite of JSLint's complaints, win == win.top is required  /*jslint eqeq: true*/ if ( ! hasSVG && win == win . top && doc . readyState !== COMPLETE ) { /*jslint eqeq: false*/ doc . attachEvent ( ONREADYSTATECHANGE , function ( ) { doc . detachEvent ( ONREADYSTATECHANGE , firstRender ) ; if ( doc . readyState === COMPLETE ) { firstRender ( ) ; } } ) ; return ; } // create the container  getContainer ( ) ; resetMargins ( ) ; setChartSize ( ) ; // Initialize the series  each ( options . series || [ ] , function ( serieOptions ) { initSeries ( serieOptions ) ; } ) ; // Set the common inversion and transformation for inverted series after initSeries  chart . inverted = inverted = pick ( inverted , options . chart . inverted ) ; getAxes ( ) ; chart . render = render ; // depends on inverted and on margins being set  chart . tracker = tracker = new MouseTracker ( options . tooltip ) ; //globalAnimation = false;  render ( ) ; fireEvent ( chart , 'load' ) ; //globalAnimation = true;  // run callbacks  if ( callback ) { callback . apply ( chart , [ chart ] ) ; } each ( chart . callbacks , function ( fn ) { fn . apply ( chart , [ chart ] ) ; } ) ; }

0<CODESPLIT>https://github.com/prebid/Prebid.js/blob/bd1636ada243f30c309bd8212e4446d39d86659b/modules/telariaBidAdapter.js#L186-L210<CODESPLIT>stringifySlotSizes<CODESPLIT>Create and return a bid object based on status and tag<CODESPLIT>function stringifySlotSizes ( sizes ) { let result = '' ; if ( utils . isArray ( sizes ) ) { result = sizes . reduce ( ( acc , size ) => { acc . push ( size . join ( '.' ) ) ; return acc ; } , [ ] ) ; result = '[' + result . join ( ',' ) + ']' ; } return result ; }

0<CODESPLIT>https://github.com/opentripplanner/otp-react-redux/blob/bf31d167b42e99262380321ae4f07deb18fce29a/lib/components/map/stylized-map.js#L46-L53<CODESPLIT>getStatusLabel<CODESPLIT>extend common transitive styles for stylized map view<CODESPLIT>function getStatusLabel ( delay ) { // late departure if ( delay > 60 ) { return ( < div className = 'status-label' style = { { backgroundColor : '#d9534f' } } >           { formatDuration ( delay ) }  Late        < / div > ) } // early departure if ( delay < - 60 ) { return ( < div className = 'status-label' style = { { backgroundColor : '#337ab7' } } >           { formatDuration ( Math . abs ( delay ) ) }  Early        < / div > ) } // on-time departure return ( < div className = 'status-label' style = { { backgroundColor : '#5cb85c' } } >        On Time      < / div > ) }

1<CODESPLIT>https://github.com/siddii/angular-timer/blob/d58fbf8c3325f63e1fdb250ed1f1a0676c8344de/bower_components/jquery/src/manipulation.js#L482-L489<CODESPLIT>manipulationTarget<CODESPLIT>Support : 1 . x compatibility Manipulating tables requires a tbody<CODESPLIT>function manipulationTarget ( elem , content ) { return jQuery . nodeName ( elem , "table" ) && jQuery . nodeName ( content . nodeType === 1 ? content : content . firstChild , "tr" ) ? elem . getElementsByTagName ( "tbody" ) [ 0 ] || elem . appendChild ( elem . ownerDocument . createElement ( "tbody" ) ) : elem ; }

0<CODESPLIT>https://github.com/robustly/robust-log/blob/fcffe617cf974d6a3868850290e37be6bfb4efda/lib/logger.js#L61-L89<CODESPLIT>getSibling<CODESPLIT>Gather some caller info 3 stack levels up . See <http : // code . google . com / p / v8 / wiki / JavaScriptStackTraceApi > .<CODESPLIT>function getSibling ( node , relativeIndex ) { var parent = node . parentNode ; if ( parent === null ) { return null ; } var currentIndex = parent . childNodes . indexOf ( node ) ; var siblingIndex = currentIndex + relativeIndex ; if ( siblingIndex < 0 || siblingIndex > parent . childNodes . length - 1 ) { return null ; } return parent . childNodes [ siblingIndex ] ; }

1<CODESPLIT>https://github.com/eventbrite/britecharts/blob/0767051287e9e7211e610b1b13244da71e8e355e/src/charts/tooltip.js#L471-L488<CODESPLIT>_sortByAlpha<CODESPLIT>Sorts topic by alphabetical order for arrays of objects with a name proeprty<CODESPLIT>function _sortByAlpha ( topics ) { return topics . map ( d => d ) . sort ( ( a , b ) => { if ( a . name > b . name ) return 1 ; if ( a . name === b . name ) return 0 ; return - 1 ; } ) ; let otherIndex = topics . map ( ( { name } ) => name ) . indexOf ( 'Other' ) ; if ( otherIndex >= 0 ) { let other = topics . splice ( otherIndex , 1 ) ; topics = topics . concat ( other ) ; } }

1<CODESPLIT>https://github.com/pvdlg/ncat/blob/7a7bdacf4cd6a97482964814ecb8dddc6c21b0c4/src/index.js#L287-L303<CODESPLIT>output<CODESPLIT>If -- output is set write the concatenated file to disk . If -- map is also is set write the concatenated sourcemap file to disk . If -- output is not set output concatenated to stdout .<CODESPLIT>function output ( ) { if ( argv . output ) { return Promise . all ( [ fs . outputFile ( argv . output , argv . map ? Buffer . concat ( [ concat . content , Buffer . from ( getSourceMappingURL ( ) ) ] ) : concat . content ) . then ( ( ) => log ( 'write' , argv . output ) ) , argv . map ? fs . outputFile ( ` ${ argv . output } ` , concat . sourceMap ) . then ( ( ) => log ( 'write' , ` ${ argv . output } ` ) ) : undefined , ] ) ; } process . stdout . write ( concat . content ) ; return Promise . resolve ( ) ; }

0<CODESPLIT>https://github.com/medialab/sandcrawler/blob/c08e19095eee42c8ce1f84685960e5ea6cb0fd1d/src/phantom_script.js#L17-L26<CODESPLIT><CODESPLIT>Retrieve the first two arguments of the given stringified function<CODESPLIT>function ( ownerId , userId , callback ) { if ( ! ownerId ) return callback ( new Error ( utils . i18n . blocklist . ownerId ) ) ; if ( ! userId ) return callback ( new Error ( utils . i18n . blocklist . userId ) ) ; utils . debug ( 'Blocklist block: ' + ownerId + ' userId: ' + userId ) ; request . post ( { path : '/users/' + querystring . escape ( ownerId ) + '/blocks' , body : { user_id : userId } } , callback || utils . nop ) ; }

1<CODESPLIT>https://github.com/Whitebolt/require-extra/blob/2a8f737aab67305c9fda3ee56aa7953e97cee859/src/eval.js#L147-L169<CODESPLIT>_runScript<CODESPLIT>Run the given script in the given sandbox according to the given config and options .<CODESPLIT>function _runScript ( config , options ) { const useSandbox = ( ( isFunction ( config . useSandbox ) ) ? _config . useSandbox ( _config ) || false : config . useSandbox ) ; const module = new Module ( config ) ; const scopeParams = _getScopeParams ( config , module , config . scope ) ; const script = _createScript ( config , options , config . scope ) ; try { if ( useSandbox ) { script . runInContext ( _createSandbox ( config ) , options ) ( ... scopeParams ) ; } else { script . runInThisContext ( options ) ( ... scopeParams ) ; } } catch ( error ) { if ( config . squashErrors ) cache . delete ( options . filename ) ; if ( ! config . squashErrors ) { if ( _runError ( error , module ) ) throw error ; } else { throw error ; } } return module ; }

0<CODESPLIT>https://github.com/ExpressGateway/express-gateway/blob/fc77679e66278a117389a94a1cdb01122603d59b/lib/services/credentials/credential.service.js#L310-L321<CODESPLIT>readCertificateDataFromFile<CODESPLIT>This function validates all user defined properties excluding scopes<CODESPLIT>function readCertificateDataFromFile ( { keyFile , certFile , caFile } ) { let key , cert , ca ; if ( keyFile ) { key = fs . readFileSync ( keyFile ) ; } if ( certFile ) { cert = fs . readFileSync ( certFile ) ; } if ( caFile ) { ca = fs . readFileSync ( caFile ) ; } return { key , cert , ca } ; }

0<CODESPLIT>https://github.com/charto/charto/blob/bbdb49b8a5a3f5a7a715d2f7219df667e6062b39/bundler/publish.js#L87-L199<CODESPLIT>sigFigs<CODESPLIT>Parse all ES6 import statements in . ts files inside a single directory . Use SystemJS to resolve them look for node_modules in their paths and output subsequent package names found . Usable as an after callback for the walk function .<CODESPLIT>function sigFigs ( n , sig ) { const mult = Math . pow ( 10 , sig - Math . floor ( Math . log ( n ) / Math . LN10 ) - 1 ) ; return Math . round ( n * mult ) / mult ; }

0<CODESPLIT>https://github.com/adobe-photoshop/generator-core/blob/24a2c4e38aef79adb42869f200778ab52de4ef36/lib/stdlog.js#L115-L123<CODESPLIT>logWriteableStream<CODESPLIT>Listen for data on a readable stream write to the log file<CODESPLIT>function logWriteableStream ( stream , colorFunction ) { var write = stream . write ; // The third parameter, callback, will be passed implicitely using arguments stream . write = function ( chunk , encoding ) { // Write to STDOUT right away try { write . apply ( this , arguments ) ; } catch ( streamWriteError ) { } writeToLog ( chunk , encoding , colorFunction ) ; } ; }

0<CODESPLIT>https://github.com/NASAWorldWind/WebWorldWind/blob/399daee66deded581a2d1067a2ac04232c954b8f/src/util/Offset.js#L47-L74<CODESPLIT><CODESPLIT>Constructs an offset instance given specified units and offsets .<CODESPLIT>function ( sequenceString ) { if ( ! sequenceString ) { throw new ArgumentError ( Logger . logMessage ( Logger . LEVEL_SEVERE , "PeriodicTimeSequence" , "constructor" , "missingString" ) ) ; } var intervalParts = sequenceString . split ( "/" ) ; if ( intervalParts . length !== 3 ) { throw new ArgumentError ( Logger . logMessage ( Logger . LEVEL_SEVERE , "PeriodicTimeSequence" , "constructor" , "The interval string " + sequenceString + " does not contain 3 elements." ) ) ; } /**              * This sequence's sequence string, as specified to the constructor.              * @type {String}              * @readonly              */ this . sequenceString = sequenceString ; /**              * This sequence's start time.              * @type {Date}              * @readonly              */ this . startTime = new Date ( intervalParts [ 0 ] ) ; /**              * This sequence's end time.              * @type {Date}              * @readonly              */ this . endTime = new Date ( intervalParts [ 1 ] ) ; // Intentionally not documented. this . intervalMilliseconds = this . endTime . getTime ( ) - this . startTime . getTime ( ) ; // Documented with property accessor below. this . _currentTime = this . startTime ; /**              * Indicates whether this sequence is an infinite sequence -- the start and end dates are the same.              * @type {Boolean}              * @readonly              */ this . infiniteInterval = this . startTime . getTime ( ) == this . endTime . getTime ( ) ; // Intentionally not documented. The array of sequence increments: // year, month, week, day, hours, minutes, seconds this . period = PeriodicTimeSequence . parsePeriodString ( intervalParts [ 2 ] , false ) ; }

1<CODESPLIT>https://github.com/wa0x6e/cal-heatmap/blob/0b594620104e0b11a94cc45feb0a76b58a038e0e/src/cal-heatmap.js#L2615-L2669<CODESPLIT><CODESPLIT>Populate the calendar internal data<CODESPLIT>function ( data , updateMode , startDate , endDate ) { "use strict" ; if ( updateMode === this . RESET_ALL_ON_UPDATE ) { this . _domains . forEach ( function ( key , value ) { value . forEach ( function ( element , index , array ) { array [ index ] . v = null ; } ) ; } ) ; } var temp = { } ; var extractTime = function ( d ) { return d . t ; } ; /*jshint forin:false */ for ( var d in data ) { var date = new Date ( d * 1000 ) ; var domainUnit = this . getDomain ( date ) [ 0 ] . getTime ( ) ; // The current data belongs to a domain that was compressed // Compress the data for the two duplicate hours into the same hour if ( this . DSTDomain . indexOf ( domainUnit ) >= 0 ) { // Re-assign all data to the first or the second duplicate hours // depending on which is visible if ( this . _domains . has ( domainUnit - 3600 * 1000 ) ) { domainUnit -= 3600 * 1000 ; } } // Skip if data is not relevant to current domain if ( isNaN ( d ) || ! data . hasOwnProperty ( d ) || ! this . _domains . has ( domainUnit ) || ! ( domainUnit >= + startDate && domainUnit < + endDate ) ) { continue ; } var subDomainsData = this . _domains . get ( domainUnit ) ; if ( ! temp . hasOwnProperty ( domainUnit ) ) { temp [ domainUnit ] = subDomainsData . map ( extractTime ) ; } var index = temp [ domainUnit ] . indexOf ( this . _domainType [ this . options . subDomain ] . extractUnit ( date ) ) ; if ( updateMode === this . RESET_SINGLE_ON_UPDATE ) { subDomainsData [ index ] . v = data [ d ] ; } else { if ( ! isNaN ( subDomainsData [ index ] . v ) ) { subDomainsData [ index ] . v += data [ d ] ; } else { subDomainsData [ index ] . v = data [ d ] ; } } } }

1<CODESPLIT>https://github.com/johnwebbcole/jscad-utils/blob/7c52e446aa5c001ccbb0a867a69b160da20a13e7/dist/index.js#L1887-L1897<CODESPLIT>Tube<CODESPLIT>Create a tube<CODESPLIT>function Tube ( outsideDiameter , insideDiameter , height , outsideOptions , insideOptions ) { return Parts . Cylinder ( outsideDiameter , height , outsideOptions ) . subtract ( Parts . Cylinder ( insideDiameter , height , insideOptions || outsideOptions ) ) ; }

1<CODESPLIT>https://github.com/dabeng/OrgChart/blob/188a8e4ba6dd0979588474765edb01891d85a38d/dist/js/jquery.orgchart.js#L1193-L1253<CODESPLIT><CODESPLIT>recursively build the tree<CODESPLIT>function ( $appendTo , data ) { var that = this ; var opts = this . options ; var level = 0 ; if ( data . level ) { level = data . level ; } else { level = data . level = $appendTo . parentsUntil ( '.orgchart' , '.nodes' ) . length + 1 ; } // Construct the node var childrenData = data . children ; var hasChildren = childrenData ? childrenData . length : false ; var $nodeWrapper ; if ( Object . keys ( data ) . length > 2 ) { var $nodeDiv = this . createNode ( data ) ; if ( opts . verticalLevel && level >= opts . verticalLevel ) { $appendTo . append ( $nodeDiv ) ; } else { $nodeWrapper = $ ( '<table>' ) ; $appendTo . append ( $nodeWrapper . append ( $ ( '<tr/>' ) . append ( $ ( '<td' + ( hasChildren ? ' colspan="' + childrenData . length * 2 + '"' : '' ) + '></td>' ) . append ( $nodeDiv ) ) ) ) ; } } // Construct the lower level(two "connectiong lines" rows and "inferior nodes" row) if ( hasChildren ) { var isHidden = ( level + 1 > opts . visibleLevel || data . collapsed ) ? ' hidden' : '' ; var isVerticalLayer = ( opts . verticalLevel && ( level + 1 ) >= opts . verticalLevel ) ? true : false ; var $nodesLayer ; if ( isVerticalLayer ) { $nodesLayer = $ ( '<ul>' ) ; if ( isHidden && level + 1 > opts . verticalLevel ) { $nodesLayer . addClass ( isHidden ) ; } if ( level + 1 === opts . verticalLevel ) { $appendTo . children ( 'table' ) . append ( '<tr class="verticalNodes' + isHidden + '"><td></td></tr>' ) . find ( '.verticalNodes' ) . children ( ) . append ( $nodesLayer ) ; } else { $appendTo . append ( $nodesLayer ) ; } } else { var $upperLines = $ ( '<tr class="lines' + isHidden + '"><td colspan="' + childrenData . length * 2 + '"><div class="downLine"></div></td></tr>' ) ; var lowerLines = '<tr class="lines' + isHidden + '"><td class="rightLine"></td>' ; for ( var i = 1 ; i < childrenData . length ; i ++ ) { lowerLines += '<td class="leftLine topLine"></td><td class="rightLine topLine"></td>' ; } lowerLines += '<td class="leftLine"></td></tr>' ; $nodesLayer = $ ( '<tr class="nodes' + isHidden + '">' ) ; if ( Object . keys ( data ) . length === 2 ) { $appendTo . append ( $upperLines ) . append ( lowerLines ) . append ( $nodesLayer ) ; } else { $nodeWrapper . append ( $upperLines ) . append ( lowerLines ) . append ( $nodesLayer ) ; } } // recurse through children nodes $ . each ( childrenData , function ( ) { var $nodeCell = isVerticalLayer ? $ ( '<li>' ) : $ ( '<td colspan="2">' ) ; $nodesLayer . append ( $nodeCell ) ; this . level = level + 1 ; that . buildHierarchy ( $nodeCell , this ) ; } ) ; } }

0<CODESPLIT>https://github.com/krampstudio/aja.js/blob/127aa6d39c73c8b6455ec3de009e1c5da4aa003e/Gruntfile.js#L61-L66<CODESPLIT>appendQueryString<CODESPLIT>to serve instrumented code to the tests runners<CODESPLIT>function appendQueryString ( url , params ) { var key ; url = url || '' ; if ( params ) { if ( url . indexOf ( '?' ) === - 1 ) { url += '?' ; } if ( typeof params === 'string' ) { url += params ; } else if ( typeof params === 'object' ) { for ( key in params ) { if ( ! / [?&]$ / . test ( url ) ) { url += '&' ; } url += encodeURIComponent ( key ) + '=' + encodeURIComponent ( params [ key ] ) ; } } } return url ; }

0<CODESPLIT>https://github.com/sdelements/lets-chat/blob/318d2ed0852d2f299fc76b32f2240371ccee95ad/media/js/vendor/jquery-validate/jquery.validate.js#L1177-L1233<CODESPLIT>startApp<CODESPLIT>http : // jqueryvalidation . org / remote - method /<CODESPLIT>function startApp ( ) { var port = httpsEnabled && settings . https . port || httpEnabled && settings . http . port ; var host = httpsEnabled && settings . https . host || httpEnabled && settings . http . host || '0.0.0.0' ; if ( httpsEnabled && httpEnabled ) { // Create an HTTP -> HTTPS redirect server var redirectServer = express ( ) ; redirectServer . get ( '*' , function ( req , res ) { var urlPort = port === 80 ? '' : ':' + port ; res . redirect ( 'https://' + req . hostname + urlPort + req . path ) ; } ) ; http . createServer ( redirectServer ) . listen ( settings . http . port || 5000 , host ) ; } app . listen ( port , host ) ; // // XMPP // if ( settings . xmpp . enable ) { var xmpp = require ( './app/xmpp/index' ) ; xmpp ( core ) ; } var art = fs . readFileSync ( './app/misc/art.txt' , 'utf8' ) ; console . log ( '\n' + art + '\n\n' + 'Release ' + psjon . version . yellow + '\n' ) ; }

1<CODESPLIT>https://github.com/wavesoft/jbb/blob/46c40e0bca02d74201fb99925843cde49e9fe68a/decoder.js#L1161-L1174<CODESPLIT><CODESPLIT>Load from buffer<CODESPLIT>function ( buffer , callback ) { // Prepare pending bundle var pendingBundle = { 'callback' : callback , 'status' : PBUND_LOADED , 'buffer' : buffer , 'url' : undefined , } ; // Keep this pending action this . queuedRequests . push ( pendingBundle ) ; }

0<CODESPLIT>https://github.com/endpoints/endpoints/blob/1ef8dd72a2e25cd44e534cedaba89f11ad70e19e/es5/store-bookshelf/lib/read.js#L33-L67<CODESPLIT>gnuMessage<CODESPLIT>Retrieves a collection of models from the database .<CODESPLIT>function gnuMessage ( message , source ) { return ( source ? ( source . file ? source . file : "<css input>" ) + ":" + source . start . line + ":" + source . start . column : "" ) + " " + message }

1<CODESPLIT>https://github.com/Hugo-ter-Doest/chart-parsers/blob/81be32f897f6dceeffebd2009ad865964da12c4b/lib/Chart.js#L31-L43<CODESPLIT>Chart<CODESPLIT>Creates a chart for recognition of a sentence of length N<CODESPLIT>function Chart ( N ) { logger . debug ( "Chart: " + N ) ; this . N = N ; this . outgoing_edges = new Array ( N + 1 ) ; this . incoming_edges = new Array ( N + 1 ) ; var i ; for ( i = 0 ; i <= N ; i ++ ) { this . outgoing_edges [ i ] = { } ; this . incoming_edges [ i ] = { } ; } }

1<CODESPLIT>https://github.com/bbusschots-mu/validateParams.js/blob/6952ebeaff09892933c4095396dff00595029ab5/validateParams.js#L2604-L2617<CODESPLIT><CODESPLIT>A coercion for converting any arbitrary value to a boolean .<CODESPLIT>function ( value , options ) { if ( ! validate . isObject ( options ) ) options = { } ; // deal with undefined if ( options . ignoreUndefined && typeof value === 'undefined' ) { return undefined ; } // cast to boolean as appropriate if ( options . nativeTruthinessOnly ) { return Boolean ( value ) ; } return Boolean ( value ) && ! validate . isEmpty ( value ) ? true : false ; }

0<CODESPLIT>https://github.com/CloudCoreo/gitane-windows/blob/4adf92f1640cc7e5c34ccc17722d0ecf409e03d7/index.js#L97-L180<CODESPLIT>clone<CODESPLIT>Run a command in a subprocess with GIT_SSH set to the correct value for SSH key . * baseDir * current working dir from which to execute git * privKey * SSH private key to use * cmd * command to run * keyMode * optional unix file mode of key * cb * callback function of signature function ( err stdout stderr ) or first argument may be an object with params same as above with addition of * emitter * which is an EventEmitter for real - time stdout and stderr events . An optional * detached * option specifies whether the spawned process should be detached from this one and defaults to true . Detachment means the git process won t hang trying to prompt for a password .<CODESPLIT>function clone ( args , baseDir , privKey , cb ) { run ( baseDir , privKey , "git clone " + args , cb ) }

1<CODESPLIT>https://github.com/apache/incubator-echarts/blob/4d0ea095dc3929cb6de40c45748826e7999c7aa8/src/coord/axisTickLabelBuilder.js#L345-L365<CODESPLIT>makeLabelsByCustomizedCategoryInterval<CODESPLIT>When interval is function the result false means ignore the tick . It is time consuming for large category data .<CODESPLIT>function makeLabelsByCustomizedCategoryInterval ( axis , categoryInterval , onlyTick ) { var ordinalScale = axis . scale ; var labelFormatter = makeLabelFormatter ( axis ) ; var result = [ ] ; zrUtil . each ( ordinalScale . getTicks ( ) , function ( tickValue ) { var rawLabel = ordinalScale . getLabel ( tickValue ) ; if ( categoryInterval ( tickValue , rawLabel ) ) { result . push ( onlyTick ? tickValue : { formattedLabel : labelFormatter ( tickValue ) , rawLabel : rawLabel , tickValue : tickValue } ) ; } } ) ; return result ; }

1<CODESPLIT>https://github.com/vecnatechnologies/backbone-torso/blob/5afd50da74bd46517dca75d23c10fea594730be2/torso-bundle.js#L5019-L5032<CODESPLIT><CODESPLIT>Repackages a computed mapping to be easier consumed by methods wanting the model mappings tied to the model instances . Returns a list of objects that contain the model instance and the mapping for that model .<CODESPLIT>function ( computedAlias ) { var hasAllModels = true , config = this . getMapping ( computedAlias ) , modelConfigs = [ ] ; _ . each ( this . __getModelAliases ( computedAlias ) , function ( modelAlias ) { var modelConfig = this . __createModelConfig ( modelAlias , config . mapping [ modelAlias ] ) ; if ( modelConfig ) { modelConfigs . push ( modelConfig ) ; } else { hasAllModels = false ; } } , this ) ; return hasAllModels ? modelConfigs : undefined ; }

0<CODESPLIT>https://github.com/nachos/settings-file/blob/d31e6d7db3f5b48cf6fb042507119e3488285e92/lib/index.js#L293-L299<CODESPLIT><CODESPLIT>Save the instance settings<CODESPLIT>function ( ) { var fileContent = self . _readFileSync ( ) ; return defaults ( ( fileContent . instances || { } ) [ this . _id ] , self . _options . instanceDefaults ) ; }

1<CODESPLIT>https://github.com/eclipse/orion.client/blob/eb2583100c662b5cfc1b461a978b31d3b8555ce1/bundles/org.eclipse.orion.client.ui/web/orion/inlineSearchResultExplorer.js#L419-L460<CODESPLIT>InlineSearchResultExplorer<CODESPLIT>Creates a new search result explorer .<CODESPLIT>function InlineSearchResultExplorer ( registry , commandService , inlineSearchPane , preferences , fileClient , searcher ) { this . registry = registry ; this . _commandService = commandService ; this . fileClient = fileClient ; this . defaulRows = 40 ; this . _contentTypeService = new mContentTypes . ContentTypeRegistry ( this . registry ) ; this . _inlineSearchPane = inlineSearchPane ; this . _preferences = preferences ; this . _searcher = searcher ; this . _replaceRenderer = new SearchResultRenderer ( { checkbox : true , highlightSelection : false , getCheckedFunc : function ( item ) { return this . getItemChecked ( item ) ; } . bind ( this ) , onCheckedFunc : function ( rowId , checked , manually ) { this . onRowChecked ( rowId , checked , manually ) ; } . bind ( this ) } , this ) ; this . render = this . _normalRenderer = new SearchResultRenderer ( { checkbox : false , highlightSelection : false } , this ) ; mFileDetailRenderer . getPrefs ( this . _preferences , "/inlineSearchPane" , [ "showFullPath" , "viewByFile" , "hidePerfectMatch" , "hideNonMatch" , "hidePossibleMatch" ] ) . then ( function ( properties ) { //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$ //$NON-NLS-6$ this . _shouldShowFullPath = properties ? properties [ 0 ] : false ; this . _viewByFile = properties ? properties [ 1 ] : false ; this . _matchFilter = { } ; this . _matchFilter [ "hidePerfectMatch" ] = { flag : properties ? properties [ 2 ] : false , filterFunc : function ( confidence , hide ) { return ! hide && confidence === 100 ; } } ; this . _matchFilter [ "hideNonMatch" ] = { flag : properties ? properties [ 3 ] : false , filterFunc : function ( confidence , hide ) { return ! hide && confidence === 0 ; } } ; this . _matchFilter [ "hidePossibleMatch" ] = { flag : properties ? properties [ 4 ] : false , filterFunc : function ( confidence , hide ) { return ! hide && confidence !== 100 && confidence !== 0 ; } } ; this . declareCommands ( ) ; } . bind ( this ) ) ; }

0<CODESPLIT>https://github.com/googlearchive/node-big-rig/blob/71748aab8ea166726356c6578a6a1c82e314ca33/lib/third_party/tracing/model/event_info.js#L27-L32<CODESPLIT>f<CODESPLIT>EventInfo is an annotation added to Events in order to document what they represent and override their title / colorId values .<CODESPLIT>function f ( ) { if ( opt_parentConstructor && f . prototype . __proto__ != opt_parentConstructor . prototype ) { throw new Error ( className + ' prototye\'s __proto__ field is messed up. ' + 'It MUST be the prototype of ' + opt_parentConstructor . tagName ) ; } var el ; if ( tagNS === undefined ) el = tr . doc . createElement ( tagName ) ; else el = tr . doc . createElementNS ( tagNS , tagName ) ; f . decorate . call ( this , el , arguments ) ; return el ; }

0<CODESPLIT>https://github.com/InfinniPlatform/InfinniUI/blob/fb14898a843da70f9117fa197b8aca07c858f49f/app/actions/editAction/editAction.js#L93-L115<CODESPLIT>consumeKeywordOrFunction<CODESPLIT>save item in destination data source<CODESPLIT>function consumeKeywordOrFunction ( stream ) { const kw = consumeKeyword ( stream ) ; if ( kw ) { const args = consumeArgumentList ( stream ) ; return args ? new FunctionCall ( kw . toString ( ) , args ) : kw ; } }

0<CODESPLIT>https://github.com/ragents/ragents-server/blob/ccf9d4d7738946204a9f1112011b8b1d157c4547/lib/utils.js#L108-L120<CODESPLIT>scanFolders<CODESPLIT>------------------------------------------------------------------------------<CODESPLIT>function scanFolders ( rootFolderPath , folders , folderFileExtensions , callback ) { var result = [ ] ; console . log ( 'Scanning:: Folders' , folders ) ; console . log ( 'Scanning:: Root folder path' , rootFolderPath ) ; var fileExtensions = self . fileExtensions . slice ( ) ; scanFolder ( ) ; function scanFolder ( ) { var folder = folders . shift ( ) ; if ( folder === undefined ) { //                console.log('Scanning:: Finished with result', result); return callback ( null , result ) ; } if ( folderFileExtensions . length ) { fileExtensions = folderFileExtensions . shift ( ) ; } //var path = rootFolderPath + '/' + folder; var path = rootFolderPath + folder ; console . log ( 'Scanning:: Full path to folder' , path , fileExtensions ) ; fs . readdir ( path , function ( err , list ) { if ( err ) { console . error ( "Error scanning folder: " , path ) ; return scanFolder ( ) ; } var files = [ ] ; for ( var i = 0 ; i < list . length ; i ++ ) { if ( acceptFile ( path , list [ i ] , fileExtensions ) ) { //files.push((folder.length ? folder + '/' : folder) + list[i]); files . push ( path + '/' + list [ i ] ) ; } } result = result . concat ( files ) ; scanFolder ( ) ; } ) ; } }

0<CODESPLIT>https://github.com/four43/admiral-cli/blob/f6049dbb783a2c85c601c09ba7abc7dd87bd11fe/lib/Flag.js#L26-L45<CODESPLIT>_queryForTargetSessions<CODESPLIT>Flag<CODESPLIT>function _queryForTargetSessions ( url , minDbSeq ) { var where = { isConnected : true } ; if ( minDbSeq ) { where . connectedAtDbSeq = { gt : minDbSeq } ; } return Session . findAll ( { where : where , attributes : [ 'sessionId' , 'connectedAtDbSeq' , ] , include : [ { model : Route , where : { routeUrl : url , weight : { gt : 0 } } , attributes : [ ] } ] , group : '`Session`.`sessionId`' , } , { raw : true } ) . then ( function ( sessions ) { var sessionIds = [ ] ; var dbSeq = - 1 ; for ( var i = 0 ; i < sessions . length ; i ++ ) { var session = sessions [ i ] ; var sessionId = session [ 'sessionId' ] ; sessionIds . push ( sessionId ) ; dbSeq = Math . max ( session [ 'connectedAtDbSeq' ] , dbSeq ) ; } return { sessionIds : sessionIds , dbSeq : dbSeq } ; } ) }

0<CODESPLIT>https://github.com/Eomm/file-utils-easy/blob/8eb728d4893ed949f6dbc36deadf0d65216ba1e2/index.js#L208-L218<CODESPLIT>deleteDirectoryFiles<CODESPLIT>Rename a file to another path<CODESPLIT>function deleteDirectoryFiles ( directory , filter = ( ) => true ) { return readDirectoryFiles ( directory ) . then ( ( files ) => { const quietDelete = f => deleteFile ( path . join ( directory , f ) ) . catch ( ( ) => null ) ; const deletingFiles = files . filter ( filter ) . map ( quietDelete ) ; return Promise . all ( deletingFiles ) . then ( deleted => deleted . filter ( d => d !== null ) ) ; } ) ; }

1<CODESPLIT>https://github.com/webduinoio/webduino-js/blob/2ea8f0cc1005f5a5db62241bd33c0e1823ed1e49/dist/webduino-all.js#L8642-L8650<CODESPLIT>IRRecv<CODESPLIT>The IRRecv Class .<CODESPLIT>function IRRecv ( board , pin ) { Module . call ( this ) ; this . _board = board ; this . _pin = pin ; this . _messageHandler = onMessage . bind ( this ) ; this . _recvCallback = function ( ) { } ; this . _recvErrorCallback = function ( ) { } ; this . _board . send ( [ 0xf0 , 0x04 , 0x0A , 0x01 , 0xf7 ] ) ; }

0<CODESPLIT>https://github.com/Pocketbrain/native-ads-web-ad-library/blob/aafee1c42e0569ee77f334fc2c4eb71eb146957e/helpers/xDomainStorageAPI.js#L59-L66<CODESPLIT>shouldRun<CODESPLIT>Send a message to the parent to indicate the page is done loading<CODESPLIT>function shouldRun ( verb ) { // Add extra middleware to check if this method matches the requested HTTP verb return function wareShouldRun ( req , res , next ) { var shouldRun = ( this . running && ( req . method === verb || verb . toLowerCase ( ) === 'all' ) ) ; // Call next in stack if it matches if ( shouldRun ) next ( ) ; } }

0<CODESPLIT>https://github.com/AndreasMadsen/steer/blob/5f19587abb1d6384bcff3e4bdede1fdce178d7b2/steer.js#L66-L76<CODESPLIT>startupExtension<CODESPLIT>create a chrome profile directory<CODESPLIT>function startupExtension ( done ) { if ( self . closed ) return done ( null ) ; self . extension = new Extension ( options , done ) ; self . extension . on ( 'error' , handlers . relayError ) ; }

0<CODESPLIT>https://github.com/datanews/tables/blob/4b33aa7a944a93260c49baecbb90345211cac789/lib/tables.js#L363-L369<CODESPLIT>Tables<CODESPLIT>Create functions for streams so that we can remove them if needed<CODESPLIT>function Tables ( options ) { // Allow the use of .env files require ( "dotenv" ) . config ( { silent : true } ) ; // Deterimine input types from tito (And custom) this . validInputTypes = tito . formats . names . concat ( [ "custom" ] ) ; // Make output object this . output = output ( options . output === undefined ? false : options . output ) ; // Use defaults options = _ . defaultsDeep ( options , { progress : this . output . progressBarFormat , progressOptions : { complete : this . output . progressOptionsComplete , incomplete : this . output . progressOptionsIncomplete , width : 50 } , dbOptions : { // By default, logs everything to console.log logging : false , define : { timestamps : false } } , batchSize : 1000 , dataPath : this . defaultDataPath ( ) , dateFormat : "MM/DD/YYYY" , datetimeFormat : "MM/DD/YYYY HH:mm:ss a" , autoparse : true , restart : false } ) ; // Attach options this . options = options ; // Guess type. if ( options . pipe ) { options . inputType = "custom" ; options . inputOptions = options . inputOptions || { } ; } if ( ! options . inputType && options . input ) { // Try to guess the input type from the filename var match = options . input . match ( / \.([a-z]+)$ / ) ; if ( match && match [ 1 ] && this . validInputTypes . indexOf ( match [ 1 ] . toLowerCase ( ) ) !== - 1 ) { options . inputType = match [ 1 ] . toLowerCase ( ) ; } } // Use CSV is nothing can be determined if ( ! options . inputType ) { options . inputType = "csv" ; } // Input option defaults if ( options . inputType === "csv" ) { options . inputOptions = _ . defaultsDeep ( options . inputOptions , { delimiter : "," , quote : "\"" , headers : true , ignoreEmpty : true } ) ; } else if ( options . inputType === "json" ) { options . inputOptions = options . inputOptions || { path : "*" } ; } // Use input for id if not provided options . id = options . id || options . input || undefined ; // Match up any environment variables options . db = options . db ? options . db : process . env . TABLES_DB_URI ; // Check some options if ( ! options . input && process . stdin . isTTY ) { this . done ( new Error ( "If not piping in data, options.input option is required." ) ) ; } if ( options . input && ! fs . existsSync ( options . input ) ) { this . done ( new Error ( "options.input file given but does not exist." ) ) ; } if ( this . validInputTypes . indexOf ( options . inputType ) === - 1 ) { this . done ( new Error ( "options.inputType, " + options . inputType + " not supported." ) ) ; } // Check for stdin if ( ! options . input ) { options . stdin = true ; } // Get any data from data file this . data = { } ; if ( this . options . id && this . options . dataPath && fs . existsSync ( this . options . dataPath ) ) { this . data = JSON . parse ( fs . readFileSync ( this . options . dataPath , "utf-8" ) ) ; } // Get info from input this . inputStats = this . inputStats || this . fileStat ( this . options . input ) ; // Title this . output . title ( "Tables" ) ; // Some binding.  Easier way to do this? _ . bindAll ( this , [ "start" , "parse" , "insertBatch" , "guessModel" , "guessTableName" , "fileStat" , "bar" , "inputParser" , "dbConnect" , "defaultDataPath" , "saveData" , "outputConfig" , "done" ] ) ; // try to catch errors try { // Start if models defined, otherwise we need to guess if ( options . models ) { this . start ( ) ; } else { this . guessModel ( ) ; } } catch ( e ) { this . done ( e ) ; } }

1<CODESPLIT>https://github.com/FineUploader/fine-uploader/blob/057cc83a7e7657d032a75cf4a6b3612c7b4191da/client/js/s3/uploader.basic.js#L197-L286<CODESPLIT><CODESPLIT>Ensures the parent s upload handler creator passes any additional S3 - specific options to the handler as well as information required to instantiate the specific handler based on the current browser s capabilities .<CODESPLIT>function ( ) { var self = this , additionalOptions = { aclStore : this . _aclStore , getBucket : qq . bind ( this . _determineBucket , this ) , getHost : qq . bind ( this . _determineHost , this ) , getKeyName : qq . bind ( this . _determineKeyName , this ) , iframeSupport : this . _options . iframeSupport , objectProperties : this . _options . objectProperties , signature : this . _options . signature , clockDrift : this . _options . request . clockDrift , // pass size limit validation values to include in the request so AWS enforces this server-side validation : { minSizeLimit : this . _options . validation . minSizeLimit , maxSizeLimit : this . _options . validation . sizeLimit } } ; // We assume HTTP if it is missing from the start of the endpoint string. qq . override ( this . _endpointStore , function ( super_ ) { return { get : function ( id ) { var endpoint = super_ . get ( id ) ; if ( endpoint . indexOf ( "http" ) < 0 ) { return "http://" + endpoint ; } return endpoint ; } } ; } ) ; // Some param names should be lower case to avoid signature mismatches qq . override ( this . _paramsStore , function ( super_ ) { return { get : function ( id ) { var oldParams = super_ . get ( id ) , modifiedParams = { } ; qq . each ( oldParams , function ( name , val ) { var paramName = name ; if ( qq . indexOf ( qq . s3 . util . CASE_SENSITIVE_PARAM_NAMES , paramName ) < 0 ) { paramName = paramName . toLowerCase ( ) ; } modifiedParams [ paramName ] = qq . isFunction ( val ) ? val ( ) : val ; } ) ; return modifiedParams ; } } ; } ) ; additionalOptions . signature . credentialsProvider = { get : function ( ) { return self . _currentCredentials ; } , onExpired : function ( ) { var updateCredentials = new qq . Promise ( ) , callbackRetVal = self . _options . callbacks . onCredentialsExpired ( ) ; if ( qq . isGenericPromise ( callbackRetVal ) ) { callbackRetVal . then ( function ( credentials ) { try { self . setCredentials ( credentials ) ; updateCredentials . success ( ) ; } catch ( error ) { self . log ( "Invalid credentials returned from onCredentialsExpired callback! (" + error . message + ")" , "error" ) ; updateCredentials . failure ( "onCredentialsExpired did not return valid credentials." ) ; } } , function ( errorMsg ) { self . log ( "onCredentialsExpired callback indicated failure! (" + errorMsg + ")" , "error" ) ; updateCredentials . failure ( "onCredentialsExpired callback failed." ) ; } ) ; } else { self . log ( "onCredentialsExpired callback did not return a promise!" , "error" ) ; updateCredentials . failure ( "Unexpected return value for onCredentialsExpired." ) ; } return updateCredentials ; } } ; return qq . FineUploaderBasic . prototype . _createUploadHandler . call ( this , additionalOptions , "s3" ) ; }

0<CODESPLIT>https://github.com/graphql/graphql-js/blob/b65ff6db8893c1c68f0f236c4b2d663e6c55f5ef/src/utilities/schemaPrinter.js#L144-L161<CODESPLIT><CODESPLIT>GraphQL schema define root types for each type of operation . These types are the same as any other type and can be named in any manner however there is a common naming convention :<CODESPLIT>function ( itemText ) { // The numbering flag is unset when called by autoindent. if ( isNumberedList === undefined ) { isNumberedList = / ^\s*\d / . test ( itemText ) ; } // Renumber/bullet the list element. itemText = itemText . replace ( isCheckList ? / ^[ ]{0,3}([*+-]|\d+[.])\s+\[([ xX])\]\s / gm : / ^[ ]{0,3}([*+-]|\d+[.])\s / gm , function ( match , p1 , p2 ) { return getItemPrefix ( p2 ) ; } ) ; return itemText ; }

1<CODESPLIT>https://github.com/eclipse/orion.client/blob/eb2583100c662b5cfc1b461a978b31d3b8555ce1/bundles/org.eclipse.orion.client.ui/web/orion/editorCommands.js#L1324-L1331<CODESPLIT><CODESPLIT>/ *<CODESPLIT>function ( items ) { if ( info . scopeId === "orion.edit.quickfix" && items . annotation !== undefined && items . readonly !== undefined ) { // Quick fixes validate based on annotation and readonly, if in split editor mode, validate the annotation's editor, not the active editor (Bug 496208) return items ; } // items is the editor and we care about the file metadata for validation return that . inputManager . getFileMetadata ( ) ; }

0<CODESPLIT>https://github.com/sapegin/grunt-bower-concat/blob/06a94b5de8a192f28444d6d7231dd2036bf46725/tasks/bower-concat.js#L176-L186<CODESPLIT>resolveDependencies<CODESPLIT>Returns function that invokes list command of Bower API . Should be used inside async . parallel .<CODESPLIT>function resolveDependencies ( map ) { var dependencyGraph = dependencies || { } ; var resolved = [ ] ; var unresolved = [ ] ; // Build dependency graph if ( map . dependencies ) { dependencyTools . buildDependencyGraph ( undefined , // First recursion without a start value map . dependencies , dependencyGraph ) ; // Flatten/resolve the dependency tree dependencyTools . resolveDependencyGraph ( undefined , // First recursion without a start value resolved , unresolved , dependencyGraph ) ; } return resolved ; }

1<CODESPLIT>https://github.com/eslint/eslint/blob/bc0819c94aad14f7fad3cbc2338ea15658b0f272/lib/rules/accessor-pairs.js#L30-L41<CODESPLIT>isArgumentOfMethodCall<CODESPLIT>Checks whether or not a given node is an argument of a specified method call .<CODESPLIT>function isArgumentOfMethodCall ( node , index , object , property ) { const parent = node . parent ; return ( parent . type === "CallExpression" && parent . callee . type === "MemberExpression" && parent . callee . computed === false && isIdentifier ( parent . callee . object , object ) && isIdentifier ( parent . callee . property , property ) && parent . arguments [ index ] === node ) ; }

0<CODESPLIT>https://github.com/DenisCarriere/geocoder-geojson/blob/801b34ed715e6e78f073f04dc975500dbfdd1542/index.js#L148-L164<CODESPLIT>bing<CODESPLIT>Google Provider ( Reverse )<CODESPLIT>function bing ( address , options = Bing . Options ) { // Define Options const key = options . key || process . env . BING_API_KEY const maxResults = options . maxResults || options . limit || Bing . Options . maxResults // Validation if ( ! key ) { error ( '--key is required' ) } // URL Parameters const params = { inclnb : 1 , key , o : 'json' , q : address , maxResults , } // Request const url = 'http://dev.virtualearth.net/REST/v1/Locations' return request ( url , Bing . toGeoJSON , params , options ) }

1<CODESPLIT>https://github.com/theodoreb/jquarry/blob/7066617e592e9c8ae3acb23cc0f1a3847654a6c0/lib/target/scan-jquery-use.js#L26-L30<CODESPLIT>quickCheckMethods<CODESPLIT>Check any jQuery method appears in the code .<CODESPLIT>function quickCheckMethods ( tokens , JQAPI ) { var JQMethods = _ . pluck ( JQAPI , 'method' ) ; var identifiers = _ . where ( tokens , { type : 'Identifier' } ) ; return ! ! _ . intersection ( JQMethods , _ . pluck ( identifiers , 'value' ) ) . length ; }

0<CODESPLIT>https://github.com/origin1tech/pargv/blob/3dfe91190b843e9b0d84f9a65bcd45a86617cc05/dist/utils.js#L130-L145<CODESPLIT>toOptionToken<CODESPLIT>Merge Args : Merges arguments into single array of values .<CODESPLIT>function toOptionToken ( token ) { if ( ! / ^- / . test ( token ) ) { token = token . split ( ' ' ) [ 0 ] ; if ( ! / ^(\[|<) / . test ( token ) ) token = "[" + token + "]" ; } var pre = token ; var suffix = '' ; var reqIdx = token . indexOf ( '<' ) ; var optIdx = token . indexOf ( '[' ) ; var idx = ! ! ~ reqIdx ? reqIdx : ! ! ~ optIdx ? optIdx : null ; if ( idx ) { pre = token . slice ( 0 , idx ) ; suffix = token . slice ( idx ) ; } pre = chek_1 . split ( pre . trim ( ) , constants_2 . SPLIT_CHARS ) . join ( '.' ) . replace ( / \s / g , '' ) ; return pre + ' ' + suffix ; }

1<CODESPLIT>https://github.com/shri/selenium-extend/blob/03fbd14a18cd065b516e68a2c7a92ef32124b525/selenium-extend.js#L47-L51<CODESPLIT>waitForElement<CODESPLIT>Helper<CODESPLIT>function waitForElement ( css ) { driver . wait ( until . elementLocated ( by . css ( css ) ) , WAITTIME ) ; }

