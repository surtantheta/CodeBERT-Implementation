1<CODESPLIT>https://github.com/riteshvish/google-contacts-crud/blob/1b34744dfaf17a5dd0d9104296e10dec51c30be3/lib/google-contacts.js#L35-L39<CODESPLIT><CODESPLIT>@classdesc This class interact with Google Contacts API .<CODESPLIT>function ( clientId , clientSecret ) { this . _clientId = clientId this . _clientSecret = clientSecret this . _auth = new googleAuth . OAuth2 ( clientId , clientSecret , '' ) ; }

1<CODESPLIT>https://github.com/Kolbaskin/yode-server/blob/55ab6680efcca9d298683eed7fc6a16933f10ace/static/ext/src/lang/Date.js#L1625-L1649<CODESPLIT><CODESPLIT>Maintains compatibility with old static and prototype window . Date methods .<CODESPLIT>function ( ) { var nativeDate = window . Date , p , statics = [ 'useStrict' , 'formatCodeToRegex' , 'parseFunctions' , 'parseRegexes' , 'formatFunctions' , 'y2kYear' , 'MILLI' , 'SECOND' , 'MINUTE' , 'HOUR' , 'DAY' , 'MONTH' , 'YEAR' , 'defaults' , 'dayNames' , 'monthNames' , 'monthNumbers' , 'getShortMonthName' , 'getShortDayName' , 'getMonthNumber' , 'formatCodes' , 'isValid' , 'parseDate' , 'getFormatCode' , 'createFormat' , 'createParser' , 'parseCodes' ] , proto = [ 'dateFormat' , 'format' , 'getTimezone' , 'getGMTOffset' , 'getDayOfYear' , 'getWeekOfYear' , 'isLeapYear' , 'getFirstDayOfMonth' , 'getLastDayOfMonth' , 'getDaysInMonth' , 'getSuffix' , 'clone' , 'isDST' , 'clearTime' , 'add' , 'between' ] , sLen = statics . length , pLen = proto . length , stat , prot , s ; //Append statics for ( s = 0 ; s < sLen ; s ++ ) { stat = statics [ s ] ; nativeDate [ stat ] = utilDate [ stat ] ; } //Append to prototype for ( p = 0 ; p < pLen ; p ++ ) { prot = proto [ p ] ; nativeDate . prototype [ prot ] = function ( ) { var args = Array . prototype . slice . call ( arguments ) ; args . unshift ( this ) ; return utilDate [ prot ] . apply ( utilDate , args ) ; } ; } }

1<CODESPLIT>https://github.com/runtimejs/runtime/blob/1955dbf3204e22bace7cfbbb6f52bb5d57a8c1e4/deps/v8/benchmarks/navier-stokes.js#L82-L387<CODESPLIT>FluidField<CODESPLIT>Code from Oliver Hunt ( http : // nerget . com / fluidSim / pressure . js ) starts here .<CODESPLIT>function FluidField ( canvas ) { function addFields ( x , s , dt ) { for ( var i = 0 ; i < size ; i ++ ) x [ i ] += dt * s [ i ] ; } function set_bnd ( b , x ) { if ( b === 1 ) { for ( var i = 1 ; i <= width ; i ++ ) { x [ i ] = x [ i + rowSize ] ; x [ i + ( height + 1 ) * rowSize ] = x [ i + height * rowSize ] ; } for ( var j = 1 ; i <= height ; i ++ ) { x [ j * rowSize ] = - x [ 1 + j * rowSize ] ; x [ ( width + 1 ) + j * rowSize ] = - x [ width + j * rowSize ] ; } } else if ( b === 2 ) { for ( var i = 1 ; i <= width ; i ++ ) { x [ i ] = - x [ i + rowSize ] ; x [ i + ( height + 1 ) * rowSize ] = - x [ i + height * rowSize ] ; } for ( var j = 1 ; j <= height ; j ++ ) { x [ j * rowSize ] = x [ 1 + j * rowSize ] ; x [ ( width + 1 ) + j * rowSize ] = x [ width + j * rowSize ] ; } } else { for ( var i = 1 ; i <= width ; i ++ ) { x [ i ] = x [ i + rowSize ] ; x [ i + ( height + 1 ) * rowSize ] = x [ i + height * rowSize ] ; } for ( var j = 1 ; j <= height ; j ++ ) { x [ j * rowSize ] = x [ 1 + j * rowSize ] ; x [ ( width + 1 ) + j * rowSize ] = x [ width + j * rowSize ] ; } } var maxEdge = ( height + 1 ) * rowSize ; x [ 0 ] = 0.5 * ( x [ 1 ] + x [ rowSize ] ) ; x [ maxEdge ] = 0.5 * ( x [ 1 + maxEdge ] + x [ height * rowSize ] ) ; x [ ( width + 1 ) ] = 0.5 * ( x [ width ] + x [ ( width + 1 ) + rowSize ] ) ; x [ ( width + 1 ) + maxEdge ] = 0.5 * ( x [ width + maxEdge ] + x [ ( width + 1 ) + height * rowSize ] ) ; } function lin_solve ( b , x , x0 , a , c ) { if ( a === 0 && c === 1 ) { for ( var j = 1 ; j <= height ; j ++ ) { var currentRow = j * rowSize ; ++ currentRow ; for ( var i = 0 ; i < width ; i ++ ) { x [ currentRow ] = x0 [ currentRow ] ; ++ currentRow ; } } set_bnd ( b , x ) ; } else { var invC = 1 / c ; for ( var k = 0 ; k < iterations ; k ++ ) { for ( var j = 1 ; j <= height ; j ++ ) { var lastRow = ( j - 1 ) * rowSize ; var currentRow = j * rowSize ; var nextRow = ( j + 1 ) * rowSize ; var lastX = x [ currentRow ] ; ++ currentRow ; for ( var i = 1 ; i <= width ; i ++ ) lastX = x [ currentRow ] = ( x0 [ currentRow ] + a * ( lastX + x [ ++ currentRow ] + x [ ++ lastRow ] + x [ ++ nextRow ] ) ) * invC ; } set_bnd ( b , x ) ; } } } function diffuse ( b , x , x0 , dt ) { var a = 0 ; lin_solve ( b , x , x0 , a , 1 + 4 * a ) ; } function lin_solve2 ( x , x0 , y , y0 , a , c ) { if ( a === 0 && c === 1 ) { for ( var j = 1 ; j <= height ; j ++ ) { var currentRow = j * rowSize ; ++ currentRow ; for ( var i = 0 ; i < width ; i ++ ) { x [ currentRow ] = x0 [ currentRow ] ; y [ currentRow ] = y0 [ currentRow ] ; ++ currentRow ; } } set_bnd ( 1 , x ) ; set_bnd ( 2 , y ) ; } else { var invC = 1 / c ; for ( var k = 0 ; k < iterations ; k ++ ) { for ( var j = 1 ; j <= height ; j ++ ) { var lastRow = ( j - 1 ) * rowSize ; var currentRow = j * rowSize ; var nextRow = ( j + 1 ) * rowSize ; var lastX = x [ currentRow ] ; var lastY = y [ currentRow ] ; ++ currentRow ; for ( var i = 1 ; i <= width ; i ++ ) { lastX = x [ currentRow ] = ( x0 [ currentRow ] + a * ( lastX + x [ currentRow ] + x [ lastRow ] + x [ nextRow ] ) ) * invC ; lastY = y [ currentRow ] = ( y0 [ currentRow ] + a * ( lastY + y [ ++ currentRow ] + y [ ++ lastRow ] + y [ ++ nextRow ] ) ) * invC ; } } set_bnd ( 1 , x ) ; set_bnd ( 2 , y ) ; } } } function diffuse2 ( x , x0 , y , y0 , dt ) { var a = 0 ; lin_solve2 ( x , x0 , y , y0 , a , 1 + 4 * a ) ; } function advect ( b , d , d0 , u , v , dt ) { var Wdt0 = dt * width ; var Hdt0 = dt * height ; var Wp5 = width + 0.5 ; var Hp5 = height + 0.5 ; for ( var j = 1 ; j <= height ; j ++ ) { var pos = j * rowSize ; for ( var i = 1 ; i <= width ; i ++ ) { var x = i - Wdt0 * u [ ++ pos ] ; var y = j - Hdt0 * v [ pos ] ; if ( x < 0.5 ) x = 0.5 ; else if ( x > Wp5 ) x = Wp5 ; var i0 = x | 0 ; var i1 = i0 + 1 ; if ( y < 0.5 ) y = 0.5 ; else if ( y > Hp5 ) y = Hp5 ; var j0 = y | 0 ; var j1 = j0 + 1 ; var s1 = x - i0 ; var s0 = 1 - s1 ; var t1 = y - j0 ; var t0 = 1 - t1 ; var row1 = j0 * rowSize ; var row2 = j1 * rowSize ; d [ pos ] = s0 * ( t0 * d0 [ i0 + row1 ] + t1 * d0 [ i0 + row2 ] ) + s1 * ( t0 * d0 [ i1 + row1 ] + t1 * d0 [ i1 + row2 ] ) ; } } set_bnd ( b , d ) ; } function project ( u , v , p , div ) { var h = - 0.5 / Math . sqrt ( width * height ) ; for ( var j = 1 ; j <= height ; j ++ ) { var row = j * rowSize ; var previousRow = ( j - 1 ) * rowSize ; var prevValue = row - 1 ; var currentRow = row ; var nextValue = row + 1 ; var nextRow = ( j + 1 ) * rowSize ; for ( var i = 1 ; i <= width ; i ++ ) { div [ ++ currentRow ] = h * ( u [ ++ nextValue ] - u [ ++ prevValue ] + v [ ++ nextRow ] - v [ ++ previousRow ] ) ; p [ currentRow ] = 0 ; } } set_bnd ( 0 , div ) ; set_bnd ( 0 , p ) ; lin_solve ( 0 , p , div , 1 , 4 ) ; var wScale = 0.5 * width ; var hScale = 0.5 * height ; for ( var j = 1 ; j <= height ; j ++ ) { var prevPos = j * rowSize - 1 ; var currentPos = j * rowSize ; var nextPos = j * rowSize + 1 ; var prevRow = ( j - 1 ) * rowSize ; var currentRow = j * rowSize ; var nextRow = ( j + 1 ) * rowSize ; for ( var i = 1 ; i <= width ; i ++ ) { u [ ++ currentPos ] -= wScale * ( p [ ++ nextPos ] - p [ ++ prevPos ] ) ; v [ currentPos ] -= hScale * ( p [ ++ nextRow ] - p [ ++ prevRow ] ) ; } } set_bnd ( 1 , u ) ; set_bnd ( 2 , v ) ; } function dens_step ( x , x0 , u , v , dt ) { addFields ( x , x0 , dt ) ; diffuse ( 0 , x0 , x , dt ) ; advect ( 0 , x , x0 , u , v , dt ) ; } function vel_step ( u , v , u0 , v0 , dt ) { addFields ( u , u0 , dt ) ; addFields ( v , v0 , dt ) ; var temp = u0 ; u0 = u ; u = temp ; var temp = v0 ; v0 = v ; v = temp ; diffuse2 ( u , u0 , v , v0 , dt ) ; project ( u , v , u0 , v0 ) ; var temp = u0 ; u0 = u ; u = temp ; var temp = v0 ; v0 = v ; v = temp ; advect ( 1 , u , u0 , u0 , v0 , dt ) ; advect ( 2 , v , v0 , u0 , v0 , dt ) ; project ( u , v , u0 , v0 ) ; } var uiCallback = function ( d , u , v ) { } ; function Field ( dens , u , v ) { // Just exposing the fields here rather than using accessors is a measurable win during display (maybe 5%) // but makes the code ugly. this . setDensity = function ( x , y , d ) { dens [ ( x + 1 ) + ( y + 1 ) * rowSize ] = d ; } this . getDensity = function ( x , y ) { return dens [ ( x + 1 ) + ( y + 1 ) * rowSize ] ; } this . setVelocity = function ( x , y , xv , yv ) { u [ ( x + 1 ) + ( y + 1 ) * rowSize ] = xv ; v [ ( x + 1 ) + ( y + 1 ) * rowSize ] = yv ; } this . getXVelocity = function ( x , y ) { return u [ ( x + 1 ) + ( y + 1 ) * rowSize ] ; } this . getYVelocity = function ( x , y ) { return v [ ( x + 1 ) + ( y + 1 ) * rowSize ] ; } this . width = function ( ) { return width ; } this . height = function ( ) { return height ; } } function queryUI ( d , u , v ) { for ( var i = 0 ; i < size ; i ++ ) u [ i ] = v [ i ] = d [ i ] = 0.0 ; uiCallback ( new Field ( d , u , v ) ) ; } this . update = function ( ) { queryUI ( dens_prev , u_prev , v_prev ) ; vel_step ( u , v , u_prev , v_prev , dt ) ; dens_step ( dens , dens_prev , u , v , dt ) ; displayFunc ( new Field ( dens , u , v ) ) ; } this . setDisplayFunction = function ( func ) { displayFunc = func ; } this . iterations = function ( ) { return iterations ; } this . setIterations = function ( iters ) { if ( iters > 0 && iters <= 100 ) iterations = iters ; } this . setUICallback = function ( callback ) { uiCallback = callback ; } var iterations = 10 ; var visc = 0.5 ; var dt = 0.1 ; var dens ; var dens_prev ; var u ; var u_prev ; var v ; var v_prev ; var width ; var height ; var rowSize ; var size ; var displayFunc ; function reset ( ) { rowSize = width + 2 ; size = ( width + 2 ) * ( height + 2 ) ; dens = new Array ( size ) ; dens_prev = new Array ( size ) ; u = new Array ( size ) ; u_prev = new Array ( size ) ; v = new Array ( size ) ; v_prev = new Array ( size ) ; for ( var i = 0 ; i < size ; i ++ ) dens_prev [ i ] = u_prev [ i ] = v_prev [ i ] = dens [ i ] = u [ i ] = v [ i ] = 0 ; } this . reset = reset ; this . setResolution = function ( hRes , wRes ) { var res = wRes * hRes ; if ( res > 0 && res < 1000000 && ( wRes != width || hRes != height ) ) { width = wRes ; height = hRes ; reset ( ) ; return true ; } return false ; } this . setResolution ( 64 , 64 ) ; }

0<CODESPLIT>https://github.com/cloudcmd/edward/blob/e1b0f8361f1ac9c7de97c3f5d57e6b30ce00653b/vendor/emmet.js#L3895-L3918<CODESPLIT><CODESPLIT>Find start and end index of text line for <code > from< / code > index<CODESPLIT>function ( start , len ) { if ( _ . isUndefined ( start ) || start === null ) return null ; if ( start instanceof Range ) return start ; if ( _ . isObject ( start ) && 'start' in start && 'end' in start ) { len = start . end - start . start ; start = start . start ; } return new Range ( start , len ) ; }

0<CODESPLIT>https://github.com/cloudcmd/edward/blob/e1b0f8361f1ac9c7de97c3f5d57e6b30ce00653b/vendor/emmet.js#L7267-L7274<CODESPLIT><CODESPLIT>Sets of gets element value<CODESPLIT>function ( pos , isAbsolute ) { return _ . find ( this . list ( ) , function ( elem ) { return elem . range ( isAbsolute ) . inside ( pos ) ; } ) ; }

0<CODESPLIT>https://github.com/Epharmix/Toureiro/blob/f60cb267819c57f7980a6f5fd03e80e9b215dc2f/lib/redis.js#L36-L40<CODESPLIT><CODESPLIT>Get a redis multi interface<CODESPLIT>function ( module , exports , __webpack_require__ ) { 'use strict' ; Object . defineProperty ( exports , "__esModule" , { value : true } ) ; exports . reactComponent = reactComponent ; var _react = __webpack_require__ ( 1 ) ; var _react2 = _interopRequireDefault ( _react ) ; function _interopRequireDefault ( obj ) { return obj && obj . __esModule ? obj : { default : obj } ; } function reactComponent ( ) { return _react2 . default . createElement ( 'div' , null , _react2 . default . createElement ( 'p' , null , 'I am the webpack application, and I\'m using SystemJS\' version of react.' ) , _react2 . default . createElement ( 'p' , null , 'I don\'t have to bundle react in with me, which makes my bundle a lot smaller.' ) , _react2 . default . createElement ( 'p' , null , 'I exported a react component from the entry module of my webpack config, and that export made it to the SystemJS app that loaded me, who was able to render my react component to the DOM.' ) ) ; } $__register__main__exports ( exports ) ; /***/ }

0<CODESPLIT>https://github.com/DavidSouther/superscore/blob/866b1eeb7eaf86e9d4024ee0af9191a60da08de8/lib/superscore.js#L348-L355<CODESPLIT><CODESPLIT>### symmetricDifference * ( set1 set2 [ ... setN ] ) * The symmetric of two sets is is the set of elements in either set but not their intersection . If two sets are equal the symmetric difference is empty .<CODESPLIT>function ( object , path , value , overwrite ) { overwrite = overwrite || false ; value = value || null ; // Break the path, if it's not already an array. path = underscore . isString ( path ) ? path . split ( '.' ) : underscore . isArray ( path ) ? path : [ ] ; // Get the next step var part = path . shift ( ) ; // Different behavior depending on if we're at the last step if ( path . length ) { // More children, so make sure there's a container at the next level if ( ! object [ part ] ) { object [ part ] = ! underscore . isNaN ( + path [ 0 ] ) ? [ ] : { } ; } // Recurse, returning either the object or the old value var next = underscore . deep ( object [ part ] , path , value , overwrite ) ; return value ? object : next ; } else { // If no value, return the part. if ( ! value ) { return object [ part ] ; } else { object [ part ] = overwrite ? value : ( object [ part ] || value ) ; return object ; } } }

0<CODESPLIT>https://github.com/vanruesc/inline-import/blob/285a6a2059af483b7bda25c9d451bdab0df8f8e4/src/core/InlineImport.js#L87-L119<CODESPLIT>inlineImports<CODESPLIT>Reads the contents of the imported files .<CODESPLIT>function inlineImports ( imports , data , declaration ) { let modified = imports . length > 0 ; let i , item ; // Inline the imports in reverse order to keep the indices intact. for ( i = imports . length - 1 ; i >= 0 ; -- i ) { item = imports [ i ] ; data = data . substring ( 0 , item . start ) + declaration + " " + item . name + " = " + JSON . stringify ( item . data ) + data . substring ( item . end ) ; } return Promise . resolve ( [ modified , data ] ) ; }

1<CODESPLIT>https://github.com/Yodata/yodata-context/blob/39a499cd4129698a00139b47f3096884177e66f0/dist/yodata-context.js#L2771-L2776<CODESPLIT>getMapData$2<CODESPLIT>Gets the data for map .<CODESPLIT>function getMapData$2 ( map , key ) { var data = map . __data__ ; return isKeyable$2 ( key ) ? data [ typeof key == 'string' ? 'string' : 'hash' ] : data . map ; }

0<CODESPLIT>https://github.com/mominsamir/smDateTimeRangePicker/blob/9f4a50efa46881af88ab95d75c3d0d60e5ae12c9/dist/scripts/vendor.min.js#L18344-L19772<CODESPLIT><CODESPLIT>@ngdoc method @name $rootScopeProvider#digestTtl @description<CODESPLIT>function ( isolate , parent ) { var child ; parent = parent || this ; if ( isolate ) { child = new Scope ( ) ; child . $root = this . $root ; } else { // Only create a child scope class if somebody asks for one, // but cache it to allow the VM to optimize lookups. if ( ! this . $$ChildScope ) { this . $$ChildScope = createChildScopeClass ( this ) ; } child = new this . $$ChildScope ( ) ; } child . $parent = parent ; child . $$prevSibling = parent . $$childTail ; if ( parent . $$childHead ) { parent . $$childTail . $$nextSibling = child ; parent . $$childTail = child ; } else { parent . $$childHead = parent . $$childTail = child ; } // When the new scope is not isolated or we inherit from `this`, and // the parent scope is destroyed, the property `$$destroyed` is inherited // prototypically. In all other cases, this property needs to be set // when the parent scope is destroyed. // The listener needs to be added after the parent is set if ( isolate || parent !== this ) child . $on ( '$destroy' , destroyChildScope ) ; return child ; }

0<CODESPLIT>https://github.com/webgme/user-management-page/blob/70d26624eb0031e73a951fb9fee4857f75b8434a/webpack.config.js#L21-L46<CODESPLIT>generateStatsdRoutes<CODESPLIT>Conditionally loads plugins ( mainly for production build )<CODESPLIT>function generateStatsdRoutes ( stats ) { var result = { } ; Object . keys ( stats ) . forEach ( function ( name ) { var routes = stats [ name ] ; if ( ! ( routes instanceof Array ) ) { routes = [ routes ] ; } routes . forEach ( function ( route ) { result [ route . path ] = { name : name , methods : route . method ? route . method : route . methods } ; } ) ; } ) ; return result ; }

1<CODESPLIT>https://github.com/boldrocket/node-semantria/blob/3ae0b59eb517ddc70724405c980770281c7ede52/SemantriaJavaScriptSDK/SemantriaJavaScriptSDK.js#L463-L480<CODESPLIT><CODESPLIT>initializes the API<CODESPLIT>function ( consumerKey , consumerSecret , applicationName , format , useCompression ) { this . eventHandlers = { } ; this . consumerKey = consumerKey ; this . consumerSecret = consumerSecret ; this . useCompression = useCompression || true ; this . format = format || "json" ; this . acceptEncoding = this . useCompression ? 'gzip, deflate' : 'identity' ; this . applicationName = applicationName ? ( applicationName + "/" ) : "" ; if ( ! this . consumerKey || ! this . consumerSecret ) { throw "ConsumerKey and ConsumerSecret should be specified in order to use SDK" ; } this . applicationName += this . tpl ( "JavaScript/{SDK_VERSION}/{format}" , { SDK_VERSION : this . SDK_VERSION , format : this . format } ) ; }

1<CODESPLIT>https://github.com/calmh/node-snmp-native/blob/13b1428cd90c6f281e7ae7bc3147245d1ad98939/lib/snmp.js#L150-L210<CODESPLIT>encode<CODESPLIT>Return an ASN . 1 BER encoding of a Packet structure . This is suitable for transmission on a UDP socket .<CODESPLIT>function encode ( pkt ) { var version , community , reqid , err , erridx , vbs , pdu , message ; // We only support SNMPv1 and SNMPv2c, so enforce those version stamps. if ( pkt . version !== versions . SNMPv1 && pkt . version !== versions . SNMPv2c ) { throw new Error ( 'Only SNMPv1 and SNMPv2c are supported.' ) ; } // Encode the message header fields. version = asn1ber . encodeInteger ( pkt . version ) ; community = asn1ber . encodeOctetString ( pkt . community ) ; // Encode the PDU header fields. reqid = asn1ber . encodeInteger ( pkt . pdu . reqid ) ; err = asn1ber . encodeInteger ( pkt . pdu . error ) ; erridx = asn1ber . encodeInteger ( pkt . pdu . errorIndex ) ; // Encode the PDU varbinds. vbs = [ ] ; pkt . pdu . varbinds . forEach ( function ( vb ) { var oid = asn1ber . encodeOid ( vb . oid ) , val ; if ( vb . type === asn1ber . types . Null || vb . value === null ) { val = asn1ber . encodeNull ( ) ; } else if ( vb . type === asn1ber . types . Integer ) { val = asn1ber . encodeInteger ( vb . value ) ; } else if ( vb . type === asn1ber . types . Gauge ) { val = asn1ber . encodeGauge ( vb . value ) ; } else if ( vb . type === asn1ber . types . IpAddress ) { val = asn1ber . encodeIpAddress ( vb . value ) ; } else if ( vb . type === asn1ber . types . OctetString ) { val = asn1ber . encodeOctetString ( vb . value ) ; } else if ( vb . type === asn1ber . types . ObjectIdentifier ) { val = asn1ber . encodeOid ( vb . value , true ) ; } else if ( vb . type === asn1ber . types . Counter ) { val = asn1ber . encodeCounter ( vb . value ) ; } else if ( vb . type === asn1ber . types . TimeTicks ) { val = asn1ber . encodeTimeTicks ( vb . value ) ; } else if ( vb . type === asn1ber . types . NoSuchObject ) { val = asn1ber . encodeNoSuchObject ( ) ; } else if ( vb . type === asn1ber . types . NoSuchInstance ) { val = asn1ber . encodeNoSuchInstance ( ) ; } else if ( vb . type === asn1ber . types . EndOfMibView ) { val = asn1ber . encodeEndOfMibView ( ) ; } else { throw new Error ( 'Unknown varbind type "' + vb . type + '" in encoding.' ) ; } vbs . push ( asn1ber . encodeSequence ( concatBuffers ( [ oid , val ] ) ) ) ; } ) ; // Concatenate all the varbinds together. vbs = asn1ber . encodeSequence ( concatBuffers ( vbs ) ) ; // Create the PDU by concatenating the inner fields and adding a request structure around it. pdu = asn1ber . encodeRequest ( pkt . pdu . type , concatBuffers ( [ reqid , err , erridx , vbs ] ) ) ; // Create the message by concatenating the header fields and the PDU. message = asn1ber . encodeSequence ( concatBuffers ( [ version , community , pdu ] ) ) ; return message ; }

1<CODESPLIT>https://github.com/PascalZajac/express-hecate/blob/d7d93070a5554768a41abcb54b0c9b8a5ec6ded2/lib/Hecate.js#L333-L351<CODESPLIT><CODESPLIT>Generate the various routes represented by a wildcard controller entry .<CODESPLIT>function ( verb , path , controllerName ) { // Load the referenced controller. var controllerPath = this . options . controllersPath + controllerName ; try { var controller = require ( this . options . rootPath + controllerPath ) ; // Iterate over the controller, creating new route entries for each function. for ( var field in controller ) { if ( typeof controller [ field ] == 'function' ) { this . addNewRouteEntry ( verb , path . replace ( / {method} / , field ) , controllerName , field ) ; } } } catch ( e ) { throw new Error ( 'The specified controller (' + controllerPath + ') does not exist.' ) ; } }

0<CODESPLIT>https://github.com/qooxdoo/qooxdoo-compiler/blob/22dc08abdc726da571a3802020c99f6426ae783b/tool/cli/templates/skeleton/mobile/source/class/custom/Application.tmpl.js#L28-L65<CODESPLIT><CODESPLIT>This method contains the initial application code and gets called during startup of the application<CODESPLIT>function ( ) { return path . join ( process . cwd ( ) , qx . tool . cli . ConfigSchemas . lockfile . filename ) ; }

1<CODESPLIT>https://github.com/Polymer/web-component-tester/blob/e68b2cb5842f206191977a58c5c6eedb2cb4b87b/browser.js#L1263-L1275<CODESPLIT>loadSuites<CODESPLIT>Loads suites of tests supporting both . js and . html files .<CODESPLIT>function loadSuites ( files ) { files . forEach ( function ( file ) { if ( / \.js(\?.*)?$ / . test ( file ) ) { jsSuites$1 . push ( file ) ; } else if ( / \.html(\?.*)?$ / . test ( file ) ) { htmlSuites$1 . push ( file ) ; } else { throw new Error ( 'Unknown resource type: ' + file ) ; } } ) ; }

0<CODESPLIT>https://github.com/jquery-i18n-properties/jquery-i18n-properties/blob/77dbadbbb692848dca5f04c2bb5824c2a9d27d64/jquery.i18n.properties.js#L366-L450<CODESPLIT>checkKeyNamespace<CODESPLIT>Parse . properties files<CODESPLIT>function checkKeyNamespace ( key ) { var regDot = / \. / ; if ( regDot . test ( key ) ) { var fullname = '' ; var names = key . split ( / \. / ) ; for ( var i = 0 , j = names . length ; i < j ; i ++ ) { var name = names [ i ] ; if ( i > 0 ) { fullname += '.' ; } fullname += name ; if ( eval ( 'typeof ' + fullname + ' == "undefined"' ) ) { eval ( fullname + '={};' ) ; } } } }

1<CODESPLIT>https://github.com/qooxdoo/qooxdoo-compiler/blob/22dc08abdc726da571a3802020c99f6426ae783b/lib/qx/tool/compiler/app/Application.js#L779-L783<CODESPLIT><CODESPLIT>Apply for type property<CODESPLIT>function ( value , oldValue ) { var loader = path . join ( __dirname , "loader-" + ( this . isBrowserApp ( ) ? "browser" : "server" ) + ".tmpl.js" ) ; this . setLoaderTemplate ( loader ) ; this . setTheme ( null ) ; }

0<CODESPLIT>https://github.com/thebuilder/react-scroll-percentage/blob/dc7db037fc0bd3f9e495ac7e4a6f6b056ad59586/stories/ScrollWrapper/index.js#L17-L29<CODESPLIT>createFlow<CODESPLIT>ScrollWrapper directs the user to scroll the page to reveal it s children . Use this on Modules that have scroll and / or observer triggers .<CODESPLIT>function createFlow ( ) { fs . writeFileSync ( path . join ( process . cwd ( ) , pkg . main + '.flow' ) , createFlowFile ( ) , 'utf-8' , ) fs . writeFileSync ( path . join ( process . cwd ( ) , pkg . module + '.flow' ) , createFlowFile ( ) , 'utf-8' , ) }

1<CODESPLIT>https://github.com/MrRio/jsPDF/blob/1d2f97628cda87041f21357ce0ad5b472906fc53/dist/jspdf.node.debug.js#L8478-L8486<CODESPLIT>setLastCellPosition<CODESPLIT>/ * jslint browser : true / * global document : false jsPDF<CODESPLIT>function setLastCellPosition ( x , y , w , h , ln ) { lastCellPos = { 'x' : x , 'y' : y , 'w' : w , 'h' : h , 'ln' : ln } ; }

0<CODESPLIT>https://github.com/Kolbaskin/yode-server/blob/55ab6680efcca9d298683eed7fc6a16933f10ace/static/ext/src/layout/container/Border.js#L497-L540<CODESPLIT><CODESPLIT>Performs the calculations for a region on a specified axis .<CODESPLIT>function ( ownerContext , axis ) { var size = axis . end - axis . begin , center = ownerContext . centerRegion ; if ( center ) { center [ 'set' + axis . sizePropCap ] ( size - center . getMarginInfo ( ) [ axis . sizeProp ] ) ; center . layoutPos [ axis . posProp ] = axis . begin ; } return Ext . isNumber ( size ) ? 1 : 0 ; }

0<CODESPLIT>https://github.com/the-labo/the-ar/blob/6e2b2085adf13e2e39446668421df1281fcf1c8e/vendor/ar.js#L1822-L1846<CODESPLIT>updateOrtho<CODESPLIT>update cloakMesh<CODESPLIT>function updateOrtho ( modelViewMatrix , cameraProjectionMatrix ) { // compute transformedUvs var transformedUvs = [ ] originalOrthoVertices . forEach ( function ( originalOrthoVertices , index ) { var transformedUv = originalOrthoVertices . clone ( ) // apply modelViewMatrix and projectionMatrix transformedUv . applyMatrix4 ( modelViewMatrix ) transformedUv . applyMatrix4 ( cameraProjectionMatrix ) // apply perspective transformedUv . x /= transformedUv . z transformedUv . y /= transformedUv . z // store it transformedUvs . push ( transformedUv ) } ) // change orthoMesh vertices for ( var i = 0 ; i < transformedUvs . length ; i ++ ) { orthoMesh . geometry . vertices [ i ] . copy ( transformedUvs [ i ] ) } orthoMesh . geometry . computeBoundingSphere ( ) orthoMesh . geometry . verticesNeedUpdate = true }

1<CODESPLIT>https://github.com/zhuowenli/vue-clipboards/blob/5d96874886264311dda0d39d10924dd2f83b08cb/dist/vue-clipboards.es.js#L477-L499<CODESPLIT>delegate<CODESPLIT>Delegates event to a selector .<CODESPLIT>function delegate ( elements , selector , type , callback , useCapture ) { // Handle the regular Element usage if ( typeof elements . addEventListener === 'function' ) { return _delegate . apply ( null , arguments ) ; } // Handle Element-less usage, it defaults to global delegation if ( typeof type === 'function' ) { // Use `document` as the first parameter, then apply arguments // This is a short way to .unshift `arguments` without running into deoptimizations return _delegate . bind ( null , document ) . apply ( null , arguments ) ; } // Handle Selector-based usage if ( typeof elements === 'string' ) { elements = document . querySelectorAll ( elements ) ; } // Handle Array-like based usage return Array . prototype . map . call ( elements , function ( element ) { return _delegate ( element , selector , type , callback , useCapture ) ; } ) ; }

1<CODESPLIT>https://github.com/runtimejs/runtime/blob/1955dbf3204e22bace7cfbbb6f52bb5d57a8c1e4/deps/v8/src/debug/liveedit.js#L840-L852<CODESPLIT>FunctionCompileInfo<CODESPLIT>An object describing function compilation details . Its index fields apply to indexes inside array that stores these objects .<CODESPLIT>function FunctionCompileInfo ( raw_array ) { this . function_name = raw_array [ 0 ] ; this . start_position = raw_array [ 1 ] ; this . end_position = raw_array [ 2 ] ; this . param_num = raw_array [ 3 ] ; this . code = raw_array [ 4 ] ; this . code_scope_info = raw_array [ 5 ] ; this . scope_info = raw_array [ 6 ] ; this . outer_index = raw_array [ 7 ] ; this . shared_function_info = raw_array [ 8 ] ; this . next_sibling_index = null ; this . raw_array = raw_array ; }

1<CODESPLIT>https://github.com/Kolbaskin/yode-server/blob/55ab6680efcca9d298683eed7fc6a16933f10ace/static/ext/src/chart/Highlight.js#L134-L180<CODESPLIT><CODESPLIT>Un - highlight any existing highlights<CODESPLIT>function ( ) { if ( ! this . highlight || ! this . items ) { return ; } var me = this , items = me . items , len = items . length , opts = Ext . merge ( { } , me . highlightCfg , me . highlight ) , animate = me . chart . animate , i = 0 , obj , p , sprite ; for ( ; i < len ; i ++ ) { if ( ! items [ i ] ) { continue ; } sprite = items [ i ] . sprite ; if ( sprite && sprite . _highlighted ) { if ( sprite . _anim ) { sprite . _anim . paused = true ; } obj = { } ; for ( p in opts ) { if ( Ext . isObject ( sprite . _defaults [ p ] ) ) { obj [ p ] = Ext . apply ( { } , sprite . _defaults [ p ] ) ; } else { obj [ p ] = sprite . _defaults [ p ] ; } } if ( animate ) { //sprite._to = obj; sprite . _endStyle = obj ; sprite . _anim = new Ext . fx . Anim ( { target : sprite , to : obj , duration : 150 } ) ; } else { sprite . setAttributes ( obj , true ) ; } delete sprite . _highlighted ; //delete sprite._defaults; } } }

1<CODESPLIT>https://github.com/jmmoser/node-drivers/blob/6d84daaf78fe483c32bbef72bda4619c0ad65fa2/src/CIP/Objects/EPath.js#L521-L553<CODESPLIT>readLogicalSegment<CODESPLIT>function readPortSegment ( path offset segment ) { let length ; segment . type = SEGMENT_TYPE . PORT ; let extendedLinkAddress = getPortSegmentExtendedLinkAddressSizeBit ( path offset ) ; let port = getPortSegmentPortIdentifier ( path offset ) ; if ( extendedLinkAddress === false && port < 15 ) { segment . port = port ; segment . linkAddress = Buffer . from ( path . slice ( offset + 1 offset + 2 )) ; length = 2 ; } else if ( extendedLinkAddress === true && port < 15 ) { segment . port = port ; let linkAddressSize = path . readUInt8 ( offset + 1 ) ; segment . linkAddress = Buffer . from ( path . slice ( offset + 2 offset + 2 + linkAddressSize )) ; length = 2 + linkAddressSize ; } else if ( extendedLinkAddress === false && port === 15 ) { segment . port = path . readUInt16LE ( offset + 1 ) ; segment . linkAddress = Buffer . from ( path . slice ( offset + 3 offset + 4 )) ; length = 4 ; } else if ( extendedLinkAddress === true && port === 15 ) { let linkAddressSize = path . readUInt8 ( offset + 1 ) ; segment . port = path . readUInt16LE ( offset + 2 ) ; segment . linkAddress = Buffer . from ( path . slice ( offset + 4 offset + 4 + linkAddressSize )) ; length = 4 + linkAddressSize ; } return length % 2 === 0 ? length : length + 1 ; }<CODESPLIT>function readLogicalSegment ( path , offset , segment ) { segment . type = SEGMENT_TYPE . LOGICAL ; const segmentByte = path . readUInt8 ( offset ) ; const type = getBits ( segmentByte , 2 , 5 ) << 2 ; const format = getBits ( segmentByte , 0 , 2 ) ; segment . info = { type , typeDescription : LOGICAL_SEGMENT_TYPE_DESCRIPTIONS [ type ] , format , formatDescription : LOGICAL_SEGMENT_FORMAT_DESCRIPTIONS [ format ] } ; let shift ; switch ( format ) { case 0 : segment . info . value = path . readUInt8 ( offset + 1 ) ; shift = 2 ; break ; case 1 : segment . info . value = path . readUInt16LE ( offset + 2 ) ; shift = 4 ; break ; case 2 : segment . info . value = path . readUInt32LE ( offset + 2 ) ; shift = 6 ; break ; default : break ; } return shift ; }

0<CODESPLIT>https://github.com/mysticatea/eslint-plugin-node/blob/bc02c52f8199d7c55e69d54628f8be397d4986f4/lib/rules/no-unsupported-features.js#L887-L897<CODESPLIT>isIgnored<CODESPLIT>Gets values of the ignores option .<CODESPLIT>function isIgnored ( key , ignores ) { return ( ignores . indexOf ( key ) !== - 1 || FEATURES [ key ] . alias . some ( alias => ignores . indexOf ( alias ) !== - 1 ) ) }

1<CODESPLIT>https://github.com/straker/gulp-livingcss/blob/b934d13abea486d7cf5c99e0b9adfd8459913307/index.js#L23-L38<CODESPLIT>bufferContents<CODESPLIT>Buffer all files before parsing them to livingcss .<CODESPLIT>function bufferContents ( file , enc , cb ) { // ignore empty files if ( file . isNull ( ) ) { return cb ( ) ; } // no streams if ( file . isStream ( ) ) { this . emit ( 'error' , new PluginError ( 'gulp-livingcss' , 'Streaming not supported' ) ) ; return cb ( ) ; } files . push ( file . path ) ; cb ( ) ; }

0<CODESPLIT>https://github.com/sampotts/plyr/blob/80aa6ffe435b170466838f977d52438a95e22186/demo/dist/demo.js#L4083-L4100<CODESPLIT>round<CODESPLIT>Setup a new instance<CODESPLIT>function round ( number , step ) { if ( step < 1 ) { var places = getDecimalPlaces ( step ) ; return parseFloat ( number . toFixed ( places ) ) ; } return Math . round ( number / step ) * step ; }

1<CODESPLIT>https://github.com/sampotts/plyr/blob/80aa6ffe435b170466838f977d52438a95e22186/demo/dist/demo.js#L7075-L7089<CODESPLIT>buildUrlParams<CODESPLIT>Convert object to URLSearchParams<CODESPLIT>function buildUrlParams ( input ) { var params = new URLSearchParams ( ) ; if ( is$1 . object ( input ) ) { Object . entries ( input ) . forEach ( function ( _ref ) { var _ref2 = _slicedToArray ( _ref , 2 ) , key = _ref2 [ 0 ] , value = _ref2 [ 1 ] ; params . set ( key , value ) ; } ) ; } return params ; }

0<CODESPLIT>https://github.com/jarradseers/middleware-chain/blob/0b9f83a04ae33ce1740dbd74611ef2ca577cd1cf/examples/mixed-sync-async.js#L40-L45<CODESPLIT>three<CODESPLIT>Function Two . Example function logs hello and currect context . This function is syncronous .<CODESPLIT>function three ( context , next ) { console . log ( 'Hi from three' , context ) ; setTimeout ( function ( ) { context . three = 'Hello' ; console . log ( 'Hello from three' , context ) ; } , 1000 ) ; }

1<CODESPLIT>https://github.com/trepo/gedcomx-date-js/blob/a0d3c5dfec2d61be652aa5690bc2377f49a1ae9e/lib/util.js#L337-L394<CODESPLIT>zipDuration<CODESPLIT>Ensures that date has its proeprties initialized based on what the duration has . For example if date does not have minutes and duration does this will initialize minutes in the date .<CODESPLIT>function zipDuration ( date , duration ) { var toSet = { } ; if ( duration . getSeconds ( ) ) { toSet = { seconds : true , minutes : true , hours : true , days : true , months : true } ; } else if ( duration . getMinutes ( ) ) { toSet = { minutes : true , hours : true , days : true , months : true } ; } else if ( duration . getHours ( ) ) { toSet = { hours : true , days : true , months : true } ; } else if ( duration . getDays ( ) ) { toSet = { days : true , months : true } ; } else if ( duration . getMonths ( ) ) { toSet = { months : true } ; } else { return ; } if ( toSet . seconds && date . seconds == undefined ) { date . seconds = 0 ; } if ( toSet . minutes && date . minutes == undefined ) { date . minutes = 0 ; } if ( toSet . hours && date . hours == undefined ) { date . hours = 0 ; } if ( toSet . days && date . day == undefined ) { date . day = 1 ; } if ( toSet . months && date . month == undefined ) { date . month = 1 ; } }

0<CODESPLIT>https://github.com/revery-ui/revery/blob/a5c8999b2a61fdbd5fa675096c1f7f1275a9c794/src/Core/file.js#L33-L54<CODESPLIT>whitespace<CODESPLIT>Provides : caml_open_sync_raw Requires : caml_ba_create_from caml_js_from_string caml_js_to_string<CODESPLIT>function whitespace ( rule , value , source , errors , options ) { if ( / ^\s+$ / . test ( value ) || value === '' ) { errors . push ( util . format ( options . messages . whitespace , rule . fullField ) ) ; } }

1<CODESPLIT>https://github.com/remotestorage/remotestorage.js/blob/1f292bb03772a7061a3b9d40b2bc797b3fcd8455/src/dropbox.js#L993-L1005<CODESPLIT>hookSyncCycle<CODESPLIT>Hook RemoteStorage . syncCycle as it s the first function called after RemoteStorage . sync is initialized so we can then hook the sync function<CODESPLIT>function hookSyncCycle ( rs ) { if ( rs . _dropboxOrigSyncCycle ) { return ; } // already hooked rs . _dropboxOrigSyncCycle = rs . syncCycle ; rs . syncCycle = ( ) => { if ( rs . sync ) { hookSync ( rs ) ; rs . _dropboxOrigSyncCycle ( arguments ) ; unHookSyncCycle ( rs ) ; } else { throw new Error ( 'expected sync to be initialized by now' ) ; } } ; }

1<CODESPLIT>https://github.com/jogabo/firestream/blob/4f4fba3610a1da35e204bc56205a64fe77d15f68/index.js#L87-L101<CODESPLIT>onChildAdd<CODESPLIT>add child to data buffer and emit value<CODESPLIT>function onChildAdd ( newData ) { // ignore all events before first read if ( ! started ) return ; // ignore already added item if ( data [ newData . key ( ) ] ) return ; // ignore older items that are not loaded if ( ! ended && ! data [ newData . key ( ) ] && marker && newData . compareTo ( marker ) > 0 ) return ; return add ( newData ) . then ( emitValue ) ; }

1<CODESPLIT>https://github.com/MorleyDev/functional-pipe-js/blob/597cf91f6828318cc66d9135fa3790f7b9816dda/dist/async-iterable/operators.js#L779-L796<CODESPLIT>toArray<CODESPLIT>Evaluate the entire iterable to a readonly array . Provided as type deduction seems to fail when using Array . from to accomplish this outside of a lamda<CODESPLIT>async function toArray ( iterable ) { var e_29 , _a ; const blob = [ ] ; try { for ( var iterable_17 = __asyncValues ( iterable ) , iterable_17_1 ; iterable_17_1 = await iterable_17 . next ( ) , ! iterable_17_1 . done ; ) { const it = iterable_17_1 . value ; blob . push ( it ) ; } } catch ( e_29_1 ) { e_29 = { error : e_29_1 } ; } finally { try { if ( iterable_17_1 && ! iterable_17_1 . done && ( _a = iterable_17 . return ) ) await _a . call ( iterable_17 ) ; } finally { if ( e_29 ) throw e_29 . error ; } } return blob ; }

0<CODESPLIT>https://github.com/Michieljoris/recaster/blob/9e17ba123bdb02505537b2a710cff89517916127/lib/recaster.js#L405-L420<CODESPLIT>recast<CODESPLIT>function Typeof ( v ) { var type = {} . toString . call ( v ) ; return type . slice ( 8 type . length - 1 ) ; }<CODESPLIT>function recast ( args ) { var encoding = args . encoding || undefined ; // var vow = VOW.make(); return readData ( args . fullPath , args . srcData , args . type , args . path ) . when ( function ( data ) { data . isModule = args . isModule ; args . srcData = data . recast ; args . type = data . type ; data . path = args . path ; // oldType = args.type = data.type; if ( ! data . type || ! extToFunction [ data . type ] ) { // vow.break({ recast: args.srcData, type: data.type }); return VOW . kept ( { recast : args . srcData , type : data . type } ) ; // return VOW.keep({ recast: args.srcData, type: data.type }); } else { data . recast = data . recast . toString ( ) ; var f = extToFunction [ data . type ] ; // debug('data=' ,data); // console.log(extToFunction['html'].toString()); return f ( data ) ; // f(data).when( //     function(data) { //         debug('data=' ,data); //         data.recast = data.recast.toString(); //         vow.keep(data); //     }, //     function(err) { //         vow.breek(err); //     } // ); } } ) . when ( function ( data ) { if ( encoding ) return transform . zip ( data , encoding ) ; else return VOW . kept ( data ) ; } ) ; // return vow.promise; }

1<CODESPLIT>https://github.com/dselmanovic/bearerjs/blob/38bb49c43fe54aa968f1f7c3ccc730d54482b905/bearer.js#L19-L26<CODESPLIT>checkUrl<CODESPLIT>Check if route should be authorized and return route setting<CODESPLIT>function checkUrl ( url , method , routes ) { method = method . toLowerCase ( ) ; for ( var i = 0 ; i < routes . length ; i ++ ) { var route = routes [ i ] ; if ( ( matchPath ( route . url , url ) ) && ( method == route . method ) ) return route ; } return false ; }

1<CODESPLIT>https://github.com/trepo/gedcomx-date-js/blob/a0d3c5dfec2d61be652aa5690bc2377f49a1ae9e/lib/duration.js#L4-L26<CODESPLIT>Duration<CODESPLIT>A gedcomX Duration<CODESPLIT>function Duration ( str ) { // There must be at least a P if ( str . length < 1 || str . charAt ( 0 ) != 'P' ) { throw new Error ( 'Invalid Duration' ) ; } var duration = str . substr ( 1 ) ; if ( duration . length < 1 ) { throw new Error ( 'Invalid Duration' ) ; } // 5.3.2 allows for NON normalized durations // We assume that if there is a space, it is non-normalized if ( / \s / . test ( duration ) ) { throw new Error ( 'Non normalized durations not implemented' ) ; //this._parseNonNormalized(duration); } else { this . _parseNormalized ( duration ) ; } }

0<CODESPLIT>https://github.com/runtimejs/runtime/blob/1955dbf3204e22bace7cfbbb6f52bb5d57a8c1e4/deps/v8/src/debug/liveedit.js#L840-L852<CODESPLIT>FindFunctionInfos<CODESPLIT>An object describing function compilation details . Its index fields apply to indexes inside array that stores these objects .<CODESPLIT>function FindFunctionInfos ( compile_info ) { var wrappers = [ ] ; for ( var i = 0 ; i < shared_infos . length ; i ++ ) { var wrapper = shared_infos [ i ] ; if ( wrapper . start_position == compile_info . start_position && wrapper . end_position == compile_info . end_position ) { wrappers . push ( wrapper ) ; } } if ( wrappers . length > 0 ) { return wrappers ; } }

1<CODESPLIT>https://github.com/fengyuanchen/cropperjs/blob/4e3634e615a09e22fb5c28239422bdeaae35779f/dist/cropper.common.js#L341-L344<CODESPLIT>normalizeDecimalNumber<CODESPLIT>Normalize decimal number . Check out {<CODESPLIT>function normalizeDecimalNumber ( value ) { var times = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : 100000000000 ; return REGEXP_DECIMALS . test ( value ) ? Math . round ( value * times ) / times : value ; }

1<CODESPLIT>https://github.com/Automattic/wp-calypso/blob/0b3ba9a386f9d7bc1ba0a2693c76799a51b0d817/server/render/index.js#L250-L257<CODESPLIT>isServerSideRenderCompatible<CODESPLIT>Applies all the app - related checks for server side rendering .<CODESPLIT>function isServerSideRenderCompatible ( context ) { return Boolean ( isSectionIsomorphic ( context . store . getState ( ) ) && ! context . user && // logged out only isDefaultLocale ( context . lang ) && context . layout ) ; }

0<CODESPLIT>https://github.com/Yodata/yodata-context/blob/39a499cd4129698a00139b47f3096884177e66f0/dist/yodata-context.js#L1560-L1568<CODESPLIT>baseIsNative$1<CODESPLIT>Gets the index at which the key is found in array of key - value pairs .<CODESPLIT>function baseIsNative$1 ( value ) { if ( ! isObject$1 ( value ) || isMasked$1 ( value ) ) { return false ; } var pattern = ( isFunction$1 ( value ) || isHostObject$2 ( value ) ) ? reIsNative$1 : reIsHostCtor$1 ; return pattern . test ( toSource$1 ( value ) ) ; }

0<CODESPLIT>https://github.com/whitfin/kscrash-converter/blob/34c9bc20bb9a358f1cd5cd58f48c354a36e92e6d/lib/cpu.js#L68-L86<CODESPLIT>parse<CODESPLIT>Finds the CPU arch name using a major / minor type number . If we can t find the arch we just wrap the major / minor in an unknown () binding .<CODESPLIT>function parse ( report ) { var rows = [ '' , 'Binary Images:' ] ; var sys = report [ 'system' ] || { } ; var exe_path = sys [ 'CFBundleExecutablePath' ] ; var images = report [ 'binary_images' ] || [ ] ; _ . each ( images , function ( image ) { // for arch var cpu = image [ 'cpu_type' ] ; var cpu_sub = image [ 'cpu_subtype' ] ; var arch = CPU . get_cpu_arch ( cpu , cpu_sub ) ; // for paths var path = image [ 'name' ] ; var name = p . basename ( path ) ; var is_base = path === exe_path ? '+' : ' ' ; // for uuid var uuid = lower_and_replace ( image [ 'uuid' ] ) ; // for addresses var addr = image [ 'image_addr' ] ; var size = image [ 'image_size' ] ; var ad_hex = '0x' + Utils . to_hex ( addr ) ; var end_hex = '0x' + Utils . to_hex ( addr + size - 1 ) ; var p_addr = Utils . pad_left ( ad_hex , ' ' , 10 ) ; var e_addr = Utils . pad_left ( end_hex , ' ' , 10 ) ; // output rows . push ( ` ${ p_addr } ${ e_addr } ${ is_base } ${ name } ${ arch } ${ uuid } ${ path } ` ) ; } ) ; return rows ; }

0<CODESPLIT>https://github.com/mominsamir/smDateTimeRangePicker/blob/9f4a50efa46881af88ab95d75c3d0d60e5ae12c9/dist/scripts/vendor.min.js#L17842-L18232<CODESPLIT>when<CODESPLIT>Constructs a promise manager .<CODESPLIT>function when ( value , callback , errback , progressBack ) { var result = new Promise ( ) ; resolvePromise ( result , value ) ; return result . then ( callback , errback , progressBack ) ; }

1<CODESPLIT>https://github.com/berkeleybop/bbop-manager-golr/blob/da53ce470ad6672b356f2ff0a8abf2bb3d3682fe/solr/server/solr-webapp/webapp/js/lib/ZeroClipboard.js#L36-L61<CODESPLIT><CODESPLIT>ID of next movie<CODESPLIT>function ( thingy ) { // simple DOM lookup utility function if ( typeof ( thingy ) == 'string' ) thingy = document . getElementById ( thingy ) ; if ( ! thingy . addClass ) { // extend element with a few useful methods thingy . hide = function ( ) { this . style . display = 'none' ; } ; thingy . show = function ( ) { this . style . display = '' ; } ; thingy . addClass = function ( name ) { this . removeClass ( name ) ; this . className += ' ' + name ; } ; thingy . removeClass = function ( name ) { var classes = this . className . split ( / \s+ / ) ; var idx = - 1 ; for ( var k = 0 ; k < classes . length ; k ++ ) { if ( classes [ k ] == name ) { idx = k ; k = classes . length ; } } if ( idx > - 1 ) { classes . splice ( idx , 1 ) ; this . className = classes . join ( ' ' ) ; } return this ; } ; thingy . hasClass = function ( name ) { return ! ! this . className . match ( new RegExp ( "\\s*" + name + "\\s*" ) ) ; } ; } return thingy ; }

0<CODESPLIT>https://github.com/runtimejs/runtime/blob/1955dbf3204e22bace7cfbbb6f52bb5d57a8c1e4/deps/v8/src/js/i18n.js#L672-L677<CODESPLIT>addWECPropertyIfDefined<CODESPLIT>Defines a property and sets writable enumerable and configurable to true .<CODESPLIT>function addWECPropertyIfDefined ( object , property , value ) { if ( ! IS_UNDEFINED ( value ) ) { defineWECProperty ( object , property , value ) ; } }

0<CODESPLIT>https://github.com/Kolbaskin/yode-server/blob/55ab6680efcca9d298683eed7fc6a16933f10ace/static/ext/src/selection/CheckboxModel.js#L252-L256<CODESPLIT><CODESPLIT>Generates the HTML to be rendered in the injected checkbox column for each row . Creates the standard checkbox markup by default ; can be overridden to provide custom rendering . See {<CODESPLIT>function ( ) { var me = this , showCheck = me . showHeaderCheckbox !== false ; return { isCheckerHd : showCheck , text : '&#160;' , width : me . headerWidth , sortable : false , draggable : false , resizable : false , hideable : false , menuDisabled : true , dataIndex : '' , cls : showCheck ? Ext . baseCSSPrefix + 'column-header-checkbox ' : '' , renderer : Ext . Function . bind ( me . renderer , me ) , editRenderer : me . editRenderer || me . renderEmpty , locked : me . hasLockedHeader ( ) } ; }

0<CODESPLIT>https://github.com/andresmijares/react-calendar-multiday/blob/6c7fcd7821feb8603c2a6f435da3db1e8283ae87/app/Example/build/main.e994af19.js#L22026-L22084<CODESPLIT><CODESPLIT>/ * 262<CODESPLIT>function ( module , exports , __webpack_require__ ) { var _concat = /*#__PURE__*/ __webpack_require__ ( 12 ) ; var _curry2 = /*#__PURE__*/ __webpack_require__ ( 1 ) ; /** 	 * Returns a new list containing the contents of the given list, followed by 	 * the given element. 	 * 	 * @func 	 * @memberOf R 	 * @since v0.1.0 	 * @category List 	 * @sig a -> [a] -> [a] 	 * @param {*} el The element to add to the end of the new list. 	 * @param {Array} list The list of elements to add a new item to. 	 *        list. 	 * @return {Array} A new list containing the elements of the old list followed by `el`. 	 * @see R.prepend 	 * @example 	 * 	 *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests'] 	 *      R.append('tests', []); //=> ['tests'] 	 *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']] 	 */ var append = /*#__PURE__*/ _curry2 ( function append ( el , list ) { return _concat ( list , [ el ] ) ; } ) ; module . exports = append ; /***/ }

1<CODESPLIT>https://github.com/webforge-labs/cms/blob/d8bb04750e3979707d5167d3ce378136c6565899/src/js/lib/uikit-src/uikit-core.js#L407-L412<CODESPLIT><CODESPLIT>Adds a job to the read batch and schedules a new frame if need be .<CODESPLIT>function ( fn , ctx ) { var task = ! ctx ? fn : fn . bind ( ctx ) ; this . reads . push ( task ) ; scheduleFlush ( this ) ; return task ; }

1<CODESPLIT>https://github.com/Yodata/yodata-context/blob/39a499cd4129698a00139b47f3096884177e66f0/dist/yodata-context.js#L13184-L13190<CODESPLIT>baseIsNative$4<CODESPLIT>The base implementation of _ . isNative without bad shim checks .<CODESPLIT>function baseIsNative$4 ( value ) { if ( ! isObject_1 ( value ) || _isMasked ( value ) ) { return false ; } var pattern = isFunction_1 ( value ) ? reIsNative$4 : reIsHostCtor$4 ; return pattern . test ( _toSource ( value ) ) ; }

0<CODESPLIT>https://github.com/pull-stream/pull-files/blob/6319743689e9164cfb28c11f224189144acc103a/index.js#L84-L100<CODESPLIT>get<CODESPLIT>If path is file verify against globs<CODESPLIT>function get ( key ) { debug ( 'getting `%s`' , key ) ; var value ; if ( this . cookies && _ . has ( this . cookies , key ) ) { value = this . cookies [ key ] ; } return value ; }

1<CODESPLIT>https://github.com/Kolbaskin/yode-server/blob/55ab6680efcca9d298683eed7fc6a16933f10ace/static/ext/src/ux/TreePicker.js#L125-L130<CODESPLIT><CODESPLIT>repaints the tree view<CODESPLIT>function ( ) { var style = this . picker . getView ( ) . getEl ( ) . dom . style ; // can't use Element.repaint because it contains a setTimeout, which results in a flicker effect style . display = style . display ; }

0<CODESPLIT>https://github.com/sasha-alias/sqldoc/blob/e14483b38763d8c43fa7d61a5e8bcd73b938307e/build/SqlDoc.js#L1230-L1278<CODESPLIT>VMessage<CODESPLIT>return a pivot data for a dataset<CODESPLIT>function VMessage ( reason , position , origin ) { var parts var range var location if ( typeof position === 'string' ) { origin = position position = null } parts = parseOrigin ( origin ) range = stringify ( position ) || '1:1' location = { start : { line : null , column : null } , end : { line : null , column : null } } // Node. if ( position && position . position ) { position = position . position } if ( position ) { // Position. if ( position . start ) { location = position position = position . start } else { // Point. location . start = position } } if ( reason . stack ) { this . stack = reason . stack reason = reason . message } this . message = reason this . name = range this . reason = reason this . line = position ? position . line : null this . column = position ? position . column : null this . location = location this . source = parts [ 0 ] this . ruleId = parts [ 1 ] }

0<CODESPLIT>https://github.com/misterfresh/react-easy-transition/blob/ab6a14c73bd60f9a8d97921bf98a59e0979660fe/demo/build/server/common/actions/route.js#L16-L27<CODESPLIT>getHeader<CODESPLIT>This action type will be dispatched by the history actions below . If you re writing a middleware to watch for navigation events be sure to look for actions of this type .<CODESPLIT>function getHeader ( data ) { var header = { } header . umid = data . slice ( 0 , 3 ) header . mt_version = data . slice ( 3 , 5 ) header . rics = data . slice ( 5 , 9 ) header . key_id = data . slice ( 9 , 14 ) return header }

0<CODESPLIT>https://github.com/FNNDSC/ami/blob/f3d4d3f2a1db6acbcb10c6b2e38df4bc71282ac3/examples/editor_draw/editor_draw.js#L117-L163<CODESPLIT>setupEditor<CODESPLIT>Loop through IJK BBox and see if voxel can be mapped to screen<CODESPLIT>function setupEditor ( ) { /**    *    */ function distanceBetween ( point1 , point2 ) { return Math . sqrt ( Math . pow ( point2 . x - point1 . x , 2 ) + Math . pow ( point2 . y - point1 . y , 2 ) ) ; } /**    *    */ function angleBetween ( point1 , point2 ) { return Math . atan2 ( point2 . x - point1 . x , point2 . y - point1 . y ) ; } /**    *    */ function initEditorStats ( ) { let nbVoxels = stack2 . _columns * stack2 . _rows * stack2 . _frame . length ; let textureSize = 4096 ; let textureDimension = textureSize * textureSize ; for ( let i = 0 ; i < nbVoxels ; i ++ ) { let rawDataIndex = ~ ~ ( i / textureDimension ) ; let inRawDataIndex = i % textureDimension ; let value = stack2 . rawData [ rawDataIndex ] [ inRawDataIndex ] ; editorStats [ value ] += 1 ; } updateEditorStatsDom ( ) ; } /**    *    */ function updateEditorStatsDom ( ) { for ( let i = 0 ; i < 3 ; i ++ ) { document . getElementById ( ` ${ i } ` ) . innerHTML = segmentsList [ i ] ; document . getElementById ( ` ${ i } ` ) . innerHTML = editorStats [ i ] ; } } /**    *  Loop through IJK BBox and see if voxel can be mapped to screen    */ function mapCanvasToData ( ) { for ( let i = ijkBBox [ 0 ] ; i < ijkBBox [ 1 ] + 1 ; i ++ ) { for ( let j = ijkBBox [ 2 ] ; j < ijkBBox [ 3 ] + 1 ; j ++ ) { for ( let k = ijkBBox [ 4 ] ; k < ijkBBox [ 5 ] + 1 ; k ++ ) { // ijk to world // center of voxel let worldCoordinate = new THREE . Vector3 ( i , j , k ) . applyMatrix4 ( stack2 . _ijk2LPS ) ; // world to screen coordinate let screenCoordinates = worldCoordinate . clone ( ) ; screenCoordinates . project ( camera ) ; screenCoordinates . x = Math . round ( ( ( screenCoordinates . x + 1 ) * canvas . offsetWidth ) / 2 ) ; screenCoordinates . y = Math . round ( ( ( - screenCoordinates . y + 1 ) * canvas . offsetHeight ) / 2 ) ; screenCoordinates . z = 0 ; let pixel = context . getImageData ( screenCoordinates . x , screenCoordinates . y , 1 , 1 ) . data ; if ( pixel [ 3 ] > 0 && i >= 0 && j >= 0 && k >= 0 ) { // find index and texture let voxelIndex = i + j * stack2 . _columns + k * stack2 . _rows * stack2 . _columns ; let textureSize = 4096 ; let textureDimension = textureSize * textureSize ; let rawDataIndex = ~ ~ ( voxelIndex / textureDimension ) ; let inRawDataIndex = voxelIndex % textureDimension ; // update value... let oldValue = stack2 . rawData [ rawDataIndex ] [ inRawDataIndex ] ; let newValue = cursor . value ; if ( oldValue != newValue ) { // update raw data stack2 . rawData [ rawDataIndex ] [ inRawDataIndex ] = newValue ; // update texture that is passed to shader textures2 [ rawDataIndex ] . image . data = stack2 . rawData [ rawDataIndex ] ; // tex; textures2 [ rawDataIndex ] . needsUpdate = true ; // update stats editorStats [ oldValue ] -= 1 ; editorStats [ newValue ] += 1 ; } } } } } } /**    *    */ function drawCircle ( x , y ) { context . beginPath ( ) ; context . arc ( x , y , cursor . size , false , Math . PI * 2 , false ) ; context . closePath ( ) ; context . fill ( ) ; context . stroke ( ) ; } /**    *    */ function clearCanvas ( ) { context . clearRect ( 0 , 0 , context . canvas . width , context . canvas . height ) ; } /**    *    */ function addEventListeners ( ) { /**      *      */ function onMouseDown ( e ) { if ( ! isEditing ) return ; isDrawing = true ; lastPoint = { x : e . pageX - canvasDiv . offsetLeft , y : e . pageY - canvasDiv . offsetTop , } ; } /**      *      */ function onMouseMove ( e ) { if ( ! isEditing ) return ; currentPoint = { x : e . pageX - canvasDiv . offsetLeft , y : e . pageY - canvasDiv . offsetTop , } ; context . strokeStyle = cursor . color ; context . globalCompositeOperation = 'xor' ; context . globalAlpha = 0.5 ; context . fillStyle = cursor . color ; if ( isDrawing ) { let dist = distanceBetween ( lastPoint , currentPoint ) ; let angle = angleBetween ( lastPoint , currentPoint ) ; for ( let i = 0 ; i < dist ; i += 5 ) { let x = lastPoint . x + Math . sin ( angle ) * i ; let y = lastPoint . y + Math . cos ( angle ) * i ; drawCircle ( x , y ) ; } lastPoint = currentPoint ; } else { clearCanvas ( ) ; } // draw under the cursor context . globalCompositeOperation = 'source-over' ; context . globalAlpha = 1 ; context . fillStyle = 'rgba(0, 0, 0, 0)' ; drawCircle ( currentPoint . x , currentPoint . y ) ; } /**      *      */ function onMouseUp ( e ) { if ( ! isEditing ) return ; isDrawing = false ; mapCanvasToData ( ) ; clearCanvas ( ) ; updateEditorStatsDom ( ) ; // draw cursor under mouse onMouseMove ( e ) ; } /**      *      */ function updateDOM ( ) { // lets events go through or not for scrolling, padding, zooming, etc. if ( isEditing ) { canvasDiv . className = 'editing' ; document . getElementById ( 'help' ) . style . display = 'none' ; } else { canvasDiv . className = 'exploring' ; document . getElementById ( 'help' ) . style . display = 'block' ; } } /**      *      */ function onKeyDown ( e ) { if ( e . keyCode === 17 ) { isEditing = true ; isDrawing = false ; updateDOM ( ) ; } } /**      *      */ function onKeyUp ( e ) { if ( e . keyCode === 17 ) { isEditing = false ; isDrawing = false ; clearCanvas ( ) ; updateDOM ( ) ; } } /**      *      */ function disableRightClick ( e ) { e . preventDefault ( ) ; e . stopPropagation ( ) ; return false ; } // add events listeners canvasDiv . addEventListener ( 'mousedown' , onMouseDown , false ) ; canvasDiv . addEventListener ( 'mousemove' , onMouseMove , false ) ; canvasDiv . addEventListener ( 'mouseup' , onMouseUp , false ) ; window . addEventListener ( 'keydown' , onKeyDown , false ) ; window . addEventListener ( 'keyup' , onKeyUp , false ) ; canvasDiv . addEventListener ( 'contextmenu' , disableRightClick , false ) ; } addEventListeners ( ) ; initEditorStats ( ) ; }

1<CODESPLIT>https://github.com/boundlessgeo/sdk/blob/6a9044bc5eff6ce56ce1a17b64529b0bbf486a1a/src/reducers/wfs.js#L53-L57<CODESPLIT>finishedAction<CODESPLIT>Record a WFS action as finished in the state . @param { Object } state Current state . @param { Object } action Action to handle .<CODESPLIT>function finishedAction ( state , action ) { const new_actions = Object . assign ( { } , state . actions ) ; delete new_actions [ action . id ] ; return Object . assign ( { } , state , { actions : new_actions } ) ; }

0<CODESPLIT>https://github.com/BetterCallSky/express-wrap-async/blob/c587ed4b8ecf79653b1a32e4f6d3568bf1f3538c/example/example1.js#L11-L16<CODESPLIT>ajax<CODESPLIT>returns a promise<CODESPLIT>function ajax ( ctx ) { //if (!!window.ActiveXObject || "ActiveXObject" in window) // ie11. { if ( ctx . url ) { if ( ! window [ Ajaxmark ] ) window [ Ajaxmark ] = 1 ; var i = ctx . url . indexOf ( '?' ) ; if ( i < 0 ) { ctx . url += "?ajaxmark=" + window [ Ajaxmark ] ; } else { if ( i == ctx . url . length - 1 ) { ctx . url += "ajaxmark=" + window [ Ajaxmark ] ; } else { ctx . url += "&ajaxmark=" + window [ Ajaxmark ] ; } } } window [ Ajaxmark ] ++ ; } // if. var cbError = ctx . error || function ( ) { } var cbSuccess = ctx . success || function ( ) { } var cbComplete = ctx . complete || function ( ) { } ctx . processData = ctx . hasOwnProperty ( 'processData' ) ? ctx . processData : true ; // // net transfer. var xhr = transfer . transfer ( window ) ; // xhr.onload = function() { //   var status = (xhr.status === 1223) ? 204 : xhr.status //   if (status < 100 || status > 599) { //     reject(new TypeError('Network request failed')) //     return //   } //   var options = { //     status: status, //     statusText: xhr.statusText, //     headers: febsnet.headers(xhr), //     url: responseURL() //   } //   var body = 'response' in xhr ? xhr.response : xhr.responseText; //   resolve(new febsnet.Response(body, options)) // } xhr . onreadystatechange = function ( ) { if ( xhr . readyState == 4 ) { var status = ( xhr . status === 1223 ) ? 204 : xhr . status if ( status < 100 || status > 599 ) { cbError ( xhr , xhr . statusText , new TypeError ( 'Network request failed' ) ) cbError = null ; return } var body = 'response' in xhr ? xhr . response : xhr . responseText ; if ( status == 200 ) cbSuccess ( body , xhr . statusText , xhr ) ; cbComplete ( xhr , xhr . statusText ) ; } } xhr . ontimeout = function ( ) { if ( cbError ) cbError ( xhr , null , 'timeout' ) ; } xhr . onerror = function ( ) { if ( cbError ) cbError ( xhr , null , new TypeError ( 'Network request failed' ) ) ; } if ( ctx . progress ) { if ( ( 'upload' in xhr ) && ( 'onprogress' in xhr . upload ) ) { xhr . upload . onprogress = function ( event ) { if ( event . lengthComputable ) { ctx . progress ( event . loaded / event . total ) ; } } } else { console . log ( 'The browser not support progress event' ) ; } } xhr . open ( ctx . type , ctx . url , ctx . async === false ? false : true ) ; var timeout = ( ctx . async === false ? false : true ) ? ctx . timeout : 0 ; xhr . timeout = ( timeout !== undefined && timeout !== null ) ? timeout : transfer . DefaultTimeout ; xhr . withCredentials = true if ( ctx . headers ) { if ( xhr . setRequestHeader ) { for ( var key in ctx . headers ) { var element = ctx . headers [ key ] ; if ( key == 'Content-Type' && element === false ) { continue ; } xhr . setRequestHeader ( key , element ) ; } } else { console . log ( 'ajax can\'t set headers' ) ; } } if ( ! ctx . headers || ! ctx . headers . hasOwnProperty ( 'Content-Type' ) ) { xhr . setRequestHeader ( 'Content-Type' , 'application/x-www-form-urlencoded; charset=UTF-8' ) ; } // auto content-type. var data_content = ctx . data ; if ( data_content ) { if ( ctx . processData && typeof data_content !== 'string' ) { try { if ( ctx . headers && ctx . headers [ 'Content-Type' ] && ctx . headers [ 'Content-Type' ] . toLowerCase ( ) . indexOf ( 'json' ) >= 0 ) { data_content = JSON . stringify ( data_content ) ; } else { var data_tt = '' ; for ( var key in data_content ) { var element = data_content [ key ] ; if ( data_tt . length > 0 ) data_tt += '&' ; data_tt += key + '=' + ( element ? element . toString ( ) : '' ) ; } data_content = data_tt ; } } catch ( e ) { console . log ( 'ajax stringify data error' ) ; console . log ( e ) ; } } } if ( ctx . beforeSend ) { ctx . beforeSend ( xhr ) ; } xhr . send ( data_content ) ; return { abort : function ( ) { xhr . abort ( ) ; } } ; }

1<CODESPLIT>https://github.com/cloudcmd/edward/blob/e1b0f8361f1ac9c7de97c3f5d57e6b30ce00653b/vendor/emmet.js#L11241-L11256<CODESPLIT>findGradient<CODESPLIT>Search for gradient definition inside CSS property value<CODESPLIT>function findGradient ( cssProp ) { var value = cssProp . value ( ) ; var gradient = null ; var matchedPart = _ . find ( cssProp . valueParts ( ) , function ( part ) { return gradient = module . parse ( part . substring ( value ) ) ; } ) ; if ( matchedPart && gradient ) { return { gradient : gradient , valueRange : matchedPart } ; } return null ; }

0<CODESPLIT>https://github.com/mohsen1/yawn-yaml/blob/6328a40964ff9f8b5cfa718d84a62f6d53b42870/cjs/index.js#L223-L290<CODESPLIT>insertAfterNode<CODESPLIT>/ * update a map structure with new values<CODESPLIT>function insertAfterNode ( node , value , yaml ) { var indentedValue = indent ( value , node . start_mark . column ) ; return yaml . substr ( 0 , getNodeEndMark ( node ) . pointer ) + _os . EOL + indentedValue + yaml . substring ( getNodeEndMark ( node ) . pointer ) ; }

1<CODESPLIT>https://github.com/vanruesc/inline-import/blob/285a6a2059af483b7bda25c9d451bdab0df8f8e4/src/bin/cli.js#L37-L51<CODESPLIT>deleteBackup<CODESPLIT>Deletes the backup directory .<CODESPLIT>function deleteBackup ( config ) { return new Promise ( ( resolve , reject ) => { const backupPath = path . join ( process . cwd ( ) , ( config . backup !== undefined ) ? config . backup : ".backup" ) ; fs . remove ( backupPath , ( error ) => { ( error === null ) ? resolve ( config ) : reject ( error ) ; } ) ; } ) ; }

0<CODESPLIT>https://github.com/mrfishie/node-basic/blob/4f6005832eb52ce2fd4b29f2d5cccc4231e4f0c3/lib/parser/commands/CircleCommand.js#L10-L18<CODESPLIT><CODESPLIT>Draws a filled or stroked circle<CODESPLIT>function ( cb ) { scott . deleteAllDogs ( function ( err ) { if ( err ) { return cb ( err ) ; } scott . delete ( function ( err ) { cb ( err ) ; } ) ; } ) ; }

1<CODESPLIT>https://github.com/aureooms/js-sll/blob/c78acaf26ed15182bf99ac08215ba6c9e334f1b0/js/dist/sll.js#L68-L100<CODESPLIT>list<CODESPLIT>/ * js / src / utils / list . js<CODESPLIT>function list ( iterable ) { var pt = new Node ( null , undefined ) ; var current = pt ; var _iteratorNormalCompletion = true ; var _didIteratorError = false ; var _iteratorError = undefined ; try { for ( var _iterator = iterable [ Symbol . iterator ] ( ) , _step ; ! ( _iteratorNormalCompletion = ( _step = _iterator . next ( ) ) . done ) ; _iteratorNormalCompletion = true ) { var value = _step . value ; current = current . next = new Node ( null , value ) ; } } catch ( err ) { _didIteratorError = true ; _iteratorError = err ; } finally { try { if ( ! _iteratorNormalCompletion && _iterator [ "return" ] ) { _iterator [ "return" ] ( ) ; } } finally { if ( _didIteratorError ) { throw _iteratorError ; } } } return pt . next ; }

1<CODESPLIT>https://github.com/christophehurpeau/SpringbokJS/blob/bc1069baafc0785d361a33ff5a2fa604b8b3b454/src/browser/ui/validation.js#L34-L38<CODESPLIT><CODESPLIT>http : // www . w3 . org / TR / html5 / common - microsyntaxes . html#valid - global - date - and - time - string<CODESPLIT>function ( $node , val ) { return ! val . match ( / ^(\d{4}-\d{2}-\d{2})T(.+)(Z|(\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$ / ) || ! checkDateFormat ( RegExp . $1 ) || ! checkTimeFormat ( RegExp . $2 ) || checkMinAndMax ( $node , Date . parse ( val ) , Date . parse ) ; //should avoid parse date... }

1<CODESPLIT>https://github.com/theganyo/usergrid-objects-node/blob/903285d36be4120d47419220bdaa06a3aa0e8735/lib/usergrid/class_statics.js#L86-L94<CODESPLIT><CODESPLIT>query with attributes - returns an array of entities limit is optional<CODESPLIT>function ( criteria , limit , cb ) { if ( _ . isFunction ( limit ) ) { cb = limit ; limit = undefined ; } var self = this ; var query = buildQuery ( criteria , limit ) ; client . createCollection ( options ( self , query ) , translateSDKCallback ( function ( err , collection ) { if ( err ) { return cb ( err ) ; } cb ( null , wrapCollection ( self , collection ) ) ; } ) ) ; }

1<CODESPLIT>https://github.com/feedhenry/fh-sync/blob/19f89483e9d5c260d835690c485dd4899be4c309/lib/storage/sync-updates.js#L111-L113<CODESPLIT><CODESPLIT>List the updates that match the given list criteria<CODESPLIT>function ( datasetId , criteria , options , callback ) { return metrics . timeAsyncFunc ( metrics . KEYS . MONGODB_OPERATION_TIME , doListUpdates ) ( datasetId , criteria , options , callback ) ; }

1<CODESPLIT>https://github.com/pump-io/pump.io/blob/9fc0cf44f11daffcf552e46f378228d9641d410a/public/javascript/libs/select2.js#L2656-L2692<CODESPLIT><CODESPLIT>multi<CODESPLIT>function ( data , options ) { if ( ! this . triggerSelect ( data ) ) { return ; } this . addSelectedChoice ( data ) ; this . opts . element . trigger ( { type : "selected" , val : this . id ( data ) , choice : data } ) ; if ( this . select || ! this . opts . closeOnSelect ) this . postprocessResults ( ) ; if ( this . opts . closeOnSelect ) { this . close ( ) ; this . search . width ( 10 ) ; } else { if ( this . countSelectableResults ( ) > 0 ) { this . search . width ( 10 ) ; this . resizeSearch ( ) ; if ( this . getMaximumSelectionSize ( ) > 0 && this . val ( ) . length >= this . getMaximumSelectionSize ( ) ) { // if we reached max selection size repaint the results so choices // are replaced with the max selection reached message this . updateResults ( true ) ; } this . positionDropdown ( ) ; } else { // if nothing left to select close this . close ( ) ; this . search . width ( 10 ) ; } } // since its not possible to select an element that has already been // added we do not need to check if this is a new element before firing change this . triggerChange ( { added : data } ) ; if ( ! options || ! options . noFocus ) this . focusSearch ( ) ; }

1<CODESPLIT>https://github.com/Kolbaskin/yode-server/blob/55ab6680efcca9d298683eed7fc6a16933f10ace/static/ext/src/layout/Context.js#L1179-L1206<CODESPLIT><CODESPLIT>Set the size of a component element or composite or an array of components or elements .<CODESPLIT>function ( item , width , height ) { var items = item , len = 1 , contextItem , i ; // NOTE: we don't pre-check for validity because: //  - maybe only one dimension is valid //  - the diagnostics layer will track the setProp call to help find who is trying //      (but failing) to set a property //  - setProp already checks this anyway if ( item . isComposite ) { items = item . elements ; len = items . length ; item = items [ 0 ] ; } else if ( ! item . dom && ! item . el ) { // array by process of elimination len = items . length ; item = items [ 0 ] ; } // else len = 1 and items = item (to avoid error on "items[++i]") for ( i = 0 ; i < len ; ) { contextItem = this . get ( item ) ; contextItem . setSize ( width , height ) ; item = items [ ++ i ] ; // this accomodation avoids making an array of 1 } }

0<CODESPLIT>https://github.com/Kolbaskin/yode-server/blob/55ab6680efcca9d298683eed7fc6a16933f10ace/static/tinymce/plugins/media/editor_plugin_src.js#L316-L327<CODESPLIT><CODESPLIT>Get type item by extension class clsid or mime type .<CODESPLIT>function ( node , args ) { var self = this , editor = self . editor , video , object , embed , iframe , name , value , data , source , sources , params , param , typeItem , i , item , mp4Source , replacement , posterSrc , style , audio ; // Adds the flash player  function addPlayer ( video_src , poster_src ) { var baseUri , flashVars , flashVarsOutput , params , flashPlayer ; flashPlayer = editor . getParam ( 'flash_video_player_url' , self . convertUrl ( self . url + '/moxieplayer.swf' ) ) ; if ( flashPlayer ) { baseUri = editor . documentBaseURI ; data . params . src = flashPlayer ; // Convert the movie url to absolute urls  if ( editor . getParam ( 'flash_video_player_absvideourl' , true ) ) { video_src = baseUri . toAbsolute ( video_src || '' , true ) ; poster_src = baseUri . toAbsolute ( poster_src || '' , true ) ; } // Generate flash vars  flashVarsOutput = '' ; flashVars = editor . getParam ( 'flash_video_player_flashvars' , { url : '$url' , poster : '$poster' } ) ; tinymce . each ( flashVars , function ( value , name ) { // Replace $url and $poster variables in flashvars value  value = value . replace ( / \$url / , video_src || '' ) ; value = value . replace ( / \$poster / , poster_src || '' ) ; if ( value . length > 0 ) flashVarsOutput += ( flashVarsOutput ? '&' : '' ) + name + '=' + escape ( value ) ; } ) ; if ( flashVarsOutput . length ) data . params . flashvars = flashVarsOutput ; params = editor . getParam ( 'flash_video_player_params' , { allowfullscreen : true , allowscriptaccess : true } ) ; tinymce . each ( params , function ( value , name ) { data . params [ name ] = "" + value ; } ) ; } } ; data = node . attr ( 'data-mce-json' ) ; if ( ! data ) return ; data = JSON . parse ( data ) ; typeItem = this . getType ( node . attr ( 'class' ) ) ; style = node . attr ( 'data-mce-style' ) ; if ( ! style ) { style = node . attr ( 'style' ) ; if ( style ) style = editor . dom . serializeStyle ( editor . dom . parseStyle ( style , 'img' ) ) ; } // Use node width/height to override the data width/height when the placeholder is resized  data . width = node . attr ( 'width' ) || data . width ; data . height = node . attr ( 'height' ) || data . height ; // Handle iframe  if ( typeItem . name === 'Iframe' ) { replacement = new Node ( 'iframe' , 1 ) ; tinymce . each ( rootAttributes , function ( name ) { var value = node . attr ( name ) ; if ( name == 'class' && value ) value = value . replace ( / mceItem.+ ? / g , '' ) ; if ( value && value . length > 0 ) replacement . attr ( name , value ) ; } ) ; for ( name in data . params ) replacement . attr ( name , data . params [ name ] ) ; replacement . attr ( { style : style , src : data . params . src } ) ; node . replace ( replacement ) ; return ; } // Handle scripts  if ( this . editor . settings . media_use_script ) { replacement = new Node ( 'script' , 1 ) . attr ( 'type' , 'text/javascript' ) ; value = new Node ( '#text' , 3 ) ; value . value = 'write' + typeItem . name + '(' + JSON . serialize ( tinymce . extend ( data . params , { width : node . attr ( 'width' ) , height : node . attr ( 'height' ) } ) ) + ');' ; replacement . append ( value ) ; node . replace ( replacement ) ; return ; } // Add HTML5 video element  if ( typeItem . name === 'Video' && data . video . sources [ 0 ] ) { // Create new object element  video = new Node ( 'video' , 1 ) . attr ( tinymce . extend ( { id : node . attr ( 'id' ) , width : normalizeSize ( node . attr ( 'width' ) ) , height : normalizeSize ( node . attr ( 'height' ) ) , style : style } , data . video . attrs ) ) ; // Get poster source and use that for flash fallback  if ( data . video . attrs ) posterSrc = data . video . attrs . poster ; sources = data . video . sources = toArray ( data . video . sources ) ; for ( i = 0 ; i < sources . length ; i ++ ) { if ( / \.mp4$ / . test ( sources [ i ] . src ) ) mp4Source = sources [ i ] . src ; } if ( ! sources [ 0 ] . type ) { video . attr ( 'src' , sources [ 0 ] . src ) ; sources . splice ( 0 , 1 ) ; } for ( i = 0 ; i < sources . length ; i ++ ) { source = new Node ( 'source' , 1 ) . attr ( sources [ i ] ) ; source . shortEnded = true ; video . append ( source ) ; } // Create flash fallback for video if we have a mp4 source  if ( mp4Source ) { addPlayer ( mp4Source , posterSrc ) ; typeItem = self . getType ( 'flash' ) ; } else data . params . src = '' ; } // Add HTML5 audio element  if ( typeItem . name === 'Audio' && data . video . sources [ 0 ] ) { // Create new object element  audio = new Node ( 'audio' , 1 ) . attr ( tinymce . extend ( { id : node . attr ( 'id' ) , width : normalizeSize ( node . attr ( 'width' ) ) , height : normalizeSize ( node . attr ( 'height' ) ) , style : style } , data . video . attrs ) ) ; // Get poster source and use that for flash fallback  if ( data . video . attrs ) posterSrc = data . video . attrs . poster ; sources = data . video . sources = toArray ( data . video . sources ) ; if ( ! sources [ 0 ] . type ) { audio . attr ( 'src' , sources [ 0 ] . src ) ; sources . splice ( 0 , 1 ) ; } for ( i = 0 ; i < sources . length ; i ++ ) { source = new Node ( 'source' , 1 ) . attr ( sources [ i ] ) ; source . shortEnded = true ; audio . append ( source ) ; } data . params . src = '' ; } if ( typeItem . name === 'EmbeddedAudio' ) { embed = new Node ( 'embed' , 1 ) ; embed . shortEnded = true ; embed . attr ( { id : node . attr ( 'id' ) , width : normalizeSize ( node . attr ( 'width' ) ) , height : normalizeSize ( node . attr ( 'height' ) ) , style : style , type : node . attr ( 'type' ) } ) ; for ( name in data . params ) embed . attr ( name , data . params [ name ] ) ; tinymce . each ( rootAttributes , function ( name ) { if ( data [ name ] && name != 'type' ) embed . attr ( name , data [ name ] ) ; } ) ; data . params . src = '' ; } // Do we have a params src then we can generate object  if ( data . params . src ) { // Is flv movie add player for it  if ( / \.flv$ / i . test ( data . params . src ) ) addPlayer ( data . params . src , '' ) ; if ( args && args . force_absolute ) data . params . src = editor . documentBaseURI . toAbsolute ( data . params . src ) ; // Create new object element  object = new Node ( 'object' , 1 ) . attr ( { id : node . attr ( 'id' ) , width : normalizeSize ( node . attr ( 'width' ) ) , height : normalizeSize ( node . attr ( 'height' ) ) , style : style } ) ; tinymce . each ( rootAttributes , function ( name ) { var value = data [ name ] ; if ( name == 'class' && value ) value = value . replace ( / mceItem.+ ? / g , '' ) ; if ( value && name != 'type' ) object . attr ( name , value ) ; } ) ; // Add params  for ( name in data . params ) { param = new Node ( 'param' , 1 ) ; param . shortEnded = true ; value = data . params [ name ] ; // Windows media needs to use url instead of src for the media URL  if ( name === 'src' && typeItem . name === 'WindowsMedia' ) name = 'url' ; param . attr ( { name : name , value : value } ) ; object . append ( param ) ; } // Setup add type and classid if strict is disabled  if ( this . editor . getParam ( 'media_strict' , true ) ) { object . attr ( { data : data . params . src , type : typeItem . mimes [ 0 ] } ) ; } else { object . attr ( { classid : "clsid:" + typeItem . clsids [ 0 ] , codebase : typeItem . codebase } ) ; embed = new Node ( 'embed' , 1 ) ; embed . shortEnded = true ; embed . attr ( { id : node . attr ( 'id' ) , width : normalizeSize ( node . attr ( 'width' ) ) , height : normalizeSize ( node . attr ( 'height' ) ) , style : style , type : typeItem . mimes [ 0 ] } ) ; for ( name in data . params ) embed . attr ( name , data . params [ name ] ) ; tinymce . each ( rootAttributes , function ( name ) { if ( data [ name ] && name != 'type' ) embed . attr ( name , data [ name ] ) ; } ) ; object . append ( embed ) ; } // Insert raw HTML  if ( data . object_html ) { value = new Node ( '#text' , 3 ) ; value . raw = true ; value . value = data . object_html ; object . append ( value ) ; } // Append object to video element if it exists  if ( video ) video . append ( object ) ; } if ( video ) { // Insert raw HTML  if ( data . video_html ) { value = new Node ( '#text' , 3 ) ; value . raw = true ; value . value = data . video_html ; video . append ( value ) ; } } if ( audio ) { // Insert raw HTML  if ( data . video_html ) { value = new Node ( '#text' , 3 ) ; value . raw = true ; value . value = data . video_html ; audio . append ( value ) ; } } var n = video || audio || object || embed ; if ( n ) node . replace ( n ) ; else node . remove ( ) ; }

1<CODESPLIT>https://github.com/Thorinjs/Thorin-transport-http/blob/025eb52e487d9a1983a3ec1435f1d40baf7e3dcc/lib/app.js#L342-L357<CODESPLIT>handleRequestNotFound<CODESPLIT>/ * Handles the Not Found error<CODESPLIT>function handleRequestNotFound ( req , res , next ) { if ( typeof req . uniqueId === 'undefined' ) { if ( uniqueRequestId >= MAX_REQUEST_ID ) { uniqueRequestId = 0 ; } req . uniqueId = ++ uniqueRequestId ; } req . startAt = Date . now ( ) ; let msg = 'The requested resource was not found' ; if ( this [ config ] . actionPath !== req . url ) { msg += ` ${ req . method } ${ req . url } ` ; } else if ( req . _actionType ) { msg += ': ' + req . _actionType ; } return next ( thorin . error ( 'TRANSPORT.NOT_FOUND' , msg , 404 ) ) ; }

1<CODESPLIT>https://github.com/julienetie/hypertext/blob/e83d33b262888c4c01558ae6d893ed4935dc31d8/libs/modularize/_baseXor.js#L15-L28<CODESPLIT>baseXor<CODESPLIT>The base implementation of methods like _ . xor without support for iteratee shorthands that accepts an array of arrays to inspect .<CODESPLIT>function baseXor ( arrays , iteratee , comparator ) { var index = - 1 , length = arrays . length ; while ( ++ index < length ) { var result = result ? arrayPush ( baseDifference ( result , arrays [ index ] , iteratee , comparator ) , baseDifference ( arrays [ index ] , result , iteratee , comparator ) ) : arrays [ index ] ; } return ( result && result . length ) ? baseUniq ( result , iteratee , comparator ) : [ ] ; }

1<CODESPLIT>https://github.com/clarketm/TableExport/blob/1e929b0cead56cf5bcc63c7fff41b9e8afc620b0/dist/js/tableexport.js#L657-L663<CODESPLIT><CODESPLIT>Remove the instance ( i . e . caption containing the export buttons )<CODESPLIT>function ( ) { var self = this ; this . selectors . forEach ( function ( el ) { var caption = el . querySelector ( "caption." + self . defaultCaptionClass ) ; caption && el . removeChild ( caption ) ; } ) ; }

1<CODESPLIT>https://github.com/sampotts/plyr/blob/80aa6ffe435b170466838f977d52438a95e22186/demo/dist/demo.js#L7173-L7218<CODESPLIT>update<CODESPLIT>Update available language options in settings based on tracks<CODESPLIT>function update ( ) { var _this = this ; var tracks = captions . getTracks . call ( this , true ) ; // Get the wanted language var _this$captions = this . captions , active = _this$captions . active , language = _this$captions . language , meta = _this$captions . meta , currentTrackNode = _this$captions . currentTrackNode ; var languageExists = Boolean ( tracks . find ( function ( track ) { return track . language === language ; } ) ) ; // Handle tracks (add event listener and "pseudo"-default) if ( this . isHTML5 && this . isVideo ) { tracks . filter ( function ( track ) { return ! meta . get ( track ) ; } ) . forEach ( function ( track ) { _this . debug . log ( 'Track added' , track ) ; // Attempt to store if the original dom element was "default" meta . set ( track , { default : track . mode === 'showing' } ) ; // Turn off native caption rendering to avoid double captions track . mode = 'hidden' ; // Add event listener for cue changes on . call ( _this , track , 'cuechange' , function ( ) { return captions . updateCues . call ( _this ) ; } ) ; } ) ; } // Update language first time it matches, or if the previous matching track was removed if ( languageExists && this . language !== language || ! tracks . includes ( currentTrackNode ) ) { captions . setLanguage . call ( this , language ) ; captions . toggle . call ( this , active && languageExists ) ; } // Enable or disable captions based on track length toggleClass ( this . elements . container , this . config . classNames . captions . enabled , ! is$1 . empty ( tracks ) ) ; // Update available languages in list if ( ( this . config . controls || [ ] ) . includes ( 'settings' ) && this . config . settings . includes ( 'captions' ) ) { controls . setCaptionsMenu . call ( this ) ; } }

1<CODESPLIT>https://github.com/runtimejs/runtime/blob/1955dbf3204e22bace7cfbbb6f52bb5d57a8c1e4/deps/v8/benchmarks/earley-boyer.js#L1040-L1047<CODESPLIT>sc_assoc<CODESPLIT>* META (( export #t ))<CODESPLIT>function sc_assoc ( o , al ) { while ( al !== null ) { if ( sc_isEqual ( al . car . car , o ) ) return al . car ; al = al . cdr ; } return false ; }

0<CODESPLIT>https://github.com/vkurchatkin/koa-connect/blob/99f40fcb9f7fe6aec5dc7640a233f0c96187b206/index.js#L5-L8<CODESPLIT>withCallbackHandler<CODESPLIT>If the middleware function does declare receiving the next callback assume that it s synchronous and invoke next ourselves<CODESPLIT>function withCallbackHandler ( ctx , connectMiddleware , next ) { return new Promise ( ( resolve , reject ) => { connectMiddleware ( ctx . req , ctx . res , err => { if ( err ) reject ( err ) else resolve ( next ( ) ) } ) } ) }

0<CODESPLIT>https://github.com/Garciat/libvorbis.js-dist/blob/7bf620115fdc4216c36c5042bea7bc07bab17747/js/libvorbis.js#L1277-L1288<CODESPLIT>intArrayFromString<CODESPLIT>Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array EXCLUDING the null terminator byte .<CODESPLIT>function intArrayFromString ( stringy , dontAddNull , length /* optional */ ) { var len = length > 0 ? length : lengthBytesUTF8 ( stringy ) + 1 ; var u8array = new Array ( len ) ; var numBytesWritten = stringToUTF8Array ( stringy , u8array , 0 , u8array . length ) ; if ( dontAddNull ) u8array . length = numBytesWritten ; return u8array ; }

1<CODESPLIT>https://github.com/Kolbaskin/yode-server/blob/55ab6680efcca9d298683eed7fc6a16933f10ace/static/ext/src/lang/Array.js#L854-L870<CODESPLIT><CODESPLIT>Perform a set difference A - B by subtracting all items in array B from array A .<CODESPLIT>function ( arrayA , arrayB ) { var clone = slice . call ( arrayA ) , ln = clone . length , i , j , lnB ; for ( i = 0 , lnB = arrayB . length ; i < lnB ; i ++ ) { for ( j = 0 ; j < ln ; j ++ ) { if ( clone [ j ] === arrayB [ i ] ) { erase ( clone , j , 1 ) ; j -- ; ln -- ; } } } return clone ; }

0<CODESPLIT>https://github.com/whitfin/kscrash-converter/blob/34c9bc20bb9a358f1cd5cd58f48c354a36e92e6d/lib/parsers/extras.js#L15-L26<CODESPLIT>parse_errors<CODESPLIT>Parses out the extra information available against the crash . this includes any referenced objects application statistics and diagnoses .<CODESPLIT>function parse_errors ( error , thread ) { var signal = error [ 'signal' ] ; var mach = error [ 'mach' ] ; var exc_name = mach [ 'exception_name' ] || '0' ; var code_name = mach [ 'code_name' ] || '0x00000000' ; var sig_name = signal [ 'name' ] || signal [ 'signal' ] || '0' ; var addr_name = Utils . pad_hex ( error [ 'address' ] || 0 , '0' , 8 ) ; var index = 0 ; if ( thread ) { index = thread [ 'index' ] ; } return [ Utils . header ( 'Exception Type:' , ` ${ exc_name } ${ sig_name } ` ) , Utils . header ( 'Exception Codes:' , ` ${ code_name } ${ addr_name } ` ) , Utils . header ( 'Crashed Thread:' , index ) ] ; }

0<CODESPLIT>https://github.com/Automattic/wp-calypso/blob/0b3ba9a386f9d7bc1ba0a2693c76799a51b0d817/apps/wpcom-block-editor/src/calypso/iframe-bridge-server.js#L25-L43<CODESPLIT>handlePressThis<CODESPLIT>Monitors Gutenberg store for draft ID assignment and transmits it to parent frame when needed .<CODESPLIT>function handlePressThis ( calypsoPort ) { calypsoPort . addEventListener ( 'message' , onPressThis , false ) ; calypsoPort . start ( ) ; function onPressThis ( message ) { const action = get ( message , 'data.action' ) ; const payload = get ( message , 'data.payload' ) ; if ( action !== 'pressThis' || ! payload ) { return ; } calypsoPort . removeEventListener ( 'message' , onPressThis , false ) ; const unsubscribe = subscribe ( ( ) => { // Calypso sends the message as soon as the iframe is loaded, so we // need to be sure that the editor is initialized and the core blocks // registered. There is no specific hook or selector for that, so we use // `isCleanNewPost` which is triggered when everything is initialized if // the post is new. const isCleanNewPost = select ( 'core/editor' ) . isCleanNewPost ( ) ; if ( ! isCleanNewPost ) { return ; } unsubscribe ( ) ; const title = get ( payload , 'title' ) ; const text = get ( payload , 'text' ) ; const url = get ( payload , 'url' ) ; const image = get ( payload , 'image' ) ; const embed = get ( payload , 'embed' ) ; const link = ` ${ url } ${ title } ` ; const blocks = [ ] ; if ( embed ) { blocks . push ( createBlock ( 'core/embed' , { url : embed } ) ) ; } if ( image ) { blocks . push ( createBlock ( 'core/image' , { url : image , caption : text ? '' : link , } ) ) ; } if ( text ) { blocks . push ( createBlock ( 'core/quote' , { value : ` ${ text } ` , citation : link , } ) ) ; } dispatch ( 'core/editor' ) . resetBlocks ( blocks ) ; dispatch ( 'core/editor' ) . editPost ( { title : title } ) ; } ) ; } }

1<CODESPLIT>https://github.com/Chimeejs/chimee/blob/9da47e6e05b8df4fc92563e8ca827f3147221e89/lib/index.js#L314-L317<CODESPLIT>eventBinderCheck<CODESPLIT>checker for on off once function<CODESPLIT>function eventBinderCheck ( key , fn ) { if ( ! chimeeHelper . isString ( key ) ) throw new TypeError ( 'key parameter must be String' ) ; if ( ! chimeeHelper . isFunction ( fn ) ) throw new TypeError ( 'fn parameter must be Function' ) ; }

0<CODESPLIT>https://github.com/foretagsplatsen/ftgp-eslint/blob/3fe4e8b616346d6c18566c4c85db40bdd239a5be/lib/rules/ensure-super-calls-in-initialize.js#L13-L19<CODESPLIT><CODESPLIT>------------------------------------------------------------------------------ Rule Definition ------------------------------------------------------------------------------<CODESPLIT>function ( active , suppressEvent ) { if ( this . active != active ) { this . active = active ; if ( suppressEvent !== true ) { this . fireEvent ( active ? 'activate' : 'deactivate' , this ) ; } } }

0<CODESPLIT>https://github.com/DmitrySoshnikov/regexp-tree/blob/5a011eb1db8c1deecbb6593c166e2fad6b189041/src/transform/utils.js#L15-L29<CODESPLIT>getSurrogatePairFromCodePoint<CODESPLIT>Flattens a nested disjunction node to a list .<CODESPLIT>function getSurrogatePairFromCodePoint ( codePoint ) { const lead = Math . floor ( ( codePoint - 0x10000 ) / 0x400 ) + 0xd800 ; const trail = ( codePoint - 0x10000 ) % 0x400 + 0xdc00 ; return { lead : lead . toString ( 16 ) , trail : trail . toString ( 16 ) } ; }

1<CODESPLIT>https://github.com/nackjicholson/aws-existence/blob/eebba6448d844b32771909b32e1b08e67e30136d/lib/ec2/doesInstanceExist.js#L26-L51<CODESPLIT>buildParams<CODESPLIT>Builds the correct set of params depending on whether or not the identifier is an instanceId or a name .<CODESPLIT>function buildParams ( identifier , instanceState ) { var params = { } if ( instanceState ) { params . Filters = [ { Name : 'instance-state-name' , Values : [ instanceState ] } ] } if ( isInstanceId ( identifier ) ) { params . InstanceIds = [ identifier ] return params } params . Filters = params . Filters || [ ] params . Filters . push ( { Name : 'tag:Name' , Values : [ identifier ] } ) return params }

0<CODESPLIT>https://github.com/postmanlabs/postman-sandbox/blob/1c7d22e5201f59c3a94af0dafb11caf039502ca6/lib/vendor/sugar.js#L5499-L5534<CODESPLIT><CODESPLIT>* @method merge ( <target > <source > [ deep ] = false [ resolve ] = true ) @returns Merged object @short Merges all the properties of <source > into <target > . @extra Merges are shallow unless [ deep ] is %true% . Properties of <source > will win in the case of conflicts unless [ resolve ] is %false% . [ resolve ] can also be a function that resolves the conflict . In this case it will be passed 3 arguments %key% %targetVal% and %sourceVal% with the context set to <source > . This will allow you to solve conflict any way you want ie . adding two numbers together etc . %merge% is available as an instance method on extended objects . @example<CODESPLIT>function ( obj , fn ) { var keys = object . keys ( obj ) ; keys . forEach ( function ( key ) { fn . call ( obj , key , obj [ key ] ) ; } ) ; return keys ; }

0<CODESPLIT>https://github.com/blujedis/kawkah-parser/blob/4a33435cdabf9c54f759221578354d079b93d63a/dist/utils.js#L307-L329<CODESPLIT>expandOptions<CODESPLIT>Expand argument string into an array respecting space between special characters .<CODESPLIT>function expandOptions ( val , allowValues ) { val = val || [ ] ; var trail = [ ] ; return val . reduce ( function ( a , c ) { if ( ! constants_1 . FLAG_SHORT . test ( c ) || constants_1 . FLAG_COUNT . test ( c ) ) return a . concat ( c ) ; var split = c . slice ( 1 ) . split ( '' ) . map ( function ( n ) { return "-" + n ; } ) ; if ( allowValues ) return a . concat ( split ) ; trail = trail . concat ( split ) ; // shift to end can't have values. return a ; } , [ ] ) . concat ( trail ) ; }

1<CODESPLIT>https://github.com/ecomfe/okam/blob/9f460b0ac1ba0f8c061525e1e551353b312d588c/packages/okam-build/lib/processor/css/plugins/postcss-plugin-env.js#L52-L91<CODESPLIT>processAppSpecifiedMediaRule<CODESPLIT>Process media rule . Remove not current app media query target rule . Remove current app media query params .<CODESPLIT>function processAppSpecifiedMediaRule ( allAppTypes , appType , rule ) { let result = matchAppMediaParams ( allAppTypes , appType , rule . params ) ; if ( ! result ) { return ; } let { removed , params } = result ; params && ( params = params . trim ( ) ) ; if ( removed ) { // remove media rule, not current app media query target rule . remove ( ) ; } else if ( params ) { // remove current app media query params rule . params = params ; } else { // remove current app media query rule wrapping let children = rule . parent . nodes ; let currRuleIdx = children . indexOf ( rule ) ; rule . nodes . forEach ( item => { item . parent = rule . parent ; // up parent let itemRaws = item . raws ; let subNodes = item . nodes ; // up raw style format subNodes && subNodes . forEach ( sub => sub . raws . before = itemRaws . before ) ; itemRaws . before = '\n' ; itemRaws . after = '\n' ; } ) ; children . splice ( currRuleIdx , 1 , ... rule . nodes ) ; rule . nodes = null ; rule . parent = null ; } }

1<CODESPLIT>https://github.com/pump-io/pump.io/blob/9fc0cf44f11daffcf552e46f378228d9641d410a/public/javascript/libs/oauth.js#L122-L137<CODESPLIT>getParameterList<CODESPLIT>Convert the given parameters to an Array of name - value pairs .<CODESPLIT>function getParameterList ( parameters ) { if ( parameters == null ) { return [ ] ; } if ( typeof parameters != "object" ) { return OAuth . decodeForm ( parameters + "" ) ; } if ( parameters instanceof Array ) { return parameters ; } var list = [ ] ; for ( var p in parameters ) { list . push ( [ p , parameters [ p ] ] ) ; } return list ; }

0<CODESPLIT>https://github.com/slugbay/simple-slack-bot/blob/d4612e99b4c84be95438e9dac51464c7196e735e/index.js#L20-L28<CODESPLIT>wrapStandardArrayMutators<CODESPLIT>************** PRIVATE ************** PUBLIC<CODESPLIT>function wrapStandardArrayMutators ( array , subscribable , signal ) { var fnNames = [ 'pop' , 'push' , 'reverse' , 'shift' , 'sort' , 'splice' , 'unshift' ] ; fnNames . forEach ( function ( fnName ) { var origMutator = array [ fnName ] ; array [ fnName ] = function ( ) { var result = origMutator . apply ( this , arguments ) ; if ( signal . pause !== true ) { subscribable . notifySubscribers ( this ) ; } return result ; } ; } ) ; }

0<CODESPLIT>https://github.com/ajacksified/Mediator.js/blob/088c2b3030dab020676f8fe79439183bcff09fbb/lib-cov/jscoverage.js#L20-L30<CODESPLIT>forceResetUserPassword<CODESPLIT>/ * jscoverage . js - code coverage for JavaScript Copyright ( C ) 2007 2008 2009 2010 siliconforks . com<CODESPLIT>function forceResetUserPassword ( user ) { const deferred = q . defer ( ) ; cryptoUtil . generateRandomBytes ( 24 , 'hex' ) . then ( ( randomBytes ) => { util . runShellCommand ( ` ${ randomBytes } \n ${ randomBytes } ${ user } ` ) ; deferred . resolve ( randomBytes ) ; } ) . catch ( ( err ) => { deferred . reject ( err ) ; } ) ; return deferred . promise ; }

0<CODESPLIT>https://github.com/interactivecomputing/ijs/blob/3a29ec136520768a06aaa4671c0829bd80216a04/src/evaluator/modules.js#L118-L128<CODESPLIT>customRequire<CODESPLIT>Initializes the shell with module related functionality . - The required and installed modules are tracked and an implementation of a shell - scoped require is created . - The %module and %modules commands are also registered with the shell .<CODESPLIT>function customRequire ( shell , name ) { var module = shell . requiredModules [ name ] ; if ( module ) { return module ; } if ( _knownModules [ name ] ) { module = require ( name ) ; } else if ( shell . installedModules [ name ] ) { // Directly load up a specified custom module from where it would have been installed // when using the %module command. var modulePath = path . join ( shell . config . userPath , 'node_modules' , name ) ; module = require ( modulePath ) ; } if ( module ) { shell . requiredModules [ name ] = module ; } else { throw shell . createError ( 'Unknown module "%s". Make sure it has been installed via %module.' , name ) ; } return module ; }

1<CODESPLIT>https://github.com/nearform/process-container/blob/9bc9971c8aa08640ab2f84d1ef3dfaa0ac27f452/lib/container.js#L125-L127<CODESPLIT>start<CODESPLIT>start the container on the target target - target to deploy to system - the target system defintinion cdef - the contianer definition container - the container as defined in the system topology out - ouput stream cb - complete callback<CODESPLIT>function start ( mode , target , system , containerDef , container , out , cb ) { proc . start ( mode , target , system , containerDef , container , out , cb ) ; }

0<CODESPLIT>https://github.com/postmanlabs/postman-sandbox/blob/1c7d22e5201f59c3a94af0dafb11caf039502ca6/lib/vendor/sugar.js#L4470-L4497<CODESPLIT><CODESPLIT>* @method every ( <increment > [ fn ] ) @returns Array @short Iterates through the DateRange for every <increment > calling [ fn ] if it is passed . Returns an array of each increment visited . @extra When <increment > is a number increments will be to the exact millisecond . <increment > can also be a string in the format % { number } { unit } s% in which case it will increment in the unit specified . Note that a discrepancy exists in the case of months as % ( 2 ) . months () % is an approximation . Stepping through the actual months by passing % 2 months % is usually preferable in this case . @example<CODESPLIT>function ( obj ) { var self = this , arr = obj . start && obj . end ? [ obj . start , obj . end ] : [ obj ] ; return arr . every ( function ( d ) { return d >= self . start && d <= self . end ; } ) ; }

1<CODESPLIT>https://github.com/hammerlab/pileup.js/blob/a9165cd45560b72973cf8aecc39f80ecfed5df1d/src/main/utils.js#L17-L27<CODESPLIT>tupleLessOrEqual<CODESPLIT>Compare two tuples of equal length . Is t1 < = t2? TODO : make this tupleLessOrEqual<T > -- it works with strings or booleans too .<CODESPLIT>function tupleLessOrEqual ( t1 : Array < number > , t2 : Array < number > ) : boolean { if ( t1 . length != t2 . length ) throw new Error ( 'Comparing non-equal length tuples' ) ; for ( var i = 0 ; i < t1 . length ; i ++ ) { if ( t1 [ i ] > t2 [ i ] ) { return false ; } else if ( t1 [ i ] < t2 [ i ] ) { return true ; } } return true ; }

0<CODESPLIT>https://github.com/Yodata/yodata-context/blob/39a499cd4129698a00139b47f3096884177e66f0/dist/yodata-context.js#L9768-L9774<CODESPLIT>hashString<CODESPLIT>Contributes additional methods to a constructor<CODESPLIT>function hashString ( string ) { // This is the hash from JVM // The hash code for a string is computed as // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1], // where s[i] is the ith character of the string and n is the length of // the string. We "mod" the result to make it between 0 (inclusive) and 2^31 // (exclusive) by dropping high bits. var hash = 0 ; for ( var ii = 0 ; ii < string . length ; ii ++ ) { hash = 31 * hash + string . charCodeAt ( ii ) | 0 ; } return smi ( hash ) ; }

1<CODESPLIT>https://github.com/Kolbaskin/yode-server/blob/55ab6680efcca9d298683eed7fc6a16933f10ace/static/ext/src/grid/column/Action.js#L337-L350<CODESPLIT><CODESPLIT>Disables this ActionColumn s action at the specified index .<CODESPLIT>function ( index , silent ) { var me = this ; if ( ! index ) { index = 0 ; } else if ( ! Ext . isNumber ( index ) ) { index = Ext . Array . indexOf ( me . items , index ) ; } me . items [ index ] . disabled = true ; me . up ( 'tablepanel' ) . el . select ( '.' + Ext . baseCSSPrefix + 'action-col-' + index ) . addCls ( me . disabledCls ) ; if ( ! silent ) { me . fireEvent ( 'disable' , me ) ; } }

0<CODESPLIT>https://github.com/Kolbaskin/yode-server/blob/55ab6680efcca9d298683eed7fc6a16933f10ace/modules/admin/model.js#L185-L187<CODESPLIT><CODESPLIT>    <CODESPLIT>function ( ) { Ext . data . flash . BinaryXhr . flashPluginActive = true ; Ext . data . flash . BinaryXhr . flashPlugin = document . getElementById ( "ext-flash-polyfill" ) ; Ext . globalEvents . fireEvent ( "flashready" ) ; // let all pending connections know }

0<CODESPLIT>https://github.com/runtimejs/runtime/blob/1955dbf3204e22bace7cfbbb6f52bb5d57a8c1e4/deps/v8/benchmarks/earley-boyer.js#L76-L82<CODESPLIT>sc_withHandlerLambda<CODESPLIT>* META (( export #t ))<CODESPLIT>function sc_withHandlerLambda ( handler , body ) { try { return body ( ) ; } catch ( e ) { if ( ! e . _internalException ) return handler ( e ) ; else throw e ; } }

0<CODESPLIT>https://github.com/yiminghe/async-validator/blob/08d67b8300153783fe61d542119baa84e51b4407/src/rule/enum.js#L16-L21<CODESPLIT>whitespace<CODESPLIT>Rule for validating a value exists in an enumerable list .<CODESPLIT>function whitespace ( rule , value , source , errors , options ) { if ( / ^\s+$ / . test ( value ) || value === '' ) { errors . push ( util . format ( options . messages . whitespace , rule . fullField ) ) ; } }

0<CODESPLIT>https://github.com/rochejul/gulp-angular-protractor/blob/5294436a0c0bf3626d9433cb48b568ae11ce9068/gulp-angular-protractor/web-driver.js#L67-L79<CODESPLIT>loadFiles<CODESPLIT>Execute the protractor engine<CODESPLIT>function loadFiles ( pattern , rootDir ) { // assert `pattern` is a valid glob (non-empty string) or array of globs var isString = typeof pattern === 'string' ; var isArray = Array . isArray ( pattern ) ; if ( ( ! isString && ! isArray ) || ( pattern . length === 0 ) ) { throw new TypeError ( 'A glob pattern or an array of glob patterns is required.' ) ; } // find all the gulpfiles - needs to happen synchronously so we create the tasks before gulp runs var filelist = resolveGlob ( pattern , rootDir ) . map ( function ( filename ) { return path . relative ( process . cwd ( ) , path . join ( rootDir , filename ) ) ; } ) ; var subfiles = getSubfiles ( filelist ) ; // load all the gulpfiles subfiles . forEach ( function ( subfile ) { util . log ( 'Loading' , util . colors . yellow ( subfile . relativePath ) ) ; loadSubfile ( subfile , tasks ) ; } ) ; }

1<CODESPLIT>https://github.com/ecomfe/okam/blob/9f460b0ac1ba0f8c061525e1e551353b312d588c/packages/okam-core/src/extend/data/observable/base.js#L97-L115<CODESPLIT>makeDataObservable<CODESPLIT>Make data observable<CODESPLIT>function makeDataObservable ( ctx ) { const data = ctx . data ; if ( ! data ) { return ; } if ( isPlainObject ( data ) ) { /* eslint-disable no-use-before-define */ let observer = new Observer ( ctx , data ) ; Object . defineProperties ( ctx , proxyObject ( observer , data , ctx ) ) ; return observer ; } let err = new Error ( 'data require plain object' ) ; err . isTypeError = true ; throw err ; }

