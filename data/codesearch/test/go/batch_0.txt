1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p * Pushy ) SubscribeToTopic ( deviceID string , topics ... string ) ( * SimpleSuccess , * Error , error ) { url := fmt . Sprintf ( " " , p . APIEndpoint , p . APIToken )   request := DeviceSubscriptionRequest { Token : deviceID , Topics : topics , }   var success * SimpleSuccess   var pushyErr * Error   err := post ( p . httpClient , url , request , & success , & pushyErr )   return success , pushyErr , err   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/xwb1989/sqlparser/blob/120387863bf27d04bc07db8015110a6e96d0146c/normalizer.go#L210-L224<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func GetBindvars ( stmt Statement ) map [ string ] struct { } { bindvars := make ( map [ string ] struct { } )   _ = Walk ( func ( node SQLNode ) ( kontinue bool , err error ) { switch node := node . ( type ) { case * SQLVal : if node . Type == ValArg { bindvars [ string ( node . Val [ 1 : ] ) ] = struct { } { }   }   case ListArg : bindvars [ string ( node [ 2 : ] ) ] = struct { } { }   }   return true , nil   } , stmt )   return bindvars   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/256dpi/fire/blob/fa66e74352b30b9a4c730f7b8dc773302941b0fb/ash/enforcer.go#L66-L73<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func WhitelistReadableFields ( fields ... string ) * Enforcer { return E ( " " , fire . Except ( fire . Delete , fire . ResourceAction , fire . CollectionAction ) , func ( ctx * fire . Context ) error { // set new list ctx . ReadableFields = fire . Intersect ( ctx . ReadableFields , fields )    return nil   } )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/llgcode/draw2d/blob/f52c8a71aff06ab8df41843d33ab167b36c971cd/draw2dpdf/gc.go#L159-L169<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( gc * GraphicContext ) CreateStringPath ( text string , x , y float64 ) ( cursor float64 ) { //fpdf uses the top left corner left , top , right , bottom := gc . GetStringBounds ( text )   w := right - left   h := bottom - top   // gc.pdf.SetXY(x, y-h) do not use this as y-h might be negative margin := gc . pdf . GetCellMargin ( )   gc . pdf . MoveTo ( x - left - margin , y + top )   gc . pdf . CellFormat ( w , h , text , " " , 0 , " " , false , 0 , " " )   return w   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/profiler/easyjson.go#L370-L374<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v TakeTypeProfileParams ) MarshalJSON ( ) ( [ ] byte , error ) { w := jwriter . Writer { }   easyjsonC5a4559bEncodeGithubComChromedpCdprotoProfiler3 ( & w , v )   return w . Buffer . BuildBytes ( ) , w . Error   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/api/nodecontainer.go#L33-L61<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func nodeContainerList ( w http . ResponseWriter , r * http . Request , t auth . Token ) error { pools , err := permission . ListContextValues ( t , permission . PermNodecontainerRead , true )   if err != nil { return err   }   lst , err := nodecontainer . AllNodeContainers ( )   if err != nil { return err   }   if pools != nil { poolMap := map [ string ] struct { } { }   for _ , p := range pools { poolMap [ p ] = struct { } { }   }   for i , entry := range lst { for poolName := range entry . ConfigPools { if poolName == " " { continue   }   if _ , ok := poolMap [ poolName ] ; ! ok { delete ( entry . ConfigPools , poolName )   }   }   lst [ i ] = entry   }   }   w . Header ( ) . Set ( " " , " " )   return json . NewEncoder ( w ) . Encode ( lst )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/cachestorage/cachestorage.go#L168-L171<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p RequestEntriesParams ) WithPathFilter ( pathFilter string ) * RequestEntriesParams { p . PathFilter = pathFilter   return & p   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/network/network.go#L623-L628<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func SearchInResponseBody ( requestID RequestID , query string ) * SearchInResponseBodyParams { return & SearchInResponseBodyParams { RequestID : requestID , Query : query , }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/profitbricks/profitbricks-sdk-go/blob/1d2db5f00bf5dd0b6c29273541c71c60cdf4d4d4/nic.go#L57-L64<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * Client ) CreateNic ( dcid string , srvid string , nic Nic ) ( * Nic , error ) { url := nicColPath ( dcid , srvid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty )   ret := & Nic { }   err := c . client . Post ( url , nic , ret , http . StatusAccepted )    return ret , err   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdctl/ctlv3/command/user_command.go#L123-L158<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func userAddCommandFunc ( cmd * cobra . Command , args [ ] string ) { if len ( args ) != 1 { ExitWithError ( ExitBadArgs , fmt . Errorf ( " " ) )   }    var password string   var user string    if passwordFromFlag != " " { user = args [ 0 ]   password = passwordFromFlag   } else { splitted := strings . SplitN ( args [ 0 ] , " " , 2 )   if len ( splitted ) < 2 { user = args [ 0 ]   if ! passwordInteractive { fmt . Scanf ( " " , & password )   } else { password = readPasswordInteractive ( args [ 0 ] )   }   } else { user = splitted [ 0 ]   password = splitted [ 1 ]   if len ( user ) == 0 { ExitWithError ( ExitBadArgs , fmt . Errorf ( " " ) )   }   }   }    resp , err := mustClientFromCmd ( cmd ) . Auth . UserAdd ( context . TODO ( ) , user , password )   if err != nil { ExitWithError ( ExitError , err )   }    display . UserAdd ( user , * resp )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/container_lxc.go#L8649-L8689<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * containerLXC ) setNetworkRoutes ( m types . Device ) error { if ! shared . PathExists ( fmt . Sprintf ( " " , m [ " " ] ) ) { return fmt . Errorf ( " " , m [ " " ] )   }    // Flush all IPv4 routes _ , err := shared . RunCommand ( " " , " " , " " , " " , " " , m [ " " ] , " " , " " )   if err != nil { return err   }    // Flush all IPv6 routes _ , err = shared . RunCommand ( " " , " " , " " , " " , " " , m [ " " ] , " " , " " )   if err != nil { return err   }    // Add additional IPv4 routes if m [ " " ] != " " { for _ , route := range strings . Split ( m [ " " ] , " " ) { route = strings . TrimSpace ( route )   _ , err := shared . RunCommand ( " " , " " , " " , " " , " " , m [ " " ] , route , " " , " " )   if err != nil { return err   }   }   }    // Add additional IPv6 routes if m [ " " ] != " " { for _ , route := range strings . Split ( m [ " " ] , " " ) { route = strings . TrimSpace ( route )   _ , err := shared . RunCommand ( " " , " " , " " , " " , " " , m [ " " ] , route , " " , " " )   if err != nil { return err   }   }   }    return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/github/reporter/reporter.go#L54-L72<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * Client ) ShouldReport ( pj * v1 . ProwJob ) bool { if ! pj . Spec . Report { // Respect report field return false   }    if pj . Spec . Type != v1 . PresubmitJob && pj . Spec . Type != v1 . PostsubmitJob { // Report presubmit and postsubmit github jobs for github reporter return false   }    if c . reportAgent != " " && pj . Spec . Agent != c . reportAgent { // Only report for specified agent return false   }    return true   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/network/network.go#L637-L640<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p SearchInResponseBodyParams ) WithIsRegex ( isRegex bool ) * SearchInResponseBodyParams { p . IsRegex = isRegex   return & p   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/webaudio/easyjson.go#L314-L318<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * EventContextCreated ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoWebaudio3 ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/clientv3/lease.go#L363-L398<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( l * lessor ) closeRequireLeader ( ) { l . mu . Lock ( )   defer l . mu . Unlock ( )   for _ , ka := range l . keepAlives { reqIdxs := 0   // find all required leader channels, close, mark as nil for i , ctx := range ka . ctxs { md , ok := metadata . FromOutgoingContext ( ctx )   if ! ok { continue   }   ks := md [ rpctypes . MetadataRequireLeaderKey ]   if len ( ks ) < 1 || ks [ 0 ] != rpctypes . MetadataHasLeader { continue   }   close ( ka . chs [ i ] )   ka . chs [ i ] = nil   reqIdxs ++   }   if reqIdxs == 0 { continue   }   // remove all channels that required a leader from keepalive newChs := make ( [ ] chan <- * LeaseKeepAliveResponse , len ( ka . chs ) - reqIdxs )   newCtxs := make ( [ ] context . Context , len ( newChs ) )   newIdx := 0   for i := range ka . chs { if ka . chs [ i ] == nil { continue   }   newChs [ newIdx ] , newCtxs [ newIdx ] = ka . chs [ i ] , ka . ctxs [ newIdx ]   newIdx ++   }   ka . chs , ka . ctxs = newChs , newCtxs   }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/cluster/config.go#L87-L90<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * Config ) AutoUpdateInterval ( ) time . Duration { n := c . m . GetInt64 ( " " )   return time . Duration ( n ) * time . Hour   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/containers/image/blob/da9ab3561ad2031aeb5e036b7cf2755d4e246fec/openshift/openshift-copies.go#L373-L421<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func validateAuthInfo ( authInfoName string , authInfo clientcmdAuthInfo ) [ ] error { var validationErrors [ ] error    usingAuthPath := false   methods := make ( [ ] string , 0 , 3 )   if len ( authInfo . Token ) != 0 { methods = append ( methods , " " )   }   if len ( authInfo . Username ) != 0 || len ( authInfo . Password ) != 0 { methods = append ( methods , " " )   }    if len ( authInfo . ClientCertificate ) != 0 || len ( authInfo . ClientCertificateData ) != 0 { // Make sure cert data and file aren't both specified if len ( authInfo . ClientCertificate ) != 0 && len ( authInfo . ClientCertificateData ) != 0 { validationErrors = append ( validationErrors , errors . Errorf ( " " , authInfoName ) )   }   // Make sure key data and file aren't both specified if len ( authInfo . ClientKey ) != 0 && len ( authInfo . ClientKeyData ) != 0 { validationErrors = append ( validationErrors , errors . Errorf ( " " , authInfoName ) )   }   // Make sure a key is specified if len ( authInfo . ClientKey ) == 0 && len ( authInfo . ClientKeyData ) == 0 { validationErrors = append ( validationErrors , errors . Errorf ( " " , authInfoName ) )   }    if len ( authInfo . ClientCertificate ) != 0 { clientCertFile , err := os . Open ( authInfo . ClientCertificate )   defer clientCertFile . Close ( )   if err != nil { validationErrors = append ( validationErrors , errors . Errorf ( " " , authInfo . ClientCertificate , authInfoName , err ) )   }   }   if len ( authInfo . ClientKey ) != 0 { clientKeyFile , err := os . Open ( authInfo . ClientKey )   defer clientKeyFile . Close ( )   if err != nil { validationErrors = append ( validationErrors , errors . Errorf ( " " , authInfo . ClientKey , authInfoName , err ) )   }   }   }    // authPath also provides information for the client to identify the server, so allow multiple auth methods in that case if ( len ( methods ) > 1 ) && ( ! usingAuthPath ) { validationErrors = append ( validationErrors , errors . Errorf ( " " , authInfoName , methods ) )   }    return validationErrors   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/provision/kubernetes/pkg/client/clientset/versioned/typed/tsuru/v1/fake/fake_app.go#L63-L67<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * FakeApps ) Watch ( opts v1 . ListOptions ) ( watch . Interface , error ) { return c . Fake . InvokesWatch ( testing . NewWatchAction ( appsResource , c . ns , opts ) )    }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/deploy/cmds/cmds.go#L149-L661<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func deployCmds ( noMetrics * bool , noPortForwarding * bool ) [ ] * cobra . Command { var commands [ ] * cobra . Command   var opts * assets . AssetOpts    var dryRun bool   var outputFormat string    var dev bool   var hostPath string   deployLocal := & cobra . Command { Short : " " , Long : " " , Run : cmdutil . RunFixedArgs ( 0 , func ( args [ ] string ) ( retErr error ) { metrics := ! * noMetrics    if metrics && ! dev { start := time . Now ( )   startMetricsWait := _metrics . StartReportAndFlushUserAction ( " " , start )   defer startMetricsWait ( )   defer func ( ) { finishMetricsWait := _metrics . FinishReportAndFlushUserAction ( " " , retErr , start )   finishMetricsWait ( )   } ( )   }   manifest := getEncoder ( outputFormat )   if dev { // Use dev build instead of release build opts . Version = deploy . DevVersionTag    // we turn metrics off this is a dev cluster. The default is set by // deploy.PersistentPreRun, below. opts . Metrics = false    // Disable authentication, for tests opts . DisableAuthentication = true    // Serve the Pachyderm object/block API locally, as this is needed by // our tests (and authentication is disabled anyway) opts . ExposeObjectAPI = true   }   if err := assets . WriteLocalAssets ( manifest , opts , hostPath ) ; err != nil { return err   }   return kubectlCreate ( dryRun , manifest , opts , metrics )   } ) , }   deployLocal . Flags ( ) . StringVar ( & hostPath , " " , " " , " " )   deployLocal . Flags ( ) . BoolVarP ( & dev , " " , " " , false , " " )   commands = append ( commands , cmdutil . CreateAlias ( deployLocal , " " ) )    deployGoogle := & cobra . Command { Use : " " , Short : " " , Long : `Deploy a Pachyderm cluster running on Google Cloud Platform.   <bucket-name>: A Google Cloud Storage bucket where Pachyderm will store PFS data.   <disk-size>: Size of Google Compute Engine persistent disks in GB (assumed to all be the same).   <credentials-file>: A file containing the private key for the account (downloaded from Google Compute Engine).` , Run : cmdutil . RunBoundedArgs ( 2 , 3 , func ( args [ ] string ) ( retErr error ) { metrics := ! * noMetrics    if metrics { start := time . Now ( )   startMetricsWait := _metrics . StartReportAndFlushUserAction ( " " , start )   defer startMetricsWait ( )   defer func ( ) { finishMetricsWait := _metrics . FinishReportAndFlushUserAction ( " " , retErr , start )   finishMetricsWait ( )   } ( )   }   volumeSize , err := strconv . Atoi ( args [ 1 ] )   if err != nil { return fmt . Errorf ( " " , args [ 1 ] )   }   manifest := getEncoder ( outputFormat )   opts . BlockCacheSize = " " // GCS is fast so we want to disable the block cache. See issue #1650   var cred string   if len ( args ) == 3 { credBytes , err := ioutil . ReadFile ( args [ 2 ] )   if err != nil { return fmt . Errorf ( " " , args [ 2 ] , err )   }   cred = string ( credBytes )   }   bucket := strings . TrimPrefix ( args [ 0 ] , " " )   if err = assets . WriteGoogleAssets ( manifest , opts , bucket , cred , volumeSize ) ; err != nil { return err   }   return kubectlCreate ( dryRun , manifest , opts , metrics )   } ) , }   commands = append ( commands , cmdutil . CreateAlias ( deployGoogle , " " ) )    var objectStoreBackend string   var persistentDiskBackend string   var secure bool   var isS3V2 bool   deployCustom := & cobra . Command { Use : " " , Short : " " , Long : `Deploy a custom Pachyderm cluster configuration. If <object store backend> is \"s3\", then the arguments are:     <volumes> <size of volumes (in GB)> <bucket> <id> <secret> <endpoint>` , Run : cmdutil . RunBoundedArgs ( 4 , 7 , func ( args [ ] string ) ( retErr error ) { metrics := ! * noMetrics    if metrics { start := time . Now ( )   startMetricsWait := _metrics . StartReportAndFlushUserAction ( " " , start )   defer startMetricsWait ( )   defer func ( ) { finishMetricsWait := _metrics . FinishReportAndFlushUserAction ( " " , retErr , start )   finishMetricsWait ( )   } ( )   }   manifest := getEncoder ( outputFormat )   err := assets . WriteCustomAssets ( manifest , opts , args , objectStoreBackend , persistentDiskBackend , secure , isS3V2 )   if err != nil { return err   }   return kubectlCreate ( dryRun , manifest , opts , metrics )   } ) , }   deployCustom . Flags ( ) . BoolVarP ( & secure , " " , " " , false , " " )   deployCustom . Flags ( ) . StringVar ( & persistentDiskBackend , " " , " " , " " + " " )   deployCustom . Flags ( ) . StringVar ( & objectStoreBackend , " " , " " , " " + " " )   deployCustom . Flags ( ) . BoolVar ( & isS3V2 , " " , false , " " )   commands = append ( commands , cmdutil . CreateAlias ( deployCustom , " " ) )    var cloudfrontDistribution string   var creds string   var iamRole string   var vault string   deployAmazon := & cobra . Command { Use : " " , Short : " " , Long : `Deploy a Pachyderm cluster running on AWS.   <bucket-name>: An S3 bucket where Pachyderm will store PFS data.   <region>: The AWS region where Pachyderm is being deployed (e.g. us-west-1)   <disk-size>: Size of EBS volumes, in GB (assumed to all be the same).` , Run : cmdutil . RunFixedArgs ( 3 , func ( args [ ] string ) ( retErr error ) { metrics := ! * noMetrics    if metrics { start := time . Now ( )   startMetricsWait := _metrics . StartReportAndFlushUserAction ( " " , start )   defer startMetricsWait ( )   defer func ( ) { finishMetricsWait := _metrics . FinishReportAndFlushUserAction ( " " , retErr , start )   finishMetricsWait ( )   } ( )   }   if creds == " " && vault == " " && iamRole == " " { return fmt . Errorf ( " " )   }    // populate 'amazonCreds' & validate var amazonCreds * assets . AmazonCreds   s := bufio . NewScanner ( os . Stdin )   if creds != " " { parts := strings . Split ( creds , " " )   if len ( parts ) < 2 || len ( parts ) > 3 || containsEmpty ( parts [ : 2 ] ) { return fmt . Errorf ( " " )   }   amazonCreds = & assets . AmazonCreds { ID : parts [ 0 ] , Secret : parts [ 1 ] }   if len ( parts ) > 2 { amazonCreds . Token = parts [ 2 ]   }    if ! awsAccessKeyIDRE . MatchString ( amazonCreds . ID ) { fmt . Printf ( " " + " \n " , awsAccessKeyIDRE )   if s . Scan ( ) ; s . Text ( ) [ 0 ] != 'y' && s . Text ( ) [ 0 ] != 'Y' { os . Exit ( 1 )   }   }    if ! awsSecretRE . MatchString ( amazonCreds . Secret ) { fmt . Printf ( " " + " \n " , awsSecretRE )   if s . Scan ( ) ; s . Text ( ) [ 0 ] != 'y' && s . Text ( ) [ 0 ] != 'Y' { os . Exit ( 1 )   }   }   }   if vault != " " { if amazonCreds != nil { return fmt . Errorf ( " " )   }   parts := strings . Split ( vault , " " )   if len ( parts ) != 3 || containsEmpty ( parts ) { return fmt . Errorf ( " " )   }   amazonCreds = & assets . AmazonCreds { VaultAddress : parts [ 0 ] , VaultRole : parts [ 1 ] , VaultToken : parts [ 2 ] }   }   if iamRole != " " { if amazonCreds != nil { return fmt . Errorf ( " " )   }   opts . IAMRole = iamRole   }   volumeSize , err := strconv . Atoi ( args [ 2 ] )   if err != nil { return fmt . Errorf ( " " , args [ 2 ] )   }   if strings . TrimSpace ( cloudfrontDistribution ) != " " { fmt . Printf ( " " + " \n " )   }   bucket , region := strings . TrimPrefix ( args [ 0 ] , " " ) , args [ 1 ]   if ! awsRegionRE . MatchString ( region ) { fmt . Printf ( " " + " \n " , awsRegionRE )   if s . Scan ( ) ; s . Text ( ) [ 0 ] != 'y' && s . Text ( ) [ 0 ] != 'Y' { os . Exit ( 1 )   }   }    // generate manifest and write assets manifest := getEncoder ( outputFormat )   if err = assets . WriteAmazonAssets ( manifest , opts , region , bucket , volumeSize , amazonCreds , cloudfrontDistribution ) ; err != nil { return err   }   return kubectlCreate ( dryRun , manifest , opts , metrics )   } ) , }   deployAmazon . Flags ( ) . StringVar ( & cloudfrontDistribution , " " , " " , " " + " " + " " )   deployAmazon . Flags ( ) . StringVar ( & creds , " " , " " , " \" \" \" \" " )   deployAmazon . Flags ( ) . StringVar ( & vault , " " , " " , " \" \" " )   deployAmazon . Flags ( ) . StringVar ( & iamRole , " " , " " , fmt . Sprintf ( " " , assets . IAMAnnotation ) )   commands = append ( commands , cmdutil . CreateAlias ( deployAmazon , " " ) )    deployMicrosoft := & cobra . Command { Use : " " , Short : " " , Long : `Deploy a Pachyderm cluster running on Microsoft Azure.   <container>: An Azure container where Pachyderm will store PFS data.   <disk-size>: Size of persistent volumes, in GB (assumed to all be the same).` , Run : cmdutil . RunFixedArgs ( 4 , func ( args [ ] string ) ( retErr error ) { metrics := ! * noMetrics    if metrics { start := time . Now ( )   startMetricsWait := _metrics . StartReportAndFlushUserAction ( " " , start )   defer startMetricsWait ( )   defer func ( ) { finishMetricsWait := _metrics . FinishReportAndFlushUserAction ( " " , retErr , start )   finishMetricsWait ( )   } ( )   }   if _ , err := base64 . StdEncoding . DecodeString ( args [ 2 ] ) ; err != nil { return fmt . Errorf ( " " , args [ 2 ] )   }   if opts . EtcdVolume != " " { tempURI , err := url . ParseRequestURI ( opts . EtcdVolume )   if err != nil { return fmt . Errorf ( " " , opts . EtcdVolume )   }   opts . EtcdVolume = tempURI . String ( )   }   volumeSize , err := strconv . Atoi ( args [ 3 ] )   if err != nil { return fmt . Errorf ( " " , args [ 3 ] )   }   manifest := getEncoder ( outputFormat )   container := strings . TrimPrefix ( args [ 0 ] , " " )   accountName , accountKey := args [ 1 ] , args [ 2 ]   if err = assets . WriteMicrosoftAssets ( manifest , opts , container , accountName , accountKey , volumeSize ) ; err != nil { return err   }   return kubectlCreate ( dryRun , manifest , opts , metrics )   } ) , }   commands = append ( commands , cmdutil . CreateAlias ( deployMicrosoft , " " ) )    deployStorageSecrets := func ( data map [ string ] [ ] byte ) error { c , err := client . NewOnUserMachine ( ! * noMetrics , ! * noPortForwarding , " " )   if err != nil { return fmt . Errorf ( " " , err )   }   defer c . Close ( )    _ , err = c . DeployStorageSecret ( context . Background ( ) , & deployclient . DeployStorageSecretRequest { Secrets : data , } )   if err != nil { return fmt . Errorf ( " " , err )   }   return nil   }    deployStorageAmazon := & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . RunBoundedArgs ( 3 , 4 , func ( args [ ] string ) error { var token string   if len ( args ) == 4 { token = args [ 3 ]   }   return deployStorageSecrets ( assets . AmazonSecret ( args [ 0 ] , " " , args [ 1 ] , args [ 2 ] , token , " " ) )   } ) , }   commands = append ( commands , cmdutil . CreateAlias ( deployStorageAmazon , " " ) )    deployStorageGoogle := & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . RunFixedArgs ( 1 , func ( args [ ] string ) error { credBytes , err := ioutil . ReadFile ( args [ 0 ] )   if err != nil { return fmt . Errorf ( " " , args [ 0 ] , err )   }   return deployStorageSecrets ( assets . GoogleSecret ( " " , string ( credBytes ) ) )   } ) , }   commands = append ( commands , cmdutil . CreateAlias ( deployStorageGoogle , " " ) )    deployStorageAzure := & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . RunFixedArgs ( 2 , func ( args [ ] string ) error { return deployStorageSecrets ( assets . MicrosoftSecret ( " " , args [ 0 ] , args [ 1 ] ) )   } ) , }   commands = append ( commands , cmdutil . CreateAlias ( deployStorageAzure , " " ) )    deployStorage := & cobra . Command { Short : " " , Long : " " , }   commands = append ( commands , cmdutil . CreateAlias ( deployStorage , " " ) )    listImages := & cobra . Command { Short : " " , Long : " " , Run : cmdutil . RunFixedArgs ( 0 , func ( args [ ] string ) error { for _ , image := range assets . Images ( opts ) { fmt . Println ( image )   }   return nil   } ) , }   commands = append ( commands , cmdutil . CreateAlias ( listImages , " " ) )    exportImages := & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . RunFixedArgs ( 1 , func ( args [ ] string ) ( retErr error ) { file , err := os . Create ( args [ 0 ] )   if err != nil { return err   }   defer func ( ) { if err := file . Close ( ) ; err != nil && retErr == nil { retErr = err   }   } ( )   return images . Export ( opts , file )   } ) , }   commands = append ( commands , cmdutil . CreateAlias ( exportImages , " " ) )    importImages := & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . RunFixedArgs ( 1 , func ( args [ ] string ) ( retErr error ) { file , err := os . Open ( args [ 0 ] )   if err != nil { return err   }   defer func ( ) { if err := file . Close ( ) ; err != nil && retErr == nil { retErr = err   }   } ( )   return images . Import ( opts , file )   } ) , }   commands = append ( commands , cmdutil . CreateAlias ( importImages , " " ) )    var blockCacheSize string   var dashImage string   var dashOnly bool   var etcdCPURequest string   var etcdMemRequest string   var etcdNodes int   var etcdStorageClassName string   var etcdVolume string   var exposeObjectAPI bool   var imagePullSecret string   var localRoles bool   var logLevel string   var namespace string   var newHashTree bool   var noDash bool   var noExposeDockerSocket bool   var noGuaranteed bool   var noRBAC bool   var pachdCPURequest string   var pachdNonCacheMemRequest string   var pachdShards int   var registry string   var tlsCertKey string   deploy := & cobra . Command { Short : " " , Long : " " , PersistentPreRun : cmdutil . Run ( func ( [ ] string ) error { dashImage = getDefaultOrLatestDashImage ( dashImage , dryRun )   opts = & assets . AssetOpts { FeatureFlags : assets . FeatureFlags { NewHashTree : newHashTree , } , PachdShards : uint64 ( pachdShards ) , Version : version . PrettyPrintVersion ( version . Version ) , LogLevel : logLevel , Metrics : ! * noMetrics , PachdCPURequest : pachdCPURequest , PachdNonCacheMemRequest : pachdNonCacheMemRequest , BlockCacheSize : blockCacheSize , EtcdCPURequest : etcdCPURequest , EtcdMemRequest : etcdMemRequest , EtcdNodes : etcdNodes , EtcdVolume : etcdVolume , EtcdStorageClassName : etcdStorageClassName , DashOnly : dashOnly , NoDash : noDash , DashImage : dashImage , Registry : registry , ImagePullSecret : imagePullSecret , NoGuaranteed : noGuaranteed , NoRBAC : noRBAC , LocalRoles : localRoles , Namespace : namespace , NoExposeDockerSocket : noExposeDockerSocket , ExposeObjectAPI : exposeObjectAPI , }   if tlsCertKey != " " { // TODO(msteffen): If either the cert path or the key path contains a // comma, this doesn't work certKey := strings . Split ( tlsCertKey , " " )   if len ( certKey ) != 2 { return fmt . Errorf ( " " , certKey )   }   opts . TLS = & assets . TLSOpts { ServerCert : certKey [ 0 ] , ServerKey : certKey [ 1 ] , }   }   return nil   } ) , }   deploy . PersistentFlags ( ) . IntVar ( & pachdShards , " " , 16 , " " )   deploy . PersistentFlags ( ) . IntVar ( & etcdNodes , " " , 0 , " " )   deploy . PersistentFlags ( ) . StringVar ( & etcdVolume , " " , " " , " " )   deploy . PersistentFlags ( ) . StringVar ( & etcdStorageClassName , " " , " " , " " )   deploy . PersistentFlags ( ) . BoolVar ( & dryRun , " " , false , " " )   deploy . PersistentFlags ( ) . StringVarP ( & outputFormat , " " , " " , " " , " " )   deploy . PersistentFlags ( ) . StringVar ( & logLevel , " " , " " , " \" \" \" \" \" \" " )   deploy . PersistentFlags ( ) . BoolVar ( & dashOnly , " " , false , " \" \" " )   deploy . PersistentFlags ( ) . BoolVar ( & noDash , " " , false , " " )   deploy . PersistentFlags ( ) . StringVar ( & registry , " " , " " , " " )   deploy . PersistentFlags ( ) . StringVar ( & imagePullSecret , " " , " " , " " )   deploy . PersistentFlags ( ) . StringVar ( & dashImage , " " , " " , " " )   deploy . PersistentFlags ( ) . BoolVar ( & noGuaranteed , " " , false , " " )   deploy . PersistentFlags ( ) . BoolVar ( & noRBAC , " " , false , " " )   deploy . PersistentFlags ( ) . BoolVar ( & localRoles , " " , false , " " )   deploy . PersistentFlags ( ) . StringVar ( & namespace , " " , " " , " " )   deploy . PersistentFlags ( ) . BoolVar ( & noExposeDockerSocket , " " , false , " " )   deploy . PersistentFlags ( ) . BoolVar ( & exposeObjectAPI , " " , false , " " )   deploy . PersistentFlags ( ) . StringVar ( & tlsCertKey , " " , " " , " \" \" " )   deploy . PersistentFlags ( ) . BoolVar ( & newHashTree , " " , false , " " )    // Flags for setting pachd resource requests. These should rarely be set -- // only if we get the defaults wrong, or users have an unusual access pattern // // All of these are empty by default, because the actual default values depend // on the backend to which we're. The defaults are set in // s/s/pkg/deploy/assets/assets.go deploy . PersistentFlags ( ) . StringVar ( & pachdCPURequest , " " , " " , " " + " " + " " )   deploy . PersistentFlags ( ) . StringVar ( & blockCacheSize , " " , " " , " " + " " )   deploy . PersistentFlags ( ) . StringVar ( & pachdNonCacheMemRequest , " " , " " , " " + " " + " " )   deploy . PersistentFlags ( ) . StringVar ( & etcdCPURequest , " " , " " , " " + " " + " " )   deploy . PersistentFlags ( ) . StringVar ( & etcdMemRequest , " " , " " , " " + " " + " " )    commands = append ( commands , cmdutil . CreateAlias ( deploy , " " ) )    return commands   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/qor/render/blob/63566e46f01b134ae9882a59a06518e82a903231/assetfs/filesystem.go#L55-L62<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( fs * AssetFileSystem ) Asset ( name string ) ( [ ] byte , error ) { for _ , pth := range fs . paths { if _ , err := os . Stat ( filepath . Join ( pth , name ) ) ; err == nil { return ioutil . ReadFile ( filepath . Join ( pth , name ) )   }   }   return [ ] byte { } , fmt . Errorf ( " " , name )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/fragmenting_reader.go#L105-L110<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( r * fragmentingReader ) ArgReader ( last bool ) ( ArgReader , error ) { if err := r . BeginArgument ( last ) ; err != nil { return nil , err   }   return r , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/shared/logging/log_posix.go#L10-L24<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func getSystemHandler ( syslog string , debug bool , format log . Format ) log . Handler { // SyslogHandler if syslog != " " { if ! debug { return log . LvlFilterHandler ( log . LvlInfo , log . Must . SyslogHandler ( syslog , format ) , )   }    return log . Must . SyslogHandler ( syslog , format )   }    return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/images.go#L538-L545<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * Cluster ) ImageDelete ( id int ) error { err := exec ( c . db , " " , id )   if err != nil { return err   }    return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/janos/web/blob/0fb0203103deb84424510a8d5166ac00700f2b0e/minifier/minifier.go#L45-L53<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func NewHandler ( h http . Handler , logFunc LogFunc ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { mw := & minifyResponseWriter { mw : minifier . ResponseWriter ( w , r ) , w : w }   h . ServeHTTP ( mw , r )   if err := mw . Close ( ) ; err != nil && err != minify . ErrNotExist && logFunc != nil { logFunc ( " " , r . URL . String ( ) , err )   }   } )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/pantheon-systems/go-certauth/blob/8764720d23a5034dd9fab090815b7859463c68f6/certauth.go#L108-L118<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( a * Auth ) RouterHandler ( h httprouter . Handle ) httprouter . Handle { return httprouter . Handle ( func ( w http . ResponseWriter , r * http . Request , ps httprouter . Params ) { // Let secure process the request. If it returns an error, // that indicates the request should not continue. if err := a . Process ( w , r ) ; err != nil { return   }    h ( w , r , ps )   } )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/api/v2store/node.go#L153-L167<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( n * node ) List ( ) ( [ ] * node , * v2error . Error ) { if ! n . IsDir ( ) { return nil , v2error . NewError ( v2error . EcodeNotDir , " " , n . store . CurrentIndex )   }    nodes := make ( [ ] * node , len ( n . Children ) )    i := 0   for _ , node := range n . Children { nodes [ i ] = node   i ++   }    return nodes , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/taskcluster/taskcluster-client-go/blob/ef6acd428ae5844a933792ed6479d0e7dca61ef8/tcqueue/tcqueue.go#L977-L981<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( queue * Queue ) GetWorker ( provisionerId , workerType , workerGroup , workerId string ) ( * WorkerResponse , error ) { cd := tcclient . Client ( * queue )   responseObject , _ , err := ( & cd ) . APICall ( nil , " " , " " + url . QueryEscape ( provisionerId ) + " " + url . QueryEscape ( workerType ) + " " + url . QueryEscape ( workerGroup ) + " " + url . QueryEscape ( workerId ) , new ( WorkerResponse ) , nil )   return responseObject . ( * WorkerResponse ) , err   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/security/types.go#L167-L177<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( t * CertificateErrorAction ) UnmarshalEasyJSON ( in * jlexer . Lexer ) { switch CertificateErrorAction ( in . String ( ) ) { case CertificateErrorActionContinue : * t = CertificateErrorActionContinue   case CertificateErrorActionCancel : * t = CertificateErrorActionCancel    default : in . AddError ( errors . New ( " " ) )   }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/boskos/ranch/storage.go#L195-L212<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ParseConfig ( configPath string ) ( [ ] common . Resource , error ) { file , err := ioutil . ReadFile ( configPath )   if err != nil { return nil , err   }    var data common . BoskosConfig   err = yaml . Unmarshal ( file , & data )   if err != nil { return nil , err   }    var resources [ ] common . Resource   for _ , entry := range data . Resources { resources = append ( resources , common . NewResourcesFromConfig ( entry ) ... )   }   return resources , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/css/easyjson.go#L1459-L1463<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v SetStyleTextsParams ) MarshalJSON ( ) ( [ ] byte , error ) { w := jwriter . Writer { }   easyjsonC5a4559bEncodeGithubComChromedpCdprotoCss12 ( & w , v )   return w . Buffer . BuildBytes ( ) , w . Error   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/storage/easyjson.go#L656-L660<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * EventIndexedDBListUpdated ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoStorage7 ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/jpillora/velox/blob/42845d32322027cde41ba6b065a083ea4120238f/go/conn.go#L76-L123<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * conn ) connect ( w http . ResponseWriter , r * http . Request ) error { //choose transport if r . Header . Get ( " " ) == " " { c . transport = & eventSourceTransport { writeTimeout : c . state . WriteTimeout }   } else if r . Header . Get ( " " ) == " " { c . transport = & websocketsTransport { writeTimeout : c . state . WriteTimeout }   } else { return fmt . Errorf ( " " )   }   //non-blocking connect to client over set transport if err := c . transport . connect ( w , r ) ; err != nil { return err   }   //initial ping if err := c . send ( & update { Ping : true } ) ; err != nil { return fmt . Errorf ( " " )   }   //successfully connected c . connected = true   c . waiter . Add ( 1 )   //while connected, ping loop (every 25s, browser timesout after 30s) go func ( ) { for { select { case <- time . After ( c . state . PingInterval ) : if err := c . send ( & update { Ping : true } ) ; err != nil { goto disconnected   }   case <- c . connectedCh : goto disconnected   }   }   disconnected : c . connected = false   c . Close ( )   //unblock waiters c . waiter . Done ( )   } ( )   //non-blocking wait on connection go func ( ) { if err := c . transport . wait ( ) ; err != nil { //log error? }   close ( c . connectedCh )   } ( )   //now connected, consumer can connection.Wait() return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/boskos/client/client.go#L308-L310<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * Client ) Metric ( rtype string ) ( common . Metric , error ) { return c . metric ( rtype )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/css/easyjson.go#L5978-L5982<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * EventStyleSheetAdded ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoCss53 ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/github/fakegithub/fakegithub.go#L213-L215<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( f * FakeClient ) GetPullRequestChanges ( org , repo string , number int ) ( [ ] github . PullRequestChange , error ) { return f . PullRequestChanges [ number ] , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/containers/image/blob/da9ab3561ad2031aeb5e036b7cf2755d4e246fec/storage/storage_image.go#L183-L213<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( s * storageImageSource ) GetManifest ( ctx context . Context , instanceDigest * digest . Digest ) ( manifestBlob [ ] byte , MIMEType string , err error ) { if instanceDigest != nil { return nil , " " , ErrNoManifestLists   }   if len ( s . cachedManifest ) == 0 { // The manifest is stored as a big data item. // Prefer the manifest corresponding to the user-specified digest, if available. if s . imageRef . named != nil { if digested , ok := s . imageRef . named . ( reference . Digested ) ; ok { key := manifestBigDataKey ( digested . Digest ( ) )   blob , err := s . imageRef . transport . store . ImageBigData ( s . image . ID , key )   if err != nil && ! os . IsNotExist ( err ) { // os.IsNotExist is true if the image exists but there is no data corresponding to key return nil , " " , err   }   if err == nil { s . cachedManifest = blob   }   }   }   // If the user did not specify a digest, or this is an old image stored before manifestBigDataKey was introduced, use the default manifest. // Note that the manifest may not match the expected digest, and that is likely to fail eventually, e.g. in c/image/image/UnparsedImage.Manifest(). if len ( s . cachedManifest ) == 0 { cachedBlob , err := s . imageRef . transport . store . ImageBigData ( s . image . ID , storage . ImageDigestBigDataKey )   if err != nil { return nil , " " , err   }   s . cachedManifest = cachedBlob   }   }   return s . cachedManifest , manifest . GuessMIMEType ( s . cachedManifest ) , err   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/dom/dom.go#L1235-L1237<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p * SetAttributeValueParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetAttributeValue , p , nil )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/velodrome/transform/plugins/comment_counter.go#L40-L49<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * CommentCounterPlugin ) CheckFlags ( ) error { for _ , pattern := range c . pattern { matcher , err := regexp . Compile ( pattern )   if err != nil { return err   }   c . matcher = append ( c . matcher , matcher )   }   return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/weaveworks/mesh/blob/512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39/routes.go#L50-L54<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( r * routes ) OnChange ( callback func ( ) ) { r . Lock ( )   defer r . Unlock ( )   r . onChange = append ( r . onChange , callback )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/shared/idmap/shift_linux.go#L171-L183<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func GetCaps ( path string ) ( [ ] byte , error ) { xattrs , err := shared . GetAllXattr ( path )   if err != nil { return nil , err   }    valueStr , ok := xattrs [ " " ]   if ! ok { return nil , nil   }    return [ ] byte ( valueStr ) , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/gobuffalo/buffalo/blob/7f360181f4ccd79dcc9dcea2c904a4801f194f04/route_mappings.go#L234-L241<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( a * App ) RouteHelpers ( ) map [ string ] RouteHelperFunc { rh := map [ string ] RouteHelperFunc { }   for _ , route := range a . Routes ( ) { cRoute := route   rh [ cRoute . PathName ] = cRoute . BuildPathHelper ( )   }   return rh   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L5965-L5968<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( e ErrorCode ) String ( ) string { name , _ := errorCodeMap [ int32 ( e ) ]   return name   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/gobuffalo/buffalo/blob/7f360181f4ccd79dcc9dcea2c904a4801f194f04/mail/message.go#L87-L95<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( m * Message ) AddEmbedded ( name string , r io . Reader ) error { m . Attachments = append ( m . Attachments , Attachment { Name : name , Reader : r , Embedded : true , } )    return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/page/easyjson.go#L7095-L7099<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v CaptureSnapshotParams ) MarshalJSON ( ) ( [ ] byte , error ) { w := jwriter . Writer { }   easyjsonC5a4559bEncodeGithubComChromedpCdprotoPage78 ( & w , v )   return w . Buffer . BuildBytes ( ) , w . Error   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/deploy/assets/assets.go#L897-L922<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func EtcdNodePortService ( local bool , opts * AssetOpts ) * v1 . Service { var clientNodePort int32   if local { clientNodePort = 32379   }   return & v1 . Service { TypeMeta : metav1 . TypeMeta { Kind : " " , APIVersion : " " , } , ObjectMeta : objectMeta ( etcdName , labels ( etcdName ) , nil , opts . Namespace ) , Spec : v1 . ServiceSpec { Type : v1 . ServiceTypeNodePort , Selector : map [ string ] string { " " : etcdName , } , Ports : [ ] v1 . ServicePort { { Port : 2379 , Name : " " , NodePort : clientNodePort , } , } , } , }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kr/s3/blob/c070c8f9a8f0032d48f0d2a77d4e382788bd8a1d/sign.go#L98-L107<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( s * Service ) Sign ( r * http . Request , k Keys ) { if k . SecurityToken != " " { r . Header . Set ( " " , k . SecurityToken )   }   h := hmac . New ( sha1 . New , [ ] byte ( k . SecretKey ) )   s . writeSigData ( h , r )   sig := make ( [ ] byte , base64 . StdEncoding . EncodedLen ( h . Size ( ) ) )   base64 . StdEncoding . Encode ( sig , h . Sum ( nil ) )   r . Header . Set ( " " , " " + k . AccessKey + " " + string ( sig ) )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/browser/easyjson.go#L1475-L1479<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v GetBrowserCommandLineReturns ) MarshalJSON ( ) ( [ ] byte , error ) { w := jwriter . Writer { }   easyjsonC5a4559bEncodeGithubComChromedpCdprotoBrowser15 ( & w , v )   return w . Buffer . BuildBytes ( ) , w . Error   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/overlay/easyjson.go#L1590-L1594<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v GetHighlightObjectForTestReturns ) MarshalJSON ( ) ( [ ] byte , error ) { w := jwriter . Writer { }   easyjsonC5a4559bEncodeGithubComChromedpCdprotoOverlay15 ( & w , v )   return w . Buffer . BuildBytes ( ) , w . Error   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/network/easyjson.go#L7034-L7038<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v EventLoadingFailed ) MarshalJSON ( ) ( [ ] byte , error ) { w := jwriter . Writer { }   easyjsonC5a4559bEncodeGithubComChromedpCdprotoNetwork54 ( & w , v )   return w . Buffer . BuildBytes ( ) , w . Error   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/nwaples/rardecode/blob/197ef08ef68c4454ae5970a9c2692d6056ceb8d7/decrypt_reader.go#L61-L84<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( cr * cipherBlockReader ) Read ( p [ ] byte ) ( n int , err error ) { for { if cr . n < len ( cr . outbuf ) { // return buffered output n = copy ( p , cr . outbuf [ cr . n : ] )   cr . n += n   return n , nil   }   if cr . err != nil { err = cr . err   cr . err = nil   return 0 , err   }   if len ( p ) >= cap ( cr . outbuf ) { break   }   // p is not large enough to process a block, use outbuf instead n , cr . err = cr . read ( cr . outbuf [ : cap ( cr . outbuf ) ] )   cr . outbuf = cr . outbuf [ : n ]   cr . n = 0   }   // read blocks into p return cr . read ( p )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/css/easyjson.go#L2824-L2828<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * Rule ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoCss25 ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/pandemicsyn/oort/blob/fca1d3baddc1d944387cc8bbe8b21f911ec9091b/api/valuestore_GEN_.go#L44-L97<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func NewValueStore ( addr string , concurrency int , ftlsConfig * ftls . Config , opts ... grpc . DialOption ) ( store . ValueStore , error ) { stor := & valueStore { addr : addr , ftlsc : ftlsConfig , opts : opts , handlersDoneChan : make ( chan struct { } ) , }    stor . pendingLookupReqChan = make ( chan * asyncValueLookupRequest , concurrency )   stor . freeLookupReqChan = make ( chan * asyncValueLookupRequest , concurrency )   stor . freeLookupResChan = make ( chan * asyncValueLookupResponse , concurrency )   for i := 0 ; i < cap ( stor . freeLookupReqChan ) ; i ++ { stor . freeLookupReqChan <- & asyncValueLookupRequest { resChan : make ( chan * asyncValueLookupResponse , 1 ) }   }   for i := 0 ; i < cap ( stor . freeLookupResChan ) ; i ++ { stor . freeLookupResChan <- & asyncValueLookupResponse { }   }   go stor . handleLookupStream ( )    stor . pendingReadReqChan = make ( chan * asyncValueReadRequest , concurrency )   stor . freeReadReqChan = make ( chan * asyncValueReadRequest , concurrency )   stor . freeReadResChan = make ( chan * asyncValueReadResponse , concurrency )   for i := 0 ; i < cap ( stor . freeReadReqChan ) ; i ++ { stor . freeReadReqChan <- & asyncValueReadRequest { resChan : make ( chan * asyncValueReadResponse , 1 ) }   }   for i := 0 ; i < cap ( stor . freeReadResChan ) ; i ++ { stor . freeReadResChan <- & asyncValueReadResponse { }   }   go stor . handleReadStream ( )    stor . pendingWriteReqChan = make ( chan * asyncValueWriteRequest , concurrency )   stor . freeWriteReqChan = make ( chan * asyncValueWriteRequest , concurrency )   stor . freeWriteResChan = make ( chan * asyncValueWriteResponse , concurrency )   for i := 0 ; i < cap ( stor . freeWriteReqChan ) ; i ++ { stor . freeWriteReqChan <- & asyncValueWriteRequest { resChan : make ( chan * asyncValueWriteResponse , 1 ) }   }   for i := 0 ; i < cap ( stor . freeWriteResChan ) ; i ++ { stor . freeWriteResChan <- & asyncValueWriteResponse { }   }   go stor . handleWriteStream ( )    stor . pendingDeleteReqChan = make ( chan * asyncValueDeleteRequest , concurrency )   stor . freeDeleteReqChan = make ( chan * asyncValueDeleteRequest , concurrency )   stor . freeDeleteResChan = make ( chan * asyncValueDeleteResponse , concurrency )   for i := 0 ; i < cap ( stor . freeDeleteReqChan ) ; i ++ { stor . freeDeleteReqChan <- & asyncValueDeleteRequest { resChan : make ( chan * asyncValueDeleteResponse , 1 ) }   }   for i := 0 ; i < cap ( stor . freeDeleteResChan ) ; i ++ { stor . freeDeleteResChan <- & asyncValueDeleteResponse { }   }   go stor . handleDeleteStream ( )    return stor , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/llgcode/draw2d/blob/f52c8a71aff06ab8df41843d33ab167b36c971cd/draw2dimg/ftgc.go#L339-L365<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( gc * GraphicContext ) FillStroke ( paths ... * draw2d . Path ) { paths = append ( paths , gc . Current . Path )   gc . fillRasterizer . UseNonZeroWinding = gc . Current . FillRule == draw2d . FillRuleWinding   gc . strokeRasterizer . UseNonZeroWinding = true    flattener := draw2dbase . Transformer { Tr : gc . Current . Tr , Flattener : FtLineBuilder { Adder : gc . fillRasterizer } }    stroker := draw2dbase . NewLineStroker ( gc . Current . Cap , gc . Current . Join , draw2dbase . Transformer { Tr : gc . Current . Tr , Flattener : FtLineBuilder { Adder : gc . strokeRasterizer } } )   stroker . HalfLineWidth = gc . Current . LineWidth / 2    var liner draw2dbase . Flattener   if gc . Current . Dash != nil && len ( gc . Current . Dash ) > 0 { liner = draw2dbase . NewDashConverter ( gc . Current . Dash , gc . Current . DashOffset , stroker )   } else { liner = stroker   }    demux := draw2dbase . DemuxFlattener { Flatteners : [ ] draw2dbase . Flattener { flattener , liner } }   for _ , p := range paths { draw2dbase . Flatten ( p , demux , gc . Current . Tr . GetScale ( ) )   }    // Fill gc . paint ( gc . fillRasterizer , gc . Current . FillColor )   // Stroke gc . paint ( gc . strokeRasterizer , gc . Current . StrokeColor )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/glycerine/rbuf/blob/75b78581bebe959bc9a3df4c5f64e82c187d7531/fbuf.go#L130-L144<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( b * Float64RingBuf ) WriteAndMaybeOverwriteOldestData ( p [ ] float64 ) ( n int , err error ) { writeCapacity := b . N - b . Readable   if len ( p ) > writeCapacity { b . Advance ( len ( p ) - writeCapacity )   }   startPos := 0   if len ( p ) > b . N { startPos = len ( p ) - b . N   }   n , err = b . Write ( p [ startPos : ] )   if err != nil { return n , err   }   return len ( p ) , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lestrrat-go/xslate/blob/6a6eb0fce8ab7407a3e0460af60758e5d6f2b9f8/internal/stack/stack.go#L111-L120<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( s * Stack ) Pop ( ) interface { } { l := len ( * s )   if l == 0 { return nil   }    v := ( * s ) [ l - 1 ]   * s = ( * s ) [ : l - 1 ]   return v   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kljensen/snowball/blob/115fa8f6419dcfb9ec4653997b1c6803a5eff962/english/common.go#L118-L202<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func stemSpecialWord ( word string ) ( stemmed string ) { switch word { case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   case " " : stemmed = " "   }   return   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/debugger/debugger.go#L790-L792<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p * SetBreakpointsActiveParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetBreakpointsActive , p , nil )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/profitbricks/profitbricks-sdk-go/blob/1d2db5f00bf5dd0b6c29273541c71c60cdf4d4d4/loadbalancer.go#L88-L93<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * Client ) DeleteLoadbalancer ( dcid , lbalid string ) ( * http . Header , error ) { url := lbalPath ( dcid , lbalid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty )   ret := & http . Header { }   err := c . client . Delete ( url , ret , http . StatusAccepted )   return ret , err   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/dom/easyjson.go#L1310-L1314<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * RequestNodeParams ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoDom13 ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/pod-utils/clone/clone.go#L173-L178<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func gitTimestampEnvs ( timestamp int ) [ ] string { return [ ] string { fmt . Sprintf ( " " , timestamp ) , fmt . Sprintf ( " " , timestamp ) , }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/input/input.go#L129-L132<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p DispatchKeyEventParams ) WithLocation ( location int64 ) * DispatchKeyEventParams { p . Location = location   return & p   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/naoina/genmai/blob/78583835e1e41e3938e1ddfffd7101f8ad27fae0/genmai.go#L252-L254<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( db * DB ) CreateIndex ( table interface { } , name string , names ... string ) error { return db . createIndex ( table , false , name , names ... )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/golang/appengine/blob/54a98f90d1c46b7731eb8fb305d2a321c30ef610/cmd/aefix/fix.go#L392-L403<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func countUses ( x * ast . Ident , scope [ ] ast . Stmt ) int { count := 0   ff := func ( n interface { } ) { if n , ok := n . ( ast . Node ) ; ok && refersTo ( n , x ) { count ++   }   }   for _ , n := range scope { walk ( n , ff )   }   return count   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/justinfx/gofileseq/blob/2555f296b4493d1825f5f6fab4aa0ff51a8306cd/ranges/ranges.go#L322-L328<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( l * InclusiveRanges ) Len ( ) int { var totalLen int   for _ , b := range l . blocks { totalLen += b . Len ( )   }   return totalLen   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/har/easyjson.go#L2389-L2393<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v CacheData ) MarshalJSON ( ) ( [ ] byte , error ) { w := jwriter . Writer { }   easyjsonC5a4559bEncodeGithubComChromedpCdprotoHar14 ( & w , v )   return w . Buffer . BuildBytes ( ) , w . Error   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/pjutil/pjutil.go#L142-L147<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func PeriodicSpec ( p config . Periodic ) prowapi . ProwJobSpec { pjs := specFromJobBase ( p . JobBase )   pjs . Type = prowapi . PeriodicJob    return pjs   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/256dpi/fire/blob/fa66e74352b30b9a4c730f7b8dc773302941b0fb/callbacks.go#L298-L357<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func VerifyReferencesValidator ( pairs map [ string ] coal . Model ) * Callback { return C ( " " , Only ( Create , Update ) , func ( ctx * Context ) error { // check all references for field , collection := range pairs { // read referenced id ref := ctx . Model . MustGet ( field )    // continue if reference is not set if oid , ok := ref . ( * bson . ObjectId ) ; ok && oid == nil { continue   }    // continue if slice is empty if ids , ok := ref . ( [ ] bson . ObjectId ) ; ok && ids == nil { continue   }    // handle to-many relationships if ids , ok := ref . ( [ ] bson . ObjectId ) ; ok { // prepare query query := bson . M { " " : bson . M { " " : ids } }    // count entities in database ctx . Tracer . Push ( " " )   ctx . Tracer . Tag ( " " , query )   n , err := ctx . Store . DB ( ) . C ( coal . C ( collection ) ) . Find ( query ) . Count ( )   if err != nil { return err   }   ctx . Tracer . Pop ( )    // check for existence if n != len ( ids ) { return E ( " " + field )   }    continue   }    // handle to-one relationships // count entities in database ctx . Tracer . Push ( " " )   ctx . Tracer . Tag ( " " , ref )   n , err := ctx . Store . DB ( ) . C ( coal . C ( collection ) ) . FindId ( ref ) . Limit ( 1 ) . Count ( )   if err != nil { return err   }   ctx . Tracer . Pop ( )    // check for existence if n != 1 { return E ( " " + field )   }   }    // pass validation return nil   } )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/Knetic/govaluate/blob/9aa49832a739dcd78a5542ff189fb82c3e423116/OperatorSymbol.go#L244-L309<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( this OperatorSymbol ) String ( ) string { switch this { case NOOP : return " "   case VALUE : return " "   case EQ : return " "   case NEQ : return " "   case GT : return " "   case LT : return " "   case GTE : return " "   case LTE : return " "   case REQ : return " "   case NREQ : return " "   case AND : return " "   case OR : return " "   case IN : return " "   case BITWISE_AND : return " "   case BITWISE_OR : return " "   case BITWISE_XOR : return " "   case BITWISE_LSHIFT : return " "   case BITWISE_RSHIFT : return " "   case PLUS : return " "   case MINUS : return " "   case MULTIPLY : return " "   case DIVIDE : return " "   case MODULUS : return " "   case EXPONENT : return " "   case NEGATE : return " "   case INVERT : return " "   case BITWISE_NOT : return " "   case TERNARY_TRUE : return " "   case TERNARY_FALSE : return " "   case COALESCE : return " "   }   return " "   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/weaveworks/mesh/blob/512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39/status.go#L160-L217<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func makeLocalConnectionStatusSlice ( cm * connectionMaker ) [ ] LocalConnectionStatus { resultChan := make ( chan [ ] LocalConnectionStatus )   cm . actionChan <- func ( ) bool { var slice [ ] LocalConnectionStatus   for conn := range cm . connections { state := " "   if conn . isEstablished ( ) { state = " "   }   lc , _ := conn . ( * LocalConnection )   attrs := lc . OverlayConn . Attrs ( )   name , ok := attrs [ " " ]   if ! ok { name = " "   }   info := fmt . Sprintf ( " " , name , conn . Remote ( ) )   if lc . router . usingPassword ( ) { if lc . untrusted ( ) { info = fmt . Sprintf ( " " , " " , info )   if attrs != nil { attrs [ " " ] = true   }   } else { info = fmt . Sprintf ( " " , " " , info )   }   }   slice = append ( slice , LocalConnectionStatus { conn . remoteTCPAddress ( ) , conn . isOutbound ( ) , state , info , attrs } )   }   for address , target := range cm . targets { add := func ( state , info string ) { slice = append ( slice , LocalConnectionStatus { address , true , state , info , nil } )   }   switch target . state { case targetWaiting : until := " "   if ! target . tryAfter . IsZero ( ) { until = target . tryAfter . String ( )   }   if target . lastError == nil { // shouldn't happen add ( " " , " " + until )   } else { add ( " " , target . lastError . Error ( ) + " " + until )   }   case targetAttempting : if target . lastError == nil { add ( " " , " " )   } else { add ( " " , target . lastError . Error ( ) )   }   case targetConnected : case targetSuspended : }   }   resultChan <- slice   return false   }   return <- resultChan   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/plugins/plugins.go#L260-L271<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( pa * ConfigAgent ) GenericCommentHandlers ( owner , repo string ) map [ string ] GenericCommentHandler { pa . mut . Lock ( )   defer pa . mut . Unlock ( )    hs := map [ string ] GenericCommentHandler { }   for _ , p := range pa . getPlugins ( owner , repo ) { if h , ok := genericCommentHandlers [ p ] ; ok { hs [ p ] = h   }   }   return hs   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/gen/writers/client.go#L76-L78<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * ClientWriter ) WriteResource ( resource * gen . Resource , w io . Writer ) error { return c . resourceTmpl . Execute ( w , resource )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/build/change_trust.go#L67-L87<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func Trust ( code , issuer string , args ... interface { } ) ( result ChangeTrustBuilder ) { mutators := [ ] interface { } { CreditAsset ( code , issuer ) , }    limitSet := false    for _ , mut := range args { mutators = append ( mutators , mut )   _ , isLimit := mut . ( Limit )   if isLimit { limitSet = true   }   }    if ! limitSet { mutators = append ( mutators , MaxLimit )   }    return ChangeTrust ( mutators ... )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/debugger/debugger.go#L46-L48<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p * ContinueToLocationParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandContinueToLocation , p , nil )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/tide/tide.go#L930-L988<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func tryMerge ( mergeFunc func ( ) error ) ( bool , error ) { var err error   const maxRetries = 3   backoff := time . Second * 4   for retry := 0 ; retry < maxRetries ; retry ++ { if err = mergeFunc ( ) ; err == nil { // Successful merge! return true , nil   }   // TODO: Add a config option to abort batches if a PR in the batch // cannot be merged for any reason. This would skip merging // not just the changed PR, but also the other PRs in the batch. // This shouldn't be the default behavior as merging batches is high // priority and this is unlikely to be problematic. // Note: We would also need to be able to roll back any merges for the // batch that were already successfully completed before the failure. // Ref: https://github.com/kubernetes/test-infra/issues/10621 if _ , ok := err . ( github . ModifiedHeadError ) ; ok { // This is a possible source of incorrect behavior. If someone // modifies their PR as we try to merge it in a batch then we // end up in an untested state. This is unlikely to cause any // real problems. return true , fmt . Errorf ( " " , err )   } else if _ , ok = err . ( github . UnmergablePRBaseChangedError ) ; ok { //  complained that the base branch was modified. This is a // strange error because the API doesn't even allow the request to // specify the base branch sha, only the head sha. // We suspect that github is complaining because we are making the // merge requests too rapidly and it cannot recompute mergability // in time. https://github.com/kubernetes/test-infra/issues/5171 // We handle this by sleeping for a few seconds before trying to // merge again. err = fmt . Errorf ( " " , err )   if retry + 1 < maxRetries { sleep ( backoff )   backoff *= 2   }   } else if _ , ok = err . ( github . UnauthorizedToPushError ) ; ok { // GitHub let us know that the token used cannot push to the branch. // Even if the robot is set up to have write access to the repo, an // overzealous branch protection setting will not allow the robot to // push to a specific branch. // We won't be able to merge the other PRs. return false , fmt . Errorf ( " " , err )   } else if _ , ok = err . ( github . MergeCommitsForbiddenError ) ; ok { // GitHub let us know that the merge method configured for this repo // is not allowed by other repo settings, so we should let the admins // know that the configuration needs to be updated. // We won't be able to merge the other PRs. return false , fmt . Errorf ( " " , err )   } else if _ , ok = err . ( github . UnmergablePRError ) ; ok { return true , fmt . Errorf ( " " , err )   } else { return true , err   }   }   // We ran out of retries. Return the last transient error. return true , err   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/net_transport.go#L286-L300<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( n * NetworkTransport ) getPooledConn ( target ServerAddress ) * netConn { n . connPoolLock . Lock ( )   defer n . connPoolLock . Unlock ( )    conns , ok := n . connPool [ target ]   if ! ok || len ( conns ) == 0 { return nil   }    var conn * netConn   num := len ( conns )   conn , conns [ num - 1 ] = conns [ num - 1 ] , nil   n . connPool [ target ] = conns [ : num - 1 ]   return conn   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lestrrat-go/xslate/blob/6a6eb0fce8ab7407a3e0460af60758e5d6f2b9f8/vm/state.go#L119-L125<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( st * State ) CurrentMark ( ) int { x , err := st . markstack . Top ( )   if err != nil { x = 0   }   return x . ( int )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/enaml-ops/enaml/blob/4f847ee10b41afca41fe09fa839cb2f6ade06fb5/deploymentmanifest.go#L62-L70<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( s * DeploymentManifest ) AddRemoteRelease ( releaseName , ver , url , sha1 string ) ( err error ) { s . Releases = append ( s . Releases , Release { Name : releaseName , URL : url , SHA1 : sha1 , Version : ver , } )   return   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/provision/kubernetes/pkg/client/listers/tsuru/v1/app.go#L67-L72<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( s appNamespaceLister ) List ( selector labels . Selector ) ( ret [ ] * v1 . App , err error ) { err = cache . ListAllByNamespace ( s . indexer , s . namespace , selector , func ( m interface { } ) { ret = append ( ret , m . ( * v1 . App ) )   } )   return ret , err   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/aphistic/gomol/blob/1546845ba714699f76f484ad3af64cf0503064d1/base.go#L423-L425<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( b * Base ) Infom ( m * Attrs , msg string , a ... interface { } ) error { return b . Log ( LevelInfo , m , msg , a ... )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/weaveworks/mesh/blob/512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39/gossip_channel.go#L82-L84<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * gossipChannel ) GossipBroadcast ( update GossipData ) { c . relayBroadcast ( c . ourself . Name , update )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/taskcluster/taskcluster-client-go/blob/ef6acd428ae5844a933792ed6479d0e7dca61ef8/tcec2manager/tcec2manager.go#L106-L110<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( eC2Manager * EC2Manager ) RunInstance ( workerType string , payload * MakeASpotRequest ) error { cd := tcclient . Client ( * eC2Manager )   _ , _ , err := ( & cd ) . APICall ( payload , " " , " " + url . QueryEscape ( workerType ) + " " , nil , nil )   return err   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/api/rafthttp/util.go#L134-L141<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func serverVersion ( h http . Header ) * semver . Version { verStr := h . Get ( " " )   // backward compatibility with etcd 2.0 if verStr == " " { verStr = " "   }   return semver . Must ( semver . NewVersion ( verStr ) )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/containers/image/blob/da9ab3561ad2031aeb5e036b7cf2755d4e246fec/docker/tarfile/dest.go#L97-L158<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( d * Destination ) PutBlob ( ctx context . Context , stream io . Reader , inputInfo types . BlobInfo , cache types . BlobInfoCache , isConfig bool ) ( types . BlobInfo , error ) { // Ouch, we need to stream the blob into a temporary file just to determine the size. // When the layer is decompressed, we also have to generate the digest on uncompressed datas. if inputInfo . Size == - 1 || inputInfo . Digest . String ( ) == " " { logrus . Debugf ( " " )   streamCopy , err := ioutil . TempFile ( tmpdir . TemporaryDirectoryForBigFiles ( ) , " " )   if err != nil { return types . BlobInfo { } , err   }   defer os . Remove ( streamCopy . Name ( ) )   defer streamCopy . Close ( )    digester := digest . Canonical . Digester ( )   tee := io . TeeReader ( stream , digester . Hash ( ) )   // TODO: This can take quite some time, and should ideally be cancellable using ctx.Done(). size , err := io . Copy ( streamCopy , tee )   if err != nil { return types . BlobInfo { } , err   }   _ , err = streamCopy . Seek ( 0 , os . SEEK_SET )   if err != nil { return types . BlobInfo { } , err   }   inputInfo . Size = size // inputInfo is a struct, so we are only modifying our copy.   if inputInfo . Digest == " " { inputInfo . Digest = digester . Digest ( )   }   stream = streamCopy   logrus . Debugf ( " " )   }    // Maybe the blob has been already sent ok , reusedInfo , err := d . TryReusingBlob ( ctx , inputInfo , cache , false )   if err != nil { return types . BlobInfo { } , err   }   if ok { return reusedInfo , nil   }    if isConfig { buf , err := ioutil . ReadAll ( stream )   if err != nil { return types . BlobInfo { } , errors . Wrap ( err , " " )   }   d . config = buf   if err := d . sendFile ( inputInfo . Digest . Hex ( ) + " " , inputInfo . Size , bytes . NewReader ( buf ) ) ; err != nil { return types . BlobInfo { } , errors . Wrap ( err , " " )   }   } else { // Note that this can't be e.g. filepath.Join(l.Digest.Hex(), legacyLayerFileName); due to the way // writeLegacyLayerMetadata constructs layer IDs differently from inputinfo.Digest values (as described // inside it), most of the layers would end up in subdirectories alone without any metadata; (docker load) // tries to load every subdirectory as an image and fails if the config is missing.  So, keep the layers // in the root of the tarball. if err := d . sendFile ( inputInfo . Digest . Hex ( ) + " " , inputInfo . Size , stream ) ; err != nil { return types . BlobInfo { } , err   }   }   d . blobs [ inputInfo . Digest ] = types . BlobInfo { Digest : inputInfo . Digest , Size : inputInfo . Size }   return types . BlobInfo { Digest : inputInfo . Digest , Size : inputInfo . Size } , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/taskcluster/taskcluster-client-go/blob/ef6acd428ae5844a933792ed6479d0e7dca61ef8/tchooks/types.go#L614-L617<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( this * TriggerHookResponse ) MarshalJSON ( ) ( [ ] byte , error ) { x := json . RawMessage ( * this )   return ( & x ) . MarshalJSON ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/client/clientset/versioned/clientset.go#L83-L89<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func NewForConfigOrDie ( c * rest . Config ) * Clientset { var cs Clientset   cs . prowV1 = prowv1 . NewForConfigOrDie ( c )    cs . DiscoveryClient = discovery . NewDiscoveryClientForConfigOrDie ( c )   return & cs   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/iron-io/functions_go/blob/91b84f5bbb17095bf1c7028ec6e70a3dc06a5893/client/apps/get_apps_parameters.go#L70-L73<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( o * GetAppsParams ) WithTimeout ( timeout time . Duration ) * GetAppsParams { o . SetTimeout ( timeout )   return o   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L6723-L6731<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( u StellarMessage ) MustEnvelope ( ) ScpEnvelope { val , ok := u . GetEnvelope ( )    if ! ok { panic ( " " )   }    return val   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/urandom/handler/blob/61508044a5569d1609521d81e81f6737567fd104/lang/i18n.go#L28-L32<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func Languages ( tags [ ] xlang . Tag ) Option { return Option { func ( o * options ) { o . languages = tags   } }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/keypair/main.go#L44-L59<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func Random ( ) ( * Full , error ) { var rawSeed [ 32 ] byte    _ , err := io . ReadFull ( rand . Reader , rawSeed [ : ] )   if err != nil { return nil , err   }    kp , err := FromRawSeed ( rawSeed )    if err != nil { return nil , err   }    return kp , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/ledger_key.go#L52-L61<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( key * LedgerKey ) SetData ( account AccountId , name string ) error { data := LedgerKeyData { account , String64 ( name ) }   nkey , err := NewLedgerKey ( LedgerEntryTypeData , data )   if err != nil { return err   }    * key = nkey   return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/performance/types.go#L61-L63<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( t * SetTimeDomainTimeDomain ) UnmarshalJSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/easyjson.go#L69-L73<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * empty ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdproto ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/shared/generate/db/mapping.go#L70-L73<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( m * Mapping ) FieldColumnName ( name string ) string { field := m . FieldByName ( name )   return fmt . Sprintf ( " " , entityTable ( m . Name ) , field . Column ( ) )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/layertree/types.go#L118-L130<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( t * ScrollRectType ) UnmarshalEasyJSON ( in * jlexer . Lexer ) { switch ScrollRectType ( in . String ( ) ) { case ScrollRectTypeRepaintsOnScroll : * t = ScrollRectTypeRepaintsOnScroll   case ScrollRectTypeTouchEventHandler : * t = ScrollRectTypeTouchEventHandler   case ScrollRectTypeWheelEventHandler : * t = ScrollRectTypeWheelEventHandler    default : in . AddError ( errors . New ( " " ) )   }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L2544-L2551<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( u CreateAccountResult ) ArmForSwitch ( sw int32 ) ( string , bool ) { switch CreateAccountResultCode ( sw ) { case CreateAccountResultCodeCreateAccountSuccess : return " " , true   default : return " " , true   }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/emulation/types.go#L43-L45<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( t VirtualTimePolicy ) MarshalEasyJSON ( out * jwriter . Writer ) { out . String ( string ( t ) )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/go-opencv/go-opencv/blob/a4fe8ec027ccc9eb8b7d0797db7c76e61083f1db/opencv/cxcore.go#L507-L511<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func GetSizeWidth ( img * IplImage ) int { size := C . cvGetSize ( unsafe . Pointer ( img ) )   w := int ( size . width )   return w   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/gernest/mention/blob/d48aa4355f942e79e1a4ac2bd08c5c46371b78ca/mention.go#L75-L82<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func isTerminator ( r rune , terminator ... rune ) bool { for _ , t := range terminator { if r == t { return true   }   }   return unicode . IsSpace ( r ) || ! unicode . IsPrint ( r )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/op/go-logging/blob/970db520ece77730c7e4724c61121037378659d9/multi.go#L58-L65<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( b * multiLogger ) IsEnabledFor ( level Level , module string ) bool { for _ , backend := range b . backends { if backend . IsEnabledFor ( level , module ) { return true   }   }   return false   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/raft/progress.go#L135-L157<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( pr * Progress ) maybeDecrTo ( rejected , last uint64 ) bool { if pr . State == ProgressStateReplicate { // the rejection must be stale if the progress has matched and "rejected" // is smaller than "match". if rejected <= pr . Match { return false   }   // directly decrease next to match + 1 pr . Next = pr . Match + 1   return true   }    // the rejection must be stale if "rejected" does not match next - 1 if pr . Next - 1 != rejected { return false   }    if pr . Next = min ( rejected , last + 1 ) ; pr . Next < 1 { pr . Next = 1   }   pr . resume ( )   return true   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/DamienFontaine/lunarc/blob/2e7332a51f554794a549a313430eaa7dec8d13cc/security/controller.go#L160-L189<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * OAuth2Controller ) Authorize ( w http . ResponseWriter , r * http . Request ) { clientID := r . URL . Query ( ) . Get ( " " )   responsetype := r . URL . Query ( ) . Get ( " " )   redirectURI := r . URL . Query ( ) . Get ( " " )   userID := r . URL . Query ( ) . Get ( " " )   if len ( redirectURI ) == 0 { app , _ := c . ApplicationManager . GetByClientID ( clientID )   redirectURI = app . Callback   }   if len ( redirectURI ) == 0 { log . Print ( " )    // return an error code ? } else { if strings . Compare ( responsetype , " " ) == 0 { code , err := EncodeOAuth2Code ( clientID , redirectURI , userID , c . cnf . Jwt . Key )   if err != nil { log . Printf ( " " , err )   }   data := map [ string ] string { " " : redirectURI , " " : code , }   js , _ := json . Marshal ( data )   w . Write ( js )   } else { log . Print ( " )    //return a Token }   }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/build/transaction.go#L129-L143<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( m AutoSequence ) MutateTransaction ( o * TransactionBuilder ) error { source := o . TX . SourceAccount    if source == ( xdr . AccountId { } ) { return errors . New ( " " )   }    seq , err := m . SequenceForAccount ( source . Address ( ) )   if err != nil { return err   }    o . TX . SeqNum = seq + 1   return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/overlay/easyjson.go#L808-L812<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v HighlightRectParams ) MarshalJSON ( ) ( [ ] byte , error ) { w := jwriter . Writer { }   easyjsonC5a4559bEncodeGithubComChromedpCdprotoOverlay9 ( & w , v )   return w . Buffer . BuildBytes ( ) , w . Error   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/domdebugger/easyjson.go#L835-L839<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * GetEventListenersParams ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoDomdebugger9 ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/client/pkg/require/require.go#L386-L398<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func Nil ( tb testing . TB , object interface { } , msgAndArgs ... interface { } ) { tb . Helper ( )   if object == nil { return   }   value := reflect . ValueOf ( object )   kind := value . Kind ( )   if kind >= reflect . Chan && kind <= reflect . Slice && value . IsNil ( ) { return   }    fatal ( tb , msgAndArgs , " " , object )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/provision/docker/scheduler.go#L183-L200<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( s * segregatedScheduler ) aggregateContainersBy ( matcher bson . M ) ( map [ string ] int , error ) { coll := s . provisioner . Collection ( )   defer coll . Close ( )   pipe := coll . Pipe ( [ ] bson . M { matcher , { " " : bson . M { " " : " " , " " : bson . M { " " : 1 } } } , } )   var results [ ] nodeAggregate   err := pipe . All ( & results )   if err != nil { return nil , err   }   countMap := make ( map [ string ] int )   for _ , result := range results { countMap [ result . HostAddr ] = result . Count   }   return countMap , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/boskos/mason/storage.go#L53-L55<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( s * Storage ) UpdateConfig ( conf common . ResourcesConfig ) error { return s . configs . Update ( conf )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/config/branch_protection.go#L94-L104<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func unionStrings ( parent , child [ ] string ) [ ] string { if child == nil { return parent   }   if parent == nil { return child   }   s := sets . NewString ( parent ... )   s . Insert ( child ... )   return s . List ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/pkg/flags/unique_strings.go#L74-L76<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func UniqueStringsMapFromFlag ( fs * flag . FlagSet , flagName string ) map [ string ] struct { } { return ( * fs . Lookup ( flagName ) . Value . ( * UniqueStringsValue ) ) . Values   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/dom/easyjson.go#L499-L503<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * SetNodeNameReturns ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoDom4 ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/golang/debug/blob/19561fee47cf8cd0400d1b094c5898002f97cf90/internal/core/read.go#L137-L145<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p * Process ) ReadCString ( a Address ) string { for n := int64 ( 0 ) ; ; n ++ { if p . ReadUint8 ( a . Add ( n ) ) == 0 { b := make ( [ ] byte , n )   p . ReadAt ( b , a )   return string ( b )   }   }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L110-L116<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p * Pushy ) NotifyDevice ( request SendNotificationRequest ) ( * NotificationResponse , * Error , error ) { url := fmt . Sprintf ( " " , p . APIEndpoint , p . APIToken )   var success * NotificationResponse   var pushyErr * Error   err := post ( p . httpClient , url , request , & success , & pushyErr )   return success , pushyErr , err   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/raft/storage.go#L239-L271<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( ms * MemoryStorage ) Append ( entries [ ] pb . Entry ) error { if len ( entries ) == 0 { return nil   }    ms . Lock ( )   defer ms . Unlock ( )    first := ms . firstIndex ( )   last := entries [ 0 ] . Index + uint64 ( len ( entries ) ) - 1    // shortcut if there is no new entry. if last < first { return nil   }   // truncate compacted entries if first > entries [ 0 ] . Index { entries = entries [ first - entries [ 0 ] . Index : ]   }    offset := entries [ 0 ] . Index - ms . ents [ 0 ] . Index   switch { case uint64 ( len ( ms . ents ) ) > offset : ms . ents = append ( [ ] pb . Entry { } , ms . ents [ : offset ] ... )   ms . ents = append ( ms . ents , entries ... )   case uint64 ( len ( ms . ents ) ) == offset : ms . ents = append ( ms . ents , entries ... )   default : raftLogger . Panicf ( " " , ms . lastIndex ( ) , entries [ 0 ] . Index )   }   return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/schema/schema.go#L88-L90<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( s * Schema ) Add ( update Update ) { s . updates = append ( s . updates , update )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/input/input.go#L286-L288<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p * DispatchTouchEventParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandDispatchTouchEvent , p , nil )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/css/css.go#L591-L600<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p * SetMediaTextParams ) Do ( ctx context . Context ) ( media * Media , err error ) { // execute var res SetMediaTextReturns   err = cdp . Execute ( ctx , CommandSetMediaText , p , & res )   if err != nil { return nil , err   }    return res . Media , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/client/pfs.go#L901-L915<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * putFileClient ) PutFileSplit ( repoName string , commitID string , path string , delimiter pfs . Delimiter , targetFileDatums int64 , targetFileBytes int64 , headerRecords int64 , overwrite bool , reader io . Reader ) ( _ int , retErr error ) { writer , err := c . PutFileSplitWriter ( repoName , commitID , path , delimiter , targetFileDatums , targetFileBytes , headerRecords , overwrite )   if err != nil { return 0 , grpcutil . ScrubGRPC ( err )   }   defer func ( ) { if err := writer . Close ( ) ; err != nil && retErr == nil { retErr = err   }   } ( )   buf := grpcutil . GetBuffer ( )   defer grpcutil . PutBuffer ( buf )   written , err := io . CopyBuffer ( writer , reader , buf )   return int ( written ) , grpcutil . ScrubGRPC ( err )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/profitbricks/profitbricks-sdk-go/blob/1d2db5f00bf5dd0b6c29273541c71c60cdf4d4d4/usermanagment.go#L280-L285<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * Client ) GetUser ( usrid string ) ( * User , error ) { url := umUsersPath ( usrid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty )   ret := & User { }   err := c . client . Get ( url , ret , http . StatusOK )   return ret , err   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L5831-L5840<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( u LedgerEntryChange ) GetState ( ) ( result LedgerEntry , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) )    if armName == " " { result = * u . State   ok = true   }    return   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/segmentio/nsq-go/blob/ff4eef968f46eb580d9dba4f637c5dfb1e5b2208/command.go#L33-L96<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ReadCommand ( r * bufio . Reader ) ( cmd Command , err error ) { var line string    if line , err = r . ReadString ( '\n' ) ; err != nil { err = errors . Wrap ( err , " " )   return   }    if n := len ( line ) ; n == 0 || line [ n - 1 ] != '\n' { err = errors . New ( " " )   return   } else { line = line [ : n - 1 ]   }    if line == " " { return readIdentify ( r )   }    if strings . HasPrefix ( line , " " ) { return readSub ( line [ 4 : ] )   }    if strings . HasPrefix ( line , " " ) { return readPub ( line [ 4 : ] , r )   }    if strings . HasPrefix ( line , " " ) { return readMPub ( line [ 5 : ] , r )   }    if strings . HasPrefix ( line , " " ) { return readRdy ( line [ 4 : ] )   }    if strings . HasPrefix ( line , " " ) { return readFin ( line [ 4 : ] )   }    if strings . HasPrefix ( line , " " ) { return readReq ( line [ 4 : ] )   }    if strings . HasPrefix ( line , " " ) { return readTouch ( line [ 6 : ] )   }    if line == " " { return readAuth ( r )   }    if line == " " { cmd = Cls { }   return   }    if line == " " { cmd = Nop { }   return   }    err = errors . New ( " " + line )   return   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/containers/image/blob/da9ab3561ad2031aeb5e036b7cf2755d4e246fec/oci/layout/oci_transport.go#L105-L107<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( ref ociReference ) StringWithinTransport ( ) string { return fmt . Sprintf ( " " , ref . dir , ref . image )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/256dpi/fire/blob/fa66e74352b30b9a4c730f7b8dc773302941b0fb/axe/task.go#L22-L27<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func E ( reason string , retry bool ) * Error { return & Error { Reason : reason , Retry : retry , }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L6623-L6631<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( u StellarMessage ) MustTxSet ( ) TransactionSet { val , ok := u . GetTxSet ( )    if ! ok { panic ( " " )   }    return val   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/profitbricks/profitbricks-sdk-go/blob/1d2db5f00bf5dd0b6c29273541c71c60cdf4d4d4/server.go#L59-L64<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * Client ) ListServers ( dcid string ) ( * Servers , error ) { url := serverColPath ( dcid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty )   ret := & Servers { }   err := c . client . Get ( url , ret , http . StatusOK )   return ret , err   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/plugins/trigger/trigger.go#L198-L210<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func runAndSkipJobs ( c Client , pr * github . PullRequest , requestedJobs [ ] config . Presubmit , skippedJobs [ ] config . Presubmit , eventGUID string , elideSkippedContexts bool ) error { if err := validateContextOverlap ( requestedJobs , skippedJobs ) ; err != nil { c . Logger . WithError ( err ) . Warn ( " " )   return err   }   runErr := RunRequested ( c , pr , requestedJobs , eventGUID )   var skipErr error   if ! elideSkippedContexts { skipErr = skipRequested ( c , pr , skippedJobs )   }    return errorutil . NewAggregate ( runErr , skipErr )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/tnet/listener.go#L32-L34<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func Wrap ( l net . Listener ) net . Listener { return & listener { Listener : l , cond : sync . NewCond ( & sync . Mutex { } ) }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/debugger/debugger.go#L99-L108<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p * EnableParams ) Do ( ctx context . Context ) ( debuggerID runtime . UniqueDebuggerID , err error ) { // execute var res EnableReturns   err = cdp . Execute ( ctx , CommandEnable , p , & res )   if err != nil { return " " , err   }    return res . DebuggerID , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/memory/easyjson.go#L409-L413<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v SamplingProfileNode ) MarshalJSON ( ) ( [ ] byte , error ) { w := jwriter . Writer { }   easyjsonC5a4559bEncodeGithubComChromedpCdprotoMemory4 ( & w , v )   return w . Buffer . BuildBytes ( ) , w . Error   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/dailyburn/bigquery/blob/b6f18972580ed8882d195da0e9b7c9b94902a1ea/client/client.go#L350-L396<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * Client ) pageOverJob ( rowCount int , jobRef * bigquery . JobReference , pageToken string , resultChan chan [ ] [ ] interface { } , headersChan chan [ ] string ) error { service , err := c . connect ( )   if err != nil { return err   }    qrc := service . Jobs . GetQueryResults ( jobRef . ProjectId , jobRef . JobId )   if len ( pageToken ) > 0 { qrc . PageToken ( pageToken )   }    qr , err := qrc . Do ( )   if err != nil { c . printDebug ( " " , err )   close ( resultChan )   return err   }    if qr . JobComplete { c . printDebug ( " " )   headers , rows := c . headersAndRows ( qr . Schema , qr . Rows )   if headersChan != nil { headersChan <- headers   close ( headersChan )   }    // send back the rows we got c . printDebug ( " " )   resultChan <- rows   rowCount = rowCount + len ( rows )   c . printDebug ( " " , rowCount )   }    if qr . TotalRows > uint64 ( rowCount ) || ! qr . JobComplete { c . printDebug ( " " )   if qr . JobReference == nil { c . pageOverJob ( rowCount , jobRef , pageToken , resultChan , headersChan )   } else { c . pageOverJob ( rowCount , qr . JobReference , qr . PageToken , resultChan , nil )   }   } else { close ( resultChan )   return nil   }    return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/dailyburn/bigquery/blob/b6f18972580ed8882d195da0e9b7c9b94902a1ea/client/client.go#L519-L529<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * Client ) Count ( dataset , project , datasetTable string ) int64 { qstr := fmt . Sprintf ( " " , datasetTable )   res , err := c . SyncQuery ( dataset , project , qstr , 1 )   if err == nil { if len ( res ) > 0 { val , _ := strconv . ParseInt ( res [ 0 ] [ 0 ] . ( string ) , 10 , 64 )   return val   }   }   return 0   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/raft.go#L1455-L1463<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( r * Raft ) persistVote ( term uint64 , candidate [ ] byte ) error { if err := r . stable . SetUint64 ( keyLastVoteTerm , term ) ; err != nil { return err   }   if err := r . stable . Set ( keyLastVoteCand , candidate ) ; err != nil { return err   }   return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/network/easyjson.go#L775-L779<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v SignedExchangeSignature ) MarshalJSON ( ) ( [ ] byte , error ) { w := jwriter . Writer { }   easyjsonC5a4559bEncodeGithubComChromedpCdprotoNetwork5 ( & w , v )   return w . Buffer . BuildBytes ( ) , w . Error   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/log/log.go#L246-L248<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( f FormatterFunc ) Format ( entry * logrus . Entry ) ( [ ] byte , error ) { return f ( entry )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L3436-L3445<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func NewAllowTrustResult ( code AllowTrustResultCode , value interface { } ) ( result AllowTrustResult , err error ) { result . Code = code   switch AllowTrustResultCode ( code ) { case AllowTrustResultCodeAllowTrustSuccess : // void default : // void }   return   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/query/config.go#L77-L93<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func upsertConfig ( tx * sql . Tx , table string , values map [ string ] string ) error { if len ( values ) == 0 { return nil // Nothing to update   }    query := fmt . Sprintf ( " " , table )   exprs := [ ] string { }   params := [ ] interface { } { }   for key , value := range values { exprs = append ( exprs , " " )   params = append ( params , key )   params = append ( params , value )   }   query += strings . Join ( exprs , " " )   _ , err := tx . Exec ( query , params ... )   return err   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/pact-foundation/pact-go/blob/467dea56d27e154363e1975f6e9f4dbf66148e79/examples/gin/provider/user_service.go#L37-L47<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func IsAuthenticated ( ) gin . HandlerFunc { return func ( c * gin . Context ) { fmt . Println ( c . GetHeader ( " " ) )    if c . GetHeader ( " " ) == fmt . Sprintf ( " " , getAuthToken ( ) ) { c . Next ( )   } else { c . JSON ( http . StatusUnauthorized , gin . H { " " : " " } )   }   }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/api/etcdhttp/peer.go#L34-L36<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func NewPeerHandler ( lg * zap . Logger , s etcdserver . ServerPeer ) http . Handler { return newPeerHandler ( lg , s . Cluster ( ) , s . RaftHandler ( ) , s . LeaseHandler ( ) )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pfs/server/driver.go#L747-L781<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( d * driver ) writeFinishedCommit ( ctx context . Context , commit * pfs . Commit , commitInfo * pfs . CommitInfo ) error { _ , err := col . NewSTM ( ctx , d . etcdClient , func ( stm col . STM ) error { commits := d . commits ( commit . Repo . Name ) . ReadWrite ( stm )   if err := commits . Put ( commit . ID , commitInfo ) ; err != nil { return err   }   if err := d . openCommits . ReadWrite ( stm ) . Delete ( commit . ID ) ; err != nil { return fmt . Errorf ( " " , commit . ID , err )   }   // update the repo size if this is the head of master repos := d . repos . ReadWrite ( stm )   repoInfo := new ( pfs . RepoInfo )   if err := repos . Get ( commit . Repo . Name , repoInfo ) ; err != nil { return err   }   for _ , branch := range repoInfo . Branches { if branch . Name == " " { branchInfo := & pfs . BranchInfo { }   if err := d . branches ( commit . Repo . Name ) . ReadWrite ( stm ) . Get ( branch . Name , branchInfo ) ; err != nil { return err   }   // If the head commit of master has been deleted, we could get here if another branch // had shared its head commit with master, and then we created a new commit on that branch if branchInfo . Head != nil && branchInfo . Head . ID == commit . ID { repoInfo . SizeBytes = commitInfo . SizeBytes   if err := repos . Put ( commit . Repo . Name , repoInfo ) ; err != nil { return err   }   }   }   }   return nil   } )   return err   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/sclevine/agouti/blob/96599c91888f1b1cf2dccc7f1776ba7f511909e5/page.go#L492-L498<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p * Page ) DoubleClick ( ) error { if err := p . session . DoubleClick ( ) ; err != nil { return fmt . Errorf ( " " , err )   }    return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/bazelbuild/bazel-gazelle/blob/e3805aaca69a9deb949b47bfc45b9b1870712f4f/cmd/gazelle/metaresolver.go#L54-L61<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( mr metaResolver ) Resolver ( r * rule . Rule , pkgRel string ) resolve . Resolver { for _ , mappedKind := range mr . mappedKinds [ pkgRel ] { if mappedKind . KindName == r . Kind ( ) { return mr . builtins [ mappedKind . FromKind ]   }   }   return mr . builtins [ r . Kind ( ) ]   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/backgroundservice/easyjson.go#L391-L395<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v EventMetadata ) MarshalJSON ( ) ( [ ] byte , error ) { w := jwriter . Writer { }   easyjsonC5a4559bEncodeGithubComChromedpCdprotoBackgroundservice4 ( & w , v )   return w . Buffer . BuildBytes ( ) , w . Error   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/profiler/easyjson.go#L692-L696<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * StopReturns ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoProfiler7 ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/gopherage/pkg/cov/aggregate.go#L26-L37<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func AggregateProfiles ( profiles [ ] [ ] * cover . Profile ) ( [ ] * cover . Profile , error ) { setProfiles := make ( [ ] [ ] * cover . Profile , 0 , len ( profiles ) )   for _ , p := range profiles { c := countToBoolean ( p )   setProfiles = append ( setProfiles , c )   }   aggregateProfiles , err := MergeMultipleProfiles ( setProfiles )   if err != nil { return nil , err   }   return aggregateProfiles , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/golang/appengine/blob/54a98f90d1c46b7731eb8fb305d2a321c30ef610/module/module.go#L77-L85<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func DefaultVersion ( c context . Context , module string ) ( string , error ) { req := & pb . GetDefaultVersionRequest { }   if module != " " { req . Module = & module   }   res := & pb . GetDefaultVersionResponse { }   err := internal . Call ( c , " " , " " , req , res )   return res . GetVersion ( ) , err   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/dom/dom.go#L1167-L1170<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p ResolveNodeParams ) WithNodeID ( nodeID cdp . NodeID ) * ResolveNodeParams { p . NodeID = nodeID   return & p   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/cluster/gateway.go#L651-L663<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func DqliteLog ( l dqlite . LogLevel , format string , a ... interface { } ) { format = fmt . Sprintf ( " " , format )   switch l { case dqlite . LogDebug : logger . Debugf ( format , a ... )   case dqlite . LogInfo : logger . Debugf ( format , a ... )   case dqlite . LogWarn : logger . Warnf ( format , a ... )   case dqlite . LogError : logger . Errorf ( format , a ... )   }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/bazelbuild/bazel-gazelle/blob/e3805aaca69a9deb949b47bfc45b9b1870712f4f/config/config.go#L122-L129<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * Config ) IsValidBuildFileName ( name string ) bool { for _ , n := range c . ValidBuildFileNames { if name == n { return true   }   }   return false   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/enaml-ops/enaml/blob/4f847ee10b41afca41fe09fa839cb2f6ade06fb5/run/showcmd.go#L20-L25<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func NewShowCmd ( releaseRepo pull . Release , release string ) * ShowCmd { return & ShowCmd { releaseRepo : releaseRepo , release : release , }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/runtime/runtime.go#L500-L503<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p GetPropertiesParams ) WithOwnProperties ( ownProperties bool ) * GetPropertiesParams { p . OwnProperties = ownProperties   return & p   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/css/easyjson.go#L3336-L3340<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * MediaQueryExpression ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoCss29 ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L57-L63<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p * Pushy ) DevicePresence ( deviceID ... string ) ( * DevicePresenceResponse , * Error , error ) { url := fmt . Sprintf ( " " , p . APIEndpoint , p . APIToken )   var devicePresenceResponse * DevicePresenceResponse   var pushyErr * Error   err := post ( p . httpClient , url , DevicePresenceRequest { Tokens : deviceID } , & devicePresenceResponse , & pushyErr )   return devicePresenceResponse , pushyErr , err   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/storage.go#L596-L598<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func getContainerMountPoint ( project string , poolName string , containerName string ) string { return shared . VarPath ( " " , poolName , " " , projectPrefix ( project , containerName ) )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/kube/client.go#L583-L593<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * Client ) CreateConfigMap ( content ConfigMap ) ( ConfigMap , error ) { c . log ( " " )   var retConfigMap ConfigMap   err := c . request ( & request { method : http . MethodPost , path : fmt . Sprintf ( " " , c . namespace ) , requestBody : & content , } , & retConfigMap )    return retConfigMap , err   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/go-opencv/go-opencv/blob/a4fe8ec027ccc9eb8b7d0797db7c76e61083f1db/opencv/cxtype.go#L526-L528<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( r * Rect ) TL ( ) Point { return Point { int ( r . x ) , int ( r . y ) }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/aphistic/gomol/blob/1546845ba714699f76f484ad3af64cf0503064d1/default.go#L136-L138<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func Infom ( m * Attrs , msg string , a ... interface { } ) error { return curDefault . Infom ( m , msg , a ... )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/bazelbuild/bazel-gazelle/blob/e3805aaca69a9deb949b47bfc45b9b1870712f4f/rule/rule.go#L812-L820<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ShouldKeep ( e bzl . Expr ) bool { for _ , c := range append ( e . Comment ( ) . Before , e . Comment ( ) . Suffix ... ) { text := strings . TrimSpace ( strings . TrimPrefix ( c . Token , " " ) )   if text == " " { return true   }   }   return false   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/opentracing/opentracing-go/blob/659c90643e714681897ec2521c60567dd21da733/log/field.go#L72-L78<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func Int32 ( key string , val int32 ) Field { return Field { key : key , fieldType : int32Type , numericVal : int64 ( val ) , }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/app/plan.go#L70-L88<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( s * planService ) ensureDefault ( ) error { plans , err := s . storage . FindAll ( )   if err != nil { return err   }   if len ( plans ) > 0 { return nil   }   configMemory , _ := config . GetInt ( " " )   configSwap , _ := config . GetInt ( " " )   dp := appTypes . Plan { Name : " " , Memory : int64 ( configMemory ) * 1024 * 1024 , Swap : int64 ( configSwap - configMemory ) * 1024 * 1024 , CpuShare : 100 , Default : true , }   return s . storage . Insert ( dp )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/nwaples/rardecode/blob/197ef08ef68c4454ae5970a9c2692d6056ceb8d7/decrypt_reader.go#L21-L56<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( cr * cipherBlockReader ) read ( p [ ] byte ) ( n int , err error ) { bs := cr . mode . BlockSize ( )   // round p down to a multiple of the block size l := len ( p ) - len ( p ) % bs   p = p [ : l ]    l = len ( cr . inbuf )   if l > 0 { // copy any buffered input into p copy ( p , cr . inbuf )   cr . inbuf = cr . inbuf [ : 0 ]   }   // read data for at least one block n , err = io . ReadAtLeast ( cr . r , p [ l : ] , bs - l )   n += l   p = p [ : n ]    l = n % bs   // check if p is a multiple of the cipher block size if l > 0 { n -= l   // save trailing partial block to process later cr . inbuf = append ( cr . inbuf , p [ n : ] ... )   p = p [ : n ]   }    if err != nil { if err == io . ErrUnexpectedEOF || err == io . ErrShortBuffer { // ignore trailing bytes < block size length err = io . EOF   }   return 0 , err   }   cr . mode . CryptBlocks ( p , p ) // decrypt block(s)   return n , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/client/lxd_storage_pools.go#L38-L52<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( r * ProtocolLXD ) GetStoragePools ( ) ( [ ] api . StoragePool , error ) { if ! r . HasExtension ( " " ) { return nil , fmt . Errorf ( " \" \" " )   }    pools := [ ] api . StoragePool { }    // Fetch the raw value _ , err := r . queryStruct ( " " , " " , nil , " " , & pools )   if err != nil { return nil , err   }    return pools , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/pact-foundation/pact-go/blob/467dea56d27e154363e1975f6e9f4dbf66148e79/dsl/mock_service.go#L71-L75<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( m * MockService ) DeleteInteractions ( ) error { log . Println ( " " )   url := fmt . Sprintf ( " " , m . BaseURL )   return m . call ( " " , url , nil )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/api/etcdhttp/base.go#L48-L56<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func HandleBasic ( mux * http . ServeMux , server etcdserver . ServerPeer ) { mux . HandleFunc ( varsPath , serveVars )    // TODO: deprecate '/config/local/log' in v3.5 mux . HandleFunc ( configPath + " " , logHandleFunc )    HandleMetricsHealth ( mux , server )   mux . HandleFunc ( versionPath , versionHandler ( server . Cluster ( ) , serveVersion ) )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/dom/dom.go#L277-L279<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p * FocusParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandFocus , p , nil )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/plank/controller.go#L153-L166<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * Controller ) setPreviousReportState ( pj prowapi . ProwJob ) error { // fetch latest before replace latestPJ , err := c . kc . GetProwJob ( pj . ObjectMeta . Name )   if err != nil { return err   }    if latestPJ . Status . PrevReportStates == nil { latestPJ . Status . PrevReportStates = map [ string ] prowapi . ProwJobState { }   }   latestPJ . Status . PrevReportStates [ reporter . GitHubReporterName ] = latestPJ . Status . State   _ , err = c . kc . ReplaceProwJob ( latestPJ . ObjectMeta . Name , latestPJ )   return err   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/containers.go#L494-L505<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * ClusterTx ) ContainerNodeList ( ) ( [ ] Container , error ) { node , err := c . NodeName ( )   if err != nil { return nil , errors . Wrap ( err , " " )   }   filter := ContainerFilter { Node : node , Type : int ( CTypeRegular ) , }    return c . ContainerList ( filter )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/target/easyjson.go#L196-L200<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * SetDiscoverTargetsParams ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget1 ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/overlay/easyjson.go#L1661-L1665<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v GetHighlightObjectForTestParams ) MarshalJSON ( ) ( [ ] byte , error ) { w := jwriter . Writer { }   easyjsonC5a4559bEncodeGithubComChromedpCdprotoOverlay16 ( & w , v )   return w . Buffer . BuildBytes ( ) , w . Error   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/storage_pools.go#L853-L855<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * Cluster ) StoragePoolNodeVolumeGetType ( volumeName string , volumeType int , poolID int64 ) ( int64 , * api . StorageVolume , error ) { return c . StoragePoolNodeVolumeGetTypeByProject ( " " , volumeName , volumeType , poolID )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/xwb1989/sqlparser/blob/120387863bf27d04bc07db8015110a6e96d0146c/ast.go#L76-L95<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ParseNext ( tokenizer * Tokenizer ) ( Statement , error ) { if tokenizer . lastChar == ';' { tokenizer . next ( )   tokenizer . skipBlank ( )   }   if tokenizer . lastChar == eofChar { return nil , io . EOF   }    tokenizer . reset ( )   tokenizer . multi = true   if yyParse ( tokenizer ) != 0 { if tokenizer . partialDDL != nil { tokenizer . ParseTree = tokenizer . partialDDL   return tokenizer . ParseTree , nil   }   return nil , tokenizer . LastError   }   return tokenizer . ParseTree , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/ipfs/go-ipfs-api/blob/a1b28da48b3763f67654ec4cfcba5fcbfb3dfb32/shell.go#L500-L504<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( s * Shell ) SwarmPeers ( ctx context . Context ) ( * SwarmConnInfos , error ) { v := & SwarmConnInfos { }   err := s . Request ( " " ) . Exec ( ctx , & v )   return v , err   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/go-opencv/go-opencv/blob/a4fe8ec027ccc9eb8b7d0797db7c76e61083f1db/opencv/cxcore.go#L621-L628<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func XorWithMask ( src1 , src2 , dst , mask * IplImage ) { C . cvXor ( unsafe . Pointer ( src1 ) , unsafe . Pointer ( src2 ) , unsafe . Pointer ( dst ) , unsafe . Pointer ( mask ) , )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/256dpi/fire/blob/fa66e74352b30b9a4c730f7b8dc773302941b0fb/callbacks.go#L155-L181<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func TimestampValidator ( ) * Callback { return C ( " " , Only ( Create , Update ) , func ( ctx * Context ) error { // get time now := time . Now ( )    // get timestamp fields ctf := coal . L ( ctx . Model , " " , false )   utf := coal . L ( ctx . Model , " " , false )    // set created timestamp on creation and set missing create timestamps // to the timestamp inferred from the model id if ctf != " " { if ctx . Operation == Create { ctx . Model . MustSet ( ctf , now )   } else if t := ctx . Model . MustGet ( ctf ) . ( time . Time ) ; t . IsZero ( ) { ctx . Model . MustSet ( ctf , ctx . Model . ID ( ) . Time ( ) )   }   }    // always set updated timestamp if utf != " " { ctx . Model . MustSet ( utf , now )   }    return nil   } )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/golang/appengine/blob/54a98f90d1c46b7731eb8fb305d2a321c30ef610/taskqueue/taskqueue.go#L444-L446<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func LeaseByTag ( c context . Context , maxTasks int , queueName string , leaseTime int , tag string ) ( [ ] * Task , error ) { return lease ( c , maxTasks , queueName , leaseTime , true , [ ] byte ( tag ) )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L6907-L6910<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( e ScpStatementType ) ValidEnum ( v int32 ) bool { _ , ok := scpStatementTypeMap [ v ]   return ok   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/TheThingsNetwork/go-utils/blob/aa2a11bd59104d2a8609328c2b2b55da61826470/log/logrus/logrus.go#L14-L16<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func Wrap ( logger * logrus . Logger ) log . Interface { return & logrusEntryWrapper { logrus . NewEntry ( logger ) }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/net_transport.go#L452-L455<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( n * NetworkTransport ) EncodePeer ( id ServerID , p ServerAddress ) [ ] byte { address := n . getProviderAddressOrFallback ( id , p )   return [ ] byte ( address )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/segmentio/objconv/blob/7a1d7b8e6f3551b30751e6b2ea6bae500883870e/codec.go#L15-L17<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c Codec ) NewEncoder ( w io . Writer ) * Encoder { return NewEncoder ( c . NewEmitter ( w ) )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/target/easyjson.go#L125-L129<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * SetRemoteLocationsParams ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdctl/ctlv3/command/lease_command.go#L119-L132<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func leaseTimeToLiveCommandFunc ( cmd * cobra . Command , args [ ] string ) { if len ( args ) != 1 { ExitWithError ( ExitBadArgs , fmt . Errorf ( " " ) )   }   var opts [ ] v3 . LeaseOption   if timeToLiveKeys { opts = append ( opts , v3 . WithAttachedKeys ( ) )   }   resp , rerr := mustClientFromCmd ( cmd ) . TimeToLive ( context . TODO ( ) , leaseFromArgs ( args [ 0 ] ) , opts ... )   if rerr != nil { ExitWithError ( ExitBadConnection , rerr )   }   display . TimeToLive ( * resp , timeToLiveKeys )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/pivotal-pez/pezdispenser/blob/768e2777520868857916b66cfd4cfb7149383ca5/fakes/fake.go#L98-L100<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( s * FakeSku ) New ( tm skurepo . TaskManager , procurementMeta map [ string ] interface { } ) skurepo . Sku { return s   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/reiver/go-telnet/blob/9ff0b2ab096ebe42bf8e2ffd1366e7ed2223b04c/server.go#L39-L43<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func Serve ( listener net . Listener , handler Handler ) error { server := & Server { Handler : handler }   return server . Serve ( listener )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/watch/watch.go#L96-L191<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func NewWatcher ( ctx context . Context , client * etcd . Client , trimPrefix , prefix string , template proto . Message , opts ... OpOption ) ( Watcher , error ) { eventCh := make ( chan * Event )   done := make ( chan struct { } )   // First list the collection to get the current items // Sort by mod revision--how the items would have been returned if we watched // them from the beginning. resp , err := client . Get ( ctx , prefix , etcd . WithPrefix ( ) , etcd . WithSort ( etcd . SortByModRevision , etcd . SortAscend ) )   if err != nil { return nil , err   }    nextRevision := resp . Header . Revision + 1   etcdWatcher := etcd . NewWatcher ( client )   // Issue a watch that uses the revision timestamp returned by the // Get request earlier.  That way even if some items are added between // when we list the collection and when we start watching the collection, // we won't miss any items. options := [ ] etcd . OpOption { etcd . WithPrefix ( ) , etcd . WithRev ( nextRevision ) }   for _ , opt := range opts { options = append ( options , etcd . OpOption ( opt ) )   }   rch := etcdWatcher . Watch ( ctx , prefix , options ... )    go func ( ) ( retErr error ) { defer func ( ) { if retErr != nil { select { case eventCh <- & Event { Err : retErr , Type : EventError , } : case <- done : }   }   close ( eventCh )   etcdWatcher . Close ( )   } ( )   for _ , etcdKv := range resp . Kvs { eventCh <- & Event { Key : bytes . TrimPrefix ( etcdKv . Key , [ ] byte ( trimPrefix ) ) , Value : etcdKv . Value , Type : EventPut , Rev : etcdKv . ModRevision , Template : template , }   }   for { var resp etcd . WatchResponse   var ok bool   select { case resp , ok = <- rch : case <- done : return nil   }   if ! ok { if err := etcdWatcher . Close ( ) ; err != nil { return err   }   etcdWatcher = etcd . NewWatcher ( client )   rch = etcdWatcher . Watch ( ctx , prefix , etcd . WithPrefix ( ) , etcd . WithRev ( nextRevision ) )   continue   }   if err := resp . Err ( ) ; err != nil { return err   }   for _ , etcdEv := range resp . Events { ev := & Event { Key : bytes . TrimPrefix ( etcdEv . Kv . Key , [ ] byte ( trimPrefix ) ) , Value : etcdEv . Kv . Value , Rev : etcdEv . Kv . ModRevision , Template : template , }   if etcdEv . PrevKv != nil { ev . PrevKey = bytes . TrimPrefix ( etcdEv . PrevKv . Key , [ ] byte ( trimPrefix ) )   ev . PrevValue = etcdEv . PrevKv . Value   }   if etcdEv . Type == etcd . EventTypePut { ev . Type = EventPut   } else { ev . Type = EventDelete   }   select { case eventCh <- ev : case <- done : return nil   }   }   nextRevision = resp . Header . Revision + 1   }   } ( )    return & watcher { eventCh : eventCh , done : done , } , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/fragmenting_writer.go#L152-L157<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( w * fragmentingWriter ) ArgWriter ( last bool ) ( ArgWriter , error ) { if err := w . BeginArgument ( last ) ; err != nil { return nil , err   }   return w , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L2844-L2853<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( u PathPaymentResult ) GetSuccess ( ) ( result PathPaymentResultSuccess , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Code ) )    if armName == " " { result = * u . Success   ok = true   }    return   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/shared/cmd/ask.go#L46-L58<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func AskInt ( question string , min int64 , max int64 , defaultAnswer string ) int64 { for { answer := askQuestion ( question , defaultAnswer )    result , err := strconv . ParseInt ( answer , 10 , 64 )    if err == nil && ( min == - 1 || result >= min ) && ( max == - 1 || result <= max ) { return result   }    invalidInput ( )   }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/iron-io/functions_go/blob/91b84f5bbb17095bf1c7028ec6e70a3dc06a5893/client/functions_client.go#L125-L136<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * Functions ) SetTransport ( transport runtime . ClientTransport ) { c . Transport = transport    c . Apps . SetTransport ( transport )    c . Routes . SetTransport ( transport )    c . Tasks . SetTransport ( transport )    c . Version . SetTransport ( transport )    }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/emulation/emulation.go#L388-L391<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p SetGeolocationOverrideParams ) WithLatitude ( latitude float64 ) * SetGeolocationOverrideParams { p . Latitude = latitude   return & p   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/tendermint/go-amino/blob/dc14acf9ef15f85828bfbc561ed9dd9d2a284885/binary-decode.go#L424-L544<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( cdc * Codec ) decodeReflectBinaryArray ( bz [ ] byte , info * TypeInfo , rv reflect . Value , fopts FieldOptions , bare bool ) ( n int , err error ) { if ! rv . CanAddr ( ) { panic ( " " )   }   if printLog { fmt . Println ( " " )   defer func ( ) { fmt . Printf ( " \n " , err )   } ( )   }   ert := info . Type . Elem ( )   if ert . Kind ( ) == reflect . Uint8 { panic ( " " )   }   length := info . Type . Len ( )   einfo , err := cdc . getTypeInfo_wlock ( ert )   if err != nil { return   }    if ! bare { // Read byte-length prefixed byteslice. var buf , _n = [ ] byte ( nil ) , int ( 0 )   buf , _n , err = DecodeByteSlice ( bz )   if slide ( & bz , nil , _n ) && err != nil { return   }   // This is a trick for debuggability -- we slide on &n more later. n += UvarintSize ( uint64 ( len ( buf ) ) )   bz = buf   }    // If elem is not already a ByteLength type, read in packed form. // This is a Proto wart due to Proto backwards compatibility issues. // Amino2 will probably migrate to use the List typ3. typ3 := typeToTyp3 ( einfo . Type , fopts )   if typ3 != Typ3_ByteLength { // Read elements in packed form. for i := 0 ; i < length ; i ++ { var erv , _n = rv . Index ( i ) , int ( 0 )   _n , err = cdc . decodeReflectBinary ( bz , einfo , erv , fopts , false )   if slide ( & bz , & n , _n ) && err != nil { err = fmt . Errorf ( " " , err )   return   }   // Special case when reading default value, prefer nil. if erv . Kind ( ) == reflect . Ptr { _ , isDefault := isDefaultValue ( erv )   if isDefault { erv . Set ( reflect . Zero ( erv . Type ( ) ) )   continue   }   }   }   // Ensure that we read the whole buffer. if len ( bz ) > 0 { err = errors . New ( " " )   return   }   } else { // NOTE: ert is for the element value, while einfo.Type is dereferenced. isErtStructPointer := ert . Kind ( ) == reflect . Ptr && einfo . Type . Kind ( ) == reflect . Struct    // Read elements in unpacked form. for i := 0 ; i < length ; i ++ { // Read field key (number and type). var fnum , typ , _n = uint32 ( 0 ) , Typ3 ( 0x00 ) , int ( 0 )   fnum , typ , _n , err = decodeFieldNumberAndTyp3 ( bz )   // Validate field number and typ3. if fnum != fopts . BinFieldNum { err = errors . New ( fmt . Sprintf ( " " , fopts . BinFieldNum , fnum ) )   return   }   if typ != Typ3_ByteLength { err = errors . New ( fmt . Sprintf ( " " , Typ3_ByteLength , typ ) )   return   }   if slide ( & bz , & n , _n ) && err != nil { return   }   // Decode the next ByteLength bytes into erv. var erv = rv . Index ( i )   // Special case if: //  * next ByteLength bytes are 0x00, and //  * - erv is not a struct pointer, or //    - field option doesn't have EmptyElements set // (the condition below uses demorgan's law) if ( len ( bz ) > 0 && bz [ 0 ] == 0x00 ) && ! ( isErtStructPointer && fopts . EmptyElements ) { slide ( & bz , & n , 1 )   erv . Set ( defaultValue ( erv . Type ( ) ) )   continue   }   // Normal case, read next non-nil element from bz. // In case of any inner lists in unpacked form. efopts := fopts   efopts . BinFieldNum = 1   _n , err = cdc . decodeReflectBinary ( bz , einfo , erv , efopts , false )   if slide ( & bz , & n , _n ) && err != nil { err = fmt . Errorf ( " " , err )   return   }   }   // Ensure that there are no more elements left, // and no field number regression either. // This is to provide better error messages. if len ( bz ) > 0 { var fnum = uint32 ( 0 )   fnum , _ , _ , err = decodeFieldNumberAndTyp3 ( bz )   if err != nil { return   }   if fnum <= fopts . BinFieldNum { err = fmt . Errorf ( " " , fnum , fopts . BinFieldNum )   return   }   }   }   return   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/layertree/types.go#L108-L110<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( t ScrollRectType ) MarshalEasyJSON ( out * jwriter . Writer ) { out . String ( string ( t ) )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/db/storage.go#L115-L120<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( s * Storage ) PoolsConstraints ( ) * storage . Collection { poolConstraintIndex := mgo . Index { Key : [ ] string { " " , " " } , Unique : true }   c := s . Collection ( " " )   c . EnsureIndex ( poolConstraintIndex )   return c   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/db/storage.go#L92-L97<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( s * Storage ) Apps ( ) * storage . Collection { nameIndex := mgo . Index { Key : [ ] string { " " } , Unique : true }   c := s . Collection ( " " )   c . EnsureIndex ( nameIndex )   return c   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/profitbricks/profitbricks-sdk-go/blob/1d2db5f00bf5dd0b6c29273541c71c60cdf4d4d4/usermanagment.go#L312-L317<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * Client ) ListResources ( ) ( * Resources , error ) { url := umResources ( ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty )   ret := & Resources { }   err := c . client . Get ( url , ret , http . StatusOK )   return ret , err   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/input/input.go#L559-L562<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p SynthesizeTapGestureParams ) WithDuration ( duration int64 ) * SynthesizeTapGestureParams { p . Duration = duration   return & p   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/client/lxd_containers.go#L1390-L1398<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( r * ProtocolLXD ) UpdateContainerState ( name string , state api . ContainerStatePut , ETag string ) ( Operation , error ) { // Send the request op , _ , err := r . queryOperation ( " " , fmt . Sprintf ( " " , url . QueryEscape ( name ) ) , state , ETag )   if err != nil { return nil , err   }    return op , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/raw/call.go#L86-L95<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func CallSC ( ctx context . Context , sc * tchannel . SubChannel , method string , arg2 , arg3 [ ] byte ) ( [ ] byte , [ ] byte , * tchannel . OutboundCallResponse , error ) { call , err := sc . BeginCall ( ctx , method , nil )   if err != nil { return nil , nil , nil , err   }    return WriteArgs ( call , arg2 , arg3 )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/dgraph-io/badger/blob/6b796b3ebec3ff006fcb1b425836cd784651e9fd/level_handler.go#L230-L257<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( s * levelHandler ) get ( key [ ] byte ) ( y . ValueStruct , error ) { tables , decr := s . getTableForKey ( key )   keyNoTs := y . ParseKey ( key )    var maxVs y . ValueStruct   for _ , th := range tables { if th . DoesNotHave ( keyNoTs ) { y . NumLSMBloomHits . Add ( s . strLevel , 1 )   continue   }    it := th . NewIterator ( false )   defer it . Close ( )    y . NumLSMGets . Add ( s . strLevel , 1 )   it . Seek ( key )   if ! it . Valid ( ) { continue   }   if y . SameKey ( key , it . Key ( ) ) { if version := y . ParseTs ( it . Key ( ) ) ; maxVs . Version < version { maxVs = it . Value ( )   maxVs . Version = version   }   }   }   return maxVs , decr ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/rsc/pdf/blob/c47d69cf462f804ff58ca63c61a8fb2aed76587e/read.go#L700-L706<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v Value ) Len ( ) int { x , ok := v . data . ( array )   if ! ok { return 0   }   return len ( x )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/api/iaas.go#L179-L205<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func templateDestroy ( w http . ResponseWriter , r * http . Request , token auth . Token ) ( err error ) { templateName := r . URL . Query ( ) . Get ( " " )   t , err := iaas . FindTemplate ( templateName )   if err != nil { if err == mgo . ErrNotFound { return & errors . HTTP { Code : http . StatusNotFound , Message : " " }   }   return err   }   iaasCtx := permission . Context ( permTypes . CtxIaaS , t . IaaSName )   allowed := permission . Check ( token , permission . PermMachineTemplateDelete , iaasCtx )   if ! allowed { return permission . ErrUnauthorized   }   evt , err := event . New ( & event . Opts { Target : event . Target { Type : event . TargetTypeIaas , Value : t . IaaSName } , Kind : permission . PermMachineTemplateDelete , Owner : token , CustomData : event . FormToCustomData ( InputFields ( r ) ) , Allowed : event . Allowed ( permission . PermMachineReadEvents , iaasCtx ) , } )   if err != nil { return err   }   defer func ( ) { evt . Done ( err ) } ( )   return iaas . DestroyTemplate ( templateName )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/weaveworks/mesh/blob/512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39/gossip_channel.go#L20-L28<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func newGossipChannel ( channelName string , ourself * localPeer , r * routes , g Gossiper , logger Logger ) * gossipChannel { return & gossipChannel { name : channelName , ourself : ourself , routes : r , gossiper : g , logger : logger , }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/ChrisTrenkamp/goxpath/blob/c385f95c6022e7756e91beac5f5510872f7dcb7d/tree/tree.go#L157-L166<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func GetAttribute ( n Elem , local , space string ) ( xml . Attr , bool ) { attrs := n . GetAttrs ( )   for _ , i := range attrs { attr := i . GetToken ( ) . ( xml . Attr )   if local == attr . Name . Local && space == attr . Name . Space { return attr , true   }   }   return xml . Attr { } , false   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/arguments.go#L120-L122<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func NewArgWriter ( writer io . WriteCloser , err error ) ArgWriteHelper { return ArgWriteHelper { writer , err }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/boskos/common/common.go#L153-L161<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( r * CommaSeparatedStrings ) Set ( value string ) error { if len ( * r ) > 0 { return errors . New ( " " )   }   for _ , rtype := range strings . Split ( value , " " ) { * r = append ( * r , rtype )   }   return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/repoowners/repoowners.go#L596-L598<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( o * RepoOwners ) IsNoParentOwners ( path string ) bool { return o . options [ path ] . NoParentOwners   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/io/easyjson.go#L248-L252<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * ReadReturns ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoIo2 ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/ledger_key.go#L39-L48<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( key * LedgerKey ) SetAccount ( account AccountId ) error { data := LedgerKeyAccount { account }   nkey , err := NewLedgerKey ( LedgerEntryTypeAccount , data )   if err != nil { return err   }    * key = nkey   return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/overlay/overlay.go#L99-L101<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p * HideHighlightParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandHideHighlight , nil , nil )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/glycerine/rbuf/blob/75b78581bebe959bc9a3df4c5f64e82c187d7531/rbuf.go#L530-L539<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( f * FixedSizeRingBuf ) DeleteMostRecentBytes ( n int ) { if n <= 0 { return   }   if n >= f . Readable { f . Readable = 0   return   }   f . Readable -= n   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/golang/debug/blob/19561fee47cf8cd0400d1b094c5898002f97cf90/internal/gocore/module.go#L98-L100<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( t * funcTab ) add ( min , max core . Address , f * Func ) { t . entries = append ( t . entries , funcTabEntry { min : min , max : max , f : f } )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/google/go-cmp/blob/6f77996f0c42f7b84e5a2b252227263f93432e9b/cmp/cmpopts/sort.go#L29-L36<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func SortSlices ( lessFunc interface { } ) cmp . Option { vf := reflect . ValueOf ( lessFunc )   if ! function . IsType ( vf . Type ( ) , function . Less ) || vf . IsNil ( ) { panic ( fmt . Sprintf ( " " , lessFunc ) )   }   ss := sliceSorter { vf . Type ( ) . In ( 0 ) , vf }   return cmp . FilterValues ( ss . filter , cmp . Transformer ( " " , ss . sort ) )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/TheThingsNetwork/go-utils/blob/aa2a11bd59104d2a8609328c2b2b55da61826470/log/filtered/filtered.go#L31-L36<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func Wrap ( logger log . Interface , filters ... Filter ) * Filtered { return & Filtered { Interface : logger , filters : filters , }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/api/node.go#L372-L399<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func listUnitsByNode ( w http . ResponseWriter , r * http . Request , t auth . Token ) error { address := r . URL . Query ( ) . Get ( " " )   _ , node , err := node . FindNode ( address )   if err != nil { if err == provision . ErrNodeNotFound { return & tsuruErrors . HTTP { Code : http . StatusNotFound , Message : err . Error ( ) , }   }   return err   }   hasAccess := permission . Check ( t , permission . PermNodeRead , permission . Context ( permTypes . CtxPool , node . Pool ( ) ) )   if ! hasAccess { return permission . ErrUnauthorized   }   units , err := node . Units ( )   if err != nil { return err   }   if len ( units ) == 0 { w . WriteHeader ( http . StatusNoContent )   return nil   }   w . Header ( ) . Set ( " " , " " )   return json . NewEncoder ( w ) . Encode ( units )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/golang/debug/blob/19561fee47cf8cd0400d1b094c5898002f97cf90/internal/gocore/type.go#L115-L217<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p * Process ) runtimeType2Type ( a core . Address ) * Type { if t := p . runtimeMap [ a ] ; t != nil { return t   }    // Read runtime._type.size r := region { p : p , a : a , typ : p . findType ( " " ) }   size := int64 ( r . Field ( " " ) . Uintptr ( ) )    // Find module this type is in. var m * module   for _ , x := range p . modules { if x . types <= a && a < x . etypes { m = x   break   }   }    // Read information out of the runtime._type. var name string   if m != nil { x := m . types . Add ( int64 ( r . Field ( " " ) . Int32 ( ) ) )   n := uint16 ( p . proc . ReadUint8 ( x . Add ( 1 ) ) ) << 8 + uint16 ( p . proc . ReadUint8 ( x . Add ( 2 ) ) )   b := make ( [ ] byte , n )   p . proc . ReadAt ( b , x . Add ( 3 ) )   name = string ( b )   if r . Field ( " " ) . Uint8 ( ) & uint8 ( p . rtConstants [ " " ] ) != 0 { name = name [ 1 : ]   }   } else { // A reflect-generated type. // TODO: The actual name is in the runtime.reflectOffs map. // Too hard to look things up in maps here, just allocate a placeholder for now. name = fmt . Sprintf ( " " , a )   }    // Read ptr/nonptr bits ptrSize := p . proc . PtrSize ( )   nptrs := int64 ( r . Field ( " " ) . Uintptr ( ) ) / ptrSize   var ptrs [ ] int64   if r . Field ( " " ) . Uint8 ( ) & uint8 ( p . rtConstants [ " " ] ) == 0 { gcdata := r . Field ( " " ) . Address ( )   for i := int64 ( 0 ) ; i < nptrs ; i ++ { if p . proc . ReadUint8 ( gcdata . Add ( i / 8 ) ) >> uint ( i % 8 ) & 1 != 0 { ptrs = append ( ptrs , i * ptrSize )   }   }   } else { // TODO: run GC program to get ptr indexes }    // Find a Type that matches this type. // (The matched type will be one constructed from DWARF info.) // It must match name, size, and pointer bits. var candidates [ ] * Type   for _ , t := range p . runtimeNameMap [ name ] { if size == t . Size && equal ( ptrs , t . ptrs ( ) ) { candidates = append ( candidates , t )   }   }   var t * Type   if len ( candidates ) > 0 { // If a runtime type matches more than one DWARF type, // pick one arbitrarily. // This looks mostly harmless. DWARF has some redundant entries. // For example, [32]uint8 appears twice. // TODO: investigate the reason for this duplication. t = candidates [ 0 ]   } else { // There's no corresponding DWARF type.  Make our own. t = & Type { Name : name , Size : size , Kind : KindStruct }   n := t . Size / ptrSize    // Types to use for ptr/nonptr fields of runtime types which // have no corresponding DWARF type. ptr := p . findType ( " " )   nonptr := p . findType ( " " )   if ptr == nil || nonptr == nil { panic ( " " )   }    for i := int64 ( 0 ) ; i < n ; i ++ { typ := nonptr   if len ( ptrs ) > 0 && ptrs [ 0 ] == i * ptrSize { typ = ptr   ptrs = ptrs [ 1 : ]   }   t . Fields = append ( t . Fields , Field { Name : fmt . Sprintf ( " " , i ) , Off : i * ptrSize , Type : typ , } )    }   if t . Size % ptrSize != 0 { // TODO: tail of <ptrSize data. }   }   // Memoize. p . runtimeMap [ a ] = t    return t   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/shared/idmap/shift_linux.go#L186-L199<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func SetCaps ( path string , caps [ ] byte , uid int64 ) error { cpath := C . CString ( path )   defer C . free ( unsafe . Pointer ( cpath ) )    ccaps := C . CString ( string ( caps ) )   defer C . free ( unsafe . Pointer ( ccaps ) )    r := C . set_vfs_ns_caps ( cpath , ccaps , C . ssize_t ( len ( caps ) ) , C . uint32_t ( uid ) )   if r != 0 { return fmt . Errorf ( " " , path )   }    return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/metadata/action.go#L52-L61<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( a * Action ) paramsByLocation ( loc Location ) [ ] string { var res [ ] string   for _ , p := range a . APIParams { if p . Location == loc { res = append ( res , p . Name )   }   }   sort . Strings ( res )   return res   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/cmd/branchprotector/protect.go#L203-L230<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p * protector ) UpdateOrg ( orgName string , org config . Org ) error { var repos [ ] string   if org . Protect != nil { // Strongly opinionated org, configure every repo in the org. rs , err := p . client . GetRepos ( orgName , false )   if err != nil { return fmt . Errorf ( " " , err )   }   for _ , r := range rs { if ! r . Archived { repos = append ( repos , r . Name )   }   }   } else { // Unopinionated org, just set explicitly defined repos for r := range org . Repos { repos = append ( repos , r )   }   }    for _ , repoName := range repos { repo := org . GetRepo ( repoName )   if err := p . UpdateRepo ( orgName , repoName , * repo ) ; err != nil { return fmt . Errorf ( " " , repoName , err )   }   }   return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/cmd/artifact-uploader/main.go#L106-L122<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func loadClusterConfig ( ) ( * rest . Config , error ) { clusterConfig , err := rest . InClusterConfig ( )   if err == nil { return clusterConfig , nil   }    credentials , err := clientcmd . NewDefaultClientConfigLoadingRules ( ) . Load ( )   if err != nil { return nil , fmt . Errorf ( " " , err )   }    clusterConfig , err = clientcmd . NewDefaultClientConfig ( * credentials , & clientcmd . ConfigOverrides { } ) . ClientConfig ( )   if err != nil { return nil , fmt . Errorf ( " " , err )   }   return clusterConfig , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/qor/roles/blob/d6375609fe3e5da46ad3a574fae244fb633e79c1/role.go#L87-L98<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( role * Role ) HasRole ( req * http . Request , user interface { } , roles ... string ) bool { if definitions := role . definitions ; definitions != nil { for _ , name := range roles { if definition , ok := definitions [ name ] ; ok { if definition ( req , user ) { return true   }   }   }   }   return false   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/layertree/easyjson.go#L130-L134<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v StickyPositionConstraint ) MarshalJSON ( ) ( [ ] byte , error ) { w := jwriter . Writer { }   easyjsonC5a4559bEncodeGithubComChromedpCdprotoLayertree ( & w , v )   return w . Buffer . BuildBytes ( ) , w . Error   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/google/go-cmp/blob/6f77996f0c42f7b84e5a2b252227263f93432e9b/cmp/cmpopts/ignore.go#L156-L178<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func IgnoreSliceElements ( discardFunc interface { } ) cmp . Option { vf := reflect . ValueOf ( discardFunc )   if ! function . IsType ( vf . Type ( ) , function . ValuePredicate ) || vf . IsNil ( ) { panic ( fmt . Sprintf ( " " , discardFunc ) )   }   return cmp . FilterPath ( func ( p cmp . Path ) bool { si , ok := p . Index ( - 1 ) . ( cmp . SliceIndex )   if ! ok { return false   }   if ! si . Type ( ) . AssignableTo ( vf . Type ( ) . In ( 0 ) ) { return false   }   vx , vy := si . Values ( )   if vx . IsValid ( ) && vf . Call ( [ ] reflect . Value { vx } ) [ 0 ] . Bool ( ) { return true   }   if vy . IsValid ( ) && vf . Call ( [ ] reflect . Value { vy } ) [ 0 ] . Bool ( ) { return true   }   return false   } , cmp . Ignore ( ) )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/containers.go#L619-L630<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * Cluster ) ContainerConfigGet ( id int , key string ) ( string , error ) { q := " "   value := " "   arg1 := [ ] interface { } { id , key }   arg2 := [ ] interface { } { & value }   err := dbQueryRowScan ( c . db , q , arg1 , arg2 )   if err == sql . ErrNoRows { return " " , ErrNoSuchObject   }    return value , err   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/storage_ceph_utils.go#L1078-L1239<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func cephContainerSnapshotDelete ( clusterName string , poolName string , volumeName string , volumeType string , snapshotName string , userName string ) int { logImageEntry := fmt . Sprintf ( " " , poolName , volumeType , volumeName )   logSnapshotEntry := fmt . Sprintf ( " " , poolName , volumeType , volumeName , snapshotName )    clones , err := cephRBDSnapshotListClones ( clusterName , poolName , volumeName , volumeType , snapshotName , userName )   if err != nil { if err != db . ErrNoSuchObject { logger . Errorf ( `Failed to list clones of RBD snapshot "%s" of RBD storage volume "%s": %s` , logSnapshotEntry , logImageEntry , err )   return - 1   }   logger . Debugf ( `RBD snapshot "%s" of RBD storage volume "%s" does not have any clones` , logSnapshotEntry , logImageEntry )    // unprotect err = cephRBDSnapshotUnprotect ( clusterName , poolName , volumeName , volumeType , snapshotName , userName )   if err != nil { logger . Errorf ( `Failed to unprotect RBD snapshot "%s" of RBD storage volume "%s": %s` , logSnapshotEntry , logImageEntry , err )   return - 1   }   logger . Debugf ( `Unprotected RBD snapshot "%s" of RBD storage volume "%s"` , logSnapshotEntry , logImageEntry )    // unmap err = cephRBDVolumeSnapshotUnmap ( clusterName , poolName , volumeName , volumeType , snapshotName , userName , true )   if err != nil { logger . Errorf ( `Failed to unmap RBD snapshot "%s" of RBD storage volume "%s": %s` , logSnapshotEntry , logImageEntry , err )   return - 1   }   logger . Debugf ( `Unmapped RBD snapshot "%s" of RBD storage volume "%s"` , logSnapshotEntry , logImageEntry )    // delete err = cephRBDSnapshotDelete ( clusterName , poolName , volumeName , volumeType , snapshotName , userName )   if err != nil { logger . Errorf ( `Failed to delete RBD snapshot "%s" of RBD storage volume "%s": %s` , logSnapshotEntry , logImageEntry , err )   return - 1   }   logger . Debugf ( `Deleted RBD snapshot "%s" of RBD storage volume "%s"` , logSnapshotEntry , logImageEntry )    // Only delete the parent image if it is a zombie. If it is not // we know that LXD is still using it. if strings . HasPrefix ( volumeType , " " ) { ret := cephContainerDelete ( clusterName , poolName , volumeName , volumeType , userName )   if ret < 0 { logger . Errorf ( `Failed to delete RBD storage volume "%s"` , logImageEntry )   return - 1   }   logger . Debugf ( `Deleted RBD storage volume "%s"` , logImageEntry )   }    return 0   } else { logger . Debugf ( `Detected "%v" as clones of RBD snapshot "%s" of RBD storage volume "%s"` , clones , logSnapshotEntry , logImageEntry )    canDelete := true   for _ , clone := range clones { clonePool , cloneType , cloneName , err := parseClone ( clone )   if err != nil { logger . Errorf ( `Failed to parse clone "%s" of RBD snapshot "%s" of RBD storage volume "%s"` , clone , logSnapshotEntry , logImageEntry )   return - 1   }   logger . Debugf ( `Split clone "%s" of RBD snapshot "%s" of RBD storage volume "%s" into pool name "%s", volume type "%s", and volume name "%s"` , clone , logSnapshotEntry , logImageEntry , clonePool , cloneType , cloneName )    if ! strings . HasPrefix ( cloneType , " " ) { canDelete = false   continue   }    ret := cephContainerDelete ( clusterName , clonePool , cloneName , cloneType , userName )   if ret < 0 { logger . Errorf ( `Failed to delete clone "%s" of RBD snapshot "%s" of RBD storage volume "%s"` , clone , logSnapshotEntry , logImageEntry )   return - 1   } else if ret == 1 { // Only marked as zombie canDelete = false   }   }    if canDelete { logger . Debugf ( `Deleted all clones of RBD snapshot "%s" of RBD storage volume "%s"` , logSnapshotEntry , logImageEntry )    // unprotect err = cephRBDSnapshotUnprotect ( clusterName , poolName , volumeName , volumeType , snapshotName , userName )   if err != nil { logger . Errorf ( `Failed to unprotect RBD snapshot "%s" of RBD storage volume "%s": %s` , logSnapshotEntry , logImageEntry , err )   return - 1   }   logger . Debugf ( `Unprotected RBD snapshot "%s" of RBD storage volume "%s"` , logSnapshotEntry , logImageEntry )    // unmap err = cephRBDVolumeSnapshotUnmap ( clusterName , poolName , volumeName , volumeType , snapshotName , userName , true )   if err != nil { logger . Errorf ( `Failed to unmap RBD snapshot "%s" of RBD storage volume "%s": %s` , logSnapshotEntry , logImageEntry , err )   return - 1   }   logger . Debugf ( `Unmapped RBD snapshot "%s" of RBD storage volume "%s"` , logSnapshotEntry , logImageEntry )    // delete err = cephRBDSnapshotDelete ( clusterName , poolName , volumeName , volumeType , snapshotName , userName )   if err != nil { logger . Errorf ( `Failed to delete RBD snapshot "%s" of RBD storage volume "%s": %s` , logSnapshotEntry , logImageEntry , err )   return - 1   }   logger . Debugf ( `Deleted RBD snapshot "%s" of RBD storage volume "%s"` , logSnapshotEntry , logImageEntry )    // Only delete the parent image if it is a zombie. If it // is not we know that LXD is still using it. if strings . HasPrefix ( volumeType , " " ) { ret := cephContainerDelete ( clusterName , poolName , volumeName , volumeType , userName )   if ret < 0 { logger . Errorf ( `Failed to delete RBD storage volume "%s"` , logImageEntry )   return - 1   }   logger . Debugf ( `Deleted RBD storage volume "%s"` , logImageEntry )   }   } else { logger . Debugf ( `Could not delete all clones of RBD snapshot "%s" of RBD storage volume "%s"` , logSnapshotEntry , logImageEntry )    if strings . HasPrefix ( snapshotName , " " ) { return 1   }    err := cephRBDVolumeSnapshotUnmap ( clusterName , poolName , volumeName , volumeType , snapshotName , userName , true )   if err != nil { logger . Errorf ( `Failed to unmap RBD snapshot "%s" of RBD storage volume "%s": %s` , logSnapshotEntry , logImageEntry , err )   return - 1   }   logger . Debug ( `Unmapped RBD snapshot "%s" of RBD storage volume "%s"` , logSnapshotEntry , logImageEntry )    newSnapshotName := fmt . Sprintf ( " " , snapshotName )   logSnapshotNewEntry := fmt . Sprintf ( " " , poolName , volumeName , volumeType , newSnapshotName )   err = cephRBDVolumeSnapshotRename ( clusterName , poolName , volumeName , volumeType , snapshotName , newSnapshotName , userName )   if err != nil { logger . Errorf ( `Failed to rename RBD snapshot "%s" of RBD storage volume "%s" to %s` , logSnapshotEntry , logImageEntry , logSnapshotNewEntry )   return - 1   }   logger . Debugf ( `Renamed RBD snapshot "%s" of RBD storage volume "%s" to %s` , logSnapshotEntry , logImageEntry , logSnapshotNewEntry )   }    }    return 1   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/css/easyjson.go#L4535-L4539<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v GetMediaQueriesParams ) MarshalJSON ( ) ( [ ] byte , error ) { w := jwriter . Writer { }   easyjsonC5a4559bEncodeGithubComChromedpCdprotoCss40 ( & w , v )   return w . Buffer . BuildBytes ( ) , w . Error   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/go-opencv/go-opencv/blob/a4fe8ec027ccc9eb8b7d0797db7c76e61083f1db/opencv/cxcore.go#L814-L816<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( seq * Seq ) Push ( element unsafe . Pointer ) unsafe . Pointer { return unsafe . Pointer ( C . cvSeqPush ( ( * C . struct_CvSeq ) ( seq ) , element ) )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/auth/options.go#L63-L94<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( opts * jwtOptions ) Parse ( optMap map [ string ] string ) error { var err error   if ttl := optMap [ optTTL ] ; ttl != " " { opts . TTL , err = time . ParseDuration ( ttl )   if err != nil { return err   }   }    if file := optMap [ optPublicKey ] ; file != " " { opts . PublicKey , err = ioutil . ReadFile ( file )   if err != nil { return err   }   }    if file := optMap [ optPrivateKey ] ; file != " " { opts . PrivateKey , err = ioutil . ReadFile ( file )   if err != nil { return err   }   }    // signing method is a required field method := optMap [ optSignMethod ]   opts . SignMethod = jwt . GetSigningMethod ( method )   if opts . SignMethod == nil { return ErrInvalidAuthMethod   }    return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/cert/logging_conn.go#L71-L77<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p * loggingPipe ) serverConn ( ) * loggingConn { return & loggingConn { pipe : p , r : p . serverReader , w : p . clientWriter , }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/storage/easyjson.go#L739-L743<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v EventIndexedDBContentUpdated ) MarshalJSON ( ) ( [ ] byte , error ) { w := jwriter . Writer { }   easyjsonC5a4559bEncodeGithubComChromedpCdprotoStorage8 ( & w , v )   return w . Buffer . BuildBytes ( ) , w . Error   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/raft/rawnode.go#L143-L150<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( rn * RawNode ) Propose ( data [ ] byte ) error { return rn . raft . Step ( pb . Message { Type : pb . MsgProp , From : rn . raft . id , Entries : [ ] pb . Entry { { Data : data } , } } )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/client/simplestreams.go#L21-L29<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( r * ProtocolSimpleStreams ) GetConnectionInfo ( ) ( * ConnectionInfo , error ) { info := ConnectionInfo { }   info . Addresses = [ ] string { r . httpHost }   info . Certificate = r . httpCertificate   info . Protocol = " "   info . URL = r . httpHost    return & info , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/domdebugger/domdebugger.go#L90-L95<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func RemoveDOMBreakpoint ( nodeID cdp . NodeID , typeVal DOMBreakpointType ) * RemoveDOMBreakpointParams { return & RemoveDOMBreakpointParams { NodeID : nodeID , Type : typeVal , }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/justinfx/gofileseq/blob/2555f296b4493d1825f5f6fab4aa0ff51a8306cd/exp/cpp/export/export.go#L611-L630<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func FindSequenceOnDiskPad ( pattern * C . char , padStyle C . int ) ( FileSeqId , Error ) { str := C . GoString ( pattern )   // Caller is responsible for freeing error string if str == " " { return 0 , C . CString ( " " )   }    fs , err := fileseq . FindSequenceOnDiskPad ( str , fileseq . PadStyle ( padStyle ) )   if err != nil { return 0 , C . CString ( err . Error ( ) )   }    // No Match if fs == nil { return 0 , nil   }    id := sFileSeqs . Add ( fs )   return id , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/llgcode/draw2d/blob/f52c8a71aff06ab8df41843d33ab167b36c971cd/draw2dbase/text.go#L58-L63<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( g * Glyph ) Copy ( ) * Glyph { return & Glyph { Path : g . Path . Copy ( ) , Width : g . Width , }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/net_transport.go#L366-L375<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( n * NetworkTransport ) AppendEntriesPipeline ( id ServerID , target ServerAddress ) ( AppendPipeline , error ) { // Get a connection conn , err := n . getConnFromAddressProvider ( id , target )   if err != nil { return nil , err   }    // Create the pipeline return newNetPipeline ( n , conn ) , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/urandom/handler/blob/61508044a5569d1609521d81e81f6737567fd104/response_wrapper.go#L31-L43<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( w * ResponseWrapper ) Hijack ( ) ( net . Conn , * bufio . ReadWriter , error ) { if hijacker , ok := w . writer . ( http . Hijacker ) ; ok { c , rw , err := hijacker . Hijack ( )    if err == nil { w . Hijacked = true   }    return c , rw , err   }    return nil , nil , errors . New ( " " )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/jhillyerd/enmime/blob/874cc30e023f36bd1df525716196887b0f04851b/builder.go#L149-L167<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p MailBuilder ) AddFileAttachment ( path string ) MailBuilder { // Only allow first p.err value if p . err != nil { return p   }   f , err := os . Open ( path )   if err != nil { p . err = err   return p   }   b , err := ioutil . ReadAll ( f )   if err != nil { p . err = err   return p   }   name := filepath . Base ( path )   ctype := mime . TypeByExtension ( filepath . Ext ( name ) )   return p . AddAttachment ( b , ctype , name )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/client/lxd_images.go#L640-L652<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( r * ProtocolLXD ) RefreshImage ( fingerprint string ) ( Operation , error ) { if ! r . HasExtension ( " " ) { return nil , fmt . Errorf ( " \" \" " )   }    // Send the request op , _ , err := r . queryOperation ( " " , fmt . Sprintf ( " " , url . QueryEscape ( fingerprint ) ) , nil , " " )   if err != nil { return nil , err   }    return op , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/cm15/codegen_client.go#L13033-L13040<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( r * Session ) Locator ( api * API ) * SessionLocator { for _ , l := range r . Links { if l [ " " ] == " " { return api . SessionLocator ( l [ " " ] )   }   }   return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/runtime/easyjson.go#L3250-L3254<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * EventInspectRequested ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoRuntime29 ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/runtime/easyjson.go#L1670-L1674<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * PropertyDescriptor ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoRuntime15 ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L7127-L7136<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( u ScpStatementPledges ) GetConfirm ( ) ( result ScpStatementConfirm , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) )    if armName == " " { result = * u . Confirm   ok = true   }    return   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/pivotal-pez/pezdispenser/blob/768e2777520868857916b66cfd4cfb7149383ca5/service/lease.go#L107-L125<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( s * Lease ) InitFromHTTPRequest ( req * http . Request ) ( err error ) { if req . Body != nil { if body , err := ioutil . ReadAll ( req . Body ) ; err == nil { if err = json . Unmarshal ( body , s ) ; err != nil { GLogger . Println ( err )   }   }   } else { err = ErrEmptyBody   }    if s . ProcurementMeta == nil { s . ProcurementMeta = make ( map [ string ] interface { } )   }   return   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/containers/image/blob/da9ab3561ad2031aeb5e036b7cf2755d4e246fec/image/docker_list.go#L83-L94<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ChooseManifestInstanceFromManifestList ( ctx context . Context , sys * types . SystemContext , src types . UnparsedImage ) ( digest . Digest , error ) { // For now this only handles manifest.DockerV2ListMediaType; we can generalize it later, // probably along with manifest list editing. blob , mt , err := src . Manifest ( ctx )   if err != nil { return " " , err   }   if mt != manifest . DockerV2ListMediaType { return " " , fmt . Errorf ( " " , mt )   }   return chooseDigestFromManifestList ( sys , blob )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/libp2p/go-libp2p-crypto/blob/9d2fed53443f745e6dc4d02bdcc94d9742a0ca84/ecdsa.go#L129-L140<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( ePriv * ECDSAPrivateKey ) Sign ( data [ ] byte ) ( [ ] byte , error ) { hash := sha256 . Sum256 ( data )   r , s , err := ecdsa . Sign ( rand . Reader , ePriv . priv , hash [ : ] )   if err != nil { return nil , err   }    return asn1 . Marshal ( ECDSASig { R : r , S : s , } )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/containers/image/blob/da9ab3561ad2031aeb5e036b7cf2755d4e246fec/ostree/ostree_transport.go#L138-L140<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( ref ostreeReference ) StringWithinTransport ( ) string { return fmt . Sprintf ( " " , ref . image , ref . repo )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/gobuffalo/buffalo/blob/7f360181f4ccd79dcc9dcea2c904a4801f194f04/servers/listener.go#L16-L20<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( s * Listener ) SetAddr ( addr string ) { if s . Server . Addr == " " { s . Server . Addr = addr   }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/overlay/easyjson.go#L951-L955<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v HighlightQuadParams ) MarshalJSON ( ) ( [ ] byte , error ) { w := jwriter . Writer { }   easyjsonC5a4559bEncodeGithubComChromedpCdprotoOverlay10 ( & w , v )   return w . Buffer . BuildBytes ( ) , w . Error   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/network/easyjson.go#L6772-L6776<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v EventRequestIntercepted ) MarshalJSON ( ) ( [ ] byte , error ) { w := jwriter . Writer { }   easyjsonC5a4559bEncodeGithubComChromedpCdprotoNetwork52 ( & w , v )   return w . Buffer . BuildBytes ( ) , w . Error   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kpango/glg/blob/68d2670cb2dbff047331daad841149a82ac37796/glg.go#L762-L764<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func Infof ( format string , val ... interface { } ) error { return glg . out ( INFO , format , val ... )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/golang/appengine/blob/54a98f90d1c46b7731eb8fb305d2a321c30ef610/image/image.go#L57-L63<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func DeleteServingURL ( c context . Context , key appengine . BlobKey ) error { req := & pb . ImagesDeleteUrlBaseRequest { BlobKey : ( * string ) ( & key ) , }   res := & pb . ImagesDeleteUrlBaseResponse { }   return internal . Call ( c , " " , " " , req , res )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/plugins/approve/approvers/owners.go#L525-L533<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( ap Approvers ) ListNoIssueApprovals ( ) [ ] Approval { approvals := [ ] Approval { }    for _ , approver := range ap . GetNoIssueApproversSet ( ) . List ( ) { approvals = append ( approvals , ap . approvers [ approver ] )   }    return approvals   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/dom/easyjson.go#L2889-L2893<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v GetSearchResultsReturns ) MarshalJSON ( ) ( [ ] byte , error ) { w := jwriter . Writer { }   easyjsonC5a4559bEncodeGithubComChromedpCdprotoDom32 ( & w , v )   return w . Buffer . BuildBytes ( ) , w . Error   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/naoina/genmai/blob/78583835e1e41e3938e1ddfffd7101f8ad27fae0/genmai.go#L804-L811<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( db * DB ) hasPKTag ( field * reflect . StructField ) bool { for _ , tag := range db . tagsFromField ( field ) { if tag == " " { return true   }   }   return false   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/pod-utils/decorate/podspec.go#L145-L185<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ProwJobToPod ( pj prowapi . ProwJob , buildID string ) ( * coreapi . Pod , error ) { if pj . Spec . PodSpec == nil { return nil , fmt . Errorf ( " " , pj . Name )   }    rawEnv , err := downwardapi . EnvForSpec ( downwardapi . NewJobSpec ( pj . Spec , buildID , pj . Name ) )   if err != nil { return nil , err   }    spec := pj . Spec . PodSpec . DeepCopy ( )   spec . RestartPolicy = " "   spec . Containers [ 0 ] . Name = kube . TestContainerName    // if the user has not provided a serviceaccount to use or explicitly // requested mounting the default token, we treat the unset value as // false, while kubernetes treats it as true if it is unset because // it was added in v1.6 if spec . AutomountServiceAccountToken == nil && spec . ServiceAccountName == " " { myFalse := false   spec . AutomountServiceAccountToken = & myFalse   }    if pj . Spec . DecorationConfig == nil { spec . Containers [ 0 ] . Env = append ( spec . Containers [ 0 ] . Env , kubeEnv ( rawEnv ) ... )   } else { if err := decorate ( spec , & pj , rawEnv ) ; err != nil { return nil , fmt . Errorf ( " " , err )   }   }    podLabels , annotations := LabelsAndAnnotationsForJob ( pj )   return & coreapi . Pod { ObjectMeta : metav1 . ObjectMeta { Name : pj . ObjectMeta . Name , Labels : podLabels , Annotations : annotations , } , Spec : * spec , } , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/container_lxc.go#L8551-L8596<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * containerLXC ) setNetworkPriority ( ) error { // Check that the container is running if ! c . IsRunning ( ) { return fmt . Errorf ( " " )   }    // Don't bother if the cgroup controller doesn't exist if ! c . state . OS . CGroupNetPrioController { return nil   }    // Extract the current priority networkPriority := c . expandedConfig [ " " ]   if networkPriority == " " { networkPriority = " "   }    networkInt , err := strconv . Atoi ( networkPriority )   if err != nil { return err   }    // Get all the interfaces netifs , err := net . Interfaces ( )   if err != nil { return err   }    // Check that we at least succeeded to set an entry success := false   var last_error error   for _ , netif := range netifs { err = c . CGroupSet ( " " , fmt . Sprintf ( " " , netif . Name , networkInt ) )   if err == nil { success = true   } else { last_error = err   }   }    if ! success { return fmt . Errorf ( " " , last_error )   }    return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/runtime/easyjson.go#L774-L778<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * RunIfWaitingForDebuggerParams ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoRuntime7 ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/llgcode/draw2d/blob/f52c8a71aff06ab8df41843d33ab167b36c971cd/draw2dbase/flattener.go#L31-L72<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func Flatten ( path * draw2d . Path , flattener Flattener , scale float64 ) { // First Point var startX , startY float64 = 0 , 0   // Current Point var x , y float64 = 0 , 0   i := 0   for _ , cmp := range path . Components { switch cmp { case draw2d . MoveToCmp : x , y = path . Points [ i ] , path . Points [ i + 1 ]   startX , startY = x , y   if i != 0 { flattener . End ( )   }   flattener . MoveTo ( x , y )   i += 2   case draw2d . LineToCmp : x , y = path . Points [ i ] , path . Points [ i + 1 ]   flattener . LineTo ( x , y )   flattener . LineJoin ( )   i += 2   case draw2d . QuadCurveToCmp : TraceQuad ( flattener , path . Points [ i - 2 : ] , 0.5 )   x , y = path . Points [ i + 2 ] , path . Points [ i + 3 ]   flattener . LineTo ( x , y )   i += 4   case draw2d . CubicCurveToCmp : TraceCubic ( flattener , path . Points [ i - 2 : ] , 0.5 )   x , y = path . Points [ i + 4 ] , path . Points [ i + 5 ]   flattener . LineTo ( x , y )   i += 6   case draw2d . ArcToCmp : x , y = TraceArc ( flattener , path . Points [ i ] , path . Points [ i + 1 ] , path . Points [ i + 2 ] , path . Points [ i + 3 ] , path . Points [ i + 4 ] , path . Points [ i + 5 ] , scale )   flattener . LineTo ( x , y )   i += 6   case draw2d . CloseCmp : flattener . LineTo ( startX , startY )   flattener . Close ( )   }   }   flattener . End ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/client/events.go#L50-L70<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( e * EventListener ) RemoveHandler ( target * EventTarget ) error { if target == nil { return fmt . Errorf ( " " )   }    // Handle locking e . targetsLock . Lock ( )   defer e . targetsLock . Unlock ( )    // Locate and remove the function from the list for i , entry := range e . targets { if entry == target { copy ( e . targets [ i : ] , e . targets [ i + 1 : ] )   e . targets [ len ( e . targets ) - 1 ] = nil   e . targets = e . targets [ : len ( e . targets ) - 1 ]   return nil   }   }    return fmt . Errorf ( " " )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/omniscale/go-mapnik/blob/710dfcc5e486e5760d0a5c46be909d91968e1ffb/mapnik.go#L354-L372<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( m * Map ) RenderToFile ( opts RenderOpts , path string ) error { scaleFactor := opts . ScaleFactor   if scaleFactor == 0.0 { scaleFactor = 1.0   }   cs := C . CString ( path )   defer C . free ( unsafe . Pointer ( cs ) )   var format * C . char   if opts . Format != " " { format = C . CString ( opts . Format )   } else { format = C . CString ( " " )   }   defer C . free ( unsafe . Pointer ( format ) )   if C . mapnik_map_render_to_file ( m . m , cs , C . double ( opts . Scale ) , C . double ( scaleFactor ) , format ) != 0 { return m . lastError ( )   }   return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/hooklift/govix/blob/063702285520a992b920fc1575e305dc9ffd6ffe/vm.go#L557-L590<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * VM ) Clone ( cloneType CloneType , destVmxFile string ) ( * VM , error ) { var jobHandle C . VixHandle = C . VIX_INVALID_HANDLE   var clonedHandle C . VixHandle = C . VIX_INVALID_HANDLE   var err C . VixError = C . VIX_OK    dstVmxFile := C . CString ( destVmxFile )   defer C . free ( unsafe . Pointer ( dstVmxFile ) )    jobHandle = C . VixVM_Clone ( v . handle , C . VIX_INVALID_HANDLE , // snapshotHandle C . VixCloneType ( cloneType ) , // cloneType dstVmxFile , // destConfigPathName 0 , // options, C . VIX_INVALID_HANDLE , // propertyListHandle nil , // callbackProc nil ) // clientData    defer C . Vix_ReleaseHandle ( jobHandle )    err = C . get_vix_handle ( jobHandle , C . VIX_PROPERTY_JOB_RESULT_HANDLE , & clonedHandle , C . VIX_PROPERTY_NONE )    if C . VIX_OK != err { return nil , & Error { Operation : " " , Code : int ( err & 0xFFFF ) , Text : C . GoString ( C . Vix_GetErrorText ( err , nil ) ) , }   }    return NewVirtualMachine ( clonedHandle , destVmxFile )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/profiles.go#L182-L239<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * Cluster ) ProfileConfig ( project , name string ) ( map [ string ] string , error ) { err := c . Transaction ( func ( tx * ClusterTx ) error { enabled , err := tx . ProjectHasProfiles ( project )   if err != nil { return errors . Wrap ( err , " " )   }   if ! enabled { project = " "   }   return nil   } )   if err != nil { return nil , err   }    var key , value string   query := `         SELECT             key, value         FROM profiles_config         JOIN profiles ON profiles_config.profile_id=profiles.id         JOIN projects ON projects.id = profiles.project_id         WHERE projects.name=? AND profiles.name=?`   inargs := [ ] interface { } { project , name }   outfmt := [ ] interface { } { key , value }   results , err := queryScan ( c . db , query , inargs , outfmt )   if err != nil { return nil , errors . Wrapf ( err , " " , name )   }    if len ( results ) == 0 { /* 		 * If we didn't get any rows here, let's check to make sure the 		 * profile really exists; if it doesn't, let's send back a 404. 		 */ query := " "   var id int   results , err := queryScan ( c . db , query , [ ] interface { } { name } , [ ] interface { } { id } )   if err != nil { return nil , err   }    if len ( results ) == 0 { return nil , ErrNoSuchObject   }   }    config := map [ string ] string { }    for _ , r := range results { key = r [ 0 ] . ( string )   value = r [ 1 ] . ( string )    config [ key ] = value   }    return config , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/debugger/types.go#L314-L316<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( t * ContinueToLocationTargetCallFrames ) UnmarshalJSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/clientv3/watch.go#L732-L826<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( w * watchGrpcStream ) serveSubstream ( ws * watcherStream , resumec chan struct { } ) { if ws . closing { panic ( " " )   }    // nextRev is the minimum expected next revision nextRev := ws . initReq . rev   resuming := false   defer func ( ) { if ! resuming { ws . closing = true   }   close ( ws . donec )   if ! resuming { w . closingc <- ws   }   w . wg . Done ( )   } ( )    emptyWr := & WatchResponse { }   for { curWr := emptyWr   outc := ws . outc    if len ( ws . buf ) > 0 { curWr = ws . buf [ 0 ]   } else { outc = nil   }   select { case outc <- * curWr : if ws . buf [ 0 ] . Err ( ) != nil { return   }   ws . buf [ 0 ] = nil   ws . buf = ws . buf [ 1 : ]   case wr , ok := <- ws . recvc : if ! ok { // shutdown from closeSubstream return   }    if wr . Created { if ws . initReq . retc != nil { ws . initReq . retc <- ws . outc   // to prevent next write from taking the slot in buffered channel // and posting duplicate create events ws . initReq . retc = nil    // send first creation event only if requested if ws . initReq . createdNotify { ws . outc <- * wr   }   // once the watch channel is returned, a current revision // watch must resume at the store revision. This is necessary // for the following case to work as expected: //	wch := m1.Watch("a") //	m2.Put("a", "b") //	<-wch // If the revision is only bound on the first observed event, // if wch is disconnected before the Put is issued, then reconnects // after it is committed, it'll miss the Put. if ws . initReq . rev == 0 { nextRev = wr . Header . Revision   }   }   } else { // current progress of watch; <= store revision nextRev = wr . Header . Revision   }    if len ( wr . Events ) > 0 { nextRev = wr . Events [ len ( wr . Events ) - 1 ] . Kv . ModRevision + 1   }   ws . initReq . rev = nextRev    // created event is already sent above, // watcher should not post duplicate events if wr . Created { continue   }    // TODO pause channel if buffer gets too large ws . buf = append ( ws . buf , wr )   case <- w . ctx . Done ( ) : return   case <- ws . initReq . ctx . Done ( ) : return   case <- resumec : resuming = true   return   }   }   // lazily send cancel message if events on missing id }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/pod-utils/clone/clone.go#L156-L169<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( g * gitCtx ) gitHeadTimestamp ( ) ( int , error ) { gitShowCommand := g . gitCommand ( " " , " " , " " , " " )   _ , gitOutput , err := gitShowCommand . run ( )   if err != nil { logrus . WithError ( err ) . Debug ( " " )   return 0 , err   }   timestamp , convErr := strconv . Atoi ( string ( gitOutput ) )   if convErr != nil { logrus . WithError ( convErr ) . Errorf ( " " , gitOutput )   return 0 , convErr   }   return timestamp , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/app/app.go#L1294-L1303<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( app * App ) Run ( cmd string , w io . Writer , args provision . RunArgs ) error { if ! args . Isolated && ! app . available ( ) { return errors . New ( " " )   }   app . Log ( fmt . Sprintf ( " " , cmd ) , " " , " " )   logWriter := LogWriter { App : app , Source : " " }   logWriter . Async ( )   defer logWriter . Close ( )   return app . run ( cmd , io . MultiWriter ( w , & logWriter ) , args )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/weaveworks/mesh/blob/512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39/router.go#L214-L220<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( router * Router ) sendPendingGossip ( ) bool { sentSomething := false   for conn := range router . Ourself . getConnections ( ) { sentSomething = conn . ( gossipConnection ) . gossipSenders ( ) . Flush ( ) || sentSomething   }   return sentSomething   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/backup.go#L55-L80<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func backupCreate ( s * state . State , args db . ContainerBackupArgs , sourceContainer container ) error { // Create the database entry err := s . Cluster . ContainerBackupCreate ( args )   if err != nil { if err == db . ErrAlreadyDefined { return fmt . Errorf ( " " , args . Name )   }    return errors . Wrap ( err , " " )   }    // Get the backup struct b , err := backupLoadByName ( s , sourceContainer . Project ( ) , args . Name )   if err != nil { return errors . Wrap ( err , " " )   }    // Now create the empty snapshot err = sourceContainer . Storage ( ) . ContainerBackupCreate ( * b , sourceContainer )   if err != nil { s . Cluster . ContainerBackupRemove ( args . Name )   return errors . Wrap ( err , " " )   }    return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/ccding/go-config-reader/blob/8b6c2b50197f20da3b1c5944c274c173634dc056/config/config.go#L165-L175<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func checkSection ( line string ) ( string , bool ) { line = strings . TrimSpace ( line )   lineLen := len ( line )   if lineLen < 2 { return " " , false   }   if line [ 0 ] == '[' && line [ lineLen - 1 ] == ']' { return line [ 1 : lineLen - 1 ] , true   }   return " " , false   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/ant0ine/go-json-rest/blob/ebb33769ae013bd5f518a8bac348c310dea768b8/rest/recorder.go#L92-L100<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( w * recorderResponseWriter ) Write ( b [ ] byte ) ( int , error ) { if ! w . wroteHeader { w . WriteHeader ( http . StatusOK )   }   writer := w . ResponseWriter . ( http . ResponseWriter )   written , err := writer . Write ( b )   w . bytesWritten += int64 ( written )   return written , err   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/olorin/nagiosplugin/blob/893f9702af4ea1e2dc4cd6528cbdcdb3dc7ca064/perfdata.go#L99-L105<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p PerfDatum ) String ( ) string { val := fmtPerfFloat ( p . value )   value := fmt . Sprintf ( " " , p . label , val , p . unit )   value += fmt . Sprintf ( " " , fmtThreshold ( p . warn ) , fmtThreshold ( p . crit ) )   value += fmt . Sprintf ( " " , fmtThreshold ( p . min ) , fmtThreshold ( p . max ) )   return value   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/schema/schema.go#L292-L338<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func queryCurrentVersion ( tx * sql . Tx ) ( int , error ) { versions , err := selectSchemaVersions ( tx )   if err != nil { return - 1 , fmt . Errorf ( " " , err )   }    // Fix bad upgrade code between 30 and 32 hasVersion := func ( v int ) bool { return shared . IntInSlice ( v , versions ) }   if hasVersion ( 30 ) && hasVersion ( 32 ) && ! hasVersion ( 31 ) { err = insertSchemaVersion ( tx , 31 )   if err != nil { return - 1 , fmt . Errorf ( " " )   }    versions , err = selectSchemaVersions ( tx )   if err != nil { return - 1 , fmt . Errorf ( " " , err )   }   }    // Fix broken schema version between 37 and 38 if hasVersion ( 37 ) && ! hasVersion ( 38 ) { count , err := query . Count ( tx , " " , " " )   if err != nil { return - 1 , fmt . Errorf ( " " , err )   }   if count == 1 { // Insert the missing version. err := insertSchemaVersion ( tx , 38 )   if err != nil { return - 1 , fmt . Errorf ( " " )   }   versions = append ( versions , 38 )   }   }    current := 0   if len ( versions ) > 0 { err = checkSchemaVersionsHaveNoHoles ( versions )   if err != nil { return - 1 , err   }   current = versions [ len ( versions ) - 1 ] // Highest recorded version   }    return current , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/github/client.go#L2681-L2699<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * Client ) CreateProjectCard ( columnID int , projectCard ProjectCard ) ( * ProjectCard , error ) { c . log ( " " , columnID , projectCard )   if ( projectCard . ContentType != " " ) && ( projectCard . ContentType != " " ) { return nil , errors . New ( " " )   }   if c . dry { return & projectCard , nil   }   path := fmt . Sprintf ( " " , columnID )   var retProjectCard ProjectCard   _ , err := c . request ( & request { method : http . MethodPost , path : path , accept : " " , requestBody : & projectCard , exitCodes : [ ] int { 200 } , } , & retProjectCard )   return & retProjectCard , err   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/runtime/easyjson.go#L1028-L1032<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * RemoteObject ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoRuntime9 ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/input/input.go#L330-L333<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p EmulateTouchFromMouseEventParams ) WithDeltaX ( deltaX float64 ) * EmulateTouchFromMouseEventParams { p . DeltaX = deltaX   return & p   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/coryb/figtree/blob/e5fa026ccd54e0a6a99b6d81f73bfcc8e6fe6a6b/figtree.go#L547-L589<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( m * Merger ) setSource ( v reflect . Value ) { if v . Kind ( ) == reflect . Ptr { v = v . Elem ( )   }   switch v . Kind ( ) { case reflect . Map : for _ , key := range v . MapKeys ( ) { keyval := v . MapIndex ( key )   if keyval . Kind ( ) == reflect . Struct && keyval . FieldByName ( " " ) . IsValid ( ) { // map values are immutable, so we need to copy the value // update the value, then re-insert the value to the map newval := reflect . New ( keyval . Type ( ) )   newval . Elem ( ) . Set ( keyval )   m . setSource ( newval )   v . SetMapIndex ( key , newval . Elem ( ) )   }   }   case reflect . Struct : if v . CanAddr ( ) { if option , ok := v . Addr ( ) . Interface ( ) . ( option ) ; ok { if option . IsDefined ( ) { option . SetSource ( m . sourceFile )   }   return   }   }   for i := 0 ; i < v . NumField ( ) ; i ++ { structField := v . Type ( ) . Field ( i )   // PkgPath is empty for upper case (exported) field names. if structField . PkgPath != " " { // unexported field, skipping continue   }   m . setSource ( v . Field ( i ) )   }   case reflect . Array : fallthrough   case reflect . Slice : for i := 0 ; i < v . Len ( ) ; i ++ { m . setSource ( v . Index ( i ) )   }   }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/shared/cmd/ask.go#L120-L124<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func askQuestion ( question , defaultAnswer string ) string { fmt . Printf ( question )    return readAnswer ( defaultAnswer )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/sclevine/agouti/blob/96599c91888f1b1cf2dccc7f1776ba7f511909e5/page.go#L283-L289<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p * Page ) PopupText ( ) ( string , error ) { text , err := p . session . GetAlertText ( )   if err != nil { return " " , fmt . Errorf ( " " , err )   }   return text , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/segmentio/nsq-go/blob/ff4eef968f46eb580d9dba4f637c5dfb1e5b2208/auth.go#L25-L42<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c Auth ) Write ( w * bufio . Writer ) ( err error ) { if _ , err = w . WriteString ( " \n " ) ; err != nil { err = errors . Wrap ( err , " " )   return   }    if err = binary . Write ( w , binary . BigEndian , uint32 ( len ( c . Secret ) ) ) ; err != nil { err = errors . Wrap ( err , " " )   return   }    if _ , err = w . WriteString ( c . Secret ) ; err != nil { err = errors . Wrap ( err , " " )   return   }    return   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/armon/go-radix/blob/1a2de0c21c94309923825da3df33a4381872c795/radix.go#L116-L122<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func NewFromMap ( m map [ string ] interface { } ) * Tree { t := & Tree { root : & node { } }   for k , v := range m { t . Insert ( k , v )   }   return t   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/workload/workload.go#L121-L151<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( w * worker ) advanceCommit ( c * client . APIClient ) error { if len ( w . started ) >= maxStartedCommits || len ( w . finished ) == 0 { // Randomly select a commit that has been started and finish it if len ( w . started ) == 0 { return nil   }   i := w . rand . Intn ( len ( w . started ) )   commit := w . started [ i ]    // Before we finish a commit, we add a file. This assures that there // won't be any empty commits which will later crash jobs if _ , err := c . PutFile ( commit . Repo . Name , commit . ID , w . randString ( 10 ) , w . reader ( ) ) ; err != nil { return err   }   if err := c . FinishCommit ( commit . Repo . Name , commit . ID ) ; err != nil { return err   }   // remove commit[i] from 'started' and add it to 'finished' w . started = append ( w . started [ : i ] , w . started [ i + 1 : ] ... )   w . finished = append ( w . finished , commit )   } else { // Start a new commmit (parented off of a commit that we've finished) commit := w . finished [ w . rand . Intn ( len ( w . finished ) ) ]   commit , err := c . StartCommitParent ( commit . Repo . Name , " " , commit . ID )   if err != nil { return err   }   w . started = append ( w . started , commit )   }   return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/plugin/vault/pachyderm/revoke.go#L18-L53<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( b * backend ) Revoke ( ctx context . Context , req * logical . Request , data * framework . FieldData ) ( resp * logical . Response , retErr error ) { b . Logger ( ) . Debug ( fmt . Sprintf ( " " , req . ID , req . Operation , req . Path ) )   defer func ( ) { b . Logger ( ) . Debug ( fmt . Sprintf ( " " , req . ID , req . Operation , req . Path , retErr == nil && ! resp . IsError ( ) ) )   } ( )    // Extract pachyderm token from vault secret tokenIface , ok := req . Secret . InternalData [ " " ]   if ! ok { return nil , fmt . Errorf ( " " )   }   userToken , ok := tokenIface . ( string )   if ! ok { return nil , fmt . Errorf ( " " , tokenIface )   }    // Get pach address and admin token from config config , err := getConfig ( ctx , req . Storage )   if err != nil { return nil , err   }   if len ( config . AdminToken ) == 0 { return nil , errors . New ( " " )   }   if len ( config . PachdAddress ) == 0 { return nil , errors . New ( " " )   }    // Revoke creds err = revokeUserCredentials ( ctx , config . PachdAddress , userToken , config . AdminToken )   if err != nil { return nil , err   }    return & logical . Response { } , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/qor/roles/blob/d6375609fe3e5da46ad3a574fae244fb633e79c1/permission.go#L50-L74<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( permission * Permission ) Concat ( newPermission * Permission ) * Permission { var result = Permission { Role : Global , AllowedRoles : map [ PermissionMode ] [ ] string { } , DeniedRoles : map [ PermissionMode ] [ ] string { } , }    var appendRoles = func ( p * Permission ) { if p != nil { result . Role = p . Role    for mode , roles := range p . DeniedRoles { result . DeniedRoles [ mode ] = append ( result . DeniedRoles [ mode ] , roles ... )   }    for mode , roles := range p . AllowedRoles { result . AllowedRoles [ mode ] = append ( result . AllowedRoles [ mode ] , roles ... )   }   }   }    appendRoles ( newPermission )   appendRoles ( permission )   return & result   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/containers/image/blob/da9ab3561ad2031aeb5e036b7cf2755d4e246fec/openshift/openshift-copies.go#L98-L112<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func newOpenShiftClientConfigLoadingRules ( ) * clientConfigLoadingRules { chain := [ ] string { }    envVarFile := os . Getenv ( " " )   if len ( envVarFile ) != 0 { chain = append ( chain , filepath . SplitList ( envVarFile ) ... )   } else { chain = append ( chain , recommendedHomeFile )   }    return & clientConfigLoadingRules { Precedence : chain , // REMOVED: Migration support; run (oc login) to trigger migration }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/relay_messages.go#L188-L198<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func finishesCall ( f * Frame ) bool { switch f . messageType ( ) { case messageTypeError : return true   case messageTypeCallRes , messageTypeCallResContinue : flags := f . Payload [ _flagsIndex ]   return flags & hasMoreFragmentsFlag == 0   default : return false   }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/containers/image/blob/da9ab3561ad2031aeb5e036b7cf2755d4e246fec/image/unparsed.go#L86-L95<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( i * UnparsedImage ) Signatures ( ctx context . Context ) ( [ ] [ ] byte , error ) { if i . cachedSignatures == nil { sigs , err := i . src . GetSignatures ( ctx , i . instanceDigest )   if err != nil { return nil , err   }   i . cachedSignatures = sigs   }   return i . cachedSignatures , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/page/easyjson.go#L7684-L7688<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v AddCompilationCacheParams ) MarshalJSON ( ) ( [ ] byte , error ) { w := jwriter . Writer { }   easyjsonC5a4559bEncodeGithubComChromedpCdprotoPage85 ( & w , v )   return w . Buffer . BuildBytes ( ) , w . Error   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/app/app.go#L1173-L1181<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( app * App ) validateNew ( ) error { if app . Name == InternalAppName || ! validation . ValidateName ( app . Name ) { msg := " " + " " + " "   return & tsuruErrors . ValidationError { Message : msg }   }   return app . validate ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/taskcluster/taskcluster-client-go/blob/ef6acd428ae5844a933792ed6479d0e7dca61ef8/tcnotify/types.go#L194-L197<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( this * PostIRCMessageRequest ) MarshalJSON ( ) ( [ ] byte , error ) { x := json . RawMessage ( * this )   return ( & x ) . MarshalJSON ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/wal/encoder.go#L54-L60<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func newFileEncoder ( f * os . File , prevCrc uint32 ) ( * encoder , error ) { offset , err := f . Seek ( 0 , io . SeekCurrent )   if err != nil { return nil , err   }   return newEncoder ( f , prevCrc , int ( offset ) ) , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/golang/appengine/blob/54a98f90d1c46b7731eb8fb305d2a321c30ef610/user/oauth.go#L18-L39<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func CurrentOAuth ( c context . Context , scopes ... string ) ( * User , error ) { req := & pb . GetOAuthUserRequest { }   if len ( scopes ) != 1 || scopes [ 0 ] != " " { // The signature for this function used to be CurrentOAuth(Context, string). // Ignore the singular "" scope to preserve existing behavior. req . Scopes = scopes   }    res := & pb . GetOAuthUserResponse { }    err := internal . Call ( c , " " , " " , req , res )   if err != nil { return nil , err   }   return & User { Email : * res . Email , AuthDomain : * res . AuthDomain , Admin : res . GetIsAdmin ( ) , ID : * res . UserId , ClientID : res . GetClientId ( ) , } , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/tracing/types.go#L52-L54<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( t StreamFormat ) MarshalEasyJSON ( out * jwriter . Writer ) { out . String ( string ( t ) )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/r3labs/sse/blob/2f90368216802092e9ed520c43e974e11d50438d/server.go#L54-L68<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( s * Server ) CreateStream ( id string ) * Stream { s . mu . Lock ( )   defer s . mu . Unlock ( )    if s . Streams [ id ] != nil { return s . Streams [ id ]   }    str := newStream ( s . BufferSize , s . AutoReplay )   str . run ( )    s . Streams [ id ] = str    return str   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/tracing/easyjson.go#L823-L827<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * GetCategoriesParams ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoTracing7 ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/gobuffalo/buffalo/blob/7f360181f4ccd79dcc9dcea2c904a4801f194f04/servers/tls.go#L23-L26<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( s * TLS ) Start ( c context . Context , h http . Handler ) error { s . Handler = h   return s . ListenAndServeTLS ( s . CertFile , s . KeyFile )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/easyjson.go#L196-L200<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * Message ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdproto1 ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/server.go#L1779-L1793<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( s * EtcdServer ) sync ( timeout time . Duration ) { req := pb . Request { Method : " " , ID : s . reqIDGen . Next ( ) , Time : time . Now ( ) . UnixNano ( ) , }   data := pbutil . MustMarshal ( & req )   // There is no promise that node has leader when do SYNC request, // so it uses goroutine to propose. ctx , cancel := context . WithTimeout ( s . ctx , timeout )   s . goAttach ( func ( ) { s . r . Propose ( ctx , data )   cancel ( )   } )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/gobuffalo/buffalo/blob/7f360181f4ccd79dcc9dcea2c904a4801f194f04/genny/newapp/core/core.go#L20-L131<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func New ( opts * Options ) ( * genny . Group , error ) { gg := & genny . Group { }    // add the root generator g , err := rootGenerator ( opts )   if err != nil { return gg , err   }   gg . Add ( g )    app := opts . App    if app . WithModules { g , err := gomods . Init ( app . PackagePkg , app . Root )   if err != nil { return gg , err   }   g . Command ( gogen . Get ( " " + runtime . Version ) )   g . Command ( gogen . Get ( " " ) )    gg . Add ( g )   }    plugs , err := plugdeps . List ( app )   if err != nil && ( errors . Cause ( err ) != plugdeps . ErrMissingConfig ) { return nil , err   }    if opts . Docker != nil { // add the docker generator g , err = docker . New ( opts . Docker )   if err != nil { return gg , err   }   gg . Add ( g )   }    if opts . Pop != nil { // add the pop generator gg2 , err := pop . New ( opts . Pop )   if err != nil { return gg , err   }   gg . Merge ( gg2 )    // add the plugin plugs . Add ( plugdeps . Plugin { Binary : " " , GoGet : " " , } )   }    if opts . CI != nil { // add the CI generator g , err = ci . New ( opts . CI )   if err != nil { return gg , err   }   gg . Add ( g )   }    if opts . Refresh != nil { g , err = refresh . New ( opts . Refresh )   if err != nil { return gg , err   }   gg . Add ( g )   }    // --- // install all of the plugins iopts := & install . Options { App : app , Plugins : plugs . List ( ) , }   if app . WithSQLite { iopts . Tags = meta . BuildTags { " " }   }    ig , err := install . New ( iopts )   if err != nil { return gg , err   }   gg . Merge ( ig )    // DEP/MODS/go get should be last if app . WithDep { // init dep di , err := depgen . Init ( " " , false )   if err != nil { return gg , err   }   gg . Add ( di )   }    if ! app . WithDep && ! app . WithModules { g := genny . New ( )   g . Command ( gogen . Get ( " " , " " ) )   gg . Add ( g )   }    if app . WithModules { g , err := gomods . Tidy ( app . Root , false )   if err != nil { return gg , err   }   gg . Add ( g )   }    return gg , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/TheThingsNetwork/go-utils/blob/aa2a11bd59104d2a8609328c2b2b55da61826470/pseudorandom/random.go#L21-L27<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func New ( seed int64 ) random . Interface { return & TTNRandom { Interface : & random . TTNRandom { Source : rand . New ( rand . NewSource ( seed ) ) , } , }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/indexeddb/easyjson.go#L903-L907<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * ObjectStore ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoIndexeddb7 ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/piotrkowalczuk/mnemosyne/blob/66d59c3c5b886e8e869915bb76257bcba4a47250/internal/storage/storagemock/storage.go#L38-L56<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( _m * Storage ) Delete ( _a0 context . Context , _a1 string , _a2 string , _a3 string , _a4 * time . Time , _a5 * time . Time ) ( int64 , error ) { ret := _m . Called ( _a0 , _a1 , _a2 , _a3 , _a4 , _a5 )    var r0 int64   if rf , ok := ret . Get ( 0 ) . ( func ( context . Context , string , string , string , * time . Time , * time . Time ) int64 ) ; ok { r0 = rf ( _a0 , _a1 , _a2 , _a3 , _a4 , _a5 )   } else { r0 = ret . Get ( 0 ) . ( int64 )   }    var r1 error   if rf , ok := ret . Get ( 1 ) . ( func ( context . Context , string , string , string , * time . Time , * time . Time ) error ) ; ok { r1 = rf ( _a0 , _a1 , _a2 , _a3 , _a4 , _a5 )   } else { r1 = ret . Error ( 1 )   }    return r0 , r1   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/api/v2http/client.go#L556-L578<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func writeKeyEvent ( w http . ResponseWriter , resp etcdserver . Response , noValueOnSuccess bool ) error { ev := resp . Event   if ev == nil { return errors . New ( " " )   }   w . Header ( ) . Set ( " " , " " )   w . Header ( ) . Set ( " " , fmt . Sprint ( ev . EtcdIndex ) )   w . Header ( ) . Set ( " " , fmt . Sprint ( resp . Index ) )   w . Header ( ) . Set ( " " , fmt . Sprint ( resp . Term ) )    if ev . IsCreated ( ) { w . WriteHeader ( http . StatusCreated )   }    ev = trimEventPrefix ( ev , etcdserver . StoreKeysPrefix )   if noValueOnSuccess && ( ev . Action == v2store . Set || ev . Action == v2store . CompareAndSwap || ev . Action == v2store . Create || ev . Action == v2store . Update ) { ev . Node = nil   ev . PrevNode = nil   }   return json . NewEncoder ( w ) . Encode ( ev )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/profiler/easyjson.go#L1869-L1873<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v PositionTickInfo ) MarshalJSON ( ) ( [ ] byte , error ) { w := jwriter . Writer { }   easyjsonC5a4559bEncodeGithubComChromedpCdprotoProfiler18 ( & w , v )   return w . Buffer . BuildBytes ( ) , w . Error   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/cm15/codegen_client.go#L9724-L9731<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( r * Route ) Locator ( api * API ) * RouteLocator { for _ , l := range r . Links { if l [ " " ] == " " { return api . RouteLocator ( l [ " " ] )   }   }   return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/bitgoin/lyra2rev2/blob/bae9ad2043bb55facb14c4918e909f88a7d3ed84/bmw.go#L131-L152<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func bmw256 ( input [ ] byte ) [ ] byte { b := new (  )   buf := make ( [ ] byte , 64 )   copy ( buf , input )   buf [ len ( input ) ] = 0x80   bitLen := uint64 ( len ( input ) ) << 3   binary . LittleEndian . PutUint64 ( buf [ 56 : ] , bitLen )   for i := 0 ; i < 16 ; i ++ { b . m [ i ] = binary . LittleEndian . Uint32 ( buf [ i * 4 : ] )   }   b . compress ( b . m )   b . h , b . h2 = b . h2 , b . h   copy ( b . h , final )   b . compress ( b . h2 )   output := make ( [ ] byte , 32 )   outlen := len ( output ) >> 2   for i := 0 ; i < outlen ; i ++ { j := 16 - outlen + i   binary . LittleEndian . PutUint32 ( output [ 4 * i : ] , b . h [ j ] )   }   return output   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L3012-L3021<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( u ManageOfferSuccessResultOffer ) ArmForSwitch ( sw int32 ) ( string , bool ) { switch ManageOfferEffect ( sw ) { case ManageOfferEffectManageOfferCreated : return " " , true   case ManageOfferEffectManageOfferUpdated : return " " , true   default : return " " , true   }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kpango/glg/blob/68d2670cb2dbff047331daad841149a82ac37796/glg.go#L954-L956<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func Printf ( format string , val ... interface { } ) error { return glg . out ( PRINT , format , val ... )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/siddontang/go-log/blob/1e957dd83bed18c84716181da7b80d4af48eaefe/log/logger.go#L259-L262<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( l * Logger ) Fatalln ( args ... interface { } ) { l . Output ( 2 , LevelFatal , fmt . Sprintln ( args ... ) )   os . Exit ( 1 )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/endpoints/endpoints.go#L104-L131<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func Up ( config * Config ) ( * Endpoints , error ) { if config . Dir == " " { return nil , fmt . Errorf ( " " )   }   if config . UnixSocket == " " { return nil , fmt . Errorf ( " " )   }   if config . RestServer == nil { return nil , fmt . Errorf ( " " )   }   if config . DevLxdServer == nil { return nil , fmt . Errorf ( " " )   }   if config . Cert == nil { return nil , fmt . Errorf ( " " )   }    endpoints := & Endpoints { systemdListenFDsStart : util . SystemdListenFDsStart , }    err := endpoints . up ( config )   if err != nil { endpoints . Down ( )   return nil , err   }   return endpoints , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdctl/ctlv3/command/member_command.go#L70-L81<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func NewMemberUpdateCommand ( ) * cobra . Command { cc := & cobra . Command { Use : " " , Short : " " , Run : memberUpdateCommandFunc , }    cc . Flags ( ) . StringVar ( & memberPeerURLs , " " , " " , " " )    return cc   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/page/easyjson.go#L868-L872<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v SetFontSizesParams ) MarshalJSON ( ) ( [ ] byte , error ) { w := jwriter . Writer { }   easyjsonC5a4559bEncodeGithubComChromedpCdprotoPage9 ( & w , v )   return w . Buffer . BuildBytes ( ) , w . Error   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/mota/klash/blob/ca6c37a4c8c2e69831c428cf0c6daac80ab56c22/parameter.go#L31-L55<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p * Parameter ) DiscoverProperties ( tag reflect . StructTag ) error { if len ( tag ) > 0 { paramtype := reflect . TypeOf ( ( * Parameter ) ( nil ) )   prefix := " "   paramvalue := reflect . ValueOf ( p )    for idx := 0 ; idx < paramtype . NumMethod ( ) ; idx ++ { method := paramtype . Method ( idx )   if ! strings . HasPrefix ( method . Name , prefix ) { continue   }    tagname := " " + strings . ToLower ( method . Name [ len ( prefix ) : ] )   if tagval := tag . Get ( tagname ) ; tagval != " " { methodValue := paramvalue . MethodByName ( method . Name )    err := methodValue . Call ( [ ] reflect . Value { reflect . ValueOf ( tagval ) } ) [ 0 ] . Interface ( )   if err != nil { return ( err ) . ( error )   }   }   }   }   return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/bazelbuild/bazel-gazelle/blob/e3805aaca69a9deb949b47bfc45b9b1870712f4f/language/go/fileinfo.go#L610-L623<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func checkConstraints ( c * config . Config , os , arch , osSuffix , archSuffix string , fileTags [ ] tagLine , cgoTags tagLine ) bool { if osSuffix != " " && osSuffix != os || archSuffix != " " && archSuffix != arch { return false   }   for _ , l := range fileTags { if ! l . check ( c , os , arch ) { return false   }   }   if len ( cgoTags ) > 0 && ! cgoTags . check ( c , os , arch ) { return false   }   return true   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/llgcode/draw2d/blob/f52c8a71aff06ab8df41843d33ab167b36c971cd/draw2dgl/gc.go#L269-L271<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( gc * GraphicContext ) StrokeString ( text string ) ( width float64 ) { return gc . StrokeStringAt ( text , 0 , 0 )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/provision/kubernetes/pkg/client/informers/externalversions/tsuru/v1/app.go#L40-L42<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func NewAppInformer ( client versioned . Interface , namespace string , resyncPeriod time . Duration , indexers cache . Indexers ) cache . SharedIndexInformer { return NewFilteredAppInformer ( client , namespace , resyncPeriod , indexers , nil )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L4239-L4248<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( u OperationResultTr ) GetManageDataResult ( ) ( result ManageDataResult , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) )    if armName == " " { result = * u . ManageDataResult   ok = true   }    return   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/storage_lvm.go#L35-L69<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( s * storageLvm ) StorageCoreInit ( ) error { s . sType = storageTypeLvm   typeName , err := storageTypeToString ( s . sType )   if err != nil { return err   }   s . sTypeName = typeName    if lvmVersion != " " { s . sTypeVersion = lvmVersion   return nil   }    output , err := shared . RunCommand ( " " , " " )   if err != nil { return fmt . Errorf ( " \n " , err , output )   }   lines := strings . Split ( output , " \n " )    s . sTypeVersion = " "   for idx , line := range lines { fields := strings . SplitAfterN ( line , " " , 2 )   if len ( fields ) < 2 { continue   }   if idx > 0 { s . sTypeVersion += " "   }   s . sTypeVersion += strings . TrimSpace ( fields [ 1 ] )   }    lvmVersion = s . sTypeVersion    return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/page/page.go#L45-L48<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p AddScriptToEvaluateOnNewDocumentParams ) WithWorldName ( worldName string ) * AddScriptToEvaluateOnNewDocumentParams { p . WorldName = worldName   return & p   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/bazelbuild/bazel-gazelle/blob/e3805aaca69a9deb949b47bfc45b9b1870712f4f/cmd/autogazelle/server_unix.go#L239-L243<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func recordWrite ( path string ) { dirSetMutex . Lock ( )   defer dirSetMutex . Unlock ( )   dirSet [ path ] = true   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/overlay/easyjson.go#L85-L89<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * SetShowViewportSizeOnResizeParams ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoOverlay ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/clientv3/balancer/balancer.go#L53-L86<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( b * builder ) Build ( cc balancer . ClientConn , opt balancer . BuildOptions ) balancer . Balancer { bb := & baseBalancer { id : strconv . FormatInt ( time . Now ( ) . UnixNano ( ) , 36 ) , policy : b . cfg . Policy , name : b . cfg . Name , lg : b . cfg . Logger , addrToSc : make ( map [ resolver . Address ] balancer . SubConn ) , scToAddr : make ( map [ balancer . SubConn ] resolver . Address ) , scToSt : make ( map [ balancer . SubConn ] connectivity . State ) , currentConn : nil , csEvltr : & connectivityStateEvaluator { } , // initialize picker always returns "ErrNoSubConnAvailable" Picker : picker . NewErr ( balancer . ErrNoSubConnAvailable ) , }   if bb . lg == nil { bb . lg = zap . NewNop ( )   }    // TODO: support multiple connections bb . mu . Lock ( )   bb . currentConn = cc   bb . mu . Unlock ( )    bb . lg . Info ( " " , zap . String ( " " , bb . id ) , zap . String ( " " , bb . policy . String ( ) ) , zap . String ( " " , cc . Target ( ) ) , )   return bb   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/blacklabeldata/namedtuple/blob/c341f1db44f30b8164294aa8605ede42be604aba/types.go#L31-L36<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func New ( namespace string , name string ) ( t TupleType ) { hash := syncHash . Hash ( [ ] byte ( name ) )   ns_hash := syncHash . Hash ( [ ] byte ( namespace ) )   t = TupleType { namespace , name , ns_hash , hash , make ( [ ] [ ] Field , 0 ) , make ( map [ string ] int ) }   return   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/containers/image/blob/da9ab3561ad2031aeb5e036b7cf2755d4e246fec/copy/copy.go#L218-L374<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * copier ) copyOneImage ( ctx context . Context , policyContext * signature . PolicyContext , options * Options , unparsedImage * image . UnparsedImage ) ( manifestBytes [ ] byte , retErr error ) { // The caller is handling manifest lists; this could happen only if a manifest list contains a manifest list. // Make sure we fail cleanly in such cases. multiImage , err := isMultiImage ( ctx , unparsedImage )   if err != nil { // FIXME FIXME: How to name a reference for the sub-image? return nil , errors . Wrapf ( err , " " , transports . ImageName ( unparsedImage . Reference ( ) ) )   }   if multiImage { return nil , fmt . Errorf ( " " )   }    // Please keep this policy check BEFORE reading any other information about the image. // (the multiImage check above only matches the MIME type, which we have received anyway. // Actual parsing of anything should be deferred.) if allowed , err := policyContext . IsRunningImageAllowed ( ctx , unparsedImage ) ; ! allowed || err != nil { // Be paranoid and fail if either return value indicates so. return nil , errors . Wrap ( err , " " )   }   src , err := image . FromUnparsedImage ( ctx , options . SourceCtx , unparsedImage )   if err != nil { return nil , errors . Wrapf ( err , " " , transports . ImageName ( c . rawSource . Reference ( ) ) )   }    // If the destination is a digested reference, make a note of that, determine what digest value we're // expecting, and check that the source manifest matches it. destIsDigestedReference := false   if named := c . dest . Reference ( ) . DockerReference ( ) ; named != nil { if digested , ok := named . ( reference . Digested ) ; ok { destIsDigestedReference = true   sourceManifest , _ , err := src . Manifest ( ctx )   if err != nil { return nil , errors . Wrapf ( err , " " )   }   matches , err := manifest . MatchesDigest ( sourceManifest , digested . Digest ( ) )   if err != nil { return nil , errors . Wrapf ( err , " " )   }   if ! matches { return nil , errors . New ( " " )   }   }   }    if err := checkImageDestinationForCurrentRuntimeOS ( ctx , options . DestinationCtx , src , c . dest ) ; err != nil { return nil , err   }    var sigs [ ] [ ] byte   if options . RemoveSignatures { sigs = [ ] [ ] byte { }   } else { c . Printf ( " \n " )   s , err := src . Signatures ( ctx )   if err != nil { return nil , errors . Wrap ( err , " " )   }   sigs = s   }   if len ( sigs ) != 0 { c . Printf ( " \n " )   if err := c . dest . SupportsSignatures ( ctx ) ; err != nil { return nil , errors . Wrap ( err , " " )   }   }    ic := imageCopier { c : c , manifestUpdates : & types . ManifestUpdateOptions { InformationOnly : types . ManifestUpdateInformation { Destination : c . dest } } , src : src , // diffIDsAreNeeded is computed later canModifyManifest : len ( sigs ) == 0 && ! destIsDigestedReference , }   // Ensure _this_ copy sees exactly the intended data when either processing a signed image or signing it. // This may be too conservative, but for now, better safe than sorry, _especially_ on the SignBy path: // The signature makes the content non-repudiable, so it very much matters that the signature is made over exactly what the user intended. // We do intend the RecordDigestUncompressedPair calls to only work with reliable data, but at least there’s a risk // that the compressed version coming from a third party may be designed to attack some other decompressor implementation, // and we would reuse and sign it. ic . canSubstituteBlobs = ic . canModifyManifest && options . SignBy == " "    if err := ic . updateEmbeddedDockerReference ( ) ; err != nil { return nil , err   }    // We compute preferredManifestMIMEType only to show it in error messages. // Without having to add this context in an error message, we would be happy enough to know only that no conversion is needed. preferredManifestMIMEType , otherManifestMIMETypeCandidates , err := ic . determineManifestConversion ( ctx , c . dest . SupportedManifestMIMETypes ( ) , options . ForceManifestMIMEType )   if err != nil { return nil , err   }    // If src.UpdatedImageNeedsLayerDiffIDs(ic.manifestUpdates) will be true, it needs to be true by the time we get here. ic . diffIDsAreNeeded = src . UpdatedImageNeedsLayerDiffIDs ( * ic . manifestUpdates )    if err := ic . copyLayers ( ctx ) ; err != nil { return nil , err   }    // With docker/distribution registries we do not know whether the registry accepts schema2 or schema1 only; // and at least with the OpenShift registry "acceptschema2" option, there is no way to detect the support // without actually trying to upload something and getting a types.ManifestTypeRejectedError. // So, try the preferred manifest MIME type. If the process succeeds, fine… manifestBytes , err = ic . copyUpdatedConfigAndManifest ( ctx )   if err != nil { logrus . Debugf ( " " , preferredManifestMIMEType , err )   // … if it fails, _and_ the failure is because the manifest is rejected, we may have other options. if _ , isManifestRejected := errors . Cause ( err ) . ( types . ManifestTypeRejectedError ) ; ! isManifestRejected || len ( otherManifestMIMETypeCandidates ) == 0 { // We don’t have other options. // In principle the code below would handle this as well, but the resulting  error message is fairly ugly. // Don’t bother the user with MIME types if we have no choice. return nil , err   }   // If the original MIME type is acceptable, determineManifestConversion always uses it as preferredManifestMIMEType. // So if we are here, we will definitely be trying to convert the manifest. // With !ic.canModifyManifest, that would just be a string of repeated failures for the same reason, // so let’s bail out early and with a better error message. if ! ic . canModifyManifest { return nil , errors . Wrap ( err , " " )   }    // errs is a list of errors when trying various manifest types. Also serves as an "upload succeeded" flag when set to nil. errs := [ ] string { fmt . Sprintf ( " " , preferredManifestMIMEType , err ) }   for _ , manifestMIMEType := range otherManifestMIMETypeCandidates { logrus . Debugf ( "   m nifestMIMEType)    ic . manifestUpdates . ManifestMIMEType = manifestMIMEType   attemptedManifest , err := ic . copyUpdatedConfigAndManifest ( ctx )   if err != nil { logrus . Debugf ( " " , manifestMIMEType , err )   errs = append ( errs , fmt . Sprintf ( " " , manifestMIMEType , err ) )   continue   }    // We have successfully uploaded a manifest. manifestBytes = attemptedManifest   errs = nil // Mark this as a success so that we don't abort below.   break   }   if errs != nil { return nil , fmt . Errorf ( " " , strings . Join ( errs , " " ) )   }   }    if options . SignBy != " " { newSig , err := c . createSignature ( manifestBytes , options . SignBy )   if err != nil { return nil , err   }   sigs = append ( sigs , newSig )   }    c . Printf ( " \n " )   if err := c . dest . PutSignatures ( ctx , sigs ) ; err != nil { return nil , errors . Wrap ( err , " " )   }    return manifestBytes , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/json/context.go#L35-L38<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func NewContext ( timeout time . Duration ) ( Context , context . CancelFunc ) { ctx , cancel := tchannel . NewContext ( timeout )   return tchannel . WrapWithHeaders ( ctx , nil ) , cancel   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/network/types.go#L478-L490<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( t * CertificateTransparencyCompliance ) UnmarshalEasyJSON ( in * jlexer . Lexer ) { switch CertificateTransparencyCompliance ( in . String ( ) ) { case CertificateTransparencyComplianceUnknown : * t = CertificateTransparencyComplianceUnknown   case CertificateTransparencyComplianceNotCompliant : * t = CertificateTransparencyComplianceNotCompliant   case CertificateTransparencyComplianceCompliant : * t = CertificateTransparencyComplianceCompliant    default : in . AddError ( errors . New ( " " ) )   }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/github/client.go#L1154-L1188<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * Client ) UpdatePullRequest ( org , repo string , number int , title , body * string , open * bool , branch * string , canModify * bool ) error { c . log ( " " , org , repo , title )   data := struct { State * string `json:"state,omitempty"`   Title * string `json:"title,omitempty"`   Body * string `json:"body,omitempty"`   Base * string `json:"base,omitempty"`   // MaintainerCanModify allows maintainers of the repo to modify this // pull request, eg. push changes to it before merging. MaintainerCanModify * bool `json:"maintainer_can_modify,omitempty"`   } { Title : title , Body : body , Base : branch , MaintainerCanModify : canModify , }   if open != nil && * open { op := " "   data . State = & op   } else if open != nil { cl := " "   data . State = & cl   }   _ , err := c . request ( & request { // allow the description and draft fields // https://developer.github.com/changes/2018-02-22-label-description-search-preview/ // https://developer.github.com/changes/2019-02-14-draft-pull-requests/ accept : " " , method : http . MethodPatch , path : fmt . Sprintf ( " " , org , repo , number ) , requestBody : & data , exitCodes : [ ] int { 200 } , } , nil )   return err   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/util/encryption.go#L17-L40<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func PasswordCheck ( secret string , password string ) error { // No password set if secret == " " { return fmt . Errorf ( " " )   }    // Compare the password buff , err := hex . DecodeString ( secret )   if err != nil { return err   }    salt := buff [ 0 : 32 ]   hash , err := scrypt . Key ( [ ] byte ( password ) , salt , 1 << 14 , 8 , 1 , 64 )   if err != nil { return err   }    if ! bytes . Equal ( hash , buff [ 32 : ] ) { return fmt . Errorf ( " " )   }    return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/debugger/easyjson.go#L3149-L3153<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * GetScriptSourceReturns ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoDebugger33 ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/github/client.go#L1359-L1368<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * Client ) GetSingleCommit ( org , repo , SHA string ) ( SingleCommit , error ) { c . log ( " " , org , repo , SHA )   var commit SingleCommit   _ , err := c . request ( & request { method : http . MethodGet , path : fmt . Sprintf ( " " , org , repo , SHA ) , exitCodes : [ ] int { 200 } , } , & commit )   return commit , err   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/debugger/debugger.go#L943-L950<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func SetVariableValue ( scopeNumber int64 , variableName string , newValue * runtime . CallArgument , callFrameID CallFrameID ) * SetVariableValueParams { return & SetVariableValueParams { ScopeNumber : scopeNumber , VariableName : variableName , NewValue : newValue , CallFrameID : callFrameID , }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/markthelaw/GoStatHelper/blob/c571b034199fdeccdcef2275c37904260a967f59/StatUtil/StatUtil.go#L12-L14<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func InverseNormalDist ( p float64 , mean float64 , stdv float64 ) float64 { return mean + stdv * InverserNormalCDF ( p )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/glycerine/rbuf/blob/75b78581bebe959bc9a3df4c5f64e82c187d7531/atomic_rbuf.go#L375-L398<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( b * AtomicFixedSizeRingBuf ) ReadFrom ( r io . Reader ) ( n int64 , err error ) { b . tex . Lock ( )   defer b . tex . Unlock ( )    for { writeCapacity := b . N - b . readable   if writeCapacity <= 0 { // we are all full return n , nil   }   writeStart := ( b . Beg + b . readable ) % b . N   upperLim := intMin2 ( writeStart + writeCapacity , b . N )    m , e := r . Read ( b . A [ b . Use ] [ writeStart : upperLim ] )   n += int64 ( m )   b . readable += m   if e == io . EOF { return n , nil   }   if e != nil { return n , e   }   }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/api/rafthttp/util.go#L40-L42<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func NewListener ( u url . URL , tlsinfo * transport . TLSInfo ) ( net . Listener , error ) { return transport . NewTimeoutListener ( u . Host , u . Scheme , tlsinfo , ConnReadTimeout , ConnWriteTimeout )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/libp2p/go-libp2p-crypto/blob/9d2fed53443f745e6dc4d02bdcc94d9742a0ca84/rsa.go#L93-L95<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( sk * RsaPrivateKey ) Decrypt ( b [ ] byte ) ( [ ] byte , error ) { return rsa . DecryptPKCS1v15 ( rand . Reader , sk . sk , b )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/accessibility/types.go#L228-L230<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( t * ValueNativeSourceType ) UnmarshalJSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/libp2p/go-libp2p-crypto/blob/9d2fed53443f745e6dc4d02bdcc94d9742a0ca84/ecdsa.go#L89-L101<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func UnmarshalECDSAPublicKey ( data [ ] byte ) ( PubKey , error ) { pubIfc , err := x509 . ParsePKIXPublicKey ( data )   if err != nil { return nil , err   }    pub , ok := pubIfc . ( * ecdsa . PublicKey )   if ! ok { return nil , ErrNotECDSAPubKey   }    return & ECDSAPublicKey { pub } , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/dom/dom.go#L177-L186<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p * DescribeNodeParams ) Do ( ctx context . Context ) ( node * cdp . Node , err error ) { // execute var res DescribeNodeReturns   err = cdp . Execute ( ctx , CommandDescribeNode , p , & res )   if err != nil { return nil , err   }    return res . Node , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/containers/image/blob/da9ab3561ad2031aeb5e036b7cf2755d4e246fec/storage/storage_image.go#L520-L552<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( s * storageImageDestination ) computeID ( m manifest . Manifest ) string { // Build the diffID list.  We need the decompressed sums that we've been calculating to // fill in the DiffIDs.  It's expected (but not enforced by us) that the number of // diffIDs corresponds to the number of non-EmptyLayer entries in the history. var diffIDs [ ] digest . Digest   switch m := m . ( type ) { case * manifest . Schema1 : // Build a list of the diffIDs we've generated for the non-throwaway FS layers, // in reverse of the order in which they were originally listed. for i , compat := range m . ExtractedV1Compatibility { if compat . ThrowAway { continue   }   blobSum := m . FSLayers [ i ] . BlobSum   diffID , ok := s . blobDiffIDs [ blobSum ]   if ! ok { logrus . Infof ( " " , blobSum . String ( ) )   return " "   }   diffIDs = append ( [ ] digest . Digest { diffID } , diffIDs ... )   }   case * manifest . Schema2 , * manifest . OCI1 : // We know the ID calculation for these formats doesn't actually use the diffIDs, // so we don't need to populate the diffID list. default : return " "   }   id , err := m . ImageID ( diffIDs )   if err != nil { return " "   }   return id   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/tide/status.go#L97-L216<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func requirementDiff ( pr * PullRequest , q * config . TideQuery , cc contextChecker ) ( string , int ) { const maxLabelChars = 50   var desc string   var diff int   // Drops labels if needed to fit the description text area, but keep at least 1. truncate := func ( labels [ ] string ) [ ] string { i := 1   chars := len ( labels [ 0 ] )   for ; i < len ( labels ) ; i ++ { if chars + len ( labels [ i ] ) > maxLabelChars { break   }   chars += len ( labels [ i ] ) + 2 // ", "   }   return labels [ : i ]   }    // Weight incorrect branches with very high diff so that we select the query // for the correct branch. targetBranchBlacklisted := false   for _ , excludedBranch := range q . ExcludedBranches { if string ( pr . BaseRef . Name ) == excludedBranch { targetBranchBlacklisted = true   break   }   }   // if no whitelist is configured, the target is OK by default targetBranchWhitelisted := len ( q . IncludedBranches ) == 0   for _ , includedBranch := range q . IncludedBranches { if string ( pr . BaseRef . Name ) == includedBranch { targetBranchWhitelisted = true   break   }   }   if targetBranchBlacklisted || ! targetBranchWhitelisted { diff += 1000   if desc == " " { desc = fmt . Sprintf ( " " , pr . BaseRef . Name )   }   }    // Weight incorrect milestone with relatively high diff so that we select the // query for the correct milestone (but choose favor query for correct branch). if q . Milestone != " " && ( pr . Milestone == nil || string ( pr . Milestone . Title ) != q . Milestone ) { diff += 100   if desc == " " { desc = fmt . Sprintf ( " " , q . Milestone )   }   }    // Weight incorrect labels and statues with low (normal) diff values. var missingLabels [ ] string   for _ , l1 := range q . Labels { var found bool   for _ , l2 := range pr . Labels . Nodes { if string ( l2 . Name ) == l1 { found = true   break   }   }   if ! found { missingLabels = append ( missingLabels , l1 )   }   }   diff += len ( missingLabels )   if desc == " " && len ( missingLabels ) > 0 { sort . Strings ( missingLabels )   trunced := truncate ( missingLabels )   if len ( trunced ) == 1 { desc = fmt . Sprintf ( " " , trunced [ 0 ] )   } else { desc = fmt . Sprintf ( " " , strings . Join ( trunced , " " ) )   }   }    var presentLabels [ ] string   for _ , l1 := range q . MissingLabels { for _ , l2 := range pr . Labels . Nodes { if string ( l2 . Name ) == l1 { presentLabels = append ( presentLabels , l1 )   break   }   }   }   diff += len ( presentLabels )   if desc == " " && len ( presentLabels ) > 0 { sort . Strings ( presentLabels )   trunced := truncate ( presentLabels )   if len ( trunced ) == 1 { desc = fmt . Sprintf ( " " , trunced [ 0 ] )   } else { desc = fmt . Sprintf ( " " , strings . Join ( trunced , " " ) )   }   }    // fixing label issues takes precedence over status contexts var contexts [ ] string   for _ , commit := range pr . Commits . Nodes { if commit . Commit . OID == pr . HeadRefOID { for _ , ctx := range unsuccessfulContexts ( commit . Commit . Status . Contexts , cc , logrus . New ( ) . WithFields ( pr . logFields ( ) ) ) { contexts = append ( contexts , string ( ctx . Context ) )   }   }   }   diff += len ( contexts )   if desc == " " && len ( contexts ) > 0 { sort . Strings ( contexts )   trunced := truncate ( contexts )   if len ( trunced ) == 1 { desc = fmt . Sprintf ( " " , trunced [ 0 ] )   } else { desc = fmt . Sprintf ( " " , strings . Join ( trunced , " " ) )   }   }    // TODO(cjwagner): List reviews (states:[APPROVED], first: 1) as part of open // PR query. return desc , diff   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/input/input.go#L462-L465<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p SynthesizeScrollGestureParams ) WithXDistance ( xDistance float64 ) * SynthesizeScrollGestureParams { p . XDistance = xDistance   return & p   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/node.go#L500-L518<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * ClusterTx ) NodeUpdateVersion ( id int64 , version [ 2 ] int ) error { stmt := " "    result , err := c . tx . Exec ( stmt , version [ 0 ] , version [ 1 ] , id )   if err != nil { return errors . Wrap ( err , " " )   }    n , err := result . RowsAffected ( )   if err != nil { return errors . Wrap ( err , " " )   }    if n != 1 { return fmt . Errorf ( " " )   }    return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/api/v2stats/queue.go#L81-L100<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( q * statsQueue ) Rate ( ) ( float64 , float64 ) { front , back := q . frontAndBack ( )    if front == nil || back == nil { return 0 , 0   }    if time . Since ( back . SendingTime ) > time . Second { q . Clear ( )   return 0 , 0   }    sampleDuration := back . SendingTime . Sub ( front . SendingTime )    pr := float64 ( q . Len ( ) ) / float64 ( sampleDuration ) * float64 ( time . Second )    br := float64 ( q . ReqSize ( ) ) / float64 ( sampleDuration ) * float64 ( time . Second )    return pr , br   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/contrib/recipes/client.go#L33-L43<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func deleteRevKey ( kv v3 . KV , key string , rev int64 ) ( bool , error ) { cmp := v3 . Compare ( v3 . ModRevision ( key ) , " " , rev )   req := v3 . OpDelete ( key )   txnresp , err := kv . Txn ( context . TODO ( ) ) . If ( cmp ) . Then ( req ) . Commit ( )   if err != nil { return false , err   } else if ! txnresp . Succeeded { return false , nil   }   return true , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/mrd0ll4r/tbotapi/blob/edc257282178bb5cebbfcc41260ec04c1ec7ac19/outgoing.go#L188-L191<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( oa * OutgoingAudio ) SetTitle ( to string ) * OutgoingAudio { oa . Title = to   return oa   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kr/s3/blob/c070c8f9a8f0032d48f0d2a77d4e382788bd8a1d/sign.go#L81-L83<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func Sign ( r * http . Request , k Keys ) { DefaultService . Sign ( r , k )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/mikespook/possum/blob/56d7ebb6470b670001632b11be7fc089038f4dd7/pprof.go#L18-L30<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( mux * ServerMux ) InitPProf ( prefix string ) { if prefix == " " { prefix = " "   }   mux . HandleFunc ( router . Wildcard ( fmt . Sprintf ( " " , prefix ) ) , WrapHTTPHandlerFunc ( pprofIndex ( prefix ) ) , nil )   mux . HandleFunc ( router . Simple ( fmt . Sprintf ( " " , prefix ) ) , WrapHTTPHandlerFunc ( http . HandlerFunc ( pprof . Cmdline ) ) , nil )   mux . HandleFunc ( router . Simple ( fmt . Sprintf ( " " , prefix ) ) , WrapHTTPHandlerFunc ( http . HandlerFunc ( pprof . Profile ) ) , nil )   mux . HandleFunc ( router . Simple ( fmt . Sprintf ( " " , prefix ) ) , WrapHTTPHandlerFunc ( http . HandlerFunc ( pprof . Symbol ) ) , nil )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/inbound.go#L273-L282<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( call * InboundCall ) readMethod ( ) error { var arg1 [ ] byte   if err := NewArgReader ( call . arg1Reader ( ) ) . Read ( & arg1 ) ; err != nil { return call . failed ( err )   }    call . method = arg1   call . methodString = string ( arg1 )   return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/target/target.go#L533-L535<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p * SetDiscoverTargetsParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetDiscoverTargets , p , nil )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/jpillora/overseer/blob/ce9055846616cf7e1ab91bb8a0bcbb1d7fa3d11a/overseer.go#L98-L110<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func Run ( c Config ) { err := runErr ( & c )   if err != nil { if c . Required { log . Fatalf ( " " , err )   } else if c . Debug || ! c . NoWarn { log . Printf ( " " , err )   }   c . Program ( DisabledState )   return   }   os . Exit ( 0 )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/css/easyjson.go#L3914-L3918<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * KeyframeRule ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoCss33 ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/debugger/debugger.go#L85-L88<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p EnableParams ) WithMaxScriptsCacheSize ( maxScriptsCacheSize float64 ) * EnableParams { p . MaxScriptsCacheSize = maxScriptsCacheSize   return & p   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/ant0ine/go-json-rest/blob/ebb33769ae013bd5f518a8bac348c310dea768b8/rest/request.go#L77-L90<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( r * Request ) UrlFor ( path string , queryParams map [ string ] [ ] string ) * url . URL { baseUrl := r . BaseUrl ( )   baseUrl . Path = path   if queryParams != nil { query := url . Values { }   for k , v := range queryParams { for _ , vv := range v { query . Add ( k , vv )   }   }   baseUrl . RawQuery = query . Encode ( )   }   return baseUrl   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/cachestorage/easyjson.go#L309-L313<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v RequestCachedResponseReturns ) MarshalJSON ( ) ( [ ] byte , error ) { w := jwriter . Writer { }   easyjsonC5a4559bEncodeGithubComChromedpCdprotoCachestorage2 ( & w , v )   return w . Buffer . BuildBytes ( ) , w . Error   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/github/client.go#L1605-L1631<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * Client ) AssignIssue ( org , repo string , number int , logins [ ] string ) error { c . log ( " " , org , repo , number , logins )   assigned := make ( map [ string ] bool )   var i Issue   _ , err := c . request ( & request { method : http . MethodPost , path : fmt . Sprintf ( " " , org , repo , number ) , requestBody : map [ string ] [ ] string { " " : logins } , exitCodes : [ ] int { 201 } , } , & i )   if err != nil { return err   }   for _ , assignee := range i . Assignees { assigned [ NormLogin ( assignee . Login ) ] = true   }   missing := MissingUsers { action : " " }   for _ , login := range logins { if ! assigned [ NormLogin ( login ) ] { missing . Users = append ( missing . Users , login )   }   }   if len ( missing . Users ) > 0 { return missing   }   return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/network/easyjson.go#L436-L440<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v WebSocketFrame ) MarshalJSON ( ) ( [ ] byte , error ) { w := jwriter . Writer { }   easyjsonC5a4559bEncodeGithubComChromedpCdprotoNetwork2 ( & w , v )   return w . Buffer . BuildBytes ( ) , w . Error   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/client/pfs.go#L557-L579<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c APIClient ) PutObject ( _r io . Reader , tags ... string ) ( object * pfs . Object , _ int64 , retErr error ) { r := grpcutil . ReaderWrapper { _r }   w , err := c . newPutObjectWriteCloser ( tags ... )   if err != nil { return nil , 0 , grpcutil . ScrubGRPC ( err )   }   defer func ( ) { if err := w . Close ( ) ; err != nil && retErr == nil { retErr = grpcutil . ScrubGRPC ( err )   }   if retErr == nil { object = w . object   }   } ( )   buf := grpcutil . GetBuffer ( )   defer grpcutil . PutBuffer ( buf )   written , err := io . CopyBuffer ( w , r , buf )   if err != nil { return nil , 0 , grpcutil . ScrubGRPC ( err )   }   // return value set by deferred function return nil , written , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/functional/agent/handler.go#L178-L223<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( srv * Server ) stopEtcd ( sig os . Signal ) error { srv . stopProxy ( )    if srv . etcdCmd != nil { srv . lg . Info ( " " , zap . String ( " " , srv . etcdCmd . Path ) , zap . String ( " " , sig . String ( ) ) , )    err := srv . etcdCmd . Process . Signal ( sig )   if err != nil { return err   }    errc := make ( chan error )   go func ( ) { _ , ew := srv . etcdCmd . Process . Wait ( )   errc <- ew   close ( errc )   } ( )    select { case <- time . After ( 5 * time . Second ) : srv . etcdCmd . Process . Kill ( )   case e := <- errc : return e   }    err = <- errc    srv . lg . Info ( " " , zap . String ( " " , srv . etcdCmd . Path ) , zap . String ( " " , sig . String ( ) ) , zap . Error ( err ) , )   return err   }    srv . lg . Info ( " " )   srv . etcdServer . Server . HardStop ( )   srv . etcdServer . Close ( )   srv . lg . Info ( " " )   return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/enaml-ops/enaml/blob/4f847ee10b41afca41fe09fa839cb2f6ade06fb5/deploymentmanifest.go#L110-L118<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( s * DeploymentManifest ) AddRemoteStemcell ( os , alias , ver , url , sha1 string ) { s . Stemcells = append ( s . Stemcells , Stemcell { OS : os , Alias : alias , Version : ver , URL : url , SHA1 : sha1 , } )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/state.go#L164-L171<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( r * raftState ) getLastEntry ( ) ( uint64 , uint64 ) { r . lastLock . Lock ( )   defer r . lastLock . Unlock ( )   if r . lastLogIndex >= r . lastSnapshotIndex { return r . lastLogIndex , r . lastLogTerm   }   return r . lastSnapshotIndex , r . lastSnapshotTerm   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/omniscale/go-mapnik/blob/710dfcc5e486e5760d0a5c46be909d91968e1ffb/mapnik.go#L375-L377<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( m * Map ) SetBufferSize ( s int ) { C . mapnik_map_set_buffer_size ( m . m , C . int ( s ) )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/HiLittleCat/core/blob/ae2101184ecd36354d3fcff0ea69d67d3fdbe156/context.go#L52-L62<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( ctx * Context ) Ok ( data interface { } ) { if ctx . written == true { log . WithFields ( log . Fields { " " : ctx . Request . URL . Path } ) . Warnln ( " " )   return   }   ctx . written = true   var json = jsoniter . ConfigCompatibleWithStandardLibrary   b , _ := json . Marshal ( & ResFormat { Ok : true , Data : data } )   ctx . ResponseWriter . WriteHeader ( http . StatusOK )   ctx . ResponseWriter . Write ( b )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/pivotal-pez/pezdispenser/blob/768e2777520868857916b66cfd4cfb7149383ca5/pdclient/get_requestid_from_task.go#L10-L38<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func GetRequestIDFromTaskResponse ( taskResponse TaskResponse ) ( requestID string , err error ) { var provisionHostInfoBytes [ ] byte   firstRecordIndex := 0   meta := taskResponse . MetaData   provisionHostInfo := ProvisionHostInfo { }   lo . G . Debug ( " " , taskResponse )   lo . G . Debug ( " " , meta )    if provisionHostInfoBytes , err = json . Marshal ( meta [ ProvisionHostInformationFieldname ] ) ; err == nil { if err = json . Unmarshal ( provisionHostInfoBytes , & provisionHostInfo ) ; err == nil { if len ( provisionHostInfo . Data ) > firstRecordIndex { requestID = provisionHostInfo . Data [ firstRecordIndex ] . RequestID    } else { lo . G . Error ( " " , provisionHostInfo )   }    } else { lo . G . Error ( " " , err , meta )   lo . G . Error ( " " , meta )   }    } else { lo . G . Error ( " " , err )   }   return   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kpango/glg/blob/68d2670cb2dbff047331daad841149a82ac37796/glg.go#L417-L432<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( g * Glg ) AddStdLevel ( tag string , mode MODE , isColor bool ) * Glg { atomic . AddUint32 ( g . levelCounter , 1 )   lev := LEVEL ( atomic . LoadUint32 ( g . levelCounter ) )   g . levelMap . Store ( tag , lev )   l := & logger { writer : nil , std : os . Stdout , color : Colorless , isColor : isColor , mode : mode , tag : tag , }   l . updateMode ( )   g . logger . Store ( lev , l )   return g   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/rl10/codegen_client.go#L71-L73<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( api * API ) DebugCookbookPathLocator ( href string ) * DebugCookbookPathLocator { return & DebugCookbookPathLocator { Href ( href ) , api }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/embed/etcd.go#L349-L409<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( e * Etcd ) Close ( ) { fields := [ ] zap . Field { zap . String ( " " , e . cfg . Name ) , zap . String ( " " , e . cfg . Dir ) , zap . Strings ( " " , e . cfg . getAPURLs ( ) ) , zap . Strings ( " " , e . cfg . getACURLs ( ) ) , }   lg := e . GetLogger ( )   if lg != nil { lg . Info ( " " , fields ... )   }   defer func ( ) { if lg != nil { lg . Info ( " " , fields ... )   lg . Sync ( )   }   } ( )    e . closeOnce . Do ( func ( ) { close ( e . stopc ) } )    // close client requests with request timeout timeout := 2 * time . Second   if e . Server != nil { timeout = e . Server . Cfg . ReqTimeout ( )   }   for _ , sctx := range e . sctxs { for ss := range sctx . serversC { ctx , cancel := context . WithTimeout ( context . Background ( ) , timeout )   stopServers ( ctx , ss )   cancel ( )   }   }    for _ , sctx := range e . sctxs { sctx . cancel ( )   }    for i := range e . Clients { if e . Clients [ i ] != nil { e . Clients [ i ] . Close ( )   }   }    for i := range e . metricsListeners { e . metricsListeners [ i ] . Close ( )   }    // close rafthttp transports if e . Server != nil { e . Server . Stop ( )   }    // close all idle connections in peer handler (wait up to 1-second) for i := range e . Peers { if e . Peers [ i ] != nil && e . Peers [ i ] . close != nil { ctx , cancel := context . WithTimeout ( context . Background ( ) , time . Second )   e . Peers [ i ] . close ( ctx )   cancel ( )   }   }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/cluster/membership.go#L30-L144<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func Bootstrap ( state * state . State , gateway * Gateway , name string ) error { // Check parameters if name == " " { return fmt . Errorf ( " " )   }    err := membershipCheckNoLeftoverClusterCert ( state . OS . VarDir )   if err != nil { return err   }    var address string    err = state . Node . Transaction ( func ( tx * db . NodeTx ) error { // Fetch current network address and raft nodes config , err := node . ConfigLoad ( tx )   if err != nil { return errors . Wrap ( err , " " )   }    address = config . ClusterAddress ( )    // Make sure node-local database state is in order. err = membershipCheckNodeStateForBootstrapOrJoin ( tx , address )   if err != nil { return err   }    // Add ourselves as first raft node err = tx . RaftNodeFirst ( address )   if err != nil { return errors . Wrap ( err , " " )   }    return nil   } )   if err != nil { return err   }    // Update our own entry in the nodes table. err = state . Cluster . Transaction ( func ( tx * db . ClusterTx ) error { // Make sure cluster database state is in order. err := membershipCheckClusterStateForBootstrapOrJoin ( tx )   if err != nil { return err   }    // Add ourselves to the nodes table. err = tx . NodeUpdate ( 1 , name , address )   if err != nil { return errors . Wrap ( err , " " )   }    return nil   } )   if err != nil { return err   }    // Shutdown the gateway. This will trash any dqlite connection against // our in-memory dqlite driver and shutdown the associated raft // instance. We also lock regular access to the cluster database since // we don't want any other database code to run while we're // reconfiguring raft. err = state . Cluster . EnterExclusive ( )   if err != nil { return errors . Wrap ( err , " " )   }    err = gateway . Shutdown ( )   if err != nil { return errors . Wrap ( err , " " )   }    // Re-initialize the gateway. This will create a new raft factory an // dqlite driver instance, which will be exposed over gRPC by the // gateway handlers. err = gateway . init ( )   if err != nil { return errors . Wrap ( err , " " )   }    err = gateway . waitLeadership ( )   if err != nil { return err   }    // The cluster certificates are symlinks against the regular node // certificate. for _ , ext := range [ ] string { " " , " " , " " } { if ext == " " && ! shared . PathExists ( filepath . Join ( state . OS . VarDir , " " ) ) { continue   }   err := os . Symlink ( " " + ext , filepath . Join ( state . OS . VarDir , " " + ext ) )   if err != nil { return errors . Wrap ( err , " " )   }   }    // Make sure we can actually connect to the cluster database through // the network endpoint. This also releases the previously acquired // lock and makes the Go SQL pooling system invalidate the old // connection, so new queries will be executed over the new gRPC // network connection. err = state . Cluster . ExitExclusive ( func ( tx * db . ClusterTx ) error { _ , err := tx . Nodes ( )   return err   } )   if err != nil { return errors . Wrap ( err , " " )   }    return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/mrd0ll4r/tbotapi/blob/edc257282178bb5cebbfcc41260ec04c1ec7ac19/ctors.go#L210-L223<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( api * TelegramBotAPI ) NewOutgoingDocument ( recipient Recipient , fileName string , reader io . Reader ) * OutgoingDocument { return & OutgoingDocument { outgoingMessageBase : outgoingMessageBase { outgoingBase : outgoingBase { api : api , Recipient : recipient , } , } , outgoingFileBase : outgoingFileBase { fileName : fileName , r : reader , } , }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/domdebugger/easyjson.go#L544-L548<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * RemoveEventListenerBreakpointParams ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoDomdebugger6 ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/github/fakegithub/fakegithub.go#L318-L320<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( f * FakeClient ) FindIssues ( query , sort string , asc bool ) ( [ ] github . Issue , error ) { return f . Issues , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/typed/reader.go#L92-L95<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( r * Reader ) ReadLen16String ( ) string { len := r . ReadUint16 ( )   return r . ReadString ( int ( len ) )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/justinfx/gofileseq/blob/2555f296b4493d1825f5f6fab4aa0ff51a8306cd/exp/cpp/export/export.go#L494-L499<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func FileSequence_SetDirname ( id FileSeqId , dir * C . char ) { if fs , ok := sFileSeqs . Get ( id ) ; ok { str := C . GoString ( dir )   fs . SetDirname ( str )   }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/headlessexperimental/easyjson.go#L164-L168<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * EventNeedsBeginFramesChanged ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoHeadlessexperimental1 ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/stefantalpalaru/pool/blob/df8b849d27751462526089005979b28064c1e08e/pool.go#L76-L96<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( pool * Pool ) worker ( worker_id uint ) { job_pipe := make ( chan * Job )   WORKER_LOOP : for { pool . job_wanted_pipe <- job_pipe   job := <- job_pipe   if job == nil { time . Sleep ( pool . interval * time . Millisecond )   } else { job . Worker_id = worker_id   pool . subworker ( job )   pool . done_pipe <- job   }   select { case <- pool . worker_kill_pipe : break WORKER_LOOP   default : }   }   pool . worker_wg . Done ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdctl/ctlv3/command/member_command.go#L44-L55<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func NewMemberAddCommand ( ) * cobra . Command { cc := & cobra . Command { Use : " " , Short : " " , Run : memberAddCommandFunc , }    cc . Flags ( ) . StringVar ( & memberPeerURLs , " " , " " , " " )    return cc   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/shared/cmd/format.go#L8-L34<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func FormatSection ( header string , content string ) string { out := " "    // Add section header if header != " " { out += header + " \n "   }    // Indent the content for _ , line := range strings . Split ( content , " \n " ) { if line != " " { out += " "   }    out += line + " \n "   }    if header != " " { // Section separator (when rendering a full section out += " \n "   } else { // Remove last newline when rendering partial section out = strings . TrimSuffix ( out , " \n " )   }    return out   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/onsi/gomega/blob/f0e010e04c08c48a875f83d17df37b04eb3a985b/gexec/session.go#L241-L247<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func TerminateAndWait ( timeout ... interface { } ) { trackedSessionsMutex . Lock ( )   defer trackedSessionsMutex . Unlock ( )   for _ , session := range trackedSessions { session . Terminate ( ) . Wait ( timeout ... )   }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/container_lxc.go#L7534-L7636<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * containerLXC ) createNetworkDevice ( name string , m types . Device ) ( string , error ) { var dev , n1 string    if shared . StringInSlice ( m [ " " ] , [ ] string { " " , " " , " " } ) { // Host Virtual NIC name if m [ " " ] != " " { n1 = m [ " " ]   } else { n1 = deviceNextVeth ( )   }   }    if m [ " " ] == " " { dev = m [ " " ]   }    // Handle bridged and p2p if shared . StringInSlice ( m [ " " ] , [ ] string { " " , " " } ) { n2 := deviceNextVeth ( )    _ , err := shared . RunCommand ( " " , " " , " " , " " , n1 , " " , " " , " " , " " , n2 )   if err != nil { return " " , fmt . Errorf ( " " , err )   }    _ , err = shared . RunCommand ( " " , " " , " " , " " , n1 , " " )   if err != nil { return " " , fmt . Errorf ( " " , n1 , err )   }    if m [ " " ] == " " { err = networkAttachInterface ( m [ " " ] , n1 )   if err != nil { deviceRemoveInterface ( n2 )   return " " , fmt . Errorf ( " " , err )   }    // Attempt to disable router advertisement acceptance networkSysctlSet ( fmt . Sprintf ( " " , n1 ) , " " )   }    dev = n2   }    // Handle physical and macvlan if shared . StringInSlice ( m [ " " ] , [ ] string { " " , " " } ) { // Deal with VLAN device := m [ " " ]   if m [ " " ] != " " { device = networkGetHostDevice ( m [ " " ] , m [ " " ] )   if ! shared . PathExists ( fmt . Sprintf ( " " , device ) ) { _ , err := shared . RunCommand ( " " , " " , " " , " " , m [ " " ] , " " , device , " " , " " , " " , " " , m [ " " ] )   if err != nil { return " " , err   }    // Attempt to disable IPv6 router advertisement acceptance networkSysctlSet ( fmt . Sprintf ( " " , device ) , " " )   }   }    // Handle physical if m [ " " ] == " " { dev = device   }    // Handle macvlan if m [ " " ] == " " { _ , err := shared . RunCommand ( " " , " " , " " , " " , n1 , " " , device , " " , " " , " " , " " )   if err != nil { return " " , fmt . Errorf ( " " , err )   }    dev = n1   }   }    // Set the MAC address if m [ " " ] != " " { _ , err := shared . RunCommand ( " " , " " , " " , " " , dev , " " , m [ " " ] )   if err != nil { deviceRemoveInterface ( dev )   return " " , fmt . Errorf ( " " , err )   }   }    // Bring the interface up _ , err := shared . RunCommand ( " " , " " , " " , " " , dev , " " )   if err != nil { deviceRemoveInterface ( dev )   return " " , fmt . Errorf ( " " , err )   }    // Set the filter if m [ " " ] == " " && shared . IsTrue ( m [ " " ] ) { err = c . createNetworkFilter ( dev , m [ " " ] , m [ " " ] )   if err != nil { return " " , err   }   }    return dev , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/golang/appengine/blob/54a98f90d1c46b7731eb8fb305d2a321c30ef610/log/log.go#L234-L241<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( params * Query ) Run ( c context . Context ) * Result { req , err := makeRequest ( params , internal . FullyQualifiedAppID ( c ) , appengine . VersionID ( c ) )   return & Result { context : c , request : req , err : err , }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/plugins/approve/approvers/owners.go#L339-L343<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( ap * Approvers ) AddAssignees ( logins ... string ) { for _ , login := range logins { ap . assignees . Insert ( strings . ToLower ( login ) )   }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kljensen/snowball/blob/115fa8f6419dcfb9ec4653997b1c6803a5eff962/romance/common.go#L17-L25<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func VnvSuffix ( word * snowballword . SnowballWord , f isVowelFunc , start int ) int { for i := 1 ; i < len ( word . RS [ start : ] ) ; i ++ { j := start + i   if f ( word . RS [ j - 1 ] ) && ! f ( word . RS [ j ] ) { return j + 1   }   }   return len ( word . RS )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/server.go#L2047-L2116<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( s * EtcdServer ) applyConfChange ( cc raftpb . ConfChange , confState * raftpb . ConfState ) ( bool , error ) { if err := s . cluster . ValidateConfigurationChange ( cc ) ; err != nil { cc . NodeID = raft . None   s . r . ApplyConfChange ( cc )   return false , err   }    lg := s . getLogger ( )   * confState = * s . r . ApplyConfChange ( cc )   switch cc . Type { case raftpb . ConfChangeAddNode : m := new ( membership . Member )   if err := json . Unmarshal ( cc . Context , m ) ; err != nil { if lg != nil { lg . Panic ( " " , zap . Error ( err ) )   } else { plog . Panicf ( " " , err )   }   }   if cc . NodeID != uint64 ( m . ID ) { if lg != nil { lg . Panic ( " " , zap . String ( " " , types . ID ( cc . NodeID ) . String ( ) ) , zap . String ( " " , m . ID . String ( ) ) , )   } else { plog . Panicf ( " " )   }   }   s . cluster . AddMember ( m )   if m . ID != s . id { s . r . transport . AddPeer ( m . ID , m . PeerURLs )   }    case raftpb . ConfChangeRemoveNode : id := types . ID ( cc . NodeID )   s . cluster . RemoveMember ( id )   if id == s . id { return true , nil   }   s . r . transport . RemovePeer ( id )    case raftpb . ConfChangeUpdateNode : m := new ( membership . Member )   if err := json . Unmarshal ( cc . Context , m ) ; err != nil { if lg != nil { lg . Panic ( " " , zap . Error ( err ) )   } else { plog . Panicf ( " " , err )   }   }   if cc . NodeID != uint64 ( m . ID ) { if lg != nil { lg . Panic ( " " , zap . String ( " " , types . ID ( cc . NodeID ) . String ( ) ) , zap . String ( " " , m . ID . String ( ) ) , )   } else { plog . Panicf ( " " )   }   }   s . cluster . UpdateRaftAttributes ( m . ID , m . RaftAttributes )   if m . ID != s . id { s . r . transport . UpdatePeer ( m . ID , m . PeerURLs )   }   }   return false , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/containers/image/blob/da9ab3561ad2031aeb5e036b7cf2755d4e246fec/oci/archive/oci_transport.go#L46-L48<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( t ociArchiveTransport ) ParseReference ( reference string ) ( types . ImageReference , error ) { return ParseReference ( reference )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/armon/go-radix/blob/1a2de0c21c94309923825da3df33a4381872c795/radix.go#L147-L233<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( t * Tree ) Insert ( s string , v interface { } ) ( interface { } , bool ) { var parent * node   n := t . root   search := s   for { // Handle key exhaution if len ( search ) == 0 { if n . isLeaf ( ) { old := n . leaf . val   n . leaf . val = v   return old , true   }    n . leaf = & leafNode { key : s , val : v , }   t . size ++   return nil , false   }    // Look for the edge parent = n   n = n . getEdge ( search [ 0 ] )    // No edge, create one if n == nil { e := edge { label : search [ 0 ] , node : & node { leaf : & leafNode { key : s , val : v , } , prefix : search , } , }   parent . addEdge ( e )   t . size ++   return nil , false   }    // Determine longest prefix of the search key on match commonPrefix := longestPrefix ( search , n . prefix )   if commonPrefix == len ( n . prefix ) { search = search [ commonPrefix : ]   continue   }    // Split the node t . size ++   child := & node { prefix : search [ : commonPrefix ] , }   parent . updateEdge ( search [ 0 ] , child )    // Restore the existing node child . addEdge ( edge { label : n . prefix [ commonPrefix ] , node : n , } )   n . prefix = n . prefix [ commonPrefix : ]    // Create a new leaf node leaf := & leafNode { key : s , val : v , }    // If the new key is a subset, add to to this node search = search [ commonPrefix : ]   if len ( search ) == 0 { child . leaf = leaf   return nil , false   }    // Create a new edge for the node child . addEdge ( edge { label : search [ 0 ] , node : & node { leaf : leaf , prefix : search , } , } )   return nil , false   }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/clientv3/snapshot/v3_snapshot.go#L156-L205<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( s * v3Manager ) Status ( dbPath string ) ( ds Status , err error ) { if _ , err = os . Stat ( dbPath ) ; err != nil { return ds , err   }    db , err := bolt . Open ( dbPath , 0400 , & bolt . Options { ReadOnly : true } )   if err != nil { return ds , err   }   defer db . Close ( )    h := crc32 . New ( crc32 . MakeTable ( crc32 . Castagnoli ) )    if err = db . View ( func ( tx * bolt . Tx ) error { // check snapshot file integrity first var dbErrStrings [ ] string   for dbErr := range tx . Check ( ) { dbErrStrings = append ( dbErrStrings , dbErr . Error ( ) )   }   if len ( dbErrStrings ) > 0 { return fmt . Errorf ( " \n " + strings . Join ( dbErrStrings , " \n " ) , len ( dbErrStrings ) )   }   ds . TotalSize = tx . Size ( )   c := tx . Cursor ( )   for next , _ := c . First ( ) ; next != nil ; next , _ = c . Next ( ) { b := tx . Bucket ( next )   if b == nil { return fmt . Errorf ( " " , string ( next ) )   }   h . Write ( next )   iskeyb := ( string ( next ) == " " )   b . ForEach ( func ( k , v [ ] byte ) error { h . Write ( k )   h . Write ( v )   if iskeyb { rev := bytesToRev ( k )   ds . Revision = rev . main   }   ds . TotalKey ++   return nil   } )   }   return nil   } ) ; err != nil { return ds , err   }    ds . Hash = h . Sum32 ( )   return ds , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/pkg/ghclient/wrappers.go#L54-L82<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * Client ) CreateIssue ( org , repo , title , body string , labels , assignees [ ] string ) ( * github . Issue , error ) { glog . Infof ( " \n " , c . dryRun , title , labels , assignees )   if c . dryRun { return nil , nil   }    issue := & github . IssueRequest { Title : & title , Body : & body , }   if len ( labels ) > 0 { issue . Labels = & labels   }   if len ( assignees ) > 0 { issue . Assignees = & assignees   }    var result * github . Issue   _ , err := c . retry ( fmt . Sprintf ( " " , title ) , func ( ) ( * github . Response , error ) { var resp * github . Response   var err error   result , resp , err = c . issueService . Create ( context . Background ( ) , org , repo , issue )   return resp , err   } , )   return result , err   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/gokyle/fswatch/blob/1dbdf8320a690537582afe0f45c947f501adeaad/watcher.go#L59-L70<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( w * Watcher ) Start ( ) <- chan * Notification { if w . notify_chan != nil { return w . notify_chan   }   if w . auto_watch { w . add_chan = make ( chan * watchItem , NotificationBufLen )   go w . watchItemListener ( )   }   w . notify_chan = make ( chan * Notification , NotificationBufLen )   go w . watch ( w . notify_chan )   return w . notify_chan   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/go-opencv/go-opencv/blob/a4fe8ec027ccc9eb8b7d0797db7c76e61083f1db/opencv/cxcore.go#L702-L704<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func SubScalar ( src * IplImage , value Scalar , dst * IplImage ) { SubScalarWithMask ( src , value , dst , nil )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/runtime/easyjson.go#L1237-L1241<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v QueryObjectsReturns ) MarshalJSON ( ) ( [ ] byte , error ) { w := jwriter . Writer { }   easyjsonC5a4559bEncodeGithubComChromedpCdprotoRuntime12 ( & w , v )   return w . Buffer . BuildBytes ( ) , w . Error   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/naoina/genmai/blob/78583835e1e41e3938e1ddfffd7101f8ad27fae0/log.go#L51-L76<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( l * templateLogger ) Print ( start time . Time , query string , args ... interface { } ) error { if len ( args ) > 0 { values := make ( [ ] string , len ( args ) )   for i , arg := range args { values [ i ] = fmt . Sprintf ( " " , arg )   }   query = fmt . Sprintf ( " " , query , strings . Join ( values , " " ) )   } else { query = fmt . Sprintf ( " " , query )   }   data := map [ string ] interface { } { " " : start , " " : fmt . Sprintf ( " " , now ( ) . Sub ( start ) . Seconds ( ) * float64 ( time . Microsecond ) ) , " " : query , }   var buf bytes . Buffer   if err := l . t . Execute ( & buf , data ) ; err != nil { return err   }   l . m . Lock ( )   defer l . m . Unlock ( )   if _ , err := fmt . Fprintln ( l . w , strings . TrimSuffix ( buf . String ( ) , " \n " ) ) ; err != nil { return err   }   return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/justinfx/gofileseq/blob/2555f296b4493d1825f5f6fab4aa0ff51a8306cd/exp/cpp/export/export.go#L292-L305<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func FileSequence_Format ( id FileSeqId , tpl * C . char ) ( * C . char , Error ) { fs , ok := sFileSeqs . Get ( id )   if ! ok { return C . CString ( " " ) , nil   }    str , err := fs . Format ( C . GoString ( tpl ) )   if err != nil { return nil , C . CString ( err . Error ( ) )   }    // caller must free the string return C . CString ( str ) , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/api_cluster.go#L617-L670<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func clusterPutDisable ( d * Daemon ) Response { // Close the cluster database err := d . cluster . Close ( )   if err != nil { return SmartError ( err )   }    // Update our TLS configuration using our original certificate. for _ , suffix := range [ ] string { " " , " " , " " } { path := filepath . Join ( d . os . VarDir , " " + suffix )   if ! shared . PathExists ( path ) { continue   }   err := os . Remove ( path )   if err != nil { return InternalError ( err )   }   }   cert , err := util . LoadCert ( d . os . VarDir )   if err != nil { return InternalError ( errors . Wrap ( err , " " ) )   }    // Reset the cluster database and make it local to this node. d . endpoints . NetworkUpdateCert ( cert )   err = d . gateway . Reset ( cert )   if err != nil { return SmartError ( err )   }    // Re-open the cluster database address , err := node . HTTPSAddress ( d . db )   if err != nil { return SmartError ( err )   }   store := d . gateway . ServerStore ( )   d . cluster , err = db . OpenCluster ( " " , store , address , " " , d . config . DqliteSetupTimeout , dqlite . WithDialFunc ( d . gateway . DialFunc ( ) ) , dqlite . WithContext ( d . gateway . Context ( ) ) , )   if err != nil { return SmartError ( err )   }    // Stop the clustering tasks d . stopClusterTasks ( )    // Remove the cluster flag from the agent version . UserAgentFeatures ( nil )    return EmptySyncResponse   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/t3rm1n4l/nitro/blob/937fe99f63a01a8bea7661c49e2f3f8af6541d7c/skiplist/merger.go#L72-L86<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( mit * MergeIterator ) Next ( ) { mit . curr = nil   if mit . h . Len ( ) == 0 { return   }    o := heap . Pop ( & mit . h )   hi := o . ( heapItem )   mit . curr = hi . n   hi . iter . Next ( )   if hi . iter . Valid ( ) { hi . n = hi . iter . GetNode ( )   heap . Push ( & mit . h , hi )   }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/fujiwara/fluent-agent-hydra/blob/f5c1c02a0b892cf5c08918ec2ff7bbca71cc7e4f/fluent/fluent.go#L89-L101<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( f * Fluent ) Close ( ) ( err error ) { if f . conn != nil { f . mu . Lock ( )   defer f . mu . Unlock ( )   } else { return   }   if f . conn != nil { f . conn . Close ( )   f . conn = nil   }   return   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/delicb/gstring/blob/77637d5e476b8e22d81f6a7bc5311a836dceb1c2/gstring.go#L130-L133<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func Sprintm ( format string , args map [ string ] interface { } ) string { f , a := gformat ( format , args )   return fmt . Sprintf ( f , a ... )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/naoina/genmai/blob/78583835e1e41e3938e1ddfffd7101f8ad27fae0/genmai.go#L1174-L1196<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * Condition ) OrderBy ( table , col interface { } , order ... interface { } ) * Condition { order = append ( [ ] interface { } { table , col } , order ... )   orderbys := make ( [ ] orderBy , 0 , 1 )   for len ( order ) > 0 { o , rest := order [ 0 ] , order [ 1 : ]   if _ , ok := o . ( string ) ; ok { if len ( rest ) < 1 { panic ( fmt . Errorf ( " " ) )   }   // OrderBy("column", genmai.DESC) orderbys = append ( orderbys , c . orderBy ( nil , o , rest [ 0 ] ) )   order = rest [ 1 : ]   continue   }   if len ( rest ) < 2 { panic ( fmt . Errorf ( " " ) )   }   // OrderBy(tbl{}, "column", genmai.DESC) orderbys = append ( orderbys , c . orderBy ( o , rest [ 0 ] , rest [ 1 ] ) )   order = rest [ 2 : ]   }   return c . appendQuery ( 300 , OrderBy , orderbys )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L6648-L6656<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( u StellarMessage ) MustTransaction ( ) TransactionEnvelope { val , ok := u . GetTransaction ( )    if ! ok { panic ( " " )   }    return val   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/bazelbuild/bazel-gazelle/blob/e3805aaca69a9deb949b47bfc45b9b1870712f4f/repo/repo.go#L95-L112<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ImportRepoRules ( filename string , repoCache * RemoteCache ) ( [ ] * rule . Rule , error ) { format := getLockFileFormat ( filename )   if format == unknownFormat { return nil , fmt . Errorf ( `%s: unrecognized lock file format. Expected "Gopkg.lock", "go.mod", or "Godeps.json"` , filename )   }   parser := lockFileParsers [ format ]   repos , err := parser ( filename , repoCache )   if err != nil { return nil , fmt . Errorf ( " " , filename , err )   }   sort . Stable ( byName ( repos ) )    rules := make ( [ ] * rule . Rule , 0 , len ( repos ) )   for _ , repo := range repos { rules = append ( rules , GenerateRule ( repo ) )   }   return rules , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/dgraph-io/badger/blob/6b796b3ebec3ff006fcb1b425836cd784651e9fd/manifest.go#L99-L105<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( m * Manifest ) asChanges ( ) [ ] * pb . ManifestChange { changes := make ( [ ] * pb . ManifestChange , 0 , len ( m . Tables ) )   for id , tm := range m . Tables { changes = append ( changes , newCreateChange ( id , int ( tm . Level ) , tm . Checksum ) )   }   return changes   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/ctripcorp/ghost/blob/9dce30d85194129b9c0ba6702c612f3b5c41d02f/pool/wrappedConn.go#L24-L33<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * WrappedConn ) Write ( b [ ] byte ) ( n int , err error ) { //c.Conn is certainly not nil n , err = c . Conn . Write ( b )   if err != nil { c . unusable = true   } else { c . start = time . Now ( )   }   return   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubicorn/kubicorn/blob/c4a4b80994b4333709c0f8164faabd801866b986/cloud/google/compute/resources/instancegroup.go#L121-L335<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( r * InstanceGroup ) Apply ( actual , expected cloud . Resource , immutable * cluster . Cluster ) ( * cluster . Cluster , cloud . Resource , error ) { logger . Debug ( " " )   applyResource := expected . ( * InstanceGroup )   isEqual , err := compare . IsEqual ( actual . ( * InstanceGroup ) , expected . ( * InstanceGroup ) )   if err != nil { return nil , nil , err   }   if isEqual { return immutable , applyResource , nil   }    masterIPPrivate := " "   masterIPPublic := " "   if r . ServerPool . Type == cluster . ServerPoolTypeNode { found := false   for i := 0 ; i < MasterIPAttempts ; i ++ { masterTag := " "   machineConfigs := immutable . MachineProviderConfigs ( )   for _ , machineConfig := range machineConfigs { serverPool := machineConfig . ServerPool   if serverPool . Type == cluster . ServerPoolTypeMaster { masterTag = serverPool . Name   }   }   if masterTag == " " { return nil , nil , fmt . Errorf ( " " )   }    instanceGroupManager , err := Sdk . Service . InstanceGroupManagers . ListManagedInstances ( immutable . ProviderConfig ( ) . CloudId , expected . ( * InstanceGroup ) . Location , strings . ToLower ( masterTag ) ) . Do ( )   if err != nil { return nil , nil , err   }    if err != nil || len ( instanceGroupManager . ManagedInstances ) == 0 { logger . Debug ( " " , err )   time . Sleep ( time . Duration ( MasterIPSleepSecondsPerAttempt ) * time . Second )   continue   }    parts := strings . Split ( instanceGroupManager . ManagedInstances [ 0 ] . Instance , " " )   instance , err := Sdk . Service . Instances . Get ( immutable . ProviderConfig ( ) . CloudId , expected . ( * InstanceGroup ) . Location , parts [ len ( parts ) - 1 ] ) . Do ( )   if err != nil { logger . Debug ( " " , err )   time . Sleep ( time . Duration ( MasterIPSleepSecondsPerAttempt ) * time . Second )   continue   }    for _ , networkInterface := range instance . NetworkInterfaces { if networkInterface . Name == " " { masterIPPrivate = networkInterface . NetworkIP   for _ , accessConfigs := range networkInterface . AccessConfigs { masterIPPublic = accessConfigs . NatIP   }   }   }    if masterIPPublic == " " { logger . Debug ( " " )   time . Sleep ( time . Duration ( MasterIPSleepSecondsPerAttempt ) * time . Second )   continue   }    found = true   providerConfig := immutable . ProviderConfig ( )   providerConfig . Values . ItemMap [ " " ] = fmt . Sprintf ( " " , masterIPPrivate , immutable . ProviderConfig ( ) . KubernetesAPI . Port )   immutable . SetProviderConfig ( providerConfig )   break   }   if ! found { return nil , nil , fmt . Errorf ( " " )   }   }    providerConfig := immutable . ProviderConfig ( )   providerConfig . Values . ItemMap [ " " ] = immutable . ProviderConfig ( ) . KubernetesAPI . Port   immutable . SetProviderConfig ( providerConfig )    scripts , err := script . BuildBootstrapScript ( r . ServerPool . BootstrapScripts , immutable )   if err != nil { return nil , nil , err   }    finalScripts := string ( scripts )   if err != nil { return nil , nil , err   }    tags := [ ] string { }   if r . ServerPool . Type == cluster . ServerPoolTypeMaster { if immutable . ProviderConfig ( ) . KubernetesAPI . Port == " " { tags = append ( tags , " " )   }    if immutable . ProviderConfig ( ) . KubernetesAPI . Port == " " { tags = append ( tags , " " )   }    tags = append ( tags , " " )   }    if r . ServerPool . Type == cluster . ServerPoolTypeNode { tags = append ( tags , " " )   }    prefix := " " + immutable . ProviderConfig ( ) . CloudId   imageURL := " " + expected . ( * InstanceGroup ) . Image    templateInstance , err := Sdk . Service . InstanceTemplates . Get ( immutable . ProviderConfig ( ) . CloudId , strings . ToLower ( expected . ( * InstanceGroup ) . Name ) ) . Do ( )   if err != nil { sshPublicKeyValue := fmt . Sprintf ( " " , immutable . ProviderConfig ( ) . SSH . User , string ( immutable . ProviderConfig ( ) . SSH . PublicKeyData ) )    templateInstance = & compute . InstanceTemplate { Name : strings . ToLower ( expected . ( * InstanceGroup ) . Name ) , Properties : & compute . InstanceProperties { MachineType : expected . ( * InstanceGroup ) . Size , Disks : [ ] * compute . AttachedDisk { { AutoDelete : true , Boot : true , Type : " " , InitializeParams : & compute . AttachedDiskInitializeParams { SourceImage : imageURL , } , } , } , NetworkInterfaces : [ ] * compute . NetworkInterface { { AccessConfigs : [ ] * compute . AccessConfig { { Type : " " , Name : " " , } , } , Network : prefix + " " , } , } , ServiceAccounts : [ ] * compute . ServiceAccount { { Email : " " , Scopes : [ ] string { compute . DevstorageFullControlScope , compute . ComputeScope , } , } , } , Metadata : & compute . Metadata { Kind : " " , Items : [ ] * compute . MetadataItems { { Key : " " , Value : & sshPublicKeyValue , } , { Key : " " , Value : & finalScripts , } , } , } , Tags : & compute . Tags { Items : tags , } , } , }    _ , err = Sdk . Service . InstanceTemplates . Insert ( immutable . ProviderConfig ( ) . CloudId , templateInstance ) . Do ( )   if err != nil { return nil , nil , err   }   }    _ , err = Sdk . Service . InstanceGroupManagers . Get ( immutable . ProviderConfig ( ) . CloudId , expected . ( * InstanceGroup ) . Location , strings . ToLower ( expected . ( * InstanceGroup ) . Name ) ) . Do ( )   if err != nil { instanceGroupManager := & compute . InstanceGroupManager { Name : templateInstance . Name , BaseInstanceName : templateInstance . Name , InstanceTemplate : prefix + " " + templateInstance . Name , TargetSize : int64 ( expected . ( * InstanceGroup ) . Count ) , }    for i := 0 ; i < MasterIPAttempts ; i ++ { logger . Debug ( " " )   _ , err = Sdk . Service . InstanceGroupManagers . Insert ( immutable . ProviderConfig ( ) . CloudId , expected . ( * InstanceGroup ) . Location , instanceGroupManager ) . Do ( )   if err == nil { break   }    logger . Debug ( " " )   time . Sleep ( time . Duration ( MasterIPSleepSecondsPerAttempt ) * time . Second )   }    logger . Success ( " " , templateInstance . Name )   }    newResource := & InstanceGroup { Shared : Shared { Name : r . ServerPool . Name , //CloudID: id, } , Image : expected . ( * InstanceGroup ) . Image , Size : expected . ( * InstanceGroup ) . Size , Location : expected . ( * InstanceGroup ) . Location , Count : expected . ( * InstanceGroup ) . Count , BootstrapScripts : expected . ( * InstanceGroup ) . BootstrapScripts , }    providerConfig = immutable . ProviderConfig ( )   providerConfig . KubernetesAPI . Endpoint = masterIPPublic   immutable . SetProviderConfig ( providerConfig )    renderedCluster , err := r . immutableRender ( newResource , immutable )   if err != nil { return nil , nil , err   }   return renderedCluster , newResource , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/iron-io/functions_go/blob/91b84f5bbb17095bf1c7028ec6e70a3dc06a5893/client/routes/get_apps_app_routes_parameters.go#L77-L80<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( o * GetAppsAppRoutesParams ) WithTimeout ( timeout time . Duration ) * GetAppsAppRoutesParams { o . SetTimeout ( timeout )   return o   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/layertree/easyjson.go#L646-L650<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v ReleaseSnapshotParams ) MarshalJSON ( ) ( [ ] byte , error ) { w := jwriter . Writer { }   easyjsonC5a4559bEncodeGithubComChromedpCdprotoLayertree6 ( & w , v )   return w . Buffer . BuildBytes ( ) , w . Error   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/experiment/resultstore/main.go#L487-L526<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func insertLink ( started * gcs . Started , viewURL string ) ( bool , error ) { if started . Metadata == nil { started . Metadata = metadata . Metadata { }   }   meta := started . Metadata   var changed bool   top , present := meta . String ( resultstoreKey )   if ! present || top == nil || * top != viewURL { changed = true   meta [ resultstoreKey ] = viewURL   }   links , present := meta . Meta ( linksKey )   if present && links == nil { return false , fmt . Errorf ( " " , meta [ linksKey ] )   }   if links == nil { links = & metadata . Metadata { }   changed = true   }   resultstoreMeta , present := links . Meta ( resultstoreKey )   if present && resultstoreMeta == nil { return false , fmt . Errorf ( " " , ( * links ) [ resultstoreKey ] )   }   if resultstoreMeta == nil { resultstoreMeta = & metadata . Metadata { }   changed = true   }   val , present := resultstoreMeta . String ( urlKey )   if present && val == nil { return false , fmt . Errorf ( " " , ( * resultstoreMeta ) [ urlKey ] )   }   if ! changed && val != nil && * val == viewURL { return false , nil   }    ( * resultstoreMeta ) [ urlKey ] = viewURL   ( * links ) [ resultstoreKey ] = * resultstoreMeta   meta [ linksKey ] = * links   return true , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/price.go#L8-L10<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p * Price ) String ( ) string { return big . NewRat ( int64 ( p . N ) , int64 ( p . D ) ) . FloatString ( 7 )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kpango/glg/blob/68d2670cb2dbff047331daad841149a82ac37796/glg.go#L493-L502<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( g * Glg ) DisableLevelColor ( lv LEVEL ) * Glg { ins , ok := g . logger . Load ( lv )   if ok { l := ins . ( * logger )   l . isColor = false   l . updateMode ( )   g . logger . Store ( lv , l )   }   return g   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/container_lxc.go#L8402-L8548<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * containerLXC ) getDiskLimits ( ) ( map [ string ] deviceBlockLimit , error ) { result := map [ string ] deviceBlockLimit { }    // Build a list of all valid block devices validBlocks := [ ] string { }    dents , err := ioutil . ReadDir ( " " )   if err != nil { return nil , err   }    for _ , f := range dents { fPath := filepath . Join ( " " , f . Name ( ) )   if shared . PathExists ( fmt . Sprintf ( " " , fPath ) ) { continue   }    if ! shared . PathExists ( fmt . Sprintf ( " " , fPath ) ) { continue   }    block , err := ioutil . ReadFile ( fmt . Sprintf ( " " , fPath ) )   if err != nil { return nil , err   }    validBlocks = append ( validBlocks , strings . TrimSuffix ( string ( block ) , " \n " ) )   }    // Process all the limits blockLimits := map [ string ] [ ] deviceBlockLimit { }   for _ , k := range c . expandedDevices . DeviceNames ( ) { m := c . expandedDevices [ k ]   if m [ " " ] != " " { continue   }    // Apply max limit if m [ " " ] != " " { m [ " " ] = m [ " " ]   m [ " " ] = m [ " " ]   }    // Parse the user input readBps , readIops , writeBps , writeIops , err := deviceParseDiskLimit ( m [ " " ] , m [ " " ] )   if err != nil { return nil , err   }    // Set the source path source := shared . HostPath ( m [ " " ] )   if source == " " { source = c . RootfsPath ( )   }    // Don't try to resolve the block device behind a non-existing path if ! shared . PathExists ( source ) { continue   }    // Get the backing block devices (major:minor) blocks , err := deviceGetParentBlocks ( source )   if err != nil { if readBps == 0 && readIops == 0 && writeBps == 0 && writeIops == 0 { // If the device doesn't exist, there is no limit to clear so ignore the failure continue   } else { return nil , err   }   }    device := deviceBlockLimit { readBps : readBps , readIops : readIops , writeBps : writeBps , writeIops : writeIops }   for _ , block := range blocks { blockStr := " "    if shared . StringInSlice ( block , validBlocks ) { // Straightforward entry (full block device) blockStr = block   } else { // Attempt to deal with a partition (guess its parent) fields := strings . SplitN ( block , " " , 2 )   fields [ 1 ] = " "   if shared . StringInSlice ( fmt . Sprintf ( " " , fields [ 0 ] , fields [ 1 ] ) , validBlocks ) { blockStr = fmt . Sprintf ( " " , fields [ 0 ] , fields [ 1 ] )   }   }    if blockStr == " " { return nil , fmt . Errorf ( " " , block )   }    if blockLimits [ blockStr ] == nil { blockLimits [ blockStr ] = [ ] deviceBlockLimit { }   }   blockLimits [ blockStr ] = append ( blockLimits [ blockStr ] , device )   }   }    // Average duplicate limits for block , limits := range blockLimits { var readBpsCount , readBpsTotal , readIopsCount , readIopsTotal , writeBpsCount , writeBpsTotal , writeIopsCount , writeIopsTotal int64    for _ , limit := range limits { if limit . readBps > 0 { readBpsCount += 1   readBpsTotal += limit . readBps   }    if limit . readIops > 0 { readIopsCount += 1   readIopsTotal += limit . readIops   }    if limit . writeBps > 0 { writeBpsCount += 1   writeBpsTotal += limit . writeBps   }    if limit . writeIops > 0 { writeIopsCount += 1   writeIopsTotal += limit . writeIops   }   }    device := deviceBlockLimit { }    if readBpsCount > 0 { device . readBps = readBpsTotal / readBpsCount   }    if readIopsCount > 0 { device . readIops = readIopsTotal / readIopsCount   }    if writeBpsCount > 0 { device . writeBps = writeBpsTotal / writeBpsCount   }    if writeIopsCount > 0 { device . writeIops = writeIopsTotal / writeIopsCount   }    result [ block ] = device   }    return result , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/runtime/runtime.go#L431-L440<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p * GetIsolateIDParams ) Do ( ctx context . Context ) ( id string , err error ) { // execute var res GetIsolateIDReturns   err = cdp . Execute ( ctx , CommandGetIsolateID , nil , & res )   if err != nil { return " " , err   }    return res . ID , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/page/easyjson.go#L6338-L6342<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * EventDownloadWillBegin ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoPage67 ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/cluster/membership.go#L897-L916<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func membershipCheckClusterStateForLeave ( tx * db . ClusterTx , nodeID int64 ) error { // Check that it has no containers or images. message , err := tx . NodeIsEmpty ( nodeID )   if err != nil { return err   }   if message != " " { return fmt . Errorf ( message )   }    // Check that it's not the last node. nodes , err := tx . Nodes ( )   if err != nil { return err   }   if len ( nodes ) == 1 { return fmt . Errorf ( " " )   }   return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/cm15/examples/rsssh/main.go#L179-L191<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func server ( client * cm15 . API , name string ) * cm15 . Instance { serverLocator := client . ServerLocator ( " " )   servers , err := serverLocator . Index ( rsapi . APIParams { " " : " " , " " : [ ] string { " " + name } } )   if err != nil { fail ( " \n " , err . Error ( ) )   }   if len ( servers ) == 0 { fail ( " \n " , name )   } else if len ( servers ) != 1 { fail ( " \n " , name )   }   return servers [ 0 ] . CurrentInstance   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/tracing.go#L121-L131<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func CurrentSpan ( ctx context . Context ) * Span { if sp := opentracing . SpanFromContext ( ctx ) ; sp != nil { var injectable injectableSpan   if err := injectable . initFromOpenTracing ( sp ) ; err == nil { span := Span ( injectable )   return & span   }   // return empty span on error, instead of possibly a partially filled one }   return & emptySpan   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/ip2location/ip2location-go/blob/a417f19539fd2a0eb0adf273b4190241cacc0499/ip2location.go#L681-L702<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func Printrecord ( x IP2Locationrecord ) { fmt . Printf ( " \n " , x . Country_short )   fmt . Printf ( " \n " , x . Country_long )   fmt . Printf ( " \n " , x . Region )   fmt . Printf ( " \n " , x . City )   fmt . Printf ( " \n " , x . Isp )   fmt . Printf ( " \n " , x . Latitude )   fmt . Printf ( " \n " , x . Longitude )   fmt . Printf ( " \n " , x . Domain )   fmt . Printf ( " \n " , x . Zipcode )   fmt . Printf ( " \n " , x . Timezone )   fmt . Printf ( " \n " , x . Netspeed )   fmt . Printf ( " \n " , x . Iddcode )   fmt . Printf ( " \n " , x . Areacode )   fmt . Printf ( " \n " , x . Weatherstationcode )   fmt . Printf ( " \n " , x . Weatherstationname )   fmt . Printf ( " \n " , x . Mcc )   fmt . Printf ( " \n " , x . Mnc )   fmt . Printf ( " \n " , x . Mobilebrand )   fmt . Printf ( " \n " , x . Elevation )   fmt . Printf ( " \n " , x . Usagetype )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/go-opencv/go-opencv/blob/a4fe8ec027ccc9eb8b7d0797db7c76e61083f1db/opencv/highgui.go#L364-L374<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func LoadImage ( filename string , iscolor_ ... int ) * IplImage { iscolor := CV_LOAD_IMAGE_COLOR   if len ( iscolor_ ) > 0 { iscolor = iscolor_ [ 0 ]   }   name_c := C . CString ( filename )   defer C . free ( unsafe . Pointer ( name_c ) )    rv := C . cvLoadImage ( name_c , C . int ( iscolor ) )   return ( * IplImage ) ( rv )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/network/easyjson.go#L6080-L6084<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v EventResponseReceived ) MarshalJSON ( ) ( [ ] byte , error ) { w := jwriter . Writer { }   easyjsonC5a4559bEncodeGithubComChromedpCdprotoNetwork48 ( & w , v )   return w . Buffer . BuildBytes ( ) , w . Error   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/fuzzy/cluster.go#L369-L388<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func assertLogEntryEqual ( t * testing . T , node string , exp * raft . Log , act * raft . Log ) bool { res := true   if exp . Term != act . Term { t . Errorf ( " " , exp . Index , node , exp . Term , act . Term )   res = false   }   if exp . Index != act . Index { t . Errorf ( " " , node , exp . Index , act . Index )   res = false   }   if exp . Type != act . Type { t . Errorf ( " " , node , exp . Index , exp . Type , act . Type )   res = false   }   if ! bytes . Equal ( exp . Data , act . Data ) { t . Errorf ( " " , node , exp . Index , exp . Data , act . Data )   res = false   }   return res   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/qor/roles/blob/d6375609fe3e5da46ad3a574fae244fb633e79c1/role.go#L49-L51<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( role * Role ) Allow ( mode PermissionMode , roles ... string ) * Permission { return role . NewPermission ( ) . Allow ( mode , roles ... )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/domsnapshot/easyjson.go#L1271-L1275<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v NameValue ) MarshalJSON ( ) ( [ ] byte , error ) { w := jwriter . Writer { }   easyjsonC5a4559bEncodeGithubComChromedpCdprotoDomsnapshot5 ( & w , v )   return w . Buffer . BuildBytes ( ) , w . Error   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/mgutz/str/blob/968bf66e3da857419e4f6e71b2d5c9ae95682dc4/funcsPZ.go#L384-L387<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ToBool ( s string ) bool { s = strings . ToLower ( s )   return s == " " || s == " " || s == " " || s == " "   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/api/capability.go#L60-L82<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func UpdateCapability ( lg * zap . Logger , v * semver . Version ) { if v == nil { // if recovered but version was never set by cluster return   }   enableMapMu . Lock ( )   if curVersion != nil && ! curVersion . LessThan ( * v ) { enableMapMu . Unlock ( )   return   }   curVersion = v   enabledMap = capabilityMaps [ curVersion . String ( ) ]   enableMapMu . Unlock ( )    if lg != nil { lg . Info ( " " , zap . String ( " " , version . Cluster ( v . String ( ) ) ) , )   } else { plog . Infof ( " " , version . Cluster ( v . String ( ) ) )   }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/schema/update.go#L18-L53<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func DotGo ( updates map [ int ] Update , name string ) error { // Apply all the updates that we have on a pristine database and dump // the resulting schema. db , err := sql . Open ( " " , " " )   if err != nil { return fmt . Errorf ( " " , err )   }    schema := NewFromMap ( updates )    _ , err = schema . Ensure ( db )   if err != nil { return err   }    dump , err := schema . Dump ( db )   if err != nil { return err   }    // Passing 1 to runtime.Caller identifies our caller. _ , filename , _ , _ := runtime . Caller ( 1 )    file , err := os . Create ( path . Join ( path . Dir ( filename ) , name + " " ) )   if err != nil { return fmt . Errorf ( " " , err )   }    pkg := path . Base ( path . Dir ( filename ) )   _ , err = file . Write ( [ ] byte ( fmt . Sprintf ( dotGoTemplate , pkg , dump ) ) )   if err != nil { return fmt . Errorf ( " " , err )   }    return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/gen/writers/metadata.go#L43-L45<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * MetadataWriter ) WriteHeader ( pkg string , w io . Writer ) error { return c . headerTmpl . Execute ( w , pkg )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/ChrisTrenkamp/goxpath/blob/c385f95c6022e7756e91beac5f5510872f7dcb7d/internal/execxp/findutil/findUtil.go#L34-L46<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func Find ( x tree . Node , p pathexpr . PathExpr ) [ ] tree . Node { ret := [ ] tree . Node { }    if p . Axis == " " { findChild ( x , & p , & ret )   return ret   }    f := findMap [ p . Axis ]   f ( x , & p , & ret )    return ret   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/systeminfo/easyjson.go#L277-L281<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * GetProcessInfoParams ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoSysteminfo2 ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/clientv3/balancer/resolver/endpoint/endpoint.go#L219-L229<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ParseTarget ( target string ) ( string , string , error ) { noPrefix := strings . TrimPrefix ( target , targetPrefix )   if noPrefix == target { return " " , " " , fmt . Errorf ( " " , targetPrefix , target )   }   parts := strings . SplitN ( noPrefix , " " , 2 )   if len ( parts ) != 2 { return " " , " " , fmt . Errorf ( " " , scheme , target )   }   return parts [ 0 ] , parts [ 1 ] , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/256dpi/fire/blob/fa66e74352b30b9a4c730f7b8dc773302941b0fb/coal/indexer.go#L63-L68<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( i * Indexer ) AddRaw ( coll string , idx mgo . Index ) { i . indexes = append ( i . indexes , index { coll : coll , index : idx , } )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/cm15/codegen_client.go#L5907-L5914<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( r * MultiCloudImageSetting ) Locator ( api * API ) * MultiCloudImageSettingLocator { for _ , l := range r . Links { if l [ " " ] == " " { return api . MultiCloudImageSettingLocator ( l [ " " ] )   }   }   return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/debugger/types.go#L270-L272<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( t * PausedReason ) UnmarshalJSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/llgcode/draw2d/blob/f52c8a71aff06ab8df41843d33ab167b36c971cd/draw2dgl/gc.go#L233-L266<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( gc * GraphicContext ) GetStringBounds ( s string ) ( left , top , right , bottom float64 ) { f , err := gc . loadCurrentFont ( )   if err != nil { log . Println ( err )   return 0 , 0 , 0 , 0   }   top , left , bottom , right = 10e6 , 10e6 , - 10e6 , - 10e6   cursor := 0.0   prev , hasPrev := truetype . Index ( 0 ) , false   for _ , rune := range s { index := f . Index ( rune )   if hasPrev { cursor += fUnitsToFloat64 ( f . Kern ( fixed . Int26_6 ( gc . Current . Scale ) , prev , index ) )   }   if err := gc . glyphBuf . Load ( gc . Current . Font , fixed . Int26_6 ( gc . Current . Scale ) , index , font . HintingNone ) ; err != nil { log . Println ( err )   return 0 , 0 , 0 , 0   }   e0 := 0   for _ , e1 := range gc . glyphBuf . Ends { ps := gc . glyphBuf . Points [ e0 : e1 ]   for _ , p := range ps { x , y := pointToF64Point ( p )   top = math . Min ( top , y )   bottom = math . Max ( bottom , y )   left = math . Min ( left , x + cursor )   right = math . Max ( right , x + cursor )   }   }   cursor += fUnitsToFloat64 ( f . HMetric ( fixed . Int26_6 ( gc . Current . Scale ) , index ) . AdvanceWidth )   prev , hasPrev = index , true   }   return left , top , right , bottom   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/taskcluster/taskcluster-client-go/blob/ef6acd428ae5844a933792ed6479d0e7dca61ef8/tcindex/tcindex.go#L99-L103<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( index * Index ) Ping ( ) error { cd := tcclient . Client ( * index )   _ , _ , err := ( & cd ) . APICall ( nil , " " , " " , nil , nil )   return err   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/segmentio/nsq-go/blob/ff4eef968f46eb580d9dba4f637c5dfb1e5b2208/nsqlookup/engine.go#L76-L81<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( info NodeInfo2 ) String ( ) string { if len ( info . Hostname ) != 0 { return info . Hostname   }   return makeBroadcastAddress ( info . BroadcastAddress , info . HttpPort )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/tendermint/go-amino/blob/dc14acf9ef15f85828bfbc561ed9dd9d2a284885/json-encode.go#L443-L457<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func isEmpty ( rv reflect . Value , zrv reflect . Value ) bool { if ! rv . IsValid ( ) { return true   }   if reflect . DeepEqual ( rv . Interface ( ) , zrv . Interface ( ) ) { return true   }   switch rv . Kind ( ) { case reflect . Slice , reflect . Array , reflect . String : if rv . Len ( ) == 0 { return true   }   }   return false   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/page/easyjson.go#L7696-L7700<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * AddCompilationCacheParams ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoPage85 ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/input/input.go#L196-L199<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p DispatchMouseEventParams ) WithModifiers ( modifiers Modifier ) * DispatchMouseEventParams { p . Modifiers = modifiers   return & p   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/gopistolet/gospf/blob/a58dd1fcbf509d558a6809c54defbce6872c40c5/spf.go#L570-L662<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( spf * SPF ) CheckIP ( ip_str string ) ( string , error ) { ip := net . ParseIP ( ip_str )   for _ , ip_net := range spf . Fail { if ip_net . Contains ( ip ) { return " " , nil   }   }   for _ , ip_net := range spf . SoftFail { if ip_net . Contains ( ip ) { return " " , nil   }   }   for _ , ip_net := range spf . Neutral { if ip_net . Contains ( ip ) { return " " , nil   }   }   for _ , ip_net := range spf . Pass { if ip_net . Contains ( ip ) { return " " , nil   }   }    for _ , include := range spf . Includes { /* 			RFC 7208 5.2 				The "include" mechanism triggers a recursive evaluation of 				check_host().  				1.  The <domain-spec> is expanded as per Section 7.  				2.  check_host() is evaluated with the resulting string as the 					<domain>.  The <ip> and <sender> arguments remain the same as in 					the current evaluation of check_host().  				3.  The recursive evaluation returns match, not-match, or an error.  				4.  If it returns match, then the appropriate result for the 					"include" mechanism is used (e.g., include or +include produces a 					"pass" result and -include produces "fail").  				5.  If it returns not-match or an error, the parent check_host() 					resumes processing as per the table below, with the previous 					value of <domain> restored.  				+---------------------------------+---------------------------------+ 				| A recursive check_host() result | Causes the "include" mechanism  | 				| of:                             | to:                             | 				+---------------------------------+---------------------------------+ 				| pass                            | match                           | 				|                                 |                                 | 				| fail                            | not match                       | 				|                                 |                                 | 				| softfail                        | not match                       | 				|                                 |                                 | 				| neutral                         | not match                       | 				|                                 |                                 | 				| temperror                       | return temperror                | 				|                                 |                                 | 				| permerror                       | return permerror                | 				|                                 |                                 | 				| none                            | return permerror                | 				+---------------------------------+---------------------------------+ 		*/ check , err := include . spf . CheckIP ( ip_str )   if err != nil { return " " , nil   }   if check == " " { return qualifierToResult ( include . qualifier ) , nil   }   }    // Check redirects /* 		RFC 7208 6.1. 			For clarity, any "redirect" modifier SHOULD appear as the very last 			term in a record.  Any "redirect" modifier MUST be ignored if there 			is an "all" mechanism anywhere in the record. 	*/ if spf . All == " " { if spf . Redirect != nil { return spf . Redirect . CheckIP ( ip_str )   }   }    // No results found -> check all if spf . All != " " { return qualifierToResult ( spf . All ) , nil   }    return " " , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdctl/ctlv2/command/backup_command.go#L58-L103<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func handleBackup ( c * cli . Context ) error { var srcWAL string   var destWAL string    withV3 := c . Bool ( " " )   srcSnap := filepath . Join ( c . String ( " " ) , " " , " " )   destSnap := filepath . Join ( c . String ( " " ) , " " , " " )    if c . String ( " " ) != " " { srcWAL = c . String ( " " )   } else { srcWAL = filepath . Join ( c . String ( " " ) , " " , " " )   }    if c . String ( " " ) != " " { destWAL = c . String ( " " )   } else { destWAL = filepath . Join ( c . String ( " " ) , " " , " " )   }    if err := fileutil . CreateDirAll ( destSnap ) ; err != nil { log . Fatalf ( " " , destSnap , err )   }    walsnap := saveSnap ( destSnap , srcSnap )   metadata , state , ents := loadWAL ( srcWAL , walsnap , withV3 )   saveDB ( filepath . Join ( destSnap , " " ) , filepath . Join ( srcSnap , " " ) , state . Commit , withV3 )    idgen := idutil . NewGenerator ( 0 , time . Now ( ) )   metadata . NodeID = idgen . Next ( )   metadata . ClusterID = idgen . Next ( )    neww , err := wal . Create ( zap . NewExample ( ) , destWAL , pbutil . MustMarshal ( & metadata ) )   if err != nil { log . Fatal ( err )   }   defer neww . Close ( )   if err := neww . Save ( state , ents ) ; err != nil { log . Fatal ( err )   }   if err := neww . SaveSnapshot ( walsnap ) ; err != nil { log . Fatal ( err )   }    return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/dgraph-io/badger/blob/6b796b3ebec3ff006fcb1b425836cd784651e9fd/db.go#L919-L953<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( db * DB ) calculateSize ( ) { newInt := func ( val int64 ) * expvar . Int { v := new ( expvar . Int )   v . Add ( val )   return v   }    totalSize := func ( dir string ) ( int64 , int64 ) { var lsmSize , vlogSize int64   err := filepath . Walk ( dir , func ( path string , info os . FileInfo , err error ) error { if err != nil { return err   }   ext := filepath . Ext ( path )   if ext == " " { lsmSize += info . Size ( )   } else if ext == " " { vlogSize += info . Size ( )   }   return nil   } )   if err != nil { db . elog . Printf ( " " , dir )   }   return lsmSize , vlogSize   }    lsmSize , vlogSize := totalSize ( db . opt . Dir )   y . LSMSize . Set ( db . opt . Dir , newInt ( lsmSize ) )   // If valueDir is different from dir, we'd have to do another walk. if db . opt . ValueDir != db . opt . Dir { _ , vlogSize = totalSize ( db . opt . ValueDir )   }   y . VlogSize . Set ( db . opt . Dir , newInt ( vlogSize ) )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/config/jobs.go#L482-L499<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * JobConfig ) AllPresubmits ( repos [ ] string ) [ ] Presubmit { var res [ ] Presubmit    for repo , v := range c . Presubmits { if len ( repos ) == 0 { res = append ( res , v ... )   } else { for _ , r := range repos { if r == repo { res = append ( res , v ... )   break   }   }   }   }    return res   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/xwb1989/sqlparser/blob/120387863bf27d04bc07db8015110a6e96d0146c/ast.go#L3395-L3406<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func Backtick ( in string ) string { var buf bytes . Buffer   buf . WriteByte ( '`' )   for _ , c := range in { buf . WriteRune ( c )   if c == '`' { buf . WriteByte ( '`' )   }   }   buf . WriteByte ( '`' )   return buf . String ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/target/easyjson.go#L2149-L2153<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v CreateBrowserContextReturns ) MarshalJSON ( ) ( [ ] byte , error ) { w := jwriter . Writer { }   easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget24 ( & w , v )   return w . Buffer . BuildBytes ( ) , w . Error   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/spyglass/gcsartifact_fetcher.go#L183-L185<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( src * gcsJobSource ) canonicalLink ( ) string { return path . Join ( src . linkPrefix , src . bucket , src . jobPrefix )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/segmentio/objconv/blob/7a1d7b8e6f3551b30751e6b2ea6bae500883870e/adapter.go#L45-L50<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func AdapterOf ( typ reflect . Type ) ( a Adapter , ok bool ) { adapterMutex . RLock ( )   a , ok = adapterStore [ typ ]   adapterMutex . RUnlock ( )   return   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/justinfx/gofileseq/blob/2555f296b4493d1825f5f6fab4aa0ff51a8306cd/frameset.go#L222-L225<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( s * FrameSet ) Normalize ( ) * FrameSet { ptr := s . rangePtr . Normalized ( )   return & FrameSet { ptr . String ( ) , ptr }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/contrib/raftexample/raft.go#L81-L108<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func newRaftNode ( id int , peers [ ] string , join bool , getSnapshot func ( ) ( [ ] byte , error ) , proposeC <- chan string , confChangeC <- chan raftpb . ConfChange ) ( <- chan * string , <- chan error , <- chan * snap . Snapshotter ) { commitC := make ( chan * string )   errorC := make ( chan error )    rc := & raftNode { proposeC : proposeC , confChangeC : confChangeC , commitC : commitC , errorC : errorC , id : id , peers : peers , join : join , waldir : fmt . Sprintf ( " " , id ) , snapdir : fmt . Sprintf ( " " , id ) , getSnapshot : getSnapshot , snapCount : defaultSnapshotCount , stopc : make ( chan struct { } ) , httpstopc : make ( chan struct { } ) , httpdonec : make ( chan struct { } ) , snapshotterReady : make ( chan * snap . Snapshotter , 1 ) , // rest of structure populated after WAL replay }   go rc . startRaft ( )   return commitC , errorC , rc . snapshotterReady   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/gen/goav2gen/swagger.go#L157-L162<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( ep * Endpoint ) Method ( ) string { if strings . Contains ( ep . OperationID , " " ) { return strings . Split ( ep . OperationID , " " ) [ 1 ]   }   return " "   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/pubsub/subscriber/server.go#L158-L162<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * pubSubClient ) subscription ( id string ) subscriptionInterface { return & pubSubSubscription { sub : c . client . Subscription ( id ) , }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/go-audio/transforms/blob/51830ccc35a5ce4be9d09b1d1f3f82dad376c240/stereo_pan.go#L14-L36<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func StereoPan ( buf * audio . FloatBuffer , pan float64 ) error { if buf == nil || buf . Format == nil || buf . Format . NumChannels != 2 { return audio . ErrInvalidBuffer   }   if pan < 0 || pan > 1 { return errors . New ( " " )   }   if pan == 0.5 { return nil   }    if pan < 0.5 { for i := 0 ; i + 2 <= len ( buf . Data ) ; i += 2 { buf . Data [ i + 1 ] *= ( pan * 2 )   }   } else { for i := 0 ; i + 2 <= len ( buf . Data ) ; i += 2 { buf . Data [ i ] *= ( ( 1 - pan ) * 2 )   }   }    return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pps/pretty/pretty.go#L196-L236<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func PrintDetailedPipelineInfo ( pipelineInfo * PrintablePipelineInfo ) error { template , err := template . New ( " " ) . Funcs ( funcMap ) . Parse ( `Name: {{.Pipeline.Name}}{{if .Description}} Description: {{.Description}}{{end}}{{if .FullTimestamps }} Created: {{.CreatedAt}}{{ else }} Created: {{prettyAgo .CreatedAt}} {{end}} State: {{pipelineState .State}} Stopped: {{ .Stopped }} Reason: {{.Reason}} Parallelism Spec: {{.ParallelismSpec}} {{ if .ResourceRequests }}ResourceRequests:   CPU: {{ .ResourceRequests.Cpu }}   Memory: {{ .ResourceRequests.Memory }} {{end}} {{ if .ResourceLimits }}ResourceLimits:   CPU: {{ .ResourceLimits.Cpu }}   Memory: {{ .ResourceLimits.Memory }}   {{ if .ResourceLimits.Gpu }}GPU:     Type: {{ .ResourceLimits.Gpu.Type }}      Number: {{ .ResourceLimits.Gpu.Number }} {{end}} {{end}} Datum Timeout: {{.DatumTimeout}} Job Timeout: {{.JobTimeout}} Input: {{pipelineInput .PipelineInfo}} {{ if .GithookURL }}Githook URL: {{.GithookURL}} {{end}} Output Branch: {{.OutputBranch}} Transform: {{prettyTransform .Transform}} {{ if .Egress }}Egress: {{.Egress.URL}} {{end}} {{if .RecentError}} Recent Error: {{.RecentError}} {{end}} Job Counts: {{jobCounts .JobCounts}} ` )   if err != nil { return err   }   err = template . Execute ( os . Stdout , pipelineInfo )   if err != nil { return err   }   return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/llgcode/draw2d/blob/f52c8a71aff06ab8df41843d33ab167b36c971cd/draw2dpdf/fileutil.go#L9-L11<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func SaveToPdfFile ( filePath string , pdf * gofpdf . Fpdf ) error { return pdf . OutputFileAndClose ( filePath )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/sclevine/agouti/blob/96599c91888f1b1cf2dccc7f1776ba7f511909e5/selectable.go#L84-L86<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( s * selectable ) FindByLabel ( text string ) * Selection { return newSelection ( s . session , s . selectors . Append ( target . Label , text ) . Single ( ) )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/api.go#L798-L811<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( r * Raft ) Shutdown ( ) Future { r . shutdownLock . Lock ( )   defer r . shutdownLock . Unlock ( )    if ! r . shutdown { close ( r . shutdownCh )   r . shutdown = true   r . setState ( Shutdown )   return & shutdownFuture { r }   }    // avoid closing transport twice return & shutdownFuture { nil }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/TheThingsNetwork/go-utils/blob/aa2a11bd59104d2a8609328c2b2b55da61826470/errors/grpc.go#L124-L131<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ToGRPC ( in error ) error { if err , ok := in . ( Error ) ; ok { attrs , _ := json . Marshal ( err . Attributes ( ) )   return grpc . Errorf ( err . Type ( ) . GRPCCode ( ) , format , err . Error ( ) , err . Code ( ) , attrs )   }    return grpc . Errorf ( codes . Unknown , in . Error ( ) )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/antlinker/go-dirtyfilter/blob/533f538ffaa112776b1258c3db63e6f55648e18b/nodefilter.go#L13-L32<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func NewNodeReaderFilter ( rd io . Reader , delim byte ) DirtyFilter { nf := & nodeFilter { root : newNode ( ) , }   buf := new ( bytes . Buffer )   io . Copy ( buf , rd )   buf . WriteByte ( delim )   for { line , err := buf . ReadString ( delim )   if err != nil { break   }   if line == " " { continue   }   nf . addDirtyWords ( line )   }   buf . Reset ( )   return nf   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/images.go#L716-L765<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * Cluster ) ImageUpdate ( id int , fname string , sz int64 , public bool , autoUpdate bool , architecture string , createdAt time . Time , expiresAt time . Time , properties map [ string ] string ) error { arch , err := osarch . ArchitectureId ( architecture )   if err != nil { arch = 0   }    err = c . Transaction ( func ( tx * ClusterTx ) error { publicInt := 0   if public { publicInt = 1   }    autoUpdateInt := 0   if autoUpdate { autoUpdateInt = 1   }    stmt , err := tx . tx . Prepare ( `UPDATE images SET filename=?, size=?, public=?, auto_update=?, architecture=?, creation_date=?, expiry_date=? WHERE id=?` )   if err != nil { return err   }   defer stmt . Close ( )    _ , err = stmt . Exec ( fname , sz , publicInt , autoUpdateInt , arch , createdAt , expiresAt , id )   if err != nil { return err   }    _ , err = tx . tx . Exec ( `DELETE FROM images_properties WHERE image_id=?` , id )   if err != nil { return err   }    stmt2 , err := tx . tx . Prepare ( `INSERT INTO images_properties (image_id, type, key, value) VALUES (?, ?, ?, ?)` )   if err != nil { return err   }   defer stmt2 . Close ( )    for key , value := range properties { _ , err = stmt2 . Exec ( id , 0 , key , value )   if err != nil { return err   }   }    return nil   } )   return err   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/Knetic/govaluate/blob/9aa49832a739dcd78a5542ff189fb82c3e423116/EvaluableExpression.go#L44-L48<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func NewEvaluableExpression ( expression string ) ( * EvaluableExpression , error ) { functions := make ( map [ string ] ExpressionFunction )   return NewEvaluableExpressionWithFunctions ( expression , functions )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/fetch/easyjson.go#L1363-L1367<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * ContinueWithAuthParams ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoFetch12 ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/iron-io/functions_go/blob/91b84f5bbb17095bf1c7028ec6e70a3dc06a5893/client/apps/apps_client.go#L152-L175<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( a * Client ) PostApps ( params * PostAppsParams ) ( * PostAppsOK , error ) { // TODO: Validate the params before sending if params == nil { params = NewPostAppsParams ( )   }    result , err := a . transport . Submit ( & runtime . ClientOperation { ID : " " , Method : " " , PathPattern : " " , ProducesMediaTypes : [ ] string { " " } , ConsumesMediaTypes : [ ] string { " " } , Schemes : [ ] string { " " , " " } , Params : params , Reader : & PostAppsReader { formats : a . formats } , Context : params . Context , Client : params . HTTPClient , } )   if err != nil { return nil , err   }   return result . ( * PostAppsOK ) , nil    }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/mattn/go-xmpp/blob/6093f50721ed2204a87a81109ca5a466a5bec6c1/xmpp.go#L250-L259<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func NewClient ( host , user , passwd string , debug bool ) ( * Client , error ) { opts := Options { Host : host , User : user , Password : passwd , Debug : debug , Session : false , }   return opts . NewClient ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/client/lxd_networks.go#L70-L84<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( r * ProtocolLXD ) GetNetworkLeases ( name string ) ( [ ] api . NetworkLease , error ) { if ! r . HasExtension ( " " ) { return nil , fmt . Errorf ( " \" \" " )   }    leases := [ ] api . NetworkLease { }    // Fetch the raw value _ , err := r . queryStruct ( " " , fmt . Sprintf ( " " , url . QueryEscape ( name ) ) , nil , " " , & leases )   if err != nil { return nil , err   }    return leases , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/memory/memory.go#L172-L174<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p * StopSamplingParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandStopSampling , nil , nil )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/olorin/nagiosplugin/blob/893f9702af4ea1e2dc4cd6528cbdcdb3dc7ca064/check.go#L81-L84<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * Check ) AddResultf ( status Status , format string , v ... interface { } ) { msg := fmt . Sprintf ( format , v ... )   c . AddResult ( status , msg )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/page/easyjson.go#L453-L457<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v StopLoadingParams ) MarshalJSON ( ) ( [ ] byte , error ) { w := jwriter . Writer { }   easyjsonC5a4559bEncodeGithubComChromedpCdprotoPage4 ( & w , v )   return w . Buffer . BuildBytes ( ) , w . Error   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pps/cmds/cmds.go#L918-L945<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func pushImage ( client * docker . Client , authConfig docker . AuthConfiguration , repo string , sourceTag string , destTag string ) ( string , error ) { sourceImage := fmt . Sprintf ( " " , repo , sourceTag )   destImage := fmt . Sprintf ( " " , repo , destTag )    fmt . Printf ( " \n " , destImage )    if err := client . TagImage ( sourceImage , docker . TagImageOptions { Repo : repo , Tag : destTag , Context : context . Background ( ) , } ) ; err != nil { err = fmt . Errorf ( " " , err )   return " " , err   }    if err := client . PushImage ( docker . PushImageOptions { Name : repo , Tag : destTag , } , authConfig , ) ; err != nil { err = fmt . Errorf ( " " , err )   return " " , err   }    return destImage , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/gen/writers/generate.go#L44-L61<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func GenerateMetadata ( descriptor * gen . APIDescriptor , codegen , pkg string ) error { f , err := os . Create ( codegen )   if err != nil { return err   }   c , err := NewMetadataWriter ( )   if err != nil { return err   }   kingpin . FatalIfError ( c . WriteHeader ( pkg , f ) , " " )   kingpin . FatalIfError ( c . WriteMetadata ( descriptor , f ) , " " )   f . Close ( )   o , err := exec . Command ( " " , " " , codegen ) . CombinedOutput ( )   if err != nil { return fmt . Errorf ( " \n " , o )   }   return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/page/easyjson.go#L4073-L4077<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * GenerateTestReportParams ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoPage44 ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/pkg/types/set.go#L68-L75<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( us * unsafeSet ) ContainsAll ( values [ ] string ) bool { for _ , s := range values { if ! us . Contains ( s ) { return false   }   }   return true   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/coryb/figtree/blob/e5fa026ccd54e0a6a99b6d81f73bfcc8e6fe6a6b/gen-rawoption.go#L2287-L2292<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( o * ListInt32Option ) Set ( value string ) error { val := Int32Option { }   val . Set ( value )   * o = append ( * o , val )   return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/hashtree/db.go#L332-L358<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( h * dbHashTree ) Walk ( path string , f func ( path string , node * NodeProto ) error ) error { path = clean ( path )   return h . View ( func ( tx * bolt . Tx ) error { c := fs ( tx ) . Cursor ( )   for k , v := c . Seek ( b ( path ) ) ; k != nil && strings . HasPrefix ( s ( k ) , path ) ; k , v = c . Next ( ) { node := & NodeProto { }   if err := node . Unmarshal ( v ) ; err != nil { return err   }   nodePath := s ( k )   if nodePath == " " { nodePath = " "   }   if nodePath != path && ! strings . HasPrefix ( nodePath , path + " " ) { // node is a sibling of path, and thus doesn't get walked continue   }   if err := f ( nodePath , node ) ; err != nil { if err == errutil . ErrBreak { return nil   }   return err   }   }   return nil   } )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/bazelbuild/bazel-gazelle/blob/e3805aaca69a9deb949b47bfc45b9b1870712f4f/rule/rule.go#L700-L712<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( r * Rule ) SetAttr ( key string , value interface { } ) { rhs := ExprFromValue ( value )   if attr , ok := r . attrs [ key ] ; ok { attr . RHS = rhs   } else { r . attrs [ key ] = & bzl . AssignExpr { LHS : & bzl . Ident { Name : key } , RHS : rhs , Op : " " , }   }   r . updated = true   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/fragmenting_writer.go#L53-L60<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( f * writableFragment ) finish ( hasMoreFragments bool ) { f . checksumRef . Update ( f . checksum . Sum ( ) )   if hasMoreFragments { f . flagsRef . Update ( hasMoreFragmentsFlag )   } else { f . checksum . Release ( )   }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/operations.go#L303-L316<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * ClusterTx ) OperationRemove ( uuid string ) error { result , err := c . tx . Exec ( " " , uuid )   if err != nil { return err   }   n , err := result . RowsAffected ( )   if err != nil { return err   }   if n != 1 { return fmt . Errorf ( " " , n )   }   return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/gobuffalo/buffalo/blob/7f360181f4ccd79dcc9dcea2c904a4801f194f04/worker/simple.go#L23-L37<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func NewSimpleWithContext ( ctx context . Context ) * Simple { ctx , cancel := context . WithCancel ( ctx )    l := logrus . New ( )   l . Level = logrus . InfoLevel   l . Formatter = & logrus . TextFormatter { }    return & Simple { Logger : l , ctx : ctx , cancel : cancel , handlers : map [ string ] Handler { } , moot : & sync . Mutex { } , }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/util/net.go#L19-L30<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func InMemoryNetwork ( ) ( net . Listener , func ( ) net . Conn ) { listener := & inMemoryListener { conns : make ( chan net . Conn , 16 ) , closed : make ( chan struct { } ) , }   dialer := func ( ) net . Conn { server , client := net . Pipe ( )   listener . conns <- server   return client   }   return listener , dialer   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/runtime/runtime.go#L691-L693<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p * RunIfWaitingForDebuggerParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandRunIfWaitingForDebugger , nil , nil )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/justinfx/gofileseq/blob/2555f296b4493d1825f5f6fab4aa0ff51a8306cd/exp/cpp/export/export.go#L526-L531<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func FileSequence_SetExt ( id FileSeqId , ext * C . char ) { if fs , ok := sFileSeqs . Get ( id ) ; ok { str := C . GoString ( ext )   fs . SetExt ( str )   }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/page/page.go#L698-L701<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p PrintToPDFParams ) WithPrintBackground ( printBackground bool ) * PrintToPDFParams { p . PrintBackground = printBackground   return & p   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/go-opencv/go-opencv/blob/a4fe8ec027ccc9eb8b7d0797db7c76e61083f1db/opencv/cxcore.go#L389-L396<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ScalarToRawData ( scalar * Scalar , data unsafe . Pointer , type_ , extend_to_12 int ) { C . cvScalarToRawData ( ( * C . CvScalar ) ( scalar ) , data , C . int ( type_ ) , C . int ( extend_to_12 ) , )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/api/v2store/node.go#L189-L203<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( n * node ) Add ( child * node ) * v2error . Error { if ! n . IsDir ( ) { return v2error . NewError ( v2error . EcodeNotDir , " " , n . store . CurrentIndex )   }    _ , name := path . Split ( child . Path )    if _ , ok := n . Children [ name ] ; ok { return v2error . NewError ( v2error . EcodeNodeExist , " " , n . store . CurrentIndex )   }    n . Children [ name ] = child    return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/obj/obj.go#L286-L288<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func NewAmazonClient ( region , bucket string , creds * AmazonCreds , distribution string , reversed ... bool ) ( Client , error ) { return newAmazonClient ( region , bucket , creds , distribution , reversed ... )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/overlay/overlay.go#L425-L427<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p * SetShowPaintRectsParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetShowPaintRects , p , nil )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/storage_pools.go#L491-L497<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func storagePoolClusterConfigForEtag ( dbConfig map [ string ] string ) map [ string ] string { config := util . CopyConfig ( dbConfig )   for _ , key := range db . StoragePoolNodeConfigKeys { delete ( config , key )   }   return config   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/mgutz/str/blob/968bf66e3da857419e4f6e71b2d5c9ae95682dc4/funcsPZ.go#L232-L236<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func SubstrF ( index , n int ) func ( string ) string { return func ( s string ) string { return Substr ( s , index , n )   }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/client/simplestreams_images.go#L52-L191<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( r * ProtocolSimpleStreams ) GetImageFile ( fingerprint string , req ImageFileRequest ) ( * ImageFileResponse , error ) { // Sanity checks if req . MetaFile == nil && req . RootfsFile == nil { return nil , fmt . Errorf ( " " )   }    // Attempt to download from host if shared . PathExists ( " " ) && os . Geteuid ( ) == 0 { unixURI := fmt . Sprintf ( " " , url . QueryEscape ( fingerprint ) )    // Setup the HTTP client devlxdHTTP , err := unixHTTPClient ( nil , " " )   if err == nil { resp , err := lxdDownloadImage ( fingerprint , unixURI , r . httpUserAgent , devlxdHTTP , req )   if err == nil { return resp , nil   }   }   }    // Get the file list files , err := r . ssClient . GetFiles ( fingerprint )   if err != nil { return nil , err   }    // Prepare the response resp := ImageFileResponse { }    // Download function download := func ( path string , filename string , hash string , target io . WriteSeeker ) ( int64 , error ) { // Try over http url := fmt . Sprintf ( " " , strings . TrimPrefix ( r . httpHost , " " ) , path )    size , err := shared . DownloadFileHash ( r . http , r . httpUserAgent , req . ProgressHandler , req . Canceler , filename , url , hash , sha256 . New ( ) , target )   if err != nil { // Handle cancelation if err . Error ( ) == " " { return - 1 , err   }    // Try over https url = fmt . Sprintf ( " " , r . httpHost , path )   size , err = shared . DownloadFileHash ( r . http , r . httpUserAgent , req . ProgressHandler , req . Canceler , filename , url , hash , sha256 . New ( ) , target )   if err != nil { return - 1 , err   }   }    return size , nil   }    // Download the LXD image file meta , ok := files [ " " ]   if ok && req . MetaFile != nil { size , err := download ( meta . Path , " " , meta . Sha256 , req . MetaFile )   if err != nil { return nil , err   }    parts := strings . Split ( meta . Path , " " )   resp . MetaName = parts [ len ( parts ) - 1 ]   resp . MetaSize = size   }    // Download the rootfs rootfs , ok := files [ " " ]   if ok && req . RootfsFile != nil { // Look for deltas (requires xdelta3) downloaded := false   _ , err := exec . LookPath ( " " )   if err == nil && req . DeltaSourceRetriever != nil { for filename , file := range files { if ! strings . HasPrefix ( filename , " " ) { continue   }    // Check if we have the source file for the delta srcFingerprint := strings . Split ( filename , " " ) [ 1 ]   srcPath := req . DeltaSourceRetriever ( srcFingerprint , " " )   if srcPath == " " { continue   }    // Create temporary file for the delta deltaFile , err := ioutil . TempFile ( " " , " " )   if err != nil { return nil , err   }   defer deltaFile . Close ( )   defer os . Remove ( deltaFile . Name ( ) )    // Download the delta _ , err = download ( file . Path , " " , file . Sha256 , deltaFile )   if err != nil { return nil , err   }    // Create temporary file for the delta patchedFile , err := ioutil . TempFile ( " " , " " )   if err != nil { return nil , err   }   defer patchedFile . Close ( )   defer os . Remove ( patchedFile . Name ( ) )    // Apply it _ , err = shared . RunCommand ( " " , " " , " " , " " , srcPath , deltaFile . Name ( ) , patchedFile . Name ( ) )   if err != nil { return nil , err   }    // Copy to the target size , err := io . Copy ( req . RootfsFile , patchedFile )   if err != nil { return nil , err   }    parts := strings . Split ( rootfs . Path , " " )   resp . RootfsName = parts [ len ( parts ) - 1 ]   resp . RootfsSize = size   downloaded = true   }   }    // Download the whole file if ! downloaded { size , err := download ( rootfs . Path , " " , rootfs . Sha256 , req . RootfsFile )   if err != nil { return nil , err   }    parts := strings . Split ( rootfs . Path , " " )   resp . RootfsName = parts [ len ( parts ) - 1 ]   resp . RootfsSize = size   }   }    return & resp , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/codegangsta/martini-contrib/blob/8ce6181c2609699e4c7cd30994b76a850a9cdadc/acceptlang/handler.go#L52-L66<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( al AcceptLanguages ) String ( ) string { output := bytes . NewBufferString ( " " )   for i , language := range al { output . WriteString ( fmt . Sprintf ( " " , language . Language , language . Quality ) )   if i != len ( al ) - 1 { output . WriteString ( " " )   }   }    if output . Len ( ) == 0 { output . WriteString ( " " )   }    return output . String ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/mgutz/str/blob/968bf66e3da857419e4f6e71b2d5c9ae95682dc4/funcsAO.go#L325-L331<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func Map ( arr [ ] string , iterator func ( string ) string ) [ ] string { r := [ ] string { }   for _ , item := range arr { r = append ( r , iterator ( item ) )   }   return r   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/containers/image/blob/da9ab3561ad2031aeb5e036b7cf2755d4e246fec/openshift/openshift-copies.go#L424-L435<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( config * directClientConfig ) getAuthInfo ( ) clientcmdAuthInfo { authInfos := config . config . AuthInfos   authInfoName := config . getAuthInfoName ( )    var mergedAuthInfo clientcmdAuthInfo   if configAuthInfo , exists := authInfos [ authInfoName ] ; exists { mergo . Merge ( & mergedAuthInfo , configAuthInfo )   }   // REMOVED: overrides support return mergedAuthInfo   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/urandom/handler/blob/61508044a5569d1609521d81e81f6737567fd104/log/access.go#L29-L33<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func Logger ( l handler . Logger ) Option { return Option { func ( o * options ) { o . logger = l   } }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/coryb/figtree/blob/e5fa026ccd54e0a6a99b6d81f73bfcc8e6fe6a6b/rawoption.go#L192-L197<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( o * ListRawTypeOption ) Set ( value string ) error { val := RawTypeOption { }   val . Set ( value )   * o = append ( * o , val )   return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/pact-foundation/pact-go/blob/467dea56d27e154363e1975f6e9f4dbf66148e79/client/mock_service.go#L9-L17<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( m * MockService ) NewService ( args [ ] string ) Service { m . Args = [ ] string { " " , }   m . Args = append ( m . Args , args ... )    m . Cmd = getMockServiceCommandPath ( )   return m   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/cm15/codegen_client.go#L15007-L15014<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( r * VolumeType ) Locator ( api * API ) * VolumeTypeLocator { for _ , l := range r . Links { if l [ " " ] == " " { return api . VolumeTypeLocator ( l [ " " ] )   }   }   return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/dgraph-io/badger/blob/6b796b3ebec3ff006fcb1b425836cd784651e9fd/manifest.go#L116-L118<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func openOrCreateManifestFile ( dir string , readOnly bool ) ( ret * manifestFile , result Manifest , err error ) { return helpOpenOrCreateManifestFile ( dir , readOnly , manifestDeletionsRewriteThreshold )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/fetch/fetch.go#L321-L330<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( p * TakeResponseBodyAsStreamParams ) Do ( ctx context . Context ) ( stream io . StreamHandle , err error ) { // execute var res TakeResponseBodyAsStreamReturns   err = cdp . Execute ( ctx , CommandTakeResponseBodyAsStream , p , & res )   if err != nil { return " " , err   }    return res . Stream , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/css/easyjson.go#L4375-L4379<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * GetPlatformFontsForNodeParams ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoCss38 ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/config.go#L179-L192<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c * ServerConfig ) VerifyJoinExisting ( ) error { // The member has announced its peer urls to the cluster before starting; no need to // set the configuration again. if err := c . hasLocalMember ( ) ; err != nil { return err   }   if checkDuplicateURL ( c . InitialPeerURLsMap ) { return fmt . Errorf ( " " , c . InitialPeerURLsMap )   }   if c . DiscoveryURL != " " { return fmt . Errorf ( " " )   }   return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/dgraph-io/badger/blob/6b796b3ebec3ff006fcb1b425836cd784651e9fd/skl/skl.go#L430-L433<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( s * Iterator ) Next ( ) { y . AssertTrue ( s . Valid ( ) )   s . n = s . list . getNext ( s . n , 0 )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/api/permission.go#L644-L687<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func roleUpdate ( w http . ResponseWriter , r * http . Request , t auth . Token ) error { roleName := InputValue ( r , " " )   newName := InputValue ( r , " " )   contextType := InputValue ( r , " " )   description := InputValue ( r , " " )   var wantedPerms [ ] * permission . PermissionScheme   if newName != " " { wantedPerms = append ( wantedPerms , permission . PermRoleUpdateName )   }   if contextType != " " { wantedPerms = append ( wantedPerms , permission . PermRoleUpdateContextType )   }   if description != " " { wantedPerms = append ( wantedPerms , permission . PermRoleUpdateDescription )   }   if len ( wantedPerms ) == 0 { msg := " "   return & errors . HTTP { Code : http . StatusBadRequest , Message : msg }   }   for _ , perm := range wantedPerms { if ! permission . Check ( t , perm ) { return permission . ErrUnauthorized   }   }   evt , err := event . New ( & event . Opts { Target : event . Target { Type : event . TargetTypeRole , Value : roleName } , Kind : permission . PermRoleUpdate , Owner : t , CustomData : event . FormToCustomData ( InputFields ( r ) ) , Allowed : event . Allowed ( permission . PermRoleUpdate ) , } )   if err != nil { return err   }   defer func ( ) { evt . Done ( err ) } ( )   err = auth . UpdateRoleFromAllUsers ( roleName , newName , contextType , description )   if err != nil { return & errors . HTTP { Code : http . StatusBadRequest , Message : err . Error ( ) , }   }   return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/cachestorage/easyjson.go#L727-L731<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( v * Header ) UnmarshalJSON ( data [ ] byte ) error { r := jlexer . Lexer { Data : data }   easyjsonC5a4559bDecodeGithubComChromedpCdprotoCachestorage6 ( & r , v )   return r . Error ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/segmentio/objconv/blob/7a1d7b8e6f3551b30751e6b2ea6bae500883870e/objutil/tag.go#L45-L63<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ParseTagJSON ( s string ) Tag { var name string   var omitempty bool    name , s = parseNextTagToken ( s )    for len ( s ) != 0 { var token string   switch token , s = parseNextTagToken ( s ) ; token { case " " : omitempty = true   }   }    return Tag { Name : name , Omitempty : omitempty , }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/kljensen/snowball/blob/115fa8f6419dcfb9ec4653997b1c6803a5eff962/snowballword/snowballword.go#L67-L70<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( w * SnowballWord ) RemoveLastNRunes ( n int ) { w . RS = w . RS [ : len ( w . RS ) - n ]   w . resetR1R2 ( )   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/client/admin.go#L94-L110<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( c APIClient ) Restore ( ops [ ] * admin . Op ) ( retErr error ) { restoreClient , err := c . AdminAPIClient . Restore ( c . Ctx ( ) )   if err != nil { return grpcutil . ScrubGRPC ( err )   }   defer func ( ) { if _ , err := restoreClient . CloseAndRecv ( ) ; err != nil && retErr == nil { retErr = grpcutil . ScrubGRPC ( err )   }   } ( )   for _ , op := range ops { if err := restoreClient . Send ( & admin . RestoreRequest { Op : op } ) ; err != nil { return grpcutil . ScrubGRPC ( err )   }   }   return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/pool/pool.go#L38-L61<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func NewPool ( kubeClient * kube . Clientset , namespace string , serviceName string , port int , queueSize int64 , opts ... grpc . DialOption ) ( * Pool , error ) { endpointsInterface := kubeClient . CoreV1 ( ) . Endpoints ( namespace )    watch , err := endpointsInterface . Watch ( metav1 . ListOptions { LabelSelector : metav1 . FormatLabelSelector ( metav1 . SetAsLabelSelector ( map [ string ] string { " " : serviceName } , ) ) , Watch : true , } )   if err != nil { return nil , err   }    pool := & Pool { port : port , endpointsWatch : watch , opts : opts , done : make ( chan struct { } ) , queueSize : queueSize , }   pool . connsCond = sync . NewCond ( & pool . connsLock )   go pool . watchEndpoints ( )   return pool , nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/build/transaction_envelope.go#L92-L111<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( m Sign ) MutateTransactionEnvelope ( txe * TransactionEnvelopeBuilder ) error { hash , err := txe . child . Hash ( )    if err != nil { return err   }    kp , err := keypair . Parse ( m . Seed )   if err != nil { return err   }    sig , err := kp . SignDecorated ( hash [ : ] )   if err != nil { return err   }    txe . E . Signatures = append ( txe . E . Signatures , sig )   return nil   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/ant0ine/go-json-rest/blob/ebb33769ae013bd5f518a8bac348c310dea768b8/rest/request.go#L107-L148<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( r * Request ) GetCorsInfo ( ) * CorsInfo { origin := r . Header . Get ( " " )    var originUrl * url . URL   var isCors bool    if origin == " " { isCors = false   } else if origin == " " { isCors = true   } else { var err error   originUrl , err = url . ParseRequestURI ( origin )   isCors = err == nil && r . Host != originUrl . Host   }    reqMethod := r . Header . Get ( " " )    reqHeaders := [ ] string { }   rawReqHeaders := r . Header [ http . CanonicalHeaderKey ( " " ) ]   for _ , rawReqHeader := range rawReqHeaders { if len ( rawReqHeader ) == 0 { continue   }   // net/http does not handle comma delimited headers for us for _ , reqHeader := range strings . Split ( rawReqHeader , " " ) { reqHeaders = append ( reqHeaders , http . CanonicalHeaderKey ( strings . TrimSpace ( reqHeader ) ) )   }   }    isPreflight := isCors && r . Method == " " && reqMethod != " "    return & CorsInfo { IsCors : isCors , IsPreflight : isPreflight , Origin : origin , OriginUrl : originUrl , AccessControlRequestMethod : strings . ToUpper ( reqMethod ) , AccessControlRequestHeaders : reqHeaders , }   }

1<CODESPLIT>https://github.com/fossapps/pushy/blob/4c6045d7a1d3c310d61168ff1ccd5421d5c162f6/pushy.go#L84-L94<CODESPLIT>https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/server.go#L710-L719<CODESPLIT>SubscribeToTopic subscribes a particular device to topics ( when you want to do from backend )<CODESPLIT>func ( s * EtcdServer ) Start ( ) { s . start ( )   s . goAttach ( func ( ) { s . adjustTicks ( ) } )   s . goAttach ( func ( ) { s . publish ( s . Cfg . ReqTimeout ( ) ) } )   s . goAttach ( s . purgeFile )   s . goAttach ( func ( ) { monitorFileDescriptor ( s . getLogger ( ) , s . stopping ) } )   s . goAttach ( s . monitorVersions )   s . goAttach ( s . linearizableReadLoop )   s . goAttach ( s . monitorKVHash )   }

