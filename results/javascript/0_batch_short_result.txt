1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function initHTTPTransaction ( { TIMEOUT = DEFAULT_TIMEOUT , TRANSACTIONS , log = noop , time , delay , uniqueId = createIncrementor ( ) , } ) { // Not using default value to always // get an empty object here and avoid // conflicts between instances spawned // with defaults TRANSACTIONS = TRANSACTIONS || { } ; log ( 'debug' , 'HTTP Transaction initialized.' ) ; return Promise . resolve ( httpTransaction ) ; /**    * Create a new HTTP transaction    * @param  {HTTPRequest}  req    * A raw NodeJS HTTP incoming message    * @param  {HTTPResponse} res    * A raw NodeJS HTTP response    * @return {Array}    * The normalized request and the HTTP    * transaction created in an array.    */ function httpTransaction ( req , res ) { let initializationPromise ; /* Architecture Note #3.1: New Transaction     The idea is to maintain a hash of each pending      transaction. To do so, we create a transaction      object that contains useful informations about      the transaction and we store it into the      `TRANSACTIONS` hash.      Each transaction has a unique id that is either      generated or picked up in the `Transaction-Id`      request header. This allows to trace      transactions end to end with that unique id.     */ return Promise . resolve ( ) . then ( ( ) => { const request = { url : req . url , method : req . method . toLowerCase ( ) , headers : req . headers , body : req , } ; const transaction = { protocol : req . connection . encrypted ? 'https' : 'http' , ip : ( req . headers [ 'x-forwarded-for' ] || '' ) . split ( ',' ) [ 0 ] || req . connection . remoteAddress , startInBytes : req . socket . bytesRead , startOutBytes : req . socket . bytesWritten , startTime : time ( ) , url : req . url , method : req . method , reqHeaders : req . headers , errored : false , } ; const delayPromise = delay . create ( TIMEOUT ) ; let id = req . headers [ 'transaction-id' ] || uniqueId ( ) ; // Handle bad client transaction ids if ( TRANSACTIONS [ id ] ) { initializationPromise = Promise . reject ( new HTTPError ( 400 , 'E_TRANSACTION_ID_NOT_UNIQUE' , id ) , ) ; id = uniqueId ( ) ; } else { initializationPromise = Promise . resolve ( ) ; } transaction . id = id ; TRANSACTIONS [ id ] = transaction ; return [ request , { id , start : startTransaction . bind ( null , { id , req , res , delayPromise } , initializationPromise , ) , catch : catchTransaction . bind ( null , { id , req , res } ) , end : endTransaction . bind ( null , { id , req , res , delayPromise } ) , } , ] ; } ) ; } function startTransaction ( { id , delayPromise } , initializationPromise , buildResponse , ) { /* Architecture Note #3.2: Transaction start     Once initiated, the transaction can be started. It      basically spawns a promise that will be resolved      to the actual response or rejected if the timeout      is reached.     */ return Promise . race ( [ initializationPromise . then ( ( ) => buildResponse ( ) ) , delayPromise . then ( ( ) => { throw new HTTPError ( 504 , 'E_TRANSACTION_TIMEOUT' , TIMEOUT , id ) ; } ) , ] ) ; } function catchTransaction ( { id , req } , err ) { /* Architecture Note #3.3: Transaction errors     Here we are simply casting and logging errors.      It is important for debugging but also for      ending the transaction properly if an error      occurs.     */ err = HTTPError . cast ( err , err . httpCode || 500 ) ; log ( 'error' , 'An error occured' , { guruMeditation : id , request : TRANSACTIONS [ id ] . protocol + '://' + ( req . headers . host || 'localhost' ) + TRANSACTIONS [ id ] . url , verb : req . method , status : err . httpCode , code : err . code , stack : err . stack , details : err . params , } ) ; TRANSACTIONS [ id ] . errored = true ; throw err ; } function endTransaction ( { id , req , res , delayPromise } , response ) { /* Architecture Note #3.4: Transaction end     We end the transaction by writing the final status      and headers and piping the response body if any.      The transaction can till error at that time but it      is too late for changing the response status so      we are just logging the event.      This could be handled with      [HTTP trailers](https://nodejs.org/api/http.html#http_response_addtrailers_headers)      but the lack of client side support for now is      preventing us to use them.       Once terminated, the transaction is removed       from the `TRANSACTIONS` hash.     */ return new Promise ( ( resolve , reject ) => { res . on ( 'error' , reject ) ; res . on ( 'finish' , resolve ) ; res . writeHead ( response . status , statuses [ response . status ] , Object . assign ( { } , response . headers , { 'Transaction-Id' : id } ) , ) ; if ( response . body && response . body . pipe ) { response . body . pipe ( res ) ; } else { res . end ( ) ; } } ) . catch ( err => { TRANSACTIONS [ id ] . errored = true ; log ( 'error' , 'An error occured' , { guruMeditation : id , request : TRANSACTIONS [ id ] . protocol + '://' + ( req . headers . host || 'localhost' ) + TRANSACTIONS [ id ] . url , method : req . method , stack : err . stack || err , } ) ; } ) . then ( ( ) => { TRANSACTIONS [ id ] . endTime = time ( ) ; TRANSACTIONS [ id ] . endInBytes = req . socket . bytesRead ; TRANSACTIONS [ id ] . endOutBytes = req . socket . bytesWritten ; TRANSACTIONS [ id ] . statusCode = response . status ; TRANSACTIONS [ id ] . resHeaders = response . headers || { } ; log ( 'info' , TRANSACTIONS [ id ] ) ; delete TRANSACTIONS [ id ] ; return delay . clear ( delayPromise ) ; } ) ; } }<CODESPLIT>0.12515106797218323<CODESPLIT>0.1640366166830063

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/snapptop/ninjs-lodash/blob/fab253b7d96cc9bb3f2a1057efff2684c200bcee/lib/path.js#L158-L162<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function nspath ( ) { let src = _ . join ( _ . filter ( _ . toArray ( arguments ) , function ( arg ) { return arg && _ . isString ( arg ) } ) , '.' ) if ( ! src ) return '' return _ . replace ( src , REGX_DOTS , '/' ) }<CODESPLIT>0.15056107938289642<CODESPLIT>0.14917878806591034

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/GitbookIO/repofs/blob/24f9880f3abb5aae4e4be56d0e88ba9d214447be/src/drivers/github.js#L500-L506<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getSimpleAuthor ( author ) { return Author . create ( { name : author . name , email : author . email , date : author . date } ) ; }<CODESPLIT>0.1406579613685608<CODESPLIT>0.1559761017560959

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/Robot/robot-js/blob/63a008a97c14e2a4cf7576a53459622fadb4fc8d/lib/hash.js#L79-L88<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function Hash ( data ) { // Auto instantiate the Hash if ( ! ( this instanceof Hash ) ) return new Hash ( data ) ; this . result = 0 ; if ( data !== undefined ) this . append ( data ) ; }<CODESPLIT>0.16158825159072876<CODESPLIT>0.12928016483783722

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/centro/transis/blob/e002b55bbe55a75b7638e9046e57bdfbff04cd1c/dist/util.js#L241-L265<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function arrayEq ( a , b ) { var r ; if ( ! Array . isArray ( a ) || ! Array . isArray ( b ) ) { return false ; } if ( a . length !== b . length ) { return false ; } r = true ; detectRecursion ( a , b , function ( ) { var i , len ; for ( i = 0 , len = a . length ; i < len ; i ++ ) { if ( ! eq ( a [ i ] , b [ i ] ) ) { r = false ; break ; } } } ) ; return r ; }<CODESPLIT>0.142390176653862<CODESPLIT>0.13851884007453918

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/jeka-kiselyov/mdict/blob/540898e63991cb0c8985ed8fb29eb11a59f35089/mdict-parser.js#L614-L632<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function read_record_block ( input , record_summary ) { var scanner = Scanner ( input ) , size = record_summary . num_blocks , record_index = Array ( size ) , p0 = record_summary . block_pos , p1 = 0 ; RECORD_BLOCK_TABLE . alloc ( size + 1 ) ; for ( var i = 0 , rdx ; i < size ; i ++ ) { record_index [ i ] = rdx = { comp_size : scanner . readNum ( ) , decomp_size : scanner . readNum ( ) } ; RECORD_BLOCK_TABLE . put ( p0 , p1 ) ; p0 += rdx . comp_size ; p1 += rdx . decomp_size ; } RECORD_BLOCK_TABLE . put ( p0 , p1 ) ; }<CODESPLIT>0.1627625823020935<CODESPLIT>0.13825824856758118

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/yahoo/scrollable/blob/d9b10d19abaf24dd6e96d9c25b07b80bc79d8a41/examples/reminders/index.js#L85-L95<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( categoryId , event ) { event . preventDefault ( ) ; this . refs . scroller . prepareAnimationSync ( ) ; this . setState ( { mode : 'single' , selected : categoryId , previousScrollPosition : this . refs . scroller . scrollTop , } , function ( ) { this . refs . scroller . animateAndResetScroll ( 0 , 0 ) ; } ) ; }<CODESPLIT>0.16718924045562744<CODESPLIT>0.13053031265735626

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/LuccaSA/lui-build/blob/916343e0ba3c36c4e9f97761e402783ca68df44d/lib/to-sass.js#L42-L49<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function parseValue ( value ) { if ( _ . isArray ( value ) ) return converters . list ( value ) ; else if ( _ . isPlainObject ( value ) ) return converters . map ( value ) ; else return value ; }<CODESPLIT>0.13243944942951202<CODESPLIT>0.141327366232872

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/centro/transis/blob/e002b55bbe55a75b7638e9046e57bdfbff04cd1c/dist/parsers.js#L103-L106<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function parseEmail ( s ) { s = String ( s ) ; return EMAIL_FORMAT . test ( s ) ? s : null ; }<CODESPLIT>0.16076962649822235<CODESPLIT>0.12565718591213226

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L1003-L1017<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function readdirSync ( dir , options , internalOptions ) { internalOptions . facade = syncFacade ; let reader = new DirectoryReader ( dir , options , internalOptions ) ; let stream = reader . stream ; let results = [ ] ; let data = stream . read ( ) ; while ( data !== null ) { results . push ( data ) ; data = stream . read ( ) ; } return results ; }<CODESPLIT>0.16863760352134705<CODESPLIT>0.13125601410865784

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/evanmoran/oj/blob/7f05880e4a4572fd67ffb0f55223f66d8ea4e68d/versions/0.2.1/oj.js#L637-L669<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function _styleFromObject ( obj , options ) { options = _extend ( { inline : true , indent : '' } , options ) // Trailing semi should only exist on when we aren't indenting options . semi = ! options . inline ; var out = "" , // Sort keys to create consistent output keys = _keys ( obj ) . sort ( ) , // Support indention and inlining indent = options . indent != null ? options . indent : '' , newline = options . inline ? '' : '\n' , ix , k , kFancy , semi for ( ix = 0 ; ix < keys . length ; ix ++ ) { kFancy = keys [ ix ] // Add semi if it is not inline or it is not the last key semi = options . semi || ix !== keys . length - 1 ? ";" : '' // Allow keys to be camal case k = _dasherize ( kFancy ) // Collect css result for this key out += "" + indent + k + ":" + obj [ kFancy ] + semi + newline } return out }<CODESPLIT>0.14766351878643036<CODESPLIT>0.15032583475112915

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/cubicmushroom/gulp-cm-phpspec-tasks/blob/671b5e6e9545c7a6a027f8b93c1349d491cf429e/pakmanaged.js#L78368-L78376<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function sigletonify ( inst ) { Object . keys ( inst ) . forEach ( function ( key ) { if ( key === 'argv' ) { Argv . __defineGetter__ ( key , inst . __lookupGetter__ ( key ) ) } else { Argv [ key ] = typeof inst [ key ] === 'function' ? inst [ key ] . bind ( inst ) : inst [ key ] } } ) }<CODESPLIT>0.16955916583538055<CODESPLIT>0.12744350731372833

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/pureqml/qmlcore/blob/21416cb4b45dce6cf6c603dfa43d6683e0d48638/platform/video.videojs/dist/video.es.js#L15453-L15464<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function setSelectedOption ( el , value , parser ) { if ( ! value ) { return ; } for ( var i = 0 ; i < el . options . length ; i ++ ) { if ( parseOptionValue ( el . options [ i ] . value , parser ) === value ) { el . selectedIndex = i ; break ; } } }<CODESPLIT>0.15886230766773224<CODESPLIT>0.11106935143470764

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/intelligo-systems/intelligo.js/blob/9e75d48214fb41d346462f5d886bd92cc9956df6/dist/multilabel/MulticlassSegmentation.js#L153-L170<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( sentence , explain ) { var minWordsToSplit = 2 ; var words = sentence . split ( /   / ) ; if ( words . length >= minWordsToSplit ) { var accumulatedClasses = { } ; var explanations = [ ] ; this . cheapestSegmentSplitStrategy ( words , accumulatedClasses , explain , explanations ) ; var classes = Object . keys ( accumulatedClasses ) ; return ( explain > 0 ? { classes : classes , explanation : explanations } : classes ) ; } else { return this . classifySegment ( sentence , explain ) ; } }<CODESPLIT>0.1024889126420021<CODESPLIT>0.1532590240240097

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L60306-L60314<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function CorkedRequest ( state ) { var _this = this ; this . next = null ; this . entry = null ; this . finish = function ( ) { onCorkedFinish ( _this , state ) ; } ; }<CODESPLIT>0.15786802768707275<CODESPLIT>0.14940780401229858

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/device/filesystem/HTML5.js#L195-L234<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( config ) { if ( config . parent == null ) { Ext . Logger . error ( 'Ext.device.filesystem.Entry#moveTo: You must specify a new `parent` of the entry.' ) ; return null ; } var me = this ; this . getEntry ( { options : config . options || { } , success : function ( sourceEntry ) { config . parent . getEntry ( { options : config . options || { } , success : function ( destinationEntry ) { if ( config . copy ) { sourceEntry . copyTo ( destinationEntry , config . newName , function ( entry ) { config . success . call ( config . scope || me , entry . isDirectory ? Ext . create ( 'Ext.device.filesystem.DirectoryEntry' , entry . fullPath , me . fileSystem ) : Ext . create ( 'Ext.device.filesystem.FileEntry' , entry . fullPath , me . fileSystem ) ) ; } , config . failure ) ; } else { sourceEntry . moveTo ( destinationEntry , config . newName , function ( entry ) { config . success . call ( config . scope || me , entry . isDirectory ? Ext . create ( 'Ext.device.filesystem.DirectoryEntry' , entry . fullPath , me . fileSystem ) : Ext . create ( 'Ext.device.filesystem.FileEntry' , entry . fullPath , me . fileSystem ) ) ; } , config . failure ) ; } } , failure : config . failure } ) ; } , failure : config . failure } ) ; }<CODESPLIT>0.1286165416240692<CODESPLIT>0.13969969749450684

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/helixbass/prettier-plugin-coffeescript/blob/274ecc60c1abe13b0693a865a010de52e5692fed/src/printer.js#L2877-L2905<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function isTryBody ( path , { stackOffset = 0 } = { } ) { const node = path . getParentNode ( stackOffset - 1 ) const parent = path . getParentNode ( stackOffset ) const grandparent = path . getParentNode ( stackOffset + 1 ) const greatgrandparent = path . getParentNode ( stackOffset + 2 ) if ( parent . type === 'TryStatement' && node === parent . block ) { return true } if ( singleExpressionBlock ( parent ) && grandparent . type === 'TryStatement' && parent === grandparent . block ) { return true } if ( parent . type === 'ExpressionStatement' && singleExpressionBlock ( grandparent ) && greatgrandparent . type === 'TryStatement' && grandparent === greatgrandparent . block ) { return true } return false }<CODESPLIT>0.17145229876041412<CODESPLIT>0.15072272717952728

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/AssemblyScript/binaryen.js/blob/43effe71e5bf6488752a468e295b94ba6ecbf571/scripts/build.js#L71-L79<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function compileIntrinsics ( ) { var target = path . join ( sourceDirectory , "passes" , "WasmIntrinsics.cpp" ) ; runCommand ( "python" , [ path . join ( binaryenDirectory , "scripts" , "embedwast.py" ) , path . join ( sourceDirectory , "passes" , "wasm-intrinsics.wast" ) , target ] ) ; sourceFiles . push ( target ) ; }<CODESPLIT>0.12070327997207642<CODESPLIT>0.14029774069786072

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/nathanjsweet/Noodles/blob/46b1265b4b1f464d78cb14aad2bece2299fa8b92/plugins/looptag/looptag.js#L91-L95<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( Template ) { Template . endTags = Template . endTags || { } ; Template . endTags [ Template . language . tag ( 'loop' ) ] = true ; Template . endTags [ Template . language . tag ( 'sortloop' ) ] = true ; }<CODESPLIT>0.1575426310300827<CODESPLIT>0.145444855093956

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/panitw/easy-rpm/blob/7a7669af5bd19969219afb98ecb419c9e69e345b/tasks/easy_rpm.js#L84-L244<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function applySpecSettings ( grunt , options , spec ) { spec . tags . name = options . name || spec . tags . name ; if ( ! _ . has ( options , 'version' ) ) { _defaultOptionNotice ( grunt , 'version' , '0.0.0' ) ; } spec . tags . version = options . version || '0.0.0' ; if ( ! _ . has ( options , 'release' ) ) { _defaultOptionNotice ( grunt , 'release' , '1' ) ; } spec . tags . release = options . release || '1' ; if ( ! _ . has ( options , 'buildArch' ) ) { _defaultOptionNotice ( grunt , 'buildArch' , 'noarch' ) ; } spec . tags . buildArch = options . buildArch || 'noarch' ; if ( ! _ . has ( options , 'description' ) ) { _defaultOptionNotice ( grunt , 'description' , 'No Description' ) ; } spec . tags . description = options . description || 'No Description' ; if ( ! _ . has ( options , 'summary' ) ) { _defaultOptionNotice ( grunt , 'summary' , 'No Summary' ) ; } spec . tags . summary = options . summary || 'No Summary' ; if ( ! _ . has ( options , 'license' ) ) { _defaultOptionNotice ( grunt , 'license' , 'MIT' ) ; } spec . tags . license = options . license || 'MIT' ; spec . tags . epoch = options . epoch || spec . tags . epoch ; spec . tags . distribution = options . distribution || spec . tags . distribution ; if ( ! _ . has ( options , 'vendor' ) ) { _defaultOptionNotice ( grunt , 'vendor' , 'Vendor' ) ; } spec . tags . vendor = options . vendor || 'Vendor' ; spec . tags . url = options . url || spec . tags . url ; if ( ! _ . has ( options , 'group' ) ) { _defaultOptionNotice ( grunt , 'group' , 'Development/Tools' ) ; } spec . tags . group = options . group || 'Development/Tools' ; spec . tags . packager = options . packager || spec . tags . packager ; if ( _ . has ( options , 'defines' ) ) { spec . addDefines . apply ( spec , options . defines ) ; } // To maintain backwards compatability with the older API, the arrays // `dependencies` and `requires` are synonymous. if ( _ . has ( options , 'dependencies' ) ) { // TODO deprecate post 1.5.0 grunt . log . writelns ( chalk . gray ( '[Notice] Deprecation warning: ' + 'the use of "dependencies" is deprecated in favour of ' + 'the RPM "requires" and "conflicts" tags.' ) ) ; spec . addRequirements . apply ( spec , options . dependencies ) ; } if ( _ . has ( options , 'requires' ) ) { spec . addRequirements . apply ( spec , options . requires ) ; } if ( _ . has ( options , 'buildRequires' ) ) { spec . addBuildRequirements . apply ( spec , options . buildRequires ) ; } if ( _ . has ( options , 'provides' ) ) { spec . addProvides . apply ( spec , options . provides ) ; } if ( options . autoReq === false ) { spec . tags . autoReq = options . autoReq ; } if ( options . autoProv === false ) { spec . tags . autoProv = options . autoProv ; } if ( options . hasOwnProperty ( 'excludeArchs' ) ) { spec . addExcludeArchs . apply ( spec , options . excludeArchs ) ; } if ( options . hasOwnProperty ( 'exclusiveArchs' ) ) { spec . addExclusiveArchs . apply ( spec , options . exclusiveArchs ) ; } if ( options . hasOwnProperty ( 'excludeOS' ) ) { spec . addExcludeOS . apply ( spec , options . excludeOS ) ; } if ( options . hasOwnProperty ( 'exclusiveOS' ) ) { spec . addExclusiveOS . apply ( spec , options . exclusiveOS ) ; } spec . tags . prefix = options . prefix || spec . tags . prefix ; spec . tags . buildRoot = options . buildRoot || spec . tags . buildRoot ; if ( options . hasOwnProperty ( 'sources' ) ) { spec . addSources . apply ( spec , options . sources ) ; } if ( options . hasOwnProperty ( 'noSources' ) ) { spec . addNoSources . apply ( spec , options . noSources ) ; } if ( options . hasOwnProperty ( 'patches' ) ) { spec . addPatches . apply ( spec , options . patches ) ; } if ( options . hasOwnProperty ( 'noPatches' ) ) { spec . addNoPatches . apply ( spec , options . noPatches ) ; } // Add scripts from options. if ( options . hasOwnProperty ( 'prepScript' ) ) { spec . addPrepScripts . apply ( spec , options . prepScript ) ; } if ( options . hasOwnProperty ( 'buildScript' ) ) { spec . addBuildScripts . apply ( spec , options . buildScript ) ; } if ( options . hasOwnProperty ( 'checkScript' ) ) { spec . addCheckScripts . apply ( spec , options . checkScript ) ; } if ( options . hasOwnProperty ( 'cleanScript' ) ) { spec . addCleanScripts . apply ( spec , options . cleanScript ) ; } if ( options . hasOwnProperty ( 'installScript' ) ) { spec . addInstallScripts . apply ( spec , options . installScript ) ; } if ( options . hasOwnProperty ( 'preInstallScript' ) ) { spec . addPreInstallScripts . apply ( spec , options . preInstallScript ) ; } if ( options . hasOwnProperty ( 'postInstallScript' ) ) { spec . addPostInstallScripts . apply ( spec , options . postInstallScript ) ; } if ( options . hasOwnProperty ( 'preUninstallScript' ) ) { spec . addPreUninstallScripts . apply ( spec , options . preUninstallScript ) ; } if ( options . hasOwnProperty ( 'postUninstallScript' ) ) { spec . addPostUninstallScripts . apply ( spec , options . postUninstallScript ) ; } if ( options . hasOwnProperty ( 'verifyScript' ) ) { spec . addVerifyScripts . apply ( spec , options . verifyScript ) ; } // Add the default file attributes from options. if ( options . hasOwnProperty ( 'defaultAttributes' ) ) { spec . setDefaultAttributes ( options . defaultAttributes ) ; } // Add the changelogs. if ( options . hasOwnProperty ( 'changelog' ) ) { var changelog ; if ( _ . isFunction ( options . changelog ) ) { changelog = options . changelog ( ) ; } else if ( _ . isArray ( options . changelog ) ) { changelog = options . changelog ; } spec . addChangelogs . apply ( spec , changelog ) ; } }<CODESPLIT>0.16704997420310974<CODESPLIT>0.13293875753879547

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/format-message/format-message/blob/7c683c57373d2999ba60f1d2ac47e09c848606dd/packages/format-message-parse/index.js#L433-L442<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function SyntaxError ( message /*: string */ , expected /*: ?string */ , found /*: ?string */ , offset /*: number */ , line /*: number */ , column /*: number */ ) { Error . call ( this , message ) this . name = 'SyntaxError' this . message = message this . expected = expected this . found = found this . offset = offset this . line = line this . column = column }<CODESPLIT>0.13019028306007385<CODESPLIT>0.18632012605667114

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/duaraghav8/Ethlint/blob/7d264373709561148c7166601ac39370e78f74b1/lib/rules/indentation.js#L10-L25<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getIndentDescription ( indentStyle , level ) { // If either user has specified 0 indent or we're at level 0 (start), totalIndent becomes 0. const totalIndent = indentStyle . length * level , s = totalIndent > 1 ? "s" : "" ; // If style is that there should be no indent for any level OR we're at base level if ( totalIndent === 0 ) { return "0 whitespace" ; } if ( indentStyle [ 0 ] === " " ) { return ` ${ totalIndent } ${ s } ` ; } // If above 2 are bypassed, indent style must be tab(s) return ` ${ totalIndent } ${ s } ` ; }<CODESPLIT>0.15860094130039215<CODESPLIT>0.14530056715011597

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/Softmotions/ejdb-node/blob/9d3c37ac2d16bb2839c2cf5cdb0d068e70b2c9cc/ejdb.js#L38-L46<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( ) { Object . defineProperty ( this , "_impl" , { value : new EJDBImpl ( ) , configurable : false , enumerable : false , writable : false } ) ; return this ; }<CODESPLIT>0.13768704235553741<CODESPLIT>0.15011529624462128

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/typhonjs-node-esdoc/esdoc-plugin-dependency-graphs/blob/af2d9cabce2d48edd4ad7ed81c722cc27efacb67/template/html/d3-graph.js#L1091-L1131<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function updateTableUI ( ) { var table = $ ( '.control-table tbody' ) ; table . off ( 'mouseenter' , 'tr' , onControlTableRowMouseOver ) ; table . off ( 'mouseleave' , 'tr' , onControlTableRowMouseOver ) ; table . off ( 'contextmenu' , 'tr' , onControlTableRowContextClick ) ; table . empty ( ) ; if ( data ) { data . nodes . forEach ( function ( node ) { var nd = node . packageData ; var name = appOptions . showFullNames ? nd . actualPackageName : nd . packageName ; var isAliased = nd . isAlias ? ' isAliased' : '' ; var tr = $ ( '<tr>' + '<td class="mdl-data-table__cell--non-numeric' + isAliased + '">' + name + '</td>' + '<td class="mdl-data-table__cell--non-numeric">' + nd . jspmType + '</td>' + '<td class="mdl-data-table__cell--non-numeric">' + nd . version + '</td>' + '<td class="mdl-data-table__cell--non-numeric">' + node . minLevel + '</td>' + '</tr>' ) ; table . append ( tr ) ; tr . on ( 'mouseenter' , onControlTableRowMouseOver . bind ( this , nodes , links , node , true ) ) ; tr . on ( 'mouseleave' , onControlTableRowMouseOver . bind ( this , nodes , links , node , false ) ) ; tr . on ( 'contextmenu' , onControlTableRowContextClick . bind ( this , node ) ) ; } ) ; // Removes sort order for any header and signals update for new data $ ( '#nodeTable th' ) . removeClass ( 'headerSortDown' ) ; $ ( '#nodeTable th' ) . removeClass ( 'headerSortUp' ) ; $ ( '#nodeTable' ) . trigger ( 'update' ) ; updateTableUIExtent ( ) ; } }<CODESPLIT>0.1633441299200058<CODESPLIT>0.11244762688875198

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/kevincennis/promise/blob/b58ef67dd4023139d0aad98ccd0cb60d8a4f9eec/promise.js#L742-L772<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function PromiseResolutionHandlerFunction ( ) { return function F ( x ) { var promise = F [ '[[Promise]]' ] , fulfillmentHandler = F [ '[[FulfillmentHandler]]' ] , rejectionHandler = F [ '[[RejectionHandler]]' ] , selfResolutionError , C , promiseCapability , updateResult ; if ( SameValue ( x , promise ) ) { selfResolutionError = TypeError ( ) ; return rejectionHandler . call ( undefined , selfResolutionError ) ; } C = promise [ '[[PromiseConstructor]]' ] ; try { promiseCapability = NewPromiseCapability ( C ) ; } catch ( e ) { return e ; } try { updateResult = UpdatePromiseFromPotentialThenable ( x , promiseCapability ) ; } catch ( e ) { return e ; } if ( updateResult !== 'not a thenable' ) { return promiseCapability [ '[[Promise]]' ] . then ( fulfillmentHandler , rejectionHandler ) ; } return fulfillmentHandler . call ( undefined , x ) ; } ; }<CODESPLIT>0.14504703879356384<CODESPLIT>0.14575518667697906

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/xperiments/TSDoc/blob/d153780b05b7500b55346b9a6b4a241fb5788ee8/template/publish.js#L48-L51<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function isModuleFunction2 ( doclet ) { return doclet . longname && doclet . longname === doclet . name && doclet . longname . indexOf ( 'module:' ) === 0 && doclet . kind === 'function' ; }<CODESPLIT>0.15710894763469696<CODESPLIT>0.1457282453775406

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/staaky/vatrates/blob/a832b9b5f9d0d2230c98d3ad399c96872d46c709/src/js/vatperiod.js#L10-L16<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function VATPeriod ( effectiveFrom , superReduced , reduced , standard , parking ) { this . _effectiveFrom = effectiveFrom ; this . _superReduced = superReduced ; this . _reduced = reduced ; this . _standard = standard ; this . _parking = parking ; }<CODESPLIT>0.14742644131183624<CODESPLIT>0.12330665439367294

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/zhs007/dsl-core/blob/d97ac3a498cb0a51b165a4ea970db66294e0b8d4/lib/base.js#L332-L345<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getStructMemberType ( membername , structname , root ) { var obj = getGlobalObj ( structname , root ) ; if ( obj != undefined ) { if ( obj . type == 'message' || obj . type == 'struct' || obj . type == 'static' ) { for ( var i = 0 ; i < obj . val . length ; ++ i ) { if ( obj . val [ i ] . name . name == membername ) { return obj . val [ i ] . type ; } } } } return undefined ; }<CODESPLIT>0.1136670708656311<CODESPLIT>0.1567322015762329

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/core/class/Base.js#L576-L610<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( name , mixinClass ) { var mixin = mixinClass . prototype , prototype = this . prototype , key ; if ( typeof mixin . onClassMixedIn != 'undefined' ) { mixin . onClassMixedIn . call ( mixinClass , this ) ; } if ( ! prototype . hasOwnProperty ( 'mixins' ) ) { if ( 'mixins' in prototype ) { prototype . mixins = Ext . Object . chain ( prototype . mixins ) ; } else { prototype . mixins = { } ; } } for ( key in mixin ) { if ( key === 'mixins' ) { Ext . merge ( prototype . mixins , mixin [ key ] ) ; } else if ( typeof prototype [ key ] == 'undefined' && key != 'mixinId' && key != 'config' ) { prototype [ key ] = mixin [ key ] ; } } //<feature classSystem.config> if ( 'config' in mixin ) { this . addConfig ( mixin . config , false ) ; } //</feature> prototype . mixins [ name ] = mixin ; }<CODESPLIT>0.1721639186143875<CODESPLIT>0.1368502825498581

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/yeezon/yhsd-api-node/blob/d46be67c1dff6bb86232e4ee491e6d5228a74489/lib/Api.js#L140-L150<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( method , path , params ) { return this . _request . request ( { hostname : this . host , path : '/v1/' + path , method : method , headers : { 'Content-Type' : 'application/json' , 'X-API-ACCESS-TOKEN' : this . token } } , params ) ; }<CODESPLIT>0.14774124324321747<CODESPLIT>0.17072364687919617

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L10348-L10357<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( store , type , payload ) { var root = this . keyForAttribute ( type . typeKey ) , partials = payload [ Ember . String . pluralize ( root ) ] ; forEach ( partials , function ( partial ) { updatePayloadWithEmbedded ( store , this , type , partial , payload ) ; } , this ) ; return this . _super ( store , type , payload ) ; }<CODESPLIT>0.16869474947452545<CODESPLIT>0.15151657164096832

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/johntitus/node-horseman/blob/831699df1708d96c91d8010a8ee975c4d022fe0e/lib/index.js#L90-L162<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function Horseman ( options ) { this . ready = false ; if ( ! ( this instanceof Horseman ) ) { return new Horseman ( options ) ; } this . options = defaults ( clone ( options ) || { } , DEFAULTS ) ; this . id = ++ instanceId ; debug ( '.setup() creating phantom instance %s' , this . id ) ; var phantomOptions = { 'load-images' : this . options . loadImages , 'ssl-protocol' : this . options . sslProtocol } ; if ( typeof this . options . ignoreSSLErrors !== 'undefined' ) { phantomOptions [ 'ignore-ssl-errors' ] = this . options . ignoreSSLErrors ; } if ( typeof this . options . webSecurity !== 'undefined' ) { phantomOptions [ 'web-security' ] = this . options . webSecurity ; } if ( typeof this . options . proxy !== 'undefined' ) { phantomOptions . proxy = this . options . proxy ; } if ( typeof this . options . proxyType !== 'undefined' ) { phantomOptions [ 'proxy-type' ] = this . options . proxyType ; } if ( typeof this . options . proxyAuth !== 'undefined' ) { phantomOptions [ 'proxy-auth' ] = this . options . proxyAuth ; } if ( typeof this . options . diskCache !== 'undefined' ) { phantomOptions [ 'disk-cache' ] = this . options . diskCache ; } if ( typeof this . options . diskCachePath !== 'undefined' ) { phantomOptions [ 'disk-cache-path' ] = this . options . diskCachePath ; } if ( typeof this . options . cookiesFile !== 'undefined' ) { phantomOptions [ 'cookies-file' ] = this . options . cookiesFile ; } if ( this . options . debugPort ) { phantomOptions [ 'remote-debugger-port' ] = this . options . debugPort ; phantomOptions [ 'remote-debugger-autorun' ] = 'no' ; if ( this . options . debugAutorun !== false ) { phantomOptions [ 'remote-debugger-autorun' ] = 'yes' ; } } Object . keys ( this . options . phantomOptions || { } ) . forEach ( function ( key ) { if ( typeof phantomOptions [ key ] !== 'undefined' ) { debug ( 'Horseman option ' + key + ' overridden by phantomOptions' ) ; } phantomOptions [ key ] = this . options . phantomOptions [ key ] ; } . bind ( this ) ) ; var instantiationOptions = { parameters : phantomOptions } ; if ( typeof this . options . phantomPath !== 'undefined' ) { instantiationOptions [ 'path' ] = this . options . phantomPath ; } // Store the url that was requested for the current url this . targetUrl = null ; // Store the HTTP status code for resources requested. this . responses = { } ; this . tabs = [ ] ; this . onTabCreated = noop ; this . onTabClosed = noop ; this . ready = prepare ( this , instantiationOptions ) ; }<CODESPLIT>0.1495337188243866<CODESPLIT>0.1169203445315361

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/localnerve/html-snapshots/blob/63e829b234a8fa1399da1f7347a7fb3463e862a8/lib/input-generators/_base.js#L207-L211<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( options , generator , listener ) { options = options || { } ; prepOptions ( options , listener ) ; return generator ( options ) ; }<CODESPLIT>0.15945424139499664<CODESPLIT>0.12619295716285706

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/azproduction/lmd/blob/03410c36839728de683c697670e1b205dc8193ee/lib/coverage_apply.js#L334-L392<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function countFunction ( ) { var ret ; if ( isFirstLine ) { isFirstLine = false ; return ret ; } if ( this [ 0 ] . start && analyzing . indexOf ( this ) < 0 ) { var defun = this [ 0 ] . name === "defun" ; var lineId = this [ 0 ] . start . line + lineOffset + '' ; //this[0].name + ":" + this[0].start.line + ":" + this[0].start.pos; var fnName = this [ 1 ] || this [ 0 ] . anonymousName || "(?)" ; var fnId = fnName + ':' + ( this [ 0 ] . start . line + lineOffset ) + ":" + this [ 0 ] . start . pos ; var body = this [ 3 ] ; analyzing . push ( this ) ; // put a new function call inside the body, works also on empty functions if ( options [ "function" ] ) { body . splice ( 0 , 0 , [ "stat" , [ "call" , [ "dot" , [ "name" , "require" ] , "coverage_function" ] , [ [ "string" , moduleName ] , [ "string" , fnId ] ] ] ] ) ; // It would be great to instrument the 'exit' from a function // but it means tracking all return statements, maybe in the future... rememberFunction ( fnId ) ; } if ( defun ) { // 'defun' should also be remembered as statements rememberStatement ( lineId ) ; ret = [ "splice" , [ [ "stat" , [ "call" , [ "dot" , [ "name" , "require" ] , "coverage_line" ] , [ [ "string" , moduleName ] , [ "string" , lineId ] ] ] ] , walker . walk ( this ) ] ] ; } else { ret = walker . walk ( this ) ; } analyzing . pop ( this ) ; } return ret ; }<CODESPLIT>0.1644018143415451<CODESPLIT>0.1549801230430603

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/AndreasMadsen/article/blob/8cf3777fc9dc72d041214faae1b8d65d37a7d134/lib/fase-2/commonality.js#L100-L104<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function arrayVector ( size ) { var vec = new Array ( size ) ; for ( var i = 0 ; i < size ; i ++ ) vec [ i ] = [ ] ; return vec ; }<CODESPLIT>0.15993434190750122<CODESPLIT>0.14639690518379211

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/appbaseio/reactivecore/blob/793de229c19013e5f2734d8d0b91332618aeb1ec/src/utils/analytics.js#L67-L87<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getFilterString ( selectedValues ) { if ( selectedValues && Object . keys ( selectedValues ) . length ) { return Object // take all selectedValues . entries ( selectedValues ) // filter out filter components having some value . filter ( ( [ , componentValues ] ) => filterComponents . includes ( componentValues . componentType ) // in case of an array filter out empty array values as well && ( ( componentValues . value && componentValues . value . length ) // also consider range values in the shape { start, end } || componentValues . value . start || componentValues . value . end ) ) // parse each filter value . map ( ( [ componentId , componentValues ] ) => parseFilterValue ( componentId , componentValues ) ) // return as a string separated with comma . join ( ) ; } return null ; }<CODESPLIT>0.14068716764450073<CODESPLIT>0.13732081651687622

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/pureqml/qmlcore/blob/21416cb4b45dce6cf6c603dfa43d6683e0d48638/platform/video.videojs/dist/video.es.js#L4952-L4972<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function trackToJson_ ( track ) { var ret = [ 'kind' , 'label' , 'language' , 'id' , 'inBandMetadataTrackDispatchType' , 'mode' , 'src' ] . reduce ( function ( acc , prop , i ) { if ( track [ prop ] ) { acc [ prop ] = track [ prop ] ; } return acc ; } , { cues : track . cues && Array . prototype . map . call ( track . cues , function ( cue ) { return { startTime : cue . startTime , endTime : cue . endTime , text : cue . text , id : cue . id } ; } ) } ) ; return ret ; }<CODESPLIT>0.15367375314235687<CODESPLIT>0.1409260332584381

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L65059-L65073<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( ) { var parsed = this . parsed ; var len = this . types . length ; var idx = - 1 ; var tok ; while ( ++ idx < len ) { if ( ( tok = this . parsers [ this . types [ idx ] ] . call ( this ) ) ) { define ( tok , 'rest' , this . input ) ; define ( tok , 'parsed' , parsed ) ; this . last = tok ; return tok ; } } }<CODESPLIT>0.15894725918769836<CODESPLIT>0.13665904104709625

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/picker/Date.js#L218-L233<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( newMonthText , oldMonthText ) { var innerItems = this . getInnerItems , ln = innerItems . length , item , i ; //loop through each of the current items and set the title on the correct slice if ( this . initialized ) { for ( i = 0 ; i < ln ; i ++ ) { item = innerItems [ i ] ; if ( ( typeof item . title == "string" && item . title == oldMonthText ) || ( item . title . html == oldMonthText ) ) { item . setTitle ( newMonthText ) ; } } } }<CODESPLIT>0.14817526936531067<CODESPLIT>0.1404622346162796

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L2971-L2988<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( key ) { var factory ; if ( typeof key === 'string' ) { var normalizedKey = this . container . normalize ( 'model:' + key ) ; factory = this . container . lookupFactory ( normalizedKey ) ; if ( ! factory ) { throw new Ember . Error ( "No model was found for '" + key + "'" ) ; } factory . typeKey = normalizedKey . split ( ':' , 2 ) [ 1 ] ; } else { // A factory already supplied. factory = key ; } factory . store = this ; return factory ; }<CODESPLIT>0.1781768798828125<CODESPLIT>0.13560886681079865

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/cubicmushroom/gulp-cm-phpspec-tasks/blob/671b5e6e9545c7a6a027f8b93c1349d491cf429e/pakmanaged.js#L54751-L54765<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function uniq ( array , isSorted , iteratee , thisArg ) { var length = array ? array . length : 0 ; if ( ! length ) { return [ ] ; } if ( isSorted != null && typeof isSorted != 'boolean' ) { thisArg = iteratee ; iteratee = isIterateeCall ( array , isSorted , thisArg ) ? undefined : isSorted ; isSorted = false ; } iteratee = iteratee == null ? iteratee : baseCallback ( iteratee , thisArg , 3 ) ; return ( isSorted ) ? sortedUniq ( array , iteratee ) : baseUniq ( array , iteratee ) ; }<CODESPLIT>0.17233364284038544<CODESPLIT>0.13073541224002838

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/azproduction/lmd/blob/03410c36839728de683c697670e1b205dc8193ee/bin/lmd_builder.js#L552-L587<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getEvents ( ast ) { var usage = { } , eventIndex = 0 ; walker . with_walkers ( { // looking for first var with sandbox item; "call" : function ( ) { if ( this [ 1 ] && this [ 2 ] [ 0 ] ) { var functionName = this [ 1 ] [ 1 ] ; switch ( functionName ) { case "lmd_on" : case "lmd_trigger" : var eventName = this [ 2 ] [ 0 ] [ 1 ] ; if ( ! usage [ eventName ] ) { usage [ eventName ] = { on : 0 , trigger : 0 , eventIndex : eventIndex } ; eventIndex ++ ; } if ( functionName === "lmd_on" ) { usage [ eventName ] . on ++ ; } else { usage [ eventName ] . trigger ++ ; } break ; } } } } , function ( ) { return walker . walk ( ast ) ; } ) ; return usage ; }<CODESPLIT>0.1547340750694275<CODESPLIT>0.15747569501399994

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/bigpipe/fabricator/blob/b480885caf5f2367385e981e1a915dda18de2806/index.js#L178-L185<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function empty ( value ) { if ( ! value ) return true ; switch ( is ( value ) ) { case "object" : return ! Object . keys ( value ) . length ; case "array" : return ! value . length ; default : return ! value ; } }<CODESPLIT>0.17889708280563354<CODESPLIT>0.12397980690002441

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/jasmith79/decorators-js/blob/9d34c8056f6ffa7dba07cc4e0919e6e243beea33/dist/decorators.js#L286-L298<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function trampoline ( fn ) { return curry ( fn . length , function ( ) { for ( var _len10 = arguments . length , args = Array ( _len10 ) , _key10 = 0 ; _key10 < _len10 ; _key10 ++ ) { args [ _key10 ] = arguments [ _key10 ] ; } var result = fn . apply ( this , args ) ; while ( _extractHiddenClass ( result ) === 'Function' ) { result = result ( ) ; } return result ; } ) ; }<CODESPLIT>0.1465662121772766<CODESPLIT>0.13689781725406647

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/luosijie/vm-markdown/blob/98d37320bb7d7e0f4d78218b769f11d5da811528/src/components/vm-markdown/utils/insertText.js#L11-L54<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getSelection ( el ) { var start = 0 , end = 0 , normalizedValue , range , textInputRange , len , endRange ; if ( typeof el . selectionStart == "number" && typeof el . selectionEnd == "number" ) { start = el . selectionStart ; end = el . selectionEnd ; } else { range = document . selection . createRange ( ) ; if ( range && range . parentElement ( ) == el ) { len = el . value . length ; normalizedValue = el . value . replace ( / \r\n / g , "\n" ) ; // Create a working TextRange that lives only in the input textInputRange = el . createTextRange ( ) ; textInputRange . moveToBookmark ( range . getBookmark ( ) ) ; // Check if the start and end of the selection are at the very end // of the input, since moveStart/moveEnd doesn't return what we want // in those cases endRange = el . createTextRange ( ) ; endRange . collapse ( false ) ; if ( textInputRange . compareEndPoints ( "StartToEnd" , endRange ) > - 1 ) { start = end = len ; } else { start = - textInputRange . moveStart ( "character" , - len ) ; start += normalizedValue . slice ( 0 , start ) . split ( "\n" ) . length - 1 ; if ( textInputRange . compareEndPoints ( "EndToEnd" , endRange ) > - 1 ) { end = len ; } else { end = - textInputRange . moveEnd ( "character" , - len ) ; end += normalizedValue . slice ( 0 , end ) . split ( "\n" ) . length - 1 ; } } } } return { start : start , end : end } }<CODESPLIT>0.16304276883602142<CODESPLIT>0.13418208062648773

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/G-E-O-F/peels/blob/09ed8c202b2585b33c8c15f14932f1fcba4adbf0/lib/sphere/positions.js#L60-L79<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function course ( pos1 , pos2 ) { var f1_    os1[ 0 ] ,  f1_    os1[ 1 ] ,  f2_    os2[ 0 ] ,  f2_    os2[ 1 ] ;  var d = distance ( f1_,   1_,  f _, f 2 ), a ,   o u se = { ;    if ( sin ( f2_    1_)  < 0   {  a = acos ( ( sin ( f2_)     in( f 1_)  * c s(d ) )   / ( i n(d )   * c s(f 1 _))) ;    } else { a = 2 *     cos( ( s in( f 2_)  - s n(f 1 _) *   o (d) )   /   s n (d)   *   o (f1 _ )));     } course . d = d ; course . a = a ; return course ; }<CODESPLIT>0.16906824707984924<CODESPLIT>0.15355601906776428

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/intelligo-systems/intelligo.js/blob/9e75d48214fb41d346462f5d886bd92cc9956df6/dist/multilabel/Homer.js#L288-L293<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( featureLookupTable , treeNode ) { if ( treeNode . superlabelClassifier && treeNode . superlabelClassifier . setFeatureLookupTable ) treeNode . superlabelClassifier . setFeatureLookupTable ( featureLookupTable ) ; for ( var superlabel in treeNode . mapSuperlabelToBranch ) this . setFeatureLookupTableRecursive ( featureLookupTable , treeNode . mapSuperlabelToBranch [ superlabel ] ) ; }<CODESPLIT>0.14404653012752533<CODESPLIT>0.1496092528104782

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/alvarotrigo/react-fullpage/blob/5a11fb5211e5706da81f2874516f023dc6e5aa88/example/dist/bundle.js#L19109-L19120<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function computeUniqueAsyncExpiration ( ) { var currentTime = requestCurrentTime ( ) ; var result = computeAsyncExpiration ( currentTime ) ; if ( result <= lastUniqueAsyncExpiration ) { // Since we assume the current time monotonically increases, we only hit // this branch when computeUniqueAsyncExpiration is fired multiple times // within a 200ms window (or whatever the async bucket size is). result = lastUniqueAsyncExpiration + 1 ; } lastUniqueAsyncExpiration = result ; return lastUniqueAsyncExpiration ; }<CODESPLIT>0.15365634858608246<CODESPLIT>0.11190352588891983

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/pandao/editor.md/blob/0e76f96d476397c5a9e64388a36e2ed74183d11e/editormd.amd.js#L1008-L1025<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( key , value ) { var settings = this . settings ; if ( typeof key === "object" ) { settings = $ . extend ( true , settings , key ) ; } if ( typeof key === "string" ) { settings [ key ] = value ; } this . settings = settings ; this . recreate ( ) ; return this ; }<CODESPLIT>0.14951765537261963<CODESPLIT>0.1543446183204651

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/Kashoo/synctos/blob/a6d59b4d4af2b837842d2107c57064c3fa12cc73/samples/sample-sync-doc-definitions.js#L34-L46<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getBusinessId ( doc , oldDoc ) { var regex = / ^biz\.([A-Za-z0-9_-]+)(?:\..+)?$ / ; var matchGroups = regex . exec ( doc . _id ) ; if ( matchGroups ) { return matchGroups [ 1 ] ; } else if ( oldDoc && oldDoc . businessId ) { // The document ID doesn't contain a business ID, so use the property from the old document return oldDoc . businessId || null ; } else { // Neither the document ID nor the old document's contents contain a business ID, so use the property from the new document return doc . businessId || null ; } }<CODESPLIT>0.16103465855121613<CODESPLIT>0.15549404919147491

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/ticup/emotional/blob/ab43abab8715d3ecefc359a7649dfdbeba8095ce/index.js#L158-L172<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function avgAssessment ( assessments , weighted ) { var w ; var s = 0 ; var n = 0 ; assessments . forEach ( function ( ws ) { w = weighted ( ws [ 0 ] ) ; s += w * ws [ 1 ] ; n += w ; } ) ; if ( n === 0 ) { return 0 ; } else { return s / n ; } }<CODESPLIT>0.13284003734588623<CODESPLIT>0.1312985122203827

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/andrao/node-analytics/blob/170bca2d2985cc384aa584b0e588221a96630834/node-analytics.js#L554-L583<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getLocation ( cb ) { if ( ! geo_lookup ) return cb ( null ) ; const loc = geo_lookup . get ( session . ip ) ; if ( ! session . geo ) session . geo = { } ; if ( loc ) { try { if ( loc . city ) session . geo . city = loc . city . names . en ; if ( loc . subdivisions ) session . geo . state = loc . subdivisions [ 0 ] . iso_code ; if ( loc . country ) session . geo . country = loc . country . iso_code ; if ( loc . continent ) session . geo . continent = loc . continent . code ; if ( loc . location ) session . geo . time_zone = loc . location . time_zone ; } catch ( e ) { log . error ( 'geoIP error:' , e ) ; } } cb ( null ) }<CODESPLIT>0.16613806784152985<CODESPLIT>0.12309538573026657

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/kevinoid/travis-status/blob/4432996e44c111046cbf0ca7b0054fe1a0a7032d/lib/travis-status-checker.js#L97-L150<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function queryWithWait ( query , valueIsPending , options ) { const maxWaitMs = options && options . wait ? Number ( options . wait ) : 0 ; if ( Number . isNaN ( maxWaitMs ) ) { return Promise . reject ( new TypeError ( 'wait must be a number' ) ) ; } if ( maxWaitMs < 0 ) { return Promise . reject ( new RangeError ( 'wait must be non-negative' ) ) ; } const startMs = Date . now ( ) ; // Note:  Divide by 2 so we can double unconditionally below let nextWaitMs = POLL_TIME_START_MS / 2 ; function doQuery ( cb ) { query . get ( cb ) ; } return new Promise ( ( resolve , reject ) => { function checkBuild ( err , result ) { if ( err ) { reject ( err ) ; return ; } if ( maxWaitMs ) { let isPending ; try { isPending = valueIsPending ( result ) ; } catch ( errPending ) { reject ( errPending ) ; return ; } if ( isPending ) { const nowMs = Date . now ( ) ; const totalWaitMs = nowMs - startMs ; if ( totalWaitMs < maxWaitMs ) { nextWaitMs = Math . min ( nextWaitMs * 2 , POLL_TIME_MAX_MS , maxWaitMs - totalWaitMs ) ; setTimeout ( doQuery , nextWaitMs , checkBuild ) ; return ; } } } resolve ( result ) ; } doQuery ( checkBuild ) ; } ) ; }<CODESPLIT>0.1577880084514618<CODESPLIT>0.13165292143821716

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/cranbee/template/blob/84044ca9124c5eb4dc28d8e0c8d366c7abd761fa/src/executor.js#L11-L37<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function executeNode ( node , data , result ) { if ( node . type === "#" ) { executeText ( node , data , result ) ; return ; } if ( node . props . each ) { executeEach ( node , data , result ) ; return ; } if ( node . props . if ) { executeIf ( node , data , result ) ; return ; } if ( node . props . fi ) { executeFi ( node , data , result ) ; return ; } let props = { } ; Object . keys ( node . props ) . forEach ( key => { if ( key !== "each" && key !== "if" && key !== "fi" ) { props [ key ] = Extender . processProp ( node . props [ key ] , data ) ; } } ) ; let children = [ ] ; node . children . forEach ( child => executeNode ( child , data , children ) ) ; result . push ( { type : node . type , props , children } ) ; }<CODESPLIT>0.15282590687274933<CODESPLIT>0.1501970738172531

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/impaler/ide-template/blob/d9a9822786075cc0b0de788d8aa4ab2045bf2210/lib/io.js#L244-L254<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function compareHigher ( a , b ) { var numA = parseFloat ( / [\d\.]+$ / . exec ( a ) [ 0 ] ) ; var numB = parseFloat ( / [\d\.]+$ / . exec ( b ) [ 0 ] ) ; if ( isNaN ( numA ) || ( numB > numA ) ) { return + 1 ; } else if ( isNaN ( numB ) || ( numA > numB ) ) { return - 1 ; } else { return 0 ; } }<CODESPLIT>0.11207304149866104<CODESPLIT>0.14851604402065277

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/device/contacts/Abstract.js#L19-L40<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( config ) { if ( ! this . _store ) { this . _store = [ { first : 'Robert' , last : 'Dougan' , emails : { work : 'rob@sencha.com' } } , { first : 'Jamie' , last : 'Avins' , emails : { work : 'jamie@sencha.com' } } ] ; } config . success . call ( config . scope || this , this . _store ) ; }<CODESPLIT>0.17176087200641632<CODESPLIT>0.1612817347049713

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/Mermade/jgeXml/blob/9bf6fcde331649a5a5e39314edd55e73eb0e4c15/jpath.js#L15-L82<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function jptr ( obj , prop , newValue ) { //property not found if ( typeof obj === 'undefined' ) return false ; if ( ( ! prop ) || ( prop == '#' ) ) return obj ; if ( prop . startsWith ( '#' ) ) prop = prop . slice ( 1 ) ; if ( prop . startsWith ( '/' ) ) prop = prop . slice ( 1 ) ; var props = prop . split ( '/' ) ; var current = props [ 0 ] ; current = current . replaceAll ( '~1' , '/' ) ; current = current . replaceAll ( '~0' , '~' ) ; var index = - 1 ; if ( ( props . length > 1 ) && ( Array . isArray ( obj [ current ] ) ) ) { var next = props [ 1 ] ; var value = parseInt ( next , 10 ) ; if ( next == '-' ) { index = obj [ current ] . length ; } else { if ( ! isNaN ( value ) ) index = value ; } if ( index >= 0 ) { props . splice ( 1 , 1 ) ; prop = props . join ( '/' ) ; } } //property split found; recursive call if ( props . length > 1 ) { var pos = prop . indexOf ( '/' ) ; //get object at property (before split), pass on remainder if ( index >= 0 ) { return jptr ( obj [ current ] [ index ] , prop . substr ( pos + 1 ) , newValue ) ; //was props } else { return jptr ( obj [ current ] , prop . substr ( pos + 1 ) , newValue ) ; } } //no split; get property[index] or property var source = obj ; if ( current ) source = obj [ current ] ; if ( index >= 0 ) { if ( index >= source . length ) { if ( typeof newValue != 'undefined' ) { source . push ( newValue ) ; return newValue ; } else { return null ; } } else { if ( typeof newValue != 'undefined' ) { source [ index ] = newValue ; } return source [ index ] ; } } else { if ( typeof newValue != 'undefined' ) { obj [ prop ] = newValue ; source = obj [ prop ] ; } return source ; } }<CODESPLIT>0.15245197713375092<CODESPLIT>0.14609435200691223

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/yortus/asyncawait/blob/7b4f573ecc7e388a1b05fa0c454bbe5d1b0154f2/src/await/makeAwaitFunc.js#L71-L88<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function traverseInPlace ( o , visitor ) { if ( _ . isArray ( o ) ) { var len = o . length ; for ( var i = 0 ; i < len ; ++ i ) { traverseInPlace ( o [ i ] , visitor ) ; visitor ( o , i ) ; } } else if ( _ . isPlainObject ( o ) ) { for ( var key in o ) { if ( ! o . hasOwnProperty ( key ) ) continue ; traverseInPlace ( o [ key ] , visitor ) ; visitor ( o , key ) ; } } return o ; }<CODESPLIT>0.1647242158651352<CODESPLIT>0.14119559526443481

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/mrtcode/opstream/blob/3364bc556d50ab8b1ce340878e3febceea2f4f3b/opstream.js#L157-L194<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( options ) { var opStream = this ; options = options || { } ; this . pingIntervalMs = options . pingIntervalMs || 5000 ; this . pingTimeoutMs = options . pingTimeoutMs || 3000 ; this . inStream = new InStream ( { maxLen : options . inMaxLen } ) ; this . outStream = new OutStream ( { retryTimeout : options . outRetryTimeout , maxNotAck : options . outMaxNotAck } ) ; this . inStream . _send = this . _send . bind ( this ) ; this . outStream . _send = this . _send . bind ( this ) ; this . inStream . onReadable = function ( ) { if ( opStream . onReadable ) opStream . onReadable ( ) ; } ; this . onReadable = null ; this . onOnline = null ; this . onOffline = null ; this . lastPing = 0 ; this . connectionStatus = 'online' ; this . paused = false ; this . timerInterval = null ; this . pingTimeout = null ; this . initTimer ( ) ; }<CODESPLIT>0.14595042169094086<CODESPLIT>0.11994128674268723

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/react-webpack-generators/generator-react-webpack/blob/9c682541787602290fc6d115d90dbd3386cfda10/generators/setup-env/utils.js#L44-L64<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getModifiedConfigModuleIndex ( fileStr , snakedEnv , classedEnv ) { // TODO [sthzg] we might want to rewrite the AST-mods in this function using a walker. const moduleFileAst = acorn . parse ( fileStr , { module : true } ) ; // if required env was already created, just return the original string if ( jp . paths ( moduleFileAst , ` ${ classedEnv } ` ) . length > 0 ) { return fileStr ; } // insert require call for the new env const envImportAst = acorn . parse ( ` ${ snakedEnv } ${ classedEnv } ` ) ; const insertAt = jp . paths ( moduleFileAst , '$..[?(@.name=="require")]' ) . pop ( ) [ 2 ] + 1 ; moduleFileAst . body . splice ( insertAt , 0 , envImportAst ) ; // add new env to module.exports const exportsAt = jp . paths ( moduleFileAst , '$..[?(@.name=="exports")]' ) . pop ( ) [ 2 ] ; moduleFileAst . body [ exportsAt ] . expression . right . properties . push ( createExportNode ( snakedEnv ) ) ; return escodegen . generate ( moduleFileAst , { format : { indent : { style : '  ' } } } ) ; }<CODESPLIT>0.15609882771968842<CODESPLIT>0.1424144208431244

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/oauthjs/node-oauth2-server/blob/90d00495842cbc68869214a4e6696e5ad048c93d/lib/grant-types/abstract-grant-type.js#L18-L33<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function AbstractGrantType ( options ) { options = options || { } ; if ( ! options . accessTokenLifetime ) { throw new InvalidArgumentError ( 'Missing parameter: `accessTokenLifetime`' ) ; } if ( ! options . model ) { throw new InvalidArgumentError ( 'Missing parameter: `model`' ) ; } this . accessTokenLifetime = options . accessTokenLifetime ; this . model = options . model ; this . refreshTokenLifetime = options . refreshTokenLifetime ; this . alwaysIssueNewRefreshToken = options . alwaysIssueNewRefreshToken ; }<CODESPLIT>0.16037137806415558<CODESPLIT>0.10833171755075455

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/Isithelo/Fraternate/blob/42e61cab38d23a420ebbb1e98fb6da3cc2f076a1/models/User.js#L60-L92<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function signupEmail ( user ) { var port = process . env . MAIL_PORT var useremail = process . env . MAIL_USERNAME var passwords = process . env . MAIL_PASSWORD var host = process . env . MAIL_HOST var temp = { } 'use strict' ; var nodemailer = require ( 'nodemailer' ) ; // create reusable transporter object using the default SMTP transport var transporter = nodemailer . createTransport ( { host : host , tls : { rejectUnauthorized : false } , secure : false , // secure:true for port 465, secure:false for port 587 auth : { user : useremail , pass : passwords , } } ) ; var mailOptions = { from : user . username + ' ' + '<' + user . email + '>' , // sender address to : process . env . MAIL_USERNAME , // list of receivers subject : ' A user has edited their information '+  s tename + ' ',  /  Subject line html : '<h2>The following user has been edited.</h2><p>Code :</p> <pre>' + user + '</pre>' , } // send mail with defined transport object transporter . sendMail ( mailOptions , ( error , info ) => { if ( error ) { return console . log ( error ) ; } } ) ; }<CODESPLIT>0.15396329760551453<CODESPLIT>0.13157601654529572

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/joyent/node-ldapjs/blob/ad451edc18d7768c3ddee1a1dd472d2bbafdae5e/lib/messages/add_response.js#L12-L18<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function AddResponse ( options ) { options = options || { } ; assert . object ( options ) ; options . protocolOp = Protocol . LDAP_REP_ADD ; LDAPResult . call ( this , options ) ; }<CODESPLIT>0.15903665125370026<CODESPLIT>0.11348313093185425

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L21279-L21291<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getEffectiveDecoratorArgumentType ( node , argIndex ) { if ( argIndex === 0 ) { return getEffectiveDecoratorFirstArgumentType ( node . parent ) ; } else if ( argIndex === 1 ) { return getEffectiveDecoratorSecondArgumentType ( node . parent ) ; } else if ( argIndex === 2 ) { return getEffectiveDecoratorThirdArgumentType ( node . parent ) ; } ts . Debug . fail ( "Decorators should not have a fourth synthetic argument." ) ; return unknownType ; }<CODESPLIT>0.16962459683418274<CODESPLIT>0.14162229001522064

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/NoRedInk/find-elm-dependencies/blob/ccfa7b538d254b73728f8c1d4f5667fdbd175120/index.js#L47-L71<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function findAllDependencies ( file , knownDependencies , sourceDirectories , knownFiles ) { if ( ! knownDependencies ) { knownDependencies = [ ] ; } if ( typeof knownFiles === "undefined" ) { knownFiles = [ ] ; } else if ( knownFiles . indexOf ( file ) > - 1 ) { return knownDependencies ; } if ( sourceDirectories ) { return findAllDependenciesHelp ( file , knownDependencies , sourceDirectories , knownFiles ) . then ( function ( thing ) { return thing . knownDependencies ; } ) ; } else { return getBaseDir ( file ) . then ( getElmPackageSourceDirectories ) . then ( function ( newSourceDirs ) { return findAllDependenciesHelp ( file , knownDependencies , newSourceDirs , knownFiles ) . then ( function ( thing ) { return thing . knownDependencies ; } ) ; } ) ; } }<CODESPLIT>0.18091575801372528<CODESPLIT>0.13041099905967712

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/alvarotrigo/react-fullpage/blob/5a11fb5211e5706da81f2874516f023dc6e5aa88/example/dist/bundle.js#L8718-L8737<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function createDangerousStringForStyles ( styles ) { { var serialized = '' ; var delimiter = '' ; for ( var styleName in styles ) { if ( ! styles . hasOwnProperty ( styleName ) ) { continue ; } var styleValue = styles [ styleName ] ; if ( styleValue != null ) { var isCustomProperty = styleName . indexOf ( '--' ) === 0 ; serialized += delimiter + hyphenateStyleName ( styleName ) + ':' ; serialized += dangerousStyleValue ( styleName , styleValue , isCustomProperty ) ; delimiter = ';' ; } } return serialized || null ; } }<CODESPLIT>0.15877199172973633<CODESPLIT>0.14295171201229095

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/ashleydavis/alpha-vantage-cli/blob/e8cf7d9f0420b6ac8d318e657b01f1da826d70b2/build/cli.js#L99-L142<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function main ( ) { return __awaiter ( this , void 0 , void 0 , function ( ) { var outputDataSize , interval , dataFrame , dateFormat , api ; return __generator ( this , function ( _a ) { switch ( _a . label ) { case 0 : outputDataSize = "compact" ; if ( argv . outputDataSize ) { outputDataSize = argv . outputDataSize ; } interval = '60min' ; if ( argv . interval ) { interval = argv . interval ; } api = new index_1 . AlphaVantageAPI ( argv . apiKey , outputDataSize , argv . verbose ) ; if ( ! ( argv . type === 'daily' ) ) return [ 3 /*break*/ , 2 ] ; return [ 4 /*yield*/ , api . getDailyDataFrame ( argv . symbol ) ] ; case 1 : dataFrame = _a . sent ( ) ; dateFormat = 'YYYY-MM-DD' ; return [ 3 /*break*/ , 5 ] ; case 2 : if ( ! ( argv . type === 'intraday' ) ) return [ 3 /*break*/ , 4 ] ; return [ 4 /*yield*/ , api . getIntradayDataFrame ( argv . symbol , interval ) ] ; case 3 : dataFrame = _a . sent ( ) ; dateFormat = "YYYY-MM-DD HH:mm:ss" ; return [ 3 /*break*/ , 5 ] ; case 4 : throw new Error ( "Unexpected data type: " + argv . type + ", expected it to be either 'daily' or 'intrday'" ) ; case 5 : if ( ! argv . verbose ) { console . log ( '>> ' + argv . out ) ; } dataFrame . transformSeries ( { Timestamp : function ( t ) { return moment ( t ) . format ( dateFormat ) ; } , } ) . asCSV ( ) . writeFileSync ( argv . out ) ; return [ 2 /*return*/ ] ; } } ) ; } ) ; }<CODESPLIT>0.13695360720157623<CODESPLIT>0.1288594901561737

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/ProseMirror/prosemirror-test-builder/blob/bd55c5dea11aaefc1e398b91138fc323a8383c25/src/build.js#L61-L71<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function block ( type , attrs ) { let result = function ( ... args ) { let myAttrs = takeAttrs ( attrs , args ) let { nodes , tag } = flatten ( type . schema , args , id ) let node = type . create ( myAttrs , nodes ) if ( tag != noTag ) node . tag = tag return node } if ( type . isLeaf ) try { result . flat = [ type . create ( attrs ) ] } catch ( _ ) { } return result }<CODESPLIT>0.1589689403772354<CODESPLIT>0.1397959291934967

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/thehelp/cluster/blob/fef5a878bfb1bdebfe903127af9e85f0c4f4fe13/src/server/graceful_express.js#L39-L63<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function GracefulExpress ( options ) { options = options || { } ; this . server = null ; this . graceful = null ; var startFile = process . mainModule . filename ; this . _setOption ( 'inProcessTest' , options , / mocha$ / . test ( startFile ) ) ; this . reaperPollInterval = options . reaperPollInterval || 500 ; util . verifyType ( 'number' , this , 'reaperPollInterval' ) ; this . shuttingDown = false ; this . _serverClosed = false ; this . _responses = [ ] ; this . _sockets = [ ] ; this . _activeSockets = [ ] ; //both here for symmetry; unlikely that both of these are available on construction this . setGraceful ( options . graceful || Graceful . instance ) ; this . setServer ( options . server ) ; this . middleware = this . middleware . bind ( this ) ; }<CODESPLIT>0.1589069813489914<CODESPLIT>0.12273328006267548

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/icelab/draft-js-single-line-plugin/blob/cc52e52642c4a4451d2f47e7342e8952277dd2ab/lib/utils.js#L41-L75<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function condenseBlocks ( editorState , blocks , options ) { blocks = blocks || editorState . getCurrentContent ( ) . getBlocksAsArray ( ) ; var text = ( 0 , _immutable . List ) ( ) ; var characterList = ( 0 , _immutable . List ) ( ) ; // Gather all the text/characterList and concat them blocks . forEach ( function ( block ) { // Atomic blocks should be ignored (stripped) if ( block . getType ( ) !== 'atomic' ) { text = text . push ( replaceNewlines ( block . getText ( ) ) ) ; characterList = characterList . concat ( block . getCharacterList ( ) ) ; } } ) ; // Strip entities? if ( options . stripEntities ) { characterList = characterList . map ( stripEntityFromCharacterMetadata ) ; } // Create a new content block var contentBlock = new _draftJs . ContentBlock ( { key : ( 0 , _draftJs . genKey ) ( ) , text : text . join ( '' ) , type : 'unstyled' , characterList : characterList , depth : 0 } ) ; // Update the editor state with the compressed version var newContentState = _draftJs . ContentState . createFromBlockArray ( [ contentBlock ] ) ; // Create the new state as an undoable action editorState = _draftJs . EditorState . push ( editorState , newContentState , 'remove-range' ) ; // Move the selection to the end return _draftJs . EditorState . moveFocusToEnd ( editorState ) ; }<CODESPLIT>0.16464120149612427<CODESPLIT>0.13040275871753693

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/azproduction/lmd/blob/03410c36839728de683c697670e1b205dc8193ee/bin/lmd_builder.js#L596-L621<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function wipeLmdEvents ( ast ) { var itemsToWipe = [ 'lmd_on' , 'lmd_trigger' , 'lmd_events' ] ; return walker . with_walkers ( { // wipe lmdEvents variables "var" : function ( ) { if ( ! itemsToWipe . length ) { return ; } for ( var i = 0 , c = this [ 1 ] . length , varItem ; i < c ; i ++ ) { varItem = this [ 1 ] [ i ] ; if ( varItem ) { var itemIndex = itemsToWipe . indexOf ( varItem [ 0 ] ) ; if ( itemIndex !== - 1 ) { itemsToWipe . splice ( itemIndex , 1 ) ; this [ 1 ] . splice ( i , 1 ) ; i -- ; } } } } } , function ( ) { return walker . walk ( ast ) ; } ) ; }<CODESPLIT>0.16762207448482513<CODESPLIT>0.14914153516292572

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/rasmuserik/fri/blob/fb0ea7d7fd9be2e5915318d4ebb687cf48e86f1c/fri.js#L185-L206<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function updateSubscribers ( ) { lastUpdate = Date . now ( ) ; updateRequested = false ; var accessMap = new immutable . Map ( ) ; for ( var path of dirtyState ) { accessMap = setIn ( accessMap , path , true ) ; } dirtyState . clear ( ) ; for ( var subscriber of subscribers . values ( ) ) { var needsUpdate = false ; for ( path of subscriber . accessed ) { if ( accessMap . getIn ( path ) ) { needsUpdate = true ; break ; } } if ( needsUpdate ) { updateSubscriber ( subscriber ) ; } } }<CODESPLIT>0.160799041390419<CODESPLIT>0.11333610862493515

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/unifiedjs/unified-stream/blob/521fe081db71ad182af988832768fbe7dd2be1cb/index.js#L86-L145<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function pipe ( dest , options ) { var settings = options || { } var onend = once ( onended ) emitter . on ( 'data' , ondata ) emitter . on ( 'error' , onerror ) emitter . on ( 'end' , cleanup ) emitter . on ( 'close' , cleanup ) // If the `end` option is not supplied, `dest.end()` will be called when the // `end` or `close` events are received.  Only `dest.end()` once. if ( ! dest . _isStdio && settings . end !== false ) { emitter . on ( 'end' , onend ) } dest . on ( 'error' , onerror ) dest . on ( 'close' , cleanup ) dest . emit ( 'pipe' , emitter ) return dest // End destination. function onended ( ) { if ( dest . end ) { dest . end ( ) } } // Handle data. function ondata ( chunk ) { if ( dest . writable ) { dest . write ( chunk ) } } // Clean listeners. function cleanup ( ) { emitter . removeListener ( 'data' , ondata ) emitter . removeListener ( 'end' , onend ) emitter . removeListener ( 'error' , onerror ) emitter . removeListener ( 'end' , cleanup ) emitter . removeListener ( 'close' , cleanup ) dest . removeListener ( 'error' , onerror ) dest . removeListener ( 'close' , cleanup ) } // Close dangling pipes and handle unheard errors. function onerror ( err ) { var handlers = emitter . _events . error cleanup ( ) // Cannot use `listenerCount` in node <= 0.12. if ( ! handlers || handlers . length === 0 || handlers === onerror ) { throw err // Unhandled stream error in pipe. } } }<CODESPLIT>0.12865211069583893<CODESPLIT>0.141714408993721

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/superfly/fly/blob/8189991b6b345169bde2b265e21029d857189364/examples/http-cache/index.js#L33-L47<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>async function origin ( req , init ) { const url = new URL ( req . url ) switch ( url . pathname ) { case "/" : return new Response ( ` ${ new Date ( ) } ` , { headers : { "Cache-Control" : "max-age=600" } } ) case "/never-cache" : return new Response ( ` ${ new Date ( ) } ` ) } return new Response ( "not found" , { status : 404 } ) }<CODESPLIT>0.1424480527639389<CODESPLIT>0.1452241986989975

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/Quartz/Chartbuilder/blob/fc6ce64e73b9ef378223afcab7057020f6dce260/src/js/util/helper.js#L225-L251<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function suggest_tick_num ( domain ) { var MAX_TICKS = 10 ; var INTERVAL_BASE_VALS = [ 1 , 2 , 2.5 , 5 , 10 , 25 ] ; var range = Math . abs ( domain [ 0 ] - domain [ 1 ] ) var minimum = range / MAX_TICKS ; var digits = Math . floor ( range ) . toString ( ) . length ; var multiplier = Math . pow ( 10 , ( digits - 2 ) ) ; var acceptable_intervals = reduce ( INTERVAL_BASE_VALS , function ( prev , curr ) { var mult = curr * multiplier ; if ( mult >= minimum ) { prev = prev . concat ( [ mult ] ) ; } return prev ; } , [ ] ) ; for ( var i = 0 ; i < acceptable_intervals . length ; i ++ ) { var interval = acceptable_intervals [ i ] if ( range % interval == 0 ) { return ( range / interval ) + 1 } } ; return 11 ; }<CODESPLIT>0.14969009160995483<CODESPLIT>0.1405857354402542

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/lib/reflect.js#L753-L773<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( name ) { "use strict" ; var trap = this . getTrap ( "deleteProperty" ) ; if ( trap === undefined ) { // default forwarding behavior return Reflect . deleteProperty ( this . target , name ) ; } name = String ( name ) ; var res = trap . call ( this . handler , this . target , name ) ; res = ! ! res ; // coerce to Boolean if ( res === true ) { if ( isSealed ( name , this . target ) ) { throw new TypeError ( "property '" + name + "' is non-configurable " + "and can't be deleted" ) ; } } return res ; }<CODESPLIT>0.12426188588142395<CODESPLIT>0.1598132699728012

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/gavinhungry/pingy/blob/6043347be9c05a2adb8a853f9face425a97799b4/pingy.js#L179-L188<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( x , y ) { var i = this . _getIndex ( x , y ) ; return { r : this . _png . data [ i + 0 ] , g : this . _png . data [ i + 1 ] , b : this . _png . data [ i + 2 ] , a : this . _png . data [ i + 3 ] } ; }<CODESPLIT>0.16586841642856598<CODESPLIT>0.13999250531196594

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/sportngin/ngin_client_node/blob/dafed7f3b86e86b01f7d5fd707d4a8d608258fe9/src/sports/teamInstance.js#L18-L33<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function scopeUrl ( options , inst ) { options = _ . extend ( { } , inst , options ) if ( ! options . season_id && ! options . team_id && ! ( options . flight_stage_id && options . flight_id ) ) throw new Error ( 'flight_stage_id+flight_id, season_id and/or team_id required to make team instance api calls' ) if ( options . flight_stage_id && options . flight_id ) { var url = ngin . Flight . urlRoot ( ) + '/' + options . flight_id + '/flight_stages/' + options . flight_stage_id + '/teams' return options . team_id ? url + '/' + options . team_id : url } else if ( options . season_id ) { var url = ngin . Season . urlRoot ( ) + '/' + options . season_id + '/teams' return options . team_id ? url + '/' + options . team_id : url } else { return ngin . Team . urlRoot ( ) + '/' + options . team_id + ngin . TeamInstance . urlRoot ( ) } }<CODESPLIT>0.17249029874801636<CODESPLIT>0.13491779565811157

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/thx/crox/blob/4fcdea527f6e238e318184c4d080cb968b75894b/build/crox-all.js#L930-L1061<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function codegen_vm_tran ( prog ) { /// <param name="prog" type="Array">AST</param>  /// <returns type="String" />  //   function encodeId ( s ) { return '$crox_' + encodeCommonName ( s ) ; } function isName ( s ) { return / ^$\w+$ / . test ( s ) ; } function emit ( s ) { body += s ; } var i_each = 0 ; function stmtGen ( a ) { switch ( a [ 0 ] ) { case 'if' : emit ( '#if(' + exprGen ( a [ 1 ] ) + ')' ) ; stmtsGen ( a [ 2 ] ) ; if ( a [ 3 ] ) { emit ( '#{else}' ) ; stmtsGen ( a [ 3 ] ) ; } emit ( '#{end}' ) ; break ; case 'each' : ++ i_each ; var sExpr = exprGen ( a [ 1 ] ) ; if ( isName ( sExpr ) ) var listName = sExpr ; else { listName = '$list' + ( i_each == 1 ? '' : i_each ) ; emit ( '#set (' + listName + ' = ' + sExpr + ')' ) ; } if ( a [ 5 ] ) { //array  emit ( '#foreach(' + encodeId ( a [ 4 ] ) + ' in ' + listName + ')' ) ; if ( a [ 3 ] ) { emit ( '#set(' + encodeId ( a [ 3 ] ) + ' = $velocityCount - 1)' ) ; } } else { //object  if ( a [ 3 ] ) { emit ( '#foreach(' + encodeId ( a [ 3 ] ) + ' in ' + listName + '.keySet())' ) ; emit ( '#set(' + encodeId ( a [ 4 ] ) + ' =' + listName + '.get(' + encodeId ( a [ 3 ] ) + '))' ) ; } else { emit ( '#foreach(' + encodeId ( a [ 4 ] ) + ' in ' + listName + ')' ) ; } } stmtsGen ( a [ 2 ] ) ; emit ( '#{end}' ) ; -- i_each ; break ; case 'set' : emit ( '#set (' + encodeId ( a [ 1 ] ) + '=' + exprGen ( a [ 2 ] ) + ')' ) ; break ; case 'eval' : var s = exprGen ( a [ 1 ] ) ; if ( isName ( s ) ) emit ( '$!{' + s . slice ( 1 ) + '}' ) ; else { emit ( '#set($t = ' + s + ')$!{t}' ) ; } break ; case 'text' : emit ( a [ 1 ] . replace ( / \$ / g , '$${dollar}' ) . replace ( / # / g , '$${sharp}' ) ) ; break ; case 'inc' : emit ( "#parse('" + changeExt ( a [ 1 ] , 'vm' ) + "')" ) ; break ; default : throw Error ( 'unknown stmt: ' + a [ 0 ] ) ; } } function stmtsGen ( a ) { for ( var i = 0 ; i < a . length ; ++ i ) stmtGen ( a [ i ] ) ; } function exprToStr ( x , check ) { var t = exprGen ( x ) ; if ( check && ! check ( x [ 0 ] ) ) t = '(' + t + ')' ; return t ; } function exprGen ( x ) { switch ( x [ 0 ] ) { case 'id' : return encodeId ( x [ 1 ] ) ; case 'lit' : if ( typeof x [ 1 ] == 'string' ) return vmQuote ( x [ 1 ] ) ; return String ( x [ 1 ] ) ; case '.' : return exprToStr ( x [ 1 ] , isMember ) + '.' + x [ 2 ] ; case '[]' : return exprToStr ( x [ 1 ] , isMember ) + '[' + exprGen ( x [ 2 ] ) + ']' ; case '!' : return '!' + exprToStr ( x [ 1 ] , isUnary ) ; case 'u-' : if ( x [ 1 ] [ 0 ] == 'u-' ) throw Error ( "");    return '-' + exprToStr ( x [ 1 ] , isUnary ) ; case '*' : case '/' : case '%' : return exprToStr ( x [ 1 ] , isMul ) + x [ 0 ] + exprToStr ( x [ 2 ] , isUnary ) ; case '+' : case '-' : return exprToStr ( x [ 1 ] , isAdd ) + x [ 0 ] + ' ' + exprToStr ( x [ 2 ] , isMul ) ; case '<' : case '>' : case '<=' : case '>=' : return exprToStr ( x [ 1 ] , isRel ) + x [ 0 ] + exprToStr ( x [ 2 ] , isAdd ) ; case '==' : case '!=' : case '===' : case '!==' : return exprToStr ( x [ 1 ] , isEquality ) + x [ 0 ] . slice ( 0 , 2 ) + exprToStr ( x [ 2 ] , isRel ) ; case '&&' : return exprToStr ( x [ 1 ] , isLogicalAnd ) + '&&' + exprToStr ( x [ 2 ] , isEquality ) ; case '||' : return exprToStr ( x [ 1 ] , isLogicalOr ) + '||' + exprToStr ( x [ 2 ] , isLogicalAnd ) ; default : throw Error ( "unknown expr: " + x [ 0 ] ) ; } } function vmQuote ( s ) { /// <param name="s" type="String"></param>  if ( s . indexOf ( "'" ) == - 1 ) return "'" + s + "'" ; var a = s . split ( "'" ) ; return "('" + a . join ( "'+\"'\"+'" ) + "')" ; } var body = "#set($dollar='$')#set($sharp='#')" ; stmtsGen ( prog [ 1 ] ) ; return body ; }<CODESPLIT>0.14682240784168243<CODESPLIT>0.17344456911087036

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/elantion/SyncOSS/blob/c70644620c083e1db339430beb8bc1b4270beb0d/lib/oss.js#L214-L234<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( filePath ) { let standerPath = filePath . replace ( / \\ / g , '/' ) ; oss . deleteObject ( { Bucket : bucket . Name , Key : standerPath } , function ( err ) { if ( err ) { console . log ( 'error:' , err ) ; return err ; } let bucketIndex = bucketPaths . indexOf ( standerPath ) ; if ( bucketIndex !== - 1 ) { bucketPaths . splice ( bucketIndex , 1 ) ; } let localIndex = localPaths . indexOf ( standerPath ) ; if ( localIndex !== - 1 ) { localPaths . splice ( localIndex , 1 ) ; } console . log ( 'delete success:' + standerPath ) ; } ) ; }<CODESPLIT>0.12202625721693039<CODESPLIT>0.1542283445596695

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/pureqml/qmlcore/blob/21416cb4b45dce6cf6c603dfa43d6683e0d48638/platform/video.videojs/dist/video.es.js#L14150-L14163<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function DescriptionsButton ( player , options , ready ) { classCallCheck ( this , DescriptionsButton ) ; var _this = possibleConstructorReturn ( this , _TextTrackButton . call ( this , player , options , ready ) ) ; var tracks = player . textTracks ( ) ; var changeHandler = bind ( _this , _this . handleTracksChange ) ; tracks . addEventListener ( 'change' , changeHandler ) ; _this . on ( 'dispose' , function ( ) { tracks . removeEventListener ( 'change' , changeHandler ) ; } ) ; return _this ; }<CODESPLIT>0.15898022055625916<CODESPLIT>0.119989313185215

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/phonegap/phonegap-plugin-contentsync/blob/2e4a40732fc444185033cfa711f0bd779413cbcf/www/index.js#L227-L230<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( url , headers , cb ) { var callback = ( typeof headers == "function" ? headers : cb ) ; exec ( callback , callback , 'Sync' , 'download' , [ url , null , headers ] ) ; }<CODESPLIT>0.13385525345802307<CODESPLIT>0.15449471771717072

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/pureqml/qmlcore/blob/21416cb4b45dce6cf6c603dfa43d6683e0d48638/platform/video.videojs/dist/video.es.js#L15233-L15240<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ErrorDisplay ( player , options ) { classCallCheck ( this , ErrorDisplay ) ; var _this = possibleConstructorReturn ( this , _ModalDialog . call ( this , player , options ) ) ; _this . on ( player , 'error' , _this . open ) ; return _this ; }<CODESPLIT>0.16315893828868866<CODESPLIT>0.12089069187641144

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/four43/node-crisp-cache/blob/716f55d62b946a950d036a93d84010178f0df6be/main.js#L648-L653<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function bindEventMap ( eventMap , eventEmitter ) { var eventNames = Object . keys ( eventMap ) ; eventNames . map ( function ( eventName ) { eventEmitter . on ( eventName , eventMap [ eventName ] ) ; } ) ; }<CODESPLIT>0.1142755076289177<CODESPLIT>0.15996737778186798

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/superfly/fly/blob/8189991b6b345169bde2b265e21029d857189364/examples/graphql-stitching/fly-backend/index.js#L151-L161<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getSentiment ( response ) { const issuesToEvaluate = response . repository . issues . edges ; for ( let i = issuesToEvaluate . length - 1 ; i >= 0 ; i -- ) { let sent = polarity ( ( issuesToEvaluate [ i ] . node . title + " " + issuesToEvaluate [ i ] . node . bodyText ) . split ( " " ) ) ; issuesToEvaluate [ i ] . node . sentiment = sent ; } ; return response ; }<CODESPLIT>0.1522650420665741<CODESPLIT>0.136391744017601

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/z-classic/zclassicjs/blob/5a399fd799a300cfda0d53bd7fdccca7523022e0/lib/transaction.js#L282-L303<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getScriptSignature ( privKey , signingTx , hashcode ) { // Buffer var _buf16 = Buffer . alloc ( 4 ) ; _buf16 . writeUInt16LE ( hashcode , 0 ) ; var signingTxHex = serializeTx ( signingTx ) ; var signingTxWithHashcode = signingTxHex + _buf16 . toString ( 'hex' ) ; // Sha256 it twice, according to spec var msg = zcrypto . sha256x2 ( Buffer . from ( signingTxWithHashcode , 'hex' ) ) ; // Signing it var rawsig = secp256k1 . sign ( Buffer . from ( msg , 'hex' ) , Buffer . from ( privKey , 'hex' ) , { canonical : true } ) ; // Convert it to DER format // Appending 01 to it cause // ScriptSig = <varint of total sig length> <SIG from code, including appended 01 SIGNHASH> <length of pubkey (0x21 or 0x41)> <pubkey> // https://bitcoin.stackexchange.com/a/36481 var signatureDER = Buffer . from ( rawsig . toDER ( ) ) . toString ( 'hex' ) + '01' ; return signatureDER ; }<CODESPLIT>0.1478704810142517<CODESPLIT>0.1499353051185608

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/tzeskimo/mocha-fibers/blob/af4fc85f3db977784d80a5f52ff7b6cb5cae3634/lib/mocha-fibers.js#L14-L36<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function fiberize ( fn ) { return function ( done ) { var self = this ; Fiber ( function ( ) { try { if ( fn . length == 1 ) { fn . call ( self , done ) ; } else { fn . call ( self ) ; done ( ) ; } } catch ( e ) { process . nextTick ( function ( ) { throw ( e ) ; } ) ; } } ) . run ( ) ; } ; }<CODESPLIT>0.14870594441890717<CODESPLIT>0.13233156502246857

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L3380-L3395<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( key ) { // don't use ES6 "delete" because it will be annoying // to use in browsers that are not ES6 friendly; var keys = this . keys , values = this . values , guid = guidFor ( key ) ; if ( values . hasOwnProperty ( guid ) ) { keys . remove ( key ) ; delete values [ guid ] ; set ( this , 'length' , keys . list . length ) ; return true ; } else { return false ; } }<CODESPLIT>0.1724163442850113<CODESPLIT>0.14139039814472198

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/dfkaye/jasmine-where/blob/96e9bda5bcba91420a2e4a20cb8c1fdc89586ba8/jasmine-where.js#L251-L258<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function convertNumerics ( row ) { for ( var t , i = 0 ; i < row . length ; i += 1 ) { t = parseFloat ( row [ i ] . replace ( / \'|\"|\, / g , '' ) ) ; isNaN ( t ) || ( row [ i ] = t ) ; } }<CODESPLIT>0.14874973893165588<CODESPLIT>0.14559414982795715

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/wavesoft/gulp-jbb-profile/blob/3e9bc0ca733ae0325a09a461f504fc847e256f7a/index.js#L50-L74<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function streamMode ( contents , options , callback ) { toArray ( contents , function ( err , chunks ) { if ( err ) { callback ( err ) ; return ; } bufferMode ( Buffer . concat ( chunks ) , options , function ( err , encBuf , decBuf ) { if ( err ) { callback ( err ) ; return ; } var encStream = new Readable ( ) ; encStream . push ( encBuf ) ; encStream . push ( null ) ; var decStream = new Readable ( ) ; decStream . push ( decBuf ) ; decStream . push ( null ) ; // Callback streams callback ( null , encStream , decStream ) ; } ) ; } ) ; }<CODESPLIT>0.15554192662239075<CODESPLIT>0.11989251524209976

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/moxiecode/moxie/blob/09eaf578f38480dc4b8e2017c473c496883b6168/src/javascript/core/utils/Basic.js#L482-L505<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function sprintf ( str ) { var args = [ ] . slice . call ( arguments , 1 ) ; return str . replace ( / %([a-z]) / g , function ( $0 , $1 ) { var value = args . shift ( ) ; switch ( $1 ) { case 's' : return value + '' ; case 'd' : return parseInt ( value , 10 ) ; case 'f' : return parseFloat ( value ) ; case 'c' : return '' ; default : return value ; } } ) ; }<CODESPLIT>0.15897136926651<CODESPLIT>0.1429671198129654

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/hapjs/action-sheet/blob/5d8bd05d8f69a1e2ab5ddd399c69bffb1c86b358/lib/tethys.js#L140-L153<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( key , value ) { var format = function ( key ) { return key . replace ( / (-([a-z])) / g , function ( s , s1 , s2 ) { return s2 . toUpperCase ( ) ; } ) ; } ; return keyValue . call ( this , arguments , function ( el ) { return el . style [ format ( key ) ] ; } , function ( el , key , attrs ) { el . style [ format ( key ) ] = attrs [ key ] + '' ; } ) ; }<CODESPLIT>0.14173690974712372<CODESPLIT>0.1619187295436859

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/logiclogue/seeded-random-node/blob/495af2634dcdde38c7a1adbf7962533e752b964f/js/Command.js#L11-L24<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( ) { // Defines all the commands with commander. program . version ( env . version ) . description ( 'Tool for generating random numbers from a seed' ) . option ( '-s, --seed <seed>' , 'specify the seed' , Math . random ( ) ) . option ( '-d, --decimal' , 'generates a random decimal number' , false ) . option ( '-r, --range <a>,<b>' , 'generates a random integer in the range inclusive' , this . range ) . parse ( process . argv ) ; // Calls the method that will check the commands // the user has entered. this . switchFunction ( ) ; }<CODESPLIT>0.17438550293445587<CODESPLIT>0.12488923221826553

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/hbouvier/node-tts/blob/6b49053bb7f667681d526dc21d5d6b71f3bf644d/swagger-ui/lib/shred.bundle.js#L989-L1003<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( timeout ) { var request = this , milliseconds = 0 ; ; if ( ! timeout ) return this ; if ( typeof timeout === "number" ) { milliseconds = timeout ; } else { milliseconds = ( timeout . milliseconds || 0 ) + ( 1000 * ( ( timeout . seconds || 0 ) + ( 60 * ( ( timeout . minutes || 0 ) + ( 60 * ( timeout . hours || 0 ) ) ) ) ) ) ; } this . _timeout = milliseconds ; return this ; }<CODESPLIT>0.15478594601154327<CODESPLIT>0.11384208500385284

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/fasttime/eslint-plugin-fasttime-rules/blob/57580844e4c88cb1353581a3b7281983793039aa/lib/nice-space-before-function-paren.js#L43-L59<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getConfigForFunction ( node ) { if ( isNamedFunction ( node ) ) return 'never' ; if ( node . type === 'ArrowFunctionExpression' ) { // Always ignore non-async functions and arrow functions without parens, e.g. // `async foo => bar`. if ( ! node . async || ! astUtils . isOpeningParenToken ( sourceCode . getFirstToken ( node , { skip : 1 } ) ) ) return 'ignore' ; } return 'always' ; }<CODESPLIT>0.16810739040374756<CODESPLIT>0.1306605190038681

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/shepherdwind/velocity.js/blob/1fa2b459d1fff5c897a0671ed9797c5603505d88/src/compile/references.js#L153-L173<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( ast ) { var id = ast . id ; var local = this . local ; var ret = false ; var isLocaled = utils . some ( this . conditions , function ( contextId ) { var _local = local [ contextId ] ; if ( id in _local ) { ret = _local [ id ] ; return true ; } return false ; } , this ) ; return { value : ret , isLocaled : isLocaled } ; }<CODESPLIT>0.15537326037883759<CODESPLIT>0.14260827004909515

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/pb82/MissMatch/blob/13153714c2e4b7fd613c3309131806cfb32ea39f/lib/MissMatch.js#L473-L492<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function bind ( n , p , v ) { var m = p ( v ) ; if ( m . result ) { // Throw an exception if the same name is bound multiple times.  if ( bindingContext . hasOwnProperty ( n ) ) { throw "Name '" + n + "' is already used in another binding." ; } bindingContext [ n ] = m . obj ? m . obj [ m . param ] : m . param ; } /**      * When the rest of an array is matched, the binding value has to      * be changed after executing bind. Thats because at bind time the      * rest of the array is not known. Therefore the name of the last      * binding is stored and can be retrieved in the continuing function.      */ m . this_binding = n ; return m ; }<CODESPLIT>0.15679430961608887<CODESPLIT>0.1439335197210312

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/pureqml/qmlcore/blob/21416cb4b45dce6cf6c603dfa43d6683e0d48638/platform/video.videojs/dist/video.es.js#L11795-L11806<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ProgressControl ( player , options ) { classCallCheck ( this , ProgressControl ) ; var _this = possibleConstructorReturn ( this , _Component . call ( this , player , options ) ) ; _this . handleMouseMove = throttle ( bind ( _this , _this . handleMouseMove ) , 25 ) ; _this . on ( _this . el_ , 'mousemove' , _this . handleMouseMove ) ; _this . throttledHandleMouseSeek = throttle ( bind ( _this , _this . handleMouseSeek ) , 25 ) ; _this . on ( [ 'mousedown' , 'touchstart' ] , _this . handleMouseDown ) ; return _this ; }<CODESPLIT>0.15548646450042725<CODESPLIT>0.11812608689069748

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L2876-L2901<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function computeLineStarts ( text ) { var result = new Array ( ) ; var pos = 0 ; var lineStart = 0 ; while ( pos < text . length ) { var ch = text . charCodeAt ( pos ++ ) ; switch ( ch ) { case 13 /* carriageReturn */ : if ( text . charCodeAt ( pos ) === 10 /* lineFeed */ ) { pos ++ ; } case 10 /* lineFeed */ : result . push ( lineStart ) ; lineStart = pos ; break ; default : if ( ch > 127 /* maxAsciiCharacter */ && isLineBreak ( ch ) ) { result . push ( lineStart ) ; lineStart = pos ; } break ; } } result . push ( lineStart ) ; return result ; }<CODESPLIT>0.15640492737293243<CODESPLIT>0.12913399934768677

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/dom/Element.style.js#L932-L947<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( className ) { //<debug warn> Ext . Logger . deprecate ( "Ext.dom.Element.radioCls() is deprecated" , this ) ; //</debug> var cn = this . dom . parentNode . childNodes , v ; className = Ext . isArray ( className ) ? className : [ className ] ; for ( var i = 0 , len = cn . length ; i < len ; i ++ ) { v = cn [ i ] ; if ( v && v . nodeType == 1 ) { Ext . fly ( v , '_internal' ) . removeCls ( className ) ; } } return this . addCls ( className ) ; }<CODESPLIT>0.13061337172985077<CODESPLIT>0.17119020223617554

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/alexiusacademia/electron-db/blob/630ac39969e27d68bd85eb048f99e0d2b64fd67b/index.js#L82-L101<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function valid ( ) { var fName = '' if ( arguments . length == 2 ) { // Given the database name and location const dbName = arguments [ 0 ] const dbLocation = arguments [ 1 ] var fName = path . join ( dbLocation , dbName + '.json' ) } else if ( arguments . length == 1 ) { const dbName = arguments [ 0 ] fname = path . join ( userData , dbName + '.json' ) } const content = fs . readFileSync ( fName , 'utf-8' ) try { JSON . parse ( content ) } catch ( e ) { return false } return true }<CODESPLIT>0.1623978167772293<CODESPLIT>0.14248892664909363

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/mobilehero-archive/aplus-node/blob/a16e11722406eb42f7b9e182c1301ffe2b706b67/resolver/path.js#L88-L134<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function normalizeStringPosix ( path , allowAboveRoot ) { var res = '' ; var lastSlash = - 1 ; var dots = 0 ; var code ; for ( var i = 0 ; i <= path . length ; ++ i ) { if ( i < path . length ) code = path . charCodeAt ( i ) ; else if ( code === 47 /*/*/ ) break ; else code = 47 /*/*/ ; if ( code === 47 /*/*/ ) { if ( lastSlash === i - 1 || dots === 1 ) { // NOOP } else if ( lastSlash !== i - 1 && dots === 2 ) { if ( res . length < 2 || res . charCodeAt ( res . length - 1 ) !== 46 /*.*/ || res . charCodeAt ( res . length - 2 ) !== 46 /*.*/ ) { if ( res . length > 2 ) { var start = res . length - 1 ; var j = start ; for ( ; j >= 0 ; -- j ) { if ( res . charCodeAt ( j ) === 47 /*/*/ ) break ; } if ( j !== start ) { if ( j === - 1 ) res = '' ; else res = res . slice ( 0 , j ) ; lastSlash = i ; dots = 0 ; continue ; } } else if ( res . length === 2 || res . length === 1 ) { res = '' ; lastSlash = i ; dots = 0 ; continue ; } } if ( allowAboveRoot ) { if ( res . length > 0 ) res += '/..' ; else res = '..' ; } } else { if ( res . length > 0 ) res += '/' + path . slice ( lastSlash + 1 , i ) ; else res = path . slice ( lastSlash + 1 , i ) ; } lastSlash = i ; dots = 0 ; } else if ( code === 46 /*.*/ && dots !== - 1 ) { ++ dots ; } else { dots = - 1 ; } } return res ; }<CODESPLIT>0.17825137078762054<CODESPLIT>0.14167052507400513

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/tencentyun/cos-js-sdk-v5/blob/fe74e2df5191d075483d9abb8a18c9426924f28f/src/util.js#L160-L165<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( blob , callback ) { readAsBinaryString ( blob , function ( content ) { var hash = md5 ( content , true ) ; callback ( null , hash ) ; } ) ; }<CODESPLIT>0.140974760055542<CODESPLIT>0.14441746473312378

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/arizonatribe/utilitarian/blob/3472a16265d0810eb2873e80211199a83825d230/src/obj.util.js#L85-L108<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function toURI ( obj , dontEncode ) { const arr = [ ] ; let paramVal ; if ( isObject ( obj ) && ! isArray ( obj ) ) { Object . keys ( obj ) . forEach ( ( val ) => { if ( isArray ( obj [ val ] ) ) { paramVal = ` ${ obj [ val ] . join ( ',' ) } ` ; } else { paramVal = obj [ val ] ; } if ( dontEncode ) { arr . push ( ` ${ val } ${ paramVal } ` ) ; } else { arr . push ( ` ${ encodeURIComponent ( val ) } ${ encodeURIComponent ( paramVal ) } ` ) ; } } ) ; } return arr . join ( '&' ) ; }<CODESPLIT>0.15426446497440338<CODESPLIT>0.14148055016994476

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/benkeen/d3pie/blob/24b488a4f44226c407186c007365ab775f92a426/website/pages/about/aboutPage.js#L26-L55<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( msg ) { if ( ! _firstPageLoaded ) { _firstPage = msg . data . page ; _firstPageLoaded = true ; if ( _firstPage === "about" ) { setTimeout ( function ( ) { _renderContent ( ) ; var width = $ ( window ) . width ( ) ; var breakPointIndex = null ; for ( var i = 0 ; i < C . OTHER . BREAKPOINTS . length ; i ++ ) { if ( width >= C . OTHER . BREAKPOINTS [ i ] ) { breakPointIndex = i ; } } if ( breakPointIndex === null ) { _handleViewport ( "small" ) ; } } , 10 ) ; } return ; } if ( msg . data . page === "about" ) { if ( ! _isRendered ) { _renderContent ( ) ; } $ ( "#aboutPageSlides" ) . slidesjs ( "refresh" ) ; } }<CODESPLIT>0.15916794538497925<CODESPLIT>0.15269719064235687

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/mrlannigan/node-akamai/blob/ccffb1c439293bd98a9f3d90b15c800ddf29338e/lib/purge.js#L105-L121<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( ) { // Apply the modifier to the current `options` options = lodash . assign ( options , modifier ) ; // Create new wrapper function. var AkamaiPurgeChain = function AkamaiPurgeChain ( username , password , objects ) { return AkamaiPurge ( username , password , objects , options ) ; } ; // Apply new modifiers to given wrapper function applyModifiers ( AkamaiPurgeChain , options ) ; // Expose current `options` AkamaiPurgeChain . options = options ; return AkamaiPurgeChain ; }<CODESPLIT>0.12261909991502762<CODESPLIT>0.13771399855613708

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/GitbookIO/repofs/blob/24f9880f3abb5aae4e4be56d0e88ba9d214447be/src/utils/file.js#L119-L124<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function exists ( repoState , filepath ) { const workingState = repoState . getCurrentState ( ) ; const mergedFileSet = WorkingUtils . getMergedTreeEntries ( workingState ) ; return mergedFileSet . has ( filepath ) ; }<CODESPLIT>0.17838801443576813<CODESPLIT>0.1352241486310959

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/zhs007/dsl-core/blob/d97ac3a498cb0a51b165a4ea970db66294e0b8d4/lib/sql.js#L11-L182<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function exportTable ( obj , callback , root ) { if ( obj . type == 'struct' ) { var isautoinc = false ; var autoincval = 1 ; var str = "-- " + obj . comment + '\r\n' ; str += "CREATE TABLE IF NOT EXISTS `" + getTableName ( obj . name ) + "` (" + '\r\n' ; var lastcomment = '' ; var lstmember = [ ] ; base . forEachStruct ( obj . name , obj , root , function ( structname , memberobj , root ) { lstmember . push ( memberobj ) ; } ) ; var validindex = [ ] ; for ( var i = 0 ; i < lstmember . length ; ++ i ) { var membername = lstmember [ i ] . name . name ; // type var t = base . getRealType_Enum ( lstmember [ i ] . type , root ) ; if ( t == '[ERR]' ) { callback ( false , 'struct ' + obj . name + '.' + membername + ': type is Error!' ) ; return ; } else if ( t == 'int' ) { validindex . push ( i ) ; } else if ( t == 'string' ) { validindex . push ( i ) ; } else if ( t == 'time' ) { validindex . push ( i ) ; } else if ( base . isStruct ( t , root ) ) { } else { callback ( false , 'struct ' + obj . name + '.' + membername + ': type not defined!' ) ; return ; } } var keyblocknums = 0 ; // PRIMARY & INDEX for ( var i = 0 ; i < lstmember . length ; ++ i ) { if ( lstmember [ i ] . hasOwnProperty ( 'type2' ) ) { var membername = lstmember [ i ] . name . name ; var fn = base . getMemberName ( membername ) ; if ( lstmember [ i ] . type2 == 'primary' ) { keyblocknums ++ ; } else if ( lstmember [ i ] . type2 == 'primary0' || lstmember [ i ] . type2 == 'primary1' || lstmember [ i ] . type2 == 'index' ) { keyblocknums ++ ; } if ( lstmember [ i ] . type2 == 'unique' ) { keyblocknums ++ ; } } } var tarr = [ [ ] , [ ] ] ; for ( var k = 0 ; k < validindex . length ; ++ k ) { var i = validindex [ k ] ; var membername = lstmember [ i ] . name . name ; var fn = base . getMemberName ( membername ) ; // name var cstr = "`" + fn + "` " ; // type var t = base . getRealType_Enum ( lstmember [ i ] . type , root ) ; if ( t == '[ERR]' ) { callback ( false , 'struct ' + obj . name + '.' + membername + ': type is Error!' ) ; return ; } else if ( t == 'int' ) { cstr += "int " ; } else if ( t == 'string' ) { cstr += "varchar " ; } else if ( t == 'time' ) { cstr += "timestamp " ; } else { callback ( false , 'struct ' + obj . name + '.' + membername + ': type not defined!' ) ; return ; } // NULL if ( typeof ( lstmember [ i ] . val ) == 'object' && lstmember [ i ] . val . type == 'NULL' ) { cstr += 'NULL' ; } else { cstr += 'NOT NULL' ; } // AUTO_INCREMENT if ( typeof ( lstmember [ i ] . val ) == 'object' && lstmember [ i ] . val . val == 'AUTOINC' ) { cstr += ' AUTO_INCREMENT' ; isautoinc = true ; if ( lstmember [ i ] . val . hasOwnProperty ( 'autoinc' ) ) { autoincval = lstmember [ i ] . val . autoinc ; } } // DEFAULT CURRENT_TIMESTAMP else if ( typeof ( lstmember [ i ] . val ) == 'object' && lstmember [ i ] . val . val == 'NOW' ) { cstr += ' DEFAULT CURRENT_TIMESTAMP' ; } if ( k < validindex . length - 1 || keyblocknums > 0 ) { cstr += ',' ; } tarr [ 0 ] . push ( cstr ) ; tarr [ 1 ] . push ( '-- ' + lstmember [ i ] . comment ) ; } str += code . alignCode ( tarr , '  ' ) ; // PRIMARY & INDEX if ( keyblocknums > 0 ) { for ( var i = 0 ; i < lstmember . length ; ++ i ) { if ( lstmember [ i ] . hasOwnProperty ( 'type2' ) ) { var membername = lstmember [ i ] . name . name ; var fn = base . getMemberName ( membername ) ; var newline = false ; if ( lstmember [ i ] . type2 == 'primary' ) { str += "  PRIMARY KEY (`" + fn + "`)" ; newline = true ; } else if ( lstmember [ i ] . type2 == 'primary0' || lstmember [ i ] . type2 == 'primary1' || lstmember [ i ] . type2 == 'index' ) { str += "  KEY (`" + fn + "`)" ; newline = true ; } if ( lstmember [ i ] . type2 == 'unique' ) { str += "  UNIQUE (`" + fn + "`)" ; newline = true ; } if ( newline ) { keyblocknums -- ; if ( keyblocknums > 0 ) { str += ',\r\n' ; } else { str += '\r\n' ; } } } } } str += ") ENGINE=InnoDB DEFAULT CHARSET=utf8" ; if ( isautoinc ) { str += ' AUTO_INCREMENT=' + autoincval ; } str += ';\r\n' ; return str ; } }<CODESPLIT>0.16222567856311798<CODESPLIT>0.13740675151348114

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/emmetio/codemirror-plugin/blob/2089c8b15b97858b82b33e6e81ee1b50954581c1/lib/model/index.js#L28-L36<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getSyntax ( editor ) { const mode = editor . getMode ( ) ; if ( mode . name === 'htmlmixed' ) { return 'html' ; } return mode . name === 'xml' ? mode . configuration : mode . name ; }<CODESPLIT>0.17676497995853424<CODESPLIT>0.13536225259304047

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L13169-L13215<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function findHighestListElementThatStartsAtPosition ( position ) { // Clear out any cached state about the last node we found. currentArray = undefined ; currentArrayIndex = - 1 /* Value */ ; current = undefined ; // Recurse into the source file to find the highest node at this position. forEachChild ( sourceFile , visitNode , visitArray ) ; return ; function visitNode ( node ) { if ( position >= node . pos && position < node . end ) { // Position was within this node.  Keep searching deeper to find the node. forEachChild ( node , visitNode , visitArray ) ; // don't procede any futher in the search. return true ; } // position wasn't in this node, have to keep searching. return false ; } function visitArray ( array ) { if ( position >= array . pos && position < array . end ) { // position was in this array.  Search through this array to see if we find a // viable element. for ( var i = 0 , n = array . length ; i < n ; i ++ ) { var child = array [ i ] ; if ( child ) { if ( child . pos === position ) { // Found the right node.  We're done. currentArray = array ; currentArrayIndex = i ; current = child ; return true ; } else { if ( child . pos < position && position < child . end ) { // Position in somewhere within this child.  Search in it and // stop searching in this array. forEachChild ( child , visitNode , visitArray ) ; return true ; } } } } } // position wasn't in this array, have to keep searching. return false ; } }<CODESPLIT>0.17008456587791443<CODESPLIT>0.13700751960277557

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/data/NodeInterface.js#L544-L557<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( newId , deep ) { var me = this , result = me . callOverridden ( arguments ) , len = me . childNodes ? me . childNodes . length : 0 , i ; // Move child nodes across to the copy if required if ( deep ) { for ( i = 0 ; i < len ; i ++ ) { result . appendChild ( me . childNodes [ i ] . copy ( true ) ) ; } } return result ; }<CODESPLIT>0.15096037089824677<CODESPLIT>0.14791233837604523

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L42315-L42350<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function matcher ( pattern , opts ) { // pattern is a function if ( typeof pattern === 'function' ) { return pattern ; } // pattern is a regex if ( pattern instanceof RegExp ) { return function ( fp ) { return pattern . test ( fp ) ; } ; } if ( typeof pattern !== 'string' ) { throw new TypeError ( msg ( 'matcher' , 'pattern' , 'a string, regex, or function' ) ) ; } // strings, all the way down... pattern = utils . unixify ( pattern , opts ) ; // pattern is a non-glob string if ( ! utils . isGlob ( pattern ) ) { return utils . matchPath ( pattern , opts ) ; } // pattern is a glob string var re = makeRe ( pattern , opts ) ; // `matchBase` is defined if ( opts && opts . matchBase ) { return utils . hasFilename ( re , opts ) ; } // `matchBase` is not defined return function ( fp ) { fp = utils . unixify ( fp , opts ) ; return re . test ( fp ) ; } ; }<CODESPLIT>0.16032449901103973<CODESPLIT>0.12808333337306976

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/mastilver/sails-hook-parametized-policies/blob/cb3da8f7d4c4a5e92e8d76f0faa806924ca4f94d/index.js#L37-L56<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function parsePolicies ( input ) { var type = typeof input ; if ( type === 'object' ) { for ( var i in input ) { input [ i ] = this . parsePolicies ( input [ i ] ) ; } return input ; } if ( type === 'string' ) { var parsedString = esprima . parse ( input ) . body [ 0 ] . expression ; return this . parseEsprima ( parsedString ) ; } return input ; }<CODESPLIT>0.15663759410381317<CODESPLIT>0.12294811010360718

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/views/Card/CardGroup.js#L21-L72<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function CardGroup ( props ) { const { centered , children , className , content , doubling , items , itemsPerRow , stackable , textAlign , } = props const classes = cx ( 'ui' , useKeyOnly ( centered , 'centered' ) , useKeyOnly ( doubling , 'doubling' ) , useKeyOnly ( stackable , 'stackable' ) , useTextAlignProp ( textAlign ) , useWidthProp ( itemsPerRow ) , 'cards' , className , ) const rest = getUnhandledProps ( CardGroup , props ) const ElementType = getElementType ( CardGroup , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } >           { children }         < / ElementType > ) } if ( ! childrenUtils . isNil ( content ) ) { return ( < ElementType { ... rest } className = { classes } >           { content }         < / ElementType > ) } const itemsJSX = _ . map ( items , ( item ) => { const key = item . key || [ item . header , item . description ] . join ( '-' ) return < Card key = { key } { ... item } / > } ) return ( < ElementType { ... rest } className = { classes } >         { itemsJSX }       < / ElementType > ) }<CODESPLIT>0.16613057255744934<CODESPLIT>0.1523059606552124

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/datastax/nodejs-driver/blob/6766188870f7099aeb393719820245b69d789d23/lib/metadata/schema-parser.js#L1157-L1181<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function pruneStaticCompactTableColumns ( tableInfo ) { let i ; let c ; //remove "column1 text" clustering column for ( i = 0 ; i < tableInfo . clusteringKeys . length ; i ++ ) { c = tableInfo . clusteringKeys [ i ] ; const index = tableInfo . columns . indexOf ( c ) ; tableInfo . columns . splice ( index , 1 ) ; delete tableInfo . columnsByName [ c . name ] ; } tableInfo . clusteringKeys = utils . emptyArray ; tableInfo . clusteringOrder = utils . emptyArray ; //remove regular columns and set the static columns to non-static i = tableInfo . columns . length ; while ( i -- ) { c = tableInfo . columns [ i ] ; if ( ! c . isStatic && tableInfo . partitionKeys . indexOf ( c ) === - 1 ) { // remove "value blob" regular column tableInfo . columns . splice ( i , 1 ) ; delete tableInfo . columnsByName [ c . name ] ; continue ; } c . isStatic = false ; } }<CODESPLIT>0.15720313787460327<CODESPLIT>0.14673876762390137

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/typhonjs-node-esdoc/esdoc-plugin-dependency-graphs/blob/af2d9cabce2d48edd4ad7ed81c722cc27efacb67/template/html/jquery-tablesorter.js#L2316-L2327<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( table , $tb , getIt ) { table = $ ( table ) [ 0 ] ; if ( getIt ) { table . isProcessing = true ; $tb . before ( '<colgroup class="tablesorter-savemyplace"/>' ) ; return $ . fn . detach ? $tb . detach ( ) : $tb . remove ( ) ; } var holdr = $ ( table ) . find ( 'colgroup.tablesorter-savemyplace' ) ; $tb . insertAfter ( holdr ) ; holdr . remove ( ) ; table . isProcessing = false ; }<CODESPLIT>0.16923366487026215<CODESPLIT>0.13666479289531708

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/GitbookIO/repofs/blob/24f9880f3abb5aae4e4be56d0e88ba9d214447be/src/utils/file.js#L205-L230<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function hasChanged ( previousState , newState , filepath ) { const previouslyExists = exists ( previousState , filepath ) ; const newExists = exists ( newState , filepath ) ; if ( ! previouslyExists && ! newExists ) { // Still non existing return false ; } else if ( exists ( previousState , filepath ) !== exists ( newState , filepath ) ) { // The file is absent from one return true ; } else { // Both files exist const prevWorking = previousState . getCurrentState ( ) ; const newWorking = newState . getCurrentState ( ) ; const prevSha = WorkingUtils . findSha ( prevWorking , filepath ) ; const newSha = WorkingUtils . findSha ( newWorking , filepath ) ; if ( prevSha === null && newSha === null ) { // Both have are in pending changes. We can compare their contents return read ( previousState , filepath ) . getAsString ( ) !== read ( newState , filepath ) . getAsString ( ) ; } else { // Content changed if Shas are different, or one of them is null return prevSha !== newSha ; } } }<CODESPLIT>0.12442733347415924<CODESPLIT>0.16855986416339874

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/direct/RemotingProvider.js#L505-L517<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( transaction ) { var me = this ; Ext . Ajax . request ( { url : me . getUrl ( ) , params : transaction . params , callback : me . onData , scope : me , form : transaction . form , isUpload : transaction . isUpload , transaction : transaction } ) ; }<CODESPLIT>0.1415511965751648<CODESPLIT>0.16993162035942078

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/mapbox/pbf/blob/e26454842595c3eae1f5f8281bba508fbd85b718/index.js#L130-L136<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( arr , isSigned ) { if ( this . type !== Pbf . Bytes ) return arr . push ( this . readVarint ( isSigned ) ) ; var end = readPackedEnd ( this ) ; arr = arr || [ ] ; while ( this . pos < end ) arr . push ( this . readVarint ( isSigned ) ) ; return arr ; }<CODESPLIT>0.1494745910167694<CODESPLIT>0.13607586920261383

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/out.js#L2-L12<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function cleanerEval$624 ( str$629 , oldConsole$630 ) { var logArr$631 = [ ] ; var console$632 = { log : function ( msg$633 ) { logArr$631 . push ( msg$633 ) ; oldConsole$630 . log ( msg$633 ) ; } } ; eval ( str$629 ) ; return logArr$631 ; }<CODESPLIT>0.137493297457695<CODESPLIT>0.13683120906352997

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/jub3i/node-net-stat/blob/576192fbf95c7f66d442efc967cc771e97f8aab7/index.js#L128-L176<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function _parseProcNetDev ( ) { var buf = fs . readFileSync ( '/proc/net/dev' ) ; var lines = buf . toString ( ) . trim ( ) . split ( '\n' ) ; var sections = lines . shift ( ) . split ( '|' ) ; var columns = lines . shift ( ) . trim ( ) . split ( '|' ) ; var s ; var l ; var c ; var p = 0 ; var map = { } ; var keys = [ ] ; for ( var i = 0 ; i < sections . length ; ++ i ) { s = sections [ i ] . trim ( ) ; l = sections [ i ] . length ; c = columns [ i ] . trim ( ) . split ( / \s+ / g ) ; while ( c . length ) { map [ keys . length ] = s ; keys . push ( c . shift ( ) ) ; } p += s . length + 1 ; } var retObj = { } ; lines . forEach ( function ( l ) { l = l . trim ( ) . split ( / \s+ / g ) ; var o = { } ; var iface ; for ( var i = 0 ; i < l . length ; ++ i ) { var s = map [ i ] ; //case for the Interface if ( s . indexOf ( '-' ) === s . length - 1 ) { iface = l [ i ] . substr ( 0 , l [ i ] . length - 1 ) ; //case for everything else } else { if ( ! o [ keys [ i ] ] ) { o [ keys [ i ] . toLowerCase ( ) ] = { } ; } o [ keys [ i ] . toLowerCase ( ) ] [ s . toLowerCase ( ) ] = l [ i ] ; } } retObj [ iface ] = o ; } ) ; return retObj ; }<CODESPLIT>0.15325692296028137<CODESPLIT>0.1347578912973404

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/hyurl/sfn/blob/c4a7a39a14983fe8e62f46280c75f386e09ff618/src/assets/js/javascript.js#L33-L39<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function stringify ( obj ) { var arr = [ ] ; for ( var x in obj ) { arr . push ( encodeURIComponent ( x ) + "=" + encodeURIComponent ( obj [ x ] ) ) ; } return arr . join ( "&" ) ; }<CODESPLIT>0.16208097338676453<CODESPLIT>0.16358494758605957

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/core/Ext-more.js#L970-L998<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( config ) { var appName = config . name , onReady , scope , requires ; if ( ! config ) { config = { } ; } if ( ! Ext . Loader . config . paths [ appName ] ) { Ext . Loader . setPath ( appName , config . appFolder || 'app' ) ; } requires = Ext . Array . from ( config . requires ) ; config . requires = [ 'Ext.app.Application' ] ; onReady = config . onReady ; scope = config . scope ; config . onReady = function ( ) { config . requires = requires ; new Ext . app . Application ( config ) ; if ( onReady ) { onReady . call ( scope ) ; } } ; Ext . setup ( config ) ; }<CODESPLIT>0.1561606079339981<CODESPLIT>0.14183685183525085

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/AdamBrodzinski/meteor-generate/blob/e8a8533677f4116809827b0292a7957ce2dc11cf/lib/router.js#L44-L85<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( resName , action ) { var route , newContent , oldFileStr , newFileStr , res ; resName = resName || '' ; res = require ( './parse_name' ) ( resName ) // set correct route for the required action // TODO Pascal case namespaces, camelcase routes switch ( action ) { case 'index' : route = "  this.route('" + res . camelPlural + "',     { path: '/" + resName + "',          controller: " + res . pascalPlural + "Controller.Index });" ; break ; case 'new' : route = "  this.route('" + res . camelPlural + "New',  { path: '/" + resName + "/new',      controller: " + res . pascalPlural + "Controller.New });" ; break ; case 'show' : route = "  this.route('" + res . camelPlural + "Show', { path: '/" + resName + "/:id',      controller: " + res . pascalPlural + "Controller.Show });" ; break ; case 'edit' : route = "  this.route('" + res . camelPlural + "Edit', { path: '/" + resName + "/edit/:id', controller: " + res . pascalPlural + "Controller.Edit });" ; break ; case 'comment_line' : route = "  // " + resName + " routes" ; break ; case 'blank_line' : route = "" ; break ; default : route = "  this.route('UNKNOWN', { path: '/', controller: UNKNOWN.index });" ; break ; } // read routes.js from users folder and save to string // concat new route together oldFileStr = fs . readFileSync ( this . routeDest , { encoding : 'utf-8' } ) ; newContent = route + "\n" + this . terminateRoute ; // insert new content into current routes.js string // write new content to file `routes/controllers/resource_name.js` newFileStr = oldFileStr . replace ( this . beforeEndOfRouter , newContent ) ; fs . writeFileSync ( this . routeDest , newFileStr ) ; }<CODESPLIT>0.16099852323532104<CODESPLIT>0.14525000751018524

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/dom/Element.style.js#L368-L379<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( width , height ) { if ( Ext . isObject ( width ) ) { // in case of object from getSize() height = width . height ; width = width . width ; } this . setWidth ( width ) ; this . setHeight ( height ) ; return this ; }<CODESPLIT>0.1512892246246338<CODESPLIT>0.13584381341934204

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/Joris-van-der-Wel/stateful-controller-browser-router/blob/636393622090b476384d9f563de5b516dcc67d79/lib/Router.js#L20-L64<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function Router ( window , urlStateMap , frontController ) { EventEmitter . call ( this ) ; this . window = window ; this . urlStateMap = urlStateMap ; this . frontController = frontController ; this . currentStateList = null ; this . _pendingTransitionPromise = null ; this . _pendingReplace = null ; this . _initialHistoryState = null ; this . _queue = { hasEntry : false , stateList : null , fromHistory : false , upgrade : false , push : false , promise : null , resolve : null , reject : null } ; if ( ! window || ! urlStateMap || ! frontController ) { throw Error ( 'Missing argument' ) ; } if ( typeof this . urlStateMap . toURL !== 'function' || typeof this . urlStateMap . fromURL !== 'function' ) { throw Error ( 'Argument `urlStateMap` must implement toURL(states) and fromURL(url)' ) ; } if ( ! Router . isSupported ( this . window ) ) { throw Error ( 'Argument `window` does not support the history API' ) ; } if ( this . frontController . isStatefulController1 !== true ) { throw Error ( 'Argument `frontController` is not a stateful-controller' ) ; } this . _onpopstate = this . _onpopstate . bind ( this ) ; }<CODESPLIT>0.1616506576538086<CODESPLIT>0.1297304779291153

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/usabilla/usabilla-u4a-react-native/blob/94504ff14d04ce47aa0590e54963057d4e4ae8d4/src/index.js#L7-L15<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function initialize ( appId ) { if ( Platform . OS == 'android' ) { usabillaEventEmitter . addListener ( 'UBFormNotFoundFragmentActivity' , ( ) => console . log ( "The Activity does not extend FragmentActivity and cannot call getSupportFragmentManager()" ) ) } UsabillaBridge . initialize ( appId ) }<CODESPLIT>0.159567728638649<CODESPLIT>0.1454530954360962

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/probot/probot-config/blob/dbdbc8b2d421997797a6e229f2e01c189c1696db/lib/index.js#L46-L57<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>async function loadYaml ( context , params ) { try { const response = await context . github . repos . getContents ( params ) ; return parseConfig ( response . data . content ) ; } catch ( e ) { if ( e . code === 404 ) { return null ; } throw e ; } }<CODESPLIT>0.18341657519340515<CODESPLIT>0.1479959785938263

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/azproduction/lmd/blob/03410c36839728de683c697670e1b205dc8193ee/bin/lmd_builder.js#L947-L1034<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( optionName , isApply , isInline ) { // /*if ($P.CSS || $P.JS || $P.ASYNC) {*/ var inlinePreprocessorBlock = isInline ? '/*if (' + optionName + ') {*/' : 'if (' + optionName + ') {' , bracesCounter = 0 , startIndex = lmd_js . indexOf ( inlinePreprocessorBlock ) , startLength = inlinePreprocessorBlock . length , endIndex = startIndex + inlinePreprocessorBlock . length , endLength = isInline ? 5 : 1 ; if ( startIndex === - 1 ) { return false ; } // lookup for own } while ( lmd_js . length > endIndex ) { if ( lmd_js [ endIndex ] === '{' ) { bracesCounter ++ ; } if ( lmd_js [ endIndex ] === '}' ) { bracesCounter -- ; } // found! if ( bracesCounter === - 1 ) { if ( isInline ) { // step back endIndex -= 2 ; } else { // remove leading spaces from open part while ( startIndex ) { startIndex -- ; startLength ++ ; if ( lmd_js [ startIndex ] !== '\t' && lmd_js [ startIndex ] !== ' ' ) { startIndex ++ ; startLength -- ; break ; } } // remove leading spaces from close part while ( endIndex ) { endIndex -- ; endLength ++ ; if ( lmd_js [ endIndex ] !== '\t' && lmd_js [ endIndex ] !== ' ' ) { endIndex ++ ; endLength -- ; break ; } } // add front \n endLength ++ ; startLength ++ ; } if ( isApply ) { // wipe preprocessor blocks only // open lmd_js = lmd_js . substr ( 0 , startIndex ) + lmd_js . substr ( startIndex + startLength ) ; // close lmd_js = lmd_js . substr ( 0 , endIndex - startLength ) + lmd_js . substr ( endIndex + endLength - startLength ) ; if ( ! isInline ) { // indent block back var blockForIndent = lmd_js . substr ( startIndex , endIndex - startLength - startIndex ) ; blockForIndent = blockForIndent . split ( '\n' ) . map ( function ( line ) { return line . replace ( / ^\s{4} / , '' ) ; } ) . join ( '\n' ) ; lmd_js = lmd_js . substr ( 0 , startIndex ) + blockForIndent + lmd_js . substr ( endIndex - startLength ) ; } } else { // wipe all lmd_js = lmd_js . substr ( 0 , startIndex ) + lmd_js . substr ( endIndex + endLength ) ; } break ; } endIndex ++ ; } return true ; }<CODESPLIT>0.15325716137886047<CODESPLIT>0.1543160080909729

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/util/TapRepeater.js#L49-L60<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( config ) { var me = this ; //<debug warn> for ( var configName in config ) { if ( me . self . prototype . config && ! ( configName in me . self . prototype . config ) ) { me [ configName ] = config [ configName ] ; Ext . Logger . warn ( 'Applied config as instance property: "' + configName + '"' , me ) ; } } //</debug> me . initConfig ( config ) ; }<CODESPLIT>0.1612478494644165<CODESPLIT>0.13262435793876648

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/cubicmushroom/gulp-cm-phpspec-tasks/blob/671b5e6e9545c7a6a027f8b93c1349d491cf429e/pakmanaged.js#L9727-L9733<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function expectKeyword ( keyword , contextual ) { var token = lex ( ) ; if ( token . type !== ( contextual ? Token . Identifier : Token . Keyword ) || token . value !== keyword ) { throwUnexpected ( token ) ; } }<CODESPLIT>0.16130180656909943<CODESPLIT>0.12890128791332245

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/fistlabs/fist/blob/7a6ddd52ae2672fbb9481855e4a64bebe5682cb9/core/runtime.js#L39-L170<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function Runtime ( unit , track , parent , args , done ) { // Create lite context to provide an interface to check execution parameters var context = new Context . Lite ( ) . // add default context params addParams ( unit . params ) . // add track's params addParams ( track . params ) . // add local args addParams ( args ) ; /**      * Runtime identity is a part of cacheKey and memorization key      *      * @public      * @memberOf {Runtime}      * @property      * @type {String}      * */ this . identity = unit . identify ( track , context ) ; /**      * Invoking unit      *      * @public      * @memberOf {Runtime}      * @property      * @type {Unit}      * */ this . unit = unit ; /**      * Request handling runtime      *      * @public      * @memberOf {Runtime}      * @property      * @type {Track}      * */ this . track = track ; /**      * The dependant Runtime      *      * @public      * @memberOf {Runtime}      * @property      * @type {Runtime}      * */ this . parent = parent ; /**      * Finish listener      *      * @public      * @memberOf {Runtime}      * @property      * @type {Function}      * */ this . done = done ; /**      * The number of dependencies remaining to resolve      *      * @public      * @memberOf {Runtime}      * @property      * @type {Number}      * */ this . pathsLeft = 0 ; /**      * The array of dependency identities      *      * @public      * @memberOf {Runtime}      * @property      * @type {Array}      * */ this . keys = [ ] ; /**      * @public      * @memberOf {Runtime}      * @property      * @type {Date}      * */ this . creationDate = 0 ; /**      * @public      * @memberOf {Runtime}      * @property      * @type {*}      * */ this . value = undefined ; /**      * The status of current runtime      *      * @public      * @memberOf {Runtime}      * @property      * @type {Number}      * */ this . statusBits = 0 ; /**      * Runtime context      *      * @public      * @memberOf {Runtime}      * @property      * @type {Context}      * */ this . context = context ; /**      * @public      * @memberOf {Runtime}      * @property      * @type {Array<Runtime>}      * */ this . listeners = [ ] ; /**      * @public      * @memberOf {Runtime}      * @property      * @type {String}      * */ this . cacheKey = unit . app . params . name ; }<CODESPLIT>0.16747640073299408<CODESPLIT>0.14148494601249695

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/alexlangberg/node-needle-schedule/blob/26b9a34d81e7b2a5b4876e4ddd7cab2dc656a5cc/lib/index.js#L14-L27<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( options ) { var defaults = { 'method' : 'get' , 'data' : null , 'needleRetry' : null , 'rule' : { 'second' : 1 } } ; if ( ! options ) { return defaults ; } return R . merge ( defaults , options ) ; }<CODESPLIT>0.15769925713539124<CODESPLIT>0.14824184775352478

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/jhsware/component-registry/blob/c351b2adc2552afe0c59600aaafd75386517a47a/lib/interfaceFactory.js#L32-L44<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( params ) { // Schema defines fields and can be used for validation and form generation (optional) this . schema = params . schema ; // The name of the interface, this should be unique this . name = params . name ; // Additional properties that aren't exposed as form data, in the future this might be  // used to check that objects fulfill the implementation this . members = params . members ; this . interfaceId = uuid . v4 ( ) ; // console.log("[SCHEMA] Created interface [" + this.name + "] with id: " + this.interfaceId); }<CODESPLIT>0.16329090297222137<CODESPLIT>0.13967038691043854

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/Strider-CD/strider/blob/56cafbc9687ebb7b67d485ec387a03cb85791c7c/lib/websockets.js#L45-L53<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( socket ) { var session = socket . handshake . session ; if ( session && session . passport ) { this . addSocket ( session . passport . user , socket ) ; } else { console . debug ( 'Websocket connection does not have authorization - nothing to do.' ) ; } }<CODESPLIT>0.16267138719558716<CODESPLIT>0.1297028809785843

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/mpetroff/pannellum/blob/59893bcea4629be059ad3e59c3fa5bde438d292b/src/js/pannellum.js#L612-L622<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function anError ( errorMsg ) { if ( errorMsg === undefined ) errorMsg = config . strings . genericWebGLError ; infoDisplay . errorMsg . innerHTML = '<p>' + errorMsg + '</p>' ; controls . load . style . display = 'none' ; infoDisplay . load . box . style . display = 'none' ; infoDisplay . errorMsg . style . display = 'table' ; error = true ; renderContainer . style . display = 'none' ; fireEvent ( 'error' , errorMsg ) ; }<CODESPLIT>0.17364190518856049<CODESPLIT>0.13514381647109985

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/mixin/Sortable.js#L329-L356<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( items , item , sortFn , containsItem ) { var start = 0 , end = items . length - 1 , sorterFn = sortFn || this . getSortFn ( ) , middle , comparison ; while ( start < end || start === end && ! containsItem ) { middle = ( start + end ) >> 1 ; var middleItem = items [ middle ] ; if ( middleItem === item ) { start = middle ; break ; } comparison = sorterFn ( item , middleItem ) ; if ( comparison > 0 || ( ! containsItem && comparison === 0 ) ) { start = middle + 1 ; } else if ( comparison < 0 ) { end = middle - 1 ; } else if ( containsItem && ( start !== end ) ) { start = middle + 1 ; } } return start ; }<CODESPLIT>0.16311320662498474<CODESPLIT>0.13096922636032104

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/AmpersandJS/ampersand-state/blob/a85945b250e6db475b02ca53ae0ef8f7afaba935/ampersand-state.js#L563-L638<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function createPropertyDefinition ( object , name , desc , isSession ) { var def = object . _definition [ name ] = { } ; var type , descArray ; if ( isString ( desc ) ) { // grab our type if all we've got is a string type = object . _ensureValidType ( desc ) ; if ( type ) def . type = type ; } else { //Transform array of ['type', required, default] to object form if ( Array . isArray ( desc ) ) { descArray = desc ; desc = { type : descArray [ 0 ] , required : descArray [ 1 ] , 'default' : descArray [ 2 ] } ; } type = object . _ensureValidType ( desc . type ) ; if ( type ) def . type = type ; if ( desc . required ) def . required = true ; if ( desc [ 'default' ] && typeof desc [ 'default' ] === 'object' ) { throw new TypeError ( 'The default value for ' + name + ' cannot be an object/array, must be a value or a function which returns a value/object/array' ) ; } def [ 'default' ] = desc [ 'default' ] ; def . allowNull = desc . allowNull ? desc . allowNull : false ; if ( desc . setOnce ) def . setOnce = true ; if ( def . required && def [ 'default' ] === undefined && ! def . setOnce ) def [ 'default' ] = object . _getDefaultForType ( type ) ; def . test = desc . test ; def . values = desc . values ; } if ( isSession ) def . session = true ; if ( ! type ) { type = isString ( desc ) ? desc : desc . type ; // TODO: start throwing a TypeError in future major versions instead of warning console . warn ( 'Invalid data type of `' + type + '` for `' + name + '` property. Use one of the default types or define your own' ) ; } // define a getter/setter on the prototype // but they get/set on the instance Object . defineProperty ( object , name , { set : function ( val ) { this . set ( name , val ) ; } , get : function ( ) { if ( ! this . _values ) { throw Error ( 'You may be trying to `extend` a state object with "' + name + '" which has been defined in `props` on the object being extended' ) ; } var value = this . _values [ name ] ; var typeDef = this . _dataTypes [ def . type ] ; if ( typeof value !== 'undefined' ) { if ( typeDef && typeDef . get ) { value = typeDef . get ( value ) ; } return value ; } var defaultValue = result ( def , 'default' ) ; this . _values [ name ] = defaultValue ; // If we've set a defaultValue, fire a change handler effectively marking // its change from undefined to the default value. if ( typeof defaultValue !== 'undefined' ) { var onChange = this . _getOnChangeForType ( def . type ) ; onChange ( defaultValue , value , name ) ; } return defaultValue ; } } ) ; return def ; }<CODESPLIT>0.1635010987520218<CODESPLIT>0.15902632474899292

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L9899-L9940<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( word , typeRules , irregular ) { var inflection , substitution , result , lowercase , isBlank , isUncountable , isIrregular , isIrregularInverse , rule ; isBlank = BLANK_REGEX . test ( word ) ; if ( isBlank ) { return word ; } lowercase = word . toLowerCase ( ) ; isUncountable = this . rules . uncountable [ lowercase ] ; if ( isUncountable ) { return word ; } isIrregular = irregular && irregular [ lowercase ] ; if ( isIrregular ) { return isIrregular ; } for ( var i = typeRules . length , min = 0 ; i > min ; i -- ) { inflection = typeRules [ i - 1 ] ; rule = inflection [ 0 ] ; if ( rule . test ( word ) ) { break ; } } inflection = inflection || [ ] ; rule = inflection [ 0 ] ; substitution = inflection [ 1 ] ; result = word . replace ( rule , substitution ) ; return result ; }<CODESPLIT>0.16493648290634155<CODESPLIT>0.14317236840724945

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/AustP/jwt-express/blob/f33e5c858e19826b7d767939a7048e3c5ff66387/jwt-express.js#L72-L80<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( ) { return { token : this . token , payload : this . payload , valid : this . valid , expired : this . expired , stale : this . stale } ; }<CODESPLIT>0.15675759315490723<CODESPLIT>0.1433076411485672

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/plain-precompiled-build.js#L18316-L18538<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( module , exports , __webpack_require__ ) { 'use strict' ; var _interopRequireDefault = __webpack_require__ ( 1 ) [ 'default' ] ; exports . __esModule = true ; var _visitor = __webpack_require__ ( 25 ) ; var _visitor2 = _interopRequireDefault ( _visitor ) ; function WhitespaceControl ( ) { var options = arguments . length <= 0 || arguments [ 0 ] === undefined ? { } : arguments [ 0 ] ; this . options = options ; } WhitespaceControl . prototype = new _visitor2 [ 'default' ] ( ) ; WhitespaceControl . prototype . Program = function ( program ) { var doStandalone = ! this . options . ignoreStandalone ; var isRoot = ! this . isRootSeen ; this . isRootSeen = true ; var body = program . body ; for ( var i = 0 , l = body . length ; i < l ; i ++ ) { var current = body [ i ] , strip = this . accept ( current ) ; if ( ! strip ) { continue ; } var _isPrevWhitespace = isPrevWhitespace ( body , i , isRoot ) , _isNextWhitespace = isNextWhitespace ( body , i , isRoot ) , openStandalone = strip . openStandalone && _isPrevWhitespace , closeStandalone = strip . closeStandalone && _isNextWhitespace , inlineStandalone = strip . inlineStandalone && _isPrevWhitespace && _isNextWhitespace ; if ( strip . close ) { omitRight ( body , i , true ) ; } if ( strip . open ) { omitLeft ( body , i , true ) ; } if ( doStandalone && inlineStandalone ) { omitRight ( body , i ) ; if ( omitLeft ( body , i ) ) { // If we are on a standalone node, save the indent info for partials if ( current . type === 'PartialStatement' ) { // Pull out the whitespace from the final line current . indent = / ([ \t]+$) / . exec ( body [ i - 1 ] . original ) [ 1 ] ; } } } if ( doStandalone && openStandalone ) { omitRight ( ( current . program || current . inverse ) . body ) ; // Strip out the previous content node if it's whitespace only omitLeft ( body , i ) ; } if ( doStandalone && closeStandalone ) { // Always strip the next node omitRight ( body , i ) ; omitLeft ( ( current . inverse || current . program ) . body ) ; } } return program ; } ; WhitespaceControl . prototype . BlockStatement = WhitespaceControl . prototype . DecoratorBlock = WhitespaceControl . prototype . PartialBlockStatement = function ( block ) { this . accept ( block . program ) ; this . accept ( block . inverse ) ; // Find the inverse program that is involed with whitespace stripping. var program = block . program || block . inverse , inverse = block . program && block . inverse , firstInverse = inverse , lastInverse = inverse ; if ( inverse && inverse . chained ) { firstInverse = inverse . body [ 0 ] . program ; // Walk the inverse chain to find the last inverse that is actually in the chain. while ( lastInverse . chained ) { lastInverse = lastInverse . body [ lastInverse . body . length - 1 ] . program ; } } var strip = { open : block . openStrip . open , close : block . closeStrip . close , // Determine the standalone candiacy. Basically flag our content as being possibly standalone // so our parent can determine if we actually are standalone openStandalone : isNextWhitespace ( program . body ) , closeStandalone : isPrevWhitespace ( ( firstInverse || program ) . body ) } ; if ( block . openStrip . close ) { omitRight ( program . body , null , true ) ; } if ( inverse ) { var inverseStrip = block . inverseStrip ; if ( inverseStrip . open ) { omitLeft ( program . body , null , true ) ; } if ( inverseStrip . close ) { omitRight ( firstInverse . body , null , true ) ; } if ( block . closeStrip . open ) { omitLeft ( lastInverse . body , null , true ) ; } // Find standalone else statments if ( ! this . options . ignoreStandalone && isPrevWhitespace ( program . body ) && isNextWhitespace ( firstInverse . body ) ) { omitLeft ( program . body ) ; omitRight ( firstInverse . body ) ; } } else if ( block . closeStrip . open ) { omitLeft ( program . body , null , true ) ; } return strip ; } ; WhitespaceControl . prototype . Decorator = WhitespaceControl . prototype . MustacheStatement = function ( mustache ) { return mustache . strip ; } ; WhitespaceControl . prototype . PartialStatement = WhitespaceControl . prototype . CommentStatement = function ( node ) { /* istanbul ignore next */ var strip = node . strip || { } ; return { inlineStandalone : true , open : strip . open , close : strip . close } ; } ; function isPrevWhitespace ( body , i , isRoot ) { if ( i === undefined ) { i = body . length ; } // Nodes that end with newlines are considered whitespace (but are special // cased for strip operations) var prev = body [ i - 1 ] , sibling = body [ i - 2 ] ; if ( ! prev ) { return isRoot ; } if ( prev . type === 'ContentStatement' ) { return ( sibling || ! isRoot ? / \r?\n\s*?$ / : / (^|\r?\n)\s*?$ / ) . test ( prev . original ) ; } } function isNextWhitespace ( body , i , isRoot ) { if ( i === undefined ) { i = - 1 ; } var next = body [ i + 1 ] , sibling = body [ i + 2 ] ; if ( ! next ) { return isRoot ; } if ( next . type === 'ContentStatement' ) { return ( sibling || ! isRoot ? / ^\s*?\r?\n / : / ^\s*?(\r?\n|$) / ) . test ( next . original ) ; } } // Marks the node to the right of the position as omitted. // I.e. {{foo}}' ' will mark the ' ' node as omitted. // // If i is undefined, then the first child will be marked as such. // // If mulitple is truthy then all whitespace will be stripped out until non-whitespace // content is met. function omitRight ( body , i , multiple ) { var current = body [ i == null ? 0 : i + 1 ] ; if ( ! current || current . type !== 'ContentStatement' || ! multiple && current . rightStripped ) { return ; } var original = current . value ; current . value = current . value . replace ( multiple ? / ^\s+ / : / ^[ \t]*\r?\n? / , '' ) ; current . rightStripped = current . value !== original ; } // Marks the node to the left of the position as omitted. // I.e. ' '{{foo}} will mark the ' ' node as omitted. // // If i is undefined then the last child will be marked as such. // // If mulitple is truthy then all whitespace will be stripped out until non-whitespace // content is met. function omitLeft ( body , i , multiple ) { var current = body [ i == null ? body . length - 1 : i - 1 ] ; if ( ! current || current . type !== 'ContentStatement' || ! multiple && current . leftStripped ) { return ; } // We omit the last node if it's whitespace only and not preceeded by a non-content node. var original = current . value ; current . value = current . value . replace ( multiple ? / \s+$ / : / [ \t]+$ / , '' ) ; current . leftStripped = current . value !== original ; return current . leftStripped ; } exports [ 'default' ] = WhitespaceControl ; module . exports = exports [ 'default' ] ; /***/ }<CODESPLIT>0.17247405648231506<CODESPLIT>0.13512791693210602

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/kgryte/travis-ci-post/blob/4b1d0701c5f24696ffd7c33b2157ad2d4cd4ee9a/lib/factory.js#L38-L87<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function factory ( options , clbk ) { var opts ; var err ; opts = copy ( defaults ) ; err = validate ( opts , options ) ; if ( err ) { throw err ; } if ( opts . port === null ) { if ( opts . protocol === 'https' ) { opts . port = DEFAULT_HTTPS_PORT ; } else { opts . port = DEFAULT_HTTP_PORT ; } } if ( ! isFunction ( clbk ) ) { throw new TypeError ( 'invalid input argument. Callback argument must be a function. Value: `' + clbk + '`.' ) ; } /** 	* FUNCTION: post( [data] ) 	*	Sends a POST request to an endpoint. 	* 	* @param {String|Object} [data] - request data 	* @returns {Void} 	*/ return function post ( data ) { var d ; if ( arguments . length && ! isString ( data ) && ! isObject ( data ) ) { throw new TypeError ( 'invalid input argument. Request data must be either a string or an object. Value: `' + data + '`.' ) ; } d = data || '' ; query ( d , opts , done ) ; } ; // end FUNCTION post() /** 	* FUNCTION: done( error, results ) 	*	Callback invoked after completing query. 	* 	* @private 	* @param {Error|Null} error - error object 	* @param {Object[]} results - query results 	* @returns {Void} 	*/ function done ( error , results ) { if ( error ) { return clbk ( error ) ; } clbk ( null , results ) ; } // end FUNCTION done() }<CODESPLIT>0.12209989130496979<CODESPLIT>0.1539616733789444

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/snapptop/ninjs-lodash/blob/fab253b7d96cc9bb3f2a1057efff2684c200bcee/lib/url.js#L149-L156<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function jquery ( src ) { src = clean ( src ) ; let params = { } let match = null if ( ! url || ! _ . isString ( src ) ) return params while ( match = REGX_QUERY_OBJECT . exec ( src ) ) { params [ match [ 1 ] ] = match [ 2 ] } return params }<CODESPLIT>0.16768133640289307<CODESPLIT>0.1246643215417862

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/kevincennis/promise/blob/b58ef67dd4023139d0aad98ccd0cb60d8a4f9eec/promise.js#L322-L333<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function NewPromiseCapability ( C ) { var promise ; if ( ! IsConstructor ( C ) ) { throw TypeError ( ) ; } try { promise = Object . create ( C . prototype ) ; } catch ( e ) { return e ; } return CreatePromiseCapabilityRecord ( promise , C ) ; }<CODESPLIT>0.16238519549369812<CODESPLIT>0.13489942252635956

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/jurca/indexed-db.es6/blob/abc22dc63b2159c253b60c5dc396d22fd72c2177/es2015/PromiseSync.js#L318-L336<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function resolve ( instance , newState , value ) { if ( instance [ FIELDS . state ] !== STATE . PENDING ) { return } instance [ FIELDS . state ] = newState instance [ FIELDS . value ] = value let listeners if ( newState === STATE . RESOLVED ) { listeners = instance [ FIELDS . fulfillListeners ] } else { listeners = instance [ FIELDS . errorListeners ] } for ( let listener of listeners ) { listener ( ) } }<CODESPLIT>0.1527036726474762<CODESPLIT>0.15024560689926147

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/kadirahq/lokka-transport-http/blob/54d37f817ef80a17277ecdad0aec07311baef68f/lib/index.js#L24-L30<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function handleErrors ( errors , data ) { const message = errors [ 0 ] . message ; const error = new Error ( ` ${ message } ` ) ; error . rawError = errors ; error . rawData = data ; throw error ; }<CODESPLIT>0.18161526322364807<CODESPLIT>0.12857049703598022

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/giannico/tiny-lr-notifier/blob/e046f370a6eb47d9dac854ee7c7ab892538fe090/lib/index.js#L34-L88<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function notify ( arg1 , arg2 , arg3 ) { var argsLength = arguments . length ; return new P ( function ( resolve , reject ) { var filesCsv = null ; var requestUrl = null ; var host = null ; var port = null ; var files = null ; if ( argsLength === 3 ) { host = arg1 ; port = arg2 ; files = arg3 ; } else if ( argsLength === 2 ) { host = DEFAULT_HOST ; port = arg1 ; files = arg2 ; } else if ( argsLength === 1 ) { host = DEFAULT_HOST ; port = DEFAULT_PORT ; files = arg1 ; } requestUrl = 'http://' + host + ':' + port + '/changed?files=' ; if ( host == null || port == null || files == null ) { return reject ( new Error ( 'host, port and files are all required fields!' ) ) ; } // one file if ( _ . isString ( files ) ) { filesCsv = files ; } else if ( _ . isArray ( files ) ) { filesCsv = files . join ( ',' ) ; } else { return reject ( new Error ( 'files must be a string or an array of strings!' ) ) ; } requestUrl += filesCsv ; console . log ( requestUrl ) ; request . get ( requestUrl , function ( err , response , body ) { if ( err !== null ) { return reject ( err ) ; } else { return resolve ( { response : response , body : body } ) ; } } ) ; } ) ; }<CODESPLIT>0.1598273366689682<CODESPLIT>0.12966017425060272

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/willconant/flow-js/blob/8336df1741a663b458cd96ba12ad2c3e13f89b84/flow.js#L13-L98<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function define ( ) { var thisFlow = function ( ) { applyArgs ( thisFlow . exec , thisFlow , arguments ) ; } thisFlow . blocks = arguments ; thisFlow . exec = function ( ) { // The flowState is the actual object each step in the flow is applied to. It acts as a // callback to the next function. It also maintains the internal state of each execution // and acts as a place for users to save values between steps of the flow. var flowState = function ( ) { if ( flowState . __frozen ) return ; if ( flowState . __timeoutId ) { clearTimeout ( flowState . __timeoutId ) ; delete flowState . __timeoutId ; } var blockIdx = flowState . __nextBlockIdx ++ ; var block = thisFlow . blocks [ blockIdx ] ; if ( block === undefined ) { return ; } else { applyArgs ( block , flowState , arguments ) ; } } // __nextBlockIdx specifies which function is the next step in the flow. flowState . __nextBlockIdx = 0 ; // __multiCount is incremented every time MULTI is used to createa a multiplexed callback flowState . __multiCount = 0 ; // __multiOutputs accumulates the arguments of each call to callbacks generated by MULTI flowState . __multiOutputs = [ ] ; // REWIND signals that the next call to thisFlow should repeat this step. It allows you // to create serial loops. flowState . REWIND = function ( ) { flowState . __nextBlockIdx -= 1 ; } // MULTI can be used to generate callbacks that must ALL be called before the next step // in the flow is executed. Arguments to those callbacks are accumulated, and an array of // of those arguments objects is sent as the one argument to the next step in the flow. // @param {String} resultId An identifier to get the result of a multi call. flowState . MULTI = function ( resultId ) { flowState . __multiCount += 1 ; return function ( ) { flowState . __multiCount -= 1 ; flowState . __multiOutputs . push ( arguments ) ; if ( resultId ) { var result = arguments . length <= 1 ? arguments [ 0 ] : arguments flowState . __multiOutputs [ resultId ] = result ; } if ( flowState . __multiCount === 0 ) { var multiOutputs = flowState . __multiOutputs ; flowState . __multiOutputs = [ ] ; flowState ( multiOutputs ) ; } } } // TIMEOUT sets a timeout that freezes a flow and calls the provided callback. This // timeout is cleared if the next flow step happens first. flowState . TIMEOUT = function ( milliseconds , timeoutCallback ) { if ( flowState . __timeoutId !== undefined ) { throw new Error ( "timeout already set for this flow step" ) ; } flowState . __timeoutId = setTimeout ( function ( ) { flowState . __frozen = true ; timeoutCallback ( ) ; } , milliseconds ) ; } applyArgs ( flowState , this , arguments ) ; } return thisFlow ; }<CODESPLIT>0.13075730204582214<CODESPLIT>0.14305879175662994

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/lps-js/lps.js/blob/f91fd5c5e738be909dea7996cb05014c716664d3/src/engine/List.js#L16-L165<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function List ( head , tail ) { let _head = head ; let _tail = tail ; let _variableHash = null ; if ( tail === undefined ) { // empty list for tail _tail = null ; } /**    * Get the head of the list    * @return {Array} Return the array representing the head of the list    */ this . getHead = function getHead ( ) { return _head . concat ( ) ; } ; /**    * Get the tail of the list    * @return {Array|List|Variable} Return the tail representation of the list    */ this . getTail = function getTail ( ) { return _tail ; } ; /**    * Determine if the term is ground    * @return {Boolean} Return true if the term is ground, false otherwise.    */ this . isGround = function isGround ( ) { if ( _tail !== null ) { return _tail . isGround ( ) ; } for ( let i = 0 ; i < _head . length ; i += 1 ) { if ( ! _head [ i ] . isGround ( ) ) { return false ; } } return true ; } ; /**    * Get all unique variables that occur in this term    * @return {Array} Return the array of unique variables occuring in this term    */ this . getVariables = function getVariables ( ) { return Object . keys ( this . getVariableHash ( ) ) ; } ; this . getVariableHash = function getVariableHash ( existingHash ) { let hash = existingHash ; if ( _variableHash !== null ) { if ( hash === undefined ) { return _variableHash ; } Object . keys ( _variableHash ) . forEach ( ( v ) => { hash [ v ] = true ; } ) ; return hash ; } // if we're writing into existing hash, don't store the hash if ( hash === undefined ) { hash = { } ; } let storedHash = { } ; const processArg = function processArg ( arg ) { arg . getVariableHash ( storedHash ) ; arg . getVariableHash ( hash ) ; } ; _head . forEach ( processArg ) ; if ( _tail instanceof List ) { processArg ( _tail ) ; } else if ( _tail instanceof Variable ) { storedHash [ _tail . evaluate ( ) ] = true ; hash [ _tail . evaluate ( ) ] = true ; } _variableHash = storedHash ; return hash ; } ; /**    * Perform a substitution on this term.    * @param  {Object} theta The substitution theta    * @return {List}       Return the substituted list    */ this . substitute = function substitute ( theta ) { let newHead = head . map ( ( element ) => { return element . substitute ( theta ) ; } ) ; let newTail = _tail ; if ( newTail instanceof List || newTail instanceof Variable ) { newTail = newTail . substitute ( theta ) ; } return new List ( newHead , newTail ) ; } ; /**    * Create a flat representation of the list. If the tail of the list is a variable,    * the empty list is assumed.    * @return {Array} Return the flat array representation of the list    */ this . flatten = function flatten ( ) { let result = [ ] ; if ( _head . length > 0 ) { result = result . concat ( _head ) ; if ( _tail instanceof List ) { result = result . concat ( _tail . flatten ( ) ) ; } } return result ; } ; /**    * Determine if the list is empty    * @return {Boolean} Return true if the list is empty, false otherwise.    */ this . isEmpty = function isEmpty ( ) { return _head . length === 0 && ( _tail instanceof List && _tail . isEmpty ( ) ) ; } ; /**    * Create a string representation of the term    * @return {string} Return the string representation of the term    */ this . toString = function toString ( ) { let result = '' ; result += '[' ; for ( let j = 0 ; j < _head . length ; j += 1 ) { result += _head [ j ] ; if ( j < _head . length - 1 ) { result += ', ' ; } } if ( _tail !== null && ( ! ( _tail instanceof List ) || ! _tail . isEmpty ( ) ) ) { result += '|' + _tail . toString ( ) ; } result += ']' ; return result ; } ; }<CODESPLIT>0.1690804660320282<CODESPLIT>0.1277848780155182

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/nearform/nscale-kernel/blob/5b9a544a6f2ffdc87294fee3fd00b81667ac0ab3/lib/api.js#L364-L388<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( user , identifier , revisionIdentifier , target , mode , out , cb ) { var systemId = _sr . findSystem ( identifier ) ; if ( ! systemId ) { logger . error ( ERR_NOSYSID ) ; return cb ( new Error ( ERR_NOSYSID ) ) ; } fetchTarget ( systemId , target , revisionIdentifier , function ( err , target ) { if ( err ) { return cb ( err ) ; } _sr . findRevision ( systemId , revisionIdentifier , function ( err , revisionId ) { if ( err ) { out . stdout ( ERR_NOREV ) ; logger . error ( ERR_NOREV ) ; return cb ( ERR_NOREV ) ; } logger . info ( { systemId : systemId , revisionId : revisionId , environment : target } , 'deploy revision' ) ; if ( ! mode ) { mode = 'live' ; } if ( ! revisionId ) { return cb ( new Error ( 'revisionId is needed to deploy' ) ) ; } return createAnalyzeAndDeployTask ( user , systemId , revisionId , target , mode , out , cb ) ; } ) ; } ) ; }<CODESPLIT>0.1624271124601364<CODESPLIT>0.14068254828453064

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/neptunejs/react-parcoords/blob/e784bb05ab5aaf56ee8e54e7255b874a1f16d1d1/d3.parcoords.js#L218-L225<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getRange ( ) { if ( __ . nullValueSeparator == "bottom" ) { return [ h ( ) + 1 - __ . nullValueSeparatorPadding . bottom - __ . nullValueSeparatorPadding . top , 1 ] ; } else if ( __ . nullValueSeparator == "top" ) { return [ h ( ) + 1 , 1 + __ . nullValueSeparatorPadding . bottom + __ . nullValueSeparatorPadding . top ] ; } return [ h ( ) + 1 , 1 ] ; }<CODESPLIT>0.1630575805902481<CODESPLIT>0.16013911366462708

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/calmh/node-zfs/blob/d4409853d2c212004202704c72e305a4022c1f1b/lib/zfs.js#L362-L378<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function unmount ( opts , cb ) { "use strict" ; var params = [ 'unmount' ] ; if ( opts . force ) { params . push ( '-f' ) ; } if ( opts . name ) { params . push ( opts . name ) ; } else { params . push ( '-a' ) ; } zfs ( params , cb ) ; }<CODESPLIT>0.16741518676280975<CODESPLIT>0.14167869091033936

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L34368-L34375<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( ) { if ( this . isAborted ) { return this ; } log ( this . router , this . sequence , this . targetName + ": transition was aborted" ) ; this . isAborted = true ; this . isActive = false ; this . router . activeTransition = null ; return this ; }<CODESPLIT>0.12257521599531174<CODESPLIT>0.17004765570163727

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/jeka-kiselyov/mdict/blob/540898e63991cb0c8985ed8fb29eb11a59f35089/mdict-parser.js#L558-L564<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function read_key_block ( scanner , kdx ) { var scanner = scanner . readBlock ( kdx . comp_size , kdx . decomp_size ) ; for ( var i = 0 ; i < kdx . num_entries ; i ++ ) { //        scanner.readNum(); scanner.readText(); var kk = [ scanner . readNum ( ) , scanner . readText ( ) ] ; } }<CODESPLIT>0.14064159989356995<CODESPLIT>0.16337348520755768

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/carrot/roots-cms-client/blob/57d5281eb03b9f8377d9478da3742f5a74653c17/assets/js/vendor/backbone-relational.js#L287-L296<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( relation ) { var coll = this . getCollection ( relation . model , false ) ; coll && coll . each ( function ( model ) { if ( ! ( model instanceof relation . model ) ) { return ; } new relation . type ( model , relation ) ; } , this ) ; }<CODESPLIT>0.164068341255188<CODESPLIT>0.13963095843791962

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/iorga-group/docker-cmd/blob/95ea2d5062b3133fd1e638c023483d834a960a4c/lib/docker-cmd.js#L103-L136<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function appendOptions ( options , fromOptions ) { function pushOption ( optionName , optionValue ) { var valueDefined = optionValue !== null && optionValue !== undefined ; if ( optionName . length === 1 ) { // simple letter option options . push ( '-' + optionName ) ; if ( valueDefined ) { options . push ( optionValue ) ; } } else { // full option name options . push ( '--' + optionName + ( valueDefined ? '=' + optionValue : '' ) ) ; } } for ( var optionName in fromOptions ) { if ( fromOptions . hasOwnProperty ( optionName ) && optionName !== '_' ) { var optionValue = fromOptions [ optionName ] ; if ( Array . isArray ( optionValue ) ) { // we have multiple values for the same option, let's iterate on each optionValue . forEach ( function ( iOptionValue ) { pushOption ( optionName , iOptionValue ) ; } ) ; } else { pushOption ( optionName , optionValue ) ; } } } // now append the "_" which are not "options" but args if ( fromOptions && fromOptions . _ ) { [ ] . concat ( fromOptions . _ ) . forEach ( function ( arg ) { options . push ( arg ) ; } ) ; } }<CODESPLIT>0.151668980717659<CODESPLIT>0.11729244887828827

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/sinnerschrader/schlump/blob/1049761c781c42cc1ce32e9fb53f32c4d055e32c/src/css.js#L37-L54<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function createScopedCss ( html , scope , filepath , cssVariables ) { scope = typeof scope === 'string' ? { ns : scope , vars : new Map ( ) } : scope ; const style = html . match ( styleMatcher ) ; if ( ! style ) { return [ { } , scope . vars , '' ] ; } const cssom = css . parse ( style [ 1 ] , { source : filepath } ) ; const vars = new Map ( scope . vars . entries ( ) ) ; getVariables ( cssom ) . forEach ( ( value , key ) => vars . set ( key , value ) ) ; if ( cssVariables ) { resolveScopeVariables ( cssom , vars ) ; } const [ classes , transformMap ] = rewriteSelectors ( ` ${ decamelize ( scope . ns , '-' ) } ` , cssom ) ; return [ classes , vars , css . stringify ( cssom ) , transformMap ] ; }<CODESPLIT>0.16761763393878937<CODESPLIT>0.1289643496274948

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/emmetio/extract-abbreviation/blob/41b7368c976ed1ccaca072a314415b67734ea37f/index.js#L117-L129<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function offsetPastAutoClosed ( line , pos , options ) { // closing quote is allowed only as a next character if ( isQuote ( line . charCodeAt ( pos ) ) ) { pos ++ ; } // offset pointer until non-autoclosed character is found while ( isCloseBrace ( line . charCodeAt ( pos ) , options . syntax ) ) { pos ++ ; } return pos ; }<CODESPLIT>0.17146942019462585<CODESPLIT>0.12395923584699631

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/oauthjs/node-oauth2-server/blob/90d00495842cbc68869214a4e6696e5ad048c93d/lib/token-types/bearer-token-type.js#L13-L26<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function BearerTokenType ( accessToken , accessTokenLifetime , refreshToken , scope , customAttributes ) { if ( ! accessToken ) { throw new InvalidArgumentError ( 'Missing parameter: `accessToken`' ) ; } this . accessToken = accessToken ; this . accessTokenLifetime = accessTokenLifetime ; this . refreshToken = refreshToken ; this . scope = scope ; if ( customAttributes ) { this . customAttributes = customAttributes ; } }<CODESPLIT>0.14702504873275757<CODESPLIT>0.13458384573459625

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/NathanaelA/nativescript-sqlite/blob/ef5a5f5eaf728da4c2337362a8c74d8cd3824596/src/sqlite.android.js#L33-L69<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function DBGetRowArrayNative ( cursor ) { //noinspection JSUnresolvedFunction let count = cursor . getColumnCount ( ) ; let results = [ ] ; for ( let i = 0 ; i < count ; i ++ ) { const type = cursor . getType ( i ) ; switch ( type ) { case 0 : // NULL results . push ( null ) ; break ; case 1 : // Integer //noinspection JSUnresolvedFunction results . push ( cursor . getLong ( i ) ) ; break ; case 2 : // Float //noinspection JSUnresolvedFunction results . push ( cursor . getFloat ( i ) ) ; break ; case 3 : // String //noinspection JSUnresolvedFunction results . push ( cursor . getString ( i ) ) ; break ; case 4 : // Blob // noinspection JSCheckFunctionSignatures results . push ( cursor . getBlob ( i ) ) ; break ; default : throw new Error ( 'SQLITE - Unknown Field Type ' + type ) ; } } return results ; }<CODESPLIT>0.15427826344966888<CODESPLIT>0.15059736371040344

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/perry-mitchell/iocane/blob/3fe5c250a405fbe8a4da3d6977d7331655572694/source/encryption.js#L27-L48<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function decryptCBC ( encryptedComponents , keyDerivationInfo ) { // Extract the components const encryptedContent = encryptedComponents . content ; const iv = new Buffer ( encryptedComponents . iv , "hex" ) ; const salt = encryptedComponents . salt ; const hmacData = encryptedComponents . auth ; // Get HMAC tool const hmacTool = crypto . createHmac ( HMAC_ALGORITHM , keyDerivationInfo . hmac ) ; // Generate the HMAC hmacTool . update ( encryptedContent ) ; hmacTool . update ( encryptedComponents . iv ) ; hmacTool . update ( salt ) ; const newHmaxHex = hmacTool . digest ( "hex" ) ; // Check hmac for tampering if ( constantTimeCompare ( hmacData , newHmaxHex ) !== true ) { throw new Error ( "Authentication failed while decrypting content" ) ; } // Decrypt const decryptTool = crypto . createDecipheriv ( ENC_ALGORITHM_CBC , keyDerivationInfo . key , iv ) ; const decryptedText = decryptTool . update ( encryptedContent , "base64" , "utf8" ) ; return Promise . resolve ( ` ${ decryptedText } ${ decryptTool . final ( "utf8" ) } ` ) ; }<CODESPLIT>0.16901586949825287<CODESPLIT>0.12378162890672684

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/Strider-CD/strider/blob/56cafbc9687ebb7b67d485ec387a03cb85791c7c/lib/routes/admin/plugins/index.js#L12-L20<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( req , res , next ) { getPluginList ( function ( err , list ) { if ( err ) return next ( err ) ; res . render ( 'admin/plugins.html' , { plugins : list } ) ; } ) ; }<CODESPLIT>0.14895085990428925<CODESPLIT>0.1402093470096588

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L17700-L17705<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( objects ) { Ember . beginPropertyChanges ( this ) ; forEach ( objects , function ( obj ) { this . addObject ( obj ) ; } , this ) ; Ember . endPropertyChanges ( this ) ; return this ; }<CODESPLIT>0.15343084931373596<CODESPLIT>0.13075682520866394

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/intelligo-systems/intelligo.js/blob/9e75d48214fb41d346462f5d886bd92cc9956df6/dist/winnow/WinnowHash.js#L140-L149<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( dataset ) { //			var normalized_inputs = []; for ( var i = 0 ; i < dataset . length ; ++ i ) this . editFeatureValues ( dataset [ i ] . input , /*remove_unknown_features=*/ false ) ; //				normalized_inputs[i] = this.normalized_features(dataset[i].input, /*remove_unknown_features=*/false); for ( var r = 0 ; r <= this . retrain_count ; ++ r ) for ( var i = 0 ; i < dataset . length ; ++ i ) this . train_features ( dataset [ i ] . input , dataset [ i ] . output ) ; }<CODESPLIT>0.14332331717014313<CODESPLIT>0.14650434255599976

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/yortus/asyncawait/blob/7b4f573ecc7e388a1b05fa0c454bbe5d1b0154f2/src/await/makeAwaitFunc.js#L7-L14<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function makeAwaitFunc ( variant ) { // Return an await function tailored to the given options. switch ( variant ) { case 'in' : return getExtraInfo ( traverseInPlace ) ; case 'top' : return function ( n ) { return getExtraInfo ( traverseInPlace , n ) ; } ; default : return getExtraInfo ( traverseClone ) ; } }<CODESPLIT>0.15109209716320038<CODESPLIT>0.13991524279117584

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L17652-L17757<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function isRelatedTo ( source , target , reportErrors , headMessage ) { var result ; // both types are the same - covers 'they are the same primitive type or both are Any' or the same type parameter cases if ( source === target ) return - 1 /* True */ ; if ( relation === identityRelation ) { return isIdenticalTo ( source , target ) ; } if ( isTypeAny ( target ) ) return - 1 /* True */ ; if ( source === undefinedType ) return - 1 /* True */ ; if ( source === nullType && target !== undefinedType ) return - 1 /* True */ ; if ( source . flags & 128 /* Enum */ && target === numberType ) return - 1 /* True */ ; if ( source . flags & 256 /* StringLiteral */ && target === stringType ) return - 1 /* True */ ; if ( relation === assignableRelation ) { if ( isTypeAny ( source ) ) return - 1 /* True */ ; if ( source === numberType && target . flags & 128 /* Enum */ ) return - 1 /* True */ ; } if ( source . flags & 1048576 /* FreshObjectLiteral */ ) { if ( hasExcessProperties ( source , target , reportErrors ) ) { if ( reportErrors ) { reportRelationError ( headMessage , source , target ) ; } return 0 /* False */ ; } // Above we check for excess properties with respect to the entire target type. When union // and intersection types are further deconstructed on the target side, we don't want to // make the check again (as it might fail for a partial target type). Therefore we obtain // the regular source type and proceed with that. if ( target . flags & 49152 /* UnionOrIntersection */ ) { source = getRegularTypeOfObjectLiteral ( source ) ; } } var saveErrorInfo = errorInfo ; // Note that the "each" checks must precede the "some" checks to produce the correct results if ( source . flags & 16384 /* Union */ ) { if ( result = eachTypeRelatedToType ( source , target , reportErrors ) ) { return result ; } } else if ( target . flags & 32768 /* Intersection */ ) { if ( result = typeRelatedToEachType ( source , target , reportErrors ) ) { return result ; } } else { // It is necessary to try "some" checks on both sides because there may be nested "each" checks // on either side that need to be prioritized. For example, A | B = (A | B) & (C | D) or // A & B = (A & B) | (C & D). if ( source . flags & 32768 /* Intersection */ ) { // If target is a union type the following check will report errors so we suppress them here if ( result = someTypeRelatedToType ( source , target , reportErrors && ! ( target . flags & 16384 /* Union */ ) ) ) { return result ; } } if ( target . flags & 16384 /* Union */ ) { if ( result = typeRelatedToSomeType ( source , target , reportErrors ) ) { return result ; } } } if ( source . flags & 512 /* TypeParameter */ ) { var constraint = getConstraintOfTypeParameter ( source ) ; if ( ! constraint || constraint . flags & 1 /* Any */ ) { constraint = emptyObjectType ; } // Report constraint errors only if the constraint is not the empty object type var reportConstraintErrors = reportErrors && constraint !== emptyObjectType ; if ( result = isRelatedTo ( constraint , target , reportConstraintErrors ) ) { errorInfo = saveErrorInfo ; return result ; } } else { if ( source . flags & 4096 /* Reference */ && target . flags & 4096 /* Reference */ && source . target === target . target ) { // We have type references to same target type, see if relationship holds for all type arguments if ( result = typeArgumentsRelatedTo ( source , target , reportErrors ) ) { return result ; } } // Even if relationship doesn't hold for unions, intersections, or generic type references, // it may hold in a structural comparison. var apparentType = getApparentType ( source ) ; // In a check of the form X = A & B, we will have previously checked if A relates to X or B relates // to X. Failing both of those we want to check if the aggregation of A and B's members structurally // relates to X. Thus, we include intersection types on the source side here. if ( apparentType . flags & ( 80896 /* ObjectType */ | 32768 /* Intersection */ ) && target . flags & 80896 /* ObjectType */ ) { // Report structural errors only if we haven't reported any errors yet var reportStructuralErrors = reportErrors && errorInfo === saveErrorInfo ; if ( result = objectTypeRelatedTo ( apparentType , target , reportStructuralErrors ) ) { errorInfo = saveErrorInfo ; return result ; } } } if ( reportErrors ) { reportRelationError ( headMessage , source , target ) ; } return 0 /* False */ ; }<CODESPLIT>0.1650693267583847<CODESPLIT>0.13551612198352814

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/rootsdev/gedcomx-fs-js/blob/47b6c6c9a609e163d80673d08fc83073f730d9d8/src/ChildAndParentsRelationship.js#L10-L23<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( json ) { // Protect against forgetting the new keyword when calling the constructor if ( ! ( this instanceof ChildAndParentsRelationship ) ) { return new ChildAndParentsRelationship ( json ) ; } // If the given object is already an instance then just return it. DON'T copy it. if ( ChildAndParentsRelationship . isInstance ( json ) ) { return json ; } this . init ( json ) ; }<CODESPLIT>0.1339670717716217<CODESPLIT>0.15114785730838776

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/butlerx/event-page/blob/eddd2b530908c3ad8a95a13e822010691b3d2dc8/src/generate.js#L34-L55<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function render ( url ) { return async page => { try { const template = ` ${ page . template || 'schedule' } ` ; // Load template and compile const filePath = path . join ( process . cwd ( ) , config . theme || 'theme' , config . template || 'templates' , template , ) ; const output = Handlebars . compile ( await fs . readFile ( filePath , 'utf-8' ) ) ( page ) ; await fs . ensureDir ( outputDir ) ; // if home page skip else create page dir const dir = url !== 'index' ? path . join ( outputDir , url ) : outputDir ; await fs . ensureDir ( dir ) ; await fs . writeFile ( path . join ( dir , 'index.html' ) , output , 'utf8' ) ; } catch ( err ) { throw err ; } } ; }<CODESPLIT>0.16974952816963196<CODESPLIT>0.1369941085577011

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/evanmoran/oj/blob/7f05880e4a4572fd67ffb0f55223f66d8ea4e68d/versions/0.2.2/oj.js#L2173-L2200<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( ) { // Do nothing until fully constructed if ( ! this . isConstructed ) return // Some properties call make before construction completes var _t = this , ix , model , models , views , out // Convert models to views using each if ( ( this . models != null ) && ( this . each != null ) ) { // Get list of models from collection or array models = oj . isEvented ( this . models ) ? this . models . models : this . models // Add view item for every model views = models . map ( function ( model ) { return _t . _itemFromModel ( model ) } ) // Items are already views so just use them } else if ( this . items != null ) { views = this . items } // Render the views this . $el . oj ( function ( ) { return views . map ( function ( view ) { _t . _itemElFromItem ( view ) } ) } ) // Indicate to CollectionView the items changed this . itemsChanged ( ) }<CODESPLIT>0.16199705004692078<CODESPLIT>0.13091157376766205

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/alexisvincent/systemjs-hot-reloader/blob/e3cca45a50e69cba4c1988a251ef07f460c27619/dist/index.js#L700-L743<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function parse$1 ( str ) { str = '' + str ; if ( str . length > 10000 ) return ; var match = / ^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$ / i . exec ( str ) ; if ( ! match ) return ; var n = parseFloat ( match [ 1 ] ) ; var type = ( match [ 2 ] || 'ms' ) . toLowerCase ( ) ; switch ( type ) { case 'years' : case 'year' : case 'yrs' : case 'yr' : case 'y' : return n * y$1 ; case 'days' : case 'day' : case 'd' : return n * d$2 ; case 'hours' : case 'hour' : case 'hrs' : case 'hr' : case 'h' : return n * h$1 ; case 'minutes' : case 'minute' : case 'mins' : case 'min' : case 'm' : return n * m$1 ; case 'seconds' : case 'second' : case 'secs' : case 'sec' : case 's' : return n * s$1 ; case 'milliseconds' : case 'millisecond' : case 'msecs' : case 'msec' : case 'ms' : return n ; } }<CODESPLIT>0.1478355973958969<CODESPLIT>0.12796977162361145

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/localnerve/html-snapshots/blob/63e829b234a8fa1399da1f7347a7fb3463e862a8/lib/input-generators/_base.js#L124-L145<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getOutputPath ( options , page , parse ) { var pagePart = urlm . parse ( page ) , // if outputPath was normalized with an object, let the key passthru outputPath = options . outputPath ( page , true ) ; // check for bad output path if ( ! outputPath ) { return false ; } // if the outputPath is really still a url, fix it to path+hash if ( common . isUrl ( outputPath ) ) { outputPath = pagePart . path + ( pagePart . hash ? pagePart . hash : "" ) ; } // if the caller wants the url parse output, return it if ( parse ) { parse . url = pagePart ; } return outputPath ; }<CODESPLIT>0.16696564853191376<CODESPLIT>0.1344204843044281

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/Quartz/Chartbuilder/blob/fc6ce64e73b9ef378223afcab7057020f6dce260/src/js/util/parse-utils.js#L10-L19<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function detectDelimiter ( input ) { var numRows = input . split ( / \r\n|\r|\n / ) . length ; var numTabs = input . replace ( tabRegex , "" ) . length ; if ( numTabs >= numRows - 1 ) { return "\t" ; } else { return "," ; } }<CODESPLIT>0.1153065636754036<CODESPLIT>0.15221340954303741

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/olindata/node-puppet-hiera/blob/fda35ca55ae054641f428873c9f2f763ea302422/index.js#L80-L89<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getBackends ( cb ) { getConfig ( function ( err , config ) { if ( err ) { cb ( err ) ; return ; } cb ( null , config [ ':backends' ] ) ; } ) ; }<CODESPLIT>0.15096929669380188<CODESPLIT>0.13453856110572815

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/everitoken/evtjs/blob/87d5dac3ae3205e654821c03c010e4738fc4b8a1/src/bigi/lib/bigi.js#L32-L39<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function am1 ( i , x , w , j , c , n ) { while ( -- n >= 0 ) { var v = x * this [ i ++ ] + w [ j ] + c c = Math . floor ( v / 0x4000000 ) w [ j ++ ] = v & 0x3ffffff } return c }<CODESPLIT>0.14372669160366058<CODESPLIT>0.14414583146572113

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L36537-L36561<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( params , transition ) { var match , name , sawParams , value ; for ( var prop in params ) { if ( prop === 'queryParams' ) { continue ; } if ( match = prop . match ( / ^(.*)_id$ / ) ) { name = match [ 1 ] ; value = params [ prop ] ; } sawParams = true ; } if ( ! name && sawParams ) { return Ember . copy ( params ) ; } else if ( ! name ) { if ( transition . resolveIndex !== transition . state . handlerInfos . length - 1 ) { return ; } var parentModel = transition . state . handlerInfos [ transition . resolveIndex - 1 ] . context ; return parentModel ; } return this . findModel ( name , value ) ; }<CODESPLIT>0.14509707689285278<CODESPLIT>0.1625663787126541

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/Tom-Alexander/regression-js/blob/7995fd9955ca23a8a99834a9f28aa9c8adc7ad19/src/regression.js#L49-L85<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function gaussianElimination ( input , order ) { const matrix = input ; const n = input . length - 1 ; const coefficients = [ order ] ; for ( let i = 0 ; i < n ; i ++ ) { let maxrow = i ; for ( let j = i + 1 ; j < n ; j ++ ) { if ( Math . abs ( matrix [ i ] [ j ] ) > Math . abs ( matrix [ i ] [ maxrow ] ) ) { maxrow = j ; } } for ( let k = i ; k < n + 1 ; k ++ ) { const tmp = matrix [ k ] [ i ] ; matrix [ k ] [ i ] = matrix [ k ] [ maxrow ] ; matrix [ k ] [ maxrow ] = tmp ; } for ( let j = i + 1 ; j < n ; j ++ ) { for ( let k = n ; k >= i ; k -- ) { matrix [ k ] [ j ] -= ( matrix [ k ] [ i ] * matrix [ i ] [ j ] ) / matrix [ i ] [ i ] ; } } } for ( let j = n - 1 ; j >= 0 ; j -- ) { let total = 0 ; for ( let k = j + 1 ; k < n ; k ++ ) { total += matrix [ k ] [ j ] * coefficients [ k ] ; } coefficients [ j ] = ( matrix [ n ] [ j ] - total ) / matrix [ j ] [ j ] ; } return coefficients ; }<CODESPLIT>0.17661023139953613<CODESPLIT>0.12385708838701248

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/alexisvincent/systemjs-hot-reloader/blob/e3cca45a50e69cba4c1988a251ef07f460c27619/dist/index.js#L684-L690<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( val , options ) { options = options || { } ; if ( 'string' == typeof val ) return parse$1 ( val ) ; return options . long ? long ( val ) : short ( val ) ; }<CODESPLIT>0.1435302495956421<CODESPLIT>0.12842945754528046

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/apache/cordova-lib/blob/dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5/spec/cordova/fixtures/projects/platformApi/platforms/windows/cordova/lib/PluginInfo.js#L103-L113<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function createReplacement ( manifestFile , originalChange ) { var replacement = { target : manifestFile , parent : originalChange . parent , after : originalChange . after , xmls : originalChange . xmls , versions : originalChange . versions , deviceTarget : originalChange . deviceTarget } ; return replacement ; }<CODESPLIT>0.15632958710193634<CODESPLIT>0.15373525023460388

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/auth0/auth0-angular/blob/3c47a3b3fc4aee9741ff2273adbb82597f83dfe8/build/auth0-angular.js#L258-L261<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getInnerLibraryConfigField ( name , libName ) { libName = libName || config . lib ; return innerAuth0libraryConfiguration [ libName ] [ name ] ; }<CODESPLIT>0.18408203125<CODESPLIT>0.13414360582828522

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L38809-L38814<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( ) { // target may be either another controller or a router var target = get ( this , 'target' ) , method = target . transitionToRoute || target . transitionTo ; return method . apply ( target , arguments ) ; }<CODESPLIT>0.10346389561891556<CODESPLIT>0.158931702375412

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/Kashoo/synctos/blob/a6d59b4d4af2b837842d2107c57064c3fa12cc73/lib/commander/index.js#L1192-L1200<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function outputHelpIfNecessary ( cmd , options ) { options = options || [ ] ; for ( var i = 0 ; i < options . length ; i ++ ) { if ( options [ i ] === '--help' || options [ i ] === '-h' ) { cmd . outputHelp ( ) ; process . exit ( 0 ) ; } } }<CODESPLIT>0.1549765020608902<CODESPLIT>0.1238059252500534

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/todvora/policecz-vehicles-client/blob/5b0bdb38c7cb135adf03edf89f77adadb280af0d/lib/client.js#L49-L56<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function formatDetails ( details ) { let result = { results : details , count : details . length , time : new Date ( ) . toISOString ( ) } ; return result ; }<CODESPLIT>0.15149317681789398<CODESPLIT>0.14849646389484406

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/G-E-O-F/peels/blob/09ed8c202b2585b33c8c15f14932f1fcba4adbf0/lib/sphere/from-raster.js#L202-L255<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function fromRaster ( data , width , height , depth , map , done ) { var sphere = this ; populateInterfieldData . call ( sphere ) ; var bmp = new Bitmap ( width , height ) ; sphere . _Fields . forEach ( function ( field ) { var geo = _fieldGeometry . call ( field ) , selection = _populateSelectionGrid ( bmp , geo , width , height ) ; var valSums = [ ] , weightSum = 0 ; for ( let z = 0 ; z < depth ; z += 1 ) { valSums [ z ] = 0 ; } for ( let x = selection . min_x ; x < selection . max_x ; x += 1 ) { for ( let y = selection . min_y ; y < selection . max_y ; y += 1 ) { let w = _testPoints ( bmp , x , y ) / 4 ; for ( let z = 0 ; z < depth ; z += 1 ) { valSums [ z ] += data [ ( height - y - 1 ) * width * depth + ( width - x - 1 ) * depth + z ] * w ; } weightSum += w ; } } if ( weightSum <= 0 ) debugger ; // weight sum should never be non-positive map . apply ( field , valSums . map ( ( val ) => { return val / weightSum } ) ) ; bmp . clear ( selection . max_x - selection . min_x , selection . max_y - selection . min_y , selection . min_x , selection . min_y ) ; } ) ; done ( ) ; }<CODESPLIT>0.1710071861743927<CODESPLIT>0.1287936568260193

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/datastax/nodejs-driver/blob/6766188870f7099aeb393719820245b69d789d23/lib/metadata/aggregate.js#L9-L55<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function Aggregate ( ) { /**    * Name of the aggregate.    * @type {String}    */ this . name = null ; /**    * Name of the keyspace where the aggregate is declared.    */ this . keyspaceName = null ; /**    * Signature of the aggregate.    * @type {Array.<String>}    */ this . signature = null ; /**    * List of the CQL aggregate argument types.    * @type {Array.<{code, info}>}    */ this . argumentTypes = null ; /**    * State Function.    * @type {String}    */ this . stateFunction = null ; /**    * State Type.    * @type {{code, info}}    */ this . stateType = null ; /**    * Final Function.    * @type {String}    */ this . finalFunction = null ; this . initConditionRaw = null ; /**    * Initial state value of this aggregate.    * @type {String}    */ this . initCondition = null ; /**    * Type of the return value.    * @type {{code: number, info: (Object|Array|null)}}    */ this . returnType = null ; }<CODESPLIT>0.17539770901203156<CODESPLIT>0.13182935118675232

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/feathers-plus/feathers-offline-realtime/blob/568de3b7443be6ae58eeb7be64880c76da905dc0/src/commons/optimistic-mutator.js#L249-L257<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function findUuidIndex ( array , uuid ) { for ( let i = 0 , len = array . length ; i < len ; i ++ ) { if ( array [ i ] . uuid == uuid ) { // eslint-disable-line  return i ; } } return - 1 ; }<CODESPLIT>0.16061809659004211<CODESPLIT>0.13889971375465393

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/apache/cordova-lib/blob/dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5/src/cordova/project_metadata.js#L28-L48<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getPlatforms ( projectRoot ) { var xml = cordova_util . projectConfig ( projectRoot ) ; var cfg = new ConfigParser ( xml ) ; // If an engine's 'version' property is really its source, map that to the appropriate field. var engines = cfg . getEngines ( ) . map ( function ( engine ) { var result = { name : engine . name } ; if ( semver . validRange ( engine . spec , true ) ) { result . version = engine . spec ; } else { result . src = engine . spec ; } return result ; } ) ; return Promise . resolve ( engines ) ; }<CODESPLIT>0.16186124086380005<CODESPLIT>0.13830599188804626

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/hapjs/action-sheet/blob/5d8bd05d8f69a1e2ab5ddd399c69bffb1c86b358/lib/tethys.js#L166-L174<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( cls ) { var has = false , reg = new RegExp ( '\\b' + cls + '\\b' ) ; this . each ( function ( el ) { has = has || ! ! el . className . match ( reg ) ; } ) ; return has ; }<CODESPLIT>0.11007241159677505<CODESPLIT>0.16601262986660004

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/easynode/nenos/blob/246e21c1bc29fa00094423b9a940463826299233/lib/index.js#L281-L303<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getMeta ( host , accessKey , secretKey , bucket , objectKey ) { var expires = arguments . length <= 5 || arguments [ 5 ] === undefined ? 0 : arguments [ 5 ] ; var opts = arguments . length <= 6 || arguments [ 6 ] === undefined ? { } : arguments [ 6 ] ; var date = utcDate ( ) ; if ( opts . versionId ) url += '?versionId=' + opts . versionId ; var resource = genResource ( bucket , objectKey , ( 0 , _lodash . pick ) ( opts , [ 'versionId' ] ) ) ; var authorization = authorize ( accessKey , secretKey , 'HEAD' , '' , '' , date , [ ] , resource ) ; var signature = ( 0 , _urlencode2 . default ) ( generateSignature ( secretKey , 'HEAD' , '' , '' , date , [ ] , resource ) ) ; var url = pub ? 'http://' + bucket + '.' + host + '/' + objectKey : 'http://' + host + '/' + bucket + '/' + objectKey + '?NOSAccessKeyId=' + accessKey + '&Expires=' + expires + '&Signature=' + signature ; var headers = { Date : date } ; if ( opts . modifiedSince ) headers [ 'If-Modified-Since' ] = opts . modifiedSince ; headers [ 'url' ] = url ; return nosRequest ( { method : 'head' , uri : url , headers : headers } ) . then ( function ( res ) { var contentType = res [ 'content-type' ] ; var lastModified = res [ 'last-modified' ] ; var etag = res [ 'etag' ] ; var requestId = res [ 'x-nos-request-id' ] ; return { contentType : contentType , lastModified : lastModified , etag : etag , requestId : requestId } ; } ) ; }<CODESPLIT>0.16684459149837494<CODESPLIT>0.14344801008701324

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/moxiecode/moxie/blob/09eaf578f38480dc4b8e2017c473c496883b6168/src/javascript/xhr/XMLHttpRequest.js#L499-L524<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( mime ) { var matches , charset ; // 1 if ( ! ! ~ Basic . inArray ( _p ( 'readyState' ) , [ XMLHttpRequest . LOADING , XMLHttpRequest . DONE ] ) ) { throw new x . DOMException ( x . DOMException . INVALID_STATE_ERR ) ; } // 2 mime = Basic . trim ( mime . toLowerCase ( ) ) ; if ( / ; / . test ( mime ) && ( matches = mime . match ( / ^([^;]+)(?:;\scharset\=)?(.*)$ / ) ) ) { mime = matches [ 1 ] ; if ( matches [ 2 ] ) { charset = matches [ 2 ] ; } } if ( ! Mime . mimes [ mime ] ) { throw new x . DOMException ( x . DOMException . SYNTAX_ERR ) ; } // 3-4 _finalMime = mime ; _finalCharset = charset ; }<CODESPLIT>0.15617558360099792<CODESPLIT>0.14679323136806488

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L17103-L17108<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function createTypedPropertyDescriptorType ( propertyType ) { var globalTypedPropertyDescriptorType = getGlobalTypedPropertyDescriptorType ( ) ; return globalTypedPropertyDescriptorType !== emptyGenericType ? createTypeReference ( globalTypedPropertyDescriptorType , [ propertyType ] ) : emptyObjectType ; }<CODESPLIT>0.1702270358800888<CODESPLIT>0.14024722576141357

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/andrao/node-analytics/blob/170bca2d2985cc384aa584b0e588221a96630834/node-analytics.js#L408-L493<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getSession ( req , res , cb ) { const now = new Date ( ) ; const cookies = getCookies ( req . headers . cookie ) ; // cookies.na_session  :: session._id // cookies.na_user     :: session.user // Establish session: new/old session? new/old user? if ( cookies . na_session ) { if ( opts . log_all ) log ( 'Session cookie found:' , cookies . na_session ) ; Session . findById ( cookies . na_session , session_fields ) . lean ( ) . exec ( function ( err , session ) { if ( err ) { log . error ( 'getSession error' , err ) ; return cb ( err ) ; } if ( ! session ) { log . error ( 'Session not found :: id[cookie]:' , this . cookies . na_session ) ; // send to check if user instead if ( cookies . na_user ) userSession ( ) ; else newSession ( ) ; } else { Update . session ( session , { $set : { last : Date . now ( ) } } , ( err , session ) => { if ( err ) { log . error ( 'establish session / update error' ) ; return cb ( true ) ; } session . continued = true ; cb ( err , this . req , this . res , session ) } ) ; } } . bind ( { cookies : cookies , req : req , res : res } ) ) } else if ( cookies . na_user ) userSession ( ) ; else newSession ( ) ; // ==================== function userSession ( ) { // OLD USER, NEW SESSION cb ( null , req , res , new Session ( { user : cookies . na_user , new_session : true } ) . toObject ( { virtuals : true } ) ) ; if ( opts . log_all ) log . timer ( 'getSession 1' , now ) ; } function newSession ( ) { // NEW USER, NEW SESSION // Initiate session to get _id let session = new Session ( ) ; session . user = session . _id . toString ( ) ; session . new_user = true ; session = session . toObject ( { virtuals : true } ) ; cb ( null , req , res , session ) ; if ( opts . log_all ) log . timer ( 'getSession 2' , now ) ; } }<CODESPLIT>0.17288143932819366<CODESPLIT>0.13714095950126648

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L18161-L18194<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( opts ) { opts = opts || { } ; var action = opts . action || get ( this , 'action' ) , target = opts . target || get ( this , 'targetObject' ) , actionContext = opts . actionContext ; function args ( options , actionName ) { var ret = [ ] ; if ( actionName ) { ret . push ( actionName ) ; } return ret . concat ( options ) ; } if ( typeof actionContext === 'undefined' ) { actionContext = get ( this , 'actionContextObject' ) || this ; } if ( target && action ) { var ret ; if ( target . send ) { ret = target . send . apply ( target , args ( actionContext , action ) ) ; } else { Ember . assert ( "The action '" + action + "' did not exist on " + target , typeof target [ action ] === 'function' ) ; ret = target [ action ] . apply ( target , args ( actionContext ) ) ; } if ( ret !== false ) ret = true ; return ret ; } else { return false ; } }<CODESPLIT>0.16000203788280487<CODESPLIT>0.13173827528953552

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/multiformats/js-multistream-select/blob/9854a1de5f44249a5d75a193f9033b4067403142/src/util.js#L17-L28<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function encode ( msg , callback ) { pull ( values ( Buffer . isBuffer ( msg ) ? [ msg ] : [ Buffer . from ( msg ) ] ) , pullLP . encode ( ) , collect ( ( err , encoded ) => { if ( err ) { return callback ( err ) } callback ( null , encoded [ 0 ] ) } ) ) }<CODESPLIT>0.13799327611923218<CODESPLIT>0.16666412353515625

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/braintree/credit-card-type/blob/bdeee729994532530fa53d6d6ce072d0aeba13ac/lib/matches.js#L4-L13<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function matchesRange ( cardNumber , min , max ) { var maxLengthToCheck = String ( min ) . length ; var substr = cardNumber . substr ( 0 , maxLengthToCheck ) ; var integerRepresentationOfCardNumber = parseInt ( substr , 10 ) ; min = parseInt ( String ( min ) . substr ( 0 , substr . length ) , 10 ) ; max = parseInt ( String ( max ) . substr ( 0 , substr . length ) , 10 ) ; return integerRepresentationOfCardNumber >= min && integerRepresentationOfCardNumber <= max ; }<CODESPLIT>0.15387384593486786<CODESPLIT>0.13538271188735962

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L3251-L4154<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function createScanner ( languageVersion , skipTrivia , languageVariant , text , onError , start , length ) { if ( languageVariant === void 0 ) { languageVariant = 0 /* Standard */ ; } // Current position (end position of text of current token) var pos ; // end of text var end ; // Start position of whitespace before current token var startPos ; // Start position of text of current token var tokenPos ; var token ; var tokenValue ; var precedingLineBreak ; var hasExtendedUnicodeEscape ; var tokenIsUnterminated ; setText ( text , start , length ) ; return { getStartPos : function ( ) { return startPos ; } , getTextPos : function ( ) { return pos ; } , getToken : function ( ) { return token ; } , getTokenPos : function ( ) { return tokenPos ; } , getTokenText : function ( ) { return text . substring ( tokenPos , pos ) ; } , getTokenValue : function ( ) { return tokenValue ; } , hasExtendedUnicodeEscape : function ( ) { return hasExtendedUnicodeEscape ; } , hasPrecedingLineBreak : function ( ) { return precedingLineBreak ; } , isIdentifier : function ( ) { return token === 69 /* Identifier */ || token > 105 /* LastReservedWord */ ; } , isReservedWord : function ( ) { return token >= 70 /* FirstReservedWord */ && token <= 105 /* LastReservedWord */ ; } , isUnterminated : function ( ) { return tokenIsUnterminated ; } , reScanGreaterToken : reScanGreaterToken , reScanSlashToken : reScanSlashToken , reScanTemplateToken : reScanTemplateToken , scanJsxIdentifier : scanJsxIdentifier , reScanJsxToken : reScanJsxToken , scanJsxToken : scanJsxToken , scan : scan , setText : setText , setScriptTarget : setScriptTarget , setLanguageVariant : setLanguageVariant , setOnError : setOnError , setTextPos : setTextPos , tryScan : tryScan , lookAhead : lookAhead } ; function error ( message , length ) { if ( onError ) { onError ( message , length || 0 ) ; } } function scanNumber ( ) { var start = pos ; while ( isDigit ( text . charCodeAt ( pos ) ) ) pos ++ ; if ( text . charCodeAt ( pos ) === 46 /* dot */ ) { pos ++ ; while ( isDigit ( text . charCodeAt ( pos ) ) ) pos ++ ; } var end = pos ; if ( text . charCodeAt ( pos ) === 69 /* E */ || text . charCodeAt ( pos ) === 101 /* e */ ) { pos ++ ; if ( text . charCodeAt ( pos ) === 43 /* plus */ || text . charCodeAt ( pos ) === 45 /* minus */ ) pos ++ ; if ( isDigit ( text . charCodeAt ( pos ) ) ) { pos ++ ; while ( isDigit ( text . charCodeAt ( pos ) ) ) pos ++ ; end = pos ; } else { error ( ts . Diagnostics . Digit_expected ) ; } } return + ( text . substring ( start , end ) ) ; } function scanOctalDigits ( ) { var start = pos ; while ( isOctalDigit ( text . charCodeAt ( pos ) ) ) { pos ++ ; } return + ( text . substring ( start , pos ) ) ; } /**          * Scans the given number of hexadecimal digits in the text,          * returning -1 if the given number is unavailable.          */ function scanExactNumberOfHexDigits ( count ) { return scanHexDigits ( /*minCount*/ count , /*scanAsManyAsPossible*/ false ) ; } /**          * Scans as many hexadecimal digits as are available in the text,          * returning -1 if the given number of digits was unavailable.          */ function scanMinimumNumberOfHexDigits ( count ) { return scanHexDigits ( /*minCount*/ count , /*scanAsManyAsPossible*/ true ) ; } function scanHexDigits ( minCount , scanAsManyAsPossible ) { var digits = 0 ; var value = 0 ; while ( digits < minCount || scanAsManyAsPossible ) { var ch = text . charCodeAt ( pos ) ; if ( ch >= 48 /* _0 */ && ch <= 57 /* _9 */ ) { value = value * 16 + ch - 48 /* _0 */ ; } else if ( ch >= 65 /* A */ && ch <= 70 /* F */ ) { value = value * 16 + ch - 65 /* A */ + 10 ; } else if ( ch >= 97 /* a */ && ch <= 102 /* f */ ) { value = value * 16 + ch - 97 /* a */ + 10 ; } else { break ; } pos ++ ; digits ++ ; } if ( digits < minCount ) { value = - 1 ; } return value ; } function scanString ( ) { var quote = text . charCodeAt ( pos ++ ) ; var result = "" ; var start = pos ; while ( true ) { if ( pos >= end ) { result += text . substring ( start , pos ) ; tokenIsUnterminated = true ; error ( ts . Diagnostics . Unterminated_string_literal ) ; break ; } var ch = text . charCodeAt ( pos ) ; if ( ch === quote ) { result += text . substring ( start , pos ) ; pos ++ ; break ; } if ( ch === 92 /* backslash */ ) { result += text . substring ( start , pos ) ; result += scanEscapeSequence ( ) ; start = pos ; continue ; } if ( isLineBreak ( ch ) ) { result += text . substring ( start , pos ) ; tokenIsUnterminated = true ; error ( ts . Diagnostics . Unterminated_string_literal ) ; break ; } pos ++ ; } return result ; } /**          * Sets the current 'tokenValue' and returns a NoSubstitutionTemplateLiteral or          * a literal component of a TemplateExpression.          */ function scanTemplateAndSetTokenValue ( ) { var startedWithBacktick = text . charCodeAt ( pos ) === 96 /* backtick */ ; pos ++ ; var start = pos ; var contents = "" ; var resultingToken ; while ( true ) { if ( pos >= end ) { contents += text . substring ( start , pos ) ; tokenIsUnterminated = true ; error ( ts . Diagnostics . Unterminated_template_literal ) ; resultingToken = startedWithBacktick ? 11 /* NoSubstitutionTemplateLiteral */ : 14 /* TemplateTail */ ; break ; } var currChar = text . charCodeAt ( pos ) ; // '`' if ( currChar === 96 /* backtick */ ) { contents += text . substring ( start , pos ) ; pos ++ ; resultingToken = startedWithBacktick ? 11 /* NoSubstitutionTemplateLiteral */ : 14 /* TemplateTail */ ; break ; } // '${' if ( currChar === 36 /* $ */ && pos + 1 < end && text . charCodeAt ( pos + 1 ) === 123 /* openBrace */ ) { contents += text . substring ( start , pos ) ; pos += 2 ; resultingToken = startedWithBacktick ? 12 /* TemplateHead */ : 13 /* TemplateMiddle */ ; break ; } // Escape character if ( currChar === 92 /* backslash */ ) { contents += text . substring ( start , pos ) ; contents += scanEscapeSequence ( ) ; start = pos ; continue ; } // Speculated ECMAScript 6 Spec 11.8.6.1: // <CR><LF> and <CR> LineTerminatorSequences are normalized to <LF> for Template Values if ( currChar === 13 /* carriageReturn */ ) { contents += text . substring ( start , pos ) ; pos ++ ; if ( pos < end && text . charCodeAt ( pos ) === 10 /* lineFeed */ ) { pos ++ ; } contents += "\n" ; start = pos ; continue ; } pos ++ ; } ts . Debug . assert ( resultingToken !== undefined ) ; tokenValue = contents ; return resultingToken ; } function scanEscapeSequence ( ) { pos ++ ; if ( pos >= end ) { error ( ts . Diagnostics . Unexpected_end_of_text ) ; return "" ; } var ch = text . charCodeAt ( pos ++ ) ; switch ( ch ) { case 48 /* _0 */ : return "\0" ; case 98 /* b */ : return "\b" ; case 116 /* t */ : return "\t" ; case 110 /* n */ : return "\n" ; case 118 /* v */ : return "\v" ; case 102 /* f */ : return "\f" ; case 114 /* r */ : return "\r" ; case 39 /* singleQuote */ : return "\'" ; case 34 /* doubleQuote */ : return "\"" ; case 117 /* u */ : // '\u{DDDDDDDD}' if ( pos < end && text . charCodeAt ( pos ) === 123 /* openBrace */ ) { hasExtendedUnicodeEscape = true ; pos ++ ; return scanExtendedUnicodeEscape ( ) ; } // '\uDDDD' return scanHexadecimalEscape ( /*numDigits*/ 4 ) ; case 120 /* x */ : // '\xDD' return scanHexadecimalEscape ( /*numDigits*/ 2 ) ; // when encountering a LineContinuation (i.e. a backslash and a line terminator sequence), // the line terminator is interpreted to be "the empty code unit sequence". case 13 /* carriageReturn */ : if ( pos < end && text . charCodeAt ( pos ) === 10 /* lineFeed */ ) { pos ++ ; } // fall through case 10 /* lineFeed */ : case 8232 /* lineSeparator */ : case 8233 /* paragraphSeparator */ : return "" ; default : return String . fromCharCode ( ch ) ; } } function scanHexadecimalEscape ( numDigits ) { var escapedValue = scanExactNumberOfHexDigits ( numDigits ) ; if ( escapedValue >= 0 ) { return String . fromCharCode ( escapedValue ) ; } else { error ( ts . Diagnostics . Hexadecimal_digit_expected ) ; return "" ; } } function scanExtendedUnicodeEscape ( ) { var escapedValue = scanMinimumNumberOfHexDigits ( 1 ) ; var isInvalidExtendedEscape = false ; // Validate the value of the digit if ( escapedValue < 0 ) { error ( ts . Diagnostics . Hexadecimal_digit_expected ) ; isInvalidExtendedEscape = true ; } else if ( escapedValue > 0x10FFFF ) { error ( ts . Diagnostics . An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive ) ; isInvalidExtendedEscape = true ; } if ( pos >= end ) { error ( ts . Diagnostics . Unexpected_end_of_text ) ; isInvalidExtendedEscape = true ; } else if ( text . charCodeAt ( pos ) === 125 /* closeBrace */ ) { // Only swallow the following character up if it's a '}'. pos ++ ; } else { error ( ts . Diagnostics . Unterminated_Unicode_escape_sequence ) ; isInvalidExtendedEscape = true ; } if ( isInvalidExtendedEscape ) { return "" ; } return utf16EncodeAsString ( escapedValue ) ; } // Derived from the 10.1.1 UTF16Encoding of the ES6 Spec. function utf16EncodeAsString ( codePoint ) { ts . Debug . assert ( 0x0 <= codePoint && codePoint <= 0x10FFFF ) ; if ( codePoint <= 65535 ) { return String . fromCharCode ( codePoint ) ; } var codeUnit1 = Math . floor ( ( codePoint - 65536 ) / 1024 ) + 0xD800 ; var codeUnit2 = ( ( codePoint - 65536 ) % 1024 ) + 0xDC00 ; return String . fromCharCode ( codeUnit1 , codeUnit2 ) ; } // Current character is known to be a backslash. Check for Unicode escape of the form '\uXXXX' // and return code point value if valid Unicode escape is found. Otherwise return -1. function peekUnicodeEscape ( ) { if ( pos + 5 < end && text . charCodeAt ( pos + 1 ) === 117 /* u */ ) { var start_1 = pos ; pos += 2 ; var value = scanExactNumberOfHexDigits ( 4 ) ; pos = start_1 ; return value ; } return - 1 ; } function scanIdentifierParts ( ) { var result = "" ; var start = pos ; while ( pos < end ) { var ch = text . charCodeAt ( pos ) ; if ( isIdentifierPart ( ch , languageVersion ) ) { pos ++ ; } else if ( ch === 92 /* backslash */ ) { ch = peekUnicodeEscape ( ) ; if ( ! ( ch >= 0 && isIdentifierPart ( ch , languageVersion ) ) ) { break ; } result += text . substring ( start , pos ) ; result += String . fromCharCode ( ch ) ; // Valid Unicode escape is always six characters pos += 6 ; start = pos ; } else { break ; } } result += text . substring ( start , pos ) ; return result ; } function getIdentifierToken ( ) { // Reserved words are between 2 and 11 characters long and start with a lowercase letter var len = tokenValue . length ; if ( len >= 2 && len <= 11 ) { var ch = tokenValue . charCodeAt ( 0 ) ; if ( ch >= 97 /* a */ && ch <= 122 /* z */ && hasOwnProperty . call ( textToToken , tokenValue ) ) { return token = textToToken [ tokenValue ] ; } } return token = 69 /* Identifier */ ; } function scanBinaryOrOctalDigits ( base ) { ts . Debug . assert ( base !== 2 || base !== 8 , "Expected either base 2 or base 8" ) ; var value = 0 ; // For counting number of digits; Valid binaryIntegerLiteral must have at least one binary digit following B or b. // Similarly valid octalIntegerLiteral must have at least one octal digit following o or O. var numberOfDigits = 0 ; while ( true ) { var ch = text . charCodeAt ( pos ) ; var valueOfCh = ch - 48 /* _0 */ ; if ( ! isDigit ( ch ) || valueOfCh >= base ) { break ; } value = value * base + valueOfCh ; pos ++ ; numberOfDigits ++ ; } // Invalid binaryIntegerLiteral or octalIntegerLiteral if ( numberOfDigits === 0 ) { return - 1 ; } return value ; } function scan ( ) { startPos = pos ; hasExtendedUnicodeEscape = false ; precedingLineBreak = false ; tokenIsUnterminated = false ; while ( true ) { tokenPos = pos ; if ( pos >= end ) { return token = 1 /* EndOfFileToken */ ; } var ch = text . charCodeAt ( pos ) ; // Special handling for shebang if ( ch === 35 /* hash */ && pos === 0 && isShebangTrivia ( text , pos ) ) { pos = scanShebangTrivia ( text , pos ) ; if ( skipTrivia ) { continue ; } else { return token = 6 /* ShebangTrivia */ ; } } switch ( ch ) { case 10 /* lineFeed */ : case 13 /* carriageReturn */ : precedingLineBreak = true ; if ( skipTrivia ) { pos ++ ; continue ; } else { if ( ch === 13 /* carriageReturn */ && pos + 1 < end && text . charCodeAt ( pos + 1 ) === 10 /* lineFeed */ ) { // consume both CR and LF pos += 2 ; } else { pos ++ ; } return token = 4 /* NewLineTrivia */ ; } case 9 /* tab */ : case 11 /* verticalTab */ : case 12 /* formFeed */ : case 32 /* space */ : if ( skipTrivia ) { pos ++ ; continue ; } else { while ( pos < end && isWhiteSpace ( text . charCodeAt ( pos ) ) ) { pos ++ ; } return token = 5 /* WhitespaceTrivia */ ; } case 33 /* exclamation */ : if ( text . charCodeAt ( pos + 1 ) === 61 /* equals */ ) { if ( text . charCodeAt ( pos + 2 ) === 61 /* equals */ ) { return pos += 3 , token = 33 /* ExclamationEqualsEqualsToken */ ; } return pos += 2 , token = 31 /* ExclamationEqualsToken */ ; } return pos ++ , token = 49 /* ExclamationToken */ ; case 34 /* doubleQuote */ : case 39 /* singleQuote */ : tokenValue = scanString ( ) ; return token = 9 /* StringLiteral */ ; case 96 /* backtick */ : return token = scanTemplateAndSetTokenValue ( ) ; case 37 /* percent */ : if ( text . charCodeAt ( pos + 1 ) === 61 /* equals */ ) { return pos += 2 , token = 62 /* PercentEqualsToken */ ; } return pos ++ , token = 40 /* PercentToken */ ; case 38 /* ampersand */ : if ( text . charCodeAt ( pos + 1 ) === 38 /* ampersand */ ) { return pos += 2 , token = 51 /* AmpersandAmpersandToken */ ; } if ( text . charCodeAt ( pos + 1 ) === 61 /* equals */ ) { return pos += 2 , token = 66 /* AmpersandEqualsToken */ ; } return pos ++ , token = 46 /* AmpersandToken */ ; case 40 /* openParen */ : return pos ++ , token = 17 /* OpenParenToken */ ; case 41 /* closeParen */ : return pos ++ , token = 18 /* CloseParenToken */ ; case 42 /* asterisk */ : if ( text . charCodeAt ( pos + 1 ) === 61 /* equals */ ) { return pos += 2 , token = 59 /* AsteriskEqualsToken */ ; } if ( text . charCodeAt ( pos + 1 ) === 42 /* asterisk */ ) { if ( text . charCodeAt ( pos + 2 ) === 61 /* equals */ ) { return pos += 3 , token = 60 /* AsteriskAsteriskEqualsToken */ ; } return pos += 2 , token = 38 /* AsteriskAsteriskToken */ ; } return pos ++ , token = 37 /* AsteriskToken */ ; case 43 /* plus */ : if ( text . charCodeAt ( pos + 1 ) === 43 /* plus */ ) { return pos += 2 , token = 41 /* PlusPlusToken */ ; } if ( text . charCodeAt ( pos + 1 ) === 61 /* equals */ ) { return pos += 2 , token = 57 /* PlusEqualsToken */ ; } return pos ++ , token = 35 /* PlusToken */ ; case 44 /* comma */ : return pos ++ , token = 24 /* CommaToken */ ; case 45 /* minus */ : if ( text . charCodeAt ( pos + 1 ) === 45 /* minus */ ) { return pos += 2 , token = 42 /* MinusMinusToken */ ; } if ( text . charCodeAt ( pos + 1 ) === 61 /* equals */ ) { return pos += 2 , token = 58 /* MinusEqualsToken */ ; } return pos ++ , token = 36 /* MinusToken */ ; case 46 /* dot */ : if ( isDigit ( text . charCodeAt ( pos + 1 ) ) ) { tokenValue = "" + scanNumber ( ) ; return token = 8 /* NumericLiteral */ ; } if ( text . charCodeAt ( pos + 1 ) === 46 /* dot */ && text . charCodeAt ( pos + 2 ) === 46 /* dot */ ) { return pos += 3 , token = 22 /* DotDotDotToken */ ; } return pos ++ , token = 21 /* DotToken */ ; case 47 /* slash */ : // Single-line comment if ( text . charCodeAt ( pos + 1 ) === 47 /* slash */ ) { pos += 2 ; while ( pos < end ) { if ( isLineBreak ( text . charCodeAt ( pos ) ) ) { break ; } pos ++ ; } if ( skipTrivia ) { continue ; } else { return token = 2 /* SingleLineCommentTrivia */ ; } } // Multi-line comment if ( text . charCodeAt ( pos + 1 ) === 42 /* asterisk */ ) { pos += 2 ; var commentClosed = false ; while ( pos < end ) { var ch_2 = text . charCodeAt ( pos ) ; if ( ch_2 === 42 /* asterisk */ && text . charCodeAt ( pos + 1 ) === 47 /* slash */ ) { pos += 2 ; commentClosed = true ; break ; } if ( isLineBreak ( ch_2 ) ) { precedingLineBreak = true ; } pos ++ ; } if ( ! commentClosed ) { error ( ts . Diagnostics . Asterisk_Slash_expected ) ; } if ( skipTrivia ) { continue ; } else { tokenIsUnterminated = ! commentClosed ; return token = 3 /* MultiLineCommentTrivia */ ; } } if ( text . charCodeAt ( pos + 1 ) === 61 /* equals */ ) { return pos += 2 , token = 61 /* SlashEqualsToken */ ; } return pos ++ , token = 39 /* SlashToken */ ; case 48 /* _0 */ : if ( pos + 2 < end && ( text . charCodeAt ( pos + 1 ) === 88 /* X */ || text . charCodeAt ( pos + 1 ) === 120 /* x */ ) ) { pos += 2 ; var value = scanMinimumNumberOfHexDigits ( 1 ) ; if ( value < 0 ) { error ( ts . Diagnostics . Hexadecimal_digit_expected ) ; value = 0 ; } tokenValue = "" + value ; return token = 8 /* NumericLiteral */ ; } else if ( pos + 2 < end && ( text . charCodeAt ( pos + 1 ) === 66 /* B */ || text . charCodeAt ( pos + 1 ) === 98 /* b */ ) ) { pos += 2 ; var value = scanBinaryOrOctalDigits ( /* base */ 2 ) ; if ( value < 0 ) { error ( ts . Diagnostics . Binary_digit_expected ) ; value = 0 ; } tokenValue = "" + value ; return token = 8 /* NumericLiteral */ ; } else if ( pos + 2 < end && ( text . charCodeAt ( pos + 1 ) === 79 /* O */ || text . charCodeAt ( pos + 1 ) === 111 /* o */ ) ) { pos += 2 ; var value = scanBinaryOrOctalDigits ( /* base */ 8 ) ; if ( value < 0 ) { error ( ts . Diagnostics . Octal_digit_expected ) ; value = 0 ; } tokenValue = "" + value ; return token = 8 /* NumericLiteral */ ; } // Try to parse as an octal if ( pos + 1 < end && isOctalDigit ( text . charCodeAt ( pos + 1 ) ) ) { tokenValue = "" + scanOctalDigits ( ) ; return token = 8 /* NumericLiteral */ ; } // This fall-through is a deviation from the EcmaScript grammar. The grammar says that a leading zero // can only be followed by an octal digit, a dot, or the end of the number literal. However, we are being // permissive and allowing decimal digits of the form 08* and 09* (which many browsers also do). case 49 /* _1 */ : case 50 /* _2 */ : case 51 /* _3 */ : case 52 /* _4 */ : case 53 /* _5 */ : case 54 /* _6 */ : case 55 /* _7 */ : case 56 /* _8 */ : case 57 /* _9 */ : tokenValue = "" + scanNumber ( ) ; return token = 8 /* NumericLiteral */ ; case 58 /* colon */ : return pos ++ , token = 54 /* ColonToken */ ; case 59 /* semicolon */ : return pos ++ , token = 23 /* SemicolonToken */ ; case 60 /* lessThan */ : if ( isConflictMarkerTrivia ( text , pos ) ) { pos = scanConflictMarkerTrivia ( text , pos , error ) ; if ( skipTrivia ) { continue ; } else { return token = 7 /* ConflictMarkerTrivia */ ; } } if ( text . charCodeAt ( pos + 1 ) === 60 /* lessThan */ ) { if ( text . charCodeAt ( pos + 2 ) === 61 /* equals */ ) { return pos += 3 , token = 63 /* LessThanLessThanEqualsToken */ ; } return pos += 2 , token = 43 /* LessThanLessThanToken */ ; } if ( text . charCodeAt ( pos + 1 ) === 61 /* equals */ ) { return pos += 2 , token = 28 /* LessThanEqualsToken */ ; } if ( languageVariant === 1 /* JSX */ && text . charCodeAt ( pos + 1 ) === 47 /* slash */ && text . charCodeAt ( pos + 2 ) !== 42 /* asterisk */ ) { return pos += 2 , token = 26 /* LessThanSlashToken */ ; } return pos ++ , token = 25 /* LessThanToken */ ; case 61 /* equals */ : if ( isConflictMarkerTrivia ( text , pos ) ) { pos = scanConflictMarkerTrivia ( text , pos , error ) ; if ( skipTrivia ) { continue ; } else { return token = 7 /* ConflictMarkerTrivia */ ; } } if ( text . charCodeAt ( pos + 1 ) === 61 /* equals */ ) { if ( text . charCodeAt ( pos + 2 ) === 61 /* equals */ ) { return pos += 3 , token = 32 /* EqualsEqualsEqualsToken */ ; } return pos += 2 , token = 30 /* EqualsEqualsToken */ ; } if ( text . charCodeAt ( pos + 1 ) === 62 /* greaterThan */ ) { return pos += 2 , token = 34 /* EqualsGreaterThanToken */ ; } return pos ++ , token = 56 /* EqualsToken */ ; case 62 /* greaterThan */ : if ( isConflictMarkerTrivia ( text , pos ) ) { pos = scanConflictMarkerTrivia ( text , pos , error ) ; if ( skipTrivia ) { continue ; } else { return token = 7 /* ConflictMarkerTrivia */ ; } } return pos ++ , token = 27 /* GreaterThanToken */ ; case 63 /* question */ : return pos ++ , token = 53 /* QuestionToken */ ; case 91 /* openBracket */ : return pos ++ , token = 19 /* OpenBracketToken */ ; case 93 /* closeBracket */ : return pos ++ , token = 20 /* CloseBracketToken */ ; case 94 /* caret */ : if ( text . charCodeAt ( pos + 1 ) === 61 /* equals */ ) { return pos += 2 , token = 68 /* CaretEqualsToken */ ; } return pos ++ , token = 48 /* CaretToken */ ; case 123 /* openBrace */ : return pos ++ , token = 15 /* OpenBraceToken */ ; case 124 /* bar */ : if ( text . charCodeAt ( pos + 1 ) === 124 /* bar */ ) { return pos += 2 , token = 52 /* BarBarToken */ ; } if ( text . charCodeAt ( pos + 1 ) === 61 /* equals */ ) { return pos += 2 , token = 67 /* BarEqualsToken */ ; } return pos ++ , token = 47 /* BarToken */ ; case 125 /* closeBrace */ : return pos ++ , token = 16 /* CloseBraceToken */ ; case 126 /* tilde */ : return pos ++ , token = 50 /* TildeToken */ ; case 64 /* at */ : return pos ++ , token = 55 /* AtToken */ ; case 92 /* backslash */ : var cookedChar = peekUnicodeEscape ( ) ; if ( cookedChar >= 0 && isIdentifierStart ( cookedChar , languageVersion ) ) { pos += 6 ; tokenValue = String . fromCharCode ( cookedChar ) + scanIdentifierParts ( ) ; return token = getIdentifierToken ( ) ; } error ( ts . Diagnostics . Invalid_character ) ; return pos ++ , token = 0 /* Unknown */ ; default : if ( isIdentifierStart ( ch , languageVersion ) ) { pos ++ ; while ( pos < end && isIdentifierPart ( ch = text . charCodeAt ( pos ) , languageVersion ) ) pos ++ ; tokenValue = text . substring ( tokenPos , pos ) ; if ( ch === 92 /* backslash */ ) { tokenValue += scanIdentifierParts ( ) ; } return token = getIdentifierToken ( ) ; } else if ( isWhiteSpace ( ch ) ) { pos ++ ; continue ; } else if ( isLineBreak ( ch ) ) { precedingLineBreak = true ; pos ++ ; continue ; } error ( ts . Diagnostics . Invalid_character ) ; return pos ++ , token = 0 /* Unknown */ ; } } } function reScanGreaterToken ( ) { if ( token === 27 /* GreaterThanToken */ ) { if ( text . charCodeAt ( pos ) === 62 /* greaterThan */ ) { if ( text . charCodeAt ( pos + 1 ) === 62 /* greaterThan */ ) { if ( text . charCodeAt ( pos + 2 ) === 61 /* equals */ ) { return pos += 3 , token = 65 /* GreaterThanGreaterThanGreaterThanEqualsToken */ ; } return pos += 2 , token = 45 /* GreaterThanGreaterThanGreaterThanToken */ ; } if ( text . charCodeAt ( pos + 1 ) === 61 /* equals */ ) { return pos += 2 , token = 64 /* GreaterThanGreaterThanEqualsToken */ ; } return pos ++ , token = 44 /* GreaterThanGreaterThanToken */ ; } if ( text . charCodeAt ( pos ) === 61 /* equals */ ) { return pos ++ , token = 29 /* GreaterThanEqualsToken */ ; } } return token ; } function reScanSlashToken ( ) { if ( token === 39 /* SlashToken */ || token === 61 /* SlashEqualsToken */ ) { var p = tokenPos + 1 ; var inEscape = false ; var inCharacterClass = false ; while ( true ) { // If we reach the end of a file, or hit a newline, then this is an unterminated // regex.  Report error and return what we have so far. if ( p >= end ) { tokenIsUnterminated = true ; error ( ts . Diagnostics . Unterminated_regular_expression_literal ) ; break ; } var ch = text . charCodeAt ( p ) ; if ( isLineBreak ( ch ) ) { tokenIsUnterminated = true ; error ( ts . Diagnostics . Unterminated_regular_expression_literal ) ; break ; } if ( inEscape ) { // Parsing an escape character; // reset the flag and just advance to the next char. inEscape = false ; } else if ( ch === 47 /* slash */ && ! inCharacterClass ) { // A slash within a character class is permissible, // but in general it signals the end of the regexp literal. p ++ ; break ; } else if ( ch === 91 /* openBracket */ ) { inCharacterClass = true ; } else if ( ch === 92 /* backslash */ ) { inEscape = true ; } else if ( ch === 93 /* closeBracket */ ) { inCharacterClass = false ; } p ++ ; } while ( p < end && isIdentifierPart ( text . charCodeAt ( p ) , languageVersion ) ) { p ++ ; } pos = p ; tokenValue = text . substring ( tokenPos , pos ) ; token = 10 /* RegularExpressionLiteral */ ; } return token ; } /**          * Unconditionally back up and scan a template expression portion.          */ function reScanTemplateToken ( ) { ts . Debug . assert ( token === 16 /* CloseBraceToken */ , "'reScanTemplateToken' should only be called on a '}'" ) ; pos = tokenPos ; return token = scanTemplateAndSetTokenValue ( ) ; } function reScanJsxToken ( ) { pos = tokenPos = startPos ; return token = scanJsxToken ( ) ; } function scanJsxToken ( ) { startPos = tokenPos = pos ; if ( pos >= end ) { return token = 1 /* EndOfFileToken */ ; } var char = text . charCodeAt ( pos ) ; if ( char === 60 /* lessThan */ ) { if ( text . charCodeAt ( pos + 1 ) === 47 /* slash */ ) { pos += 2 ; return token = 26 /* LessThanSlashToken */ ; } pos ++ ; return token = 25 /* LessThanToken */ ; } if ( char === 123 /* openBrace */ ) { pos ++ ; return token = 15 /* OpenBraceToken */ ; } while ( pos < end ) { pos ++ ; char = text . charCodeAt ( pos ) ; if ( ( char === 123 /* openBrace */ ) || ( char === 60 /* lessThan */ ) ) { break ; } } return token = 236 /* JsxText */ ; } // Scans a JSX identifier; these differ from normal identifiers in that // they allow dashes function scanJsxIdentifier ( ) { if ( tokenIsIdentifierOrKeyword ( token ) ) { var firstCharPosition = pos ; while ( pos < end ) { var ch = text . charCodeAt ( pos ) ; if ( ch === 45 /* minus */ || ( ( firstCharPosition === pos ) ? isIdentifierStart ( ch , languageVersion ) : isIdentifierPart ( ch , languageVersion ) ) ) { pos ++ ; } else { break ; } } tokenValue += text . substr ( firstCharPosition , pos - firstCharPosition ) ; } return token ; } function speculationHelper ( callback , isLookahead ) { var savePos = pos ; var saveStartPos = startPos ; var saveTokenPos = tokenPos ; var saveToken = token ; var saveTokenValue = tokenValue ; var savePrecedingLineBreak = precedingLineBreak ; var result = callback ( ) ; // If our callback returned something 'falsy' or we're just looking ahead, // then unconditionally restore us to where we were. if ( ! result || isLookahead ) { pos = savePos ; startPos = saveStartPos ; tokenPos = saveTokenPos ; token = saveToken ; tokenValue = saveTokenValue ; precedingLineBreak = savePrecedingLineBreak ; } return result ; } function lookAhead ( callback ) { return speculationHelper ( callback , /*isLookahead:*/ true ) ; } function tryScan ( callback ) { return speculationHelper ( callback , /*isLookahead:*/ false ) ; } function setText ( newText , start , length ) { text = newText || "" ; end = length === undefined ? text . length : start + length ; setTextPos ( start || 0 ) ; } function setOnError ( errorCallback ) { onError = errorCallback ; } function setScriptTarget ( scriptTarget ) { languageVersion = scriptTarget ; } function setLanguageVariant ( variant ) { languageVariant = variant ; } function setTextPos ( textPos ) { ts . Debug . assert ( textPos >= 0 ) ; pos = textPos ; startPos = textPos ; tokenPos = textPos ; token = 0 /* Unknown */ ; precedingLineBreak = false ; tokenValue = undefined ; hasExtendedUnicodeEscape = false ; tokenIsUnterminated = false ; } }<CODESPLIT>0.13806435465812683<CODESPLIT>0.1483992040157318

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/bgrins/javascript-astar/blob/ef5ec96002f87f8ae9854c9a411e6f482d20ff35/demo/demo.js#L210-L218<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( path , i ) { if ( i >= path . length ) { // finished removing path, set start positions return setStartClass ( path , i ) ; } elementFromNode ( path [ i ] ) . removeClass ( css . active ) ; setTimeout ( function ( ) { removeClass ( path , i + 1 ) ; } , timeout * path [ i ] . getCost ( ) ) ; }<CODESPLIT>0.1732322722673416<CODESPLIT>0.1415380835533142

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/jsdom/jsdom/blob/43f2089142f57cddc3983e6429c34351699625f2/lib/jsdom/living/helpers/dates-and-times.js#L109-L128<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function parseTimeString ( str ) { const matches = timeRe . exec ( str ) ; if ( ! matches ) { return null ; } const hour = Number ( matches [ 1 ] ) ; if ( hour < 0 || hour > 23 ) { return null ; } const minute = Number ( matches [ 2 ] ) ; if ( minute < 0 || minute > 59 ) { return null ; } const second = matches [ 3 ] !== undefined ? Math . trunc ( Number ( matches [ 3 ] ) ) : 0 ; if ( second < 0 || second >= 60 ) { return null ; } const millisecond = matches [ 4 ] !== undefined ? Number ( matches [ 4 ] ) : 0 ; return { hour , minute , second , millisecond } ; }<CODESPLIT>0.15340353548526764<CODESPLIT>0.1267753690481186

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/zeit/next.js/blob/3641f79a0f68d1093cc238b50b8d47eec1c25cfd/packages/next/client/dev-error-overlay/hot-dev-client.js#L260-L306<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>async function tryApplyUpdates ( onHotUpdateSuccess ) { if ( ! module . hot ) { // HotModuleReplacementPlugin is not in Webpack configuration. console . error ( 'HotModuleReplacementPlugin is not in Webpack configuration.' ) // window.location.reload(); return } if ( ! isUpdateAvailable ( ) || ! canApplyUpdates ( ) ) { return } function handleApplyUpdates ( err , updatedModules ) { if ( err || hadRuntimeError ) { if ( err ) { console . warn ( 'Error while applying updates, reloading page' , err ) } if ( hadRuntimeError ) { console . warn ( 'Had runtime error previously, reloading page' ) } window . location . reload ( ) return } if ( typeof onHotUpdateSuccess === 'function' ) { // Maybe we want to do something. onHotUpdateSuccess ( ) } if ( isUpdateAvailable ( ) ) { // While we were updating, there was a new update! Do it again. tryApplyUpdates ( ) } } // https://webpack.github.io/docs/hot-module-replacement.html#check try { const updatedModules = await module . hot . check ( /* autoApply */ { ignoreUnaccepted : true } ) if ( updatedModules ) { handleApplyUpdates ( null , updatedModules ) } } catch ( err ) { handleApplyUpdates ( err , null ) } }<CODESPLIT>0.14331357181072235<CODESPLIT>0.13111408054828644

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/z-classic/zclassicjs/blob/5a399fd799a300cfda0d53bd7fdccca7523022e0/lib/address.js#L41-L47<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function privKeyToPubKey ( privKey ) { var toCompressed = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : false ; var pkBuffer = Buffer . from ( privKey , 'hex' ) ; var publicKey = secp256k1 . publicKeyCreate ( pkBuffer , toCompressed ) ; return publicKey . toString ( 'hex' ) ; }<CODESPLIT>0.15883572399616241<CODESPLIT>0.1343584507703781

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/jshttp/negotiator/blob/99f418e11907b60e63f0addc09fc596ddc7be5be/lib/encoding.js#L98-L110<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getEncodingPriority ( encoding , accepted , index ) { var priority = { o : - 1 , q : 0 , s : 0 } ; for ( var i = 0 ; i < accepted . length ; i ++ ) { var spec = specify ( encoding , accepted [ i ] , index ) ; if ( spec && ( priority . s - spec . s || priority . q - spec . q || priority . o - spec . o ) < 0 ) { priority = spec ; } } return priority ; }<CODESPLIT>0.15612764656543732<CODESPLIT>0.15569324791431427

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L7928-L7941<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( type ) { if ( type . FIXTURES ) { var fixtures = Ember . A ( type . FIXTURES ) ; return fixtures . map ( function ( fixture ) { var fixtureIdType = typeof fixture . id ; if ( fixtureIdType !== "number" && fixtureIdType !== "string" ) { throw new Error ( fmt ( 'the id property must be defined as a number or string for fixture %@' , [ fixture ] ) ) ; } fixture . id = fixture . id + '' ; return fixture ; } ) ; } return null ; }<CODESPLIT>0.11727990955114365<CODESPLIT>0.158238023519516

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/jsantell/GhostTrain/blob/e69b6cc33669035c1d571bff3805e1b6d8a50ccb/lib/utils.js#L88-L99<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function addRoute ( verb ) { return function ( path , fn ) { // Support all HTTP verbs if ( ! this . routes [ verb ] ) this . routes [ verb ] = [ ] ; this . routes [ verb ] . push ( new Route ( verb , path , fn , { sensitive : this . settings [ 'case sensitive routing' ] , strict : this . settings [ 'strict routing' ] } ) ) ; } ; }<CODESPLIT>0.16693682968616486<CODESPLIT>0.12704108655452728

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/writetome51/array-get-indexes-basic/blob/6e724f4100228e990e019c23267b069cf93d88ed/dist/getIndexOfPrimitive.js#L9-L15<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getIndexOfPrimitive ( primitive , array , startingPosition ) { if ( startingPosition === void 0 ) { startingPosition = 0 ; } errorIfNotPrimitive_1 . errorIfNotPrimitive ( primitive ) ; error_if_not_populated_array_1 . errorIfNotPopulatedArray ( array ) ; errorIfNotInteger_1 . errorIfNotInteger ( startingPosition ) ; return array . indexOf ( primitive , startingPosition ) ; }<CODESPLIT>0.1703817993402481<CODESPLIT>0.1358352154493332

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/algolia/algoliasearch-helper-js/blob/9ebdd34ab98a3298a7687f81dfef24b01e798c53/src/SearchParameters/index.js#L769-L790<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( attribute , operator , v ) { var value = valToNumber ( v ) ; if ( this . isNumericRefined ( attribute , operator , value ) ) return this ; var mod = merge ( { } , this . numericRefinements ) ; mod [ attribute ] = merge ( { } , mod [ attribute ] ) ; if ( mod [ attribute ] [ operator ] ) { // Array copy mod [ attribute ] [ operator ] = mod [ attribute ] [ operator ] . slice ( ) ; // Add the element. Concat can't be used here because value can be an array. mod [ attribute ] [ operator ] . push ( value ) ; } else { mod [ attribute ] [ operator ] = [ value ] ; } return this . setQueryParameters ( { numericRefinements : mod } ) ; }<CODESPLIT>0.15433378517627716<CODESPLIT>0.13760046660900116

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L3594-L3619<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function braces ( pattern , options ) { var key = utils . createKey ( String ( pattern ) , options ) ; var arr = [ ] ; var disabled = options && options . cache === false ; if ( ! disabled && cache . hasOwnProperty ( key ) ) { return cache [ key ] ; } if ( Array . isArray ( pattern ) ) { for ( var i = 0 ; i < pattern . length ; i ++ ) { arr . push . apply ( arr , braces . create ( pattern [ i ] , options ) ) ; } } else { arr = braces . create ( pattern , options ) ; } if ( options && options . nodupes === true ) { arr = unique ( arr ) ; } if ( ! disabled ) { cache [ key ] = arr ; } return arr ; }<CODESPLIT>0.11425460129976273<CODESPLIT>0.13915345072746277

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/sTdobTs/validator/blob/d6364d9b17ab73943a375c319cf94f57831b6677/src/isInteger.js#L34-L42<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function _isInteger ( val , options ) { var opts = _isObject ( options ) ? options : { } ; if ( opts . isStrict === true ) { return _isNumber ( val ) && REGEX_ENUM . INTEGER_REX . test ( val ) ; } return REGEX_ENUM . INTEGER_REX . test ( val ) ; }<CODESPLIT>0.15275999903678894<CODESPLIT>0.12675528228282928

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/cubicmushroom/gulp-cm-phpspec-tasks/blob/671b5e6e9545c7a6a027f8b93c1349d491cf429e/pakmanaged.js#L44468-L44476<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function uniqSet ( arr ) { var seen = new Set ( ) ; return arr . filter ( function ( el ) { if ( ! seen . has ( el ) ) { seen . add ( el ) ; return true ; } } ) ; }<CODESPLIT>0.1390441507101059<CODESPLIT>0.14367331564426422

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/util/Collection.js#L795-L805<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( items ) { if ( items ) { var ln = items . length , i ; for ( i = 0 ; i < ln ; i ++ ) { this . remove ( items [ i ] ) ; } } return this ; }<CODESPLIT>0.13936667144298553<CODESPLIT>0.1412964016199112

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/clux/npm-graph/blob/69a8391e71d6c50bfeffbbda7f4aa0187f7d7d0a/lib/cycle.js#L39-L68<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( ms , cycles ) { var removed = { } ; cycles . forEach ( function ( c ) { var last = c [ c . length - 1 ] ; // last id in cycle //console.log('will try to trim from', last, ms[last]); // need to find a dependency in the cycle var depsInCycle = ms [ last ] . filter ( function ( deps ) { return deps . path && c . indexOf ( deps . path ) >= 0 ; } ) ; if ( ! depsInCycle . length ) { throw new Error ( "logic fail2" ) ; // last thing in a cycle should have deps } var depToRemove = depsInCycle [ 0 ] . path ; //console.log('deps in cycle', depsInCycle); for ( var i = 0 ; i < ms [ last ] . length ; i += 1 ) { var dep = ms [ last ] [ i ] ; if ( dep . path && dep . path === depToRemove ) { //console.log('removing', depToRemove); removed [ last ] = dep . name ; ms [ last ] . splice ( i , 1 ) ; } } //console.log('after remove', ms[last]); } ) ; return removed ; }<CODESPLIT>0.15756556391716003<CODESPLIT>0.13578927516937256

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/apache/cordova-lib/blob/dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5/spec/cordova/fixtures/projects/platformApi/platforms/windows/cordova/lib/AppxManifest.js#L61-L74<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function AppxManifest ( path , prefix ) { this . path = path ; // Append ':' to prefix if needed prefix = prefix || '' ; this . prefix = ( prefix . indexOf ( ':' ) === prefix . length - 1 ) ? prefix : prefix + ':' ; this . doc = xml . parseElementtreeSync ( path ) ; if ( this . doc . getroot ( ) . tag !== 'Package' ) { // Some basic validation throw new Error ( path + ' has incorrect root node name (expected "Package")' ) ; } // Indicates that this manifest is for phone application (either WinPhone 8.1 or Universal Windows 10) this . hasPhoneIdentity = this . prefix === 'uap:' || this . prefix === 'm3:' ; }<CODESPLIT>0.16322290897369385<CODESPLIT>0.13726860284805298

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/scttnlsn/mubsub/blob/6f1b6d7da675b312a81fbff8be9bebc44a151dd5/lib/channel.js#L18-L34<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function Channel ( connection , name , options ) { options || ( options = { } ) ; options . capped = true ; // In mongo v <= 2.2 index for _id is not done by default options . autoIndexId = true ; options . size || ( options . size = 1024 * 1024 * 5 ) ; options . strict = false ; this . options = options ; this . connection = connection ; this . closed = false ; this . listening = null ; this . name = name || 'mubsub' ; this . create ( ) . listen ( ) ; this . setMaxListeners ( 0 ) ; }<CODESPLIT>0.1653776913881302<CODESPLIT>0.12450983375310898

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/pureqml/qmlcore/blob/21416cb4b45dce6cf6c603dfa43d6683e0d48638/platform/video.videojs/dist/video.es.js#L6295-L6327<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function TextTrackCueList ( cues ) { classCallCheck ( this , TextTrackCueList ) ; var list = this ; // eslint-disable-line if ( IS_IE8 ) { list = document . createElement ( 'custom' ) ; for ( var prop in TextTrackCueList . prototype ) { if ( prop !== 'constructor' ) { list [ prop ] = TextTrackCueList . prototype [ prop ] ; } } } TextTrackCueList . prototype . setCues_ . call ( list , cues ) ; /**      * @memberof TextTrackCueList      * @member {number} length      *         The current number of `TextTrackCue`s in the TextTrackCueList.      * @instance      */ Object . defineProperty ( list , 'length' , { get : function get$$1 ( ) { return this . length_ ; } } ) ; if ( IS_IE8 ) { return list ; } }<CODESPLIT>0.15916137397289276<CODESPLIT>0.12403670698404312

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L23740-L23748<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( key , value ) { var attributeName = this . _unspecifiedAttributeBindings && this . _unspecifiedAttributeBindings [ key ] ; if ( attributeName ) { this . _setupAttributeBindingObservation ( key , attributeName ) ; } defineProperty ( this , key ) ; return set ( this , key , value ) ; }<CODESPLIT>0.16345380246639252<CODESPLIT>0.14395248889923096

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/localnerve/html-snapshots/blob/63e829b234a8fa1399da1f7347a7fb3463e862a8/lib/common/sitemap.js#L46-L75<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function stillCurrent ( urlNode , options ) { var lesser , greater , oPath ; var now = Date . now ( ) ; var lMod = _ . first ( urlNode . lastmod ) ; var cFreq = _ . first ( urlNode . changefreq ) ? _ . first ( urlNode . changefreq ) . toLowerCase ( ) : null ; // only lastmod specified if ( lMod && ! cFreq ) { // if sitemap is malformed, just blow up oPath = base . outputFile ( options , urlNode . loc [ 0 ] ) ; lesser = now - ( ( fs . existsSync ( oPath ) && fs . statSync ( oPath ) . mtime . getTime ( ) ) || unixStart ) ; greater = now - Date . parse ( lMod ) ; } // only changefreq specified else if ( ! lMod && cFreq ) { // if sitemap is malformed, just blow up oPath = base . outputFile ( options , urlNode . loc [ 0 ] ) ; lesser = now - ( ( fs . existsSync ( oPath ) && fs . statSync ( oPath ) . mtime . getTime ( ) ) || unixStart ) ; greater = changeFreq [ cFreq ] || changeFreq . always ; } // both or neither were specified else { lesser = now - Date . parse ( lMod || unixStart ) ; greater = changeFreq [ cFreq ] || changeFreq . always ; } return lesser <= greater ; }<CODESPLIT>0.15903761982917786<CODESPLIT>0.13169747591018677

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/maxleiko/grunt-publish/blob/d4df6e441edd9203c66e18c53c50c7416dc7d499/tasks/publish.js#L34-L41<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getIgnored ( filepath ) { for ( var i in options . ignore ) { if ( filepath . indexOf ( options . ignore [ i ] ) !== - 1 ) { return options . ignore [ i ] ; } } return null ; }<CODESPLIT>0.17465412616729736<CODESPLIT>0.13427437841892242

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/trendmicro-frontend/react-liquid-gauge/blob/c8b24bd48a504539e25553a66097466f75917af6/docs/bundle.js#L27354-L27365<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function batchedUpdates ( fn , a ) { var previousIsBatchingUpdates = isBatchingUpdates ; isBatchingUpdates = true ; try { return fn ( a ) ; } finally { isBatchingUpdates = previousIsBatchingUpdates ; if ( ! isBatchingUpdates && ! isRendering ) { performWork ( Sync , null ) ; } } }<CODESPLIT>0.13980476558208466<CODESPLIT>0.14350442588329315

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/xperiments/TSDoc/blob/d153780b05b7500b55346b9a6b4a241fb5788ee8/template/static/scripts/bootstrap-typeahead.js#L325-L330<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( item ) { var query = this . query . replace ( / [\-\[\]{}()*+?.,\\\^$|#\s] / g , '\\$&' ) ; return item . replace ( new RegExp ( '(' + query + ')' , 'ig' ) , function ( $1 , match ) { return '<strong>' + match + '</strong>' ; } ) ; }<CODESPLIT>0.15263867378234863<CODESPLIT>0.11578639596700668

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/Softmotions/ejdb-node/blob/9d3c37ac2d16bb2839c2cf5cdb0d068e70b2c9cc/ejdb.js#L292-L324<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function parseQueryArgs ( args ) { var cname , qobj , orarr , hints , cb ; var i = 0 ; cname = args [ i ++ ] ; if ( typeof cname !== "string" ) { throw new Error ( "Collection name 'cname' argument must be specified" ) ; } var next = args [ i ++ ] ; if ( typeof next === "function" ) { cb = next ; } else { qobj = next ; } next = args [ i ++ ] ; if ( next !== undefined ) { if ( Array . isArray ( next ) ) { orarr = next ; next = args [ i ++ ] ; } else if ( typeof next === "object" ) { hints = next ; orarr = null ; next = args [ i ++ ] ; } if ( ! hints && typeof next === "object" ) { hints = next ; next = args [ i ++ ] ; } if ( typeof next === "function" ) { cb = next ; } } return [ cname , ( qobj || { } ) , ( orarr || [ ] ) , ( hints || { } ) , ( cb || null ) ] ; }<CODESPLIT>0.16395661234855652<CODESPLIT>0.14984367787837982

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/cranbee/template/blob/84044ca9124c5eb4dc28d8e0c8d366c7abd761fa/src/executor.js#L81-L92<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function executeFi ( node , data , result ) { if ( Extender . processExpr ( node . props . fi , data ) ) { return ; } let nextNode = { type : node . type , props : Object . assign ( { } , node . props ) , children : node . children } ; nextNode . props . fi = null ; executeNode ( nextNode , data , result ) ; }<CODESPLIT>0.1359098255634308<CODESPLIT>0.153812974691391

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/matai-tech/matai-pro/blob/668cc8222d0fe4664d1ca11a672c9960d49f100e/scripts/inline-template-and-style.js#L25-L35<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function inlineStyle ( fileContent , filePath ) { return fileContent . replace ( / styleUrls\s*:\s*\[(.+)\] / g , ( _match , templateUrl ) => { let styleContent = '' const styleList = templateUrl . replace ( / '|\s / g , '' ) . split ( ',' ) styleList . forEach ( s => { const stylePath = path . join ( path . dirname ( filePath ) , s ) styleContent += loadResourceFile ( stylePath ) } ) return ` \[ \` ${ styleContent } \` \] ` } ) }<CODESPLIT>0.14546780288219452<CODESPLIT>0.12247460335493088

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/d11n/uri-query/blob/ac0e55cf5742d3d25a3c823b5d1b99c3abb9a305/source/index.js#L148-L152<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function unprotect_prop ( unsafe_key , safe_key ) { unsafe_query_object [ unsafe_key ] = unsafe_query_object [ safe_key ] ; delete unsafe_query_object [ safe_key ] ; return true ; }<CODESPLIT>0.1640874147415161<CODESPLIT>0.15461577475070953

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/tstachl/desk.js/blob/b339196cce68dbbc79d3075f2ebe82372972f4f5/lib/mixins/link.js#L21-L44<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function link ( definition ) { var key , link , newResource , Resource ; if ( '_links' in definition ) { for ( key in definition . _links ) { if ( key === 'self' ) continue ; link = definition . _links [ key ] ; key = key . charAt ( 0 ) + inflection . camelize ( key ) . slice ( 1 ) ; // resources like next, previous can be null if ( link === null ) { this [ key ] = _buildFunction ( null ) ; continue ; } // this is a really ugly hack but necessary for sub resources which aren't declared consistently if ( inflection . singularize ( key ) !== key && link [ 'class' ] === inflection . singularize ( key ) ) link [ 'class' ] = 'page' newResource = new ( getResource ( link [ 'class' ] ) ) ( this , { _links : { self : link } } ) ; this [ key ] = _buildFunction ( newResource ) ; } } }<CODESPLIT>0.15133385360240936<CODESPLIT>0.149436354637146

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/acarl005/join-monster/blob/8db8b54aaefd2fd975d63e2ab3ec05922e25118c/src/query-ast-to-sql-ast/index.js#L541-L559<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function stripRelayConnection ( gqlType , queryASTNode , fragments ) { // get the GraphQL Type inside the list of edges inside the Node from the schema definition const edgeType = stripNonNullType ( gqlType . _fields . edges . type ) const strippedType = stripNonNullType ( stripNonNullType ( edgeType . ofType ) . _fields . node . type ) // let's remember those arguments on the connection const args = queryASTNode . arguments // and then find the fields being selected on the underlying type, also buried within edges and Node const edges = spreadFragments ( queryASTNode . selectionSet . selections , fragments , gqlType . name ) . find ( selection => selection . name . value === 'edges' ) if ( edges ) { queryASTNode = spreadFragments ( edges . selectionSet . selections , fragments , gqlType . name ) . find ( selection => selection . name . value === 'node' ) || { } } else { queryASTNode = { } } // place the arguments on this inner field, so our SQL AST picks it up later queryASTNode . arguments = args return { gqlType : strippedType , queryASTNode } }<CODESPLIT>0.1705741286277771<CODESPLIT>0.14768092334270477

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/evanmoran/oj/blob/7f05880e4a4572fd67ffb0f55223f66d8ea4e68d/versions/0.2.2/oj.js#L269-L273<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function _splitAndTrim ( str , seperator , limit ) { return str . split ( seperator , limit ) . map ( function ( v ) { return v . trim ( ) } ) }<CODESPLIT>0.10276960581541061<CODESPLIT>0.1526062935590744

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/centro/transis/blob/e002b55bbe55a75b7638e9046e57bdfbff04cd1c/dist/model.js#L86-L102<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function wrapPromise ( promise ) { return promise . then ( function ( value ) { return new Promise ( function ( resolve , reject ) { _object2 . default . delay ( function ( ) { resolve ( value ) ; } ) ; _object2 . default . _queueFlush ( ) ; } ) ; } , function ( reason ) { return new Promise ( function ( resolve , reject ) { _object2 . default . delay ( function ( ) { reject ( reason ) ; } ) ; _object2 . default . _queueFlush ( ) ; } ) ; } ) ; }<CODESPLIT>0.15872834622859955<CODESPLIT>0.13542070984840393

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/olegpolyakov/sendpulse/blob/7c8230e75c918a8a110f641ddb241006a1f86ac1/index.js#L542-L551<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function addSender ( callback , senderName , senderEmail ) { if ( ( senderEmail === undefined ) || ( ! senderEmail . length ) || ( senderName === undefined ) || ( ! senderName . length ) ) { return callback ( returnError ( 'Empty sender name or email' ) ) ; } var data = { email : senderEmail , name : senderName } sendRequest ( 'senders' , 'POST' , data , true , callback ) ; }<CODESPLIT>0.15523892641067505<CODESPLIT>0.12942469120025635

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/willconant/flow-js/blob/8336df1741a663b458cd96ba12ad2c3e13f89b84/flow.js#L137-L146<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function anyError ( results ) { var r , _i , _len ; for ( _i = 0 , _len = results . length ; _i < _len ; _i ++ ) { r = results [ _i ] ; if ( r [ 0 ] ) { return r [ 0 ] ; } } return null ; }<CODESPLIT>0.15086333453655243<CODESPLIT>0.15098334848880768

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/apache/cordova-plugin-media/blob/b1c135342619f773fee3e8693a46992a133efd56/www/browser/Media.js#L64-L97<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function createNode ( media ) { var node = new Audio ( ) ; node . onplay = function ( ) { Media . onStatus ( media . id , Media . MEDIA_STATE , Media . MEDIA_STARTING ) ; } ; node . onplaying = function ( ) { Media . onStatus ( media . id , Media . MEDIA_STATE , Media . MEDIA_RUNNING ) ; } ; node . ondurationchange = function ( e ) { Media . onStatus ( media . id , Media . MEDIA_DURATION , e . target . duration || - 1 ) ; } ; node . onerror = function ( e ) { // Due to media.spec.15 It should return MediaError for bad filename var err = e . target . error . code === MediaError . MEDIA_ERR_SRC_NOT_SUPPORTED ? { code : MediaError . MEDIA_ERR_ABORTED } : e . target . error ; Media . onStatus ( media . id , Media . MEDIA_ERROR , err ) ; } ; node . onended = function ( ) { Media . onStatus ( media . id , Media . MEDIA_STATE , Media . MEDIA_STOPPED ) ; } ; if ( media . src ) { node . src = media . src ; } return node ; }<CODESPLIT>0.16655166447162628<CODESPLIT>0.12274176627397537

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/graphology/graphology-generators/blob/bd9c36df57550fbec68a0b56040ea0dab8f81bd8/random/erdos-renyi.js#L22-L78<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function erdosRenyi ( GraphClass , options ) { if ( ! isGraphConstructor ( GraphClass ) ) throw new Error ( 'graphology-generators/random/erdos-renyi: invalid Graph constructor.' ) ; var order = options . order , probability = options . probability , rng = options . rng || Math . random ; var graph = new GraphClass ( ) ; // If user gave a size, we need to compute probability if ( typeof options . approximateSize === 'number' ) { var densityFunction = density [ graph . type + 'Density' ] ; probability = densityFunction ( order , options . approximateSize ) ; } if ( typeof order !== 'number' || order <= 0 ) throw new Error ( 'graphology-generators/random/erdos-renyi: invalid `order`. Should be a positive number.' ) ; if ( typeof probability !== 'number' || probability < 0 || probability > 1 ) throw new Error ( 'graphology-generators/random/erdos-renyi: invalid `probability`. Should be a number between 0 and 1. Or maybe you gave an `approximateSize` exceeding the graph\'s density.' ) ; if ( typeof rng !== 'function' ) throw new Error ( 'graphology-generators/random/erdos-renyi: invalid `rng`. Should be a function.' ) ; for ( var i = 0 ; i < order ; i ++ ) graph . addNode ( i ) ; if ( probability <= 0 ) return graph ; if ( order > 1 ) { var iterator = combinations ( range ( order ) , 2 ) , path , step ; while ( ( step = iterator . next ( ) , ! step . done ) ) { path = step . value ; if ( graph . type !== 'directed' ) { if ( rng ( ) < probability ) graph . addUndirectedEdge ( path [ 0 ] , path [ 1 ] ) ; } if ( graph . type !== 'undirected' ) { if ( rng ( ) < probability ) graph . addDirectedEdge ( path [ 0 ] , path [ 1 ] ) ; if ( rng ( ) < probability ) graph . addDirectedEdge ( path [ 1 ] , path [ 0 ] ) ; } } } return graph ; }<CODESPLIT>0.1541476547718048<CODESPLIT>0.1217561736702919

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L23528-L23560<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( buffer ) { // If this view has a layout, it is the responsibility of the // the layout to render the view's template. Otherwise, render the template // directly. var template = get ( this , 'layout' ) || get ( this , 'template' ) ; if ( template ) { var context = get ( this , 'context' ) ; var keywords = this . cloneKeywords ( ) ; var output ; var data = { view : this , buffer : buffer , isRenderData : true , keywords : keywords , insideGroup : get ( this , 'templateData.insideGroup' ) } ; // Invoke the template with the provided template context, which // is the view's controller by default. A hash of data is also passed that provides // the template with access to the view and render buffer. Ember . assert ( 'template must be a function. Did you mean to call Ember.Handlebars.compile("...") or specify templateName instead?' , typeof template === 'function' ) ; // The template should write directly to the render buffer instead // of returning a string. output = template ( context , { data : data } ) ; // If the template returned a string instead of writing to the buffer, // push the string onto the buffer. if ( output !== undefined ) { buffer . push ( output ) ; } } }<CODESPLIT>0.1664389669895172<CODESPLIT>0.14926783740520477

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/jeffharrell/minicart/blob/41066535b978637c2c3ec651d74b406b9510e7c7/src/product.js#L38-L50<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function Product ( data ) { data . quantity = parser . quantity ( data . quantity ) ; data . amount = parser . amount ( data . amount ) ; data . href = parser . href ( data . href ) ; this . _data = data ; this . _options = null ; this . _discount = null ; this . _amount = null ; this . _total = null ; Pubsub . call ( this ) ; }<CODESPLIT>0.1586708277463913<CODESPLIT>0.12037297338247299

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/typhonjs-node-esdoc/esdoc-plugin-dependency-graphs/blob/af2d9cabce2d48edd4ad7ed81c722cc27efacb67/template/html/d3-graph.js#L1073-L1086<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function updateMenuUI ( ) { if ( data ) { $ ( '.control-menu li[data-action=toggleFreezeAllNodes]' ) . html ( data . allNodesFixed ? 'Unfreeze nodes' : 'Freeze nodes' ) ; } appMenuToggleOptions . forEach ( function ( key ) { var icon = appOptions [ key ] ? 'check_box' : 'check_box_outline_blank' ; $ ( '.control-menu li[data-action=' + key + '] i' ) . html ( icon ) ; } ) ; }<CODESPLIT>0.12802383303642273<CODESPLIT>0.13880698382854462

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/canjs/can-map/blob/f2083ca4ef9f2c193aeaf15e013c956aa64c3a77/can-map.js#L164-L187<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( obj ) { if ( canReflect . isObservableLike ( obj ) && typeof obj . serialize === "function" ) { obj = obj . serialize ( ) ; } // Where we keep the values of the compute. this . _data = Object . create ( null ) ; // The namespace this `object` uses to listen to events. CID ( this , ".map" ) ; this . _setupComputedProperties ( ) ; var teardownMapping = obj && mapHelpers . addToMap ( obj , this ) ; var defaultValues = this . _setupDefaults ( obj ) ; var data = assign ( canReflect . assignDeep ( { } , defaultValues ) , obj ) ; this . attr ( data ) ; if ( teardownMapping ) { teardownMapping ( ) ; } }<CODESPLIT>0.15105271339416504<CODESPLIT>0.14568264782428741

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/hugozap/react-rotary-knob/blob/215f5c6d9b72dd9d324dda71b80df421864707f3/src/utils.js#L90-L114<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function transformBoundingClientRectToDocument ( box ) { var t ; const scrollX = ( ( ( t = document . documentElement ) || ( t = document . body . parentNode ) ) && typeof t . scrollLeft == "number" ? t : document . body ) . scrollLeft ; const scrollY = ( ( ( t = document . documentElement ) || ( t = document . body . parentNode ) ) && typeof t . scrollTop == "number" ? t : document . body ) . scrollTop ; //This assumes width == height const ttop = box . top - scrollY ; const tleft = box . left - scrollX ; //info needed to draw line from center to mousepos return { top : ttop , left : tleft , width : box . width , height : box . height } }<CODESPLIT>0.14745090901851654<CODESPLIT>0.1514255851507187

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/reactbits/prismjs-package/blob/a50eb0c18c30a62d6af4e9be61b83de586d32187/gulpfile.js#L15-L17<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function replace ( format , data ) { return format . replace ( / {(\w+)} / g , ( m , name ) => ( data [ name ] ? data [ name ] : '' ) ) ; }<CODESPLIT>0.12653133273124695<CODESPLIT>0.13395071029663086

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/pandao/editor.md/blob/0e76f96d476397c5a9e64388a36e2ed74183d11e/editormd.amd.js#L1123-L1168<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( fixed ) { var state = this . state ; var editor = this . editor ; var toolbar = this . toolbar ; var settings = this . settings ; if ( typeof fixed !== "undefined" ) { settings . toolbarAutoFixed = fixed ; } var autoFixedHandle = function ( ) { var $window = $ ( window ) ; var top = $window . scrollTop ( ) ; if ( ! settings . toolbarAutoFixed ) { return false ; } if ( top - editor . offset ( ) . top > 10 && top < editor . height ( ) ) { toolbar . css ( { position : "fixed" , width : editor . width ( ) + "px" , left : ( $window . width ( ) - editor . width ( ) ) / 2 + "px" } ) ; } else { toolbar . css ( { position : "absolute" , width : "100%" , left : 0 } ) ; } } ; if ( ! state . fullscreen && ! state . preview && settings . toolbar && settings . toolbarAutoFixed ) { $ ( window ) . bind ( "scroll" , autoFixedHandle ) ; } return this ; }<CODESPLIT>0.16210664808750153<CODESPLIT>0.13913191854953766

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/datastax/nodejs-driver/blob/6766188870f7099aeb393719820245b69d789d23/lib/connection.js#L30-L98<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function Connection ( endpoint , protocolVersion , options ) { events . EventEmitter . call ( this ) ; this . setMaxListeners ( 0 ) ; if ( ! options ) { throw new Error ( 'options is not defined' ) ; } /**    * Gets the ip and port of the server endpoint.    * @type {String}    */ this . endpoint = endpoint ; /**    * Gets the friendly name of the host, used to identify the connection in log messages.    * With direct connect, this is the address and port.    * @type {String}    */ this . endpointFriendlyName = endpoint ; if ( ! this . endpoint || this . endpoint . indexOf ( ':' ) < 0 ) { throw new Error ( 'EndPoint must contain the ip address and port separated by : symbol' ) ; } const portSeparatorIndex = this . endpoint . lastIndexOf ( ':' ) ; this . address = this . endpoint . substr ( 0 , portSeparatorIndex ) ; this . port = this . endpoint . substr ( portSeparatorIndex + 1 ) ; Object . defineProperty ( this , "options" , { value : options , enumerable : false , writable : false } ) ; if ( protocolVersion === null ) { // Set initial protocol version protocolVersion = types . protocolVersion . maxSupported ; if ( options . protocolOptions . maxVersion ) { // User provided the protocol version protocolVersion = options . protocolOptions . maxVersion ; } // Allow to check version using this connection instance this . _checkingVersion = true ; } this . protocolVersion = protocolVersion ; /** @type {Object.<String, OperationState>} */ this . _operations = { } ; this . _pendingWrites = [ ] ; this . _preparing = { } ; /**    * The timeout state for the idle request (heartbeat)    */ this . _idleTimeout = null ; this . timedOutOperations = 0 ; this . _streamIds = new StreamIdStack ( this . protocolVersion ) ; this . _metrics = options . metrics ; this . encoder = new Encoder ( protocolVersion , options ) ; this . keyspace = null ; this . emitDrain = false ; /**    * Determines if the socket is open and startup succeeded, whether the connection can be used to send requests /     * receive events    */ this . connected = false ; /**    * Determines if the socket can be considered as open    */ this . isSocketOpen = false ; }<CODESPLIT>0.1508866548538208<CODESPLIT>0.12188057601451874

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/jsdom/jsdom/blob/43f2089142f57cddc3983e6429c34351699625f2/lib/jsdom/living/helpers/shadow-dom.js#L215-L235<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function findSlot ( slotable , openFlag ) { const { parentNode : parent } = slotable ; if ( ! parent ) { return null ; } const shadow = parent . _shadowRoot ; if ( ! shadow || ( openFlag && shadow . mode !== "open" ) ) { return null ; } for ( const child of domSymbolTree . treeIterator ( shadow ) ) { if ( isSlot ( child ) && child . name === slotable . _slotableName ) { return child ; } } return null ; }<CODESPLIT>0.18723638355731964<CODESPLIT>0.13598892092704773

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/views/Statistic/Statistic.js#L23-L75<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function Statistic ( props ) { const { children , className , color , content , floated , horizontal , inverted , label , size , text , value , } = props const classes = cx ( 'ui' , color , size , useValueAndKey ( floated , 'floated' ) , useKeyOnly ( horizontal , 'horizontal' ) , useKeyOnly ( inverted , 'inverted' ) , 'statistic' , className , ) const rest = getUnhandledProps ( Statistic , props ) const ElementType = getElementType ( Statistic , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } >           { children }         < / ElementType > ) } if ( ! childrenUtils . isNil ( content ) ) { return ( < ElementType { ... rest } className = { classes } >           { content }         < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } >         { StatisticValue . create ( value , { defaultProps : { text } , autoGenerateKey : false , } ) }         { StatisticLabel . create ( label , { autoGenerateKey : false } ) }       < / ElementType > ) }<CODESPLIT>0.17308379709720612<CODESPLIT>0.1521129459142685

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/distributions-io/triangular-quantile/blob/3614b5e5d34f3a61dee1f80ba7e9054838519908/lib/partial.js#L19-L44<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function partial ( a , b , c ) { var pInflection = ( c - a ) / ( b - a ) , fact1 = ( b - a ) * ( c - a ) , fact2 = ( b - a ) * ( b - c ) ; /** 	* FUNCTION: quantile( p ) 	*	Evaluates the quantile function for a triangular distribution. 	* 	* @private 	* @param {Number} p - input value 	* @returns {Number} evaluated quantile function 	*/ return function quantile ( p ) { if ( p !== p || p < 0 || p > 1 ) { return NaN ; } if ( p < pInflection ) { return a + sqrt ( fact1 * p ) ; } if ( p > pInflection ) { return b - sqrt ( fact2 * ( 1 - p ) ) ; } // Case: p = pInflection return c ; } ; }<CODESPLIT>0.13202747702598572<CODESPLIT>0.15193483233451843

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/Countly/countly-sdk-nodejs/blob/4cdce095fa0e479aad985cbfa2d58bc1163ae635/lib/countly-bulk.js#L443-L449<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function prepareParams ( params ) { var str = [ ] ; for ( var i in params ) { str . push ( i + "=" + encodeURIComponent ( params [ i ] ) ) ; } return str . join ( "&" ) ; }<CODESPLIT>0.15091943740844727<CODESPLIT>0.16980873048305511

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/phodal/dore/blob/4cf8917000558eedb054f97b4a1a0f7610a78235/examples/webview/www/js/DoreClient.js#L262-L269<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( test , message , optionalParams ) { return invoke ( 'CONSOLE' , { type : 'assert' , test : test , message : message , optionalParams : optionalParams || [ ] } ) ; }<CODESPLIT>0.13154920935630798<CODESPLIT>0.16081814467906952

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/DeadAlready/node-easy-pipe/blob/e739e052494cd6be96c95bc65e34442042243e7d/lib/pipeStream.js#L23-L60<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function createPipeStream ( cmd /*, args, opts*/ ) { var proc ; var command ; if ( Array . isArray ( cmd ) ) { // We have an array so create a pipe from all elements var firstCmd = cmd . shift ( ) ; var open = Array . isArray ( firstCmd ) ? createPipeStream . apply ( { } , firstCmd ) : createPipeStream ( firstCmd ) ; cmd . forEach ( function ( p ) { open = open . pipe ( p ) ; } ) ; return open ; } else if ( cmd instanceof EventEmitter ) { // Take the eventemitter as base proc = cmd ; command = 'pre-defined' ; } else if ( typeof cmd === 'object' ) { throw new TypeError ( 'Invalid input, expected object type -> EventEmitter' ) ; } else { // We have input for Spawn command, normalize the input and create spawn var input = utils . normalizeInput . apply ( this , arguments ) ; command = utils . getCommand ( input ) ; proc = spawn . apply ( { } , input ) ; } // Create inner pointer for command proc . _command = command ; // Check if process is still alive if ( proc . exitCode ) { throw new Error ( 'Process already dead' ) ; } return PipeStream ( proc ) ; }<CODESPLIT>0.16828416287899017<CODESPLIT>0.14523674547672272

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/othiym23/async-listener/blob/01a02ee123db3d4a98e0cc5dda6f8ef82c55f81e/glue.js#L391-L405<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function wrapCallback ( original ) { var length = listeners . length ; // no context to capture, so avoid closure creation if ( length === 0 ) return original ; // capture the active listeners as of when the wrapped function was called var list = listeners . slice ( ) ; for ( var i = 0 ; i < length ; ++ i ) { if ( list [ i ] . flags > 0 ) return asyncWrap ( original , list , length ) ; } return simpleWrap ( original , list , length ) ; }<CODESPLIT>0.16652768850326538<CODESPLIT>0.14586888253688812

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/liabru/matter-js/blob/2ec247b7af1c6b5da6ee05c73274ed5822c73503/src/body/Body.js#L141-L175<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( body , options ) { options = options || { } ; // init required properties (order is important) Body . set ( body , { bounds : body . bounds || Bounds . create ( body . vertices ) , positionPrev : body . positionPrev || Vector . clone ( body . position ) , anglePrev : body . anglePrev || body . angle , vertices : body . vertices , parts : body . parts || [ body ] , isStatic : body . isStatic , isSleeping : body . isSleeping , parent : body . parent || body } ) ; Vertices . rotate ( body . vertices , body . angle , body . position ) ; Axes . rotate ( body . axes , body . angle ) ; Bounds . update ( body . bounds , body . vertices , body . velocity ) ; // allow options to override the automatically calculated properties Body . set ( body , { axes : options . axes || body . axes , area : options . area || body . area , mass : options . mass || body . mass , inertia : options . inertia || body . inertia } ) ; // render properties var defaultFillStyle = ( body . isStatic ? '#2e2b44' : Common . choose ( [ '#006BA6' , '#0496FF' , '#FFBC42' , '#D81159' , '#8F2D56' ] ) ) , defaultStrokeStyle = '#000' ; body . render . fillStyle = body . render . fillStyle || defaultFillStyle ; body . render . strokeStyle = body . render . strokeStyle || defaultStrokeStyle ; body . render . sprite . xOffset += - ( body . bounds . min . x - body . position . x ) / ( body . bounds . max . x - body . bounds . min . x ) ; body . render . sprite . yOffset += - ( body . bounds . min . y - body . position . y ) / ( body . bounds . max . y - body . bounds . min . y ) ; }<CODESPLIT>0.1558479219675064<CODESPLIT>0.1305554211139679

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/zdfs/grunt-datadriver/blob/8c08f6dfe10a66c4b02a9a4fe42d4f64cb72354e/support/reporter.js#L24-L86<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ddReporter ( runner ) { Base . call ( this , runner ) ; var self = this , stats = this . stats , indents = 0 , n = 0 ; function indent ( ) { return Array ( indents ) . join ( '  ' ) } runner . on ( 'start' , function ( ) { console . log ( ) ; } ) ; runner . on ( 'suite' , function ( suite ) { ++ indents ; console . log ( color ( 'suite' , '%s%s' ) , indent ( ) , suite . title ) ; } ) ; runner . on ( 'suite end' , function ( suite ) { -- indents ; if ( 1 == indents ) console . log ( ) ; } ) ; runner . on ( 'pending' , function ( test ) { var fmt = indent ( ) + color ( 'pending' , '  - %s' ) ; console . log ( fmt , test . title ) ; } ) ; runner . on ( 'pass' , function ( test ) { if ( test . isAction ) { var fmt = indent ( ) + color ( 'pending' , '   %s');   cursor . CR ( ) ; self . stats . passes -- ; console . log ( fmt , test . title ) ; } else if ( 'fast' == test . speed ) { var fmt = indent ( ) + color ( 'checkmark' , '  ' + Base . symbols . ok ) + color ( 'pass' , ' %s' ) ; cursor . CR ( ) ; console . log ( fmt , test . title ) ; } else { var fmt = indent ( ) + color ( 'checkmark' , '  ' + Base . symbols . ok ) + color ( 'pass' , ' %s' ) + color ( test . speed , ' (%dms)' ) ; cursor . CR ( ) ; console . log ( fmt , test . title , test . duration ) ; } } ) ; runner . on ( 'fail' , function ( test , err ) { cursor . CR ( ) ; console . log ( indent ( ) + color ( 'fail' , '  %d) %s' ) , ++ n , test . title ) ; } ) ; runner . on ( 'end' , self . epilogue . bind ( self ) ) ; }<CODESPLIT>0.15751904249191284<CODESPLIT>0.13314884901046753

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/plain-precompiled-build.js#L16332-L16344<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( module , exports ) { "use strict" ; exports [ "default" ] = function ( obj ) { return obj && obj . __esModule ? obj : { "default" : obj } ; } ; exports . __esModule = true ; /***/ }<CODESPLIT>0.16242383420467377<CODESPLIT>0.1440909206867218

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/HydraJS/HydraJS/blob/ef3ede4aebd29081fe960eb86a37a1a4bf571b2d/src/libs/Bus.js#L97-L107<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function subscribersByEvent ( oChannel , sEventName ) { let aSubscribers = [ ] ; if ( ! isTypeOf ( oChannel , sNotDefined ) ) { iterateObject ( oChannel , function ( oItem , sKey ) { if ( sKey === sEventName ) { aSubscribers = oItem ; } } ) ; } return aSubscribers ; }<CODESPLIT>0.15672044456005096<CODESPLIT>0.13310183584690094

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/cubicmushroom/gulp-cm-phpspec-tasks/blob/671b5e6e9545c7a6a027f8b93c1349d491cf429e/pakmanaged.js#L43334-L43342<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function isAbsolute ( fp ) { if ( typeof fp !== 'string' ) { throw new TypeError ( 'isAbsolute expects a string.' ) ; } if ( ! isWindows ( ) && isAbsolute . posix ( fp ) ) { return true ; } return isAbsolute . win32 ( fp ) ; }<CODESPLIT>0.17495986819267273<CODESPLIT>0.14779874682426453

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/he9qi/ember-cli-emoji/blob/dcf4f38f5628369da6334aa7b5abc819adbf63a6/index.js#L26-L45<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( app , parentAddon ) { this . _super . included ( app ) ; var target = ( parentAddon || app ) ; target . import ( target . bowerDirectory + '/emojify/dist/js/emojify.js' ) ; if ( _emojiConfig . mode === 'sprites' ) { var destSpriteDir = 'images/sprites' ; var spritePath = '/emojify/dist/images/sprites/' ; target . import ( target . bowerDirectory + spritePath + 'emojify.png' , { destDir : destSpriteDir } ) ; target . import ( target . bowerDirectory + spritePath + 'emojify@2x.png' , { destDir : destSpriteDir } ) ; } }<CODESPLIT>0.1487845778465271<CODESPLIT>0.13542842864990234

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/aliqin/atui/blob/910e25b2dd8db456b5f7e47b48271c898dcb9a21/src/index.js#L134-L142<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getIEVersion ( ) { var agent = navigator . userAgent var reg = / MSIE\s?(\d+)(?:\.(\d+))? / i var matches = agent . match ( reg ) if ( matches != null ) { return { major : matches [ 1 ] , minor : matches [ 2 ] } } return { major : '-1' , minor : '-1' } }<CODESPLIT>0.16730841994285583<CODESPLIT>0.1350168138742447

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/tstachl/desk.js/blob/b339196cce68dbbc79d3075f2ebe82372972f4f5/lib/mixins/destroy.js#L18-L23<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function destroy ( callback ) { this . getClient ( ) . destroy ( this . definition . _links . self . href , function ( err , definition , response ) { if ( err ) return callback ( err ) ; callback ( ) ; } . bind ( this ) ) ; }<CODESPLIT>0.12401997298002243<CODESPLIT>0.15633220970630646

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/vedmalex/fte2/blob/5a516114deb8c4fa37936d83cebf6e8cc1825cd8/grammar/raw.pegjs.js#L2339-L2344<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function f ( arr ) { if ( arr ) { var merged = [ ] ; return merged . concat . apply ( merged , arr ) . join ( "" ) } }<CODESPLIT>0.15007013082504272<CODESPLIT>0.13049744069576263

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L72472-L72476<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function zip ( a , b ) { var arr = [ ] ; for ( var ch in a ) arr . push ( [ a [ ch ] , b [ ch ] ] ) ; return arr ; }<CODESPLIT>0.15477073192596436<CODESPLIT>0.12789487838745117

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L42122-L42136<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( ) { var namespaces = Ember . A ( Ember . Namespace . NAMESPACES ) , types = Ember . A ( ) ; namespaces . forEach ( function ( namespace ) { for ( var key in namespace ) { if ( ! namespace . hasOwnProperty ( key ) ) { continue ; } var name = Ember . String . dasherize ( key ) ; if ( ! ( namespace instanceof Ember . Application ) && namespace . toString ( ) ) { name = namespace + '/' + name ; } types . push ( name ) ; } } ) ; return types ; }<CODESPLIT>0.15545086562633514<CODESPLIT>0.13310471177101135

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/weikinhuang/closedinterval-git-hooks/blob/42d7e6874a4500bc3d6f9aaadf03324748930e44/lib/pre-commit/pre-commit-base.js#L77-L84<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function flushMessages ( ) { Object . keys ( messages ) . forEach ( function ( type ) { messages [ type ] . forEach ( function ( msg ) { writeLine ( msg . type + " error: [" + msg . file + ":" + msg . line + "] " + msg . message ) ; } ) ; } ) ; }<CODESPLIT>0.15991409122943878<CODESPLIT>0.13545189797878265

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/ftlabs/fruitmachine/blob/7ef6445c3a422e462074b4de5007c4662ae09347/examples/lib/delegate.js#L291-L336<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function handle ( listenerList , root , event ) { var listener , returned , specificList , target ; if ( event [ EVENT_IGNORE ] === true ) { return ; } target = event . target ; if ( target . nodeType === Node . TEXT_NODE ) { target = target . parentNode ; } specificList = listenerList [ event . type ] ; // If the fire function actually causes the specific list to be destroyed, // Need check that the specific list is still populated while ( target && specificList . length > 0 ) { listener = specificList . first ; do { // Check for match and fire the event if there's one // TODO:MCG:20120117: Need a way to check if event#stopImmediateProgagation was called. If so, break both loops. if ( listener . m . call ( target , listener . p , target ) ) { returned = fire ( event , target , listener ) ; } // Stop propagation to subsequent callbacks if the callback returned false if ( returned === false ) { event [ EVENT_IGNORE ] = true ; return ; } listener = listener . next ; // If the fire function actually causes the specific list object to be destroyed, // need a way of getting out of here so check listener is set } while ( listener !== specificList . first && listener ) ; // TODO:MCG:20120117: Need a way to check if event#stopProgagation was called. If so, break looping through the DOM. // Stop if the delegation root has been reached if ( target === root ) { break ; } target = target . parentElement ; } }<CODESPLIT>0.16027222573757172<CODESPLIT>0.1410181075334549

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/rrrene/inchjs/blob/453b4dac7a75707afc217fbacdea501179e0e5a4/lib/docs/retriever.js#L20-L24<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getIncluded ( ) { var args = config . files ( ) . included || getDefaultArgs ( ) || getPackageJsonArgs ( ) || getBowerJsonArgs ( ) || [ ] ; return _expandGlobs ( args ) ; }<CODESPLIT>0.16644012928009033<CODESPLIT>0.11699144542217255

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/lixinliang/require-extension-vue/blob/7e8d45cc3c734e4ddd8ca5f9ab23015739a38d6f/index.js#L77-L172<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function loader ( module , filePath ) { let content = fs . readFileSync ( filePath , 'utf8' ) ; let moduleId = ` ${ hash ( filePath ) } ` ; let vueTemplate = '' ; let vueComponent = compiler . parseComponent ( stripBom ( content ) ) ; let script = vueComponent . script ; let styles = vueComponent . styles ; let template = vueComponent . template ; let scoped = styles . some ( ( { attrs } ) => attrs . scoped ) ; [ ] . concat ( script , template , styles ) . forEach ( ( tag , index ) => { if ( tag ) { let type = tag . type ; let content = tag . content ; let lang = tag . attrs . lang || store [ type ] . defaults ; let handler = store [ type ] . langs [ lang ] ; if ( handler ) { content = handler ( content , filePath , index , module ) ; } switch ( type ) { case 'style' : if ( browserEnv ) { /**                          * Only in Browser Environment, append style to head                          */ if ( tag . attrs . scoped ) { let ast = css . parse ( content ) ; ast . stylesheet . rules . forEach ( ( rule ) => { rule . selectors = rule . selectors . map ( ( selector ) => { let [ patterns ] = cssWhat ( selector ) ; let index = patterns . length - 1 ; for ( ; index >= 0 ; index -- ) { let { type } = patterns [ index ] ; if ( type !== 'pseudo' && type !== 'pseudo-element' ) { break ; } } patterns . splice ( index + 1 , 0 , { value : '' , name : moduleId , action : 'exists' , type : 'attribute' , ignoreCase : false , } ) ; return cssWhat . stringify ( [ patterns ] ) ; } ) ; } ) ; content = css . stringify ( ast ) ; } let style = document . createElement ( 'style' ) ; style . innerHTML = content ; store . style . exports . call ( module . exports , style , { index , styles , filePath , } ) ; } break ; case 'script' : module . _compile ( content , filePath ) ; break ; case 'template' : if ( browserEnv ) { /**                          * Only in Browser Environment, set Attribute for each element                          */ if ( scoped ) { let div = document . createElement ( 'div' ) ; div . innerHTML = content ; let root = div . firstElementChild ; let walk = function walk ( element , handler ) { handler ( element ) ; let children = element . children || [ ] ; [ ] . forEach . call ( children , ( child ) => { walk ( child , handler ) ; } ) ; } ; walk ( root , ( element ) => { element . setAttribute ( moduleId , '' ) ; } ) ; content = div . innerHTML ; } } vueTemplate = content ; break ; } } } ) ; module . exports . vueComponent = vueComponent ; module . exports . template = vueTemplate ; }<CODESPLIT>0.13394951820373535<CODESPLIT>0.142666757106781

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/nowsecure/node-applesign/blob/84847c3f4a5037263d3b08ecc4cb049ff91ef259/index.js#L606-L622<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getResignedFilename ( input ) { if ( ! input ) { return null ; } const pos = input . lastIndexOf ( path . sep ) ; if ( pos !== - 1 ) { const tmp = input . substring ( pos + 1 ) ; const dot = tmp . lastIndexOf ( '.' ) ; input = ( dot !== - 1 ) ? tmp . substring ( 0 , dot ) : tmp ; } else { const dot = input . lastIndexOf ( '.' ) ; if ( dot !== - 1 ) { input = input . substring ( 0 , dot ) ; } } return input + '-resigned.ipa' ; }<CODESPLIT>0.16965509951114655<CODESPLIT>0.1229492798447609

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L42263-L42279<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function any ( fp , patterns , opts ) { if ( ! Array . isArray ( patterns ) && typeof patterns !== 'string' ) { throw new TypeError ( msg ( 'any' , 'patterns' , 'a string or array' ) ) ; } patterns = utils . arrayify ( patterns ) ; var len = patterns . length ; fp = utils . unixify ( fp , opts ) ; while ( len -- ) { var isMatch = matcher ( patterns [ len ] , opts ) ; if ( isMatch ( fp ) ) { return true ; } } return false ; }<CODESPLIT>0.16154398024082184<CODESPLIT>0.12706784904003143

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L23829-L23861<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function checkDecorator ( node ) { var signature = getResolvedSignature ( node ) ; var returnType = getReturnTypeOfSignature ( signature ) ; if ( returnType . flags & 1 /* Any */ ) { return ; } var expectedReturnType ; var headMessage = getDiagnosticHeadMessageForDecoratorResolution ( node ) ; var errorInfo ; switch ( node . parent . kind ) { case 214 /* ClassDeclaration */ : var classSymbol = getSymbolOfNode ( node . parent ) ; var classConstructorType = getTypeOfSymbol ( classSymbol ) ; expectedReturnType = getUnionType ( [ classConstructorType , voidType ] ) ; break ; case 138 /* Parameter */ : expectedReturnType = voidType ; errorInfo = ts . chainDiagnosticMessages ( errorInfo , ts . Diagnostics . The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any ) ; break ; case 141 /* PropertyDeclaration */ : expectedReturnType = voidType ; errorInfo = ts . chainDiagnosticMessages ( errorInfo , ts . Diagnostics . The_return_type_of_a_property_decorator_function_must_be_either_void_or_any ) ; break ; case 143 /* MethodDeclaration */ : case 145 /* GetAccessor */ : case 146 /* SetAccessor */ : var methodType = getTypeOfNode ( node . parent ) ; var descriptorType = createTypedPropertyDescriptorType ( methodType ) ; expectedReturnType = getUnionType ( [ descriptorType , voidType ] ) ; break ; } checkTypeAssignableTo ( returnType , expectedReturnType , node , headMessage , errorInfo ) ; }<CODESPLIT>0.16641998291015625<CODESPLIT>0.14699751138687134

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/rootsdev/gedcomx-fs-js/blob/47b6c6c9a609e163d80673d08fc83073f730d9d8/src/OAuth2.js#L10-L23<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( json ) { // Protect against forgetting the new keyword when calling the constructor if ( ! ( this instanceof OAuth2 ) ) { return new OAuth2 ( json ) ; } // If the given object is already an instance then just return it. DON'T copy it. if ( OAuth2 . isInstance ( json ) ) { return json ; } this . init ( json ) ; }<CODESPLIT>0.1339670717716217<CODESPLIT>0.15114785730838776

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/flowjs/flow.js/blob/aadc5a72b1414d87ed1aa3563b30209f9b1f7773/dist/flow.js#L955-L973<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( ) { if ( this . error ) { return 1 ; } if ( this . chunks . length === 1 ) { this . _prevProgress = Math . max ( this . _prevProgress , this . chunks [ 0 ] . progress ( ) ) ; return this . _prevProgress ; } // Sum up progress across everything var bytesLoaded = 0 ; each ( this . chunks , function ( c ) { // get chunk progress relative to entire file bytesLoaded += c . progress ( ) * ( c . endByte - c . startByte ) ; } ) ; var percent = bytesLoaded / this . size ; // We don't want to lose percentages when an upload is paused this . _prevProgress = Math . max ( this . _prevProgress , percent > 0.9999 ? 1 : percent ) ; return this . _prevProgress ; }<CODESPLIT>0.14481765031814575<CODESPLIT>0.12350180000066757

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/Strider-CD/strider/blob/56cafbc9687ebb7b67d485ec387a03cb85791c7c/lib/auth.js#L272-L279<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function requireUser ( req , res , next ) { if ( req . user ) { next ( ) ; } else { req . session . return_to = req . url ; res . redirect ( '/login' ) ; } }<CODESPLIT>0.1639992743730545<CODESPLIT>0.11602196842432022

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/mobilehero-archive/aplus-node/blob/a16e11722406eb42f7b9e182c1301ffe2b706b67/resolver/resolve-fix.js#L114-L123<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function replaceBackSlashes ( input ) { var isExtendedLengthPath = / ^\\\\\?\\ / . test ( input ) ; var hasNonAscii = / [^\x00-\x80]+ / . test ( input ) ; if ( isExtendedLengthPath || hasNonAscii ) { return input ; } return input . replace ( / \\ / g , '/' ) ; }<CODESPLIT>0.16645652055740356<CODESPLIT>0.12142499536275864

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L45108-L45114<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getScopeNode ( initialToken , position , sourceFile ) { var scope = initialToken ; while ( scope && ! ts . positionBelongsToNode ( scope , position , sourceFile ) ) { scope = scope . parent ; } return scope ; }<CODESPLIT>0.15612512826919556<CODESPLIT>0.14756041765213013

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L7387-L7394<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( type , query ) { return DS . AdapterPopulatedRecordArray . create ( { type : type , query : query , content : Ember . A ( ) , store : this . store } ) ; }<CODESPLIT>0.15000686049461365<CODESPLIT>0.1690003126859665

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/andrao/node-analytics/blob/170bca2d2985cc384aa584b0e588221a96630834/node-analytics.js#L520-L606<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function sessionData ( req , res , session , cb ) { const now = new Date ( ) ; if ( session . continued ) return cb ( null , req , res , session ) ; async . parallelLimit ( [ getIp , getLocation , getSystem ] , 2 , function ( err ) { cb ( err , this . req , this . res , this . session ) ; if ( opts . log_all ) log . timer ( 'sessionData' , now ) ; } . bind ( { req : req , res : res , session : session } ) ) ; // ====================== // .ip function getIp ( cb ) { session . ip = get_ip ( req ) . clientIp ; cb ( null ) } // .geo :: .city, .state, .country function getLocation ( cb ) { if ( ! geo_lookup ) return cb ( null ) ; const loc = geo_lookup . get ( session . ip ) ; if ( ! session . geo ) session . geo = { } ; if ( loc ) { try { if ( loc . city ) session . geo . city = loc . city . names . en ; if ( loc . subdivisions ) session . geo . state = loc . subdivisions [ 0 ] . iso_code ; if ( loc . country ) session . geo . country = loc . country . iso_code ; if ( loc . continent ) session . geo . continent = loc . continent . code ; if ( loc . location ) session . geo . time_zone = loc . location . time_zone ; } catch ( e ) { log . error ( 'geoIP error:' , e ) ; } } cb ( null ) } // .system :: .os{, .broswer{ .name, .version function getSystem ( cb ) { var agent = useragent . parse ( req . headers [ 'user-agent' ] ) ; var os = agent . os ; if ( ! session . system ) session . system = { } ; if ( ! session . system . browser ) session . system . browser = { } ; if ( ! session . system . os ) session . system . os = { } ; session . system . browser . name = agent . family ; session . system . browser . version = agent . major + '.' + agent . minor + '.' + agent . patch ; session . system . os . name = os . family ; session . system . os . version = os . major + '.' + os . minor + '.' + os . patch ; cb ( null ) } }<CODESPLIT>0.17166036367416382<CODESPLIT>0.137321338057518

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/FCOO/fcoo-grunt-plugin/blob/03d8b5c0b493244b4db3d08844554b31306ca8bf/lib/common.js#L31-L33<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function readJSONFile ( filename , defaultContents ) { return readFile ( filename , true , true , defaultContents === null ? { } : defaultContents ) ; }<CODESPLIT>0.12076065689325333<CODESPLIT>0.13282275199890137

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/pureqml/qmlcore/blob/21416cb4b45dce6cf6c603dfa43d6683e0d48638/platform/video.videojs/dist/video.es.js#L2945-L2972<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function mergeOptions ( ) { var result = { } ; for ( var _len = arguments . length , sources = Array ( _len ) , _key = 0 ; _key < _len ; _key ++ ) { sources [ _key ] = arguments [ _key ] ; } sources . forEach ( function ( source ) { if ( ! source ) { return ; } each ( source , function ( value , key ) { if ( ! isPlain ( value ) ) { result [ key ] = value ; return ; } if ( ! isPlain ( result [ key ] ) ) { result [ key ] = { } ; } result [ key ] = mergeOptions ( result [ key ] , value ) ; } ) ; } ) ; return result ; }<CODESPLIT>0.14924831688404083<CODESPLIT>0.13102993369102478

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/AndreasMadsen/domstream-client/blob/f21874a1f4be81f778ed4922c829e96b15c75cd4/module.js#L40-L54<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function Search ( document , tree ) { this . document = document ; this . tree = tree ; this . onlyFlag = false ; this . onlySearch = false ; this . searchFilled = false ; this . searchList = { 'id' : null , 'tag' : null , 'attr' : [ ] } ; this . nodeList = [ ] ; }<CODESPLIT>0.1529572308063507<CODESPLIT>0.1295226365327835

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/nearform/nscale-kernel/blob/5b9a544a6f2ffdc87294fee3fd00b81667ac0ab3/lib/api.js#L55-L60<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( identifier , target , cb ) { logger . info ( 'get head system: ' + identifier ) ; var systemId = _sr . findSystem ( identifier ) ; if ( ! systemId ) { logger . error ( ERR_NOSYSID ) ; return cb ( new Error ( ERR_NOSYSID ) ) ; } _sr . getHead ( systemId , target , cb ) ; }<CODESPLIT>0.16267724335193634<CODESPLIT>0.1373916119337082

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/localvoid/karma-snapshot/blob/ec3f41bab775b5be6d3aa236f55ee12881b25662/lib/index.js#L29-L35<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function defaultPathResolver ( basePath , suiteName ) { const suiteSourcePath = path . join ( basePath , suiteName ) ; const suiteSourceDir = path . dirname ( suiteSourcePath ) ; const sourceFileName = path . basename ( suiteName ) ; return path . join ( suiteSourceDir , "__snapshots__" , sourceFileName + ".md" ) ; }<CODESPLIT>0.13589924573898315<CODESPLIT>0.1500118374824524

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/algolia/algoliasearch-helper-js/blob/9ebdd34ab98a3298a7687f81dfef24b01e798c53/src/SearchResults/index.js#L548-L576<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function extractNormalizedFacetValues ( results , attribute ) { var predicate = { name : attribute } ; if ( results . _state . isConjunctiveFacet ( attribute ) ) { var facet = find ( results . facets , predicate ) ; if ( ! facet ) return [ ] ; return map ( facet . data , function ( v , k ) { return { name : k , count : v , isRefined : results . _state . isFacetRefined ( attribute , k ) , isExcluded : results . _state . isExcludeRefined ( attribute , k ) } ; } ) ; } else if ( results . _state . isDisjunctiveFacet ( attribute ) ) { var disjunctiveFacet = find ( results . disjunctiveFacets , predicate ) ; if ( ! disjunctiveFacet ) return [ ] ; return map ( disjunctiveFacet . data , function ( v , k ) { return { name : k , count : v , isRefined : results . _state . isDisjunctiveFacetRefined ( attribute , k ) } ; } ) ; } else if ( results . _state . isHierarchicalFacet ( attribute ) ) { return find ( results . hierarchicalFacets , predicate ) ; } }<CODESPLIT>0.1597098410129547<CODESPLIT>0.14596544206142426

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/Katochimoto/xblocks-core/blob/714102b7c2adb4ae197403df252e967a1b967bb1/src/xblocks/block.js#L215-L225<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function blockCreate ( node ) { if ( node . hasChildNodes ( ) ) { Array . prototype . forEach . call ( node . querySelectorAll ( 'script[type="text/x-template"][ref],template[ref]' ) , tmplCompileIterator , node ) ; } node [ Constants . BLOCK ] = new XBElement ( node ) ; }<CODESPLIT>0.1636473834514618<CODESPLIT>0.1427694410085678

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/incuna/node-yaml-merge/blob/08fd6e540e30e40a4fd9325e3b7b9968a47044c8/lib/yaml-merge.js#L12-L28<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( files ) { if ( ! _ . isArray ( files ) ) { throw new Error ( 'Arguments to config-helper.mergeConfig should be an array' ) ; } var appConfig = { } ; files . forEach ( function ( filePath ) { if ( gruntFile . exists ( filePath ) ) { var fileConfig = gruntFile . readYAML ( filePath ) ; // Use lodash to do a 'deep merge' which only overwrites the properties // specified in previous config files, without wiping out their child properties. _ . merge ( appConfig , fileConfig ) ; } } ) ; return appConfig ; }<CODESPLIT>0.1414777934551239<CODESPLIT>0.12967194616794586

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/acalvoa/sails-hook-multitenant/blob/640a51cc1cbf47487e20172524e9efbb765cdf25/lib/internal/querys/stream.js#L298-L467<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function _beginBatchMaybe ( next ) { // 0   => 15 // 15  => 15 // 30  => 15 // 45  => 5 // 50 var numRecordsLeftUntilAbsLimit = query . criteria . limit - ( i * BATCH_SIZE ) ; var limitForThisBatch = Math . min ( numRecordsLeftUntilAbsLimit , BATCH_SIZE ) ; var skipForThisBatch = query . criteria . skip + ( i * BATCH_SIZE ) ; //                     |_initial offset    +  |_relative offset from end of previous batch // If we've exceeded the absolute limit, then we go ahead and stop. if ( limitForThisBatch <= 0 ) { reachedLastBatch = true ; return next ( ) ; } //- // Build the criteria + deferred object to do a `.find()` for this batch. var criteriaForThisBatch = { skip : skipForThisBatch , limit : limitForThisBatch , sort : query . criteria . sort , select : query . criteria . select , omit : query . criteria . omit , where : query . criteria . where } ; // console.log('---iterating---'); // console.log('i:',i); // console.log('   BATCH_SIZE:',BATCH_SIZE); // console.log('   query.criteria.limit:',query.criteria.limit); // console.log('   query.criteria.skip:',query.criteria.skip); // console.log('   query.criteria.sort:',query.criteria.sort); // console.log('   query.criteria.where:',query.criteria.where); // console.log('   query.criteria.select:',query.criteria.select); // console.log('   query.criteria.omit:',query.criteria.omit); // console.log('   --'); // console.log('   criteriaForThisBatch.limit:',criteriaForThisBatch.limit); // console.log('   criteriaForThisBatch.skip:',criteriaForThisBatch.skip); // console.log('   criteriaForThisBatch.sort:',criteriaForThisBatch.sort); // console.log('   criteriaForThisBatch.where:',criteriaForThisBatch.where); // console.log('   criteriaForThisBatch.select:',criteriaForThisBatch.select); // console.log('   criteriaForThisBatch.omit:',criteriaForThisBatch.omit); // console.log('------'); var deferredForThisBatch = WLModel . find ( criteriaForThisBatch ) ; _ . each ( query . populates , function ( assocCriteria , assocName ) { deferredForThisBatch = deferredForThisBatch . populate ( assocName , assocCriteria ) ; } ) ; // Pass through `meta` so we're sure to use the same db connection // and settings (i.e. esp. relevant if we happen to be inside a transaction) deferredForThisBatch . meta ( query . meta ) ; deferredForThisBatch . exec ( function ( err , batchOfRecords ) { if ( err ) { return next ( err ) ; } // If there were no records returned, then we have already reached the last batch of results. // (i.e. it was the previous batch-- since this batch was empty) // In this case, we'll set the `reachedLastBatch` flag and trigger our callback, // allowing `async.whilst()` to call _its_ callback, which will pass control back // to userland. if ( batchOfRecords . length === 0 ) { reachedLastBatch = true ; return next ( ) ; } // -- // But otherwise, we need to go ahead and call the appropriate // iteratee for this batch.  If it's eachBatchFn, we'll call it // once.  If it's eachRecordFn, we'll call it once per record. ( function _makeCallOrCallsToAppropriateIteratee ( proceed ) { // If an `eachBatchFn` iteratee was provided, we'll call it. // > At this point we already know it's a function, because // > we validated usage at the very beginning. if ( query . eachBatchFn ) { // Note that, if you try to call next() more than once in the iteratee, Waterline // logs a warning explaining what's up, ignoring all subsequent calls to next() // that occur after the first. var didIterateeAlreadyHalt ; try { var promiseMaybe = query . eachBatchFn ( batchOfRecords , function ( err ) { if ( err ) { return proceed ( err ) ; } if ( didIterateeAlreadyHalt ) { console . warn ( 'Warning: The per-batch iteratee provided to `.stream()` triggered its callback \n' + 'again-- after already triggering it once!  Please carefully check your iteratee\'s \n' + 'code to figure out why this is happening.  (Ignoring this subsequent invocation...)' ) ; return ; } //- didIterateeAlreadyHalt = true ; return proceed ( ) ; } ) ; //__  </ invoked per-batch iteratee > // Take care of unhandled promise rejections from `await`. if ( query . eachBatchFn . constructor . name === 'AsyncFunction' ) { promiseMaybe . catch ( function ( e ) { proceed ( e ) ; } ) ; //__ } } catch ( e ) { return proceed ( e ) ; } //>- return ; } //__. // Otherwise `eachRecordFn` iteratee must have been provided. // We'll call it once per record in this batch. // > We validated usage at the very beginning, so we know that // > one or the other iteratee must have been provided as a // > valid function if we made it here. async . eachSeries ( batchOfRecords , function _eachRecordInBatch ( record , next ) { // Note that, if you try to call next() more than once in the iteratee, Waterline // logs a warning explaining what's up, ignoring all subsequent calls to next() // that occur after the first. var didIterateeAlreadyHalt ; try { var promiseMaybe = query . eachRecordFn ( record , function ( err ) { if ( err ) { return next ( err ) ; } if ( didIterateeAlreadyHalt ) { console . warn ( 'Warning: The per-record iteratee provided to `.stream()` triggered its callback\n' + 'again-- after already triggering it once!  Please carefully check your iteratee\'s\n' + 'code to figure out why this is happening.  (Ignoring this subsequent invocation...)' ) ; return ; } //- didIterateeAlreadyHalt = true ; return next ( ) ; } ) ; //__  </ invoked per-record iteratee > // Take care of unhandled promise rejections from `await`. if ( query . eachRecordFn . constructor . name === 'AsyncFunction' ) { promiseMaybe . catch ( function ( e ) { next ( e ) ; } ) ; //__ } } catch ( e ) { return next ( e ) ; } } , // ~% function _afterIteratingOverRecordsInBatch ( err ) { if ( err ) { return proceed ( err ) ; } return proceed ( ) ; } ) ; //</async.eachSeries()> } ) ( function _afterCallingIteratee ( err ) { if ( err ) { return next ( err ) ; } // Increment the batch counter. i ++ ; // On to the next batch! return next ( ) ; } ) ; //</self-calling function :: process this batch by making either one call or multiple calls to the appropriate iteratee> } ) ; //</deferredForThisBatch.exec()> }<CODESPLIT>0.16151416301727295<CODESPLIT>0.14177832007408142

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/beyo/model/blob/625b386b6e1141e1869ede753640850c0c9f0971/lib/collection.js#L54-L123<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function find ( filter ) { var item ; var i ; var ilen ; var keys ; var key ; var k ; var klen ; var found ; if ( filter instanceof Function ) { for ( i = 0 , ilen = this . items . length ; i < ilen ; ++ i ) { item = this . items [ i ] ; if ( filter ( item , i ) ) { return item ; } } } else if ( filter !== null && filter !== undefined ) { if ( typeof filter === 'object' ) { keys = Object . keys ( filter ) ; klen = keys . length ; for ( i = 0 , ilen = this . items . length ; i < ilen ; ++ i ) { item = this . items [ i ] ; found = true ; for ( k = 0 ; k < klen && found ; ++ k ) { key = keys [ k ] ; if ( filter [ key ] !== item [ key ] ) { found = false ; } } if ( found ) { return item ; } } } else if ( this . modelType ) { keys = Object . keys ( this . modelType . attributes ) ; klen = keys . length ; for ( i = 0 , ilen = this . items . length ; i < ilen ; ++ i ) { item = this . items [ i ] ; found = false ; for ( k = 0 ; k < klen && ! found ; ++ k ) { key = keys [ k ] ; if ( filter === item [ key ] ) { found = true ; } } if ( found ) { return item ; } } } else { for ( i = 0 , ilen = this . items . length ; i < ilen ; ++ i ) { item = this . items [ i ] ; found = false ; keys = Object . keys ( item ) ; for ( k = 0 , klen = keys . length ; k < klen && ! found ; ++ k ) { key = keys [ k ] ; if ( filter === item [ key ] ) { found = true ; } } if ( found ) { return item ; } } } } return undefined ; }<CODESPLIT>0.16780544817447662<CODESPLIT>0.14204129576683044

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L11274-L11283<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function isInvalidChar ( str ) { var ch = toStr ( str ) ; return ch === '\\' || ch === '[' || ch === ']' || ch === '^' || ch === '(' || ch === ')' || ch === '`' ; }<CODESPLIT>0.1678135246038437<CODESPLIT>0.13344833254814148

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/sepehr-laal/livecam/blob/e229dee6efbfe58aba29fde82c79ccf008e08510/livecam.js#L6-L154<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function GstLaunch ( ) { const gst_launch_executable = 'gst-launch-1.0' ; const gst_launch_versionarg = '--version' ; const SpawnSync = require ( 'child_process' ) . spawnSync ; const Spawn = require ( 'child_process' ) . spawn ; const Assert = require ( 'assert' ) ; const Path = require ( 'path' ) ; const OS = require ( 'os' ) ; const FS = require ( 'fs' ) ; /**    * @fn getPath    * @brief Returns path to gst-launch or undefined on error    */ var getPath = function ( ) { var detected_path = undefined ; if ( OS . platform ( ) == 'win32' ) { // On Windows, GStreamer MSI installer defines the following // environment variables. const detected_path_x64 = process . env . GSTREAMER_1_0_ROOT_X86_64 ; const detected_path_x32 = process . env . GSTREAMER_1_0_ROOT_X86 ; if ( detected_path_x64 || detected_path_x32 ) { // If both variables are present, favor the architecture // of GStreamer which is the same as Node.js runtime. if ( detected_path_x64 && detected_path_x32 ) { if ( process . arch == 'x64' ) detected_path = detected_path_x64 ; else if ( process . arch == 'x32' ) detected_path = detected_path_x32 ; } else { detected_path = detected_path_x64 || detected_path_x32 ; } } if ( detected_path ) { detected_path = Path . join ( detected_path , 'bin' , ( gst_launch_executable + '.exe' ) ) ; try { FS . accessSync ( detected_path , FS . F_OK ) ; } catch ( e ) { detected_path = undefined ; } } else { // Look for GStreamer on PATH var path_dirs = process . env . PATH . split ( ';' ) ; for ( var index = 0 ; index < path_dirs . length ; ++ index ) { try { var base = Path . normalize ( path_dirs [ index ] ) ; var bin = Path . join ( base , ( gst_launch_executable + '.exe' ) ) ; FS . accessSync ( bin , FS . F_OK ) ; detected_path = bin ; } catch ( e ) { /* no-op */ } } } } else if ( OS . platform ( ) == 'linux' ) { // Look for GStreamer on PATH var path_dirs = process . env . PATH . split ( ':' ) ; for ( var index = 0 ; index < path_dirs . length ; ++ index ) { try { var base = Path . normalize ( path_dirs [ index ] ) ; var bin = Path . join ( base , gst_launch_executable ) ; FS . accessSync ( bin , FS . F_OK ) ; detected_path = bin ; } catch ( e ) { /* no-op */ } } } else if ( OS . platform ( ) == 'darwin' ) { try { var bin = '/usr/local/bin/gst-launch-1.0' FS . accessSync ( bin , FS . F_OK ) ; detected_path = bin ; } catch ( e ) { /* no-op */ } } return detected_path ; } /**    * @fn getVersion    * @brief Returns version string of GStreamer on this machine by    * invoking the gst-launch executable or 'undefined' on failure.    */ var getVersion = function ( ) { var version_str = undefined ; try { var gst_launch_path = getPath ( ) ; Assert . ok ( typeof ( gst_launch_path ) , 'string' ) ; var output = SpawnSync ( gst_launch_path , [ gst_launch_versionarg ] , { 'timeout' : 1000 } ) . stdout ; if ( output && output . toString ( ) . includes ( 'GStreamer' ) ) { version_str = output . toString ( ) . match ( / GStreamer\s+.+ / g ) [ 0 ] . replace ( / GStreamer\s+ / , '' ) ; } } catch ( ex ) { version_str = undefined ; } return version_str ; } /*!    * @fn isAvailable    * @brief Answers true if gst-launch executable is available    */ var isAvailable = function ( ) { return getVersion ( ) != undefined ; } /*!    * @fn spawnPipeline    * @brief Spawns a GStreamer pipeline using gst-launch    * @return A Node <child-process> of the launched pipeline    * @see To construct a correct pipeline arg, consult the link below:    * https://gstreamer.freedesktop.org/data/doc/gstreamer/head/manual/html/chapter-programs.html    * @usage spawnPipeline('videotestsrc ! autovideosink')    */ var spawnPipeline = function ( pipeline ) { Assert . ok ( typeof ( pipeline ) , 'string' ) ; Assert . ok ( isAvailable ( ) , "gst-launch is not available." ) ; var gst_launch_path = getPath ( ) ; Assert . ok ( typeof ( gst_launch_path ) , 'string' ) ; return Spawn ( gst_launch_path , pipeline . split ( ' ' ) ) ; } return { 'getPath' : getPath , 'getVersion' : getVersion , 'isAvailable' : isAvailable , 'spawnPipeline' : spawnPipeline } }<CODESPLIT>0.16507560014724731<CODESPLIT>0.09379414469003677

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/rrrene/inchjs/blob/453b4dac7a75707afc217fbacdea501179e0e5a4/lib/inch.js#L18-L25<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function run ( inch_args , options ) { var callback = function ( filename ) { LocalInch . run ( inch_args || [ 'suggest' ] , filename , noop ) ; } if ( options . dry_run ) callback = noop ; retriever . run ( PathExtractor . extractPaths ( inch_args ) , callback ) ; }<CODESPLIT>0.16694246232509613<CODESPLIT>0.1306629776954651

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/musicode/gulp-resource/blob/a036c496591cf9af7e53ac0b8cd661788d74bf2a/index.js#L829-L840<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( options ) { var me = this ; return me . custom ( function ( file , callback ) { cssDependencies ( file , me , options ) ; callback ( ) ; } ) ; }<CODESPLIT>0.15011464059352875<CODESPLIT>0.13978074491024017

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/moxiecode/moxie/blob/09eaf578f38480dc4b8e2017c473c496883b6168/src/javascript/core/utils/Events.js#L102-L149<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( obj , name , callback ) { var type , undef ; name = name . toLowerCase ( ) ; if ( obj [ uid ] && eventhash [ obj [ uid ] ] && eventhash [ obj [ uid ] ] [ name ] ) { type = eventhash [ obj [ uid ] ] [ name ] ; } else { return ; } for ( var i = type . length - 1 ; i >= 0 ; i -- ) { // undefined or not, key should match if ( type [ i ] . orig === callback || type [ i ] . key === callback ) { if ( obj . removeEventListener ) { obj . removeEventListener ( name , type [ i ] . func , false ) ; } else if ( obj . detachEvent ) { obj . detachEvent ( 'on' + name , type [ i ] . func ) ; } type [ i ] . orig = null ; type [ i ] . func = null ; type . splice ( i , 1 ) ; // If callback was passed we are done here, otherwise proceed if ( callback !== undef ) { break ; } } } // If event array got empty, remove it if ( ! type . length ) { delete eventhash [ obj [ uid ] ] [ name ] ; } // If mOxie registry has become empty, remove it if ( Basic . isEmptyObj ( eventhash [ obj [ uid ] ] ) ) { delete eventhash [ obj [ uid ] ] ; // IE doesn't let you remove DOM object property with - delete try { delete obj [ uid ] ; } catch ( e ) { obj [ uid ] = undef ; } } }<CODESPLIT>0.16286936402320862<CODESPLIT>0.14108781516551971

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/typhonjs-node-esdoc/esdoc-plugin-dependency-graphs/blob/af2d9cabce2d48edd4ad7ed81c722cc27efacb67/template/html/d3-graph.js#L219-L229<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function detectAllNodesFixed ( ) { if ( data ) { var currentNodesFixed = data . allNodesFixed ; var allNodesFixed = true ; data . nodes . forEach ( function ( node ) { if ( ! node . fixed ) { allNodesFixed = false ; } } ) ; data . allNodesFixed = allNodesFixed ; if ( currentNodesFixed !== allNodesFixed ) { updateMenuUI ( ) ; } // Update freeze / unfreeze menu option. } }<CODESPLIT>0.16083304584026337<CODESPLIT>0.12809696793556213

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/AndreasMadsen/article/blob/8cf3777fc9dc72d041214faae1b8d65d37a7d134/lib/helpers-dom.js#L60-L109<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function buildAttributeMatcher ( match ) { var keys = Object . keys ( match ) ; var jskey , i , l ; var transform = '' ; var bool = '' ; transform = 'transform = {\n' ; for ( i = 0 , l = keys . length ; i < l ; i ++ ) { jskey = JSON . stringify ( keys [ i ] ) ; transform += '  ' + jskey + ': attr.hasOwnProperty(' + jskey + ') ? attr[' + jskey + '].toLowerCase() : false' ; if ( i !== l - 1 ) transform += ',' ; transform += '\n' ; } transform += '};\n' ; bool = 'return !!(' ; for ( i = 0 , l = keys . length ; i < l ; i ++ ) { jskey = JSON . stringify ( keys [ i ] ) ; if ( i > 0 ) bool += '    ||    ' ; bool += ' ( transform[' + jskey + ']' ; if ( Array . isArray ( match [ keys [ i ] ] ) ) { bool += ' && ( ' ; for ( var j = 0 , s = match [ keys [ i ] ] . length ; j < s ; j ++ ) { if ( j > 0 ) bool += ' || ' ; if ( typeof match [ keys [ i ] ] [ j ] === 'string' ) { bool += 'transform[' + jskey + '] === \'' + match [ keys [ i ] ] [ j ] . toLowerCase ( ) + '\'' ; } else if ( util . isRegExp ( match [ keys [ i ] ] [ j ] ) ) { bool += 'match[' + jskey + '][' + j + '].test(transform[' + jskey + '])' ; } } bool += ' )' ; } bool += ' ) \n' ; } bool += '         );' ; var anonymous = new Function ( 'attr' , 'match' , transform + '\n' + bool ) ; return function ( attr ) { return anonymous ( attr , match ) ; } ; }<CODESPLIT>0.15939220786094666<CODESPLIT>0.1344231367111206

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/standardhealth/shr-json-schema-export/blob/7f6d0994185028edc3cf930e233592f5fd54c57d/lib/export.js#L1101-L1123<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function supportsCodeConstraint ( identifier , dataElementSpecs ) { if ( CODE . equals ( identifier ) || checkHasBaseType ( identifier , new Identifier ( 'shr.core' , 'Coding' ) , dataElementSpecs ) || checkHasBaseType ( identifier , new Identifier ( 'shr.core' , 'CodeableConcept' ) , dataElementSpecs ) ) { return true ; } const element = dataElementSpecs . findByIdentifier ( identifier ) ; if ( element . value ) { if ( element . value instanceof IdentifiableValue ) { return CODE . equals ( element . value . identifier ) || checkHasBaseType ( element . value . identifier , new Identifier ( 'shr.core' , 'Coding' ) , dataElementSpecs ) || checkHasBaseType ( element . value . identifier , new Identifier ( 'shr.core' , 'CodeableConcept' ) , dataElementSpecs ) ; } else if ( element . value instanceof ChoiceValue ) { for ( const value of element . value . aggregateOptions ) { if ( value instanceof IdentifiableValue ) { if ( CODE . equals ( value . identifier ) || checkHasBaseType ( value . identifier , new Identifier ( 'shr.core' , 'Coding' ) , dataElementSpecs ) || checkHasBaseType ( value . identifier , new Identifier ( 'shr.core' , 'CodeableConcept' ) , dataElementSpecs ) ) { return true ; } } } } } return false ; }<CODESPLIT>0.14222779870033264<CODESPLIT>0.1431940495967865

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/jeka-kiselyov/mdict/blob/540898e63991cb0c8985ed8fb29eb11a59f35089/mdict-parser.js#L286-L1023<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function parse_mdict ( file , ext ) { var KEY_INDEX , // keyword index array RECORD_BLOCK_TABLE = createRecordBlockTable ( ) ; // record block table var attrs = { } , // storing dictionary attributes _v2 , // true if enginge version > 2 _bpu , // bytes per unit when converting text size to byte length for text data _tail , // need to skip extra tail bytes after decoding text _decoder , // text decorder _decryptors = [ false , false ] , // [keyword_header_decryptor, keyword_index_decryptor], only keyword_index_decryptor is supported _searchTextLen , // search NUL to get text length _readShort = function ( scanner ) { return scanner . readUint8 ( ) ; } , // read a "short" number representing kewword text size, 8-bit for version < 2, 16-bit for version >= 2 _readNum = function ( scanner ) { return scanner . readInt ( ) ; } , // Read a number representing offset or data block size, 16-bit for version < 2, 32-bit for version >= 2 _checksum_v2 = function ( ) { } , // Version >= 2.0 only checksum _adaptKey = function ( key ) { return key ; } , // adapt key by converting to lower case or stripping punctuations according to dictionary attributes (KeyCaseSensitive, StripKey) _slice = sliceThen . bind ( null , file ) ; // bind sliceThen() with file argument           /**      * Config scanner according to dictionary attributes.      */ function config ( ) { attrs . Encoding = attrs . Encoding || 'UTF-16' ; _searchTextLen = ( attrs . Encoding === 'UTF-16' ) ? function ( dv , offset ) { offset = offset ; var mark = offset ; while ( dv . getUint16 ( offset ++ ) ) { /* scan for NUL */ } ; return offset - mark ; } : function ( dv , offset ) { offset = offset ; var mark = offset ; while ( dv . getUint8 ( offset ++ ) ) { /* scan for NUL */ } return offset - mark - 1 ; } ; _decoder = new TextDecoder ( attrs . Encoding || 'UTF-16LE' ) ; _bpu = ( attrs . Encoding === 'UTF-16' ) ? 2 : 1 ; if ( parseInt ( attrs . GeneratedByEngineVersion , 10 ) >= 2.0 ) { _v2 = true ; _tail = _bpu ; // HUGE dictionary file (>4G) is not supported, take only lower 32-bit _readNum = function ( scanner ) { return scanner . forward ( 4 ) , scanner . readInt ( ) ; } ; _readShort = function ( scanner ) { return scanner . readUint16 ( ) ; } ; _checksum_v2 = function ( scanner ) { return scanner . checksum ( ) ; } ; } else { _tail = 0 ; } // keyword index decrypted? if ( attrs . Encrypted & 0x02 ) { _decryptors [ 1 ] = decrypt ; } var regexp = common . REGEXP_STRIPKEY [ ext ] ; if ( isTrue ( attrs . KeyCaseSensitive ) ) { _adaptKey = isTrue ( attrs . StripKey ) ? function ( key ) { return key . replace ( regexp , '$1' ) ; } : function ( key ) { return key ; } ; } else { _adaptKey = isTrue ( attrs . StripKey || ( _v2 ? '' : 'yes' ) ) ? function ( key ) { return key . toLowerCase ( ) . replace ( regexp , '$1' ) ; } : function ( key ) { return key . toLowerCase ( ) ; } ; } } // Read data in current offset from target data ArrayBuffer function Scanner ( buf , len ) { var offset = 0 , dv = new DataView ( buf ) ; var methods = { // target data size in bytes size : function ( ) { return len || buf . byteLength ; } , // update offset to new position forward : function ( len ) { return offset += len ; } , // return current offset offset : function ( ) { return offset ; } , // MDict file format uses big endian to store number // 32-bit unsigned int readInt : function ( ) { return conseq ( dv . getUint32 ( offset , false ) , this . forward ( 4 ) ) ; } , readUint16 : function ( ) { return conseq ( dv . getUint16 ( offset , false ) , this . forward ( 2 ) ) ; } , readUint8 : function ( ) { return conseq ( dv . getUint8 ( offset , false ) , this . forward ( 1 ) ) ; } , // Read a "short" number representing keyword text size, 8-bit for version < 2, 16-bit for version >= 2 readShort : function ( ) { return _readShort ( this ) ; } , // Read a number representing offset or data block size, 16-bit for version < 2, 32-bit for version >= 2 readNum : function ( ) { return _readNum ( this ) ; } , readUTF16 : function ( len ) { return conseq ( UTF_16LE . decode ( newUint8Array ( buf , offset , len ) ) , this . forward ( len ) ) ; } , // Read data to an Uint8Array and decode it to text with specified encoding. // Text length in bytes is determined by searching terminated NUL. // NOTE: After decoding the text, it is need to forward extra "tail" bytes according to specified encoding.  readText : function ( ) { var len = _searchTextLen ( dv , offset ) ; return conseq ( _decoder . decode ( newUint8Array ( buf , offset , len ) ) , this . forward ( len + _bpu ) ) ; } , // Read data to an Uint8Array and decode it to text with specified encoding. // @param len length in basic unit, need to multiply byte per unit to get length in bytes // NOTE: After decoding the text, it is need to forward extra "tail" bytes according to specified encoding.  readTextSized : function ( len ) { len *= _bpu ; var read = conseq ( _decoder . decode ( newUint8Array ( buf , offset , len ) ) , this . forward ( len + _tail ) ) ; return read ; } , // Skip checksum, just ignore it anyway. checksum : function ( ) { this . forward ( 4 ) ; } , // Version >= 2.0 only checksum_v2 : function ( ) { return _checksum_v2 ( this ) ; } , // Read data block of keyword index, key block or record content. // These data block are maybe in compressed (gzip or lzo) format, while keyword index maybe be encrypted. // @see https://github.com/zhansliu/writemdict/blob/master/fileformat.md#compression (with typo mistake) readBlock : function ( len , expectedBufSize , decryptor ) { var comp_type = dv . getUint8 ( offset , false ) ; // compression type, 0 = non, 1 = lzo, 2 = gzip if ( comp_type === 0 ) { if ( _v2 ) { this . forward ( 8 ) ; // for version >= 2, skip comp_type (4 bytes with tailing \x00) and checksum (4 bytes) } return this ; } else { // skip comp_type (4 bytes with tailing \x00) and checksum (4 bytes) offset += 8 ; len -= 8 ; var tmp = new Uint8Array ( len ) ; buf . copy ( tmp , 0 , offset , offset + len ) ; if ( decryptor ) { var passkey = new Uint8Array ( 8 ) ; var q = new Buffer ( 4 ) ; buf . copy ( passkey , 0 , offset - 4 , offset ) ; // var q = new Buffer(4); passkey . set ( [ 0x95 , 0x36 , 0x00 , 0x00 ] , 4 ) ; // key part 2: fixed data tmp = decryptor ( tmp , passkey ) ; } tmp = comp_type === 2 ? pako . inflate ( tmp ) : lzo . decompress ( tmp , expectedBufSize , 1308672 ) ; this . forward ( len ) ; var d = new Buffer ( tmp ) ; return Scanner ( d , tmp . length ) ; } } , // Read raw data as Uint8Array from current offset with specified length in bytes readRaw : function ( len ) { return conseq ( newUint8Array ( buf , offset , len ) , this . forward ( len === UNDEFINED ? buf . length - offset : len ) ) ; } , } ; return Object . create ( methods ) ; } /**      * Read the first 4 bytes of mdx/mdd file to get length of header_str.      * @see https://github.com/zhansliu/writemdict/blob/master/fileformat.md#file-structure      * @param input sliced file (start = 0, length = 4)      * @return length of header_str      */ function read_file_head ( input ) { return Scanner ( input ) . readInt ( ) ; } /**      * Read header section, parse dictionary attributes and config scanner according to engine version attribute.      * @see https://github.com/zhansliu/writemdict/blob/master/fileformat.md#header-section      * @param input sliced file (start = 4, length = len + 48), header string + header section (max length 48)      * @param len lenghth of header_str      * @return [remained length of header section (header_str and checksum, = len + 4), original input]      */ function read_header_sect ( input , len ) { var scanner = Scanner ( input ) , header_str = scanner . readUTF16 ( len ) . replace ( / \0$ / , '' ) ; // need to remove tailing NUL // parse dictionary attributes var doc = new DOMParser ( ) . parseFromString ( header_str , 'text/xml' ) ; var elem = doc . getElementsByTagName ( 'Dictionary' ) [ 0 ] ; if ( ! elem ) { elem = doc . getElementsByTagName ( 'Library_Data' ) [ 0 ] ; } // console.log(doc.getElementsByTagName('Dictionary')[0].attributes); // var xml = parseXml(header_str).querySelector('Dictionary, Library_Data').attributes; for ( var i = 0 , item ; i < elem . attributes . length ; i ++ ) { item = elem . attributes [ i ] ; attrs [ item . nodeName ] = item . nodeValue ; } attrs . Encrypted = parseInt ( attrs . Encrypted , 10 ) || 0 ; config ( ) ; return spreadus ( len + 4 , input ) ; } /**      * Read keyword summary at the begining of keyword section.      * @see https://github.com/zhansliu/writemdict/blob/master/fileformat.md#keyword-section      * @param input sliced file, same as input passed to read_header_sect()      * @param offset start position of keyword section in sliced file, equals to length of header string plus checksum.\      * @return keyword_sect object      */ function read_keyword_summary ( input , offset ) { var scanner = Scanner ( input ) ; scanner . forward ( offset ) ; return { num_blocks : scanner . readNum ( ) , num_entries : scanner . readNum ( ) , key_index_decomp_len : _v2 && scanner . readNum ( ) , // Ver >= 2.0 only key_index_comp_len : scanner . readNum ( ) , key_blocks_len : scanner . readNum ( ) , chksum : scanner . checksum_v2 ( ) , // extra field len : scanner . offset ( ) - offset , // actual length of keyword section, varying with engine version attribute } ; } /**      * Read keyword index part of keyword section.       * @see https://github.com/zhansliu/writemdict/blob/master/fileformat.md#keyword-header-encryption      * @see https://github.com/zhansliu/writemdict/blob/master/fileformat.md#keyword-index      * @param input sliced file, remained part of keyword section after keyword summary which can also be used to read following key blocks.      * @param keyword_summary       * @return [keyword_summary, array of keyword index]      */ function read_keyword_index ( input , keyword_summary ) { var scanner = Scanner ( input ) . readBlock ( keyword_summary . key_index_comp_len , keyword_summary . key_index_decomp_len , _decryptors [ 1 ] ) , keyword_index = Array ( keyword_summary . num_blocks ) , offset = 0 ; for ( var i = 0 , size ; i < keyword_summary . num_blocks ; i ++ ) { keyword_index [ i ] = { num_entries : conseq ( scanner . readNum ( ) , size = scanner . readShort ( ) ) , // UNUSED, can be ignored         //          first_size:  size = scanner.readShort(), first_word : conseq ( scanner . readTextSized ( size ) , size = scanner . readShort ( ) ) , // UNUSED, can be ignored //          last_size:   size = scanner.readShort(), last_word : scanner . readTextSized ( size ) , comp_size : size = scanner . readNum ( ) , decomp_size : scanner . readNum ( ) , // extra fields offset : offset , // offset of the first byte for the target key block in mdx/mdd file index : i // index of this key index, used to search previous/next block } ; offset += size ; } return spreadus ( keyword_summary , keyword_index ) ; } /**      * Read keyword entries inside a keyword block and fill KEY_TABLE.      * @param scanner scanner object to read key entries, which starts at begining of target key block      * @param kdx corresponding keyword index object      * NOTE: no need to read keyword block anymore, for debug only.      */ function read_key_block ( scanner , kdx ) { var scanner = scanner . readBlock ( kdx . comp_size , kdx . decomp_size ) ; for ( var i = 0 ; i < kdx . num_entries ; i ++ ) { //        scanner.readNum(); scanner.readText(); var kk = [ scanner . readNum ( ) , scanner . readText ( ) ] ; } } /**      * Delay to scan key table, for debug onyl.      * @param slicedKeyBlock a promise object which will resolve to an ArrayBuffer containing keyword blocks       *                       sliced from mdx/mdd file.      * @param num_entries number of keyword entries      * @param keyword_index array of keyword index      * @param delay time to delay for scanning key table      */ function willScanKeyTable ( slicedKeyBlock , num_entries , keyword_index , delay ) { slicedKeyBlock . delay ( delay ) . then ( function ( input ) { var scanner = Scanner ( input ) ; for ( var i = 0 , size = keyword_index . length ; i < size ; i ++ ) { // common.log('z',keyword_index[i]); read_key_block ( scanner , keyword_index [ i ] ) ; } } ) ; } /**      * Read record summary at the begining of record section.      * @see https://github.com/zhansliu/writemdict/blob/master/fileformat.md#record-section      * @param input sliced file, start = begining of record section, length = 32 (max length of record summary)      * @param pos begining of record section      * @returj record summary object      */ function read_record_summary ( input , pos ) { var scanner = Scanner ( input ) , record_summary = { num_blocks : scanner . readNum ( ) , num_entries : scanner . readNum ( ) , index_len : scanner . readNum ( ) , blocks_len : scanner . readNum ( ) , // extra field len : scanner . offset ( ) , // actual length of record section (excluding record block index), varying with engine version attribute } ; // start position of record block from head of mdx/mdd file record_summary . block_pos = pos + record_summary . index_len + record_summary . len ; return record_summary ; } /**      * Read record block index part in record section, and fill RECORD_BLOCK_TABLE      * @see https://github.com/zhansliu/writemdict/blob/master/fileformat.md#record-section      * @param input sliced file, start = begining of record block index, length = record_summary.index_len      * @param record_summary record summary object      */ function read_record_block ( input , record_summary ) { var scanner = Scanner ( input ) , size = record_summary . num_blocks , record_index = Array ( size ) , p0 = record_summary . block_pos , p1 = 0 ; RECORD_BLOCK_TABLE . alloc ( size + 1 ) ; for ( var i = 0 , rdx ; i < size ; i ++ ) { record_index [ i ] = rdx = { comp_size : scanner . readNum ( ) , decomp_size : scanner . readNum ( ) } ; RECORD_BLOCK_TABLE . put ( p0 , p1 ) ; p0 += rdx . comp_size ; p1 += rdx . decomp_size ; } RECORD_BLOCK_TABLE . put ( p0 , p1 ) ; } /**      * Read definition in text for given keyinfo object.      * @param input record block sliced from the file      * @param block record block index       * @param keyinfo a object with property of record's offset and optional size for the given keyword      * @return definition in text      */ function read_definition ( input , block , keyinfo ) { var scanner = Scanner ( input ) . readBlock ( block . comp_size , block . decomp_size ) ; scanner . forward ( keyinfo . offset - block . decomp_offset ) ; return scanner . readText ( ) ; } /**      * Following link to find actual definition of keyword.      * @param definition maybe starts with "@@@LINK=" which links to another keyword       * @param lookup search function      * @return resolved actual definition      */ function followLink ( definition , lookup ) { return ( definition . substring ( 0 , 8 ) !== '@@@LINK=' ) ? definition : lookup ( definition . substring ( 8 ) ) ; } /**      * Read content in ArrayBuffer for give keyinfo object      * @param input record block sliced from the file      * @param block record block index       * @param keyinfo a object with property of record's offset and optional size for the given keyword      * @return an ArrayBuffer containing resource of image/audio/css/font etc.      */ function read_object ( input , block , keyinfo ) { if ( input . byteLength > 0 ) { var scanner = Scanner ( input ) . readBlock ( block . comp_size , block . decomp_size ) ; scanner . forward ( keyinfo . offset - block . decomp_offset ) ; return scanner . readRaw ( keyinfo . size ) ; } else { throw '* OUT OF FILE RANGE * ' + keyinfo + ' @offset=' + block . comp_offset ; } } /**      * Find word definition for given keyinfo object.      * @param keyinfo a object with property of record's offset and optional size for the given keyword      * @return a promise object which will resolve to definition in text. Link to other keyword is followed to get actual definition.      */ function findWord ( keyinfo ) { var block = RECORD_BLOCK_TABLE . find ( keyinfo . offset ) ; return _slice ( block . comp_offset , block . comp_size ) . exec ( read_definition , block , keyinfo ) . spread ( function ( definition ) { return resolve ( followLink ( definition , LOOKUP . mdx ) ) ; } ) ; } /**      * Find resource (image, sound etc.) for given keyinfo object.      * @param keyinfo a object with property of record's offset and optional size for the given keyword      * @return a promise object which will resolve to an ArrayBuffer containing resource of image/audio/css/font etc.      * TODO: Follow link, maybe it's too expensive and a rarely used feature?      */ function findResource ( keyinfo ) { var block = RECORD_BLOCK_TABLE . find ( keyinfo . offset ) ; return _slice ( block . comp_offset , block . comp_size ) . exec ( read_object , block , keyinfo ) . spread ( function ( blob ) { return resolve ( blob ) ; } ) ; } //------------------------------------------------------------------------------------------------ // Implementation for look-up //------------------------------------------------------------------------------------------------ var slicedKeyBlock , _cached_keys , // cache latest keys  _trail , // store latest visited record block & position when search for candidate keys mutual_ticket = 0 ; // a oneway increased ticket used to cancel unfinished pattern match /**       * Reduce the key index array to an element which contains or is the nearest one matching a given phrase.       */ function reduce ( arr , phrase ) { var len = arr . length ; if ( len > 1 ) { len = len >> 1 ; return phrase > _adaptKey ( arr [ len - 1 ] . last_word ) ? reduce ( arr . slice ( len ) , phrase ) : reduce ( arr . slice ( 0 , len ) , phrase ) ; } else { return arr [ 0 ] ; } } /**       * Reduce the array to index of an element which contains or is the nearest one matching a given phrase.       */ function shrink ( arr , phrase ) { var len = arr . length , sub ; if ( len > 1 ) { len = len >> 1 ; var key = _adaptKey ( arr [ len ] ) ; if ( phrase < key ) { sub = arr . slice ( 0 , len ) ; sub . pos = arr . pos ; } else { sub = arr . slice ( len ) ; sub . pos = ( arr . pos || 0 ) + len ; } return shrink ( sub , phrase ) ; } else { return ( arr . pos || 0 ) + ( phrase <= _adaptKey ( arr [ 0 ] ) ? 0 : 1 ) ; } } /**      * Load keys for a keyword index object from mdx/mdd file.      * @param kdx keyword index object      */ function loadKeys ( kdx ) { if ( _cached_keys && _cached_keys . pilot === kdx . first_word ) { return resolve ( _cached_keys . list ) ; } else { return slicedKeyBlock . then ( function ( input ) { var scanner = Scanner ( input ) , list = Array ( kdx . num_entries ) ; scanner . forward ( kdx . offset ) ; scanner = scanner . readBlock ( kdx . comp_size , kdx . decomp_size ) ; for ( var i = 0 ; i < kdx . num_entries ; i ++ ) { var offset = scanner . readNum ( ) ; list [ i ] = new Object ( scanner . readText ( ) ) ; list [ i ] . offset = offset ; if ( i > 0 ) { list [ i - 1 ] . size = offset - list [ i - 1 ] . offset ; } } _cached_keys = { list : list , pilot : kdx . first_word } ; return list ; } ) ; } } /**      * Search for the first keyword match given phrase.      */ function seekVanguard ( phrase ) { phrase = _adaptKey ( phrase ) ; var kdx = reduce ( KEY_INDEX , phrase ) ; // look back for the first record block containing keyword for the specified phrase if ( phrase <= _adaptKey ( kdx . last_word ) ) { var index = kdx . index - 1 , prev ; while ( prev = KEY_INDEX [ index ] ) { if ( _adaptKey ( prev . last_word ) !== _adaptKey ( kdx . last_word ) ) { break ; } kdx = prev ; index -- ; } } return loadKeys ( kdx ) . then ( function ( list ) { var idx = shrink ( list , phrase ) ; // look back for the first matched keyword position while ( idx > 0 ) { if ( _adaptKey ( list [ -- idx ] ) !== _adaptKey ( phrase ) ) { idx ++ ; break ; } } return [ kdx , Math . min ( idx , list . length - 1 ) , list ] ; } ) ; } // TODO: have to restrict max count to improve response /**      * Append more to word list according to a filter or expected size.      */ function appendMore ( word , list , nextKdx , expectedSize , filter , ticket ) { if ( ticket !== mutual_ticket ) { throw 'force terminated' ; } if ( filter ) { if ( _trail . count < expectedSize && nextKdx && nextKdx . first_word . substr ( 0 , word . length ) === word ) { return loadKeys ( nextKdx ) . delay ( 30 ) . then ( function ( more ) { _trail . offset = 0 ; _trail . block = nextKdx . index ; Array . prototype . push . apply ( list , more . filter ( filter , _trail ) ) ; return appendMore ( word , list , KEY_INDEX [ nextKdx . index + 1 ] , expectedSize , filter , ticket ) ; } ) ; } else { if ( list . length === 0 ) { _trail . exhausted = true ; } return resolve ( list ) ; } } else { var shortage = expectedSize - list . length ; if ( shortage > 0 && nextKdx ) { _trail . block = nextKdx . index ; return loadKeys ( nextKdx ) . then ( function ( more ) { _trail . offset = 0 ; _trail . pos = Math . min ( shortage , more . length ) ; Array . prototype . push . apply ( list , more . slice ( 0 , shortage ) ) ; return appendMore ( word , list , KEY_INDEX [ nextKdx . index + 1 ] , expectedSize , filter , ticket ) ; } ) ; } else { if ( _trail . pos > expectedSize ) { _trail . pos = expectedSize ; } list = list . slice ( 0 , expectedSize ) ; _trail . count = list . length ; _trail . total += _trail . count ; return resolve ( list ) ; } } } function followUp ( ) { var kdx = KEY_INDEX [ _trail . block ] ; return loadKeys ( kdx ) . then ( function ( list ) { return [ kdx , Math . min ( _trail . offset + _trail . pos , list . length - 1 ) , list ] ; } ) ; } function matchKeys ( phrase , expectedSize , follow ) { expectedSize = Math . max ( expectedSize || 0 , 10 ) ; var str = phrase . trim ( ) . toLowerCase ( ) , m = / ([^?*]+)[?*]+ / . exec ( str ) , word ; if ( m ) { word = m [ 1 ] ; var wildcard = new RegExp ( '^' + str . replace ( / ([\.\\\+\[\^\]\$\(\)]) / g , '\\$1' ) . replace ( / \*+ / g , '.*' ) . replace ( / \? / g , '.' ) + '$' ) , tester = phrase [ phrase . length - 1 ] === ' ' ? function ( s ) { return wildcard . test ( s ) ; } : function ( s ) { return wildcard . test ( s ) && ! /   / . test ( s ) ; } , filter = function ( s , i ) { if ( _trail . count < expectedSize && tester ( s ) ) { _trail . count ++ ; _trail . total ++ ; _trail . pos = i + 1 ; return true ; } return false ; } ; } else { word = phrase . trim ( ) ; } if ( _trail && _trail . phrase !== phrase ) { follow = false ; } if ( follow && _trail && _trail . exhausted ) { return resolve ( [ ] ) ; } var startFrom = follow && _trail ? followUp ( ) : seekVanguard ( word ) ; return startFrom . spread ( function ( kdx , idx , list ) { list = list . slice ( idx ) ; _trail = { phrase : phrase , block : kdx . index , offset : idx , pos : list . length , count : 0 , total : follow ? _trail && _trail . total || 0 : 0 } ; if ( filter ) { list = list . filter ( filter , _trail ) ; } return appendMore ( word , list , KEY_INDEX [ kdx . index + 1 ] , expectedSize , filter , ++ mutual_ticket ) . then ( function ( result ) { if ( _trail . block === KEY_INDEX . length - 1 ) { if ( _trail . offset + _trail . pos >= KEY_INDEX [ _trail . block ] . num_entries ) { _trail . exhausted = true ; // console.log('EXHAUSTED!!!!'); } } // console.log('trail: ', _trail);           return result ; } ) ; } ) ; } ; /**      * Match the first element in list with given offset.      */ function matchOffset ( list , offset ) { return list . some ( function ( el ) { return el . offset === offset ? list = [ el ] : false ; } ) ? list : [ ] ; } // Lookup functions var LOOKUP = { /**        * @param query         *          String        *          {phrase: .., max: .., follow: true} object        */ mdx : function ( query ) { if ( typeof query === 'string' || query instanceof String ) { _trail = null ; var word = query . trim ( ) . toLowerCase ( ) , offset = query . offset ; return seekVanguard ( word ) . spread ( function ( kdx , idx , list ) { list = list . slice ( idx ) ; if ( offset !== UNDEFINED ) { list = matchOffset ( list , offset ) ; } else { list = list . filter ( function ( el ) { return el . toLowerCase ( ) === word ; } ) ; } return harvest ( list . map ( findWord ) ) ; } ) ; } else { return matchKeys ( query . phrase , query . max , query . follow ) ; } } , // TODO: chain multiple mdd file mdd : function ( phrase ) { var word = phrase . trim ( ) . toLowerCase ( ) ; word = '\\' + word . replace ( / (^[/\\])|([/]$) / , '' ) ; word = word . replace ( / \/ / g , '\\' ) ; return seekVanguard ( word ) . spread ( function ( kdx , idx , list ) { return list . slice ( idx ) . filter ( function ( one ) { return one . toLowerCase ( ) === word ; } ) ; } ) . then ( function ( candidates ) { if ( candidates . length === 0 ) { throw '*RESOURCE NOT FOUND* ' + phrase ; } else { return findResource ( candidates [ 0 ] ) ; } } ) ; } } ; // ------------------------------------------ // start to load mdx/mdd file // ------------------------------------------ var pos = 0 ; // read first 4 bytes to get header length return _slice ( pos , 4 ) . exec ( read_file_head ) . then ( function ( len ) { len = parseInt ( len , 10 ) ; pos += 4 ; // start of header string in header section return _slice ( pos , len + 48 ) . exec ( read_header_sect , len ) ; } ) . then ( function ( ret ) { var header_remain_len = ret [ 0 ] ; var input = ret [ 1 ] ; pos += header_remain_len ; // start of keyword section return read_keyword_summary ( input , header_remain_len ) ; } ) . then ( function ( keyword_summary ) { pos += keyword_summary . len ; // start of key index in keyword section return _slice ( pos , keyword_summary . key_index_comp_len ) . exec ( read_keyword_index , keyword_summary ) ; } ) . then ( function ( data ) { var keyword_summary = data [ 0 ] ; var keyword_index = data [ 1 ] ; // console.log(data[1]); // console.log(data); pos += keyword_summary . key_index_comp_len ; // start of keyword block in keyword section slicedKeyBlock = _slice ( pos , keyword_summary . key_blocks_len ) ; // Now it's fast enough to look up word without key table, which scans keyword from the specified key blocks in an effcient way. // No need to scan the whole key table in ahead. // willScanKeyTable(slicedKeyBlock, keyword_summary.num_entries, keyword_index, 00); dasd; //  pos += keyword_summary . key_blocks_len ; // start of record section KEY_INDEX = keyword_index ; } ) . then ( function ( ) { return _slice ( pos , 32 ) . exec ( read_record_summary , pos ) ; } ) . spread ( function ( record_summary ) { pos += record_summary . len ; // start of record blocks in record section return _slice ( pos , record_summary . index_len ) . exec ( read_record_block , record_summary ) ; } ) . spread ( function ( ) { // resolve and return lookup() function according to file extension (mdx/mdd) LOOKUP [ ext ] . description = attrs . Description ; return resolve ( LOOKUP [ ext ] ) ; } ) ; }<CODESPLIT>0.17085005342960358<CODESPLIT>0.15076559782028198

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/GitbookIO/theme-default/blob/a8e920453dc8e4eb522840b61606486622848099/src/js/theme/navigation.js#L123-L165<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function setChapterActive ( $chapter , hash ) { // No chapter and no hash means first chapter if ( ! $chapter && ! hash ) { $chapter = $chapters . first ( ) ; } // If hash is provided, set as active chapter if ( ! ! hash ) { // Multiple chapters for this file if ( $chapters . length > 1 ) { $chapter = $chapters . filter ( function ( ) { var titleId = getChapterHash ( $ ( this ) ) ; return titleId == hash ; } ) . first ( ) ; } // Only one chapter, no need to search else { $chapter = $chapters . first ( ) ; } } // Don't update current chapter if ( $chapter . is ( $activeChapter ) ) { return ; } // Update current active chapter $activeChapter = $chapter ; // Add class to selected chapter $chapters . removeClass ( 'active' ) ; $chapter . addClass ( 'active' ) ; // Update history state if needed hash = getChapterHash ( $chapter ) ; var oldUri = window . location . pathname + window . location . hash , uri = window . location . pathname + hash ; if ( uri != oldUri ) { history . replaceState ( { path : uri } , null , uri ) ; } }<CODESPLIT>0.14788983762264252<CODESPLIT>0.13154980540275574

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/sendanor/nor-api/blob/50c88c6a606443e89f978a75057902a65d8312bd/src/index.js#L65-L75<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function do_create_server ( config , do_req ) { var http = require ( 'http' ) ; if ( config . host ) { http . createServer ( do_req ) . listen ( config . port , config . host ) ; //console.log("Server running at http://"+config.host+":"+config.port+"/"); } else { http . createServer ( do_req ) . listen ( config . port ) ; //console.log("Server running at http://0.0.0.0:"+config.port); } return http ; }<CODESPLIT>0.16295813024044037<CODESPLIT>0.1368238776922226

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/jurca/indexed-db.es6/blob/abc22dc63b2159c253b60c5dc396d22fd72c2177/es2015/migration/ObjectStoreMigrator.js#L91-L113<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function shouldDeleteIndex ( objectStore , schema , indexName ) { let schemaIndexes = schema . indexes || [ ] let newIndexNames = schemaIndexes . map ( indexSchema => indexSchema . name ) if ( newIndexNames . indexOf ( indexName ) === - 1 ) { return true } let index = objectStore . index ( indexName ) let indexKeyPath = index . keyPath ; if ( indexKeyPath && ( typeof indexKeyPath !== "string" ) ) { indexKeyPath = Array . from ( indexKeyPath ) } let serializedIndexKeyPath = JSON . stringify ( indexKeyPath ) let indexSchema = schemaIndexes . filter ( ( indexSchema ) => { return indexSchema . name === index . name } ) [ 0 ] return ( index . unique !== indexSchema . unique ) || ( index . multiEntry !== indexSchema . multiEntry ) || ( serializedIndexKeyPath !== JSON . stringify ( indexSchema . keyPaths ) ) }<CODESPLIT>0.1823493242263794<CODESPLIT>0.14102987945079803

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/jurca/indexed-db.es6/blob/abc22dc63b2159c253b60c5dc396d22fd72c2177/es2015/object-store/query-engine.js#L380-L388<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function prepareSortingOptimization ( storages , simplifiedOrderFieldPaths ) { let idb = idbProvider ( ) for ( let [ keyPath , storageAndScore ] of storages ) { let keyPathSlice = keyPath . slice ( 0 , simplifiedOrderFieldPaths . length ) if ( idb . cmp ( keyPathSlice , simplifiedOrderFieldPaths ) === 0 ) { storageAndScore . score += 4 // optimizing the sorting is more important } } }<CODESPLIT>0.16521461308002472<CODESPLIT>0.14416971802711487

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/mcasimir/mobile-angular-ui/blob/5ec10ac8883e31beb91a940f133290a5146a126d/dist/js/mobile-angular-ui.js#L2792-L2880<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( e ) { // Stop any throw in progress if ( o . intercept ) { o . intercept ( ) ; } // Reset the distance and direction tracking resetVertTracking ( ) ; resetHorTracking ( ) ; elem = o . closest ( e . target ) ; if ( ! elem || elem === docElem || e . touches . length > 1 ) { return ; } setPointers ( "none" ) ; var touchStartE = e , scrollT = elem . scrollTop , scrollL = elem . scrollLeft , height = elem . offsetHeight , width = elem . offsetWidth , startY = e . touches [ 0 ] . pageY , startX = e . touches [ 0 ] . pageX , scrollHeight = elem . scrollHeight , scrollWidth = elem . scrollWidth , // Touchmove handler move = function ( e ) { var ty = scrollT + startY - e . touches [ 0 ] . pageY , tx = scrollL + startX - e . touches [ 0 ] . pageX , down = ty >= ( lastTops . length ? lastTops [ 0 ] : 0 ) , right = tx >= ( lastLefts . length ? lastLefts [ 0 ] : 0 ) ; // If there's room to scroll the current container, prevent the default window scroll if ( ( ty > 0 && ty < scrollHeight - height ) || ( tx > 0 && tx < scrollWidth - width ) ) { e . preventDefault ( ) ; } // This bubbling is dumb. Needs a rethink. else { changeScrollTarget ( touchStartE ) ; } // If down and lastDown are inequal, the y scroll has changed direction. Reset tracking. if ( lastDown && down !== lastDown ) { resetVertTracking ( ) ; } // If right and lastRight are inequal, the x scroll has changed direction. Reset tracking. if ( lastRight && right !== lastRight ) { resetHorTracking ( ) ; } // remember the last direction in which we were headed lastDown = down ; lastRight = right ; // set the container's scroll elem . scrollTop = ty ; elem . scrollLeft = tx ; lastTops . unshift ( ty ) ; lastLefts . unshift ( tx ) ; if ( lastTops . length > 3 ) { lastTops . pop ( ) ; } if ( lastLefts . length > 3 ) { lastLefts . pop ( ) ; } } , // Touchend handler end = function ( e ) { // Bring the pointers back setPointers ( "auto" ) ; setTimeout ( function ( ) { setPointers ( "none" ) ; } , 450 ) ; elem . removeEventListener ( "touchmove" , move , false ) ; elem . removeEventListener ( "touchend" , end , false ) ; } ; elem . addEventListener ( "touchmove" , move , false ) ; elem . addEventListener ( "touchend" , end , false ) ; }<CODESPLIT>0.17564354836940765<CODESPLIT>0.16797977685928345

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L3363-L3371<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( key , value ) { var keys = this . keys , values = this . values , guid = guidFor ( key ) ; keys . add ( key ) ; values [ guid ] = value ; set ( this , 'length' , keys . list . length ) ; }<CODESPLIT>0.1580016314983368<CODESPLIT>0.150505930185318

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/mesqueeb/vuex-easy-firestore/blob/08695ae1abd5c5bbfb6c3cfb618f17e7249f5667/dist/index.esm.js#L1115-L1128<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function storeUpdateFn ( _doc ) { switch ( change ) { case 'added' : commit ( 'INSERT_DOC' , _doc ) ; break ; case 'removed' : commit ( 'DELETE_DOC' , id ) ; break ; default : dispatch ( 'deleteMissingProps' , _doc ) ; commit ( 'PATCH_DOC' , _doc ) ; break ; } }<CODESPLIT>0.10391061753034592<CODESPLIT>0.1529046893119812

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/cedx/coveralls.js/blob/42ee63e3e6f6ffc695809f0c722cef7792edf0c5/lib/parsers/clover.js#L21-L23<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function findElements ( node , name ) { return name in node && Array . isArray ( node [ name ] ) ? node [ name ] : [ ] ; }<CODESPLIT>0.1543300896883011<CODESPLIT>0.16854602098464966

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L14142-L14146<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( ) { var path = this . decodeFragment ( this . location . pathname ) ; var root = path . slice ( 0 , this . root . length - 1 ) + '/' ; return root === this . root ; }<CODESPLIT>0.17782467603683472<CODESPLIT>0.13128967583179474

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/moxiecode/moxie/blob/09eaf578f38480dc4b8e2017c473c496883b6168/build/mkjs.js#L122-L129<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( from , to , text , all ) { var pos = text . indexOf ( from ) ; if ( pos == - 1 ) { return text ; } text = text . substring ( 0 , pos ) + to + text . substring ( pos + from . length ) ; return ! all ? text : replace . call ( null , from , to , text , all ) ; }<CODESPLIT>0.16294172406196594<CODESPLIT>0.1328934282064438

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/socialally/browser-cookie/blob/c64f8abf894bd0d66248d2a6310013783c86dddf/lib/cookie.js#L91-L100<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function del ( key , options ) { if ( ! options ) { options = { } ; for ( var z in this . options ) { options [ z ] = this . options [ z ] ; } } options . expires = - 1 ; this . set ( key , '' , options ) ; }<CODESPLIT>0.17173263430595398<CODESPLIT>0.15431907773017883

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L5319-L5321<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function unescapeIdentifier ( identifier ) { return identifier . length >= 3 && identifier . charCodeAt ( 0 ) === 95 /* _ */ && identifier . charCodeAt ( 1 ) === 95 /* _ */ && identifier . charCodeAt ( 2 ) === 95 /* _ */ ? identifier . substr ( 1 ) : identifier ; }<CODESPLIT>0.12553979456424713<CODESPLIT>0.13703392446041107

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L3555-L3563<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function utf16EncodeAsString ( codePoint ) { ts . Debug . assert ( 0x0 <= codePoint && codePoint <= 0x10FFFF ) ; if ( codePoint <= 65535 ) { return String . fromCharCode ( codePoint ) ; } var codeUnit1 = Math . floor ( ( codePoint - 65536 ) / 1024 ) + 0xD800 ; var codeUnit2 = ( ( codePoint - 65536 ) % 1024 ) + 0xDC00 ; return String . fromCharCode ( codeUnit1 , codeUnit2 ) ; }<CODESPLIT>0.13328033685684204<CODESPLIT>0.17665626108646393

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/dryjs/dry-underscore/blob/32dff1d8abf575b3576406049dd02f0f7d946187/deps/moment-duration-format.js#L156-L167<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function rest ( array , callback ) { var ret = [ ] ; each ( array , function ( item , index ) { if ( ! callback ( item ) ) { ret = array . slice ( index ) ; return false ; } } ) ; return ret ; }<CODESPLIT>0.12247224897146225<CODESPLIT>0.13611267507076263

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/flowjs/flow.js/blob/aadc5a72b1414d87ed1aa3563b30209f9b1f7773/dist/flow.js#L209-L224<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( event , args ) { // `arguments` is an object, not array, in FF, so: args = Array . prototype . slice . call ( arguments ) ; event = event . toLowerCase ( ) ; var preventDefault = false ; if ( this . events . hasOwnProperty ( event ) ) { each ( this . events [ event ] , function ( callback ) { preventDefault = callback . apply ( this , args . slice ( 1 ) ) === false || preventDefault ; } , this ) ; } if ( event != 'catchall' ) { args . unshift ( 'catchAll' ) ; preventDefault = this . fire . apply ( this , args ) === false || preventDefault ; } return ! preventDefault ; }<CODESPLIT>0.16467899084091187<CODESPLIT>0.14389081299304962

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/direct/RemotingProvider.js#L321-L323<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( options ) { return options && options . getTid ? Ext . direct . Manager . getTransaction ( options . getTid ( ) ) : null ; }<CODESPLIT>0.12664228677749634<CODESPLIT>0.14579829573631287

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/zeit/next.js/blob/3641f79a0f68d1093cc238b50b8d47eec1c25cfd/packages/next/client/amp-dev.js#L34-L59<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>async function tryApplyUpdates ( ) { if ( ! isUpdateAvailable ( ) || ! canApplyUpdates ( ) ) { return } try { const res = await fetch ( ` ${ hotUpdatePath } ${ curHash } ` ) const data = await res . json ( ) const curPage = page === '/' ? 'index' : page const pageUpdated = Object . keys ( data . c ) . some ( mod => { return ( mod . indexOf ( ` ${ curPage . substr ( 0 , 1 ) === '/' ? curPage : ` ${ curPage } ` } ` ) !== - 1 || mod . indexOf ( ` ${ curPage . substr ( 0 , 1 ) === '/' ? curPage : ` ${ curPage } ` } ` . replace ( / \/ / g , '\\' ) ) !== - 1 ) } ) if ( pageUpdated ) { document . location . reload ( true ) } else { curHash = mostRecentHash } } catch ( err ) { console . error ( 'Error occurred checking for update' , err ) document . location . reload ( true ) } }<CODESPLIT>0.1368752121925354<CODESPLIT>0.10997848957777023

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/wjbryant/taboverride/blob/02238ec1ab098cb998dcb3c1c38d39316e2ac03d/build/output/taboverride.js#L469-L484<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function overrideKeyPress ( e ) { e = e || event ; var key = e . keyCode ; if ( tabKeyComboPressed ( key , e ) || untabKeyComboPressed ( key , e ) || ( key === 13 && autoIndent && ! inWhitespace ) ) { if ( e . preventDefault ) { e . preventDefault ( ) ; } else { e . returnValue = false ; return false ; } } }<CODESPLIT>0.18126527965068817<CODESPLIT>0.13273489475250244

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/react-dnd/react-dnd/blob/5fefffc8c6c1ceced3aa0356fd869354ad74734a/packages/documentation/gatsby-node.js#L6-L44<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>async function createPages ( { actions , graphql } ) { const retrieveMarkdownPages = ( ) => graphql ( ` ` ) const exampleTemplate = path . resolve ( ` ` ) const docTemplate = path . resolve ( ` ` ) const result = await retrieveMarkdownPages ( ) if ( result . errors ) { console . error ( 'graphql error' , result . errors ) throw new Error ( 'Error invoking graphql for pages' ) } result . data . allMarkdownRemark . edges . forEach ( ( { node } ) => { const { frontmatter : { path : pagePath } , } = node const category = ( pagePath || '/' ) . split ( '/' ) . filter ( t => ! ! t ) [ 0 ] const isExample = category === 'examples' console . log ( ` ${ pagePath } ${ category } ` ) actions . createPage ( { path : pagePath , component : isExample ? exampleTemplate : docTemplate , context : { } , // additional data can be passed via context } ) } ) }<CODESPLIT>0.15222425758838654<CODESPLIT>0.12466376274824142

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/mpetroff/pannellum/blob/59893bcea4629be059ad3e59c3fa5bde438d292b/src/js/libpannellum.js#L1122-L1130<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function processLoadedTexture ( img , tex ) { gl . bindTexture ( gl . TEXTURE_2D , tex ) ; gl . texImage2D ( gl . TEXTURE_2D , 0 , gl . RGB , gl . RGB , gl . UNSIGNED_BYTE , img ) ; gl . texParameteri ( gl . TEXTURE_2D , gl . TEXTURE_MAG_FILTER , gl . LINEAR ) ; gl . texParameteri ( gl . TEXTURE_2D , gl . TEXTURE_MIN_FILTER , gl . LINEAR ) ; gl . texParameteri ( gl . TEXTURE_2D , gl . TEXTURE_WRAP_S , gl . CLAMP_TO_EDGE ) ; gl . texParameteri ( gl . TEXTURE_2D , gl . TEXTURE_WRAP_T , gl . CLAMP_TO_EDGE ) ; gl . bindTexture ( gl . TEXTURE_2D , null ) ; }<CODESPLIT>0.13669344782829285<CODESPLIT>0.1435994952917099

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L43967-L43984<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function wrap ( inner , prefix , esc ) { if ( esc ) inner = escape ( inner ) ; switch ( prefix ) { case '!' : return '(?!' + inner + ')[^/]' + ( esc ? '%%%~' : '*?' ) ; case '@' : return '(?:' + inner + ')' ; case '+' : return '(?:' + inner + ')+' ; case '*' : return '(?:' + inner + ')' + ( esc ? '%%' : '*' ) case '?' : return '(?:' + inner + '|)' ; default : return inner ; } }<CODESPLIT>0.1481585055589676<CODESPLIT>0.1474509984254837

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/mpetroff/pannellum/blob/59893bcea4629be059ad3e59c3fa5bde438d292b/src/js/pannellum.js#L1551-L1559<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function computeQuaternion ( alpha , beta , gamma ) { // Convert Tait-Bryan angles to quaternion var quaternion = taitBryanToQuaternion ( alpha , beta , gamma ) ; // Apply world transform quaternion = quaternion . multiply ( new Quaternion ( Math . sqrt ( 0.5 ) , - Math . sqrt ( 0.5 ) , 0 , 0 ) ) ; // Apply screen transform var angle = window . orientation ? - window . orientation * Math . PI / 180 / 2 : 0 ; return quaternion . multiply ( new Quaternion ( Math . cos ( angle ) , 0 , - Math . sin ( angle ) , 0 ) ) ; }<CODESPLIT>0.17610958218574524<CODESPLIT>0.13076624274253845

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/core/lang/Number.js#L46-L63<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( value , increment , minValue , maxValue ) { var newValue = value , m ; if ( ! ( increment && value ) ) { return value ; } m = value % increment ; if ( m !== 0 ) { newValue -= m ; if ( m * 2 >= increment ) { newValue += increment ; } else if ( m * 2 < - increment ) { newValue -= increment ; } } return Ext . Number . constrain ( newValue , minValue , maxValue ) ; }<CODESPLIT>0.15029208362102509<CODESPLIT>0.13456930220127106

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/genify/toolkit2/blob/bb40480731f363327e055f7120d3fd6de6336cda/lib/script/nej/util.js#L359-L366<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( uri , deps , func ) { var args = exports . formatARG . apply ( exports , arguments ) ; this . isNEJ = ! 0 ; this . dependency = args [ 1 ] ; this . source = ( args [ 2 ] || '' ) . toString ( ) ; }<CODESPLIT>0.12712614238262177<CODESPLIT>0.16859370470046997

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/pandao/editor.md/blob/0e76f96d476397c5a9e64388a36e2ed74183d11e/editormd.amd.js#L1564-L1579<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( ) { if ( timer === null ) { return this ; } this . previewContainer . find ( "." + editormd . classNames . tex ) . each ( function ( ) { var tex = $ ( this ) ; editormd . $katex . render ( tex . text ( ) , tex [ 0 ] ) ; tex . find ( ".katex" ) . css ( "font-size" , "1.6em" ) ; } ) ; return this ; }<CODESPLIT>0.12958364188671112<CODESPLIT>0.13182257115840912

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/saymedia/angularjs-server/blob/db61e9cfd9d6634ebf66c8320b823ebf7eab1a6b/examples/weather/angular.js#L9763-L9799<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( watchExp , listener , objectEquality ) { var scope = this , get = compileToFn ( watchExp , 'watch' ) , array = scope . $$watchers , watcher = { fn : listener , last : initWatchVal , get : get , exp : watchExp , eq : ! ! objectEquality } ; // in the case user pass string, we need to compile it, do we really need this ? if ( ! isFunction ( listener ) ) { var listenFn = compileToFn ( listener || noop , 'listener' ) ; watcher . fn = function ( newVal , oldVal , scope ) { listenFn ( scope ) ; } ; } if ( typeof watchExp == 'string' && get . constant ) { var originalFn = watcher . fn ; watcher . fn = function ( newVal , oldVal , scope ) { originalFn . call ( this , newVal , oldVal , scope ) ; arrayRemove ( array , watcher ) ; } ; } if ( ! array ) { array = scope . $$watchers = [ ] ; } // we use unshift since we use a while loop in $digest for speed. // the while loop reads in reverse order. array . unshift ( watcher ) ; return function ( ) { arrayRemove ( array , watcher ) ; } ; }<CODESPLIT>0.1598486304283142<CODESPLIT>0.1385164111852646

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/bpostlethwaite/colormap/blob/cb22a04d23b9fd47a6663d80d44ad77594bd394a/res/draw.js#L155-L163<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function createCubehelix ( steps , opts ) { var data = [ ] ; for ( var i = 0 ; i < steps ; i ++ ) { data . push ( cubehelix . rgb ( i / steps , opts ) . map ( ( v ) => v / 255 ) ) ; } return data ; }<CODESPLIT>0.1620592623949051<CODESPLIT>0.1409316509962082

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/dfkaye/jasmine-where/blob/96e9bda5bcba91420a2e4a20cb8c1fdc89586ba8/jasmine-where.js#L70-L142<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function where ( fn ) { if ( typeof fn != 'function' ) { throw new Error ( 'where(param) expected param should be a function' ) ; } var fnBody = fn . toString ( ) . replace ( / \s*function[^\(]*[\(][^\)]*[\)][^\{]*{ / , '' ) . replace ( / [\}]$ / , '' ) ; var values = parseFnBody ( fnBody ) ; var labels = values [ 0 ] ; /**      * {labels} array is toString'd so the values became param symbols in the new Function.      * {fnBody} is what's left of the original function, mainly the expectation.      */ var fnTest = new Function ( labels . toString ( ) , fnBody ) ; var failedCount = 0 ; var trace = '\n [' + labels . join ( PAD ) + '] : ' ; /*      * 1.x.x - jasmine.getEnv().currentSpec      * 2.x.x - .currentSpec is no longer exposed (leaking state) so use a shim for it with       *          the v2 .result property      */ var currentSpec = jasmine . getEnv ( ) . currentSpec || { result : { } } ; var result = /* jasmine 2.x.x. */ currentSpec . result || /* jasmine 1.x.x. */ currentSpec . results_ ; var item , message ; for ( var i = 1 ; i < values . length ; ++ i ) { message = MESSAGE ; fnTest . apply ( currentSpec , values [ i ] ) ; // TODO - extract method, perhaps... // collect any failed expectations  if ( result . failedExpectations && result . failedExpectations . length ) { /*          * jasmine 2.x.x.          */ if ( failedCount < result . failedExpectations . length ) { failedCount += 1 ; item = result . failedExpectations [ failedCount - 1 ] ; message = item . message ; item . message = trace + '\n [' + values [ i ] . join ( PAD ) + '] (' + message + ')' ; } } else if ( result . items_ ) { /*          * jasmine 1.x.x.          */ item = result . items_ [ result . items_ . length - 1 ] ; if ( item && ! item . passed_ ) { failedCount += 1 ; message = item . message ; item . message = trace + '\n [' + values [ i ] . join ( PAD ) + '] (' + message + ')' ; } } } // use these in further assertions  return values ; }<CODESPLIT>0.13205508887767792<CODESPLIT>0.14992232620716095

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/dwightjack/vue-types/blob/083089dbef1bc351b7b242546c24e6f5a2ddaed0/examples/userlist/dist/bundle.js#L1933-L1942<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function withMacroTask ( fn ) { return fn . _withTask || ( fn . _withTask = function ( ) { useMacroTask = true ; try { return fn . apply ( null , arguments ) } finally { useMacroTask = false ; } } ) }<CODESPLIT>0.16831707954406738<CODESPLIT>0.14143522083759308

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/ParksProjets/C-Preprocessor/blob/9c9ea8901b801cc42c69192bacd39814c415cd3b/bin/global.js#L39-L48<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function error ( msg , addHint ) { console . log ( '\x1b[31m' ) ; console . log ( 'The compiler has stopped on an error' ) console . log ( ` \x1b ${ msg } \x1b ` ) ; if ( addHint ) console . log ( ` \n ` ) ; process . exit ( 1 ) ; }<CODESPLIT>0.10646664351224899<CODESPLIT>0.15669958293437958

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/zeit/next.js/blob/3641f79a0f68d1093cc238b50b8d47eec1c25cfd/packages/next/client/dev-error-overlay/hot-dev-client.js#L172-L193<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function handleErrors ( errors ) { clearOutdatedErrors ( ) isFirstCompilation = false hasCompileErrors = true // "Massage" webpack messages. var formatted = formatWebpackMessages ( { errors : errors , warnings : [ ] } ) // Only show the first error. ErrorOverlay . reportBuildError ( formatted . errors [ 0 ] ) // Also log them to the console. if ( typeof console !== 'undefined' && typeof console . error === 'function' ) { for ( var i = 0 ; i < formatted . errors . length ; i ++ ) { console . error ( stripAnsi ( formatted . errors [ i ] ) ) } } }<CODESPLIT>0.18588422238826752<CODESPLIT>0.13191428780555725

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/jharding/yapa/blob/019f027868dec17a3ae4d6fc458f3bcdbdf80759/index.js#L107-L129<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function invokeCallback ( cb , invokeMethod , valueOrReason , promise , type ) { var cbValue , cbError , errorThrown ; try { cbValue = cb [ invokeMethod ] ( null , valueOrReason ) ; } catch ( err ) { errorThrown = true , cbError = err ; } // send return values in promise chain to downstream promise if ( type === 'fulfill' ) { promise . _values = this . _values . concat ( [ valueOrReason ] ) ; } if ( ! errorThrown && cbValue && typeof cbValue . then === 'function' ) { cbValue . then ( function ( value ) { promise . fulfill ( value ) ; } , function ( reason ) { promise . reject ( reason ) ; } ) ; } else { ! errorThrown ? promise . fulfill ( cbValue ) : promise . reject ( cbError ) ; } }<CODESPLIT>0.15801607072353363<CODESPLIT>0.1359887272119522

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L5991-L6021<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( ) { var queue = this . _queue , options = this . options , before = options && options . before , after = options && options . after , target , method , args , stack , i , l = queue . length ; if ( l && before ) { before ( ) ; } for ( i = 0 ; i < l ; i += 4 ) { target = queue [ i ] ; method = queue [ i + 1 ] ; args = queue [ i + 2 ] ; stack = queue [ i + 3 ] ; // Debugging assistance // TODO: error handling if ( args && args . length > 0 ) { method . apply ( target , args ) ; } else { method . call ( target ) ; } } if ( l && after ) { after ( ) ; } // check if new items have been added if ( queue . length > l ) { this . _queue = queue . slice ( l ) ; this . flush ( ) ; } else { this . _queue . length = 0 ; } }<CODESPLIT>0.15701785683631897<CODESPLIT>0.12571056187152863

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/bigpipe/fabricator/blob/b480885caf5f2367385e981e1a915dda18de2806/index.js#L198-L218<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function init ( constructor , name , options ) { constructor = ( 'string' === is ( constructor ) ) ? require ( constructor ) : constructor ; // // We really want to have a function/class here. Make sure that we can // construct it using `new constructor` // if ( ! constructor . prototype ) return ; name = constructor . prototype . name || name || constructor . name ; if ( options . name ) name = options . name ; // // Sets the name on the prototype to a string. // if ( 'name' in constructor . prototype ) { constructor . prototype . name = name . toString ( ) ; } return constructor ; }<CODESPLIT>0.1797265261411667<CODESPLIT>0.12808997929096222

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/device/purchases/Sencha.js#L63-L90<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( config ) { if ( ! config . success ) { Ext . Logger . error ( 'You must specify a `success` callback for `#getProducts` to work.' ) ; return false ; } if ( ! config . failure ) { Ext . Logger . error ( 'You must specify a `failure` callback for `#getProducts` to work.' ) ; return false ; } Ext . device . Communicator . send ( { command : 'Purchase#getProducts' , productInfos : JSON . stringify ( config . productInfos ) , callbacks : { success : function ( products ) { var store = Ext . create ( 'Ext.data.Store' , { model : 'Ext.device.Purchases.Product' , data : products } ) ; config . success . call ( config . scope || this , store ) ; } , failure : config . failure } , scope : config . scope || this } ) ; }<CODESPLIT>0.12233852595090866<CODESPLIT>0.12919946014881134

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L20949-L20956<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function instantiateSignatureInContextOf ( signature , contextualSignature , contextualMapper ) { var context = createInferenceContext ( signature . typeParameters , /*inferUnionTypes*/ true ) ; forEachMatchingParameterType ( contextualSignature , signature , function ( source , target ) { // Type parameters from outer context referenced by source type are fixed by instantiation of the source type inferTypes ( context , instantiateType ( source , contextualMapper ) , target ) ; } ) ; return getSignatureInstantiation ( signature , getInferredTypes ( context ) ) ; }<CODESPLIT>0.17001797258853912<CODESPLIT>0.15030060708522797

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/carbon-design-system/carbon-components/blob/e5ae58647d32aaae687e811d3f61e988cab1c302/packages/bundler/src/commands/measure.js#L89-L107<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>async function findPackageFor ( filepath ) { let directory = filepath ; while ( directory !== '/' ) { const directoryToSearch = path . dirname ( directory ) ; const files = await fs . readdir ( directoryToSearch ) ; if ( files . indexOf ( 'package.json' ) !== - 1 ) { const packageJson = await fs . readJson ( path . join ( directoryToSearch , 'package.json' ) ) ; return packageJson . name ; } directory = path . resolve ( directory , '..' ) ; } throw new Error ( ` ${ filepath } ` ) ; }<CODESPLIT>0.15347729623317719<CODESPLIT>0.13637012243270874

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/bholloway/browserify-nginject/blob/42cff52081b66d77e4e7fac923d4d824de13cfd3/lib/get-updater.js#L43-L82<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getAnnotatedNode ( comment ) { // find the first function declaration or expression following the annotation var result ; if ( comment . annotates ) { var candidateTrees ; // consider the context the block is in (i.e. what is its parent) var parent = comment . annotates . parent ; // consider nodes from the annotated node forward //  include the first non-generated node and all generated nodes preceding it if ( testNode . isBlockOrProgram ( parent ) ) { var body = parent . body ; var index = body . indexOf ( comment . annotates ) ; var candidates = body . slice ( index ) ; var length = candidates . map ( testNode . isGeneratedCode ) . indexOf ( false ) + 1 ; candidateTrees = candidates . slice ( 0 , length || candidates . length ) ; } // otherwise we can only consider the given node else { candidateTrees = [ comment . annotates ] ; } // try the nodes while ( ! result && candidateTrees . length ) { result = esprimaTools . orderNodes ( candidateTrees . shift ( ) ) . filter ( testNode . isFunctionNotIFFE ) . shift ( ) ; } } // throw where not valid if ( result ) { return result ; } else { errorFn ( 'Doc-tag @ngInject does not annotate anything' ) ; } }<CODESPLIT>0.160420760512352<CODESPLIT>0.14370392262935638

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L21312-L21319<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getEffectiveArgument ( node , args , argIndex ) { // For a decorator or the first argument of a tagged template expression we return undefined. if ( node . kind === 139 /* Decorator */ || ( argIndex === 0 && node . kind === 170 /* TaggedTemplateExpression */ ) ) { return undefined ; } return args [ argIndex ] ; }<CODESPLIT>0.1768399178981781<CODESPLIT>0.1475917398929596

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/reactbits/prismjs-package/blob/a50eb0c18c30a62d6af4e9be61b83de586d32187/gulpfile.js#L55-L61<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function highlight ( code , lang ) { const g = Prism . languages [ lang ] ; if ( g ) { return Prism . highlight ( code , g , lang ) ; } return code ; }<CODESPLIT>0.17502349615097046<CODESPLIT>0.13304786384105682

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/saymedia/angularjs-server/blob/db61e9cfd9d6634ebf66c8320b823ebf7eab1a6b/examples/weather/angular.js#L4443-L4525<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( key , value , writeAttr , attrName ) { //special case for class attribute addition + removal //so that class changes can tap into the animation //hooks provided by the $animate service if ( key == 'class' ) { value = value || '' ; var current = this . $$element . attr ( 'class' ) || '' ; this . $removeClass ( tokenDifference ( current , value ) . join ( ' ' ) ) ; this . $addClass ( tokenDifference ( value , current ) . join ( ' ' ) ) ; } else { var booleanKey = getBooleanAttrName ( this . $$element [ 0 ] , key ) , normalizedVal , nodeName ; if ( booleanKey ) { this . $$element . prop ( key , value ) ; attrName = booleanKey ; } this [ key ] = value ; // translate normalized key to actual key if ( attrName ) { this . $attr [ key ] = attrName ; } else { attrName = this . $attr [ key ] ; if ( ! attrName ) { this . $attr [ key ] = attrName = snake_case ( key , '-' ) ; } } nodeName = nodeName_ ( this . $$element ) ; // sanitize a[href] and img[src] values if ( ( nodeName === 'A' && key === 'href' ) || ( nodeName === 'IMG' && key === 'src' ) ) { // NOTE: $$urlUtils.resolve() doesn't support IE < 8 so we don't sanitize for that case. if ( ! msie || msie >= 8 ) { normalizedVal = $$urlUtils . resolve ( value ) ; if ( normalizedVal !== '' ) { if ( ( key === 'href' && ! normalizedVal . match ( aHrefSanitizationWhitelist ) ) || ( key === 'src' && ! normalizedVal . match ( imgSrcSanitizationWhitelist ) ) ) { this [ key ] = value = 'unsafe:' + normalizedVal ; } } } } if ( writeAttr !== false ) { if ( value === null || value === undefined ) { this . $$element . removeAttr ( attrName ) ; } else { this . $$element . attr ( attrName , value ) ; } } } // fire observers var $$observers = this . $$observers ; $$observers && forEach ( $$observers [ key ] , function ( fn ) { try { fn ( value ) ; } catch ( e ) { $exceptionHandler ( e ) ; } } ) ; function tokenDifference ( str1 , str2 ) { var values = [ ] , tokens1 = str1 . split ( / \s+ / ) , tokens2 = str2 . split ( / \s+ / ) ; outer : for ( var i = 0 ; i < tokens1 . length ; i ++ ) { var token = tokens1 [ i ] ; for ( var j = 0 ; j < tokens2 . length ; j ++ ) { if ( token == tokens2 [ j ] ) continue outer ; } values . push ( token ) ; } return values ; } ; }<CODESPLIT>0.16286322474479675<CODESPLIT>0.14567254483699799

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/emmetio/codemirror-plugin/blob/2089c8b15b97858b82b33e6e81ee1b50954581c1/lib/extract-abbreviation.js#L61-L87<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function canExtract ( editor , pos , config ) { const tokenType = editor . getTokenTypeAt ( pos ) ; if ( config . type === 'stylesheet' ) { return tokenType !== 'comment' && tokenType !== 'string' ; } if ( config . syntax === 'html' ) { return tokenType === null ; } if ( config . syntax === 'slim' || config . syntax === 'pug' ) { return tokenType === null || tokenType === 'tag' || ( tokenType && / attribute / . test ( tokenType ) ) ; } if ( config . syntax === 'haml' ) { return tokenType === null || tokenType === 'attribute' ; } if ( config . syntax === 'jsx' ) { // JSX a bit tricky, delegate it to caller return true ; } return false ; }<CODESPLIT>0.14167198538780212<CODESPLIT>0.1452401727437973

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/janjakubnanista/simple-imap-inbox/blob/c333a46ed21a95f3ccf19bc91148b0fa1c35aeda/lib/inbox.js#L16-L45<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( imapMessage ) { var deferred = Q . defer ( ) ; var message = new Message ( ) ; imapMessage . on ( 'body' , function ( stream , info ) { var buffer = '' ; stream . on ( 'data' , function ( chunk ) { buffer += chunk . toString ( 'utf8' ) ; } ) ; stream . on ( 'end' , function ( ) { if ( info . which === 'TEXT' ) { message . body = buffer ; } else { message . headers = Imap . parseHeader ( buffer ) ; } } ) ; } ) ; imapMessage . on ( 'attributes' , function ( attrs ) { message . attributes = attrs ; } ) ; imapMessage . on ( 'end' , function ( ) { deferred . resolve ( message ) ; } ) ; return deferred . promise ; }<CODESPLIT>0.16387474536895752<CODESPLIT>0.13301722705364227

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/canjs/can-map/blob/f2083ca4ef9f2c193aeaf15e013c956aa64c3a77/can-map.js#L58-L130<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( baseMap ) { Construct . setup . apply ( this , arguments ) ; // A cached list of computed properties on the prototype. this . _computedPropertyNames = [ ] ; // Do not run if we are defining can.Map. if ( Map ) { addTypeEvents ( this ) ; this [ canSymbol . for ( "can.defineInstanceKey" ) ] = function ( prop , definition ) { if ( definition . value !== undefined ) { this . defaults [ prop ] = definition . value ; } if ( definition . enumerable === false ) { this . enumerable [ prop ] = false ; } } ; // Provide warnings if can.Map is used incorrectly. //!steal-remove-start if ( process . env . NODE_ENV !== 'production' ) { if ( this . prototype . define && ! mapHelpers . define ) { dev . warn ( "can/map/define is not included, yet there is a define property " + "used. You may want to add this plugin." ) ; } if ( this . define && ! mapHelpers . define ) { dev . warn ( "The define property should be on the map's prototype properties, " + "not the static properties. Also, can/map/define is not included." ) ; } } //!steal-remove-end // Create a placeholder for default values. if ( ! this . defaults ) { this . defaults = { } ; } if ( ! this . enumerable ) { this . enumerable = { } ; } // Go through everything on the prototype.  If it's a primitive, // treat it as a default value.  If it's a compute, identify it so // it can be setup as a computed property. for ( var prop in this . prototype ) { if ( prop !== "define" && prop !== "constructor" && ( typeof this . prototype [ prop ] !== "function" || this . prototype [ prop ] . prototype instanceof Construct ) ) { this . defaults [ prop ] = this . prototype [ prop ] ; } else if ( canReflect . isObservableLike ( this . prototype [ prop ] ) ) { this . _computedPropertyNames . push ( prop ) ; } } // If define is a function, call it with this can.Map if ( mapHelpers . define ) { mapHelpers . define ( this , baseMap . prototype . define ) ; } } // If we inherit from can.Map, but not can.List, create a can.List that // creates instances of this Map type. // This is something List should weave in. /*if (can.List && !(this.prototype instanceof can.List)) { 				this.List = Map.List.extend({ 					Map: this 				}, {}); 			}*/ }<CODESPLIT>0.1610415130853653<CODESPLIT>0.14358463883399963

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/GitbookIO/repofs/blob/24f9880f3abb5aae4e4be56d0e88ba9d214447be/src/utils/conflict.js#L78-L105<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function mergeCommit ( treeConflict , parents , options ) { options = options || { } ; const opts = { } ; // Assume the commit is not empty opts . empty = false ; // Parent SHAs opts . parents = new Immutable . List ( parents ) ; opts . author = options . author ; opts . message = options . message || 'Merged commit' ; // Get the solved tree entries const solvedEntries = _getSolvedEntries ( treeConflict ) ; opts . treeEntries = solvedEntries ; // Create map of blobs that needs to be created const solvedConflicts = treeConflict . getConflicts ( ) ; opts . blobs = solvedEntries . filter ( ( treeEntry ) => { return ! treeEntry . hasSha ( ) ; } ) . map ( ( treeEntry , path ) => { return solvedConflicts . get ( path ) . getSolvedContent ( ) ; } ) ; return CommitBuilder . create ( opts ) ; }<CODESPLIT>0.1609971672296524<CODESPLIT>0.13441431522369385

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/cloudinary/cloudinary_js/blob/c5ef98e858ba83e7c2c13a1d898748b571a5931b/webpack.config.js#L53-L138<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function baseConfig ( name , mode ) { const config = { name : ` ${ name } ${ mode } ` , mode , output : { library : 'cloudinary' , libraryTarget : 'umd' , globalObject : "this" , pathinfo : false } , optimization : { concatenateModules : true , moduleIds : 'named' , usedExports : true , minimizer : [ new TerserPlugin ( { terserOptions : { mangle : { keep_classnames : true , reserved : reserved , ie8 : true } } , } ) ] } , resolve : { extensions : [ '.js' ] } , externals : [ { jquery : 'jQuery' } ] , node : { Buffer : false , process : false } , devtool : "source-map" , module : { rules : [ { test : / \.m?js$ / , exclude : / (node_modules|bower_components) / , use : { loader : 'babel-loader' } } ] } , plugins : [ new webpack . BannerPlugin ( { banner : ` ${ version } ` , // the banner as string or function, it will be wrapped in a comment raw : true , // if true, banner will not be wrapped in a comment entryOnly : true , // if true, the banner will only be added to the entry chunks } ) ] } ; let filename = ` ${ name } ` ; if ( mode === 'production' ) { filename += '.min' ; } const util = name . startsWith ( 'jquery' ) ? 'jquery' : 'lodash' ; const utilPath = path . resolve ( __dirname , ` ${ util } ` ) ; config . output . filename = ` ${ filename } ` ; config . entry = ` ${ name } ` ; config . resolve . alias = { "../util$" : utilPath , "./util$" : utilPath } ; // Add reference to each lodash function as a separate module. if ( name === 'core' ) { config . externals . push ( resolveLodash ) ; } config . plugins . push ( new BundleAnalyzerPlugin ( { analyzerMode : 'static' , reportFilename : ` ${ filename } ` , openAnalyzer : false } ) ) ; return config ; }<CODESPLIT>0.17839814722537994<CODESPLIT>0.13359825313091278

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/tencentyun/cos-js-sdk-v5/blob/fe74e2df5191d075483d9abb8a18c9426924f28f/src/base.js#L2229-L2356<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function _submitRequest ( params , callback ) { var self = this ; var TaskId = params . TaskId ; if ( TaskId && ! self . _isRunningTask ( TaskId ) ) return ; var bucket = params . Bucket ; var region = params . Region ; var object = params . Key ; var method = params . method || 'GET' ; var url = params . url ; var body = params . body ; var json = params . json ; var rawBody = params . rawBody ; // url url = url || getUrl ( { ForcePathStyle : self . options . ForcePathStyle , protocol : self . options . Protocol , domain : self . options . Domain , bucket : bucket , region : region , object : object , } ) ; if ( params . action ) { url = url + '?' + params . action ; } var opt = { method : method , url : url , headers : params . headers , qs : params . qs , body : body , json : json , } ; //  opt . headers . Authorization = params . AuthData . Authorization ; params . AuthData . Token && ( opt . headers [ 'token' ] = params . AuthData . Token ) ; params . AuthData . ClientIP && ( opt . headers [ 'clientIP' ] = params . AuthData . ClientIP ) ; params . AuthData . ClientUA && ( opt . headers [ 'clientUA' ] = params . AuthData . ClientUA ) ; params . AuthData . XCosSecurityToken && ( opt . headers [ 'x-cos-security-token' ] = params . AuthData . XCosSecurityToken ) ; //  undefined  null  opt . headers && ( opt . headers = util . clearKey ( opt . headers ) ) ; opt = util . clearKey ( opt ) ; // progress if ( params . onProgress && typeof params . onProgress === 'function' ) { var contentLength = body && ( body . size || body . length ) || 0 ; opt . onProgress = function ( e ) { if ( TaskId && ! self . _isRunningTask ( TaskId ) ) return ; var loaded = e ? e . loaded : 0 ; params . onProgress ( { loaded : loaded , total : contentLength } ) ; } ; } if ( this . options . Timeout ) { opt . timeout = this . options . Timeout ; } self . emit ( 'before-send' , opt ) ; var sender = REQUEST ( opt , function ( err , response , body ) { if ( err === 'abort' ) return ; //    headers var hasReturned ; var cb = function ( err , data ) { TaskId && self . off ( 'inner-kill-task' , killTask ) ; if ( hasReturned ) return ; hasReturned = true ; var attrs = { } ; response && response . statusCode && ( attrs . statusCode = response . statusCode ) ; response && response . headers && ( attrs . headers = response . headers ) ; if ( err ) { err = util . extend ( err || { } , attrs ) ; callback ( err , null ) ; } else { data = util . extend ( data || { } , attrs ) ; callback ( null , data ) ; } sender = null ; } ; //  if ( err ) { cb ( { error : err } ) ; return ; } var jsonRes ; try { jsonRes = body && body . indexOf ( '<' ) > - 1 && body . indexOf ( '>' ) > - 1 && util . xml2json ( body ) || { } ; } catch ( e ) { jsonRes = body || { } ; } //  200 var statusCode = response . statusCode ; var statusSuccess = Math . floor ( statusCode / 100 ) === 2 ; // 200 202 204 206 if ( ! statusSuccess ) { cb ( { error : jsonRes . Error || jsonRes } ) ; return ; } //  body body  if ( rawBody ) { jsonRes = { } ; jsonRes . body = body ; } if ( jsonRes . Error ) { cb ( { error : jsonRes . Error } ) ; return ; } cb ( null , jsonRes ) ; } ) ; // kill task var killTask = function ( data ) { if ( data . TaskId === TaskId ) { sender && sender . abort && sender . abort ( ) ; self . off ( 'inner-kill-task' , killTask ) ; } } ; TaskId && self . on ( 'inner-kill-task' , killTask ) ; }<CODESPLIT>0.1512562483549118<CODESPLIT>0.1311257928609848

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L3220-L3235<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( childRecord , childKey , parentRecord , parentKey , change ) { var clientId = childRecord . clientId , parentClientId = parentRecord ? parentRecord : parentRecord ; var key = childKey + parentKey ; var changes = this . _relationshipChanges ; if ( ! ( clientId in changes ) ) { changes [ clientId ] = { } ; } if ( ! ( parentClientId in changes [ clientId ] ) ) { changes [ clientId ] [ parentClientId ] = { } ; } if ( ! ( key in changes [ clientId ] [ parentClientId ] ) ) { changes [ clientId ] [ parentClientId ] [ key ] = { } ; } changes [ clientId ] [ parentClientId ] [ key ] [ change . changeType ] = change ; }<CODESPLIT>0.17106585204601288<CODESPLIT>0.140640988945961

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/flowjs/flow.js/blob/aadc5a72b1414d87ed1aa3563b30209f9b1f7773/dist/flow.js#L1531-L1538<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function evalOpts ( data , args ) { if ( typeof data === "function" ) { // `arguments` is an object, not array, in FF, so: args = Array . prototype . slice . call ( arguments ) ; data = data . apply ( null , args . slice ( 1 ) ) ; } return data ; }<CODESPLIT>0.16494545340538025<CODESPLIT>0.15556631982326508

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/jsantell/GhostTrain/blob/e69b6cc33669035c1d571bff3805e1b6d8a50ccb/lib/utils.js#L30-L40<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function findRoute ( ghosttrain , verb , url ) { // Extract path from the object or string var path = url . pathname ? url . pathname : parseURL ( url ) ; var routes = ghosttrain . routes [ verb . toLowerCase ( ) ] ; if ( ! routes ) return null ; for ( var i = 0 ; i < routes . length ; i ++ ) if ( routes [ i ] . match ( path ) ) return routes [ i ] ; return null ; }<CODESPLIT>0.17462752759456635<CODESPLIT>0.13629737496376038

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/ldez/cubejs/blob/36b38b676ddf4f939583e020455a0834264d61f3/lib/solve.js#L196-L215<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( twist ) { var i , m , o , ori , parity , v ; if ( twist != null ) { parity = 0 ; for ( i = m = 6 ; m >= 0 ; i = -- m ) { ori = twist % 3 ; twist = ( twist / 3 ) | 0 ; this . co [ i ] = ori ; parity += ori ; } this . co [ 7 ] = ( 3 - parity % 3 ) % 3 ; return this ; } else { v = 0 ; for ( i = o = 0 ; o <= 6 ; i = ++ o ) { v = 3 * v + this . co [ i ] ; } return v ; } }<CODESPLIT>0.15892630815505981<CODESPLIT>0.14424969255924225

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/spec/helpers/fixture-utils.js#L125-L172<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getTemplateLanguageConstructs ( templateLanguage ) { var constructs ; switch ( templateLanguage . toLowerCase ( ) ) { case "handlebars" : constructs = { startDelimiter : "{{" , endDelimiter : "}}" , if : "{{#if isActive}}" , else : "{{else}}" , endIf : "{{/if}}" , loop : "{{#each looped as |value index|}}" , endLoop : "{{/each}}" , partial : '{{> userMessage tagName="h2" }}' } ; break ; case "ejs" : constructs = { startDelimiter : "<%= " , endDelimiter : " %>" , if : "<% if (isActive) { %>" , else : "<% } else { %>" , endIf : "<% } %>" , loop : "<% looped.forEach(function(item) { %>" , endLoop : "<% }); %>" , partial : "<%- include('user/show', {user: user}); %>" } ; break ; case "es6" : constructs = { startDelimiter : "${" , endDelimiter : "}" , if : "" , else : "" , endIf : "" , loop : "" , endLoop : "" , partial : "" } ; break ; default : throw new Error ( 'Unsupported template language "' + templateLanguage + '"' ) ; } return constructs ; }<CODESPLIT>0.13718758523464203<CODESPLIT>0.1443336457014084

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/AdamBrodzinski/meteor-generate/blob/e8a8533677f4116809827b0292a7957ce2dc11cf/lib/controller.js#L97-L110<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( action ) { var templateStr = fs . readFileSync ( this . contrTemplates + action + '.js' , { encoding : 'utf-8' } ) ; // rename template variables and append to controller file templateStr = require ( './rename' ) ( this . resName , templateStr ) ; fs . appendFileSync ( this . contrFile , templateStr ) ; // add a route for new controller if ( action !== 'create' && action !== 'update' && action !== 'destroy' ) { require ( './router' ) . appendRoute ( this . resName , action ) ; console . log ( '    Added Route: ' + this . resName + " " + action ) ; } }<CODESPLIT>0.12314967811107635<CODESPLIT>0.14593493938446045

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/flightjs/jasmine-flight/blob/8b82f490aaf239adc8369927bbf72e207efffdb1/lib/jasmine-flight.js#L83-L130<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function describeComponentFactory ( componentPath , specDefinitions , isMixin ) { return function ( ) { beforeEach ( function ( done ) { // reset member variables this . Component = this . component = this . $node = null ; // bind setupComponent to the current context this . setupComponent = setupComponent . bind ( this ) ; var requireCallback = function ( registry , defineComponent , Component ) { // reset the registry registry . reset ( ) ; if ( isMixin ) { // mix the mixin in to an anonymous, component this . Component = defineComponent ( function ( ) { } , Component ) ; } else { this . Component = Component ; } // let Jasmine know we're good to continue with the tests done ( ) ; } . bind ( this ) ; require ( [ 'flight/lib/registry' , 'flight/lib/component' , componentPath ] , requireCallback ) ; } ) ; afterEach ( function ( done ) { // remove the component root node if ( this . $node ) { this . $node . remove ( ) ; this . $node = null ; } var requireCallback = function ( defineComponent ) { // reset local member variables this . component = null ; this . Component = null ; // teardown all flight components defineComponent . teardownAll ( ) ; done ( ) ; } . bind ( this ) ; require ( [ 'flight/lib/component' ] , requireCallback ) ; } ) ; specDefinitions . apply ( this ) ; } ; }<CODESPLIT>0.17087049782276154<CODESPLIT>0.12904509902000427

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/canjs/can-map/blob/f2083ca4ef9f2c193aeaf15e013c956aa64c3a77/can-map.js#L379-L403<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( prop , value , current ) { if ( value !== current || ! Object . prototype . hasOwnProperty . call ( this . _data , prop ) ) { var computedAttr = this . _computedAttrs [ prop ] ; // Dispatch an "add" event if adding a new property. var changeType = computedAttr || current !== undefined || hasOwnProperty . call ( this . ___get ( ) , prop ) ? "set" : "add" ; // Set the value on `_data` and set up bubbling. this . ___set ( prop , typeof value === "object" ? bubble . set ( this , prop , value , current ) : value ) ; // Computed properties change events are already forwarded except if // no one is listening to them. if ( ! computedAttr || ! computedAttr . count ) { this . _triggerChange ( prop , changeType , value , current ) ; } // Stop bubbling old nested maps. if ( typeof current === "object" ) { bubble . teardownFromParent ( this , current ) ; } } }<CODESPLIT>0.15149468183517456<CODESPLIT>0.14475563168525696

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/ftlabs/fruitmachine/blob/7ef6445c3a422e462074b4de5007c4662ae09347/lib/module/index.js#L42-L59<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function Module ( options ) { // Shallow clone the options options = mixin ( { } , options ) ; // Various config steps this . _configure ( options ) ; this . _add ( options . children ) ; // Fire before initialize event hook this . fireStatic ( 'before initialize' , options ) ; // Run initialize hooks if ( this . initialize ) this . initialize ( options ) ; // Fire initialize event hook this . fireStatic ( 'initialize' , options ) ; }<CODESPLIT>0.17191635072231293<CODESPLIT>0.11860935389995575

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/app/Application.js#L580-L598<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( name , profileName ) { var instances = this . getControllerInstances ( ) , appName = this . getName ( ) , format = Ext . String . format , topLevelName ; if ( name instanceof Ext . app . Controller ) { return name ; } if ( instances [ name ] ) { return instances [ name ] ; } else { topLevelName = format ( "{0}.controller.{1}" , appName , name ) ; profileName = format ( "{0}.controller.{1}.{2}" , appName , profileName , name ) ; return instances [ profileName ] || instances [ topLevelName ] ; } }<CODESPLIT>0.169034942984581<CODESPLIT>0.14066803455352783

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L3960-L3973<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function deepClone ( object ) { var clone = { } , value ; for ( var prop in object ) { value = object [ prop ] ; if ( value && typeof value === 'object' ) { clone [ prop ] = deepClone ( value ) ; } else { clone [ prop ] = value ; } } return clone ; }<CODESPLIT>0.16669823229312897<CODESPLIT>0.13948310911655426

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/GitbookIO/repofs/blob/24f9880f3abb5aae4e4be56d0e88ba9d214447be/src/utils/file.js#L146-L153<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function write ( repoState , filepath , content ) { if ( ! exists ( repoState , filepath ) ) { throw error . fileNotFound ( filepath ) ; } const change = Change . createUpdate ( content ) ; return ChangeUtils . setChange ( repoState , filepath , change ) ; }<CODESPLIT>0.14972369372844696<CODESPLIT>0.13485662639141083

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/taskcluster/taskcluster-lib-stats/blob/1760c7037a07f0a4a715c6aa93475209f8bcbfc6/src/series.js#L33-L44<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( options ) { // Validate options assert ( options , "options are required" ) ; assert ( options . name , "Series must be named" ) ; options = _ . defaults ( { } , options , { columns : { } , additionalColumns : null } ) ; // Store options this . _options = options ; }<CODESPLIT>0.13928104937076569<CODESPLIT>0.14376331865787506

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L10127-L10130<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( data , type , record , options ) { var root = Ember . String . decamelize ( type . typeKey ) ; data [ root ] = this . serialize ( record , options ) ; }<CODESPLIT>0.1243465393781662<CODESPLIT>0.16455647349357605

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/GitbookIO/repofs/blob/24f9880f3abb5aae4e4be56d0e88ba9d214447be/src/utils/branches.js#L13-L63<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function create ( repositoryState , driver , name , opts = { } ) { const { // Base branch for the new branch base = repositoryState . getCurrentBranch ( ) , // Fetch the working state and switch to it ? checkout = true , // Drop changes from base branch the new working state ? clean = true , // Drop changes from the base branch ? cleanBase = false } = opts ; let createdBranch ; return driver . createBranch ( base , name ) // Update list of branches . then ( ( branch ) => { createdBranch = branch ; let branches = repositoryState . getBranches ( ) ; branches = branches . push ( createdBranch ) ; return repositoryState . set ( 'branches' , branches ) ; } ) // Update working state or fetch it if needed . then ( ( repoState ) => { let baseWk = repoState . getWorkingStateForBranch ( base ) ; if ( ! baseWk ) { return checkout ? RepoUtils . fetchTree ( repoState , driver , createdBranch ) : repoState ; } // Reuse base WorkingState clean const headWk = clean ? baseWk . asClean ( ) : baseWk ; repoState = RepoUtils . updateWorkingState ( repoState , createdBranch , headWk ) ; // Clean base WorkingState baseWk = cleanBase ? baseWk . asClean ( ) : baseWk ; repoState = RepoUtils . updateWorkingState ( repoState , base , baseWk ) ; return repoState ; } ) // Checkout the branch . then ( ( repoState ) => { if ( ! checkout ) { return repoState ; } return RepoUtils . checkout ( repoState , createdBranch ) ; } ) ; }<CODESPLIT>0.17033444344997406<CODESPLIT>0.1485927850008011

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/azproduction/lmd/blob/03410c36839728de683c697670e1b205dc8193ee/stats_server/views/statics/vendors/3d/d3.js#L4452-L4461<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function touchstart ( ) { start . apply ( this , arguments ) ; var touches = d3_behavior_zoomTouchup ( ) , touch , now = Date . now ( ) ; if ( ( touches . length === 1 ) && ( now - d3_behavior_zoomLast < 300 ) ) { d3_behavior_zoomTo ( 1 + Math . floor ( xyz [ 2 ] ) , touch = touches [ 0 ] , d3_behavior_zoomLocations [ touch . identifier ] ) ; } d3_behavior_zoomLast = now ; }<CODESPLIT>0.16210530698299408<CODESPLIT>0.12772798538208008

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L2247-L2258<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( type , id ) { if ( id === undefined ) { return this . findAll ( type ) ; } // We are passed a query instead of an id. if ( Ember . typeOf ( id ) === 'object' ) { return this . findQuery ( type , id ) ; } return this . findById ( type , coerceId ( id ) ) ; }<CODESPLIT>0.16497790813446045<CODESPLIT>0.15886995196342468

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/mpetroff/pannellum/blob/59893bcea4629be059ad3e59c3fa5bde438d292b/src/js/pannellum.js#L1802-L1838<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function renderHotSpot ( hs ) { var hsPitchSin = Math . sin ( hs . pitch * Math . PI / 180 ) , hsPitchCos = Math . cos ( hs . pitch * Math . PI / 180 ) , configPitchSin = Math . sin ( config . pitch * Math . PI / 180 ) , configPitchCos = Math . cos ( config . pitch * Math . PI / 180 ) , yawCos = Math . cos ( ( - hs . yaw + config . yaw ) * Math . PI / 180 ) ; var z = hsPitchSin * configPitchSin + hsPitchCos * yawCos * configPitchCos ; if ( ( hs . yaw <= 90 && hs . yaw > - 90 && z <= 0 ) || ( ( hs . yaw > 90 || hs . yaw <= - 90 ) && z <= 0 ) ) { hs . div . style . visibility = 'hidden' ; } else { var yawSin = Math . sin ( ( - hs . yaw + config . yaw ) * Math . PI / 180 ) , hfovTan = Math . tan ( config . hfov * Math . PI / 360 ) ; hs . div . style . visibility = 'visible' ; // Subpixel rendering doesn't work in Firefox // https://bugzilla.mozilla.org/show_bug.cgi?id=739176 var canvas = renderer . getCanvas ( ) , canvasWidth = canvas . clientWidth , canvasHeight = canvas . clientHeight ; var coord = [ - canvasWidth / hfovTan * yawSin * hsPitchCos / z / 2 , - canvasWidth / hfovTan * ( hsPitchSin * configPitchCos - hsPitchCos * yawCos * configPitchSin ) / z / 2 ] ; // Apply roll var rollSin = Math . sin ( config . roll * Math . PI / 180 ) , rollCos = Math . cos ( config . roll * Math . PI / 180 ) ; coord = [ coord [ 0 ] * rollCos - coord [ 1 ] * rollSin , coord [ 0 ] * rollSin + coord [ 1 ] * rollCos ] ; // Apply transform coord [ 0 ] += ( canvasWidth - hs . div . offsetWidth ) / 2 ; coord [ 1 ] += ( canvasHeight - hs . div . offsetHeight ) / 2 ; var transform = 'translate(' + coord [ 0 ] + 'px, ' + coord [ 1 ] + 'px) translateZ(9999px) rotate(' + config . roll + 'deg)' ; hs . div . style . webkitTransform = transform ; hs . div . style . MozTransform = transform ; hs . div . style . transform = transform ; } }<CODESPLIT>0.13892190158367157<CODESPLIT>0.15358197689056396

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/developmentseed/kes/blob/c92aaaf84c6ad5f75e03bdd0f0e4328c784854e6/src/utils.js#L93-L109<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function configureAws ( region , profile , role ) { if ( region ) { AWS . config . update ( { region } ) ; } if ( profile ) { AWS . config . credentials = new AWS . SharedIniFileCredentials ( { profile } ) ; } if ( role ) { AWS . config . credentials = new AWS . TemporaryCredentials ( { RoleArn : role } ) ; } }<CODESPLIT>0.1309913545846939<CODESPLIT>0.15927432477474213

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/html-next/ember-cli-changelog/blob/85ec3df1ea43c5e281eb07dc33b15cb9c7afcec2/lib/helpers/git/github/compare-commits.js#L25-L28<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function githubCompareCommits ( options , parseOptions ) { return compareCommits ( options ) . then ( function ( commits ) { return massageGithubCommits ( commits , parseOptions ) ; } ) ; }<CODESPLIT>0.1502709835767746<CODESPLIT>0.12536370754241943

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L18080-L18089<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( ) { var children = this . _getImmediateChildren ( ) ; if ( ! children . length ) { return children ; } return _ . reduce ( children , function ( memo , view ) { if ( ! view . _getNestedViews ) { return memo ; } return memo . concat ( view . _getNestedViews ( ) ) ; } , children ) ; }<CODESPLIT>0.161171093583107<CODESPLIT>0.1259717494249344

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/mojaie/kiwiii-client/blob/0f2820e9e0500c845acc36e8e21cb2ee11c28996/src/graph/GraphControlBox.js#L221-L229<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function mainControlBox ( ) { d3 . select ( '#show-struct' ) . on ( 'change' , function ( ) { const data = nodeContentInput ( ) ; d3 . select ( '#main-control' ) . datum ( data ) ; updateNodeStructure ( data ) ; } ) . dispatch ( 'change' ) ; }<CODESPLIT>0.11676685512065887<CODESPLIT>0.11843971163034439

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L15884-L15927<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function joinMarionette ( ) { if ( Backbone . Marionette && Backbone . Marionette . TemplateCache && ! isMarionetteInitialized ) { originalClearCache = Backbone . Marionette . TemplateCache . clear ; // Custom implementation of Marionette.TemplateCache.clear() // // When the Marionette cache is cleared, the DeclarativeViews cache is cleared as well. This is not technically // necessary, but makes sense. If there is a reason to invalidate a cached template, it applies to all caches. Backbone . Marionette . TemplateCache . clear = function ( ) { if ( arguments . length ) { Backbone . DeclarativeViews . clearCachedTemplate ( arguments , true ) ; } else { Backbone . DeclarativeViews . clearCache ( true ) ; } originalClearCache . apply ( this , arguments ) ; } ; isMarionetteInitialized = true ; // Removed: integration of the Marionette and Backbone.Declarative.Views template loading mechanisms // // Integrating the template loaders turned out to be of little or no benefit, and could potentially have caused // problems with other custom loaders. In detail: // // - Integration saved exactly one DOM access per *template*. Given the limited number of templates in a project, //   the performance gain had often been too small to even be measurable. // // - During testing with just a single template, the net effect was even negative (!) - integration and the //   associated overhead seemed to slow things down. // // - With integration, custom loaders like the one for Marionette/Handlebars had been trickier to use. Load //   order suddenly mattered. The code setting up a custom loader had to be run after integrating //   Backbone.Declarative.Views with Marionette. Otherwise, the custom loader would haven been overwritten, //   breaking the application. // // In a nutshell, loader integration has proven to be more trouble than it is worth. } }<CODESPLIT>0.17181436717510223<CODESPLIT>0.12378127872943878

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/vshymanskyy/blynk-library-js/blob/d886383546b416bc347f6c7fe94c512391c37957/blynk.js#L255-L431<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( auth , options ) { var self = this ; if ( needsEmitter ( ) ) { events . EventEmitter . call ( this ) ; } this . auth = auth ; var options = options || { } ; this . heartbeat = options . heartbeat || 10000 ; console . log ( "\n\     ___  __          __\n\    / _ )/ /_ _____  / /__\n\   / _  / / // / _ \\/  '_/\n\  /____/_/\\_, /_//_/_/\\_\\\n\         /___/\n\ \n\   Give Blynk a Github star! => https://github.com/vshymanskyy/blynk-library-js\n\ " ) ; // Auto-detect board if ( options . board ) { this . board = options . board ; } else if ( isEspruino ( ) ) { this . board = new BoardEspruinoPico ( ) ; } else if ( isBrowser ( ) ) { this . board = new BoardDummy ( ) ; } else { [ bl_node . BoardMRAA , bl_node . BoardOnOff , BoardDummy ] . some ( function ( b ) { try { self . board = new b ( ) ; return true ; } catch ( e ) { return false ; } } ) ; } self . board . init ( self ) ; // Auto-detect connector if ( options . connector ) { this . conn = options . connector ; } else if ( isEspruino ( ) ) { this . conn = new EspruinoTCP ( options ) ; } else if ( isBrowser ( ) ) { this . conn = new bl_browser . WsClient ( options ) ; } else { this . conn = new bl_node . SslClient ( options ) ; } this . buff_in = '' ; this . msg_id = 1 ; this . vpins = [ ] ; this . profile = options . profile ; this . VirtualPin = function ( vPin ) { if ( needsEmitter ( ) ) { events . EventEmitter . call ( this ) ; } this . pin = vPin ; self . vpins [ vPin ] = this ; this . write = function ( value ) { self . virtualWrite ( this . pin , value ) ; } ; } ; this . WidgetBridge = function ( vPin ) { this . pin = vPin ; this . setAuthToken = function ( token ) { self . sendMsg ( MsgType . BRIDGE , [ this . pin , 'i' , token ] ) ; } ; this . digitalWrite = function ( pin , val ) { self . sendMsg ( MsgType . BRIDGE , [ this . pin , 'dw' , pin , val ] ) ; } ; this . analogWrite = function ( pin , val ) { self . sendMsg ( MsgType . BRIDGE , [ this . pin , 'aw' , pin , val ] ) ; } ; this . virtualWrite = function ( pin , val ) { self . sendMsg ( MsgType . BRIDGE , [ this . pin , 'vw' , pin ] . concat ( val ) ) ; } ; } ; this . WidgetTerminal = function ( vPin ) { if ( needsEmitter ( ) ) { events . EventEmitter . call ( this ) ; } this . pin = vPin ; self . vpins [ vPin ] = this ; this . write = function ( data ) { self . virtualWrite ( this . pin , data ) ; } ; } ; this . WidgetLCD = function ( vPin ) { this . pin = vPin ; this . clear = function ( ) { self . virtualWrite ( this . pin , 'clr' ) ; } ; this . print = function ( x , y , val ) { self . sendMsg ( MsgType . HW , [ 'vw' , this . pin , 'p' , x , y , val ] ) ; } ; } ; this . WidgetTable = function ( vPin ) { this . pin = vPin ; this . clear = function ( ) { self . virtualWrite ( this . pin , 'clr' ) ; } ; this . add_row = function ( id , name , value ) { self . virtualWrite ( this . pin , [ 'add' , id , name , value ] ) ; } ; this . update_row = function ( id , name , value ) { self . virtualWrite ( this . pin , [ 'update' , id , name , value ] ) ; } ; this . highlight_row = function ( id ) { self . virtualWrite ( this . pin , [ 'pick' , id ] ) ; } ; this . select_row = function ( id ) { self . virtualWrite ( this . pin , [ 'select' , id ] ) ; } ; this . deselect_row = function ( id ) { self . virtualWrite ( this . pin , [ 'deselect' , id ] ) ; } ; this . move_row = function ( old_row , new_row ) { self . virtualWrite ( this . pin , [ 'order' , old_row , new_row ] ) ; } ; } ; this . WidgetLED = function ( vPin ) { this . pin = vPin ; this . setValue = function ( val ) { self . virtualWrite ( this . pin , val ) ; } ; this . turnOn = function ( ) { self . virtualWrite ( this . pin , 255 ) ; } ; this . turnOff = function ( ) { self . virtualWrite ( this . pin , 0 ) ; } ; } ; this . WidgetMAP = function ( vPin ) { this . pin = vPin ; this . location = function ( index , lat , lon , value ) { var locationdata = [ index , lat , lon , value ] self . virtualWrite ( this . pin , locationdata ) ; } } ; if ( needsEmitter ( ) ) { util . inherits ( this . VirtualPin , events . EventEmitter ) ; util . inherits ( this . WidgetBridge , events . EventEmitter ) ; util . inherits ( this . WidgetTerminal , events . EventEmitter ) ; } if ( ! options . skip_connect ) { this . connect ( ) ; } }<CODESPLIT>0.15290407836437225<CODESPLIT>0.1486017405986786

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/colinskow/superlogin/blob/8e7c7c1a77c1f5303b74f941208349e3a6e0c9ad/lib/dbauth/index.js#L261-L278<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getLegalDBName ( input ) { input = input . toLowerCase ( ) ; var output = encodeURIComponent ( input ) ; output = output . replace ( / \. / g , '%2E' ) ; output = output . replace ( / ! / g , '%21' ) ; output = output . replace ( / ~ / g , '%7E' ) ; output = output . replace ( / \* / g , '%2A' ) ; output = output . replace ( / ' / g , '%27' ) ; output = output . replace ( / \( / g , '%28' ) ; output = output . replace ( / \) / g , '%29' ) ; output = output . replace ( / \- / g , '%2D' ) ; output = output . toLowerCase ( ) ; output = output . replace ( / (%..) / g , function ( esc ) { esc = esc . substr ( 1 ) ; return '(' + esc + ')' ; } ) ; return output ; }<CODESPLIT>0.16290892660617828<CODESPLIT>0.12699314951896667

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/nearform/nscale-kernel/blob/5b9a544a6f2ffdc87294fee3fd00b81667ac0ab3/lib/api.js#L654-L679<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( user , identifier , comment , out , cb ) { logger . info ( 'commit system: ' + identifier ) ; var systemId = _sr . findSystem ( identifier ) ; _sr . commitRevision ( user , systemId , comment , function ( err , revisionId ) { _sr . getDeployedTargets ( systemId , function ( err , targets ) { if ( targets ) { async . eachSeries ( targets , function ( target , next ) { if ( target . commit === 'edits' ) { _sr . markDeployedRevision ( user , systemId , revisionId , target . env , function ( ) { next ( ) ; } ) ; } else { next ( ) ; } } , function ( ) { cb ( err , revisionId ) ; } ) ; } else { cb ( err , revisionId ) ; } } ) ; } ) ; }<CODESPLIT>0.10720396041870117<CODESPLIT>0.15412715077400208

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/daliwali/simulacra/blob/b6bb7e2486f7722101f9e416ec345d49f3afa901/lib/render.js#L123-L158<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function render ( obj , def , html ) { var i , nodes , handler , parser , element , elementPrototype // If given bindings with a root node, pick only the binding keys. if ( Array . isArray ( def ) ) def = def [ 1 ] // Generating the render function is processing intensive. Skip if possible. if ( renderFnKey in def ) return def [ renderFnKey ] ( obj ) // Callback API looks weird. This is actually synchronous, not asynchronous. handler = new htmlParser . DomHandler ( function ( error , result ) { if ( error ) throw error nodes = result } , handlerOptions ) parser = new htmlParser . Parser ( handler ) parser . write ( html ) parser . end ( ) for ( i = nodes . length ; i -- ; ) if ( nodes [ i ] . type === 'tag' ) { element = nodes [ i ] break } if ( ! element ) throw new Error ( 'No element found!' ) elementPrototype = Object . getPrototypeOf ( element ) Element . prototype = elementPrototype Object . defineProperties ( elementPrototype , elementExtension ) processDefinition ( def , nodes ) def [ renderFnKey ] = makeRender ( def , nodes ) return def [ renderFnKey ] ( obj ) }<CODESPLIT>0.16869540512561798<CODESPLIT>0.15256182849407196

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/core/EventManager.js#L105-L110<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( fn , scope , options ) { //<debug warn> Ext . Logger . deprecate ( "Ext.EventManager.onWindowResize is deprecated, attach listener to Ext.Viewport instead, i.e: Ext.Viewport.on('resize', ...)" , 2 ) ; //</debug> Ext . Viewport . on ( 'resize' , fn , scope , options ) ; }<CODESPLIT>0.13203312456607819<CODESPLIT>0.1596135050058365

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/jshttp/negotiator/blob/99f418e11907b60e63f0addc09fc596ddc7be5be/lib/charset.js#L53-L75<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function parseCharset ( str , i ) { var match = simpleCharsetRegExp . exec ( str ) ; if ( ! match ) return null ; var charset = match [ 1 ] ; var q = 1 ; if ( match [ 2 ] ) { var params = match [ 2 ] . split ( ';' ) for ( var j = 0 ; j < params . length ; j ++ ) { var p = params [ j ] . trim ( ) . split ( '=' ) ; if ( p [ 0 ] === 'q' ) { q = parseFloat ( p [ 1 ] ) ; break ; } } } return { charset : charset , q : q , i : i } ; }<CODESPLIT>0.11866743117570877<CODESPLIT>0.17349928617477417

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/steve-jansen/json-proxy/blob/b996609b627690774367d8d887f2e8baf102f6bf/spec/shared/setup.js#L29-L67<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function setup ( connection , done ) { var config = createDefaultConfig ( ) , options = { proxy : false , headers : { } } ; // reset the global variable with handles to port numbers handles = { } ; if ( connection !== 'direct' ) { options . proxy = true ; config . proxy . gateway = { protocol : 'http:' , host : 'localhost' , port : 0 , auth : 'proxyuser:C0mp13x_!d0rd$$@P!' } ; // optionally test a non-RFC proxy that expects explicit values // for the  Via and/or Host request headers if ( connection === 'non-rfc-proxy' ) { config . proxy . headers [ 'Via' ] = 'http://jedi.example.com' ; config . proxy . headers [ 'Host' ] = 'force.example.com' ; } // the config map will be mutated by the json-proxy library, so clone it options . headers = require ( 'util' ) . _extend ( config . proxy . headers ) ; configureLanProxy ( options , config , function ( ) { configureNock ( options , config ) ; configureExpress ( config , done ) ; } ) } else { configureNock ( options , config ) ; configureExpress ( config , done ) ; } }<CODESPLIT>0.16010360419750214<CODESPLIT>0.14370611310005188

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/HydraJS/HydraJS/blob/ef3ede4aebd29081fe960eb86a37a1a4bf571b2d/src/libs/Module.js#L550-L566<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function remove ( sModuleId ) { const oModules = getModules ( ) ; var oModule = oModules [ sModuleId ] ; if ( isTypeOf ( oModule , sNotDefined ) ) { return null ; } if ( ! isTypeOf ( oModule , sNotDefined ) ) { try { return Module ; } finally { _delete ( sModuleId ) ; createMapping ( getMappingMaps ( ) , 'hm_' , oModules ) ; } } return null ; }<CODESPLIT>0.17499254643917084<CODESPLIT>0.12430687248706818

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L11233-L11236<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function shouldExpand ( a , b , num , isNum , padding , opts ) { if ( isNum && ( a > 9 || b > 9 ) ) { return false ; } return ! padding && num === 1 && a < b ; }<CODESPLIT>0.1565641164779663<CODESPLIT>0.13569597899913788

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/benkeen/d3pie/blob/24b488a4f44226c407186c007365ab775f92a426/website/pages/generator/tabs/generate/tabGenerate.js#L57-L491<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( allSettings ) { var finalObj = { } ; // header title var headerTitleTextDiff = allSettings . header . title . text != defaultSettings . header . title . text ; var headerTitleColorDiff = allSettings . header . title . color != defaultSettings . header . title . color ; var headerTitleFontSizeDiff = allSettings . header . title . fontSize != defaultSettings . header . title . fontSize ; var headerTitleFontDiff = allSettings . header . title . font != defaultSettings . header . title . font ; if ( headerTitleTextDiff || headerTitleColorDiff || headerTitleFontSizeDiff || headerTitleFontDiff ) { finalObj . header = { title : { } } ; if ( headerTitleTextDiff ) { finalObj . header . title . text = allSettings . header . title . text ; } if ( headerTitleColorDiff ) { finalObj . header . title . color = allSettings . header . title . color ; } if ( headerTitleFontSizeDiff ) { finalObj . header . title . fontSize = parseInt ( allSettings . header . title . fontSize , 10 ) ; } if ( headerTitleFontDiff ) { finalObj . header . title . font = allSettings . header . title . font ; } } // header subtitle var headerSubtitleTextDiff = allSettings . header . subtitle . text != defaultSettings . header . subtitle . text ; var headerSubtitleColorDiff = allSettings . header . subtitle . color != defaultSettings . header . subtitle . color ; var headerSubtitleFontSizeDiff = allSettings . header . subtitle . fontSize != defaultSettings . header . subtitle . fontSize ; var headerSubtitleFontDiff = allSettings . header . subtitle . font != defaultSettings . header . subtitle . font ; if ( headerSubtitleTextDiff || headerSubtitleColorDiff || headerSubtitleFontSizeDiff || headerSubtitleFontDiff ) { if ( ! finalObj . hasOwnProperty ( "header" ) ) { finalObj . header = { } ; } finalObj . header . subtitle = { } ; if ( headerSubtitleTextDiff ) { finalObj . header . subtitle . text = allSettings . header . subtitle . text ; } if ( headerSubtitleColorDiff ) { finalObj . header . subtitle . color = allSettings . header . subtitle . color ; } if ( headerSubtitleFontSizeDiff ) { finalObj . header . subtitle . fontSize = parseInt ( allSettings . header . subtitle . fontSize , 10 ) ; } if ( headerSubtitleFontDiff ) { finalObj . header . subtitle . font = allSettings . header . subtitle . font ; } } if ( allSettings . header . location != defaultSettings . header . location ) { if ( ! finalObj . hasOwnProperty ( "header" ) ) { finalObj . header = { } ; } finalObj . header . location = allSettings . header . location ; } if ( allSettings . header . titleSubtitlePadding != defaultSettings . header . titleSubtitlePadding ) { if ( ! finalObj . hasOwnProperty ( "header" ) ) { finalObj . header = { } ; } finalObj . header . titleSubtitlePadding = parseInt ( allSettings . header . titleSubtitlePadding , 10 ) ; } // footer var footerTextDiff = allSettings . footer . text != defaultSettings . footer . text ; var footerColorDiff = allSettings . footer . color != defaultSettings . footer . color ; var footerFontSizeDiff = allSettings . footer . fontSize != defaultSettings . footer . fontSize ; var footerFontDiff = allSettings . footer . font != defaultSettings . footer . font ; var footerLocationDiff = allSettings . footer . font != defaultSettings . footer . location ; if ( footerTextDiff || footerColorDiff || footerFontSizeDiff || footerFontDiff ) { finalObj . footer = { } ; if ( footerTextDiff ) { finalObj . footer . text = allSettings . footer . text ; } if ( footerColorDiff ) { finalObj . footer . color = allSettings . footer . color ; } if ( footerFontSizeDiff ) { finalObj . footer . fontSize = parseInt ( allSettings . footer . fontSize , 10 ) ; } if ( footerFontDiff ) { finalObj . footer . font = allSettings . footer . font ; } if ( footerLocationDiff ) { finalObj . footer . location = allSettings . footer . location ; } } // size var canvasHeightDiff = allSettings . size . canvasHeight != defaultSettings . size . canvasHeight ; var canvasWidthDiff = allSettings . size . canvasWidth != defaultSettings . size . canvasWidth ; var pieInnerRadiusDiff = allSettings . size . pieInnerRadius != defaultSettings . size . pieInnerRadius ; var pieOuterRadiusDiff = allSettings . size . pieOuterRadius != defaultSettings . size . pieOuterRadius ; if ( canvasHeightDiff || canvasWidthDiff || pieInnerRadiusDiff || pieOuterRadiusDiff ) { finalObj . size = { } ; if ( canvasHeightDiff ) { finalObj . size . canvasHeight = parseFloat ( allSettings . size . canvasHeight , 10 ) ; } if ( canvasWidthDiff ) { finalObj . size . canvasWidth = parseFloat ( allSettings . size . canvasWidth , 10 ) ; } if ( pieInnerRadiusDiff ) { finalObj . size . pieInnerRadius = allSettings . size . pieInnerRadius ; } if ( pieOuterRadiusDiff ) { finalObj . size . pieOuterRadius = allSettings . size . pieOuterRadius ; } } // data finalObj . data = { } ; if ( allSettings . data . sortOrder != defaultSettings . data . sortOrder ) { finalObj . data . sortOrder = allSettings . data . sortOrder ; } var smallSegmentGroupingEnabledDiff = allSettings . data . smallSegmentGrouping . enabled != defaultSettings . data . smallSegmentGrouping . enabled ; if ( smallSegmentGroupingEnabledDiff ) { finalObj . data . smallSegmentGrouping = { } ; finalObj . data . smallSegmentGrouping . enabled = allSettings . data . smallSegmentGrouping . enabled ; var smallSegmentGroupingValDiff = allSettings . data . smallSegmentGrouping . value != defaultSettings . data . smallSegmentGrouping . value ; var smallSegmentGroupingValTypeDiff = allSettings . data . smallSegmentGrouping . valueType != defaultSettings . data . smallSegmentGrouping . valueType ; var smallSegmentGroupingLabelDiff = allSettings . data . smallSegmentGrouping . label != defaultSettings . data . smallSegmentGrouping . label ; var smallSegmentGroupingColorDiff = allSettings . data . smallSegmentGrouping . color != defaultSettings . data . smallSegmentGrouping . color ; if ( smallSegmentGroupingValDiff ) { finalObj . data . smallSegmentGrouping . value = allSettings . data . smallSegmentGrouping . value ; } if ( smallSegmentGroupingValTypeDiff ) { finalObj . data . smallSegmentGrouping . valueType = allSettings . data . smallSegmentGrouping . valueType ; } if ( smallSegmentGroupingLabelDiff ) { finalObj . data . smallSegmentGrouping . label = allSettings . data . smallSegmentGrouping . label ; } if ( smallSegmentGroupingColorDiff ) { finalObj . data . smallSegmentGrouping . color = allSettings . data . smallSegmentGrouping . color ; } } finalObj . data . content = allSettings . data . content ; // outer labels var outerLabelFormatDiff = allSettings . labels . outer . format != defaultSettings . labels . outer . format ; var outerLabelHideDiff = allSettings . labels . outer . hideWhenLessThanPercentage != defaultSettings . labels . outer . hideWhenLessThanPercentage ; var outerLabelPieDistDiff = allSettings . labels . outer . pieDistance != defaultSettings . labels . outer . pieDistance ; if ( outerLabelFormatDiff || outerLabelHideDiff || outerLabelPieDistDiff ) { finalObj . labels = { outer : { } } ; if ( outerLabelFormatDiff ) { finalObj . labels . outer . format = allSettings . labels . outer . format ; } if ( outerLabelHideDiff ) { finalObj . labels . outer . hideWhenLessThanPercentage = parseFloat ( allSettings . labels . outer . hideWhenLessThanPercentage ) ; } if ( outerLabelPieDistDiff ) { finalObj . labels . outer . pieDistance = allSettings . labels . outer . pieDistance ; } } var innerLabelFormatDiff = allSettings . labels . inner . format != defaultSettings . labels . inner . format ; var innerLabelHideDiff = allSettings . labels . inner . hideWhenLessThanPercentage != defaultSettings . labels . inner . hideWhenLessThanPercentage ; if ( innerLabelFormatDiff || innerLabelHideDiff ) { if ( ! finalObj . hasOwnProperty ( "labels" ) ) { finalObj . labels = { } ; } finalObj . labels . inner = { } ; if ( innerLabelFormatDiff ) { finalObj . labels . inner . format = allSettings . labels . inner . format ; } if ( innerLabelHideDiff ) { finalObj . labels . inner . hideWhenLessThanPercentage = parseFloat ( allSettings . labels . inner . hideWhenLessThanPercentage ) ; } } var mainLabelColorDiff = allSettings . labels . mainLabel . color != defaultSettings . labels . mainLabel . color ; var mainLabelFontDiff = allSettings . labels . mainLabel . font != defaultSettings . labels . mainLabel . font ; var mainLabelFontSizeDiff = allSettings . labels . mainLabel . fontSize != defaultSettings . labels . mainLabel . fontSize ; if ( mainLabelColorDiff || mainLabelFontDiff || mainLabelFontSizeDiff ) { if ( ! finalObj . hasOwnProperty ( "labels" ) ) { finalObj . labels = { } ; } finalObj . labels . mainLabel = { } ; if ( mainLabelColorDiff ) { finalObj . labels . mainLabel . color = allSettings . labels . mainLabel . color ; } if ( mainLabelFontDiff ) { finalObj . labels . mainLabel . font = allSettings . labels . mainLabel . font ; } if ( mainLabelFontSizeDiff ) { finalObj . labels . mainLabel . fontSize = parseInt ( allSettings . labels . mainLabel . fontSize , 10 ) ; } } var percentageColorDiff = allSettings . labels . percentage . color != defaultSettings . labels . percentage . color ; var percentageFontDiff = allSettings . labels . percentage . font != defaultSettings . labels . percentage . font ; var percentageFontSizeDiff = allSettings . labels . percentage . fontSize != defaultSettings . labels . percentage . fontSize ; var percentageDecimalDiff = allSettings . labels . percentage . decimalPlaces != defaultSettings . labels . percentage . decimalPlaces ; if ( percentageColorDiff || percentageFontDiff || percentageFontSizeDiff || percentageDecimalDiff ) { if ( ! finalObj . hasOwnProperty ( "labels" ) ) { finalObj . labels = { } ; } finalObj . labels . percentage = { } ; if ( percentageColorDiff ) { finalObj . labels . percentage . color = allSettings . labels . percentage . color ; } if ( percentageFontDiff ) { finalObj . labels . percentage . font = allSettings . labels . percentage . font ; } if ( percentageFontSizeDiff ) { finalObj . labels . percentage . fontSize = parseInt ( allSettings . labels . percentage . fontSize , 10 ) ; } if ( percentageColorDiff ) { finalObj . labels . percentage . decimalPlaces = parseInt ( allSettings . labels . percentage . decimalPlaces , 10 ) ; } } var valueColorDiff = allSettings . labels . value . color != defaultSettings . labels . value . color ; var valueFontDiff = allSettings . labels . value . font != defaultSettings . labels . value . font ; var valueFontSizeDiff = allSettings . labels . value . fontSize != defaultSettings . labels . value . fontSize ; if ( valueColorDiff || valueFontDiff || valueFontSizeDiff ) { if ( ! finalObj . hasOwnProperty ( "labels" ) ) { finalObj . labels = { } ; } finalObj . labels . value = { } ; if ( valueColorDiff ) { finalObj . labels . value . color = allSettings . labels . value . color ; } if ( valueFontDiff ) { finalObj . labels . value . font = allSettings . labels . value . font ; } if ( valueFontSizeDiff ) { finalObj . labels . value . fontSize = parseInt ( allSettings . labels . value . fontSize , 10 ) ; } } // label lines var labelLinesDiff = allSettings . labels . lines . enabled != defaultSettings . labels . lines . enabled ; if ( ! labelLinesDiff ) { if ( ! finalObj . hasOwnProperty ( "labels" ) ) { finalObj . labels = { } ; } finalObj . labels . lines = { enabled : allSettings . labels . lines . enabled } ; if ( allSettings . labels . lines . style != defaultSettings . labels . lines . style ) { finalObj . labels . lines . style = allSettings . labels . lines . style ; } if ( allSettings . labels . lines . color != defaultSettings . labels . lines . color ) { finalObj . labels . lines . color = allSettings . labels . lines . color ; } } // label truncation var labelTruncationDiff = allSettings . labels . truncation . enabled != defaultSettings . labels . truncation . enabled ; if ( labelTruncationDiff ) { if ( ! finalObj . hasOwnProperty ( "labels" ) ) { finalObj . labels = { } ; } finalObj . labels . truncation = { enabled : allSettings . labels . truncation . enabled } ; if ( allSettings . labels . truncation . truncateLength != defaultSettings . labels . truncation . truncateLength ) { finalObj . labels . truncation . truncateLength = allSettings . labels . truncation . truncateLength ; } } // tooltips var tooltipsDiff = allSettings . tooltips . enabled != defaultSettings . tooltips . enabled ; if ( tooltipsDiff ) { finalObj . tooltips = { enabled : allSettings . tooltips . enabled , type : "placeholder" , string : allSettings . tooltips . string } ; if ( allSettings . tooltips . styles . fadeInSpeed !== defaultSettings . tooltips . styles . fadeInSpeed ) { if ( ! finalObj . tooltips . hasOwnProperty ( "styles" ) ) { finalObj . tooltips . styles = { } ; } finalObj . tooltips . styles . fadeInSpeed = allSettings . tooltips . styles . fadeInSpeed ; } if ( allSettings . tooltips . styles . backgroundColor !== defaultSettings . tooltips . styles . backgroundColor ) { if ( ! finalObj . tooltips . hasOwnProperty ( "styles" ) ) { finalObj . tooltips . styles = { } ; } finalObj . tooltips . styles . backgroundColor = allSettings . tooltips . styles . backgroundColor ; } if ( allSettings . tooltips . styles . backgroundOpacity !== defaultSettings . tooltips . styles . backgroundOpacity ) { if ( ! finalObj . tooltips . hasOwnProperty ( "styles" ) ) { finalObj . tooltips . styles = { } ; } finalObj . tooltips . styles . backgroundOpacity = allSettings . tooltips . styles . backgroundOpacity ; } if ( allSettings . tooltips . styles . color !== defaultSettings . tooltips . styles . color ) { if ( ! finalObj . tooltips . hasOwnProperty ( "styles" ) ) { finalObj . tooltips . styles = { } ; } finalObj . tooltips . styles . color = allSettings . tooltips . styles . color ; } if ( allSettings . tooltips . styles . borderRadius !== defaultSettings . tooltips . styles . borderRadius ) { if ( ! finalObj . tooltips . hasOwnProperty ( "styles" ) ) { finalObj . tooltips . styles = { } ; } finalObj . tooltips . styles . borderRadius = allSettings . tooltips . styles . borderRadius ; } if ( allSettings . tooltips . styles . font !== defaultSettings . tooltips . styles . font ) { if ( ! finalObj . tooltips . hasOwnProperty ( "styles" ) ) { finalObj . tooltips . styles = { } ; } finalObj . tooltips . styles . font = allSettings . tooltips . styles . font ; } if ( allSettings . tooltips . styles . fontSize !== defaultSettings . tooltips . styles . fontSize ) { if ( ! finalObj . tooltips . hasOwnProperty ( "styles" ) ) { finalObj . tooltips . styles = { } ; } finalObj . tooltips . styles . fontSize = allSettings . tooltips . styles . fontSize ; } if ( allSettings . tooltips . styles . padding !== defaultSettings . tooltips . styles . padding ) { if ( ! finalObj . tooltips . hasOwnProperty ( "styles" ) ) { finalObj . tooltips . styles = { } ; } finalObj . tooltips . styles . padding = allSettings . tooltips . styles . padding ; } } // effects var effectsLoadDiff = allSettings . effects . load . effect != defaultSettings . effects . load . effect ; var effectsSpeedDiff = allSettings . effects . load . speed != defaultSettings . effects . load . speed ; if ( effectsLoadDiff || effectsSpeedDiff ) { if ( ! finalObj . hasOwnProperty ( "effects" ) ) { finalObj . effects = { } ; } finalObj . effects . load = { } ; if ( effectsLoadDiff ) { finalObj . effects . load . effect = allSettings . effects . load . effect ; } if ( effectsSpeedDiff ) { finalObj . effects . load . speed = parseInt ( allSettings . effects . load . speed , 10 ) ; } } var effectsPullOutDiff = allSettings . effects . pullOutSegmentOnClick . effect != defaultSettings . effects . pullOutSegmentOnClick . effect ; var effectsPullOutSpeedDiff = allSettings . effects . pullOutSegmentOnClick . speed != defaultSettings . effects . pullOutSegmentOnClick . speed ; var effectsPullOutSizeDiff = allSettings . effects . pullOutSegmentOnClick . size != defaultSettings . effects . pullOutSegmentOnClick . size ; if ( effectsPullOutDiff || effectsPullOutSpeedDiff || effectsPullOutSizeDiff ) { if ( ! finalObj . hasOwnProperty ( "effects" ) ) { finalObj . effects = { } ; } finalObj . effects . pullOutSegmentOnClick = { } ; if ( effectsPullOutDiff ) { finalObj . effects . pullOutSegmentOnClick . effect = allSettings . effects . pullOutSegmentOnClick . effect ; } if ( effectsPullOutSpeedDiff ) { finalObj . effects . pullOutSegmentOnClick . speed = parseInt ( allSettings . effects . pullOutSegmentOnClick . speed , 10 ) ; } if ( effectsPullOutSizeDiff ) { finalObj . effects . pullOutSegmentOnClick . size = parseInt ( allSettings . effects . pullOutSegmentOnClick . size , 10 ) ; } } if ( allSettings . effects . highlightSegmentOnMouseover != defaultSettings . effects . highlightSegmentOnMouseover ) { if ( ! finalObj . hasOwnProperty ( "effects" ) ) { finalObj . effects = { } ; } finalObj . effects . highlightSegmentOnMouseover = allSettings . effects . highlightSegmentOnMouseover ; if ( allSettings . effects . highlightLuminosity != defaultSettings . effects . highlightLuminosity ) { finalObj . effects . highlightLuminosity = parseFloat ( allSettings . effects . highlightLuminosity , 10 ) ; } } // misc var miscColorBgDiff = allSettings . misc . colors . background != defaultSettings . misc . colors . background ; // N.B. It's not possible in the generator to generate the misc.colors.segments property. This is missing on purpose. var miscSegmentStrokeDiff = allSettings . misc . colors . segmentStroke != defaultSettings . misc . colors . segmentStroke ; if ( miscColorBgDiff || miscSegmentStrokeDiff ) { if ( ! finalObj . hasOwnProperty ( "misc" ) ) { finalObj . misc = { } ; } finalObj . misc . colors = { } ; if ( miscColorBgDiff ) { finalObj . misc . colors . background = allSettings . misc . colors . background ; } if ( miscSegmentStrokeDiff ) { finalObj . misc . colors . segmentStroke = allSettings . misc . colors . segmentStroke ; } } var gradientEnabledDiff = allSettings . misc . gradient . enabled != defaultSettings . misc . gradient . enabled ; if ( gradientEnabledDiff ) { if ( ! finalObj . hasOwnProperty ( "misc" ) ) { finalObj . misc = { } ; } finalObj . misc . gradient = { enabled : true } ; var gradientPercentageDiff = allSettings . misc . gradient . percentage != defaultSettings . misc . gradient . percentage ; var gradientColorDiff = allSettings . misc . gradient . color != defaultSettings . misc . gradient . color ; if ( gradientPercentageDiff ) { finalObj . misc . gradient . percentage = parseInt ( allSettings . misc . gradient . percentage , 10 ) ; } if ( gradientColorDiff ) { finalObj . misc . gradient . color = allSettings . misc . gradient . color ; } } var canvasPaddingTopDiff = allSettings . misc . canvasPadding . top != defaultSettings . misc . canvasPadding . top ; var canvasPaddingRightDiff = allSettings . misc . canvasPadding . right != defaultSettings . misc . canvasPadding . right ; var canvasPaddingBottomDiff = allSettings . misc . canvasPadding . bottom != defaultSettings . misc . canvasPadding . bottom ; var canvasPaddingLeftDiff = allSettings . misc . canvasPadding . left != defaultSettings . misc . canvasPadding . left ; if ( canvasPaddingTopDiff || canvasPaddingRightDiff || canvasPaddingBottomDiff || canvasPaddingLeftDiff ) { if ( ! finalObj . hasOwnProperty ( "misc" ) ) { finalObj . misc = { } ; } finalObj . misc . canvasPadding = { } ; if ( canvasPaddingTopDiff ) { finalObj . misc . canvasPadding . top = parseInt ( allSettings . misc . canvasPadding . top , 10 ) ; } if ( canvasPaddingRightDiff ) { finalObj . misc . canvasPadding . right = parseInt ( allSettings . misc . canvasPadding . right , 10 ) ; } if ( canvasPaddingBottomDiff ) { finalObj . misc . canvasPadding . bottom = parseInt ( allSettings . misc . canvasPadding . bottom , 10 ) ; } if ( canvasPaddingTopDiff ) { finalObj . misc . canvasPadding . left = parseInt ( allSettings . misc . canvasPadding . left , 10 ) ; } } var pieCenterOffsetXDiff = allSettings . misc . pieCenterOffset . x != defaultSettings . misc . pieCenterOffset . x ; var pieCenterOffsetYDiff = allSettings . misc . pieCenterOffset . y != defaultSettings . misc . pieCenterOffset . y ; if ( pieCenterOffsetXDiff || pieCenterOffsetYDiff ) { if ( ! finalObj . hasOwnProperty ( "misc" ) ) { finalObj . misc = { } ; } finalObj . misc . pieCenterOffset = { } ; if ( pieCenterOffsetXDiff ) { finalObj . misc . pieCenterOffset . x = parseInt ( allSettings . misc . pieCenterOffset . x , 10 ) ; } if ( pieCenterOffsetYDiff ) { finalObj . misc . pieCenterOffset . y = parseInt ( allSettings . misc . pieCenterOffset . y , 10 ) ; } } var miscPrefixDiff = allSettings . misc . cssPrefix != defaultSettings . misc . cssPrefix ; if ( miscPrefixDiff ) { if ( ! finalObj . hasOwnProperty ( "misc" ) ) { finalObj . misc = { } ; } finalObj . misc . cssPrefix = allSettings . misc . cssPrefix ; } var callbackOnloadDiff = allSettings . callbacks . onload != defaultSettings . callbacks . onload ; var callbackOnmouseoverDiff = allSettings . callbacks . onMouseoverSegment != defaultSettings . callbacks . onMouseoverSegment ; var callbackOnmouseoutDiff = allSettings . callbacks . onMouseoutSegment != defaultSettings . callbacks . onMouseoutSegment ; var callbackOnclickDiff = allSettings . callbacks . onClickSegment != defaultSettings . callbacks . onClickSegment ; if ( callbackOnloadDiff || callbackOnmouseoverDiff || callbackOnmouseoutDiff || callbackOnclickDiff ) { finalObj . callbacks = { } ; if ( callbackOnloadDiff ) { finalObj . callbacks . onload = allSettings . callbacks . onload ; } if ( callbackOnloadDiff ) { finalObj . callbacks . onMouseoverSegment = allSettings . callbacks . onMouseoverSegment ; } if ( callbackOnloadDiff ) { finalObj . callbacks . onMouseoutSegment = allSettings . callbacks . onMouseoutSegment ; } if ( callbackOnloadDiff ) { finalObj . callbacks . onClickSegment = allSettings . callbacks . onClickSegment ; } } return finalObj ; }<CODESPLIT>0.1435340940952301<CODESPLIT>0.14405329525470734

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L9386-L9395<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( store , type , record ) { var data = { } ; var serializer = store . serializerFor ( type . typeKey ) ; serializer . serializeIntoHash ( data , type , record ) ; var id = get ( record , 'id' ) ; return this . ajax ( this . buildURL ( type . typeKey , id ) , "PUT" , { data : data } ) ; }<CODESPLIT>0.1717635542154312<CODESPLIT>0.14729560911655426

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/SOHU-Co/kafka-node/blob/707348d9a9881782f3a390fdcc6362d35cfe24c0/lib/baseProducer.js#L55-L77<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function BaseProducer ( client , options , defaultPartitionerType , customPartitioner ) { EventEmitter . call ( this ) ; options = options || { } ; this . ready = false ; this . client = client ; this . requireAcks = options . requireAcks === undefined ? DEFAULTS . requireAcks : options . requireAcks ; this . ackTimeoutMs = options . ackTimeoutMs === undefined ? DEFAULTS . ackTimeoutMs : options . ackTimeoutMs ; if ( customPartitioner !== undefined && options . partitionerType !== PARTITIONER_TYPES . custom ) { throw new Error ( 'Partitioner Type must be custom if providing a customPartitioner.' ) ; } else if ( customPartitioner === undefined && options . partitionerType === PARTITIONER_TYPES . custom ) { throw new Error ( 'No customer partitioner defined' ) ; } var partitionerType = PARTITIONER_MAP [ options . partitionerType ] || PARTITIONER_MAP [ defaultPartitionerType ] ; // eslint-disable-next-line this . partitioner = new partitionerType ( customPartitioner ) ; this . connect ( ) ; }<CODESPLIT>0.16357557475566864<CODESPLIT>0.12184708565473557

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/azproduction/lmd/blob/03410c36839728de683c697670e1b205dc8193ee/bin/lmd_builder.js#L494-L537<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function brakeSandboxes ( ast ) { var map = getSandboxMap ( ast ) , isSandboxVariableWiped = false ; return walker . with_walkers ( { // lookup for modules // looking for this pattern // [ 'call', //  [ 'function', null, [ 'sb' ], [ [Object] ] ], //  [ [ 'name', 'sandbox' ] ] ] "call" : function ( content ) { if ( this [ 2 ] && this [ 2 ] . length > 0 && this [ 2 ] [ 0 ] [ 0 ] === "name" && this [ 2 ] [ 0 ] [ 1 ] === "sandbox" && this [ 1 ] && this [ 1 ] [ 0 ] === "function" ) { // 1. remove sandbox argument this [ 2 ] = [ ] ; // 2. break sandbox in each module return breakSandbox ( this , map ) ; } } , // wipe sandobx variable "var" : function ( ) { if ( isSandboxVariableWiped ) { return ; } for ( var i = 0 , c = this [ 1 ] . length , varItem ; i < c ; i ++ ) { varItem = this [ 1 ] [ i ] ; if ( varItem [ 0 ] === 'sandbox' ) { isSandboxVariableWiped = true ; this [ 1 ] . splice ( i , 1 ) ; return this ; } } } } , function ( ) { return walker . walk ( ast ) ; } ) ; }<CODESPLIT>0.16918335855007172<CODESPLIT>0.14977684617042542

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/trekjs/route-mapper/blob/d6cabfb5b75c1301cfd5da8ab984ac870653b448/src/utils.js#L59-L78<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function parseArgs ( ... args ) { const l = args . length const last = args [ l - 1 ] let cb , opts , paths if ( _ . isFunction ( last ) ) { cb = last args . pop ( ) ; // don't remove this semicolon [ paths , opts ] = parseArgs ( ... args ) } else if ( _ . isObject ( last ) && ! Array . isArray ( last ) ) { opts = last args . pop ( ) paths = args } else if ( ! last && l > 0 ) { args . pop ( ) return parseArgs ( ... args ) } else { paths = args } return [ _ . compact ( _ . flatten ( paths , true ) ) , opts || { } , cb ] }<CODESPLIT>0.1755361109972<CODESPLIT>0.11573261767625809

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/azproduction/lmd/blob/03410c36839728de683c697670e1b205dc8193ee/lib/lmd_common.js#L382-L391<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( config , configDir ) { config = config || { } ; if ( typeof config . extends !== "string" ) { return config ; } var parentConfig = tryExtend ( readConfig ( configDir , config . extends ) , configDir ) ; return deepDestructableMerge ( parentConfig , config ) ; }<CODESPLIT>0.15529310703277588<CODESPLIT>0.13671866059303284

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/Quartz/Chartbuilder/blob/fc6ce64e73b9ef378223afcab7057020f6dce260/src/js/stores/SessionStore.js#L89-L106<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function detectNumberSeparators ( ) { var n = 1000.50 ; var l = n . toLocaleString ( ) ; var s = n . toString ( ) ; var o = { decimal : l . substring ( 5 , 6 ) , thousands : l . substring ( 1 , 2 ) } ; if ( l . substring ( 5 , 6 ) == s . substring ( 5 , 6 ) ) { o . decimal = "." ; } if ( l . substring ( 1 , 2 ) == s . substring ( 1 , 2 ) ) { o . thousands = "," ; } return o ; }<CODESPLIT>0.15915460884571075<CODESPLIT>0.11502449959516525

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/spec/helpers/various-utils.js#L86-L96<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function attributesHashToString ( attributesHash , options ) { var reduce = options && options . reverse ? _ . reduceRight : _ . reduce , separator = options && options . multiline ? "\n" : " " , spacing = options && options . extrSpace || "" , defaultQuote = options && options . preferSingleQuotes ? "'" : '"' ; return reduce ( attributesHash , function ( attrString , value , key ) { var quote = value . indexOf ( '"' ) !== - 1 ? "'" : value . indexOf ( "'" ) !== - 1 ? '"' : defaultQuote ; return attrString + key + spacing + "=" + spacing + quote + value + quote + separator ; } , "" ) ; }<CODESPLIT>0.1569063812494278<CODESPLIT>0.1381085216999054

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/apache/cordova-lib/blob/dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5/src/cordova/serve.js#L98-L111<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function absolutePathHandler ( request , response , next ) { if ( ! request . headers . referer ) return next ( ) ; // @todo Use 'url.URL' constructor instead since 'url.parse' was deprecated since v11.0.0 const { pathname } = url . parse ( request . headers . referer ) ; // eslint-disable-line const platform = pathname . split ( '/' ) [ 1 ] ; if ( installedPlatforms . includes ( platform ) && ! request . originalUrl . includes ( platform ) ) { response . redirect ( ` ${ platform } ` + request . originalUrl ) ; } else { next ( ) ; } }<CODESPLIT>0.16968201100826263<CODESPLIT>0.13024376332759857

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L14167-L14174<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function resolveESModuleSymbol ( moduleSymbol , moduleReferenceExpression ) { var symbol = resolveExternalModuleSymbol ( moduleSymbol ) ; if ( symbol && ! ( symbol . flags & ( 1536 /* Module */ | 3 /* Variable */ ) ) ) { error ( moduleReferenceExpression , ts . Diagnostics . Module_0_resolves_to_a_non_module_entity_and_cannot_be_imported_using_this_construct , symbolToString ( moduleSymbol ) ) ; symbol = undefined ; } return symbol ; }<CODESPLIT>0.17090775072574615<CODESPLIT>0.13788703083992004

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L4087-L4102<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function scanJsxIdentifier ( ) { if ( tokenIsIdentifierOrKeyword ( token ) ) { var firstCharPosition = pos ; while ( pos < end ) { var ch = text . charCodeAt ( pos ) ; if ( ch === 45 /* minus */ || ( ( firstCharPosition === pos ) ? isIdentifierStart ( ch , languageVersion ) : isIdentifierPart ( ch , languageVersion ) ) ) { pos ++ ; } else { break ; } } tokenValue += text . substr ( firstCharPosition , pos - firstCharPosition ) ; } return token ; }<CODESPLIT>0.17588895559310913<CODESPLIT>0.12596477568149567

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/apache/cordova-lib/blob/dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5/src/cordova/util.js#L190-L200<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function fixRelativePath ( value , /* optional */ cwd ) { // Don't touch absolute paths. if ( value [ 1 ] === ':' || value [ 0 ] === path . sep ) { return value ; } var newDir = cwd || process . env . PWD || process . cwd ( ) ; var origDir = getOrigWorkingDirectory ( ) ; var pathDiff = path . relative ( newDir , origDir ) ; var ret = path . normalize ( path . join ( pathDiff , value ) ) ; return ret ; }<CODESPLIT>0.1922132819890976<CODESPLIT>0.1408366709947586

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/lobsangnet/lobsang.js/blob/1d50d976ded68b719d77487952e3fe6ec13d0891/packages/lobsang-formatter-matrix/lib/lobsang-formatter-matrix.js#L40-L50<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function lobsangFormatterMatrix ( message ) { if ( typeof message !== 'string' ) { return Promise . reject ( new Error ( 'Message is not a string' ) ) } const formattedMessage = { body : message , msgtype : CONSTANTS . MATRIX_NOTICE_TYPE } return Promise . resolve ( formattedMessage ) }<CODESPLIT>0.16001495718955994<CODESPLIT>0.144216388463974

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/andrao/node-analytics/blob/170bca2d2985cc384aa584b0e588221a96630834/node-analytics.js#L466-L477<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function userSession ( ) { // OLD USER, NEW SESSION cb ( null , req , res , new Session ( { user : cookies . na_user , new_session : true } ) . toObject ( { virtuals : true } ) ) ; if ( opts . log_all ) log . timer ( 'getSession 1' , now ) ; }<CODESPLIT>0.11261337250471115<CODESPLIT>0.17071373760700226

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/jorgecuesta/mongoose-multitenancy/blob/2c3ed0276a59455a0bf0587155b9a303dc53dc6d/src/discriminator.js#L179-L183<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( model , schema ) { for ( var i in schema . statics ) { model [ i ] = schema . statics [ i ] ; } }<CODESPLIT>0.17529328167438507<CODESPLIT>0.17273034155368805

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/sorellabs/iris/blob/1bc545d99e8235b10238d62dea717b631f24c6d4/src/http.js#L300-L302<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function setup_headers ( headers ) { keys ( headers ) . forEach ( function ( key ) { client . setRequestHeader ( key , headers [ key ] ) } ) }<CODESPLIT>0.1620064675807953<CODESPLIT>0.13651379942893982

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/encharm/xcase/blob/8af0a2edd440639cb2385d2bfabb3f3ab2db9148/benchmark.js#L29-L35<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function onCycle ( event ) { if ( objectPool . length == 0 ) { throw new Error ( 'Pool ran out of objects' ) ; } console . log ( String ( event . target ) ) ; initPool ( ) ; }<CODESPLIT>0.153010755777359<CODESPLIT>0.1416855752468109

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/Wiredcraft/file-register/blob/6393edebdcd7074eba41fc2838988772da7b1766/lib/proto.js#L16-L20<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function subRegister ( obj , name ) { var res ; res = isPrimitive ( obj [ name ] ) ? { } : obj [ name ] ; return obj [ name ] = mixable ( res ) . mixin ( proto , 'register' , 'extend' ) ; }<CODESPLIT>0.17264054715633392<CODESPLIT>0.13869412243366241

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/kasperisager/bundstreg/blob/75b16e7587ecba7f565bf5a7cab4aba911ef21f5/lib/array/sort.js#L46-L72<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function quickSort ( a , l , h , k , c ) { const s = [ ] ; let t = 0 ; s [ t ++ ] = l ; s [ t ++ ] = h ; while ( t > 0 ) { h = s [ -- t ] ; l = s [ -- t ] ; if ( h - l > k ) { const p = partition ( a , l , h , c ) ; if ( p > l ) { s [ t ++ ] = l ; s [ t ++ ] = p ; } if ( p + 1 < h ) { s [ t ++ ] = p + 1 ; s [ t ++ ] = h ; } } } }<CODESPLIT>0.1526614874601364<CODESPLIT>0.12308891862630844

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/GeoSensorWebLab/polarmap.js/blob/fa1e87d0082f5d6ae0981b0c5dd80ed18e7f611b/js/leaflet.markercluster.js#L839-L844<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( fn ) { this . _queue . push ( fn ) ; if ( ! this . _queueTimeout ) { this . _queueTimeout = setTimeout ( L . bind ( this . _processQueue , this ) , 300 ) ; } }<CODESPLIT>0.150258406996727<CODESPLIT>0.12387197464704514

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/data/NodeStore.js#L223-L259<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( root ) { var node = this . getNode ( ) , recursive = this . getRecursive ( ) , added = [ ] , child = root ; if ( ! root . childNodes . length || ( ! recursive && root !== node ) ) { return added ; } if ( ! recursive ) { return root . childNodes ; } while ( child ) { if ( child . _added ) { delete child . _added ; if ( child === root ) { break ; } else { child = child . nextSibling || child . parentNode ; } } else { if ( child !== root ) { added . push ( child ) ; } if ( child . firstChild ) { child . _added = true ; child = child . firstChild ; } else { child = child . nextSibling || child . parentNode ; } } } return added ; }<CODESPLIT>0.1404426395893097<CODESPLIT>0.14900854229927063

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/retextjs/retext-sentiment/blob/c16297b152426091c21a34210d7026e2934fe22a/index.js#L47-L74<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function one ( node ) { var children = node . children var length = children . length var polarity = 0 var index = - 1 var child var hasNegation while ( ++ index < length ) { child = children [ index ] if ( child . data && child . data . polarity ) { polarity += ( hasNegation ? - 1 : 1 ) * child . data . polarity } // If the value is a word, remove any present negation.  Otherwise, add // negation if the node contains it. if ( child . type === 'WordNode' ) { if ( hasNegation ) { hasNegation = false } else if ( isNegation ( child ) ) { hasNegation = true } } } patch ( node , polarity ) }<CODESPLIT>0.1632467657327652<CODESPLIT>0.136592835187912

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L22183-L22208<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( addedEvents , rootElement ) { var event , events = get ( this , 'events' ) ; Ember . $ . extend ( events , addedEvents || { } ) ; if ( ! Ember . isNone ( rootElement ) ) { set ( this , 'rootElement' , rootElement ) ; } rootElement = Ember . $ ( get ( this , 'rootElement' ) ) ; Ember . assert ( fmt ( 'You cannot use the same root element (%@) multiple times in an Ember.Application' , [ rootElement . selector || rootElement [ 0 ] . tagName ] ) , ! rootElement . is ( '.ember-application' ) ) ; Ember . assert ( 'You cannot make a new Ember.Application using a root element that is a descendent of an existing Ember.Application' , ! rootElement . closest ( '.ember-application' ) . length ) ; Ember . assert ( 'You cannot make a new Ember.Application using a root element that is an ancestor of an existing Ember.Application' , ! rootElement . find ( '.ember-application' ) . length ) ; rootElement . addClass ( 'ember-application' ) ; Ember . assert ( 'Unable to add "ember-application" class to rootElement. Make sure you set rootElement to the body or an element in the body.' , rootElement . is ( '.ember-application' ) ) ; for ( event in events ) { if ( events . hasOwnProperty ( event ) ) { this . setupHandler ( rootElement , event , events [ event ] ) ; } } }<CODESPLIT>0.15140458941459656<CODESPLIT>0.1391267329454422

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/GraFiddle/angular-chart/blob/76620974f0547b5a9c86d2860b6b401af8aee5fc/src/js/state.js#L24-L30<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function applyZoom ( options , chart ) { if ( angular . isObject ( options . state ) && angular . isObject ( options . state ) && angular . isArray ( options . state . range ) ) { chart . zoom ( options . state . range ) ; } else { chart . unzoom ( ) ; } }<CODESPLIT>0.16758567094802856<CODESPLIT>0.13810774683952332

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/mhemmings/obfuscemail/blob/9bcadb2ce85d5715f68b2c5e06109840b2fc2830/src/index.js#L48-L53<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function rot13 ( str ) { return str . replace ( / [a-zA-Z] / g , function ( c ) { return String . fromCharCode ( ( c <= 'Z' ? 90 : 122 ) >= ( c = c . charCodeAt ( 0 ) + 13 ) ? c : c - 26 ) ; } ) ; }<CODESPLIT>0.11482076346874237<CODESPLIT>0.14344917237758636

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/davidfig/pixi-viewport/blob/b769a1eb8f7d7ec0295d74f7d7714848b92efebb/dist/snap.js#L37-L56<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function Snap ( parent , x , y , options ) { _classCallCheck ( this , Snap ) ; var _this = _possibleConstructorReturn ( this , ( Snap . __proto__ || Object . getPrototypeOf ( Snap ) ) . call ( this , parent ) ) ; options = options || { } ; _this . friction = options . friction || 0.8 ; _this . time = options . time || 1000 ; _this . ease = utils . ease ( options . ease , 'easeInOutSine' ) ; _this . x = x ; _this . y = y ; _this . topLeft = options . topLeft ; _this . interrupt = utils . defaults ( options . interrupt , true ) ; _this . removeOnComplete = options . removeOnComplete ; _this . removeOnInterrupt = options . removeOnInterrupt ; if ( options . forceStart ) { _this . startEase ( ) ; } return _this ; }<CODESPLIT>0.16396363079547882<CODESPLIT>0.12407257407903671

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/JAAulde/cookies/blob/63e74a48a7245cd88202f825c01bfe69fc5e4559/lib/jaaulde-cookies.js#L64-L112<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( o ) { var r , e ; if ( typeof o !== 'object' || o === null ) { r = default_options ; } else { r = { expires : default_options . expires , path : default_options . path , domain : default_options . domain , secure : default_options . secure } ; /*                      * I've been very finicky about the name and format of the expiration option over time,                      * so I'm accounting for older styles to maintain backwards compatibility. Preferably it                      * will be called "expires" and will be an instance of Date                      */ if ( typeof o . expires === 'object' && o . expires instanceof Date ) { r . expires = o . expires ; } else if ( typeof o . expires_at === 'object' && o . expires_at instanceof Date ) { r . expires = o . expires_at ; warn ( 'Cookie option "expires_at" has been deprecated. Rename to "expires". Support for "expires_at" will be removed in a version to come.' ) ; } else if ( typeof o . expiresAt === 'object' && o . expiresAt instanceof Date ) { r . expires = o . expiresAt ; warn ( 'Cookie option "expiresAt" has been deprecated. Rename to "expires". Support for "expiresAt" will be removed in a version to come.' ) ; } else if ( typeof o . hoursToLive === 'number' && o . hoursToLive !== 0 ) { e = new Date ( ) ; e . setTime ( e . getTime ( ) + ( o . hoursToLive * 60 * 60 * 1000 ) ) ; r . expires = e ; warn ( 'Cookie option "hoursToLive" has been deprecated. Rename to "expires" and prodvide a Date instance (see documentation). Support for "hoursToLive" will be removed in a version to come.' ) ; } if ( typeof o . path === 'string' && o . path !== '' ) { r . path = o . path ; } if ( typeof o . domain === 'string' && o . domain !== '' ) { r . domain = o . domain ; } if ( o . secure === true ) { r . secure = o . secure ; } } return r ; }<CODESPLIT>0.14423494040966034<CODESPLIT>0.14961999654769897

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/collections/Form/FormRadio.js#L12-L18<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function FormRadio ( props ) { const { control } = props const rest = getUnhandledProps ( FormRadio , props ) const ElementType = getElementType ( FormRadio , props ) return < ElementType { ... rest } control = { control } / > }<CODESPLIT>0.11369015276432037<CODESPLIT>0.14729084074497223

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/monarkee/postcss-beard-spacing/blob/0679a00ea08e775e7c4a2a59f06c9749164a1c8e/index.js#L71-L90<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( breakpoints , spacingScale ) { return _ . map ( breakpoints , function ( breakpointValue , breakpointKey ) { let mediaQuery = postcss . atRule ( { name : 'media' , params : breakpointValue , } ) let rules = _ . flatMap ( spacingScale , function ( scaleValue , scaleKey ) { return _ . map ( helpers , function ( helperValues , helperKey ) { return makeFunctionalRule ( ` ${ breakpointKey } ${ helperKey } ${ scaleKey } ` , helperValues , scaleValue ) } ) } ) return mediaQuery . append ( rules ) } ) }<CODESPLIT>0.12198397517204285<CODESPLIT>0.12835974991321564

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/zhouyuexie/react-native-navigator-animation/blob/c46426f12420c008f2931c75b1858045a2026f6b/Animation.js#L655-L681<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function CustomAnimation ( init ) { let buildStyleInterpolator = init ; return ( LeftRightIn , UpDowmOut , Gestures , Base = { springFriction : 26 , springTension : 200 , defaultTransitionVelocity : 1.5 } ) => { return Object . assign ( { } , NavigatorSceneConfigs . FadeAndroid , { animationInterpolators : { into : buildStyleInterpolator ( { ... CheckParams ( LeftRightIn ) } ) , out : buildStyleInterpolator ( { ... CheckParams ( UpDowmOut ) } ) } , gestures : Gestures ? Gestures : { pop : { ... BaseLeftToRightGesture , direction : "left-to-right" , fullDistance : Width } } , ... Base // springFriction:Base.springFriction, // springTension:Base.springTension, // defaultTransitionVelocity:Base.defaultTransitionVelocity, } ) } }<CODESPLIT>0.13501481711864471<CODESPLIT>0.14594875276088715

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/GitbookIO/repofs/blob/24f9880f3abb5aae4e4be56d0e88ba9d214447be/src/utils/branches.js#L97-L102<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function remove ( repoState , driver , branch ) { return driver . deleteBranch ( branch ) . then ( ( ) => { return repoState . updateBranch ( branch , null ) ; } ) ; }<CODESPLIT>0.1483701914548874<CODESPLIT>0.1413927525281906

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L37281-L37288<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function parseConfigFileTextToJson ( fileName , jsonText ) { try { return { config : / \S / . test ( jsonText ) ? JSON . parse ( jsonText ) : { } } ; } catch ( e ) { return { error : ts . createCompilerDiagnostic ( ts . Diagnostics . Failed_to_parse_file_0_Colon_1 , fileName , e . message ) } ; } }<CODESPLIT>0.16251018643379211<CODESPLIT>0.1447708159685135

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/intelligo-systems/intelligo.js/blob/9e75d48214fb41d346462f5d886bd92cc9956df6/dist/multilabel/BinaryRelevance.js#L14-L22<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( opts ) { if ( ! opts . binaryClassifierType ) { console . dir ( opts ) ; throw new Error ( "opts.binaryClassifierType not found" ) ; } this . binaryClassifierType = opts . binaryClassifierType ; this . debug = opts . debug || false this . mapClassnameToClassifier = { } ; }<CODESPLIT>0.12536418437957764<CODESPLIT>0.16181647777557373

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/ifrost/protoplast/blob/6ff349404c38a92f8715ab746953adf2dc8d8df6/js/utils/common.js#L45-L52<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function merge ( destination , source ) { for ( var property in source ) { if ( source . hasOwnProperty ( property ) ) { mergeProperty ( destination , source , property ) ; } } return destination ; }<CODESPLIT>0.16177161037921906<CODESPLIT>0.13505522906780243

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/navigation/Bar.js#L567-L583<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( hidden ) { if ( ! hidden ) { this . element . setStyle ( { position : 'relative' , top : 'auto' , left : 'auto' , width : 'auto' } ) ; } else { this . element . setStyle ( { position : 'absolute' , top : '-1000px' , left : '-1000px' , width : this . element . getWidth ( ) + 'px' } ) ; } }<CODESPLIT>0.1492553949356079<CODESPLIT>0.14169941842556

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/es-analysis/plato/blob/a944bb9313785bcc47fb27b257bb2518c86174bd/lib/assets/scripts/vendor/codemirror/codemirror.js#L80-L164<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function makeDisplay ( place ) { var d = { } ; var input = d . input = elt ( "textarea" , null , null , "position: absolute; padding: 0; width: 1px; height: 1em; outline: none;" ) ; input . setAttribute ( "wrap" , "off" ) ; input . setAttribute ( "autocorrect" , "off" ) ; input . setAttribute ( "autocapitalize" , "off" ) ; // Wraps and hides input textarea d . inputDiv = elt ( "div" , [ input ] , null , "overflow: hidden; position: relative; width: 3px; height: 0px;" ) ; // The actual fake scrollbars. d . scrollbarH = elt ( "div" , [ elt ( "div" , null , null , "height: 1px" ) ] , "CodeMirror-hscrollbar" ) ; d . scrollbarV = elt ( "div" , [ elt ( "div" , null , null , "width: 1px" ) ] , "CodeMirror-vscrollbar" ) ; d . scrollbarFiller = elt ( "div" , null , "CodeMirror-scrollbar-filler" ) ; // DIVs containing the selection and the actual code d . lineDiv = elt ( "div" ) ; d . selectionDiv = elt ( "div" , null , null , "position: relative; z-index: 1" ) ; // Blinky cursor, and element used to ensure cursor fits at the end of a line d . cursor = elt ( "pre" , "\u00a0" , "CodeMirror-cursor" ) ; // Secondary cursor, shown when on a 'jump' in bi-directional text d . otherCursor = elt ( "pre" , "\u00a0" , "CodeMirror-cursor CodeMirror-secondarycursor" ) ; // Used to measure text size d . measure = elt ( "div" , null , "CodeMirror-measure" ) ; // Wraps everything that needs to exist inside the vertically-padded coordinate system d . lineSpace = elt ( "div" , [ d . measure , d . selectionDiv , d . lineDiv , d . cursor , d . otherCursor ] , null , "position: relative; outline: none" ) ; // Moved around its parent to cover visible view d . mover = elt ( "div" , [ elt ( "div" , [ d . lineSpace ] , "CodeMirror-lines" ) ] , null , "position: relative" ) ; // Set to the height of the text, causes scrolling d . sizer = elt ( "div" , [ d . mover ] , "CodeMirror-sizer" ) ; // D is needed because behavior of elts with overflow: auto and padding is inconsistent across browsers d . heightForcer = elt ( "div" , "\u00a0" , null , "position: absolute; height: " + scrollerCutOff + "px" ) ; // Will contain the gutters, if any d . gutters = elt ( "div" , null , "CodeMirror-gutters" ) ; d . lineGutter = null ; // Helper element to properly size the gutter backgrounds var scrollerInner = elt ( "div" , [ d . sizer , d . heightForcer , d . gutters ] , null , "position: relative; min-height: 100%" ) ; // Provides scrolling d . scroller = elt ( "div" , [ scrollerInner ] , "CodeMirror-scroll" ) ; d . scroller . setAttribute ( "tabIndex" , "-1" ) ; // The element in which the editor lives. d . wrapper = elt ( "div" , [ d . inputDiv , d . scrollbarH , d . scrollbarV , d . scrollbarFiller , d . scroller ] , "CodeMirror" ) ; // Work around IE7 z-index bug if ( ie_lt8 ) { d . gutters . style . zIndex = - 1 ; d . scroller . style . paddingRight = 0 ; } if ( place . appendChild ) place . appendChild ( d . wrapper ) ; else place ( d . wrapper ) ; // Needed to hide big blue blinking cursor on Mobile Safari if ( ios ) input . style . width = "0px" ; if ( ! webkit ) d . scroller . draggable = true ; // Needed to handle Tab key in KHTML if ( khtml ) { d . inputDiv . style . height = "1px" ; d . inputDiv . style . position = "absolute" ; } // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8). else if ( ie_lt8 ) d . scrollbarH . style . minWidth = d . scrollbarV . style . minWidth = "18px" ; // Current visible range (may be bigger than the view window). d . viewOffset = d . showingFrom = d . showingTo = d . lastSizeC = 0 ; // Used to only resize the line number gutter when necessary (when // the amount of lines crosses a boundary that makes its width change) d . lineNumWidth = d . lineNumInnerWidth = d . lineNumChars = null ; // See readInput and resetInput d . prevInput = "" ; // Set to true when a non-horizontal-scrolling widget is added. As // an optimization, widget aligning is skipped when d is false. d . alignWidgets = false ; // Flag that indicates whether we currently expect input to appear // (after some event like 'keypress' or 'input') and are polling // intensively. d . pollingFast = false ; // Self-resetting timeout for the poller d . poll = new Delayed ( ) ; // True when a drag from the editor is active d . draggingText = false ; d . cachedCharWidth = d . cachedTextHeight = null ; d . measureLineCache = [ ] ; d . measureLineCachePos = 0 ; // Tracks when resetInput has punted to just putting a short // string instead of the (large) selection. d . inaccurateSelection = false ; // Used to adjust overwrite behaviour when a paste has been // detected d . pasteIncoming = false ; return d ; }<CODESPLIT>0.11570708453655243<CODESPLIT>0.14902184903621674

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/mongodb-js/mongodb-extjson/blob/d60c810266dcaa31e124a87a7224567c8330ea62/lib/ext_json.js#L174-L185<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function stringify ( value , replacer , space , options ) { if ( space != null && typeof space === 'object' ) ( options = space ) , ( space = 0 ) ; if ( replacer != null && typeof replacer === 'object' ) ( options = replacer ) , ( replacer = null ) , ( space = 0 ) ; options = Object . assign ( { } , { relaxed : true } , options ) ; const doc = Array . isArray ( value ) ? serializeArray ( value , options ) : serializeDocument ( value , options ) ; return JSON . stringify ( doc , replacer , space ) ; }<CODESPLIT>0.16426946222782135<CODESPLIT>0.13747313618659973

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/ottojs/otto-authentication/blob/c7314fb46beda36c7400d170c74db40be9d913d5/lib/index.js#L19-L32<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function http_basic ( username , password ) { return function ( req , res , next ) { var credentials = basic_auth ( req ) ; if ( credentials !== undefined ) { if ( credentials . name && credentials . name === username ) { if ( credentials . pass && credentials . pass === password ) { return next ( ) ; } } } res . set ( 'WWW-Authenticate' , 'Basic' ) ; next ( new ErrorUnauthorized ( 'Authentication Failed' ) ) ; } ; }<CODESPLIT>0.1448136866092682<CODESPLIT>0.1363019496202469

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/arusahni/ngtweet/blob/60e19c174be0f868193568858ad8172def50d5fa/dist/ngtweet.js#L116-L129<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function diffArrays ( arr1 , arr2 ) { if ( ! Array . isArray ( arr1 ) || ! Array . isArray ( arr2 ) ) { return true ; } if ( arr1 . length !== arr2 . length ) { return true ; } for ( var i = 0 , len = arr1 . length ; i < len ; i ++ ) { if ( arr1 [ i ] !== arr2 [ i ] ) { return true ; } } return false ; }<CODESPLIT>0.14642922580242157<CODESPLIT>0.12820781767368317

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/jsdom/jsdom/blob/43f2089142f57cddc3983e6429c34351699625f2/lib/jsdom/living/nodes/Node-impl.js#L79-L92<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function isHostInclusiveAncestor ( nodeImplA , nodeImplB ) { for ( const ancestor of domSymbolTree . ancestorsIterator ( nodeImplB ) ) { if ( ancestor === nodeImplA ) { return true ; } } const rootImplB = getRoot ( nodeImplB ) ; if ( rootImplB . _host ) { return isHostInclusiveAncestor ( nodeImplA , rootImplB . _host ) ; } return false ; }<CODESPLIT>0.1394764631986618<CODESPLIT>0.14751696586608887

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/isaaceindhoven/angularjs-nouislider/blob/41bc5d034a9ae01dceb7311d6c31c92403b8ef75/src/directive.js#L105-L119<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function initializeNgModel ( ) { if ( ngModel === null ) { return $q . resolve ( null ) ; } return $q ( ( resolve ) => { $timeout ( ( ) => { if ( ! ( angular . isArray ( ngModel . $modelValue ) || angular . isNumber ( ngModel . $modelValue ) ) ) { throw new Error ( ` ${ ngModel . $modelValue } ` ) ; } resolve ( ngModel . $modelValue ) ; } ) ; } ) ; }<CODESPLIT>0.15893040597438812<CODESPLIT>0.16438953578472137

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/ajbarry3/easel-gl/blob/e3b14a55d0266fe7950b1ff445be5017658ec665/easeljs.js#L11292-L11325<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function Bitmap ( imageOrUri ) { this . DisplayObject_constructor ( ) ; // public properties: /** 		 * The source image to display. This can be a CanvasImageSource 		 * (image, video, canvas), an object with a `getImage` method that returns a CanvasImageSource, or a string URL to an image. 		 * If the latter, a new Image instance with the URL as its src will be used. 		 * @property image 		 * @type CanvasImageSource | Object 		 **/ if ( typeof imageOrUri == "string" ) { this . image = document . createElement ( "img" ) ; this . image . src = imageOrUri ; } else { this . image = imageOrUri ; } /** 		 * Specifies an area of the source image to draw. If omitted, the whole image will be drawn. 		 * Note that video sources must have a width / height set to work correctly with `sourceRect`. 		 * @property sourceRect 		 * @type Rectangle 		 * @default null 		 */ this . sourceRect = null ; // private properties: /** 		 * Docced in superclass. 		 */ this . _webGLRenderStyle = createjs . DisplayObject . _StageGL_BITMAP ; }<CODESPLIT>0.15395735204219818<CODESPLIT>0.13222724199295044

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L19173-L19187<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( ) { this . _ensureViewIsIntact ( ) ; if ( this . _firstRender ) { // if this is the first render, don't do anything to // reset the regions this . _firstRender = false ; } else { // If this is not the first render call, then we need to // re-initialize the `el` for each region this . _reInitializeRegions ( ) ; } return Marionette . ItemView . prototype . render . apply ( this , arguments ) ; }<CODESPLIT>0.1538841277360916<CODESPLIT>0.1235218197107315

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/apache/cordova-lib/blob/dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5/src/cordova/plugin/add.js#L334-L356<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getFetchVersion ( projectRoot , pluginInfo , cordovaVersion ) { // Figure out the project requirements if ( pluginInfo . engines && pluginInfo . engines . cordovaDependencies ) { // grab array of already installed plugins var pluginList = plugin_util . getInstalledPlugins ( projectRoot ) ; var pluginMap = { } ; pluginList . forEach ( function ( plugin ) { pluginMap [ plugin . id ] = plugin . version ; } ) ; return cordova_util . getInstalledPlatformsWithVersions ( projectRoot ) . then ( function ( platformVersions ) { return module . exports . determinePluginVersionToFetch ( pluginInfo , pluginMap , platformVersions , cordovaVersion ) ; } ) ; } else { // If we have no engine, we want to fall back to the default behavior events . emit ( 'verbose' , 'npm info for ' + pluginInfo . name + ' did not contain any engine info. Fetching latest release' ) ; return Promise . resolve ( null ) ; } }<CODESPLIT>0.1599833369255066<CODESPLIT>0.13611888885498047

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/mapero/node-red-contrib-nools/blob/f569d9ca8c16dac5b9eefe11df290f5a7432b7ec/nools.js#L35-L60<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( ) { this . date = new Date ( ) ; this . getHours = function ( ) { return this . date . getHours ( ) ; } ; this . getMinutes = function ( ) { return this . date . getMinutes ( ) ; } ; this . hoursIsBetween = function ( a , b ) { if ( a <= b ) return this . date . getHours ( ) >= a && this . date . getHours ( ) <= b ; else return this . date . getHours ( ) >= a || this . date . getHours ( ) <= b ; } ; this . step = function ( ) { this . date = new Date ( ) ; this . isMorning = this . hoursIsBetween ( 6 , 11 ) ; this . isNoon = this . hoursIsBetween ( 12 , 14 ) ; this . isAfternoon = this . hoursIsBetween ( 15 , 17 ) ; this . isEvening = this . hoursIsBetween ( 18 , 23 ) ; this . isNight = this . hoursIsBetween ( 0 , 5 ) ; return this ; } ; }<CODESPLIT>0.15671870112419128<CODESPLIT>0.11694485694169998

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/duaraghav8/Ethlint/blob/7d264373709561148c7166601ac39370e78f74b1/lib/rules/function-order.js#L130-L159<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function inspectFunctionsOfContract ( emitted ) { if ( emitted . exit ) { return ; } const { node } = emitted , { body } = node ; let cursor = 0 ; // Filter out non-function nodes body . filter ( child => { return [ "FunctionDeclaration" , "ConstructorDeclaration" ] . includes ( child . type ) ; } ) . forEach ( funcNode => { // Return if the function is ignored or in the correct order. if ( ( context . options && isIgnored ( funcNode , node , context . options [ 0 ] . ignore ) ) || isFunctionVisibility ( node , funcNode , functionOrder [ cursor ] ) ) { return ; } const funcPosInOrder = findFuncPosInOrder ( node , funcNode ) ; if ( funcPosInOrder > cursor ) { cursor = funcPosInOrder ; return ; } context . report ( { node : funcNode , message : errorMessage } ) ; } ) ; }<CODESPLIT>0.1696239411830902<CODESPLIT>0.15899483859539032

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/mysticatea/event-target-shim/blob/89a7c7cb62971c45ae566a47f42436af923011b9/dist/event-target-shim.js#L44-L52<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function pd ( event ) { const retv = privateData . get ( event ) ; console . assert ( retv != null , "'this' is expected an Event object, but got" , event ) ; return retv }<CODESPLIT>0.1398962438106537<CODESPLIT>0.14429286122322083

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/liabru/matter-js/blob/2ec247b7af1c6b5da6ee05c73274ed5822c73503/src/render/RenderPixi.js#L506-L513<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( render , imagePath ) { var texture = render . textures [ imagePath ] ; if ( ! texture ) texture = render . textures [ imagePath ] = PIXI . Texture . fromImage ( imagePath ) ; return texture ; }<CODESPLIT>0.16695401072502136<CODESPLIT>0.14003127813339233

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/carrot/roots-cms-client/blob/57d5281eb03b9f8377d9478da3742f5a74653c17/assets/js/vendor/backbone-relational.js#L255-L264<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( ) { // Make sure to operate on a copy since we're removing while iterating _ . each ( this . _orphanRelations . slice ( 0 ) , function ( rel ) { var relatedModel = Backbone . Relational . store . getObjectByName ( rel . relatedModel ) ; if ( relatedModel ) { this . initializeRelation ( null , rel ) ; this . _orphanRelations = _ . without ( this . _orphanRelations , rel ) ; } } , this ) ; }<CODESPLIT>0.14056293666362762<CODESPLIT>0.13514448702335358

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/apache/cordova-lib/blob/dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5/src/cordova/util.js#L356-L373<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getPlatformApiFunction ( dir ) { let PlatformApi ; try { PlatformApi = exports . requireNoCache ( dir ) ; } catch ( err ) { // Module not found or threw error during loading err . message = ` ${ dir } \n ${ err . message } ` ; throw err ; } // Module doesn't implement the expected interface if ( ! PlatformApi || ! PlatformApi . createPlatform ) { throw new Error ( ` ${ dir } ` ) ; } events . emit ( 'verbose' , 'Platform API successfully found in: ' + dir ) ; return PlatformApi ; }<CODESPLIT>0.16868643462657928<CODESPLIT>0.13904133439064026

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/xinbenlv/passport-weibo/blob/c489d6f31f67e8b2854235c445108570013ce430/lib/passport-weibo/strategy.js#L46-L61<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function Strategy ( options , verify ) { options = options || { } ; options . authorizationURL = options . authorizationURL || 'https://api.weibo.com/oauth2/authorize' ; options . tokenURL = options . tokenURL || 'https://api.weibo.com/oauth2/access_token' ; options . scopeSeparator = options . scopeSeparator || ',' ; options . customHeaders = options . customHeaders || { } ; if ( ! options . customHeaders [ 'User-Agent' ] ) { options . customHeaders [ 'User-Agent' ] = options . userAgent || 'passport-weibo' ; } OAuth2Strategy . call ( this , options , verify ) ; this . name = 'weibo' ; this . _getuidAPI = options . getuidAPI || 'https://api.weibo.com/2/account/get_uid.json' ; this . _getProfileAPI = options . getProfileAPI || 'https://api.weibo.com/2/users/show.json' ; }<CODESPLIT>0.16543003916740417<CODESPLIT>0.12374820560216904

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L23626-L23647<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( ) { // Get the current value of the property newClass = this . _classStringForProperty ( binding ) ; elem = this . $ ( ) ; // If we had previously added a class to the element, remove it. if ( oldClass ) { elem . removeClass ( oldClass ) ; // Also remove from classNames so that if the view gets rerendered, // the class doesn't get added back to the DOM. classNames . removeObject ( oldClass ) ; } // If necessary, add a new class. Make sure we keep track of it so // it can be removed in the future. if ( newClass ) { elem . addClass ( newClass ) ; oldClass = newClass ; } else { oldClass = null ; } }<CODESPLIT>0.10950841754674911<CODESPLIT>0.15392716228961945

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L18333-L18347<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( child , collection , opts ) { // `index` is present when adding with `at` since BB 1.2; indexOf fallback for < 1.2 var index = opts . at !== undefined && ( opts . index || collection . indexOf ( child ) ) ; // When filtered or when there is no initial index, calculate index. if ( this . getOption ( 'filter' ) || index === false ) { index = _ . indexOf ( this . _filteredSortedModels ( index ) , child ) ; } if ( this . _shouldAddChild ( child , index ) ) { this . destroyEmptyView ( ) ; var ChildView = this . getChildView ( child ) ; this . addChild ( child , ChildView , index ) ; } }<CODESPLIT>0.1677544265985489<CODESPLIT>0.13368003070354462

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/wavesoft/gulp-jbb-profile/blob/3e9bc0ca733ae0325a09a461f504fc847e256f7a/lib/ProfileObject.js#L103-L124<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( o ) { // Don't extend 'depends', extend only 'extends' if ( this . extends ) { this . embed = o . embed . concat ( this . embed ) ; this . properties = o . properties . concat ( this . properties ) ; this . postInit = o . postInit + this . postInit ; // Replace init & Factory if different if ( this . init === "default" ) this . init = o . init ; if ( this . factory === "new" ) this . factory = o . factory ; // Replace default property assigned if not defined if ( ! this . propAssign ) this . propAssign = o . propAssign ; // Implement undefined extended property assigners for ( var k in o . propCustomAssign ) { if ( ! this . propCustomAssign [ k ] ) { this . propCustomAssign [ k ] = o . propCustomAssign [ k ] ; } } } }<CODESPLIT>0.15094336867332458<CODESPLIT>0.13595424592494965

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/cubicmushroom/gulp-cm-phpspec-tasks/blob/671b5e6e9545c7a6a027f8b93c1349d491cf429e/pakmanaged.js#L76925-L76935<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function eatNargs ( i , key , args ) { var toEat = checkAllAliases ( key , opts . narg ) if ( args . length - ( i + 1 ) < toEat ) error = Error ( __ ( 'Not enough arguments following: %s' , key ) ) for ( var ii = i + 1 ; ii < ( toEat + i + 1 ) ; ii ++ ) { setArg ( key , args [ ii ] ) } return ( i + toEat ) }<CODESPLIT>0.1265043467283249<CODESPLIT>0.16521085798740387

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L27943-L27969<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( view ) { var morph = view . morph ; view . transitionTo ( 'preRender' ) ; Ember . run . schedule ( 'render' , this , function renderMetamorphView ( ) { if ( view . isDestroying ) { return ; } view . clearRenderedChildren ( ) ; var buffer = view . renderToBuffer ( ) ; view . invokeRecursively ( function ( view ) { view . propertyWillChange ( 'element' ) ; } ) ; view . triggerRecursively ( 'willInsertElement' ) ; morph . replaceWith ( buffer . string ( ) ) ; view . transitionTo ( 'inDOM' ) ; view . invokeRecursively ( function ( view ) { view . propertyDidChange ( 'element' ) ; } ) ; view . triggerRecursively ( 'didInsertElement' ) ; notifyMutationListeners ( ) ; } ) ; }<CODESPLIT>0.17781184613704681<CODESPLIT>0.13416902720928192

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/jsantell/GhostTrain/blob/e69b6cc33669035c1d571bff3805e1b6d8a50ccb/lib/request.js#L19-L42<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function Request ( ghosttrain , route , url , options ) { // Headers info this . headers = options . headers || { } ; // Allows us to check protocol of client-side requests, // but relative requests won't have a protocol var protocol = 'window' in this ? window . location . protocol : '' ; // Expose URL properties var parsedURL = url . pathname ? url : parseURL ( url , true ) ; this . path = parsedURL . pathname ; this . query = parsedURL . query ; this . protocol = ( parsedURL . protocol || protocol ) . replace ( ':' , '' ) ; this . secure = this . protocol === 'https' ; this . route = route ; this . method = route . method . toUpperCase ( ) ; this . url = this . originalUrl = requestURL ( parsedURL ) ; this . params = route . params ; this . body = options . body || { } ; this . headers = options . headers || { } ; this . xhr = 'xmlhttprequest' === ( this . get ( 'X-Requested-With' ) || '' ) . toLowerCase ( ) ; }<CODESPLIT>0.15879781544208527<CODESPLIT>0.13393016159534454

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/vshymanskyy/blynk-library-js/blob/d886383546b416bc347f6c7fe94c512391c37957/blynk.js#L7-L11<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function string_of_enum ( e , value ) { for ( var k in e ) if ( e [ k ] == value ) return k ; return "Unknown(" + value + ")" ; }<CODESPLIT>0.17825676500797272<CODESPLIT>0.1654898077249527

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L14096-L14128<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function resolveEntityName ( name , meaning , ignoreErrors ) { if ( ts . nodeIsMissing ( name ) ) { return undefined ; } var symbol ; if ( name . kind === 69 /* Identifier */ ) { var message = meaning === 1536 /* Namespace */ ? ts . Diagnostics . Cannot_find_namespace_0 : ts . Diagnostics . Cannot_find_name_0 ; symbol = resolveName ( name , name . text , meaning , ignoreErrors ? undefined : message , name ) ; if ( ! symbol ) { return undefined ; } } else if ( name . kind === 135 /* QualifiedName */ || name . kind === 166 /* PropertyAccessExpression */ ) { var left = name . kind === 135 /* QualifiedName */ ? name . left : name . expression ; var right = name . kind === 135 /* QualifiedName */ ? name . right : name . name ; var namespace = resolveEntityName ( left , 1536 /* Namespace */ , ignoreErrors ) ; if ( ! namespace || namespace === unknownSymbol || ts . nodeIsMissing ( right ) ) { return undefined ; } symbol = getSymbol ( getExportsOfSymbol ( namespace ) , right . text , meaning ) ; if ( ! symbol ) { if ( ! ignoreErrors ) { error ( right , ts . Diagnostics . Module_0_has_no_exported_member_1 , getFullyQualifiedName ( namespace ) , ts . declarationNameToString ( right ) ) ; } return undefined ; } } else { ts . Debug . fail ( "Unknown entity name kind." ) ; } ts . Debug . assert ( ( symbol . flags & 16777216 /* Instantiated */ ) === 0 , "Should never get an instantiated symbol here." ) ; return symbol . flags & meaning ? symbol : resolveAlias ( symbol ) ; }<CODESPLIT>0.15397606790065765<CODESPLIT>0.16224221885204315

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/JedWatson/asyncdi/blob/4e9dd53ded83b65fc96f07fd9347931a1c82b302/index.js#L161-L173<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function each ( arr , callback ) { var wrapper = this ; if ( this . isAsync ) { return async . each ( arr , function ( item , cb ) { wrapper . call ( item , cb ) ; } , callback ) ; } else { arr . each ( function ( item ) { wrapper . call ( item ) ; } ) ; if ( callback ) { callback ( ) ; } } }<CODESPLIT>0.16005371510982513<CODESPLIT>0.14188745617866516

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/jeka-kiselyov/mdict/blob/540898e63991cb0c8985ed8fb29eb11a59f35089/mdict-parser.js#L418-L443<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( len , expectedBufSize , decryptor ) { var comp_type = dv . getUint8 ( offset , false ) ; // compression type, 0 = non, 1 = lzo, 2 = gzip if ( comp_type === 0 ) { if ( _v2 ) { this . forward ( 8 ) ; // for version >= 2, skip comp_type (4 bytes with tailing \x00) and checksum (4 bytes) } return this ; } else { // skip comp_type (4 bytes with tailing \x00) and checksum (4 bytes) offset += 8 ; len -= 8 ; var tmp = new Uint8Array ( len ) ; buf . copy ( tmp , 0 , offset , offset + len ) ; if ( decryptor ) { var passkey = new Uint8Array ( 8 ) ; var q = new Buffer ( 4 ) ; buf . copy ( passkey , 0 , offset - 4 , offset ) ; // var q = new Buffer(4); passkey . set ( [ 0x95 , 0x36 , 0x00 , 0x00 ] , 4 ) ; // key part 2: fixed data tmp = decryptor ( tmp , passkey ) ; } tmp = comp_type === 2 ? pako . inflate ( tmp ) : lzo . decompress ( tmp , expectedBufSize , 1308672 ) ; this . forward ( len ) ; var d = new Buffer ( tmp ) ; return Scanner ( d , tmp . length ) ; } }<CODESPLIT>0.1599137783050537<CODESPLIT>0.13514982163906097

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/Mermade/jgeXml/blob/9bf6fcde331649a5a5e39314edd55e73eb0e4c15/jgeXml.js#L94-L336<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function jgeParse ( s , callback , context ) { if ( context && context . newState ) { if ( ! context . keepToken ) context . token = '' ; context . state = context . newState ; } else { context = { } ; reset ( context ) ; } var c ; for ( var i = context . position ; i < s . length ; i ++ ) { c = s . charAt ( i ) ; if ( ( c . charCodeAt ( 0 ) < 32 ) && ( context . validControlChars . indexOf ( c ) < 0 ) ) { context . newState = context . state = sError ; } if ( context . state != sContent ) { if ( context . validControlChars . indexOf ( c ) >= 0 ) { //other unicode spaces are not treated as whitespace c = ' ' ; } } context . bIndex = - 1 ; for ( var b = 0 ; b < context . boundary . length ; b ++ ) { if ( s . substr ( i , context . boundary [ b ] . length ) == context . boundary [ b ] ) { context . bIndex = b ; if ( context . boundary [ context . bIndex ] . length > 1 ) { i = i + context . boundary [ context . bIndex ] . length - 1 ; } break ; } } if ( context . bIndex >= 0 ) { if ( ( context . state != sValue ) && ( context . state != sComment ) ) { // && (context.state != sContent) context . token = context . token . trim ( ) ; } context . keepToken = false ; if ( ( ( context . state & 1 ) == 1 ) && ( ( context . token . trim ( ) !== '' ) || context . state == sValue ) ) { // TODO test element names for validity (using regex?) if ( context . state != sCData ) { context . token = context . token . replaceAll ( '&amp;' , '&' ) ; context . token = context . token . replaceAll ( '&quot;' , '"' ) ; context . token = context . token . replaceAll ( '&apos;' , "'" ) ; context . token = context . token . replaceAll ( '&gt;' , '>' ) ; context . token = context . token . replaceAll ( '&lt;' , '<' ) ; if ( context . token . indexOf ( '&#' ) >= 0 ) { context . token = context . token . replace ( / &(?:#([0-9]+)|#x([0-9a-fA-F]+)); / g , function ( match , group1 , group2 ) { var e ; if ( group2 ) { e = String . fromCharCode ( parseInt ( group2 , 16 ) ) ; if ( ( e . charCodeAt ( 0 ) < 32 ) && ( context . validControlChars . indexOf ( e ) < 0 ) ) { context . newState = context . state = sError ; } return e ; } else { e = String . fromCharCode ( group1 ) ; if ( ( e . charCodeAt ( 0 ) < 32 ) && ( context . validControlChars . indexOf ( e ) < 0 ) ) { context . newState = context . state = sError ; } return e ; } } ) ; } } if ( context . state == sElement ) context . depth ++ ; else if ( context . state == sEndElement ) { context . depth -- ; if ( context . depth < 0 ) { context . newState = context . state = sError ; } } if ( context . state == sError ) { context . error = true ; } if ( callback ) { callback ( context . state , context . token ) ; } if ( context . state == sError ) { context . boundary = [ ] ; } } if ( context . state == sInitial ) { if ( context . boundary [ context . bIndex ] == '<?' ) { context . newState = sDeclaration ; context . boundary = [ '?>' ] ; } else { context . newState = sElement ; context . boundary = [ '>' , ' ' , '/' , '!--' , '?' , '!DOCTYPE' , '![CDATA[' ] ; context . boundary = context . boundary . concat ( context . validControlChars ) ; } } else if ( context . state == sDeclaration ) { context . newState = sPreElement ; context . boundary = [ '<' ] ; if ( context . token . indexOf ( '1.1' ) > 0 ) { context . validControlChars . push ( '\u2028' , '\u0085' , '\u0015' ) ; } } else if ( context . state == sPreElement ) { context . newState = sElement ; context . boundary = [ '>' , ' ' , '/' , '!--' , '?' , '!DOCTYPE' , '![CDATA[' ] ; context . boundary = context . boundary . concat ( context . validControlChars ) ; } else if ( context . state == sElement ) { context . lastElement = context . token ; if ( c == '>' ) { context . newState = sContent ; context . boundary = [ '<!DOCTYPE' , '<' ] ; } else if ( c == ' ' ) { context . newState = sAttribute ; context . boundary = [ '/' , '=' , '>' ] ; } else if ( c == '/' ) { context . newState = sEndElement ; context . boundary = [ '>' ] ; context . keepToken = true ; } else if ( c == '?' ) { context . newState = sProcessingInstruction ; context . boundary = [ '?>' ] ; } else if ( context . boundary [ context . bIndex ] == '!--' ) { context . newState = sComment ; context . boundary = [ '-->' ] ; } else if ( context . boundary [ context . bIndex ] == '![CDATA[' ) { context . newState = sCData ; context . boundary = [ ']]>' ] ; } else if ( context . boundary [ context . bIndex ] == '!DOCTYPE' ) { context . newState = sDocType ; context . boundary = [ '>' , '[' ] ; } } else if ( context . state == sAttribute ) { if ( c == '=' ) { context . newState = sAttrNML ; context . boundary = [ '\'' , '"' ] ; } else if ( c == '>' ) { context . newState = sContent ; context . boundary = [ '<!DOCTYPE' , '<' ] ; } else if ( c == '/' ) { context . newState = sEndElement ; context . keepToken = true ; context . state = sAttributeSpacer ; // to stop dummy attributes being emitted to pullparser context . token = context . lastElement ; } } else if ( context . state == sAttrNML ) { context . newState = sValue ; context . boundary = [ c ] ; } else if ( context . state == sValue ) { context . newState = sAttribute ; context . boundary = [ '=' , '/' , '>' ] ; } else if ( context . state == sEndElement ) { if ( context . depth !== 0 ) context . newState = sContent ; context . boundary = [ '<' ] ; // don't allow DOCTYPE's after the first sEndElement } else if ( context . state == sContent ) { if ( context . boundary [ context . bIndex ] == '<!DOCTYPE' ) { context . newState = sDocType ; context . boundary = [ '>' , '[' ] ; } else { context . newState = sElement ; context . boundary = [ '>' , ' ' , '/' , '!--' , '?' , '![CDATA[' ] ; context . boundary = context . boundary . concat ( context . validControlChars ) ; } } else if ( context . state == sComment ) { context . newState = sContent ; context . boundary = [ '<!DOCTYPE' , '<' ] ; } else if ( context . state == sProcessingInstruction ) { context . newState = sContent ; context . boundary = [ '<!DOCTYPE' , '<' ] ; } else if ( context . state == sCData ) { context . newState = sContent ; context . boundary = [ '<!DOCTYPE' , '<' ] ; } else if ( context . state == sDocType ) { if ( context . boundary [ context . bIndex ] == '[' ) { context . newState = sDTD ; context . boundary = [ ']>' ] ; } else { context . newState = sPreElement ; context . boundary = [ '<' ] ; } } else if ( context . state == sDTD ) { context . newState = sPreElement ; context . boundary = [ '<' ] ; } if ( ! callback ) { if ( ( ( context . state & 1 ) == 1 ) && ( ( context . token . trim ( ) !== '' ) || context . state == sValue ) ) { context . position = i + 1 ; return context ; } } context . state = context . newState ; if ( ! context . keepToken ) context . token = '' ; } else { context . token += c ; } } if ( ( context . state == sEndElement ) && ( context . depth === 0 ) && ( context . token . trim ( ) === '' ) ) { context . wellFormed = true ; } if ( ( ! context . wellFormed ) && ( ! context . error ) ) { if ( callback ) { // generate a final error, only for pushparsers though callback ( sError , context . token ) ; } } context . state = sEndDocument ; if ( callback ) { callback ( context . state , context . token ) ; return context . wellFormed ; } else { return context ; } }<CODESPLIT>0.1610630452632904<CODESPLIT>0.14759516716003418

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/daliwali/simulacra/blob/b6bb7e2486f7722101f9e416ec345d49f3afa901/lib/index.js#L66-L110<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function simulacra ( obj , def , matchNode ) { var document = this ? this . document : window . document var Node = this ? this . Node : window . Node var node , query // Before continuing, check if required features are present. featureCheck ( this || window , features ) if ( obj === null || typeof obj !== 'object' || isArray ( obj ) ) throw new TypeError ( 'First argument must be a singular object.' ) if ( ! isArray ( def ) ) throw new TypeError ( 'Second argument must be an array.' ) if ( typeof def [ 0 ] === 'string' ) { query = def [ 0 ] def [ 0 ] = document . querySelector ( query ) if ( ! def [ 0 ] ) throw new Error ( 'Top-level Node "' + query + '" could not be found in the document.' ) } else if ( ! ( def [ 0 ] instanceof Node ) ) throw new TypeError ( 'The first position of the top-level must be either a Node or a CSS ' + 'selector string.' ) if ( ! def [ isProcessedKey ] ) { // Auto-detect template tag. if ( 'content' in def [ 0 ] ) def [ 0 ] = def [ 0 ] . content def [ 0 ] = def [ 0 ] . cloneNode ( true ) cleanNode ( this , def [ 0 ] ) ensureNodes ( def [ 0 ] , def [ 1 ] ) setProperties ( def ) } node = processNodes ( this , def [ 0 ] , def [ 1 ] ) bindKeys ( this , obj , def [ 1 ] , node , { root : obj } ) if ( matchNode ) { rehydrate ( this , obj , def [ 1 ] , node , matchNode ) return matchNode } return node }<CODESPLIT>0.1593073159456253<CODESPLIT>0.1467278003692627

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/IntrospectiveSystems/xGraph/blob/86bc86f6cd7aab4c5259532ce28fb7f8ac5424e0/lib/Nexus.js#L238-L260<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>async function exit ( code = 0 ) { log . i ( '--Nexus/Stop' ) ; //build the Stop promise array let stopTasks = [ ] ; log . i ( 'Nexus unloading node modules' ) ; log . v ( Object . keys ( require . cache ) . join ( '\n' ) ) ; for ( let pid in Stop ) { stopTasks . push ( new Promise ( ( resolve , _reject ) => { let com = { } ; com . Cmd = Stop [ pid ] ; com . Passport = { } ; com . Passport . To = pid ; com . Passport . Pid = genPid ( ) ; sendMessage ( com , resolve ) ; } ) ) ; } await Promise . all ( stopTasks ) ; log . v ( '--Nexus: All Stops Complete' ) ; dispatchEvent ( 'exit' , { exitCode : code } ) ; }<CODESPLIT>0.16304032504558563<CODESPLIT>0.1397242397069931

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/othiym23/async-listener/blob/01a02ee123db3d4a98e0cc5dda6f8ef82c55f81e/glue.js#L60-L83<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function union ( dest , added ) { var destLength = dest . length ; var addedLength = added . length ; var returned = [ ] ; if ( destLength === 0 && addedLength === 0 ) return returned ; for ( var j = 0 ; j < destLength ; j ++ ) returned [ j ] = dest [ j ] ; if ( addedLength === 0 ) return returned ; for ( var i = 0 ; i < addedLength ; i ++ ) { var missing = true ; for ( j = 0 ; j < destLength ; j ++ ) { if ( dest [ j ] . uid === added [ i ] . uid ) { missing = false ; break ; } } if ( missing ) returned . push ( added [ i ] ) ; } return returned ; }<CODESPLIT>0.15963305532932281<CODESPLIT>0.1208987906575203

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/hash-bang/async-chainable/blob/9f2ef431598472ed3ac8d8a518b3108ef138c0e8/index.js#L179-L195<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function race ( ) { var self = this ; argy ( arguments ) . ifForm ( '' , function ( ) { } ) . ifForm ( 'array' , function ( tasks ) { self . _struct . push ( { type : 'race' , payload : tasks } ) ; } ) . ifForm ( 'string array' , function ( id , tasks ) { self . _struct . push ( { type : 'race' , id : arguments [ 0 ] , payload : arguments [ 1 ] } ) ; } ) . ifFormElse ( function ( form ) { throw new Error ( 'Unknown call style for .parallel(): ' + form ) ; } ) return self ; }<CODESPLIT>0.13994839787483215<CODESPLIT>0.13111867010593414

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/GitbookIO/theme-default/blob/a8e920453dc8e4eb522840b61606486622848099/src/js/theme/sidebar.js#L37-L47<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function filterSummary ( paths ) { var $summary = $ ( '.book-summary' ) ; $summary . find ( 'li' ) . each ( function ( ) { var path = $ ( this ) . data ( 'path' ) ; var st = paths == null || paths . indexOf ( path ) !== - 1 ; $ ( this ) . toggle ( st ) ; if ( st ) $ ( this ) . parents ( 'li' ) . show ( ) ; } ) ; }<CODESPLIT>0.1586741805076599<CODESPLIT>0.12243956327438354

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/young-steveo/bottlejs/blob/2e7652ac79aeafa2b51b12a7f7afcd1086ff5c51/dist/bottle.js#L265-L277<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function createService ( name , Service , isClass ) { var deps = arguments . length > 3 ? slice . call ( arguments , 3 ) : [ ] ; var bottle = this ; return factory . call ( this , name , function GenericFactory ( ) { var serviceFactory = Service ; // alias for jshint var args = deps . map ( getNestedService , bottle . container ) ; if ( ! isClass ) { return serviceFactory . apply ( null , args ) ; } return new ( Service . bind . apply ( Service , [ null ] . concat ( args ) ) ) ( ) ; } ) ; }<CODESPLIT>0.16129690408706665<CODESPLIT>0.13809484243392944

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/viridia/certainty/blob/ab4294df65dfda324ef0713a3a22657959958f80/lib/format/formatMap.js#L8-L10<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function formatMap ( value , options ) { return 'Map(' + registry . format ( Array . from ( value . entries ( ) ) , options ) + ')' ; }<CODESPLIT>0.1341366171836853<CODESPLIT>0.15766894817352295

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L64657-L64662<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function Parser ( options ) { debug ( 'initializing' , __filename ) ; this . options = utils . extend ( { source : 'string' } , options ) ; this . init ( this . options ) ; use ( this ) ; }<CODESPLIT>0.16696032881736755<CODESPLIT>0.12104568630456924

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L24456-L24464<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function checkElementTypeOfIterable ( iterable , errorNode ) { var elementType = getElementTypeOfIterable ( iterable , errorNode ) ; // Now even though we have extracted the iteratedType, we will have to validate that the type // passed in is actually an Iterable. if ( errorNode && elementType ) { checkTypeAssignableTo ( iterable , createIterableType ( elementType ) , errorNode ) ; } return elementType || anyType ; }<CODESPLIT>0.16526950895786285<CODESPLIT>0.13015854358673096

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/jub3i/node-net-stat/blob/576192fbf95c7f66d442efc967cc771e97f8aab7/index.js#L13-L28<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function totalRx ( opts ) { if ( opts ) { opts . iface = opts . iface || 'lo' ; opts . units = opts . units || 'bytes' ; } else { opts = { iface : 'lo' , units : 'bytes' , } ; } var total = parseInt ( _parseProcNetDev ( ) [ opts . iface ] . bytes . receive ) ; var converted = _bytesTo ( total , opts . units ) ; return converted ; }<CODESPLIT>0.15057013928890228<CODESPLIT>0.14675137400627136

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/router.js#L164-L343<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function httpRouter ( req , res ) { let operation ; let responseSpec = defaultResponseSpec ; return httpTransaction ( req , res ) . then ( ( [ request , transaction ] ) => transaction . start ( ( ) => Promise . resolve ( ) . then ( ( ) => { const method = request . method ; const path = request . url . split ( SEARCH_SEPARATOR ) [ 0 ] ; const search = request . url . substr ( path . length ) ; const parts = path . split ( '/' ) . filter ( a => a ) ; let [ result , pathParameters ] = routers [ method ] ? routers [ method ] . find ( parts ) : [ ] ; // Second chance for HEAD calls if ( ! result && 'head' === method ) { [ result , pathParameters ] = routers . get ? routers . get . find ( parts ) : [ ] ; } const { handler , operation : _operation_ , validators } = result || { } ; if ( ! handler ) { log ( 'debug' , 'No handler found for: ' , method , parts ) ; throw new HTTPError ( 404 , 'E_NOT_FOUND' , method , parts ) ; } operation = _operation_ ; return { search , pathParameters , validators , operation , handler , } ; } ) . then ( ( { search , pathParameters , validators , operation , handler , } ) => { const consumableMediaTypes = operation . consumes || API . consumes || [ ] ; const produceableMediaTypes = ( operation && operation . produces ) || API . produces || [ ] ; const bodySpec = extractBodySpec ( request , consumableMediaTypes , consumableCharsets , ) ; responseSpec = extractResponseSpec ( operation , request , produceableMediaTypes , produceableCharsets , ) ; return getBody ( { DECODERS , PARSERS , bufferLimit , } , operation , request . body , bodySpec , ) . then ( body => Object . assign ( body ? { body } : { } , pathParameters , QUERY_PARSER ( operation . parameters , search ) , filterHeaders ( operation . parameters , request . headers , ) , ) , ) . then ( parameters => { applyValidators ( operation , validators , parameters ) ; return parameters ; } ) . catch ( err => { throw HTTPError . cast ( err , 400 ) ; } ) . then ( executeHandler . bind ( null , operation , handler ) ) . then ( response => { if ( response . body ) { response . headers [ 'content-type' ] = response . headers [ 'content-type' ] || responseSpec . contentTypes [ 0 ] ; } // Check the stringifyer only when a schema is // specified const responseHasSchema = operation . responses && operation . responses [ response . status ] && operation . responses [ response . status ] . schema ; if ( responseHasSchema && ! STRINGIFYERS [ response . headers [ 'content-type' ] ] ) { return Promise . reject ( new HTTPError ( 500 , 'E_STRINGIFYER_LACK' , response . headers [ 'content-type' ] , ) , ) ; } if ( response . body ) { checkResponseCharset ( request , responseSpec , produceableCharsets , ) ; checkResponseMediaType ( request , responseSpec , produceableMediaTypes , ) ; } return response ; } ) ; } , ) , ) . catch ( transaction . catch ) . catch ( errorHandler . bind ( null , transaction . id , responseSpec ) ) . then ( response => { if ( response . body && 'head' === request . method ) { log ( 'warning' , 'Body stripped:' , response . body instanceof Stream ? 'Stream' : response . body , ) ; return Object . keys ( response ) . filter ( key => 'body' !== key ) . reduce ( ( cleanedResponse , key ) => { cleanedResponse [ key ] = response [ key ] ; return cleanedResponse ; } , { } ) ; } return response ; } ) // Here sendBody is not binded since we need // the `operation` value at the exact moment // of the then stage execution . then ( response => sendBody ( { DEBUG_NODE_ENVS , ENV , API , ENCODERS , STRINGIFYERS , log , ajv , } , operation , response , ) , ) . then ( transaction . end ) , ) . catch ( handleFatalError ) ; }<CODESPLIT>0.17351488769054413<CODESPLIT>0.12746991217136383

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/jhermsmeier/node-gpt/blob/0e8c5d6b92183e23ece5fed29dece2a96d12b42e/example/verify.js#L84-L95<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function readBackupGPT ( primaryGPT ) { var backupGPT = new GPT ( { blockSize : primaryGPT . blockSize } ) var buffer = Buffer . alloc ( 33 * primaryGPT . blockSize ) var offset = ( ( primaryGPT . backupLBA - 32 ) * blockSize ) fs . readSync ( fd , buffer , 0 , buffer . length , offset ) backupGPT . parseBackup ( buffer ) return backupGPT }<CODESPLIT>0.1517944484949112<CODESPLIT>0.1539437621831894

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/Kashoo/synctos/blob/a6d59b4d4af2b837842d2107c57064c3fa12cc73/templates/sync-function/time-module.js#L315-L333<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function compareDates ( a , b ) { var aPieces = extractDatePieces ( a ) ; var bPieces = extractDatePieces ( b ) ; if ( aPieces === null || bPieces === null ) { return NaN ; } for ( var pieceIndex = 0 ; pieceIndex < aPieces . length ; pieceIndex ++ ) { if ( aPieces [ pieceIndex ] < bPieces [ pieceIndex ] ) { return - 1 ; } else if ( aPieces [ pieceIndex ] > bPieces [ pieceIndex ] ) { return 1 ; } } // If we got here, the two parameters represent the same date/point in time return 0 ; }<CODESPLIT>0.14539332687854767<CODESPLIT>0.1322670429944992

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/z-classic/zclassicjs/blob/5a399fd799a300cfda0d53bd7fdccca7523022e0/lib/transaction.js#L78-L86<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function addressToScript ( address , blockHeight , blockHash ) { // P2SH replay starts with a 's', or 'r' if ( address [ 1 ] === 's' || address [ 1 ] === 'r' ) { return mkScriptHashReplayScript ( address , blockHeight , blockHash ) ; } // P2PKH-replay is a replacement for P2PKH return mkPubkeyHashReplayScript ( address , blockHeight , blockHash ) ; }<CODESPLIT>0.15484172105789185<CODESPLIT>0.12028878927230835

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/DeadAlready/node-easy-pipe/blob/e739e052494cd6be96c95bc65e34442042243e7d/lib/pipeStream.js#L232-L240<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function addEventHandlers ( self ) { self . on ( 'error' , function ( d ) { var fn = self . _error ; self . _cleanUp ( ) ; if ( fn ) { fn ( 'pipeline[' + self . _nr + ']:"' + self . _command + '" failed with: ' + d . toString ( ) ) ; } } ) ; }<CODESPLIT>0.14392954111099243<CODESPLIT>0.12836791574954987

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/olegpolyakov/sendpulse/blob/7c8230e75c918a8a110f641ddb241006a1f86ac1/index.js#L618-L623<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function removeEmailFromAllBooks ( callback , email ) { if ( ( email === undefined ) || ( ! email . length ) ) { return callback ( returnError ( 'Empty email' ) ) ; } sendRequest ( 'emails/' + email , 'DELETE' , { } , true , callback ) ; }<CODESPLIT>0.13449044525623322<CODESPLIT>0.14183972775936127

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/olindata/node-puppet-hiera/blob/fda35ca55ae054641f428873c9f2f763ea302422/index.js#L24-L30<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function init ( adapter , config ) { if ( ! fs ) { var Adapter = require ( './adapters/' + adapter ) ; fs = new Adapter ( config ) ; } }<CODESPLIT>0.13302403688430786<CODESPLIT>0.1325753778219223

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/westoque/gauges-node/blob/4dfc962cc58fb03d97e0137d89703e321d4f8ec3/docs/jsdoc/templates/codeview/publish.js#L202-L220<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function makeSignature ( params ) { if ( ! params ) return "()" ; var signature = "(" + params . filter ( function ( $ ) { return ! / \w+\.\w+ / . test ( $ . name ) ; } ) . map ( function ( $ ) { var name = $ . isOptional ? '[' + $ . name + ']' : $ . name ; return name ; } ) . join ( ", " ) + ")" ; return signature ; }<CODESPLIT>0.1543261855840683<CODESPLIT>0.1375749558210373

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/cachewatch/node/blob/64182392c52db0d57d2210b921fd321333408873/lib/index.js#L22-L64<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function Cache ( key , opt ) { if ( ! ( this instanceof Cache ) ) return new Cache ( key , opt ) ; if ( key ) this . setToken ( key ) ; this . config = _ . defaults ( opt || { } , { protocol : 'https' , fragment : '_escaped_fragment_' , service : 'service.cache.watch' , path : '/' , sender : { method : 'get' , headers : { 'User-Agent' : 'CacheWatch Client' } , } , auth : 'x-cache-watch' , lengths : 150 , useragent : pack . config . useragent , url : pack . config . extencion } ) ; var that = this ; that . watch = function CacheWatch ( req , res , next ) { var query = querystring . parse ( url . parse ( req . url ) . query ) ; if ( that . isNot ( req , query ) || ! that . key ) return next ( ) ; that . get ( that . createUrl ( req , query ) , function ( err , resp , body ) { if ( err || that . res ( resp ) ) return next ( ) ; res . setHeader ( 'CacheWatch' , Cache . version ) ; res . setHeader ( 'last-modified' , resp . headers [ 'last-modified' ] ) ; res . setHeader ( 'content-type' , resp . headers [ 'content-type' ] ) ; res . send ( body ) ; } ) ; } ; }<CODESPLIT>0.12622076272964478<CODESPLIT>0.1393764317035675

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/trendmicro-frontend/react-liquid-gauge/blob/c8b24bd48a504539e25553a66097466f75917af6/docs/bundle.js#L33167-L33203<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function validateFragmentProps ( fragment ) { currentlyValidatingElement = fragment ; var _iteratorNormalCompletion = true ; var _didIteratorError = false ; var _iteratorError = undefined ; try { for ( var _iterator = Object . keys ( fragment . props ) [ Symbol . iterator ] ( ) , _step ; ! ( _iteratorNormalCompletion = ( _step = _iterator . next ( ) ) . done ) ; _iteratorNormalCompletion = true ) { var key = _step . value ; if ( ! VALID_FRAGMENT_PROPS . has ( key ) ) { warning ( false , 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.%s' , key , getStackAddendum ( ) ) ; break ; } } } catch ( err ) { _didIteratorError = true ; _iteratorError = err ; } finally { try { if ( ! _iteratorNormalCompletion && _iterator [ 'return' ] ) { _iterator [ 'return' ] ( ) ; } } finally { if ( _didIteratorError ) { throw _iteratorError ; } } } if ( fragment . ref !== null ) { warning ( false , 'Invalid attribute `ref` supplied to `React.Fragment`.%s' , getStackAddendum ( ) ) ; } currentlyValidatingElement = null ; }<CODESPLIT>0.15997573733329773<CODESPLIT>0.14343926310539246

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/LuccaSA/lui-build/blob/916343e0ba3c36c4e9f97761e402783ca68df44d/lib/to-sass.js#L17-L21<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( map ) { return '(' + Object . keys ( map ) . map ( function ( key ) { return key + ': ' + parseValue ( map [ key ] ) ; } ) . join ( ',' ) + ')' ; }<CODESPLIT>0.15270015597343445<CODESPLIT>0.1363717019557953

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/apache/cordova-lib/blob/dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5/src/hooks/HooksRunner.js#L103-L113<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function executeEventHandlersSerially ( hook , opts ) { var handlers = events . listeners ( hook ) ; if ( handlers . length ) { // Chain the handlers in series. return handlers . reduce ( function ( soFar , f ) { return soFar . then ( function ( ) { return f ( opts ) ; } ) ; } , Promise . resolve ( ) ) ; } else { return Promise . resolve ( ) ; // Nothing to do. } }<CODESPLIT>0.16494975984096527<CODESPLIT>0.1334664672613144

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/Kong/httpsnippet/blob/c780dad09b014a1bb28e463b4b058b2d40ae2124/src/targets/swift/helpers.js#L19-L29<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function concatArray ( arr , pretty , indentation , indentLevel ) { var currentIndent = buildString ( indentLevel , indentation ) var closingBraceIndent = buildString ( indentLevel - 1 , indentation ) var join = pretty ? ',\n' + currentIndent : ', ' if ( pretty ) { return '[\n' + currentIndent + arr . join ( join ) + '\n' + closingBraceIndent + ']' } else { return '[' + arr . join ( join ) + ']' } }<CODESPLIT>0.15064969658851624<CODESPLIT>0.13588805496692657

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/dynamoosejs/dynamoose/blob/cedea45b1bfc07f899de871c76da4ea0512a4a64/lib/Model.js#L89-L94<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( model , schema ) { debug ( 'applying statics' ) ; for ( const i in schema . statics ) { model [ i ] = schema . statics [ i ] . bind ( model ) ; } }<CODESPLIT>0.1616068333387375<CODESPLIT>0.14038489758968353

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/chakrit/jam/blob/cec411501db983f0627a4e83710d414c0ee8fc02/lib/jam.js#L48-L272<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function includeHelpers ( func ) { // ## jam.identity() // Simple function that passes the values it receives to the next function. // Useful if you need a `process.nextTick` inserted in-between your call chain. func . identity = function ( next ) { function _identity ( next ) { var args = arguments ; tick ( function ( ) { next . apply ( this , replaceHead ( args , null ) ) ; } ) ; } // This function can also be passed to jam verbatim. return ( typeof next === 'function' ) ? _identity . apply ( this , arguments ) : _identity ; } ; // ## jam.nextTick() // Alias for `.identity`. Use when you need a `process.nextTick` inserted in-between // your call chain. func . nextTick = func . identity // ## jam.return( [args...] ) // Returns a set of values to the next function in the chain. Useful when you want to // pass in the next function verbatim without wrapping it in a `function() { }` just // to pass values into it. func . return = function ( ) { var args = toArgs ( arguments ) ; return function ( next ) { args . unshift ( null ) ; next . apply ( this , args ) ; } ; } ; // ## jam.null() // Similar to `.identity` but absorbs all arguments that has been passed to it and // forward nothing to the next function. Effectively nullifying any arguments passed // from previous jam call. //  // Like `jam.identity`, this function can be passed to the jam chain verbatim. func . null = function ( next ) { function _null ( next ) { next ( ) ; } return ( typeof next === 'function' ) ? _null . call ( this , next ) : _null ; } ; // ## jam.call( function, [args...] ) // Convenience for calling functions that accepts arguments in standard node.js // convention. Since jam insert `next` as first argument, most functions cannot be // passed directly into the jam chain, thus this helper function. //  // If no `args` is given, this function passes arguments given to `next()` call from // previous function directly to the function (with proper callback) placement). //  // Use this in combination with `jam.return` or `jam.null` if you want to control the // arguments that are passed to the function. func . call = function ( func ) { ensureFunc ( func , 'function' ) ; var args = toArgs ( arguments ) ; args . shift ( ) ; // func if ( args . length ) { // use provided arguments return function ( next ) { args . push ( next ) ; func . apply ( this , args ) ; } ; } else { // use passed-in arguments during chain resolution return function ( next ) { args = toArgs ( arguments ) ; args . shift ( ) ; // move next to last position args . push ( next ) ; func . apply ( this , args ) ; } ; } } ; // ## jam.each( array, iterator( next, element, index ) ) // Execute the given `iterator` function for each element given in the `array`. The // iterator is given a `next` function and the element to act on. The next step in the // chain will receive the original array passed verbatim so you can chain multiple // `.each` calls to act on the same array. //  // You can also pass `arguments` and `"strings"` as an array or you can omit the array // entirely, in which case this method will assume that the previous chain step // returns something that looks like an array as its first result. //  // Under the hood, a JAM step is added for each element. So the iterator will be // called serially, one after another finish. A parallel version maybe added in the // future. func . each = function ( array , iterator ) { if ( typeof array === 'function' ) { iterator = array ; array = null } else { ensureArray ( array , 'array' ) ; } ensureFunc ( iterator , 'iterator' ) ; return function ( next , array_ ) { var arr = array || array_ ; // Builds another JAM chain internally var chain = jam ( jam . identity ) , count = arr . length ; for ( var i = 0 ; i < count ; i ++ ) ( function ( element , i ) { chain = chain ( function ( next ) { iterator ( next , element , i ) ; } ) ; } ) ( arr [ i ] , i ) ; chain = chain ( function ( next ) { next ( null , arr ) ; } ) ; return chain ( next ) ; } ; } ; // ## jam.map( array, iterator( next, element, index ) ) // Works exactly like the `each` helper but if a value is passed to the iterator's // `next` function, it is collected into a new array which will be passed to the next // function in the JAM chain after `map`. //  // Like with `each`, you can omit the `array` input, in which case this method will // assume that the previous chain step returns something that looks like an array as // its first result. func . map = function ( array , iterator ) { if ( typeof array === 'function' ) { iterator = array ; array = null ; } else { ensureArray ( array , 'array' ) ; } ensureFunc ( iterator , 'iterator' ) ; return function ( next , array_ ) { var arr = array || array_ ; // Builds another JAM chain internally and collect results. // TODO: Dry with .each? var chain = jam ( jam . identity ) , count = arr . length , result = [ ] ; for ( var i = 0 ; i < count ; i ++ ) ( function ( element , i ) { chain = chain ( function ( next , previous ) { result . push ( previous ) ; iterator ( next , element , i ) ; } ) ; } ) ( arr [ i ] , i ) ; chain = chain ( function ( next , last ) { result . push ( last ) ; result . shift ( ) ; // discard first undefined element next ( null , result ) ; } ) ; return chain ( next ) ; } ; } ; // ## jam.timeout( timeout ) // Pauses the chain for the specified `timeout` using `setTimeout`. Useful for // inserting a delay in-between a long jam chain. func . timeout = function ( timeout ) { ensureNum ( timeout , 'timeout' ) ; return function ( next ) { var args = replaceHead ( arguments , null ) ; setTimeout ( function ( ) { next . apply ( this , args ) ; } , timeout ) ; } ; } ; // ## jam.promise( [chain] ) // Returns a JAM promise, useful when you are starting an asynchronous call outside of // the JAM chain itself but wants the callback to call into the chain. In other words, // this allow you to put a 'waiting point' (aka promise?) into existing JAM chain that // waits for the initial call to finish and also pass any arguments passed to the // callback to the next step in the JAM chain as well. // // This function will returns a callback that automatically bridges into the JAM // chain. You can pass the returned callback to any asynchronous function and the JAM // chain (at the point of calling .promise()) will wait for that asynchronous function // to finish effectively creating a 'waiting point'. // // Additionally, any arguments passed to the callback are forwarded to the next call // in the JAM chain as well. If errors are passed, then it is fast-forwarded to the // last handler normally like normal JAM steps. func . promise = function ( chain ) { chain = typeof chain === 'function' ? chain : // chain is supplied typeof this === 'function' ? this : // called from the chain variable ensureFunc ( chain , 'chain' ) ; // fails if ( typeof chain === 'undefined' && typeof this === 'function' ) { chain = this ; } var args = null , next = null ; chain ( function ( next_ ) { if ( args ) return next_ . apply ( this , args ) ; // callback already called next = next_ ; // wait for callback } ) ; return function ( ) { if ( next ) return next . apply ( this , arguments ) ; // chain promise already called args = arguments ; // wait for chain to call the promise } ; } ; // TODO: noError() ? or absorbError() return func ; }<CODESPLIT>0.16282398998737335<CODESPLIT>0.15001873672008514

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/compute-io/msum/blob/c57904c821ddd22da73d9cb16bb5cb52fcaa71e9/lib/index.js#L53-L145<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function msum ( arr , W , options ) { var copy = true , clbk , len , sum , dropVal , out , i ; if ( ! isArray ( arr ) ) { throw new TypeError ( 'msum()::invalid input argument. Must provide an array. Value: `' + arr + '`.' ) ; } if ( ! isPositiveInteger ( W ) ) { throw new TypeError ( 'msum()::invalid input argument. Window must be a positive integer. Value: `' + W + '`.' ) ; } if ( arguments . length > 2 ) { if ( ! isObject ( options ) ) { throw new TypeError ( 'msum()::invalid input argument. Options must be an object. Value: `' + options + '`.' ) ; } if ( options . hasOwnProperty ( 'accessor' ) ) { clbk = options . accessor ; if ( ! isFunction ( clbk ) ) { throw new TypeError ( 'msum()::invalid option. Accessor option must be a function. Value: `' + clbk + '`.' ) ; } } if ( options . hasOwnProperty ( 'copy' ) ) { copy = options . copy ; if ( ! isBoolean ( copy ) ) { throw new TypeError ( 'msum()::invalid option. Copy option must be a boolean primitive. Value: `' + copy + '`.' ) ; } } } if ( W > arr . length ) { throw new Error ( 'msum()::invalid input argument. Window cannot exceed the array length.' ) ; } len = arr . length ; sum = 0 ; if ( copy && ! clbk ) { // Case 1: numeric array and return a copy... len = len - W + 1 ; out = new Array ( len ) ; // Calculate the sum for the first window... for ( i = 0 ; i < W ; i ++ ) { sum += arr [ i ] ; } out [ 0 ] = sum ; // Calculate sums for the remaining windows... for ( i = 0 ; i < len - 1 ; i ++ ) { sum += arr [ i + W ] - arr [ i ] ; out [ i + 1 ] = sum ; } return out ; } else if ( clbk ) { if ( copy ) { // Case 2: non-numeric array and return a copy... out = new Array ( len ) ; for ( i = 0 ; i < len ; i ++ ) { out [ i ] = clbk ( arr [ i ] ) ; } } else { // Case 3: non-numeric array and mutate the input array... out = arr ; for ( i = 0 ; i < len ; i ++ ) { out [ i ] = clbk ( arr [ i ] ) ; } } } else { // Case 4: numeric array and mutate the input array... out = arr ; } len = len - W + 1 ; // Calculate the sum for the first window... for ( i = 0 ; i < W ; i ++ ) { sum += out [ i ] ; } dropVal = out [ 0 ] ; out [ 0 ] = sum ; // Calculate sums for the remaining windows... for ( i = 1 ; i < len ; i ++ ) { sum += out [ i + W - 1 ] - dropVal ; dropVal = out [ i ] ; out [ i ] = sum ; } // Trim the output array: out . length = len ; return out ; }<CODESPLIT>0.15891969203948975<CODESPLIT>0.1369856595993042

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/YR/data-store/blob/bf8f581f850b9ebcb0fd319001ca69d0d9ff967f/src/lib/DataStore.js#L519-L542<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function serialise ( key , data , config ) { if ( isPlainObject ( data ) ) { const obj = { } ; for ( const prop in data ) { const keyChain = key ? ` ${ key } ${ prop } ` : prop ; const value = data [ prop ] ; if ( config [ keyChain ] !== false ) { if ( isPlainObject ( value ) ) { obj [ prop ] = serialise ( keyChain , value , config ) ; } else if ( value != null && typeof value === 'object' && 'toJSON' in value ) { obj [ prop ] = value . toJSON ( ) ; } else { obj [ prop ] = value ; } } } return obj ; } return config [ key ] !== false ? data : null ; }<CODESPLIT>0.17354241013526917<CODESPLIT>0.13067738711833954

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/benkeen/d3pie/blob/24b488a4f44226c407186c007365ab775f92a426/website/libs/handlebars.dev.js#L2656-L2667<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( paramSize , params , useRegister ) { var options = '{' + this . setupOptions ( paramSize , params ) . join ( ',' ) + '}' ; if ( useRegister ) { this . useRegister ( 'options' ) ; params . push ( 'options' ) ; return 'options=' + options ; } else { params . push ( options ) ; return '' ; } }<CODESPLIT>0.11550744622945786<CODESPLIT>0.1531609147787094

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/yeezon/yhsd-api-node/blob/d46be67c1dff6bb86232e4ee491e6d5228a74489/lib/Auth.js#L21-L43<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( options ) { if ( arguments . length < 1 || ! options . appKey || ! options . appSecret ) { throw paramError ; } if ( ! options . private ) { if ( ! options . callbackUrl ) { throw paramError ; } options . scope || ( options . scope = [ 'read_basic' ] ) ; } this . app_key = options . appKey || '' ; this . app_secret = options . appSecret || '' ; this . private = options . private || false ; this . callback_url = options . callbackUrl || '' ; this . scope = options . scope || '' ; this . redirect_url = options . redirectUrl || '' ; this . protocol = options . protocol || config . httpProtocol ; this . host = options . host || config . appHost ; this . _request = new Request ( { protocol : this . protocol , } ) ; }<CODESPLIT>0.15496636927127838<CODESPLIT>0.13138039410114288

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/intelligo-systems/intelligo.js/blob/9e75d48214fb41d346462f5d886bd92cc9956df6/dist/multilabel/Homer.js#L102-L116<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( dataset ) { dataset = dataset . map ( function ( datum ) { var normalizedLabels = multilabelutils . normalizeOutputLabels ( datum . output ) ; for ( var i in normalizedLabels ) this . allClasses [ normalizedLabels [ i ] ] = true ; return { input : datum . input , output : normalizedLabels . map ( this . splitLabel ) } } , this ) ; // [ [ 'Offer', 'Leased Car', 'Without leased car' ], [ 'Offer', 'Working Hours', '9 hours' ] ] return this . trainBatchRecursive ( dataset , this . root ) ; }<CODESPLIT>0.15533865988254547<CODESPLIT>0.13114629685878754

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/HydraJS/HydraJS/blob/ef3ede4aebd29081fe960eb86a37a1a4bf571b2d/src/libs/Module.js#L483-L496<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function stop ( sModuleId , sInstanceId ) { const oModules = getModules ( ) ; var oModule ; oModule = oModules [ sModuleId ] ; if ( isTypeOf ( oModule , sNotDefined ) ) { return false ; } if ( ! isTypeOf ( sInstanceId , sNotDefined ) ) { _singleModuleStop ( oModule , sInstanceId ) ; } else { _multiModuleStop ( oModule ) ; } return true ; }<CODESPLIT>0.1672297865152359<CODESPLIT>0.12563811242580414

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/wavesoft/gulp-jbb-profile/blob/3e9bc0ca733ae0325a09a461f504fc847e256f7a/lib/ProfileObject.js#L145-L171<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( instVar , prefix ) { var code = "[" , getCode = "" , prop = "" , defaultGet = "$inst.$prop" ; if ( this . defaultGet ) defaultGet = defaultGet ; for ( var i = 0 , l = this . properties . length ; i < l ; ++ i ) { prop = this . properties [ i ] ; if ( i > 0 ) code += "," ; if ( this . propCustomGet [ prop ] ) { getCode = this . propCustomGet [ prop ] . replace ( / \$inst / g , instVar ) . replace ( / \$prop / g , prop ) ; } else { getCode = defaultGet . replace ( / \$inst / g , instVar ) . replace ( / \$prop / g , prop ) ; } // Check if we should embed this property if ( this . embed . indexOf ( prop ) === - 1 ) { code += "\n" + prefix + getCode ; } else { code += "\n" + prefix + "new BinaryEncoder.FileResource( " + getCode + " )" ; } } code += "]" ; return code ; }<CODESPLIT>0.1535043865442276<CODESPLIT>0.17017613351345062

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/mdns-js/node-dns-js/blob/212b6c903db40bcd501af741e51cd20d676acbc9/lib/dnsrecord.js#L304-L311<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function asAAAA ( consumer , packet ) { var data = '' ; for ( var i = 0 ; i < 7 ; i ++ ) { data += consumer . short ( ) . toString ( 16 ) + ':' ; } data += consumer . short ( ) . toString ( 16 ) ; packet . address = data ; }<CODESPLIT>0.13438370823860168<CODESPLIT>0.14661945402622223

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/avajs/babel-preset-stage-4/blob/9e4b45c0b5c33c76e0e1ed834eacefe6e94a41e1/plugins/best-match.js#L4-L20<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getClosestVersion ( ) { if ( ! process . versions . v8 ) { // Assume compatibility with Node.js 8.9.4 return 'v8-6.1' ; } const v8 = parseFloat ( process . versions . v8 ) ; if ( v8 >= 6.6 ) { return 'v8-6.6' ; } if ( v8 >= 6.2 ) { return 'v8-6.2' ; } return 'v8-6.1' ; }<CODESPLIT>0.16950498521327972<CODESPLIT>0.12770743668079376

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/mpetroff/pannellum/blob/59893bcea4629be059ad3e59c3fa5bde438d292b/src/js/libpannellum.js#L813-L838<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function multiresDraw ( ) { if ( ! program . drawInProgress ) { program . drawInProgress = true ; gl . clear ( gl . COLOR_BUFFER_BIT ) ; for ( var i = 0 ; i < program . currentNodes . length ; i ++ ) { if ( program . currentNodes [ i ] . textureLoaded > 1 ) { //var color = program.currentNodes[i].color; //gl.uniform4f(program.colorUniform, color[0], color[1], color[2], 1.0); // Bind vertex buffer and pass vertices to WebGL gl . bindBuffer ( gl . ARRAY_BUFFER , cubeVertBuf ) ; gl . bufferData ( gl . ARRAY_BUFFER , new Float32Array ( program . currentNodes [ i ] . vertices ) , gl . STATIC_DRAW ) ; gl . vertexAttribPointer ( program . vertPosLocation , 3 , gl . FLOAT , false , 0 , 0 ) ; // Prep for texture gl . bindBuffer ( gl . ARRAY_BUFFER , cubeVertTexCoordBuf ) ; gl . vertexAttribPointer ( program . texCoordLocation , 2 , gl . FLOAT , false , 0 , 0 ) ; // Bind texture and draw tile gl . bindTexture ( gl . TEXTURE_2D , program . currentNodes [ i ] . texture ) ; // Bind program.currentNodes[i].texture to TEXTURE0 gl . drawElements ( gl . TRIANGLES , 6 , gl . UNSIGNED_SHORT , 0 ) ; } } program . drawInProgress = false ; } }<CODESPLIT>0.1741544008255005<CODESPLIT>0.13465197384357452

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/YR/data-store/blob/bf8f581f850b9ebcb0fd319001ca69d0d9ff967f/src/lib/DataStore.js#L506-L510<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function reset ( store , data ) { store . debug ( 'reset' ) ; store . _data = data ; store . changed = true ; }<CODESPLIT>0.17790943384170532<CODESPLIT>0.12620390951633453

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/ralt/tartempion/blob/0de497437261229575d40f49f20f9630bf6053e2/lib/routes.js#L25-L51<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function addRoutes ( pies , pie , routes , app ) { // Add the GET routes if ( 'get' in routes ) { routes . get . forEach ( function ( route ) { Object . keys ( route ) . forEach ( function ( r ) { var middlewares = true ; if ( typeof route [ r ] === 'string' ) { middlewares = false ; } loadRoute ( app , 'get' , r , pies [ pie ] . path , route [ r ] , middlewares ) ; } ) ; } ) ; } // Add the POST routes if ( 'post' in routes ) { routes . post . forEach ( function ( route ) { Object . keys ( route ) . forEach ( function ( r ) { var middlewares = true ; if ( typeof route [ r ] === 'string' ) { middlewares = false ; } loadRoute ( app , 'post' , r , pies [ pie ] . path , route [ r ] , middlewares ) ; } ) ; } ) ; } }<CODESPLIT>0.17809413373470306<CODESPLIT>0.1239016056060791

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/GitbookIO/theme-default/blob/a8e920453dc8e4eb522840b61606486622848099/src/js/theme/navigation.js#L168-L174<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getChapterHash ( $chapter ) { var $link = $chapter . children ( 'a' ) , hash = $link . attr ( 'href' ) . split ( '#' ) [ 1 ] ; if ( hash ) hash = '#' + hash ; return ( ! ! hash ) ? hash : '' ; }<CODESPLIT>0.15837299823760986<CODESPLIT>0.12479634582996368

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/util/Format.js#L132-L137<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( format ) { var args = Ext . toArray ( arguments , 1 ) ; return format . replace ( Ext . util . Format . formatRe , function ( m , i ) { return args [ i ] ; } ) ; }<CODESPLIT>0.1349187195301056<CODESPLIT>0.14576181769371033

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/mixin/Sortable.js#L271-L295<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( ) { var sorters = this . getSorters ( ) . items ; this . sortFn = function ( r1 , r2 ) { var ln = sorters . length , result , i ; // We loop over each sorter and check if r1 should be before or after r2 for ( i = 0 ; i < ln ; i ++ ) { result = sorters [ i ] . sort . call ( this , r1 , r2 ) ; // If the result is -1 or 1 at this point it means that the sort is done. // Only if they are equal (0) we continue to see if a next sort function // actually might find a winner. if ( result !== 0 ) { break ; } } return result ; } ; this . dirtySortFn = false ; return this . sortFn ; }<CODESPLIT>0.14617417752742767<CODESPLIT>0.12297362834215164

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/canjs/can-map/blob/f2083ca4ef9f2c193aeaf15e013c956aa64c3a77/can-map.js#L277-L282<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( attr ) { if ( ! unobservable [ attr ] && ! this . _computedAttrs [ attr ] ) { ObservationRecorder . add ( this , attr ) ; } return this . ___get ( attr ) ; }<CODESPLIT>0.15130658447742462<CODESPLIT>0.14110586047172546

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/dimichgh/orka/blob/bc8dec66bd8f35ac7fbc564728c628edaa905498/lib/pub-sub.js#L180-L187<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function PubSub ( name , options ) { EventEmitter . call ( this ) ; this . name = name ; this . topics = { } ; this . options = options || { strict : true } ; }<CODESPLIT>0.1597118228673935<CODESPLIT>0.12249364703893661

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/snapptop/ninjs-lodash/blob/fab253b7d96cc9bb3f2a1057efff2684c200bcee/lib/cproc.js#L32-L34<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function execFile ( options , callback ) { return cmd ( _ . assign ( options , { type : 'execFile' } ) , _ . cb ( callback ) ) }<CODESPLIT>0.14735370874404907<CODESPLIT>0.13481128215789795

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L40286-L40291<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function fixTokenKind ( tokenInfo , container ) { if ( ts . isToken ( container ) && tokenInfo . token . kind !== container . kind ) { tokenInfo . token . kind = container . kind ; } return tokenInfo ; }<CODESPLIT>0.16556701064109802<CODESPLIT>0.14023655652999878

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/alvarotrigo/react-fullpage/blob/5a11fb5211e5706da81f2874516f023dc6e5aa88/example/dist/bundle.js#L19891-L19901<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function flushSync ( fn , a ) { ! ! isRendering ? invariant ( false , 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.' ) : void 0 ; var previousIsBatchingUpdates = isBatchingUpdates ; isBatchingUpdates = true ; try { return syncUpdates ( fn , a ) ; } finally { isBatchingUpdates = previousIsBatchingUpdates ; performSyncWork ( ) ; } }<CODESPLIT>0.13097970187664032<CODESPLIT>0.16978837549686432

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L13384-L13386<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function visit ( node , fn ) { return node . nodes ? mapVisit ( node . nodes , fn ) : fn ( node ) ; }<CODESPLIT>0.16849084198474884<CODESPLIT>0.13862207531929016

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/tunnckoCore/hela/blob/f78d60daef03d52288bd1c4edd88e30f6b206a36/src/cli.js#L50-L65<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>async function run ( ) { const pkg = await readJson ( path . join ( options . cwd , 'package.json' ) ) const tasks = await hela ( { pkg , ... options } ) const name = options . taskName if ( Object . keys ( tasks ) . length === 0 ) { throw new Error ( 'hela: no tasks' ) } const hasOwn = ( o , k ) => Object . prototype . hasOwnProperty . call ( o , k ) if ( ! hasOwn ( tasks , name ) ) { throw new Error ( ` ${ name } ` ) } return tasks [ name ] ( ) }<CODESPLIT>0.14528398215770721<CODESPLIT>0.14410920441150665

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/shinuza/captain/blob/cbc7473f82d0c593bb2f5a250b66266a40d6452d/bin/captain.js#L302-L312<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function theme ( target ) { if ( target === true ) { program . help ( ) ; } if ( helpers . isCaptainProject ( ) ) { helpers . copyR ( [ join ( 'themes' , target ) ] , '.' ) ; } else { terminal . abort ( 'Not a Captain project' ) ; } }<CODESPLIT>0.15713468194007874<CODESPLIT>0.13226370513439178

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/Yoast/eslint-plugin/blob/d935d013064d066cc6e67d46b9b240fc228fdc51/lib/rules/comment-starting-capital.js#L33-L46<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getFirstLetter ( text ) { var matches = text . match ( firstLetterRegex ) ; if ( null === matches ) { return '' ; } // Ignore JSDoc blocks if ( '@' === matches [ 1 ] ) { return '' ; } return matches [ 0 ] ; }<CODESPLIT>0.15145839750766754<CODESPLIT>0.11719458550214767

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/yamadapc/jsdoctest/blob/ccd6cdbff8a4db98d20da8ac1868558a45913005/lib/get-example-code.js#L16-L34<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function getExampleCode ( comment ) { var expectedResult = comment . expectedResult ; var isAsync = comment . isAsync ; var testCase = comment . testCase ; if ( isAsync ) { return '\nfunction cb(err, result) {' + 'if(err) return done(err);' + 'result.should.eql(' + expectedResult + ');' + 'done();' + '}\n' + 'var returnValue = ' + testCase + ';' + 'if(returnValue && returnValue.then && typeof returnValue.then === \'function\') {' + 'returnValue.then(cb.bind(null, null), cb);' + '}' ; } else { return '(' + testCase + ').should.eql(' + expectedResult + ');' ; } }<CODESPLIT>0.16048891842365265<CODESPLIT>0.13549526035785675

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/acarl005/join-monster/blob/8db8b54aaefd2fd975d63e2ab3ec05922e25118c/src/array-to-connection.js#L8-L83<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function arrToConnection ( data , sqlAST ) { // use "post-order" tree traversal for ( let astChild of sqlAST . children || [ ] ) { if ( Array . isArray ( data ) ) { for ( let dataItem of data ) { recurseOnObjInData ( dataItem , astChild ) } } else if ( data ) { recurseOnObjInData ( data , astChild ) } } const pageInfo = { hasNextPage : false , hasPreviousPage : false } if ( ! data ) { if ( sqlAST . paginate ) { return { pageInfo , edges : [ ] } } return null } // is cases where pagination was done, take the data and convert to the connection object // if any two fields happen to become a reference to the same object (when their `uniqueKey`s are the same), // we must prevent the recursive processing from visting the same object twice, because mutating the object the first // time changes it everywhere. we'll set the `_paginated` property to true to prevent this if ( sqlAST . paginate && ! data . _paginated ) { if ( sqlAST . sortKey || idx ( sqlAST , _ => _ . junction . sortKey ) ) { if ( idx ( sqlAST , _ => _ . args . first ) ) { // we fetched an extra one in order to determine if there is a next page, if there is one, pop off that extra if ( data . length > sqlAST . args . first ) { pageInfo . hasNextPage = true data . pop ( ) } } else if ( sqlAST . args && sqlAST . args . last ) { // if backward paging, do the same, but also reverse it if ( data . length > sqlAST . args . last ) { pageInfo . hasPreviousPage = true data . pop ( ) } data . reverse ( ) } // convert nodes to edges and compute the cursor for each // TODO: only compute all the cursor if asked for them const sortKey = sqlAST . sortKey || sqlAST . junction . sortKey const edges = data . map ( obj => { const cursor = { } const key = sortKey . key for ( let column of wrap ( key ) ) { cursor [ column ] = obj [ column ] } return { cursor : objToCursor ( cursor ) , node : obj } } ) if ( data . length ) { pageInfo . startCursor = edges [ 0 ] . cursor pageInfo . endCursor = last ( edges ) . cursor } return { edges , pageInfo , _paginated : true } } if ( sqlAST . orderBy || ( sqlAST . junction && sqlAST . junction . orderBy ) ) { let offset = 0 if ( idx ( sqlAST , _ => _ . args . after ) ) { offset = cursorToOffset ( sqlAST . args . after ) + 1 } // $total was a special column for determining the total number of items const arrayLength = data [ 0 ] && parseInt ( data [ 0 ] . $total , 10 ) const connection = connectionFromArraySlice ( data , sqlAST . args || { } , { sliceStart : offset , arrayLength } ) connection . total = arrayLength || 0 connection . _paginated = true return connection } } return data }<CODESPLIT>0.13396748900413513<CODESPLIT>0.15431314706802368

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/FCOO/fcoo-grunt-plugin/blob/03d8b5c0b493244b4db3d08844554b31306ca8bf/grunt/tasks/_github.js#L17-L52<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function writeGithubActionList ( ) { var newVersion , tagMessage ; _console . writelnYellow ( '**************************************************' ) ; _console . writelnYellow ( 'ACTIONS:' ) ; if ( grunt . config ( 'build' ) ) _console . writelnYellow ( '- Build/compile the ' + ( options . isApplication ? 'application' : 'packages' ) ) ; if ( grunt . config ( 'newVersion' ) != 'none' ) { newVersion = semver . inc ( options . currentVersion , grunt . config ( 'newVersion' ) ) ; _console . writelnYellow ( '- Bump \'version: "' + newVersion + '"\' to bower.json and package.json' ) ; } if ( grunt . config ( 'commit' ) == 'commit' ) _console . writelnYellow ( '- Commit staged changes to a new snapshot. Message="' + grunt . config ( 'commitMessage' ) + '"' ) ; else _console . writelnYellow ( '- Amend/combine staged changes with the previous commit' ) ; if ( grunt . config ( 'newVersion' ) != 'none' ) { tagMessage = grunt . config ( 'tagMessage' ) ; _console . writelnYellow ( '- Create new tag="' + newVersion + ( tagMessage ? ': ' + tagMessage : '' ) + '"' ) ; } if ( options . haveGhPages ) _console . writelnYellow ( '- Merge "master" branch into "gh-pages" branch' ) ; else grunt . config . set ( 'release.options.afterRelease' , [ ] ) ; //Remove all git merge commands if ( grunt . config ( 'newVersion' ) == 'none' ) _console . writelnYellow ( '- Push all branches to GitHub' ) ; else _console . writelnYellow ( '- Push all branches and tags to GitHub' ) ; _console . writelnYellow ( '**************************************************' ) ; }<CODESPLIT>0.11123497784137726<CODESPLIT>0.15619488060474396

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/mpetroff/pannellum/blob/59893bcea4629be059ad3e59c3fa5bde438d292b/src/js/libpannellum.js#L1264-L1282<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function checkInView ( m , v ) { var vpp = applyRotPerspToVec ( m , v ) ; var winX = vpp [ 0 ] * vpp [ 3 ] ; var winY = vpp [ 1 ] * vpp [ 3 ] ; var winZ = vpp [ 2 ] * vpp [ 3 ] ; var ret = [ 0 , 0 , 0 ] ; if ( winX < - 1 ) ret [ 0 ] = - 1 ; if ( winX > 1 ) ret [ 0 ] = 1 ; if ( winY < - 1 ) ret [ 1 ] = - 1 ; if ( winY > 1 ) ret [ 1 ] = 1 ; if ( winZ < - 1 || winZ > 1 ) ret [ 2 ] = 1 ; return ret ; }<CODESPLIT>0.10762146860361099<CODESPLIT>0.16865846514701843

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L13480-L13484<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function textRegex ( pattern ) { var notStr = regexNot . create ( pattern , { contains : true , strictClose : false } ) ; var prefix = '(?:[\\^]|\\\\|' ; return toRegex ( prefix + notStr + ')' , { strictClose : false } ) ; }<CODESPLIT>0.1264318972826004<CODESPLIT>0.1582815945148468

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/apache/cordova-lib/blob/dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5/spec/cordova/fixtures/projects/platformApi/platforms/windows/cordova/lib/AppxManifest.js#L720-L731<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ensureUniqueCapabilities ( capabilities ) { var uniqueCapabilities = [ ] ; capabilities . getchildren ( ) . forEach ( function ( el ) { var name = el . attrib . Name ; if ( uniqueCapabilities . indexOf ( name ) !== - 1 ) { capabilities . remove ( el ) ; } else { uniqueCapabilities . push ( name ) ; } } ) ; }<CODESPLIT>0.1492840200662613<CODESPLIT>0.13431039452552795

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/bholloway/browserify-nginject/blob/42cff52081b66d77e4e7fac923d4d824de13cfd3/lib/process-node.js#L67-L73<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function offset ( array , node ) { var nodeIndex = array . indexOf ( node ) ; var returnIndex = array . map ( test . isReturnStatement ) . indexOf ( true ) ; return ( returnIndex < 0 ) ? + 1 : ( returnIndex > nodeIndex ) ? + 1 : ( returnIndex - nodeIndex - 1 ) ; }<CODESPLIT>0.1680014431476593<CODESPLIT>0.1340571492910385

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/intelligo-systems/intelligo.js/blob/9e75d48214fb41d346462f5d886bd92cc9956df6/dist/multilabel/PassiveAggressiveHash.js#L194-L202<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( classes ) { classes = hash . normalized ( classes ) ; for ( var aClass in classes ) { if ( ! ( aClass in this . weights ) ) { this . weights [ aClass ] = { } ; this . weights_sum [ aClass ] = { } ; } } }<CODESPLIT>0.17198093235492706<CODESPLIT>0.12277624756097794

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/views/Feed/FeedExtra.js#L18-L50<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function FeedExtra ( props ) { const { children , className , content , images , text } = props const classes = cx ( useKeyOnly ( images , 'images' ) , useKeyOnly ( content || text , 'text' ) , 'extra' , className , ) const rest = getUnhandledProps ( FeedExtra , props ) const ElementType = getElementType ( FeedExtra , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } >           { children }         < / ElementType > ) } // TODO need a "collection factory" to handle creating multiple image elements and their keys const imageElements = _ . map ( images , ( image , index ) => { const key = [ index , image ] . join ( '-' ) return createHTMLImage ( image , { key } ) } ) return ( < ElementType { ... rest } className = { classes } >         { content }         { imageElements }       < / ElementType > ) }<CODESPLIT>0.16662263870239258<CODESPLIT>0.132241889834404

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/mpetroff/pannellum/blob/59893bcea4629be059ad3e59c3fa5bde438d292b/src/js/pannellum.js#L2229-L2301<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function loadScene ( sceneId , targetPitch , targetYaw , targetHfov , fadeDone ) { loaded = false ; animatedMove = { } ; // Set up fade if specified var fadeImg , workingPitch , workingYaw , workingHfov ; if ( config . sceneFadeDuration && ! fadeDone ) { var data = renderer . render ( config . pitch * Math . PI / 180 , config . yaw * Math . PI / 180 , config . hfov * Math . PI / 180 , { returnImage : true } ) ; if ( data !== undefined ) { fadeImg = new Image ( ) ; fadeImg . className = 'pnlm-fade-img' ; fadeImg . style . transition = 'opacity ' + ( config . sceneFadeDuration / 1000 ) + 's' ; fadeImg . style . width = '100%' ; fadeImg . style . height = '100%' ; fadeImg . onload = function ( ) { loadScene ( sceneId , targetPitch , targetYaw , targetHfov , true ) ; } ; fadeImg . src = data ; renderContainer . appendChild ( fadeImg ) ; renderer . fadeImg = fadeImg ; return ; } } // Set new pointing if ( targetPitch === 'same' ) { workingPitch = config . pitch ; } else { workingPitch = targetPitch ; } if ( targetYaw === 'same' ) { workingYaw = config . yaw ; } else if ( targetYaw === 'sameAzimuth' ) { workingYaw = config . yaw + ( config . northOffset || 0 ) - ( initialConfig . scenes [ sceneId ] . northOffset || 0 ) ; } else { workingYaw = targetYaw ; } if ( targetHfov === 'same' ) { workingHfov = config . hfov ; } else { workingHfov = targetHfov ; } // Destroy hot spots from previous scene destroyHotSpots ( ) ; // Create the new config for the scene mergeConfig ( sceneId ) ; // Stop motion speed . yaw = speed . pitch = speed . hfov = 0 ; // Reload scene processOptions ( ) ; if ( workingPitch !== undefined ) { config . pitch = workingPitch ; } if ( workingYaw !== undefined ) { config . yaw = workingYaw ; } if ( workingHfov !== undefined ) { config . hfov = workingHfov ; } fireEvent ( 'scenechange' , sceneId ) ; load ( ) ; // Properly handle switching to dynamic scenes update = config . dynamicUpdate === true ; if ( config . dynamic ) { panoImage = config . panorama ; onImageLoad ( ) ; } }<CODESPLIT>0.16486123204231262<CODESPLIT>0.13790231943130493

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L12733-L12738<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( keyName , increment ) { if ( Ember . isNone ( increment ) ) { increment = 1 ; } Ember . assert ( "Must pass a numeric value to incrementProperty" , ( ! isNaN ( parseFloat ( increment ) ) && isFinite ( increment ) ) ) ; set ( this , keyName , ( get ( this , keyName ) || 0 ) + increment ) ; return get ( this , keyName ) ; }<CODESPLIT>0.1634400486946106<CODESPLIT>0.18395069241523743

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L7322-L7335<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( type , records ) { var manyArray = DS . ManyArray . create ( { type : type , content : records , store : this . store } ) ; forEach ( records , function ( record ) { var arrays = this . recordArraysForRecord ( record ) ; arrays . add ( manyArray ) ; } , this ) ; return manyArray ; }<CODESPLIT>0.13210679590702057<CODESPLIT>0.17430421710014343

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/cranbee/template/blob/84044ca9124c5eb4dc28d8e0c8d366c7abd761fa/src/packer.js#L12-L29<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function packNode ( node ) { if ( node . type === "#" ) { return node . text ; } let item = [ node . type ] ; let hasProps = ( Object . keys ( node . props ) . length !== 0 ) ; if ( hasProps ) { item . push ( node . props ) ; } if ( node . children . length === 0 ) { return item ; } if ( ! hasProps ) { item . push ( 0 ) ; } node . children . forEach ( child => item . push ( packNode ( child ) ) ) ; return item ; }<CODESPLIT>0.16484200954437256<CODESPLIT>0.12993831932544708

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/LoadMask.js#L99-L109<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( newMessage ) { var cls = Ext . baseCSSPrefix + 'has-message' ; if ( newMessage ) { this . addCls ( cls ) ; } else { this . removeCls ( cls ) ; } this . messageElement . setHtml ( newMessage ) ; }<CODESPLIT>0.1538613736629486<CODESPLIT>0.13533885776996613

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/hbouvier/node-tts/blob/6b49053bb7f667681d526dc21d5d6b71f3bf644d/swagger-ui/lib/shred.bundle.js#L1067-L1130<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( request , options ) { request . log . debug ( "Processing request options .." ) ; // We'll use `request.emitter` to manage the `on` event handlers. request . emitter = ( new Emitter ) ; request . agent = options . agent ; // Set up the handlers ... if ( options . on ) { for ( var key in options . on ) { if ( options . on . hasOwnProperty ( key ) ) { request . emitter . on ( key , options . on [ key ] ) ; } } } // Make sure we were give a URL or a host if ( ! options . url && ! options . host ) { request . emitter . emit ( "request_error" , new Error ( "No url or url options (host, port, etc.)" ) ) ; return ; } // Allow for the [use of a proxy](http://www.jmarshall.com/easy/http/#proxies). if ( options . url ) { if ( options . proxy ) { request . url = options . proxy ; request . path = options . url ; } else { request . url = options . url ; } } // Set the remaining options. request . query = options . query || options . parameters || request . query ; request . method = options . method ; request . setHeader ( "user-agent" , options . agent || "Shred" ) ; request . setHeaders ( options . headers ) ; if ( request . cookieJar ) { var cookies = request . cookieJar . getCookies ( CookieAccessInfo ( request . host , request . path ) ) ; if ( cookies . length ) { var cookieString = request . getHeader ( 'cookie' ) || '' ; for ( var cookieIndex = 0 ; cookieIndex < cookies . length ; ++ cookieIndex ) { if ( cookieString . length && cookieString [ cookieString . length - 1 ] != ';' ) { cookieString += ';' ; } cookieString += cookies [ cookieIndex ] . name + '=' + cookies [ cookieIndex ] . value + ';' ; } request . setHeader ( "cookie" , cookieString ) ; } } // The content entity can be set either using the `body` or `content` attributes. if ( options . body || options . content ) { request . content = options . body || options . content ; } request . timeout = options . timeout ; }<CODESPLIT>0.16323189437389374<CODESPLIT>0.12927457690238953

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/johnnycopperstone/led-me-know/blob/ece9bfed5e4ed4de1ad3c31def1aea59c7a72023/lib/led-me-know.js#L38-L50<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( strip ) { if ( ! strip ) { console . log ( messagingTexts . noStrip ) ; } if ( ! ( strip instanceof pixel . Strip ) ) { console . log ( messagingTexts . wrongStrip ) ; } pattern . reset ( strip , interval ) ; interval = pattern . domino ( strip , 'white' ) ; }<CODESPLIT>0.16035762429237366<CODESPLIT>0.1499457210302353

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/zdfs/grunt-datadriver/blob/8c08f6dfe10a66c4b02a9a4fe42d4f64cb72354e/tasks/datadriver.js#L274-L283<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( callback ) { grunt . log . debug ( 'run mocha tests' ) ; /**                  * save session ID                  */ sessionID = GLOBAL . browser . requestHandler . sessionID ; mocha . run ( next ( callback ) ) ; }<CODESPLIT>0.1729489415884018<CODESPLIT>0.13622695207595825

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/FormidableLabs/rowdy/blob/5cbb8cf0f2896320a191cbc0541b7e3ac9b8525d/lib/server.js#L63-L74<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( data ) { data = ( data || "" ) . toString ( ) . trim ( ) ; _ . any ( SEL_LOG_COLORS , function ( val , key ) { if ( data . indexOf ( key ) > NOT_FOUND ) { data = data . split ( key ) . join ( key [ val ] ) ; return true ; } } ) ; return data ; }<CODESPLIT>0.1651153564453125<CODESPLIT>0.11954864114522934

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/sendanor/nor-api/blob/50c88c6a606443e89f978a75057902a65d8312bd/src/Router.js#L13-L74<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function _resolve ( routes , path , req , res ) { return Q . fcall ( function ( ) { path = path || [ ] ; var obj = routes ; // Resolve promises first if ( IS . obj ( obj ) && IS . fun ( obj . then ) ) { var p = obj . then ( function ( ret ) { return _resolve ( ret , path , req , res ) ; } ) ; return p ; } // Resolve functions first if ( IS . fun ( obj ) ) { var p2 = Q . when ( obj ( req , res ) ) . then ( function ( ret ) { return _resolve ( ret , path , req , res ) ; } ) ; return p2 ; } // If the resource is undefined, return flags.notFound (resulting to a HTTP error 404). if ( obj === undefined ) { return flags . notFound ; } // If path is at the end, then return the current resource. if ( path . length === 0 ) { return obj ; } // Handle arrays if ( IS . array ( obj ) ) { var k = path [ 0 ] , n = parseInt ( path . shift ( ) , 10 ) ; if ( k === "length" ) { return _resolve ( obj . length , path . shift ( ) , req , res ) ; } if ( k !== "" + n ) { return Q . fcall ( function ( ) { throw new errors . HTTPError ( { 'code' : 400 , 'desc' : 'Bad Request' } ) ; } ) ; } return _resolve ( obj [ n ] , path . shift ( ) , req , res ) ; } // Handle objects if ( IS . obj ( obj ) ) { var k2 = path [ 0 ] ; if ( obj [ k2 ] === undefined ) { return flags . notFound ; } if ( ! obj . hasOwnProperty ( k2 ) ) { return Q . fcall ( function ( ) { throw new errors . HTTPError ( { 'code' : 403 , 'desc' : 'Forbidden' } ) ; } ) ; } return _resolve ( obj [ path . shift ( ) ] , path , req , res ) ; } // Returns notFound because we still have keys in the path but nowhere to go. return flags . notFound ; } ) ; }<CODESPLIT>0.15622501075267792<CODESPLIT>0.15534162521362305

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/shepherdwind/velocity.js/blob/1fa2b459d1fff5c897a0671ed9797c5603505d88/src/compile/blocks.js#L144-L183<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( str , local , contextId ) { if ( ! local ) { if ( utils . isArray ( str ) ) { return this . _render ( str ) ; } else { return this . evalStr ( str ) ; } } else { var asts = [ ] ; var parse = Velocity . parse ; contextId = contextId || ( 'eval:' + utils . guid ( ) ) ; if ( utils . isArray ( str ) ) { asts = str ; } else if ( parse ) { asts = parse ( str ) ; } if ( asts . length ) { this . local [ contextId ] = local ; var ret = this . _render ( asts , contextId ) ; this . local [ contextId ] = { } ; this . conditions . shift ( ) ; this . condition = this . conditions [ 0 ] || '' ; return ret ; } } }<CODESPLIT>0.14907227456569672<CODESPLIT>0.1539192497730255

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/tstachl/desk.js/blob/b339196cce68dbbc79d3075f2ebe82372972f4f5/lib/mixins/search.js#L20-L27<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function search ( parent , baseUrl , callback ) { var resource = new ( getResource ( 'page' ) ) ( parent , { _links : { self : { href : baseUrl , 'class' : 'page' } } } ) ; if ( typeof callback == 'function' ) return resource . exec ( callback ) ; return resource ; }<CODESPLIT>0.13618957996368408<CODESPLIT>0.15539665520191193

1<CODESPLIT>https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/transaction.js#L94-L290<CODESPLIT>https://github.com/localnerve/html-snapshots/blob/63e829b234a8fa1399da1f7347a7fb3463e862a8/lib/input-generators/index.js#L23-L47<CODESPLIT>Instantiate the httpTransaction service @param { Object } services The services to inject @param { Number } [ services . TIMEOUT = 30000 ] A number indicating how many ms the transaction should take to complete before being cancelled . @param { Object } [ services . TRANSACTIONS = {} ] A hash of every current transactions @param { Function } services . time A timing function @param { Object } services . delay A delaying service @param { Function } [ services . log ] A logging function @param { Function } [ services . uniqueId ] A function returning unique identifiers @return { Promise<Function > } A promise of the httpTransaction function @example import { initHTTPTransaction } from swagger - http - router ;<CODESPLIT>function ( input ) { var result = { run : function ( ) { return [ ] ; } , __null : true } , hasInput ; if ( input ) { input = ( "" + input ) . replace ( " " , "" ) . toLowerCase ( ) ; hasInput = input && input . charAt ( 0 ) !== '_' && input !== "index" ; } try { if ( hasInput ) { result = require ( "./" + input ) ; } } catch ( e ) { console . error ( "Input generator load failed '" + input + "'" , e ) /* return the "null" generator on error */ } return result ; }<CODESPLIT>0.15160106122493744<CODESPLIT>0.14576973021030426

